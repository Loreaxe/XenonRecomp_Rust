pub fn sub_82CE73C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE73C0 size=68
    let mut pc: u32 = 0x82CE73C0;
    'dispatch: loop {
        match pc {
            0x82CE73C0 => {
    //   block [0x82CE73C0..0x82CE7404)
	// 82CE73C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE73C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE73C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE73CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE73D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE73D4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82CE73D8: 4BFFF381  bl 0x82ce6758
	ctx.lr = 0x82CE73DC;
	sub_82CE6758(ctx, base);
	// 82CE73DC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE73E0: 41980010  blt cr6, 0x82ce73f0
	if ctx.cr[6].lt {
	pc = 0x82CE73F0; continue 'dispatch;
	}
	// 82CE73E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CE73E8: B17F006C  sth r11, 0x6c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u16 ) };
	// 82CE73EC: B17F006E  sth r11, 0x6e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(110 as u32), ctx.r[11].u16 ) };
	// 82CE73F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CE73F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE73F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE73FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE7400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE7408 size=248
    let mut pc: u32 = 0x82CE7408;
    'dispatch: loop {
        match pc {
            0x82CE7408 => {
    //   block [0x82CE7408..0x82CE7500)
	// 82CE7408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE740C: 4BFC1FFD  bl 0x82ca9408
	ctx.lr = 0x82CE7410;
	sub_82CA93D0(ctx, base);
	// 82CE7410: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CE7414: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE7418: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE741C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CE7420: 485D2EE5  bl 0x832ba304
	ctx.lr = 0x82CE7424;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE7424: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE7428: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE742C: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CE7430: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CE7434: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7438: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE743C: 419A0010  beq cr6, 0x82ce744c
	if ctx.cr[6].eq {
	pc = 0x82CE744C; continue 'dispatch;
	}
	// 82CE7440: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7444: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE7448: 419A0018  beq cr6, 0x82ce7460
	if ctx.cr[6].eq {
	pc = 0x82CE7460; continue 'dispatch;
	}
	// 82CE744C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE7450: 485D2EA5  bl 0x832ba2f4
	ctx.lr = 0x82CE7454;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE7454: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7458: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CE745C: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE7460: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE7464: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7468: D3FE0070  stfs f31, 0x70(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82CE746C: 897E0038  lbz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7474: 419A0030  beq cr6, 0x82ce74a4
	if ctx.cr[6].eq {
	pc = 0x82CE74A4; continue 'dispatch;
	}
	// 82CE7478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE747C: 813E00C8  lwz r9, 0xc8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE7480: 1D4B0058  mulli r10, r11, 0x58
	ctx.r[10].s64 = ctx.r[11].s64 * 88;
	// 82CE7484: C01E0070  lfs f0, 0x70(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE7488: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82CE748C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE7490: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE7494: D00A0028  stfs f0, 0x28(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82CE7498: 893E0038  lbz r9, 0x38(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE749C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE74A0: 4198FFDC  blt cr6, 0x82ce747c
	if ctx.cr[6].lt {
	pc = 0x82CE747C; continue 'dispatch;
	}
	// 82CE74A4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE74A8: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE74AC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CE74B0: 419A0040  beq cr6, 0x82ce74f0
	if ctx.cr[6].eq {
	pc = 0x82CE74F0; continue 'dispatch;
	}
	// 82CE74B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE74B8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE74BC: 409A0034  bne cr6, 0x82ce74f0
	if !ctx.cr[6].eq {
	pc = 0x82CE74F0; continue 'dispatch;
	}
	// 82CE74C0: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE74C4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE74C8: 40820028  bne 0x82ce74f0
	if !ctx.cr[0].eq {
	pc = 0x82CE74F0; continue 'dispatch;
	}
	// 82CE74CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE74D0: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE74D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE74D8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE74DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE74E0: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE74E4: 485D2E51  bl 0x832ba334
	ctx.lr = 0x82CE74E8;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE74E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE74EC: 485D2E29  bl 0x832ba314
	ctx.lr = 0x82CE74F0;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE74F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE74F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CE74F8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CE74FC: 4BFC1F5C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE7500 size=344
    let mut pc: u32 = 0x82CE7500;
    'dispatch: loop {
        match pc {
            0x82CE7500 => {
    //   block [0x82CE7500..0x82CE7658)
	// 82CE7500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE7504: 4BFC1F05  bl 0x82ca9408
	ctx.lr = 0x82CE7508;
	sub_82CA93D0(ctx, base);
	// 82CE7508: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CE750C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE7510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE7514: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CE7518: 485D2DED  bl 0x832ba304
	ctx.lr = 0x82CE751C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE751C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE7520: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE7524: 3BCB7238  addi r30, r11, 0x7238
	ctx.r[30].s64 = ctx.r[11].s64 + 29240;
	// 82CE7528: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CE752C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7530: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7534: 419A0010  beq cr6, 0x82ce7544
	if ctx.cr[6].eq {
	pc = 0x82CE7544; continue 'dispatch;
	}
	// 82CE7538: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE753C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE7540: 419A0018  beq cr6, 0x82ce7558
	if ctx.cr[6].eq {
	pc = 0x82CE7558; continue 'dispatch;
	}
	// 82CE7544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE7548: 485D2DAD  bl 0x832ba2f4
	ctx.lr = 0x82CE754C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE754C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7550: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CE7554: 9B9E000C  stb r28, 0xc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE7558: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE755C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82CE7560: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CE7564: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7568: C82A0DE8  lfd f1, 0xde8(r10)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3560 as u32) ) };
	// 82CE756C: 4B516F3D  bl 0x821fe4a8
	ctx.lr = 0x82CE7570;
	sub_821FE4A8(ctx, base);
	// 82CE7570: 893F0038  lbz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7574: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CE7578: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82CE757C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CE7580: 419A007C  beq cr6, 0x82ce75fc
	if ctx.cr[6].eq {
	pc = 0x82CE75FC; continue 'dispatch;
	}
	// 82CE7584: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE7588: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82CE758C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CE7590: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CE7594: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE7598: 38CA0008  addi r6, r10, 8
	ctx.r[6].s64 = ctx.r[10].s64 + 8;
	// 82CE759C: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE75A0: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82CE75A4: 1D6A0058  mulli r11, r10, 0x58
	ctx.r[11].s64 = ctx.r[10].s64 * 88;
	// 82CE75A8: 8065003C  lwz r3, 0x3c(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CE75AC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CE75B0: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 82CE75B4: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CE75B8: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CE75BC: 54C91838  slwi r9, r6, 3
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CE75C0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CE75C4: 7CA9F8AE  lbzx r5, r9, r31
	ctx.r[5].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CE75C8: 808B0050  lwz r4, 0x50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CE75CC: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 82CE75D0: 990B000C  stb r8, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u8 ) };
	// 82CE75D4: 60830001  ori r3, r4, 1
	ctx.r[3].u64 = ctx.r[4].u64 | 1;
	// 82CE75D8: 54CA063E  clrlwi r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CE75DC: 98AB000D  stb r5, 0xd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(13 as u32), ctx.r[5].u8 ) };
	// 82CE75E0: 906B0050  stw r3, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82CE75E4: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CE75E8: FD20565E  fctidz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[10].f64.trunc() as i64 };
	// 82CE75EC: 7D2B3FAE  stfiwx f9, r11, r7
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82CE75F0: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE75F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE75F8: 4198FF98  blt cr6, 0x82ce7590
	if ctx.cr[6].lt {
	pc = 0x82CE7590; continue 'dispatch;
	}
	// 82CE75FC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7600: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE7604: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CE7608: 419A0040  beq cr6, 0x82ce7648
	if ctx.cr[6].eq {
	pc = 0x82CE7648; continue 'dispatch;
	}
	// 82CE760C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7610: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE7614: 409A0034  bne cr6, 0x82ce7648
	if !ctx.cr[6].eq {
	pc = 0x82CE7648; continue 'dispatch;
	}
	// 82CE7618: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE761C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7620: 40820028  bne 0x82ce7648
	if !ctx.cr[0].eq {
	pc = 0x82CE7648; continue 'dispatch;
	}
	// 82CE7624: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE7628: 8BFE000C  lbz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE762C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE7630: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE7634: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE7638: 997E000C  stb r11, 0xc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE763C: 485D2CF9  bl 0x832ba334
	ctx.lr = 0x82CE7640;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE7640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE7644: 485D2CD1  bl 0x832ba314
	ctx.lr = 0x82CE7648;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE7648: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE764C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CE7650: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CE7654: 4BFC1E04  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE7658 size=324
    let mut pc: u32 = 0x82CE7658;
    'dispatch: loop {
        match pc {
            0x82CE7658 => {
    //   block [0x82CE7658..0x82CE779C)
	// 82CE7658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE765C: 4BFC1DAD  bl 0x82ca9408
	ctx.lr = 0x82CE7660;
	sub_82CA93D0(ctx, base);
	// 82CE7660: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CE7664: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE7668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE766C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CE7670: 485D2C95  bl 0x832ba304
	ctx.lr = 0x82CE7674;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE7674: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE7678: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE767C: 3BCB7238  addi r30, r11, 0x7238
	ctx.r[30].s64 = ctx.r[11].s64 + 29240;
	// 82CE7680: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CE7684: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7688: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE768C: 419A0010  beq cr6, 0x82ce769c
	if ctx.cr[6].eq {
	pc = 0x82CE769C; continue 'dispatch;
	}
	// 82CE7690: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7694: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE7698: 419A0018  beq cr6, 0x82ce76b0
	if ctx.cr[6].eq {
	pc = 0x82CE76B0; continue 'dispatch;
	}
	// 82CE769C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE76A0: 485D2C55  bl 0x832ba2f4
	ctx.lr = 0x82CE76A4;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE76A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE76A8: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CE76AC: 9B9E000C  stb r28, 0xc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE76B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE76B4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE76B8: D3FF0074  stfs f31, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82CE76BC: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE76C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE76C4: 419A007C  beq cr6, 0x82ce7740
	if ctx.cr[6].eq {
	pc = 0x82CE7740; continue 'dispatch;
	}
	// 82CE76C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE76CC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82CE76D0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CE76D4: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CE76D8: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE76DC: 38CA0008  addi r6, r10, 8
	ctx.r[6].s64 = ctx.r[10].s64 + 8;
	// 82CE76E0: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE76E4: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82CE76E8: 1D6A0058  mulli r11, r10, 0x58
	ctx.r[11].s64 = ctx.r[10].s64 * 88;
	// 82CE76EC: 8065003C  lwz r3, 0x3c(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CE76F0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CE76F4: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 82CE76F8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CE76FC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CE7700: 54C91838  slwi r9, r6, 3
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CE7704: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CE7708: 7CA9F8AE  lbzx r5, r9, r31
	ctx.r[5].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CE770C: 808B0050  lwz r4, 0x50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CE7710: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 82CE7714: 990B000C  stb r8, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u8 ) };
	// 82CE7718: 60830001  ori r3, r4, 1
	ctx.r[3].u64 = ctx.r[4].u64 | 1;
	// 82CE771C: 54CA063E  clrlwi r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CE7720: 98AB000D  stb r5, 0xd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(13 as u32), ctx.r[5].u8 ) };
	// 82CE7724: 906B0050  stw r3, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82CE7728: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CE772C: FD20565E  fctidz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[10].f64.trunc() as i64 };
	// 82CE7730: 7D2B3FAE  stfiwx f9, r11, r7
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82CE7734: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7738: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE773C: 4198FF98  blt cr6, 0x82ce76d4
	if ctx.cr[6].lt {
	pc = 0x82CE76D4; continue 'dispatch;
	}
	// 82CE7740: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7744: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE7748: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CE774C: 419A0040  beq cr6, 0x82ce778c
	if ctx.cr[6].eq {
	pc = 0x82CE778C; continue 'dispatch;
	}
	// 82CE7750: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7754: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE7758: 409A0034  bne cr6, 0x82ce778c
	if !ctx.cr[6].eq {
	pc = 0x82CE778C; continue 'dispatch;
	}
	// 82CE775C: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7760: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7764: 40820028  bne 0x82ce778c
	if !ctx.cr[0].eq {
	pc = 0x82CE778C; continue 'dispatch;
	}
	// 82CE7768: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE776C: 8BFE000C  lbz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE7770: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE7774: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE7778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE777C: 997E000C  stb r11, 0xc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE7780: 485D2BB5  bl 0x832ba334
	ctx.lr = 0x82CE7784;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE7784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE7788: 485D2B8D  bl 0x832ba314
	ctx.lr = 0x82CE778C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE778C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE7790: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CE7794: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CE7798: 4BFC1CC0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE77A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE77A0 size=480
    let mut pc: u32 = 0x82CE77A0;
    'dispatch: loop {
        match pc {
            0x82CE77A0 => {
    //   block [0x82CE77A0..0x82CE7980)
	// 82CE77A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE77A4: 4BFC1C55  bl 0x82ca93f8
	ctx.lr = 0x82CE77A8;
	sub_82CA93D0(ctx, base);
	// 82CE77A8: 3BE1FF60  addi r31, r1, -0xa0
	ctx.r[31].s64 = ctx.r[1].s64 + -160;
	// 82CE77AC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE77B0: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82CE77B4: 88690038  lbz r3, 0x38(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE77B8: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 82CE77BC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82CE77C0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CE77C4: 7D0A00D0  neg r8, r10
	ctx.r[8].s64 = -ctx.r[10].s64;
	// 82CE77C8: 550C0036  rlwinm r12, r8, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE77CC: 4BFC8E89  bl 0x82cb0654
	ctx.lr = 0x82CE77D0;
	sub_82CB0654(ctx, base);
	// 82CE77D0: 80E10000  lwz r7, 0(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE77D4: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82CE77D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CE77DC: 7CE1616E  stwux r7, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[1].u32 = ea;
	// 82CE77E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CE77E4: 419A016C  beq cr6, 0x82ce7950
	if ctx.cr[6].eq {
	pc = 0x82CE7950; continue 'dispatch;
	}
	// 82CE77E8: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82CE77EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CE77F0: 39490040  addi r10, r9, 0x40
	ctx.r[10].s64 = ctx.r[9].s64 + 64;
	// 82CE77F4: 39040004  addi r8, r4, 4
	ctx.r[8].s64 = ctx.r[4].s64 + 4;
	// 82CE77F8: 3B890114  addi r28, r9, 0x114
	ctx.r[28].s64 = ctx.r[9].s64 + 276;
	// 82CE77FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82CE7800: 3B200010  li r25, 0x10
	ctx.r[25].s64 = 16;
	// 82CE7804: 617EBB80  ori r30, r11, 0xbb80
	ctx.r[30].u64 = ctx.r[11].u64 | 48000;
	// 82CE7808: 80CAFFFC  lwz r6, -4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82CE780C: 3B400F80  li r26, 0xf80
	ctx.r[26].s64 = 3968;
	// 82CE7810: 816900CC  lwz r11, 0xcc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(204 as u32) ) } as u64;
	// 82CE7814: 7D6B31D6  mullw r11, r11, r6
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[6].s32 as i64);
	// 82CE7818: 5566402E  slwi r6, r11, 8
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CE781C: 7D66F396  divwu r11, r6, r30
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[30].u32;
	// 82CE7820: 38CB0010  addi r6, r11, 0x10
	ctx.r[6].s64 = ctx.r[11].s64 + 16;
	// 82CE7824: B0DC0000  sth r6, 0(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	// 82CE7828: 88CA0000  lbz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE782C: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 82CE7830: 419A0008  beq cr6, 0x82ce7838
	if ctx.cr[6].eq {
	pc = 0x82CE7838; continue 'dispatch;
	}
	// 82CE7834: 3B400780  li r26, 0x780
	ctx.r[26].s64 = 1920;
	// 82CE7838: 8BAA0001  lbz r29, 1(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CE783C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82CE7840: 409A000C  bne cr6, 0x82ce784c
	if !ctx.cr[6].eq {
	pc = 0x82CE784C; continue 'dispatch;
	}
	// 82CE7844: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82CE7848: 48000068  b 0x82ce78b0
	pc = 0x82CE78B0; continue 'dispatch;
	// 82CE784C: 396B007F  addi r11, r11, 0x7f
	ctx.r[11].s64 = ctx.r[11].s64 + 127;
	// 82CE7850: 556BC9FE  srwi r11, r11, 7
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(7);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CE7854: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 82CE7858: 557B3830  slwi r27, r11, 7
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82CE785C: 7CC65838  and r6, r6, r11
	ctx.r[6].u64 = ctx.r[6].u64 & ctx.r[11].u64;
	// 82CE7860: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CE7864: 419A0010  beq cr6, 0x82ce7874
	if ctx.cr[6].eq {
	pc = 0x82CE7874; continue 'dispatch;
	}
	// 82CE7868: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82CE786C: 20CB0020  subfic r6, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[6].s64 = (32 as i64) - ctx.r[11].s64;
	// 82CE7870: 7F0B3030  slw r11, r24, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[24].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 82CE7874: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CE7878: 4098000C  bge cr6, 0x82ce7884
	if !ctx.cr[6].lt {
	pc = 0x82CE7884; continue 'dispatch;
	}
	// 82CE787C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82CE7880: 48000010  b 0x82ce7890
	pc = 0x82CE7890; continue 'dispatch;
	// 82CE7884: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82CE7888: 40990008  ble cr6, 0x82ce7890
	if !ctx.cr[6].gt {
	pc = 0x82CE7890; continue 'dispatch;
	}
	// 82CE788C: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82CE7890: 55663830  slwi r6, r11, 7
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CE7894: 2B1D00FF  cmplwi cr6, r29, 0xff
	ctx.cr[6].compare_u32(ctx.r[29].u32, 255 as u32, &mut ctx.xer);
	// 82CE7898: 7CC6DA14  add r6, r6, r27
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[27].u64;
	// 82CE789C: 419A000C  beq cr6, 0x82ce78a8
	if ctx.cr[6].eq {
	pc = 0x82CE78A8; continue 'dispatch;
	}
	// 82CE78A0: 57BD3830  slwi r29, r29, 7
	ctx.r[29].u32 = ctx.r[29].u32.wrapping_shl(7);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82CE78A4: 7CDD3214  add r6, r29, r6
	ctx.r[6].u64 = ctx.r[29].u64 + ctx.r[6].u64;
	// 82CE78A8: 7F06D040  cmplw cr6, r6, r26
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82CE78AC: 40990008  ble cr6, 0x82ce78b4
	if !ctx.cr[6].gt {
	pc = 0x82CE78B4; continue 'dispatch;
	}
	// 82CE78B0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82CE78B4: 83AAFFFC  lwz r29, -4(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82CE78B8: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82CE78BC: 3B9C0002  addi r28, r28, 2
	ctx.r[28].s64 = ctx.r[28].s64 + 2;
	// 82CE78C0: 93A8FFFC  stw r29, -4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-4 as u32), ctx.r[29].u32 ) };
	// 82CE78C4: 8BAA0000  lbz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE78C8: 90C80000  stw r6, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82CE78CC: 99680005  stb r11, 5(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(5 as u32), ctx.r[11].u8 ) };
	// 82CE78D0: 9BA80004  stb r29, 4(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[29].u8 ) };
	// 82CE78D4: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 82CE78D8: 816900C8  lwz r11, 0xc8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE78DC: 7CC75A14  add r6, r7, r11
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82CE78E0: 89690108  lbz r11, 0x108(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CE78E4: 91660054  stw r11, 0x54(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82CE78E8: C0090074  lfs f0, 0x74(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE78EC: 83AAFFFC  lwz r29, -4(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82CE78F0: FBBF0050  std r29, 0x50(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82CE78F4: C9BF0050  lfd f13, 0x50(r31)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	// 82CE78F8: 816900C8  lwz r11, 0xc8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE78FC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CE7900: 88CA0000  lbz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE7904: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82CE7908: 98CB000D  stb r6, 0xd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(13 as u32), ctx.r[6].u8 ) };
	// 82CE790C: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CE7910: 83AB0050  lwz r29, 0x50(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CE7914: 63BD0001  ori r29, r29, 1
	ctx.r[29].u64 = ctx.r[29].u64 | 1;
	// 82CE7918: 9B0B000C  stb r24, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[24].u8 ) };
	// 82CE791C: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CE7920: 93AB0050  stw r29, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82CE7924: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CE7928: FD20565E  fctidz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[10].f64.trunc() as i64 };
	// 82CE792C: 7D2BCFAE  stfiwx f9, r11, r25
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), tmp.u32) };
	// 82CE7930: 816900C8  lwz r11, 0xc8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE7934: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82CE7938: 80CB0050  lwz r6, 0x50(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CE793C: 60C60002  ori r6, r6, 2
	ctx.r[6].u64 = ctx.r[6].u64 | 2;
	// 82CE7940: 38E70058  addi r7, r7, 0x58
	ctx.r[7].s64 = ctx.r[7].s64 + 88;
	// 82CE7944: 93CB0020  stw r30, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82CE7948: 90CB0050  stw r6, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 82CE794C: 4082FEBC  bne 0x82ce7808
	if !ctx.cr[0].eq {
	pc = 0x82CE7808; continue 'dispatch;
	}
	// 82CE7950: 89690108  lbz r11, 0x108(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CE7954: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CE7958: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE795C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE7960: 419A0008  beq cr6, 0x82ce7968
	if ctx.cr[6].eq {
	pc = 0x82CE7968; continue 'dispatch;
	}
	// 82CE7964: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82CE7968: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CE796C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CE7970: 38C900B8  addi r6, r9, 0xb8
	ctx.r[6].s64 = ctx.r[9].s64 + 184;
	// 82CE7974: 4BFF2265  bl 0x82cd9bd8
	ctx.lr = 0x82CE7978;
	sub_82CD9BD8(ctx, base);
	// 82CE7978: 383F00A0  addi r1, r31, 0xa0
	ctx.r[1].s64 = ctx.r[31].s64 + 160;
	// 82CE797C: 4BFC1ACC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE7980 size=256
    let mut pc: u32 = 0x82CE7980;
    'dispatch: loop {
        match pc {
            0x82CE7980 => {
    //   block [0x82CE7980..0x82CE7A80)
	// 82CE7980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE7984: 4BFC1A85  bl 0x82ca9408
	ctx.lr = 0x82CE7988;
	sub_82CA93D0(ctx, base);
	// 82CE7988: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE798C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE7990: 3BFD0128  addi r31, r29, 0x128
	ctx.r[31].s64 = ctx.r[29].s64 + 296;
	// 82CE7994: 485D2971  bl 0x832ba304
	ctx.lr = 0x82CE7998;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE7998: 817D012C  lwz r11, 0x12c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(300 as u32) ) } as u64;
	// 82CE799C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE79A0: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE79A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE79A8: 419A0010  beq cr6, 0x82ce79b8
	if ctx.cr[6].eq {
	pc = 0x82CE79B8; continue 'dispatch;
	}
	// 82CE79AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE79B0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE79B4: 419A0014  beq cr6, 0x82ce79c8
	if ctx.cr[6].eq {
	pc = 0x82CE79C8; continue 'dispatch;
	}
	// 82CE79B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE79BC: 485D2939  bl 0x832ba2f4
	ctx.lr = 0x82CE79C0;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE79C0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE79C4: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE79C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE79CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE79D0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE79D4: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE79D8: 4BFF2529  bl 0x82cd9f00
	ctx.lr = 0x82CE79DC;
	sub_82CD9F00(ctx, base);
	// 82CE79DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82CE79E0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE79E4: 419A0044  beq cr6, 0x82ce7a28
	if ctx.cr[6].eq {
	pc = 0x82CE7A28; continue 'dispatch;
	}
	// 82CE79E8: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE79EC: 4BFF2E75  bl 0x82cda860
	ctx.lr = 0x82CE79F0;
	sub_82CDA860(ctx, base);
	// 82CE79F0: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE79F4: 4BFF2F05  bl 0x82cda8f8
	ctx.lr = 0x82CE79F8;
	sub_82CDA8F8(ctx, base);
	// 82CE79F8: 897D0038  lbz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE79FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7A00: 419A0028  beq cr6, 0x82ce7a28
	if ctx.cr[6].eq {
	pc = 0x82CE7A28; continue 'dispatch;
	}
	// 82CE7A04: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82CE7A08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CE7A0C: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7A10: 4BFF2A99  bl 0x82cda4a8
	ctx.lr = 0x82CE7A14;
	sub_82CDA4A8(ctx, base);
	// 82CE7A14: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82CE7A18: 895D0038  lbz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7A1C: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE7A20: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE7A24: 4198FFE4  blt cr6, 0x82ce7a08
	if ctx.cr[6].lt {
	pc = 0x82CE7A08; continue 'dispatch;
	}
	// 82CE7A28: 9B9D0124  stb r28, 0x124(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(292 as u32), ctx.r[28].u8 ) };
	// 82CE7A2C: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE7A30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7A34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7A38: 419A0038  beq cr6, 0x82ce7a70
	if ctx.cr[6].eq {
	pc = 0x82CE7A70; continue 'dispatch;
	}
	// 82CE7A3C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7A40: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE7A44: 409A002C  bne cr6, 0x82ce7a70
	if !ctx.cr[6].eq {
	pc = 0x82CE7A70; continue 'dispatch;
	}
	// 82CE7A48: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7A4C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7A50: 40820020  bne 0x82ce7a70
	if !ctx.cr[0].eq {
	pc = 0x82CE7A70; continue 'dispatch;
	}
	// 82CE7A54: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE7A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE7A5C: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE7A60: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82CE7A64: 485D28D1  bl 0x832ba334
	ctx.lr = 0x82CE7A68;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE7A68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE7A6C: 485D28A9  bl 0x832ba314
	ctx.lr = 0x82CE7A70;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE7A70: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 82CE7A74: 4BFFE855  bl 0x82ce62c8
	ctx.lr = 0x82CE7A78;
	sub_82CE62C8(ctx, base);
	// 82CE7A78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CE7A7C: 4BFC19DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE7A80 size=336
    let mut pc: u32 = 0x82CE7A80;
    'dispatch: loop {
        match pc {
            0x82CE7A80 => {
    //   block [0x82CE7A80..0x82CE7BD0)
	// 82CE7A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE7A84: 4BFC1979  bl 0x82ca93fc
	ctx.lr = 0x82CE7A88;
	sub_82CA93D0(ctx, base);
	// 82CE7A88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE7A8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE7A90: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82CE7A94: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82CE7A98: 3BDD0128  addi r30, r29, 0x128
	ctx.r[30].s64 = ctx.r[29].s64 + 296;
	// 82CE7A9C: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82CE7AA0: 485D2865  bl 0x832ba304
	ctx.lr = 0x82CE7AA4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE7AA4: 817D012C  lwz r11, 0x12c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(300 as u32) ) } as u64;
	// 82CE7AA8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE7AAC: 7DBF6B78  mr r31, r13
	ctx.r[31].u64 = ctx.r[13].u64;
	// 82CE7AB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7AB4: 419A0010  beq cr6, 0x82ce7ac4
	if ctx.cr[6].eq {
	pc = 0x82CE7AC4; continue 'dispatch;
	}
	// 82CE7AB8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7ABC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE7AC0: 419A0014  beq cr6, 0x82ce7ad4
	if ctx.cr[6].eq {
	pc = 0x82CE7AD4; continue 'dispatch;
	}
	// 82CE7AC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE7AC8: 485D282D  bl 0x832ba2f4
	ctx.lr = 0x82CE7ACC;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE7ACC: 9B9E000C  stb r28, 0xc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE7AD0: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82CE7AD4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7AD8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE7ADC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7AE0: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7AE4: 4BFF2EDD  bl 0x82cda9c0
	ctx.lr = 0x82CE7AE8;
	sub_82CDA9C0(ctx, base);
	// 82CE7AE8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE7AEC: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82CE7AF0: 409A0020  bne cr6, 0x82ce7b10
	if !ctx.cr[6].eq {
	pc = 0x82CE7B10; continue 'dispatch;
	}
	// 82CE7AF4: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7AF8: 4BFF2D69  bl 0x82cda860
	ctx.lr = 0x82CE7AFC;
	sub_82CDA860(ctx, base);
	// 82CE7AFC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82CE7B00: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82CE7B04: 4198007C  blt cr6, 0x82ce7b80
	if ctx.cr[6].lt {
	pc = 0x82CE7B80; continue 'dispatch;
	}
	// 82CE7B08: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7B0C: 4BFF2DED  bl 0x82cda8f8
	ctx.lr = 0x82CE7B10;
	sub_82CDA8F8(ctx, base);
	// 82CE7B10: 897D0038  lbz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7B18: 419A0054  beq cr6, 0x82ce7b6c
	if ctx.cr[6].eq {
	pc = 0x82CE7B6C; continue 'dispatch;
	}
	// 82CE7B1C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82CE7B20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CE7B24: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7B28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE7B2C: 4BFF2B8D  bl 0x82cda6b8
	ctx.lr = 0x82CE7B30;
	sub_82CDA6B8(ctx, base);
	// 82CE7B30: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82CE7B34: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82CE7B38: 41980034  blt cr6, 0x82ce7b6c
	if ctx.cr[6].lt {
	pc = 0x82CE7B6C; continue 'dispatch;
	}
	// 82CE7B3C: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CE7B40: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82CE7B44: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CE7B48: 393F0001  addi r9, r31, 1
	ctx.r[9].s64 = ctx.r[31].s64 + 1;
	// 82CE7B4C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82CE7B50: 55473C30  rlwinm r7, r10, 7, 0x10, 0x18
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 82CE7B54: 553F063E  clrlwi r31, r9, 0x18
	ctx.r[31].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CE7B58: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82CE7B5C: B0EB0004  sth r7, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
	// 82CE7B60: 88DD0038  lbz r6, 0x38(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7B64: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CE7B68: 4198FFB8  blt cr6, 0x82ce7b20
	if ctx.cr[6].lt {
	pc = 0x82CE7B20; continue 'dispatch;
	}
	// 82CE7B6C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82CE7B70: 409A0010  bne cr6, 0x82ce7b80
	if !ctx.cr[6].eq {
	pc = 0x82CE7B80; continue 'dispatch;
	}
	// 82CE7B74: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7B78: 4BFF2F99  bl 0x82cdab10
	ctx.lr = 0x82CE7B7C;
	sub_82CDAB10(ctx, base);
	// 82CE7B7C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82CE7B80: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7B84: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE7B88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7B8C: 419A0038  beq cr6, 0x82ce7bc4
	if ctx.cr[6].eq {
	pc = 0x82CE7BC4; continue 'dispatch;
	}
	// 82CE7B90: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7B94: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE7B98: 409A002C  bne cr6, 0x82ce7bc4
	if !ctx.cr[6].eq {
	pc = 0x82CE7BC4; continue 'dispatch;
	}
	// 82CE7B9C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7BA0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7BA4: 40820020  bne 0x82ce7bc4
	if !ctx.cr[0].eq {
	pc = 0x82CE7BC4; continue 'dispatch;
	}
	// 82CE7BA8: 8BFE000C  lbz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE7BAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE7BB0: 933E0008  stw r25, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82CE7BB4: 9B3E000C  stb r25, 0xc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[25].u8 ) };
	// 82CE7BB8: 485D277D  bl 0x832ba334
	ctx.lr = 0x82CE7BBC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE7BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE7BC0: 485D2755  bl 0x832ba314
	ctx.lr = 0x82CE7BC4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE7BC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82CE7BC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82CE7BCC: 4BFC1880  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE7BD0 size=216
    let mut pc: u32 = 0x82CE7BD0;
    'dispatch: loop {
        match pc {
            0x82CE7BD0 => {
    //   block [0x82CE7BD0..0x82CE7CA8)
	// 82CE7BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE7BD4: 4BFC1831  bl 0x82ca9404
	ctx.lr = 0x82CE7BD8;
	sub_82CA93D0(ctx, base);
	// 82CE7BD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE7BDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE7BE0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82CE7BE4: 897D0124  lbz r11, 0x124(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(292 as u32) ) } as u64;
	// 82CE7BE8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CE7BEC: 409A0014  bne cr6, 0x82ce7c00
	if !ctx.cr[6].eq {
	pc = 0x82CE7C00; continue 'dispatch;
	}
	// 82CE7BF0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82CE7BF4: 60634001  ori r3, r3, 0x4001
	ctx.r[3].u64 = ctx.r[3].u64 | 16385;
	// 82CE7BF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CE7BFC: 4BFC1858  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82CE7C00: 3BFD0128  addi r31, r29, 0x128
	ctx.r[31].s64 = ctx.r[29].s64 + 296;
	// 82CE7C04: 485D2701  bl 0x832ba304
	ctx.lr = 0x82CE7C08;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE7C08: 817D012C  lwz r11, 0x12c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(300 as u32) ) } as u64;
	// 82CE7C0C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE7C10: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE7C14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7C18: 419A0010  beq cr6, 0x82ce7c28
	if ctx.cr[6].eq {
	pc = 0x82CE7C28; continue 'dispatch;
	}
	// 82CE7C1C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7C20: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE7C24: 419A0014  beq cr6, 0x82ce7c38
	if ctx.cr[6].eq {
	pc = 0x82CE7C38; continue 'dispatch;
	}
	// 82CE7C28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE7C2C: 485D26C9  bl 0x832ba2f4
	ctx.lr = 0x82CE7C30;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE7C30: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE7C34: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE7C38: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7C3C: 387D0078  addi r3, r29, 0x78
	ctx.r[3].s64 = ctx.r[29].s64 + 120;
	// 82CE7C40: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 82CE7C44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE7C48: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82CE7C4C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7C50: 4BFC1831  bl 0x82ca9480
	ctx.lr = 0x82CE7C54;
	sub_82CA9480(ctx, base);
	// 82CE7C54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7C58: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE7C5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7C60: 419A003C  beq cr6, 0x82ce7c9c
	if ctx.cr[6].eq {
	pc = 0x82CE7C9C; continue 'dispatch;
	}
	// 82CE7C64: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7C68: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE7C6C: 409A0030  bne cr6, 0x82ce7c9c
	if !ctx.cr[6].eq {
	pc = 0x82CE7C9C; continue 'dispatch;
	}
	// 82CE7C70: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7C74: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7C78: 40820024  bne 0x82ce7c9c
	if !ctx.cr[0].eq {
	pc = 0x82CE7C9C; continue 'dispatch;
	}
	// 82CE7C7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE7C80: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE7C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE7C88: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE7C8C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82CE7C90: 485D26A5  bl 0x832ba334
	ctx.lr = 0x82CE7C94;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE7C94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE7C98: 485D267D  bl 0x832ba314
	ctx.lr = 0x82CE7C9C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE7C9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE7CA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CE7CA4: 4BFC17B0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CA8 size=8
    let mut pc: u32 = 0x82CE7CA8;
    'dispatch: loop {
        match pc {
            0x82CE7CA8 => {
    //   block [0x82CE7CA8..0x82CE7CB0)
	// 82CE7CA8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE7CAC: 4BFFF75C  b 0x82ce7408
	sub_82CE7408(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CB0 size=8
    let mut pc: u32 = 0x82CE7CB0;
    'dispatch: loop {
        match pc {
            0x82CE7CB0 => {
    //   block [0x82CE7CB0..0x82CE7CB8)
	// 82CE7CB0: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82CE7CB4: 48001F1C  b 0x82ce9bd0
	sub_82CE9BD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CB8 size=8
    let mut pc: u32 = 0x82CE7CB8;
    'dispatch: loop {
        match pc {
            0x82CE7CB8 => {
    //   block [0x82CE7CB8..0x82CE7CC0)
	// 82CE7CB8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE7CBC: 4BFFFCC4  b 0x82ce7980
	sub_82CE7980(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CC0 size=8
    let mut pc: u32 = 0x82CE7CC0;
    'dispatch: loop {
        match pc {
            0x82CE7CC0 => {
    //   block [0x82CE7CC0..0x82CE7CC8)
	// 82CE7CC0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE7CC4: 4BFFF654  b 0x82ce7318
	sub_82CE7318(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CC8 size=8
    let mut pc: u32 = 0x82CE7CC8;
    'dispatch: loop {
        match pc {
            0x82CE7CC8 => {
    //   block [0x82CE7CC8..0x82CE7CD0)
	// 82CE7CC8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE7CCC: 4BFFF834  b 0x82ce7500
	sub_82CE7500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CD0 size=8
    let mut pc: u32 = 0x82CE7CD0;
    'dispatch: loop {
        match pc {
            0x82CE7CD0 => {
    //   block [0x82CE7CD0..0x82CE7CD8)
	// 82CE7CD0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE7CD4: 4BFFF984  b 0x82ce7658
	sub_82CE7658(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CD8 size=8
    let mut pc: u32 = 0x82CE7CD8;
    'dispatch: loop {
        match pc {
            0x82CE7CD8 => {
    //   block [0x82CE7CD8..0x82CE7CE0)
	// 82CE7CD8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE7CDC: 48001D84  b 0x82ce9a60
	sub_82CE9A60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CE0 size=8
    let mut pc: u32 = 0x82CE7CE0;
    'dispatch: loop {
        match pc {
            0x82CE7CE0 => {
    //   block [0x82CE7CE0..0x82CE7CE8)
	// 82CE7CE0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE7CE4: 4BFFF6DC  b 0x82ce73c0
	sub_82CE73C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CE8 size=8
    let mut pc: u32 = 0x82CE7CE8;
    'dispatch: loop {
        match pc {
            0x82CE7CE8 => {
    //   block [0x82CE7CE8..0x82CE7CF0)
	// 82CE7CE8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE7CEC: 48001E1C  b 0x82ce9b08
	sub_82CE9B08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CF0 size=4
    let mut pc: u32 = 0x82CE7CF0;
    'dispatch: loop {
        match pc {
            0x82CE7CF0 => {
    //   block [0x82CE7CF0..0x82CE7CF4)
	// 82CE7CF0: 4BFFFC90  b 0x82ce7980
	sub_82CE7980(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE7CF8 size=40
    let mut pc: u32 = 0x82CE7CF8;
    'dispatch: loop {
        match pc {
            0x82CE7CF8 => {
    //   block [0x82CE7CF8..0x82CE7D20)
	// 82CE7CF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CE7CFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE7D00: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CE7D04: 892B000C  lbz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE7D08: 1D4A0078  mulli r10, r10, 0x78
	ctx.r[10].s64 = ctx.r[10].s64 * 120;
	// 82CE7D0C: 1D690058  mulli r11, r9, 0x58
	ctx.r[11].s64 = ctx.r[9].s64 * 88;
	// 82CE7D10: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CE7D14: 390B0138  addi r8, r11, 0x138
	ctx.r[8].s64 = ctx.r[11].s64 + 312;
	// 82CE7D18: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82CE7D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE7D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE7D20 size=2280
    let mut pc: u32 = 0x82CE7D20;
    'dispatch: loop {
        match pc {
            0x82CE7D20 => {
    //   block [0x82CE7D20..0x82CE8608)
	// 82CE7D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE7D24: 4BFC16BD  bl 0x82ca93e0
	ctx.lr = 0x82CE7D28;
	sub_82CA93D0(ctx, base);
	// 82CE7D28: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE7D2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE7D30: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 82CE7D34: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82CE7D38: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 82CE7D3C: 897D0038  lbz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7D40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7D44: 419A004C  beq cr6, 0x82ce7d90
	if ctx.cr[6].eq {
	pc = 0x82CE7D90; continue 'dispatch;
	}
	// 82CE7D48: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 82CE7D4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE7D50: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7D54: 4BFF2315  bl 0x82cda068
	ctx.lr = 0x82CE7D58;
	sub_82CDA068(ctx, base);
	// 82CE7D58: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE7D5C: 419A0098  beq cr6, 0x82ce7df4
	if ctx.cr[6].eq {
	pc = 0x82CE7DF4; continue 'dispatch;
	}
	// 82CE7D60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE7D64: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7D68: 4BFF2369  bl 0x82cda0d0
	ctx.lr = 0x82CE7D6C;
	sub_82CDA0D0(ctx, base);
	// 82CE7D6C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE7D70: 409A0008  bne cr6, 0x82ce7d78
	if !ctx.cr[6].eq {
	pc = 0x82CE7D78; continue 'dispatch;
	}
	// 82CE7D74: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 82CE7D78: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82CE7D7C: 895D0038  lbz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7D80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE7D84: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82CE7D88: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE7D8C: 4198FFC0  blt cr6, 0x82ce7d4c
	if ctx.cr[6].lt {
	pc = 0x82CE7D4C; continue 'dispatch;
	}
	// 82CE7D90: 485D2575  bl 0x832ba304
	ctx.lr = 0x82CE7D94;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE7D94: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE7D98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE7D9C: 3AAB7238  addi r21, r11, 0x7238
	ctx.r[21].s64 = ctx.r[11].s64 + 29240;
	// 82CE7DA0: 7DBF6B78  mr r31, r13
	ctx.r[31].u64 = ctx.r[13].u64;
	// 82CE7DA4: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7DA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7DAC: 419A0010  beq cr6, 0x82ce7dbc
	if ctx.cr[6].eq {
	pc = 0x82CE7DBC; continue 'dispatch;
	}
	// 82CE7DB0: 81550008  lwz r10, 8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7DB4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE7DB8: 419A0018  beq cr6, 0x82ce7dd0
	if ctx.cr[6].eq {
	pc = 0x82CE7DD0; continue 'dispatch;
	}
	// 82CE7DBC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82CE7DC0: 485D2535  bl 0x832ba2f4
	ctx.lr = 0x82CE7DC4;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE7DC4: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7DC8: 93F50008  stw r31, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82CE7DCC: 9BD5000C  stb r30, 0xc(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 82CE7DD0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE7DD4: 3A7D0014  addi r19, r29, 0x14
	ctx.r[19].s64 = ctx.r[29].s64 + 20;
	// 82CE7DD8: 91750004  stw r11, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7DDC: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE7DE0: 7F135840  cmplw cr6, r19, r11
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE7DE4: 419A001C  beq cr6, 0x82ce7e00
	if ctx.cr[6].eq {
	pc = 0x82CE7E00; continue 'dispatch;
	}
	// 82CE7DE8: 81530008  lwz r10, 8(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7DEC: 7FCA5850  subf r30, r10, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CE7DF0: 48000014  b 0x82ce7e04
	pc = 0x82CE7E04; continue 'dispatch;
	// 82CE7DF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82CE7DF8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82CE7DFC: 4BFC1634  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
	// 82CE7E00: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 82CE7E04: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82CE7E08: 3A400004  li r18, 4
	ctx.r[18].s64 = 4;
	// 82CE7E0C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CE7E10: 419A036C  beq cr6, 0x82ce817c
	if ctx.cr[6].eq {
	pc = 0x82CE817C; continue 'dispatch;
	}
	// 82CE7E14: 817D0110  lwz r11, 0x110(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(272 as u32) ) } as u64;
	// 82CE7E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7E1C: 419A00F8  beq cr6, 0x82ce7f14
	if ctx.cr[6].eq {
	pc = 0x82CE7F14; continue 'dispatch;
	}
	// 82CE7E20: 815D00A8  lwz r10, 0xa8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(168 as u32) ) } as u64;
	// 82CE7E24: 813D010C  lwz r9, 0x10c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(268 as u32) ) } as u64;
	// 82CE7E28: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE7E2C: 419800E8  blt cr6, 0x82ce7f14
	if ctx.cr[6].lt {
	pc = 0x82CE7F14; continue 'dispatch;
	}
	// 82CE7E30: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82CE7E34: 409A000C  bne cr6, 0x82ce7e40
	if !ctx.cr[6].eq {
	pc = 0x82CE7E40; continue 'dispatch;
	}
	// 82CE7E38: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82CE7E3C: 4800000C  b 0x82ce7e48
	pc = 0x82CE7E48; continue 'dispatch;
	// 82CE7E40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82CE7E44: 917D0110  stw r11, 0x110(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82CE7E48: 917D0110  stw r11, 0x110(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82CE7E4C: 3BFD0128  addi r31, r29, 0x128
	ctx.r[31].s64 = ctx.r[29].s64 + 296;
	// 82CE7E50: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CE7E54: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE7E58: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE7E5C: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CE7E60: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CE7E64: 90FD010C  stw r7, 0x10c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(268 as u32), ctx.r[7].u32 ) };
	// 82CE7E68: 817D012C  lwz r11, 0x12c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(300 as u32) ) } as u64;
	// 82CE7E6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7E70: 419A0038  beq cr6, 0x82ce7ea8
	if ctx.cr[6].eq {
	pc = 0x82CE7EA8; continue 'dispatch;
	}
	// 82CE7E74: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7E78: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE7E7C: 409A002C  bne cr6, 0x82ce7ea8
	if !ctx.cr[6].eq {
	pc = 0x82CE7EA8; continue 'dispatch;
	}
	// 82CE7E80: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7E84: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7E88: 40820020  bne 0x82ce7ea8
	if !ctx.cr[0].eq {
	pc = 0x82CE7EA8; continue 'dispatch;
	}
	// 82CE7E8C: 8B9F000C  lbz r28, 0xc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE7E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE7E94: 9A9F000C  stb r20, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[20].u8 ) };
	// 82CE7E98: 929F0008  stw r20, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 82CE7E9C: 485D2499  bl 0x832ba334
	ctx.lr = 0x82CE7EA0;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE7EA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CE7EA4: 485D2471  bl 0x832ba314
	ctx.lr = 0x82CE7EA8;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE7EA8: 817D00B4  lwz r11, 0xb4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 82CE7EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7EB0: 419A0024  beq cr6, 0x82ce7ed4
	if ctx.cr[6].eq {
	pc = 0x82CE7ED4; continue 'dispatch;
	}
	// 82CE7EB4: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE7EB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82CE7EBC: 813E0024  lwz r9, 0x24(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CE7EC0: 92810060  stw r20, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[20].u32 ) };
	// 82CE7EC4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82CE7EC8: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82CE7ECC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82CE7ED0: 4E800421  bctrl
	ctx.lr = 0x82CE7ED4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE7ED4: 485D2431  bl 0x832ba304
	ctx.lr = 0x82CE7ED8;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE7ED8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7EDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE7EE0: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE7EE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7EE8: 419A0010  beq cr6, 0x82ce7ef8
	if ctx.cr[6].eq {
	pc = 0x82CE7EF8; continue 'dispatch;
	}
	// 82CE7EEC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7EF0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE7EF4: 419A0014  beq cr6, 0x82ce7f08
	if ctx.cr[6].eq {
	pc = 0x82CE7F08; continue 'dispatch;
	}
	// 82CE7EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE7EFC: 485D23F9  bl 0x832ba2f4
	ctx.lr = 0x82CE7F00;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE7F00: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE7F04: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE7F08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE7F0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE7F10: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE7F14: 817D0120  lwz r11, 0x120(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(288 as u32) ) } as u64;
	// 82CE7F18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE7F1C: 419A0048  beq cr6, 0x82ce7f64
	if ctx.cr[6].eq {
	pc = 0x82CE7F64; continue 'dispatch;
	}
	// 82CE7F20: 897D00C6  lbz r11, 0xc6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(198 as u32) ) } as u64;
	// 82CE7F24: 895D0038  lbz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7F28: 929D0120  stw r20, 0x120(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(288 as u32), ctx.r[20].u32 ) };
	// 82CE7F2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE7F30: 917D0110  stw r11, 0x110(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82CE7F34: 419A0030  beq cr6, 0x82ce7f64
	if ctx.cr[6].eq {
	pc = 0x82CE7F64; continue 'dispatch;
	}
	// 82CE7F38: 3BDD00BC  addi r30, r29, 0xbc
	ctx.r[30].s64 = ctx.r[29].s64 + 188;
	// 82CE7F3C: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 82CE7F40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82CE7F44: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7F48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE7F4C: 4BFF268D  bl 0x82cda5d8
	ctx.lr = 0x82CE7F50;
	sub_82CDA5D8(ctx, base);
	// 82CE7F50: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82CE7F54: 895D0038  lbz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7F58: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE7F5C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE7F60: 4198FFE0  blt cr6, 0x82ce7f40
	if ctx.cr[6].lt {
	pc = 0x82CE7F40; continue 'dispatch;
	}
	// 82CE7F64: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE7F68: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82CE7F6C: 419A0210  beq cr6, 0x82ce817c
	if ctx.cr[6].eq {
	pc = 0x82CE817C; continue 'dispatch;
	}
	// 82CE7F70: 81730008  lwz r11, 8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7F74: 7D4BD82E  lwzx r10, r11, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82CE7F78: 7F135040  cmplw cr6, r19, r10
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE7F7C: 7F4B5050  subf r26, r11, r10
	ctx.r[26].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CE7F80: 409A0008  bne cr6, 0x82ce7f88
	if !ctx.cr[6].eq {
	pc = 0x82CE7F88; continue 'dispatch;
	}
	// 82CE7F84: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	// 82CE7F88: 897B0074  lbz r11, 0x74(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(116 as u32) ) } as u64;
	// 82CE7F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7F90: 419A0078  beq cr6, 0x82ce8008
	if ctx.cr[6].eq {
	pc = 0x82CE8008; continue 'dispatch;
	}
	// 82CE7F94: 897D0038  lbz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7F98: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 82CE7F9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7FA0: 419A0054  beq cr6, 0x82ce7ff4
	if ctx.cr[6].eq {
	pc = 0x82CE7FF4; continue 'dispatch;
	}
	// 82CE7FA4: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 82CE7FA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE7FAC: 80BB0008  lwz r5, 8(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE7FB0: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7FB4: 4BFF2035  bl 0x82cd9fe8
	ctx.lr = 0x82CE7FB8;
	sub_82CD9FE8(ctx, base);
	// 82CE7FB8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE7FBC: 419A001C  beq cr6, 0x82ce7fd8
	if ctx.cr[6].eq {
	pc = 0x82CE7FD8; continue 'dispatch;
	}
	// 82CE7FC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE7FC4: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE7FC8: 4BFF2591  bl 0x82cda558
	ctx.lr = 0x82CE7FCC;
	sub_82CDA558(ctx, base);
	// 82CE7FCC: 546B0738  rlwinm r11, r3, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE7FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7FD4: 419A001C  beq cr6, 0x82ce7ff0
	if ctx.cr[6].eq {
	pc = 0x82CE7FF0; continue 'dispatch;
	}
	// 82CE7FD8: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82CE7FDC: 895D0038  lbz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE7FE0: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE7FE4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE7FE8: 4198FFC0  blt cr6, 0x82ce7fa8
	if ctx.cr[6].lt {
	pc = 0x82CE7FA8; continue 'dispatch;
	}
	// 82CE7FEC: 48000008  b 0x82ce7ff4
	pc = 0x82CE7FF4; continue 'dispatch;
	// 82CE7FF0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82CE7FF4: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82CE7FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE7FFC: 409A0010  bne cr6, 0x82ce800c
	if !ctx.cr[6].eq {
	pc = 0x82CE800C; continue 'dispatch;
	}
	// 82CE8000: 9A5B0074  stb r18, 0x74(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(116 as u32), ctx.r[18].u8 ) };
	// 82CE8004: 48000008  b 0x82ce800c
	pc = 0x82CE800C; continue 'dispatch;
	// 82CE8008: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82CE800C: 897B0074  lbz r11, 0x74(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(116 as u32) ) } as u64;
	// 82CE8010: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82CE8014: 409A015C  bne cr6, 0x82ce8170
	if !ctx.cr[6].eq {
	pc = 0x82CE8170; continue 'dispatch;
	}
	// 82CE8018: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82CE801C: 409A0020  bne cr6, 0x82ce803c
	if !ctx.cr[6].eq {
	pc = 0x82CE803C; continue 'dispatch;
	}
	// 82CE8020: 897D00AC  lbz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CE8024: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CE8028: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE802C: 419A0010  beq cr6, 0x82ce803c
	if ctx.cr[6].eq {
	pc = 0x82CE803C; continue 'dispatch;
	}
	// 82CE8030: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE8034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8038: 419A0138  beq cr6, 0x82ce8170
	if ctx.cr[6].eq {
	pc = 0x82CE8170; continue 'dispatch;
	}
	// 82CE803C: 81550004  lwz r10, 4(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8040: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CE8044: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CE8048: 419A0044  beq cr6, 0x82ce808c
	if ctx.cr[6].eq {
	pc = 0x82CE808C; continue 'dispatch;
	}
	// 82CE804C: 81550008  lwz r10, 8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8050: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE8054: 409A0038  bne cr6, 0x82ce808c
	if !ctx.cr[6].eq {
	pc = 0x82CE808C; continue 'dispatch;
	}
	// 82CE8058: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE805C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8060: 91750004  stw r11, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8064: 40820028  bne 0x82ce808c
	if !ctx.cr[0].eq {
	pc = 0x82CE808C; continue 'dispatch;
	}
	// 82CE8068: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 82CE806C: 8BF5000C  lbz r31, 0xc(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8070: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 82CE8074: 9975000C  stb r11, 0xc(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE8078: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82CE807C: 91550008  stw r10, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE8080: 485D22B5  bl 0x832ba334
	ctx.lr = 0x82CE8084;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE8084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8088: 485D228D  bl 0x832ba314
	ctx.lr = 0x82CE808C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE808C: 817D012C  lwz r11, 0x12c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(300 as u32) ) } as u64;
	// 82CE8090: 3BFD0128  addi r31, r29, 0x128
	ctx.r[31].s64 = ctx.r[29].s64 + 296;
	// 82CE8094: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE8098: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE809C: 419A0038  beq cr6, 0x82ce80d4
	if ctx.cr[6].eq {
	pc = 0x82CE80D4; continue 'dispatch;
	}
	// 82CE80A0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE80A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE80A8: 409A002C  bne cr6, 0x82ce80d4
	if !ctx.cr[6].eq {
	pc = 0x82CE80D4; continue 'dispatch;
	}
	// 82CE80AC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE80B0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE80B4: 40820020  bne 0x82ce80d4
	if !ctx.cr[0].eq {
	pc = 0x82CE80D4; continue 'dispatch;
	}
	// 82CE80B8: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE80BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE80C0: 9A9F000C  stb r20, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[20].u8 ) };
	// 82CE80C4: 929F0008  stw r20, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 82CE80C8: 485D226D  bl 0x832ba334
	ctx.lr = 0x82CE80CC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE80CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE80D0: 485D2245  bl 0x832ba314
	ctx.lr = 0x82CE80D4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE80D4: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE80D8: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 82CE80DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CE80E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82CE80E4: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82CE80E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE80EC: 4E800421  bctrl
	ctx.lr = 0x82CE80F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE80F0: 485D2215  bl 0x832ba304
	ctx.lr = 0x82CE80F4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE80F4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE80F8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE80FC: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE8100: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CE8104: 419A0010  beq cr6, 0x82ce8114
	if ctx.cr[6].eq {
	pc = 0x82CE8114; continue 'dispatch;
	}
	// 82CE8108: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE810C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE8110: 419A0014  beq cr6, 0x82ce8124
	if ctx.cr[6].eq {
	pc = 0x82CE8124; continue 'dispatch;
	}
	// 82CE8114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8118: 485D21DD  bl 0x832ba2f4
	ctx.lr = 0x82CE811C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE811C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE8120: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE8124: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8128: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE812C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8130: 485D21D5  bl 0x832ba304
	ctx.lr = 0x82CE8134;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE8134: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8138: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE813C: 7DBF6B78  mr r31, r13
	ctx.r[31].u64 = ctx.r[13].u64;
	// 82CE8140: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8144: 419A0010  beq cr6, 0x82ce8154
	if ctx.cr[6].eq {
	pc = 0x82CE8154; continue 'dispatch;
	}
	// 82CE8148: 81550008  lwz r10, 8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE814C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE8150: 419A0018  beq cr6, 0x82ce8168
	if ctx.cr[6].eq {
	pc = 0x82CE8168; continue 'dispatch;
	}
	// 82CE8154: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82CE8158: 485D219D  bl 0x832ba2f4
	ctx.lr = 0x82CE815C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE815C: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8160: 93F50008  stw r31, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82CE8164: 9BD5000C  stb r30, 0xc(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 82CE8168: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE816C: 91750004  stw r11, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8170: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 82CE8174: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82CE8178: 409AFDEC  bne cr6, 0x82ce7f64
	if !ctx.cr[6].eq {
	pc = 0x82CE7F64; continue 'dispatch;
	}
	// 82CE817C: 897D0124  lbz r11, 0x124(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(292 as u32) ) } as u64;
	// 82CE8180: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CE8184: 409A0014  bne cr6, 0x82ce8198
	if !ctx.cr[6].eq {
	pc = 0x82CE8198; continue 'dispatch;
	}
	// 82CE8188: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82CE818C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8190: 409A0008  bne cr6, 0x82ce8198
	if !ctx.cr[6].eq {
	pc = 0x82CE8198; continue 'dispatch;
	}
	// 82CE8194: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 82CE8198: 81550004  lwz r10, 4(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE819C: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CE81A0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CE81A4: 419A0044  beq cr6, 0x82ce81e8
	if ctx.cr[6].eq {
	pc = 0x82CE81E8; continue 'dispatch;
	}
	// 82CE81A8: 81550008  lwz r10, 8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE81AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE81B0: 409A0038  bne cr6, 0x82ce81e8
	if !ctx.cr[6].eq {
	pc = 0x82CE81E8; continue 'dispatch;
	}
	// 82CE81B4: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE81B8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE81BC: 91750004  stw r11, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE81C0: 40820028  bne 0x82ce81e8
	if !ctx.cr[0].eq {
	pc = 0x82CE81E8; continue 'dispatch;
	}
	// 82CE81C4: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 82CE81C8: 8BF5000C  lbz r31, 0xc(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE81CC: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 82CE81D0: 9975000C  stb r11, 0xc(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE81D4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82CE81D8: 91550008  stw r10, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE81DC: 485D2159  bl 0x832ba334
	ctx.lr = 0x82CE81E0;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE81E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE81E4: 485D2131  bl 0x832ba314
	ctx.lr = 0x82CE81E8;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE81E8: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 82CE81EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE81F0: 419A0360  beq cr6, 0x82ce8550
	if ctx.cr[6].eq {
	pc = 0x82CE8550; continue 'dispatch;
	}
	// 82CE81F4: 485D2111  bl 0x832ba304
	ctx.lr = 0x82CE81F8;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE81F8: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE81FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE8200: 7DBF6B78  mr r31, r13
	ctx.r[31].u64 = ctx.r[13].u64;
	// 82CE8204: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8208: 419A0010  beq cr6, 0x82ce8218
	if ctx.cr[6].eq {
	pc = 0x82CE8218; continue 'dispatch;
	}
	// 82CE820C: 81350008  lwz r9, 8(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8210: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE8214: 419A001C  beq cr6, 0x82ce8230
	if ctx.cr[6].eq {
	pc = 0x82CE8230; continue 'dispatch;
	}
	// 82CE8218: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82CE821C: 485D20D9  bl 0x832ba2f4
	ctx.lr = 0x82CE8220;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE8220: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82CE8224: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8228: 9BD5000C  stb r30, 0xc(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 82CE822C: 91350008  stw r9, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CE8230: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82CE8234: 91550004  stw r10, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CE8238: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE823C: 7F135840  cmplw cr6, r19, r11
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE8240: 419A0010  beq cr6, 0x82ce8250
	if ctx.cr[6].eq {
	pc = 0x82CE8250; continue 'dispatch;
	}
	// 82CE8244: 81130008  lwz r8, 8(r19)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8248: 7FE85850  subf r31, r8, r11
	ctx.r[31].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CE824C: 48000008  b 0x82ce8254
	pc = 0x82CE8254; continue 'dispatch;
	// 82CE8250: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 82CE8254: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CE8258: 419A02B4  beq cr6, 0x82ce850c
	if ctx.cr[6].eq {
	pc = 0x82CE850C; continue 'dispatch;
	}
	// 82CE825C: 3AC00003  li r22, 3
	ctx.r[22].s64 = 3;
	// 82CE8260: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE8264: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82CE8268: 419A029C  beq cr6, 0x82ce8504
	if ctx.cr[6].eq {
	pc = 0x82CE8504; continue 'dispatch;
	}
	// 82CE826C: 81730008  lwz r11, 8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8270: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CE8274: 7F135040  cmplw cr6, r19, r10
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE8278: 7EEB5050  subf r23, r11, r10
	ctx.r[23].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CE827C: 409A0008  bne cr6, 0x82ce8284
	if !ctx.cr[6].eq {
	pc = 0x82CE8284; continue 'dispatch;
	}
	// 82CE8280: 7E97A378  mr r23, r20
	ctx.r[23].u64 = ctx.r[20].u64;
	// 82CE8284: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82CE8288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE828C: 409A026C  bne cr6, 0x82ce84f8
	if !ctx.cr[6].eq {
	pc = 0x82CE84F8; continue 'dispatch;
	}
	// 82CE8290: 897D0038  lbz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8294: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82CE8298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE829C: 419A024C  beq cr6, 0x82ce84e8
	if ctx.cr[6].eq {
	pc = 0x82CE84E8; continue 'dispatch;
	}
	// 82CE82A0: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 82CE82A4: 897D0124  lbz r11, 0x124(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(292 as u32) ) } as u64;
	// 82CE82A8: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 82CE82AC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CE82B0: 409A000C  bne cr6, 0x82ce82bc
	if !ctx.cr[6].eq {
	pc = 0x82CE82BC; continue 'dispatch;
	}
	// 82CE82B4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82CE82B8: 4800001C  b 0x82ce82d4
	pc = 0x82CE82D4; continue 'dispatch;
	// 82CE82BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CE82C0: 419A0014  beq cr6, 0x82ce82d4
	if ctx.cr[6].eq {
	pc = 0x82CE82D4; continue 'dispatch;
	}
	// 82CE82C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CE82C8: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE82CC: 4BFF1E05  bl 0x82cda0d0
	ctx.lr = 0x82CE82D0;
	sub_82CDA0D0(ctx, base);
	// 82CE82D0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE82D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CE82D8: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE82DC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE82E0: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE82E4: 4BFF1C2D  bl 0x82cd9f10
	ctx.lr = 0x82CE82E8;
	sub_82CD9F10(ctx, base);
	// 82CE82E8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82CE82EC: 419A0050  beq cr6, 0x82ce833c
	if ctx.cr[6].eq {
	pc = 0x82CE833C; continue 'dispatch;
	}
	// 82CE82F0: 897D0124  lbz r11, 0x124(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(292 as u32) ) } as u64;
	// 82CE82F4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CE82F8: 409A002C  bne cr6, 0x82ce8324
	if !ctx.cr[6].eq {
	pc = 0x82CE8324; continue 'dispatch;
	}
	// 82CE82FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CE8300: 80DF001C  lwz r6, 0x1c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CE8304: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82CE8308: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE830C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8310: 4BFFEBD1  bl 0x82ce6ee0
	ctx.lr = 0x82CE8314;
	sub_82CE6EE0(ctx, base);
	// 82CE8314: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CE8318: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82CE831C: 5566CFBE  rlwinm r6, r11, 0x19, 0x1e, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 82CE8320: 48000010  b 0x82ce8330
	pc = 0x82CE8330; continue 'dispatch;
	// 82CE8324: 57CB7022  slwi r11, r30, 0xe
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(14);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CE8328: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 82CE832C: 38AB0020  addi r5, r11, 0x20
	ctx.r[5].s64 = ctx.r[11].s64 + 32;
	// 82CE8330: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CE8334: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8338: 4BFF2409  bl 0x82cda740
	ctx.lr = 0x82CE833C;
	sub_82CDA740(ctx, base);
	// 82CE833C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE8340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8344: 419A0144  beq cr6, 0x82ce8488
	if ctx.cr[6].eq {
	pc = 0x82CE8488; continue 'dispatch;
	}
	// 82CE8348: 929D00BC  stw r20, 0xbc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(188 as u32), ctx.r[20].u32 ) };
	// 82CE834C: 3B7D00BC  addi r27, r29, 0xbc
	ctx.r[27].s64 = ctx.r[29].s64 + 188;
	// 82CE8350: 929D00C0  stw r20, 0xc0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(192 as u32), ctx.r[20].u32 ) };
	// 82CE8354: 929D00C4  stw r20, 0xc4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(196 as u32), ctx.r[20].u32 ) };
	// 82CE8358: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE835C: 897D0124  lbz r11, 0x124(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(292 as u32) ) } as u64;
	// 82CE8360: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CE8364: 995D00C6  stb r10, 0xc6(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(198 as u32), ctx.r[10].u8 ) };
	// 82CE8368: 409A00D8  bne cr6, 0x82ce8440
	if !ctx.cr[6].eq {
	pc = 0x82CE8440; continue 'dispatch;
	}
	// 82CE836C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CE8370: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CE8374: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82CE8378: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE837C: 3B4BFF80  addi r26, r11, -0x80
	ctx.r[26].s64 = ctx.r[11].s64 + -128;
	// 82CE8380: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8384: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82CE8388: 4BFFEB59  bl 0x82ce6ee0
	ctx.lr = 0x82CE838C;
	sub_82CE6EE0(ctx, base);
	// 82CE838C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82CE8390: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82CE8394: 80DF0014  lwz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE8398: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82CE839C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE83A0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE83A4: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 82CE83A8: 4BFFEB39  bl 0x82ce6ee0
	ctx.lr = 0x82CE83AC;
	sub_82CE6EE0(ctx, base);
	// 82CE83AC: 80DF0014  lwz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE83B0: 54DCCFBE  rlwinm r28, r6, 0x19, 0x1e, 0x1f
	ctx.r[28].u64 = ctx.r[6].u32 as u64 & 0x0000007Fu64;
	// 82CE83B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82CE83B8: 409A0058  bne cr6, 0x82ce8410
	if !ctx.cr[6].eq {
	pc = 0x82CE8410; continue 'dispatch;
	}
	// 82CE83BC: 2B060200  cmplwi cr6, r6, 0x200
	ctx.cr[6].compare_u32(ctx.r[6].u32, 512 as u32, &mut ctx.xer);
	// 82CE83C0: 41980030  blt cr6, 0x82ce83f0
	if ctx.cr[6].lt {
	pc = 0x82CE83F0; continue 'dispatch;
	}
	// 82CE83C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CE83C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE83CC: 409A0058  bne cr6, 0x82ce8424
	if !ctx.cr[6].eq {
	pc = 0x82CE8424; continue 'dispatch;
	}
	// 82CE83D0: 38C6FE00  addi r6, r6, -0x200
	ctx.r[6].s64 = ctx.r[6].s64 + -512;
	// 82CE83D4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE83D8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CE83DC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE83E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82CE83E4: 4BFFEAFD  bl 0x82ce6ee0
	ctx.lr = 0x82CE83E8;
	sub_82CE6EE0(ctx, base);
	// 82CE83E8: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
	// 82CE83EC: 48000038  b 0x82ce8424
	pc = 0x82CE8424; continue 'dispatch;
	// 82CE83F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CE83F4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE83F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CE83FC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8400: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82CE8404: 4BFFEADD  bl 0x82ce6ee0
	ctx.lr = 0x82CE8408;
	sub_82CE6EE0(ctx, base);
	// 82CE8408: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 82CE840C: 48000018  b 0x82ce8424
	pc = 0x82CE8424; continue 'dispatch;
	// 82CE8410: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CE8414: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8418: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82CE841C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8420: 4BFFEAC1  bl 0x82ce6ee0
	ctx.lr = 0x82CE8424;
	sub_82CE6EE0(ctx, base);
	// 82CE8424: 574BCFBE  rlwinm r11, r26, 0x19, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x0000007Fu64;
	// 82CE8428: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82CE842C: 933D00C0  stw r25, 0xc0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(192 as u32), ctx.r[25].u32 ) };
	// 82CE8430: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CE8434: 997D00C4  stb r11, 0xc4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(196 as u32), ctx.r[11].u8 ) };
	// 82CE8438: 9B9D00C5  stb r28, 0xc5(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(197 as u32), ctx.r[28].u8 ) };
	// 82CE843C: 48000068  b 0x82ce84a4
	pc = 0x82CE84A4; continue 'dispatch;
	// 82CE8440: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CE8444: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82CE8448: 7D3E5214  add r9, r30, r10
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82CE844C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CE8450: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CE8454: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CE8458: 7D69FA14  add r11, r9, r31
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 82CE845C: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CE8460: 80CB0028  lwz r6, 0x28(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CE8464: 90DB0000  stw r6, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82CE8468: 80AB002C  lwz r5, 0x2c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82CE846C: 90BD00C0  stw r5, 0xc0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(192 as u32), ctx.r[5].u32 ) };
	// 82CE8470: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CE8474: 7C87F8AE  lbzx r4, r7, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CE8478: 989D00C4  stb r4, 0xc4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(196 as u32), ctx.r[4].u8 ) };
	// 82CE847C: 886B0031  lbz r3, 0x31(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 82CE8480: 987D00C5  stb r3, 0xc5(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(197 as u32), ctx.r[3].u8 ) };
	// 82CE8484: 48000020  b 0x82ce84a4
	pc = 0x82CE84A4; continue 'dispatch;
	// 82CE8488: 897D0124  lbz r11, 0x124(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(292 as u32) ) } as u64;
	// 82CE848C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CE8490: 409A0020  bne cr6, 0x82ce84b0
	if !ctx.cr[6].eq {
	pc = 0x82CE84B0; continue 'dispatch;
	}
	// 82CE8494: 929D00BC  stw r20, 0xbc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(188 as u32), ctx.r[20].u32 ) };
	// 82CE8498: 38BD00BC  addi r5, r29, 0xbc
	ctx.r[5].s64 = ctx.r[29].s64 + 188;
	// 82CE849C: 929D00C0  stw r20, 0xc0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(192 as u32), ctx.r[20].u32 ) };
	// 82CE84A0: 929D00C4  stw r20, 0xc4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(196 as u32), ctx.r[20].u32 ) };
	// 82CE84A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CE84A8: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE84AC: 4BFF212D  bl 0x82cda5d8
	ctx.lr = 0x82CE84B0;
	sub_82CDA5D8(ctx, base);
	// 82CE84B0: 897D0124  lbz r11, 0x124(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(292 as u32) ) } as u64;
	// 82CE84B4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CE84B8: 419A0018  beq cr6, 0x82ce84d0
	if ctx.cr[6].eq {
	pc = 0x82CE84D0; continue 'dispatch;
	}
	// 82CE84BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CE84C0: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE84C4: 4BFF1BA5  bl 0x82cda068
	ctx.lr = 0x82CE84C8;
	sub_82CDA068(ctx, base);
	// 82CE84C8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE84CC: 409A0008  bne cr6, 0x82ce84d4
	if !ctx.cr[6].eq {
	pc = 0x82CE84D4; continue 'dispatch;
	}
	// 82CE84D0: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 82CE84D4: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82CE84D8: 895D0038  lbz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE84DC: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE84E0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE84E4: 4198FDC0  blt cr6, 0x82ce82a4
	if ctx.cr[6].lt {
	pc = 0x82CE82A4; continue 'dispatch;
	}
	// 82CE84E8: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 82CE84EC: 9ADF0074  stb r22, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[22].u8 ) };
	// 82CE84F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE84F4: 419A0010  beq cr6, 0x82ce8504
	if ctx.cr[6].eq {
	pc = 0x82CE8504; continue 'dispatch;
	}
	// 82CE84F8: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 82CE84FC: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82CE8500: 409AFD60  bne cr6, 0x82ce8260
	if !ctx.cr[6].eq {
	pc = 0x82CE8260; continue 'dispatch;
	}
	// 82CE8504: 81350008  lwz r9, 8(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8508: 81550004  lwz r10, 4(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE850C: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CE8510: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CE8514: 419A003C  beq cr6, 0x82ce8550
	if ctx.cr[6].eq {
	pc = 0x82CE8550; continue 'dispatch;
	}
	// 82CE8518: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE851C: 409A0034  bne cr6, 0x82ce8550
	if !ctx.cr[6].eq {
	pc = 0x82CE8550; continue 'dispatch;
	}
	// 82CE8520: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8524: 91750004  stw r11, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8528: 40820028  bne 0x82ce8550
	if !ctx.cr[0].eq {
	pc = 0x82CE8550; continue 'dispatch;
	}
	// 82CE852C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 82CE8530: 8BF5000C  lbz r31, 0xc(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8534: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 82CE8538: 9975000C  stb r11, 0xc(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE853C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82CE8540: 91550008  stw r10, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE8544: 485D1DF1  bl 0x832ba334
	ctx.lr = 0x82CE8548;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE8548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE854C: 485D1DC9  bl 0x832ba314
	ctx.lr = 0x82CE8550;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE8550: 817D0078  lwz r11, 0x78(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 82CE8554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8558: 419A0054  beq cr6, 0x82ce85ac
	if ctx.cr[6].eq {
	pc = 0x82CE85AC; continue 'dispatch;
	}
	// 82CE855C: 897D0038  lbz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8564: 419A0044  beq cr6, 0x82ce85a8
	if ctx.cr[6].eq {
	pc = 0x82CE85A8; continue 'dispatch;
	}
	// 82CE8568: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 82CE856C: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CE8570: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8574: 395F000F  addi r10, r31, 0xf
	ctx.r[10].s64 = ctx.r[31].s64 + 15;
	// 82CE8578: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82CE857C: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CE8580: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE8584: A0E9007C  lhz r7, 0x7c(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 82CE8588: 7CA8E82E  lwzx r5, r8, r29
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82CE858C: 54E6C9FE  srwi r6, r7, 7
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CE8590: 4BFF21B1  bl 0x82cda740
	ctx.lr = 0x82CE8594;
	sub_82CDA740(ctx, base);
	// 82CE8594: 38DF0001  addi r6, r31, 1
	ctx.r[6].s64 = ctx.r[31].s64 + 1;
	// 82CE8598: 88BD0038  lbz r5, 0x38(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE859C: 54DF063E  clrlwi r31, r6, 0x18
	ctx.r[31].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CE85A0: 7F1F2840  cmplw cr6, r31, r5
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82CE85A4: 4198FFC8  blt cr6, 0x82ce856c
	if ctx.cr[6].lt {
	pc = 0x82CE856C; continue 'dispatch;
	}
	// 82CE85A8: 929D0078  stw r20, 0x78(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[20].u32 ) };
	// 82CE85AC: 897D0038  lbz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE85B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE85B4: 419A0048  beq cr6, 0x82ce85fc
	if ctx.cr[6].eq {
	pc = 0x82CE85FC; continue 'dispatch;
	}
	// 82CE85B8: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 82CE85BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE85C0: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE85C4: 4BFF1B0D  bl 0x82cda0d0
	ctx.lr = 0x82CE85C8;
	sub_82CDA0D0(ctx, base);
	// 82CE85C8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE85CC: 409A001C  bne cr6, 0x82ce85e8
	if !ctx.cr[6].eq {
	pc = 0x82CE85E8; continue 'dispatch;
	}
	// 82CE85D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE85D4: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE85D8: 4BFF1F81  bl 0x82cda558
	ctx.lr = 0x82CE85DC;
	sub_82CDA558(ctx, base);
	// 82CE85DC: 546B0738  rlwinm r11, r3, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE85E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE85E4: 419AF810  beq cr6, 0x82ce7df4
	if ctx.cr[6].eq {
	pc = 0x82CE7DF4; continue 'dispatch;
	}
	// 82CE85E8: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82CE85EC: 895D0038  lbz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE85F0: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE85F4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE85F8: 4198FFC4  blt cr6, 0x82ce85bc
	if ctx.cr[6].lt {
	pc = 0x82CE85BC; continue 'dispatch;
	}
	// 82CE85FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE8600: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82CE8604: 4BFC0E2C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE8608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE8608 size=652
    let mut pc: u32 = 0x82CE8608;
    'dispatch: loop {
        match pc {
            0x82CE8608 => {
    //   block [0x82CE8608..0x82CE8894)
	// 82CE8608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE860C: 4BFC0DED  bl 0x82ca93f8
	ctx.lr = 0x82CE8610;
	sub_82CA93D0(ctx, base);
	// 82CE8610: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE8614: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE8618: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82CE861C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82CE8620: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82CE8624: 897C0038  lbz r11, 0x38(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE862C: 419A003C  beq cr6, 0x82ce8668
	if ctx.cr[6].eq {
	pc = 0x82CE8668; continue 'dispatch;
	}
	// 82CE8630: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82CE8634: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE8638: 807C00B8  lwz r3, 0xb8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE863C: 4BFF1A95  bl 0x82cda0d0
	ctx.lr = 0x82CE8640;
	sub_82CDA0D0(ctx, base);
	// 82CE8640: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE8644: 419A0020  beq cr6, 0x82ce8664
	if ctx.cr[6].eq {
	pc = 0x82CE8664; continue 'dispatch;
	}
	// 82CE8648: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82CE864C: 895C0038  lbz r10, 0x38(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8650: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE8654: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82CE8658: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE865C: 4198FFD8  blt cr6, 0x82ce8634
	if ctx.cr[6].lt {
	pc = 0x82CE8634; continue 'dispatch;
	}
	// 82CE8660: 48000008  b 0x82ce8668
	pc = 0x82CE8668; continue 'dispatch;
	// 82CE8664: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82CE8668: 485D1C9D  bl 0x832ba304
	ctx.lr = 0x82CE866C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE866C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE8670: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE8674: 3B6B7238  addi r27, r11, 0x7238
	ctx.r[27].s64 = ctx.r[11].s64 + 29240;
	// 82CE8678: 7DBF6B78  mr r31, r13
	ctx.r[31].u64 = ctx.r[13].u64;
	// 82CE867C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8680: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CE8684: 419A0010  beq cr6, 0x82ce8694
	if ctx.cr[6].eq {
	pc = 0x82CE8694; continue 'dispatch;
	}
	// 82CE8688: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE868C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE8690: 419A0018  beq cr6, 0x82ce86a8
	if ctx.cr[6].eq {
	pc = 0x82CE86A8; continue 'dispatch;
	}
	// 82CE8694: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82CE8698: 485D1C5D  bl 0x832ba2f4
	ctx.lr = 0x82CE869C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE869C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE86A0: 93FB0008  stw r31, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82CE86A4: 9BDB000C  stb r30, 0xc(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 82CE86A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CE86AC: 397C0014  addi r11, r28, 0x14
	ctx.r[11].s64 = ctx.r[28].s64 + 20;
	// 82CE86B0: 915B0004  stw r10, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CE86B4: 813C0014  lwz r9, 0x14(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE86B8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE86BC: 419A0188  beq cr6, 0x82ce8844
	if ctx.cr[6].eq {
	pc = 0x82CE8844; continue 'dispatch;
	}
	// 82CE86C0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE86C4: 7FCB4850  subf r30, r11, r9
	ctx.r[30].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CE86C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CE86CC: 419A0178  beq cr6, 0x82ce8844
	if ctx.cr[6].eq {
	pc = 0x82CE8844; continue 'dispatch;
	}
	// 82CE86D0: 897E0074  lbz r11, 0x74(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 82CE86D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE86D8: 419A016C  beq cr6, 0x82ce8844
	if ctx.cr[6].eq {
	pc = 0x82CE8844; continue 'dispatch;
	}
	// 82CE86DC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CE86E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE86E4: 419A0160  beq cr6, 0x82ce8844
	if ctx.cr[6].eq {
	pc = 0x82CE8844; continue 'dispatch;
	}
	// 82CE86E8: 897E0076  lbz r11, 0x76(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(118 as u32) ) } as u64;
	// 82CE86EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE86F0: 419A0058  beq cr6, 0x82ce8748
	if ctx.cr[6].eq {
	pc = 0x82CE8748; continue 'dispatch;
	}
	// 82CE86F4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82CE86F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE86FC: 419A0148  beq cr6, 0x82ce8844
	if ctx.cr[6].eq {
	pc = 0x82CE8844; continue 'dispatch;
	}
	// 82CE8700: 897E0077  lbz r11, 0x77(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(119 as u32) ) } as u64;
	// 82CE8704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8708: 409A013C  bne cr6, 0x82ce8844
	if !ctx.cr[6].eq {
	pc = 0x82CE8844; continue 'dispatch;
	}
	// 82CE870C: 897C0038  lbz r11, 0x38(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8714: 419A002C  beq cr6, 0x82ce8740
	if ctx.cr[6].eq {
	pc = 0x82CE8740; continue 'dispatch;
	}
	// 82CE8718: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82CE871C: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82CE8720: 807C00B8  lwz r3, 0xb8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE8728: 4BFF1CF9  bl 0x82cda420
	ctx.lr = 0x82CE872C;
	sub_82CDA420(ctx, base);
	// 82CE872C: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82CE8730: 895C0038  lbz r10, 0x38(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8734: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE8738: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE873C: 4198FFE0  blt cr6, 0x82ce871c
	if ctx.cr[6].lt {
	pc = 0x82CE871C; continue 'dispatch;
	}
	// 82CE8740: 9B1E0077  stb r24, 0x77(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(119 as u32), ctx.r[24].u8 ) };
	// 82CE8744: 480000FC  b 0x82ce8840
	pc = 0x82CE8840; continue 'dispatch;
	// 82CE8748: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE874C: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82CE8750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8754: 419A004C  beq cr6, 0x82ce87a0
	if ctx.cr[6].eq {
	pc = 0x82CE87A0; continue 'dispatch;
	}
	// 82CE8758: 897C0038  lbz r11, 0x38(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE875C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8760: 419A0040  beq cr6, 0x82ce87a0
	if ctx.cr[6].eq {
	pc = 0x82CE87A0; continue 'dispatch;
	}
	// 82CE8764: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82CE8768: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE876C: 807C00B8  lwz r3, 0xb8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8770: 4BFF1EE1  bl 0x82cda650
	ctx.lr = 0x82CE8774;
	sub_82CDA650(ctx, base);
	// 82CE8774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CE8778: 409A0020  bne cr6, 0x82ce8798
	if !ctx.cr[6].eq {
	pc = 0x82CE8798; continue 'dispatch;
	}
	// 82CE877C: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82CE8780: 895C0038  lbz r10, 0x38(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8784: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE8788: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82CE878C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE8790: 4198FFD8  blt cr6, 0x82ce8768
	if ctx.cr[6].lt {
	pc = 0x82CE8768; continue 'dispatch;
	}
	// 82CE8794: 48000008  b 0x82ce879c
	pc = 0x82CE879C; continue 'dispatch;
	// 82CE8798: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82CE879C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE87A0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82CE87A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE87A8: 419A009C  beq cr6, 0x82ce8844
	if ctx.cr[6].eq {
	pc = 0x82CE8844; continue 'dispatch;
	}
	// 82CE87AC: 897C0038  lbz r11, 0x38(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE87B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE87B4: 419A0088  beq cr6, 0x82ce883c
	if ctx.cr[6].eq {
	pc = 0x82CE883C; continue 'dispatch;
	}
	// 82CE87B8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82CE87BC: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 82CE87C0: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82CE87C4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82CE87C8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CE87CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CE87D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CE87D4: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE87D8: 3BABFF80  addi r29, r11, -0x80
	ctx.r[29].s64 = ctx.r[11].s64 + -128;
	// 82CE87DC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE87E0: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82CE87E4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82CE87E8: 932A0004  stw r25, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82CE87EC: 9B01005A  stb r24, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[24].u8 ) };
	// 82CE87F0: 4BFFE6F1  bl 0x82ce6ee0
	ctx.lr = 0x82CE87F4;
	sub_82CE6EE0(ctx, base);
	// 82CE87F4: 57A9CFBE  rlwinm r9, r29, 0x19, 0x1e, 0x1f
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x0000007Fu64;
	// 82CE87F8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82CE87FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CE8800: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82CE8804: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8808: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE880C: 4BFFE79D  bl 0x82ce6fa8
	ctx.lr = 0x82CE8810;
	sub_82CE6FA8(ctx, base);
	// 82CE8810: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82CE8814: 9B410059  stb r26, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[26].u8 ) };
	// 82CE8818: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CE881C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CE8820: 807C00B8  lwz r3, 0xb8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8824: 4BFF1DB5  bl 0x82cda5d8
	ctx.lr = 0x82CE8828;
	sub_82CDA5D8(ctx, base);
	// 82CE8828: 391F0001  addi r8, r31, 1
	ctx.r[8].s64 = ctx.r[31].s64 + 1;
	// 82CE882C: 88FC0038  lbz r7, 0x38(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8830: 551F063E  clrlwi r31, r8, 0x18
	ctx.r[31].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CE8834: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CE8838: 4198FF88  blt cr6, 0x82ce87c0
	if ctx.cr[6].lt {
	pc = 0x82CE87C0; continue 'dispatch;
	}
	// 82CE883C: 9B1E0076  stb r24, 0x76(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(118 as u32), ctx.r[24].u8 ) };
	// 82CE8840: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8844: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CE8848: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CE884C: 419A0040  beq cr6, 0x82ce888c
	if ctx.cr[6].eq {
	pc = 0x82CE888C; continue 'dispatch;
	}
	// 82CE8850: 813B0008  lwz r9, 8(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8854: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE8858: 409A0034  bne cr6, 0x82ce888c
	if !ctx.cr[6].eq {
	pc = 0x82CE888C; continue 'dispatch;
	}
	// 82CE885C: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8860: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8864: 40820028  bne 0x82ce888c
	if !ctx.cr[0].eq {
	pc = 0x82CE888C; continue 'dispatch;
	}
	// 82CE8868: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82CE886C: 8BFB000C  lbz r31, 0xc(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8870: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82CE8874: 997B000C  stb r11, 0xc(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE8878: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82CE887C: 915B0008  stw r10, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE8880: 485D1AB5  bl 0x832ba334
	ctx.lr = 0x82CE8884;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE8884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8888: 485D1A8D  bl 0x832ba314
	ctx.lr = 0x82CE888C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE888C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CE8890: 4BFC0BB8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE8898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE8898 size=436
    let mut pc: u32 = 0x82CE8898;
    'dispatch: loop {
        match pc {
            0x82CE8898 => {
    //   block [0x82CE8898..0x82CE8A4C)
	// 82CE8898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE889C: 4BFC0B69  bl 0x82ca9404
	ctx.lr = 0x82CE88A0;
	sub_82CA93D0(ctx, base);
	// 82CE88A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE88A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE88A8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82CE88AC: 897D0108  lbz r11, 0x108(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CE88B0: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE88B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE88B8: 419A00A0  beq cr6, 0x82ce8958
	if ctx.cr[6].eq {
	pc = 0x82CE8958; continue 'dispatch;
	}
	// 82CE88BC: 3BFD0128  addi r31, r29, 0x128
	ctx.r[31].s64 = ctx.r[29].s64 + 296;
	// 82CE88C0: 485D1A45  bl 0x832ba304
	ctx.lr = 0x82CE88C4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE88C4: 817D012C  lwz r11, 0x12c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(300 as u32) ) } as u64;
	// 82CE88C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE88CC: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE88D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE88D4: 419A0010  beq cr6, 0x82ce88e4
	if ctx.cr[6].eq {
	pc = 0x82CE88E4; continue 'dispatch;
	}
	// 82CE88D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE88DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE88E0: 419A0014  beq cr6, 0x82ce88f4
	if ctx.cr[6].eq {
	pc = 0x82CE88F4; continue 'dispatch;
	}
	// 82CE88E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE88E8: 485D1A0D  bl 0x832ba2f4
	ctx.lr = 0x82CE88EC;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE88EC: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE88F0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE88F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE88F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE88FC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8900: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8904: 4BFF1E95  bl 0x82cda798
	ctx.lr = 0x82CE8908;
	sub_82CDA798(ctx, base);
	// 82CE8908: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE890C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE8910: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE8914: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8918: 419A0038  beq cr6, 0x82ce8950
	if ctx.cr[6].eq {
	pc = 0x82CE8950; continue 'dispatch;
	}
	// 82CE891C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8920: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE8924: 409A002C  bne cr6, 0x82ce8950
	if !ctx.cr[6].eq {
	pc = 0x82CE8950; continue 'dispatch;
	}
	// 82CE8928: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE892C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8930: 40820020  bne 0x82ce8950
	if !ctx.cr[0].eq {
	pc = 0x82CE8950; continue 'dispatch;
	}
	// 82CE8934: 8B9F000C  lbz r28, 0xc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE893C: 9B7F000C  stb r27, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u8 ) };
	// 82CE8940: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82CE8944: 485D19F1  bl 0x832ba334
	ctx.lr = 0x82CE8948;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE8948: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CE894C: 485D19C9  bl 0x832ba314
	ctx.lr = 0x82CE8950;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE8950: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CE8954: 419800EC  blt cr6, 0x82ce8a40
	if ctx.cr[6].lt {
	pc = 0x82CE8A40; continue 'dispatch;
	}
	// 82CE8958: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 82CE895C: 485D19A9  bl 0x832ba304
	ctx.lr = 0x82CE8960;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE8960: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE8964: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE8968: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CE896C: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CE8970: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8974: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8978: 419A0010  beq cr6, 0x82ce8988
	if ctx.cr[6].eq {
	pc = 0x82CE8988; continue 'dispatch;
	}
	// 82CE897C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8980: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE8984: 419A0018  beq cr6, 0x82ce899c
	if ctx.cr[6].eq {
	pc = 0x82CE899C; continue 'dispatch;
	}
	// 82CE8988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE898C: 485D1969  bl 0x832ba2f4
	ctx.lr = 0x82CE8990;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE8990: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8994: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CE8998: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE899C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE89A0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE89A4: 895E009C  lbz r10, 0x9c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 82CE89A8: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82CE89AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CE89B0: 409A0010  bne cr6, 0x82ce89c0
	if !ctx.cr[6].eq {
	pc = 0x82CE89C0; continue 'dispatch;
	}
	// 82CE89B4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82CE89B8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82CE89BC: 48000018  b 0x82ce89d4
	pc = 0x82CE89D4; continue 'dispatch;
	// 82CE89C0: 554A077A  rlwinm r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE89C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE89C8: 419A0024  beq cr6, 0x82ce89ec
	if ctx.cr[6].eq {
	pc = 0x82CE89EC; continue 'dispatch;
	}
	// 82CE89CC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82CE89D0: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82CE89D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE89D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE89DC: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CE89E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE89E4: 4E800421  bctrl
	ctx.lr = 0x82CE89E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE89E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE89EC: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE89F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE89F4: 419A0040  beq cr6, 0x82ce8a34
	if ctx.cr[6].eq {
	pc = 0x82CE8A34; continue 'dispatch;
	}
	// 82CE89F8: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE89FC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE8A00: 409A0034  bne cr6, 0x82ce8a34
	if !ctx.cr[6].eq {
	pc = 0x82CE8A34; continue 'dispatch;
	}
	// 82CE8A04: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8A08: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8A0C: 40820028  bne 0x82ce8a34
	if !ctx.cr[0].eq {
	pc = 0x82CE8A34; continue 'dispatch;
	}
	// 82CE8A10: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82CE8A14: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8A18: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82CE8A1C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE8A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8A24: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE8A28: 485D190D  bl 0x832ba334
	ctx.lr = 0x82CE8A2C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE8A2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE8A30: 485D18E5  bl 0x832ba314
	ctx.lr = 0x82CE8A34;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE8A34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82CE8A38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CE8A3C: 4BFC0A18  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82CE8A40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE8A44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CE8A48: 4BFC0A0C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE8A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE8A50 size=480
    let mut pc: u32 = 0x82CE8A50;
    'dispatch: loop {
        match pc {
            0x82CE8A50 => {
    //   block [0x82CE8A50..0x82CE8C30)
	// 82CE8A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE8A54: 4BFC09AD  bl 0x82ca9400
	ctx.lr = 0x82CE8A58;
	sub_82CA93D0(ctx, base);
	// 82CE8A58: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE8A5C: 549B07FE  clrlwi r27, r4, 0x1f
	ctx.r[27].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82CE8A60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE8A64: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82CE8A68: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CE8A6C: 419A00A4  beq cr6, 0x82ce8b10
	if ctx.cr[6].eq {
	pc = 0x82CE8B10; continue 'dispatch;
	}
	// 82CE8A70: 897D0108  lbz r11, 0x108(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CE8A74: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE8A78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE8A7C: 419A0094  beq cr6, 0x82ce8b10
	if ctx.cr[6].eq {
	pc = 0x82CE8B10; continue 'dispatch;
	}
	// 82CE8A80: 3BFD0128  addi r31, r29, 0x128
	ctx.r[31].s64 = ctx.r[29].s64 + 296;
	// 82CE8A84: 485D1881  bl 0x832ba304
	ctx.lr = 0x82CE8A88;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE8A88: 817D012C  lwz r11, 0x12c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(300 as u32) ) } as u64;
	// 82CE8A8C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE8A90: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE8A94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8A98: 419A0010  beq cr6, 0x82ce8aa8
	if ctx.cr[6].eq {
	pc = 0x82CE8AA8; continue 'dispatch;
	}
	// 82CE8A9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8AA0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE8AA4: 419A0014  beq cr6, 0x82ce8ab8
	if ctx.cr[6].eq {
	pc = 0x82CE8AB8; continue 'dispatch;
	}
	// 82CE8AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8AAC: 485D1849  bl 0x832ba2f4
	ctx.lr = 0x82CE8AB0;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE8AB0: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE8AB4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE8AB8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8ABC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE8AC0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8AC4: 807D00B8  lwz r3, 0xb8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8AC8: 4BFF13C1  bl 0x82cd9e88
	ctx.lr = 0x82CE8ACC;
	sub_82CD9E88(ctx, base);
	// 82CE8ACC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8AD0: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE8AD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8AD8: 419A0038  beq cr6, 0x82ce8b10
	if ctx.cr[6].eq {
	pc = 0x82CE8B10; continue 'dispatch;
	}
	// 82CE8ADC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8AE0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE8AE4: 409A002C  bne cr6, 0x82ce8b10
	if !ctx.cr[6].eq {
	pc = 0x82CE8B10; continue 'dispatch;
	}
	// 82CE8AE8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8AEC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8AF0: 40820020  bne 0x82ce8b10
	if !ctx.cr[0].eq {
	pc = 0x82CE8B10; continue 'dispatch;
	}
	// 82CE8AF4: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8AFC: 9B5F000C  stb r26, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u8 ) };
	// 82CE8B00: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82CE8B04: 485D1831  bl 0x832ba334
	ctx.lr = 0x82CE8B08;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE8B08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE8B0C: 485D1809  bl 0x832ba314
	ctx.lr = 0x82CE8B10;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE8B10: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 82CE8B14: 485D17F1  bl 0x832ba304
	ctx.lr = 0x82CE8B18;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE8B18: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE8B1C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE8B20: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CE8B24: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CE8B28: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8B2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8B30: 419A0010  beq cr6, 0x82ce8b40
	if ctx.cr[6].eq {
	pc = 0x82CE8B40; continue 'dispatch;
	}
	// 82CE8B34: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8B38: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE8B3C: 419A0018  beq cr6, 0x82ce8b54
	if ctx.cr[6].eq {
	pc = 0x82CE8B54; continue 'dispatch;
	}
	// 82CE8B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8B44: 485D17B1  bl 0x832ba2f4
	ctx.lr = 0x82CE8B48;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE8B48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8B4C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CE8B50: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE8B54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE8B58: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8B5C: 895E009C  lbz r10, 0x9c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 82CE8B60: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82CE8B64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CE8B68: 419A0074  beq cr6, 0x82ce8bdc
	if ctx.cr[6].eq {
	pc = 0x82CE8BDC; continue 'dispatch;
	}
	// 82CE8B6C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CE8B70: 409A004C  bne cr6, 0x82ce8bbc
	if !ctx.cr[6].eq {
	pc = 0x82CE8BBC; continue 'dispatch;
	}
	// 82CE8B74: 554906FC  rlwinm r9, r10, 0, 0x1b, 0x1e
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE8B78: 552907B6  rlwinm r9, r9, 0, 0x1e, 0x1b
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE8B7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CE8B80: 409A003C  bne cr6, 0x82ce8bbc
	if !ctx.cr[6].eq {
	pc = 0x82CE8BBC; continue 'dispatch;
	}
	// 82CE8B84: 554A077A  rlwinm r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE8B88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE8B8C: 409A0050  bne cr6, 0x82ce8bdc
	if !ctx.cr[6].eq {
	pc = 0x82CE8BDC; continue 'dispatch;
	}
	// 82CE8B90: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE8B94: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82CE8B98: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82CE8B9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE8BA0: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CE8BA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE8BA8: 4E800421  bctrl
	ctx.lr = 0x82CE8BAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE8BAC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CE8BB0: A1694E08  lhz r11, 0x4e08(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(19976 as u32) ) } as u64;
	// 82CE8BB4: B17E009E  sth r11, 0x9e(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(158 as u32), ctx.r[11].u16 ) };
	// 82CE8BB8: 48000020  b 0x82ce8bd8
	pc = 0x82CE8BD8; continue 'dispatch;
	// 82CE8BBC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE8BC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CE8BC4: 38800057  li r4, 0x57
	ctx.r[4].s64 = 87;
	// 82CE8BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE8BCC: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CE8BD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE8BD4: 4E800421  bctrl
	ctx.lr = 0x82CE8BD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE8BD8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8BDC: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE8BE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8BE4: 419A0040  beq cr6, 0x82ce8c24
	if ctx.cr[6].eq {
	pc = 0x82CE8C24; continue 'dispatch;
	}
	// 82CE8BE8: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8BEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE8BF0: 409A0034  bne cr6, 0x82ce8c24
	if !ctx.cr[6].eq {
	pc = 0x82CE8C24; continue 'dispatch;
	}
	// 82CE8BF4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8BF8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8BFC: 40820028  bne 0x82ce8c24
	if !ctx.cr[0].eq {
	pc = 0x82CE8C24; continue 'dispatch;
	}
	// 82CE8C00: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82CE8C04: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8C08: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82CE8C0C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE8C10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8C14: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE8C18: 485D171D  bl 0x832ba334
	ctx.lr = 0x82CE8C1C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE8C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE8C20: 485D16F5  bl 0x832ba314
	ctx.lr = 0x82CE8C24;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE8C24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE8C28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CE8C2C: 4BFC0824  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE8C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE8C30 size=8
    let mut pc: u32 = 0x82CE8C30;
    'dispatch: loop {
        match pc {
            0x82CE8C30 => {
    //   block [0x82CE8C30..0x82CE8C38)
	// 82CE8C30: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE8C34: 4BFFFE1C  b 0x82ce8a50
	sub_82CE8A50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE8C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE8C38 size=8
    let mut pc: u32 = 0x82CE8C38;
    'dispatch: loop {
        match pc {
            0x82CE8C38 => {
    //   block [0x82CE8C38..0x82CE8C40)
	// 82CE8C38: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE8C3C: 4BFFFC5C  b 0x82ce8898
	sub_82CE8898(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE8C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE8C40 size=8
    let mut pc: u32 = 0x82CE8C40;
    'dispatch: loop {
        match pc {
            0x82CE8C40 => {
    //   block [0x82CE8C40..0x82CE8C48)
	// 82CE8C40: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE8C44: 4BFFF0AC  b 0x82ce7cf0
	sub_82CE7CF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE8C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE8C48 size=360
    let mut pc: u32 = 0x82CE8C48;
    'dispatch: loop {
        match pc {
            0x82CE8C48 => {
    //   block [0x82CE8C48..0x82CE8DB0)
	// 82CE8C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE8C4C: 4BFC07B5  bl 0x82ca9400
	ctx.lr = 0x82CE8C50;
	sub_82CA93D0(ctx, base);
	// 82CE8C50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE8C54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE8C58: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82CE8C5C: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 82CE8C60: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CE8C64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CE8C68: 4BFF7251  bl 0x82cdfeb8
	ctx.lr = 0x82CE8C6C;
	sub_82CDFEB8(ctx, base);
	// 82CE8C6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CE8C70: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CE8C74: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CE8C78: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CE8C7C: 390B4EF8  addi r8, r11, 0x4ef8
	ctx.r[8].s64 = ctx.r[11].s64 + 20216;
	// 82CE8C80: 38EA4ED0  addi r7, r10, 0x4ed0
	ctx.r[7].s64 = ctx.r[10].s64 + 20176;
	// 82CE8C84: 93DF00B8  stw r30, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 82CE8C88: 38C94E70  addi r6, r9, 0x4e70
	ctx.r[6].s64 = ctx.r[9].s64 + 20080;
	// 82CE8C8C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82CE8C90: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CE8C94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82CE8C98: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82CE8C9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CE8CA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82CE8CA4: 897B0045  lbz r11, 0x45(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CE8CA8: 997F0108  stb r11, 0x108(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u8 ) };
	// 82CE8CAC: 93DF010C  stw r30, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u32 ) };
	// 82CE8CB0: 93DF0110  stw r30, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[30].u32 ) };
	// 82CE8CB4: 93DF0120  stw r30, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 82CE8CB8: 9BDF0124  stb r30, 0x124(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[30].u8 ) };
	// 82CE8CBC: 93DF012C  stw r30, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u32 ) };
	// 82CE8CC0: 93DF0130  stw r30, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 82CE8CC4: 9BDF0134  stb r30, 0x134(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u8 ) };
	// 82CE8CC8: 93DF0128  stw r30, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u32 ) };
	// 82CE8CCC: 4BFF6F7D  bl 0x82cdfc48
	ctx.lr = 0x82CE8CD0;
	sub_82CDFC48(ctx, base);
	// 82CE8CD0: 3D4002E8  lis r10, 0x2e8
	ctx.r[10].s64 = 48758784;
	// 82CE8CD4: 6149BA2E  ori r9, r10, 0xba2e
	ctx.r[9].u64 = ctx.r[10].u64 | 47662;
	// 82CE8CD8: 8B9F0038  lbz r28, 0x38(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8CDC: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE8CE0: 1C9C0058  mulli r4, r28, 0x58
	ctx.r[4].s64 = ctx.r[28].s64 * 88;
	// 82CE8CE4: 40990008  ble cr6, 0x82ce8cec
	if !ctx.cr[6].gt {
	pc = 0x82CE8CEC; continue 'dispatch;
	}
	// 82CE8CE8: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 82CE8CEC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE8CF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CE8CF4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE8CF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE8CFC: 4E800421  bctrl
	ctx.lr = 0x82CE8D00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE8D00: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82CE8D04: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82CE8D08: 419A0038  beq cr6, 0x82ce8d40
	if ctx.cr[6].eq {
	pc = 0x82CE8D40; continue 'dispatch;
	}
	// 82CE8D0C: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82CE8D10: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82CE8D14: 41800024  blt 0x82ce8d38
	if ctx.cr[0].lt {
	pc = 0x82CE8D38; continue 'dispatch;
	}
	// 82CE8D18: 38A0004C  li r5, 0x4c
	ctx.r[5].s64 = 76;
	// 82CE8D1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CE8D20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CE8D24: 4BFC0C8D  bl 0x82ca99b0
	ctx.lr = 0x82CE8D28;
	sub_82CA99B0(ctx, base);
	// 82CE8D28: 93DD004C  stw r30, 0x4c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82CE8D2C: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82CE8D30: 3BBD0058  addi r29, r29, 0x58
	ctx.r[29].s64 = ctx.r[29].s64 + 88;
	// 82CE8D34: 4080FFE4  bge 0x82ce8d18
	if !ctx.cr[0].lt {
	pc = 0x82CE8D18; continue 'dispatch;
	}
	// 82CE8D38: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82CE8D3C: 48000008  b 0x82ce8d44
	pc = 0x82CE8D44; continue 'dispatch;
	// 82CE8D40: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CE8D44: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 82CE8D48: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82CE8D4C: 100F038C  vspltisw v0, 0xf
	for i in 0..4 {
		ctx.v[0].u32[i] = 15;
	}
	// 82CE8D50: 392000CC  li r9, 0xcc
	ctx.r[9].s64 = 204;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE8DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE8DB0 size=2756
    let mut pc: u32 = 0x82CE8DB0;
    'dispatch: loop {
        match pc {
            0x82CE8DB0 => {
    //   block [0x82CE8DB0..0x82CE9874)
	// 82CE8DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE8DB4: 4BFC063D  bl 0x82ca93f0
	ctx.lr = 0x82CE8DB8;
	sub_82CA93D0(ctx, base);
	// 82CE8DB8: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82CE8DBC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE8DC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE8DC4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82CE8DC8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82CE8DCC: 3B1F0128  addi r24, r31, 0x128
	ctx.r[24].s64 = ctx.r[31].s64 + 296;
	// 82CE8DD0: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 82CE8DD4: 7EF6BB78  mr r22, r23
	ctx.r[22].u64 = ctx.r[23].u64;
	// 82CE8DD8: 485D152D  bl 0x832ba304
	ctx.lr = 0x82CE8DDC;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE8DDC: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 82CE8DE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE8DE4: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE8DE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8DEC: 419A0010  beq cr6, 0x82ce8dfc
	if ctx.cr[6].eq {
	pc = 0x82CE8DFC; continue 'dispatch;
	}
	// 82CE8DF0: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8DF4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE8DF8: 419A0014  beq cr6, 0x82ce8e0c
	if ctx.cr[6].eq {
	pc = 0x82CE8E0C; continue 'dispatch;
	}
	// 82CE8DFC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82CE8E00: 485D14F5  bl 0x832ba2f4
	ctx.lr = 0x82CE8E04;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE8E04: 9BB8000C  stb r29, 0xc(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CE8E08: 93D80008  stw r30, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE8E0C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8E10: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE8E14: 91780004  stw r11, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8E18: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8E1C: 4BFF10E5  bl 0x82cd9f00
	ctx.lr = 0x82CE8E20;
	sub_82CD9F00(ctx, base);
	// 82CE8E20: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE8E24: 419A09FC  beq cr6, 0x82ce9820
	if ctx.cr[6].eq {
	pc = 0x82CE9820; continue 'dispatch;
	}
	// 82CE8E28: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8E2C: 4BFF1A35  bl 0x82cda860
	ctx.lr = 0x82CE8E30;
	sub_82CDA860(ctx, base);
	// 82CE8E30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE8E34: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CE8E38: 40980058  bge cr6, 0x82ce8e90
	if !ctx.cr[6].lt {
	pc = 0x82CE8E90; continue 'dispatch;
	}
	// 82CE8E3C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8E40: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE8E44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8E48: 419A0038  beq cr6, 0x82ce8e80
	if ctx.cr[6].eq {
	pc = 0x82CE8E80; continue 'dispatch;
	}
	// 82CE8E4C: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8E50: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE8E54: 409A002C  bne cr6, 0x82ce8e80
	if !ctx.cr[6].eq {
	pc = 0x82CE8E80; continue 'dispatch;
	}
	// 82CE8E58: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8E5C: 91780004  stw r11, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8E60: 40820020  bne 0x82ce8e80
	if !ctx.cr[0].eq {
	pc = 0x82CE8E80; continue 'dispatch;
	}
	// 82CE8E64: 8BF8000C  lbz r31, 0xc(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8E68: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82CE8E6C: 92F80008  stw r23, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82CE8E70: 9AF8000C  stb r23, 0xc(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[23].u8 ) };
	// 82CE8E74: 485D14C1  bl 0x832ba334
	ctx.lr = 0x82CE8E78;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE8E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8E7C: 485D1499  bl 0x832ba314
	ctx.lr = 0x82CE8E80;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE8E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE8E84: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82CE8E88: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82CE8E8C: 4BFC05B4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 82CE8E90: 485D1475  bl 0x832ba304
	ctx.lr = 0x82CE8E94;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE8E94: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE8E98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE8E9C: 3B2B7238  addi r25, r11, 0x7238
	ctx.r[25].s64 = ctx.r[11].s64 + 29240;
	// 82CE8EA0: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE8EA4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8EA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8EAC: 419A0010  beq cr6, 0x82ce8ebc
	if ctx.cr[6].eq {
	pc = 0x82CE8EBC; continue 'dispatch;
	}
	// 82CE8EB0: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8EB4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE8EB8: 419A0018  beq cr6, 0x82ce8ed0
	if ctx.cr[6].eq {
	pc = 0x82CE8ED0; continue 'dispatch;
	}
	// 82CE8EBC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82CE8EC0: 485D1435  bl 0x832ba2f4
	ctx.lr = 0x82CE8EC4;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE8EC4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8EC8: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE8ECC: 9BB9000C  stb r29, 0xc(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CE8ED0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE8ED4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CE8ED8: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8EDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CE8EE0: 4BFF56D1  bl 0x82cde5b0
	ctx.lr = 0x82CE8EE4;
	sub_82CDE5B0(ctx, base);
	// 82CE8EE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE8EE8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CE8EEC: 4198005C  blt cr6, 0x82ce8f48
	if ctx.cr[6].lt {
	pc = 0x82CE8F48; continue 'dispatch;
	}
	// 82CE8EF0: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8EF4: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CE8EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8EFC: 419A002C  beq cr6, 0x82ce8f28
	if ctx.cr[6].eq {
	pc = 0x82CE8F28; continue 'dispatch;
	}
	// 82CE8F00: 5568063E  clrlwi r8, r11, 0x18
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE8F04: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE8F08: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 82CE8F0C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82CE8F10: 55261838  slwi r6, r9, 3
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CE8F14: 54EB063E  clrlwi r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82CE8F18: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CE8F1C: 7D26F8AE  lbzx r9, r6, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CE8F20: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CE8F24: 4198FFE4  blt cr6, 0x82ce8f08
	if ctx.cr[6].lt {
	pc = 0x82CE8F08; continue 'dispatch;
	}
	// 82CE8F28: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82CE8F2C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82CE8F30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CE8F34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CE8F38: 4BFF58D9  bl 0x82cde810
	ctx.lr = 0x82CE8F3C;
	sub_82CDE810(ctx, base);
	// 82CE8F3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE8F40: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CE8F44: 409802B8  bge cr6, 0x82ce91fc
	if !ctx.cr[6].lt {
	pc = 0x82CE91FC; continue 'dispatch;
	}
	// 82CE8F48: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE8F4C: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE8F50: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CE8F54: 419A0040  beq cr6, 0x82ce8f94
	if ctx.cr[6].eq {
	pc = 0x82CE8F94; continue 'dispatch;
	}
	// 82CE8F58: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE8F5C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE8F60: 409A0034  bne cr6, 0x82ce8f94
	if !ctx.cr[6].eq {
	pc = 0x82CE8F94; continue 'dispatch;
	}
	// 82CE8F64: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE8F68: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE8F6C: 40820028  bne 0x82ce8f94
	if !ctx.cr[0].eq {
	pc = 0x82CE8F94; continue 'dispatch;
	}
	// 82CE8F70: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CE8F74: 8BB9000C  lbz r29, 0xc(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE8F78: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE8F7C: 91590008  stw r10, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE8F80: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82CE8F84: 9979000C  stb r11, 0xc(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE8F88: 485D13AD  bl 0x832ba334
	ctx.lr = 0x82CE8F8C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE8F8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CE8F90: 485D1385  bl 0x832ba314
	ctx.lr = 0x82CE8F94;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE8F94: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CE8F98: 409AFEA4  bne cr6, 0x82ce8e3c
	if !ctx.cr[6].eq {
	pc = 0x82CE8E3C; continue 'dispatch;
	}
	// 82CE8F9C: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8FA0: 4BFF1959  bl 0x82cda8f8
	ctx.lr = 0x82CE8FA4;
	sub_82CDA8F8(ctx, base);
	// 82CE8FA4: 897F0124  lbz r11, 0x124(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82CE8FA8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CE8FAC: 409A000C  bne cr6, 0x82ce8fb8
	if !ctx.cr[6].eq {
	pc = 0x82CE8FB8; continue 'dispatch;
	}
	// 82CE8FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE8FB4: 4BFFF655  bl 0x82ce8608
	ctx.lr = 0x82CE8FB8;
	sub_82CE8608(ctx, base);
	// 82CE8FB8: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE8FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE8FC0: 419A0178  beq cr6, 0x82ce9138
	if ctx.cr[6].eq {
	pc = 0x82CE9138; continue 'dispatch;
	}
	// 82CE8FC4: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82CE8FC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82CE8FCC: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8FD0: 4BFF1161  bl 0x82cda130
	ctx.lr = 0x82CE8FD4;
	sub_82CDA130(ctx, base);
	// 82CE8FD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE8FD8: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 82CE8FDC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82CE8FE0: 419A0098  beq cr6, 0x82ce9078
	if ctx.cr[6].eq {
	pc = 0x82CE9078; continue 'dispatch;
	}
	// 82CE8FE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CE8FE8: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE8FEC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82CE8FF0: 4BFF1389  bl 0x82cda378
	ctx.lr = 0x82CE8FF4;
	sub_82CDA378(ctx, base);
	// 82CE8FF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CE8FF8: 419A0080  beq cr6, 0x82ce9078
	if ctx.cr[6].eq {
	pc = 0x82CE9078; continue 'dispatch;
	}
	// 82CE8FFC: 1FDB0058  mulli r30, r27, 0x58
	ctx.r[30].s64 = ctx.r[27].s64 * 88;
	// 82CE9000: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE9004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CE9008: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CE900C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82CE9010: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CE9014: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82CE9018: 419A0008  beq cr6, 0x82ce9020
	if ctx.cr[6].eq {
	pc = 0x82CE9020; continue 'dispatch;
	}
	// 82CE901C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82CE9020: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82CE9024: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE9028: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82CE902C: 48004F35  bl 0x82cedf60
	ctx.lr = 0x82CE9030;
	sub_82CEDF60(ctx, base);
	// 82CE9030: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82CE9034: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82CE9038: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE903C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82CE9040: 7FA5EA14  add r29, r5, r29
	ctx.r[29].u64 = ctx.r[5].u64 + ctx.r[29].u64;
	// 82CE9044: 4BFF117D  bl 0x82cda1c0
	ctx.lr = 0x82CE9048;
	sub_82CDA1C0(ctx, base);
	// 82CE9048: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE904C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82CE9050: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CE9054: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CE9058: 7D095051  subf. r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CE905C: 4182001C  beq 0x82ce9078
	if ctx.cr[0].eq {
	pc = 0x82CE9078; continue 'dispatch;
	}
	// 82CE9060: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CE9064: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE9068: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82CE906C: 4BFF130D  bl 0x82cda378
	ctx.lr = 0x82CE9070;
	sub_82CDA378(ctx, base);
	// 82CE9070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CE9074: 409AFF8C  bne cr6, 0x82ce9000
	if !ctx.cr[6].eq {
	pc = 0x82CE9000; continue 'dispatch;
	}
	// 82CE9078: 397B008A  addi r11, r27, 0x8a
	ctx.r[11].s64 = ctx.r[27].s64 + 138;
	// 82CE907C: 7D5DE050  subf r10, r29, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 82CE9080: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CE9084: 7D09FA2E  lhzx r8, r9, r31
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CE9088: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CE908C: 41990008  bgt cr6, 0x82ce9094
	if ctx.cr[6].gt {
	pc = 0x82CE9094; continue 'dispatch;
	}
	// 82CE9090: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 82CE9094: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CE9098: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82CE909C: 4BFFAD8D  bl 0x82ce3e28
	ctx.lr = 0x82CE90A0;
	sub_82CE3E28(ctx, base);
	// 82CE90A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82CE90A4: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 82CE90A8: 4BFFAD81  bl 0x82ce3e28
	ctx.lr = 0x82CE90AC;
	sub_82CE3E28(ctx, base);
	// 82CE90AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CE90B0: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE90B4: 4BFF15E5  bl 0x82cda698
	ctx.lr = 0x82CE90B8;
	sub_82CDA698(ctx, base);
	// 82CE90B8: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE90BC: 1D7B0058  mulli r11, r27, 0x58
	ctx.r[11].s64 = ctx.r[27].s64 * 88;
	// 82CE90C0: 907F00A8  stw r3, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[3].u32 ) };
	// 82CE90C4: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CE90C8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CE90CC: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CE90D0: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CE90D4: 8BBE000D  lbz r29, 0xd(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CE90D8: 41820038  beq 0x82ce9110
	if ctx.cr[0].eq {
	pc = 0x82CE9110; continue 'dispatch;
	}
	// 82CE90DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82CE90E0: 419A002C  beq cr6, 0x82ce910c
	if ctx.cr[6].eq {
	pc = 0x82CE910C; continue 'dispatch;
	}
	// 82CE90E4: 555A103A  slwi r26, r10, 2
	ctx.r[26].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82CE90E8: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82CE90EC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE90F0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82CE90F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CE90F8: 7C7C5A14  add r3, r28, r11
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82CE90FC: 4BFC08B5  bl 0x82ca99b0
	ctx.lr = 0x82CE9100;
	sub_82CA99B0(ctx, base);
	// 82CE9100: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82CE9104: 3B9C0400  addi r28, r28, 0x400
	ctx.r[28].s64 = ctx.r[28].s64 + 1024;
	// 82CE9108: 4082FFE4  bne 0x82ce90ec
	if !ctx.cr[0].eq {
	pc = 0x82CE90EC; continue 'dispatch;
	}
	// 82CE910C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82CE9110: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CE9114: 409A0010  bne cr6, 0x82ce9124
	if !ctx.cr[6].eq {
	pc = 0x82CE9124; continue 'dispatch;
	}
	// 82CE9118: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CE911C: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82CE9120: 4BFFAD09  bl 0x82ce3e28
	ctx.lr = 0x82CE9124;
	sub_82CE3E28(ctx, base);
	// 82CE9124: 397B0001  addi r11, r27, 1
	ctx.r[11].s64 = ctx.r[27].s64 + 1;
	// 82CE9128: 895F0038  lbz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE912C: 557B063E  clrlwi r27, r11, 0x18
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE9130: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9134: 4198FE94  blt cr6, 0x82ce8fc8
	if ctx.cr[6].lt {
	pc = 0x82CE8FC8; continue 'dispatch;
	}
	// 82CE9138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE913C: 4BFFEBE5  bl 0x82ce7d20
	ctx.lr = 0x82CE9140;
	sub_82CE7D20(ctx, base);
	// 82CE9140: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE9144: 485D11C1  bl 0x832ba304
	ctx.lr = 0x82CE9148;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE9148: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE914C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE9150: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE9154: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9158: 419A0010  beq cr6, 0x82ce9168
	if ctx.cr[6].eq {
	pc = 0x82CE9168; continue 'dispatch;
	}
	// 82CE915C: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9160: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9164: 419A0018  beq cr6, 0x82ce917c
	if ctx.cr[6].eq {
	pc = 0x82CE917C; continue 'dispatch;
	}
	// 82CE9168: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82CE916C: 485D1189  bl 0x832ba2f4
	ctx.lr = 0x82CE9170;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE9170: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9174: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE9178: 9BB9000C  stb r29, 0xc(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CE917C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82CE9180: 90F90004  stw r7, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CE9184: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE918C: 419A0034  beq cr6, 0x82ce91c0
	if ctx.cr[6].eq {
	pc = 0x82CE91C0; continue 'dispatch;
	}
	// 82CE9190: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE9194: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE9198: 1D4B0058  mulli r10, r11, 0x58
	ctx.r[10].s64 = ctx.r[11].s64 * 88;
	// 82CE919C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82CE91A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE91A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE91A8: C00A0028  lfs f0, 0x28(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE91AC: D00A0024  stfs f0, 0x24(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CE91B0: 895F0038  lbz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE91B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE91B8: 4198FFDC  blt cr6, 0x82ce9194
	if ctx.cr[6].lt {
	pc = 0x82CE9194; continue 'dispatch;
	}
	// 82CE91BC: 80F90004  lwz r7, 4(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE91C0: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82CE91C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE91C8: 419A038C  beq cr6, 0x82ce9554
	if ctx.cr[6].eq {
	pc = 0x82CE9554; continue 'dispatch;
	}
	// 82CE91CC: 897F00AC  lbz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CE91D0: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE91D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE91D8: 409A034C  bne cr6, 0x82ce9524
	if !ctx.cr[6].eq {
	pc = 0x82CE9524; continue 'dispatch;
	}
	// 82CE91DC: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CE91E0: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82CE91E4: 393F0014  addi r9, r31, 0x14
	ctx.r[9].s64 = ctx.r[31].s64 + 20;
	// 82CE91E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE91EC: 419A02C4  beq cr6, 0x82ce94b0
	if ctx.cr[6].eq {
	pc = 0x82CE94B0; continue 'dispatch;
	}
	// 82CE91F0: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE91F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CE91F8: 480002BC  b 0x82ce94b4
	pc = 0x82CE94B4; continue 'dispatch;
	// 82CE91FC: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE9204: 419A0058  beq cr6, 0x82ce925c
	if ctx.cr[6].eq {
	pc = 0x82CE925C; continue 'dispatch;
	}
	// 82CE9208: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82CE920C: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CE9210: 38E00100  li r7, 0x100
	ctx.r[7].s64 = 256;
	// 82CE9214: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE9218: 1D0A0058  mulli r8, r10, 0x58
	ctx.r[8].s64 = ctx.r[10].s64 * 88;
	// 82CE921C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CE9220: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 82CE9224: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 82CE9228: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CE922C: 54CA063E  clrlwi r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CE9230: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82CE9234: 90EB0018  stw r7, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 82CE9238: 92EB001C  stw r23, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[23].u32 ) };
	// 82CE923C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82CE9240: 7D65F8AE  lbzx r11, r5, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CE9244: 556B503E  rotlwi r11, r11, 0xa
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(10)) as u64;
	// 82CE9248: 7D2B2214  add r9, r11, r4
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82CE924C: 887F0038  lbz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9250: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82CE9254: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82CE9258: 4198FFBC  blt cr6, 0x82ce9214
	if ctx.cr[6].lt {
	pc = 0x82CE9214; continue 'dispatch;
	}
	// 82CE925C: 897F00AC  lbz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CE9260: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CE9264: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE9268: 419A0180  beq cr6, 0x82ce93e8
	if ctx.cr[6].eq {
	pc = 0x82CE93E8; continue 'dispatch;
	}
	// 82CE926C: 556A06F6  rlwinm r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE9270: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE9274: 409A0174  bne cr6, 0x82ce93e8
	if !ctx.cr[6].eq {
	pc = 0x82CE93E8; continue 'dispatch;
	}
	// 82CE9278: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CE927C: 556907BC  rlwinm r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE9280: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CE9284: C3EA0C18  lfs f31, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82CE9288: 419A0090  beq cr6, 0x82ce9318
	if ctx.cr[6].eq {
	pc = 0x82CE9318; continue 'dispatch;
	}
	// 82CE928C: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE9294: 419A0068  beq cr6, 0x82ce92fc
	if ctx.cr[6].eq {
	pc = 0x82CE92FC; continue 'dispatch;
	}
	// 82CE9298: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82CE929C: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE92A0: 1D680058  mulli r11, r8, 0x58
	ctx.r[11].s64 = ctx.r[8].s64 * 88;
	// 82CE92A4: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE92A8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CE92AC: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 82CE92B0: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82CE92B4: D00A0028  stfs f0, 0x28(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82CE92B8: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE92BC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CE92C0: C1AA0028  lfs f13, 0x28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CE92C4: D1AA0024  stfs f13, 0x24(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CE92C8: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE92CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CE92D0: 394B0034  addi r10, r11, 0x34
	ctx.r[10].s64 = ctx.r[11].s64 + 52;
	// 82CE92D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CE92D8: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82CE92DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CE92E0: 4200FFF8  bdnz 0x82ce92d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82CE92D8; continue 'dispatch;
	}
	// 82CE92E4: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 82CE92E8: D3EB0030  stfs f31, 0x30(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82CE92EC: 893F0038  lbz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE92F0: 5548063E  clrlwi r8, r10, 0x18
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CE92F4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE92F8: 4198FFA4  blt cr6, 0x82ce929c
	if ctx.cr[6].lt {
	pc = 0x82CE929C; continue 'dispatch;
	}
	// 82CE92FC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE9300: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82CE9304: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CE9308: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82CE930C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CE9310: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE9314: 4E800421  bctrl
	ctx.lr = 0x82CE9318;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE9318: 897F00AC  lbz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CE931C: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE9320: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE9324: 419A0074  beq cr6, 0x82ce9398
	if ctx.cr[6].eq {
	pc = 0x82CE9398; continue 'dispatch;
	}
	// 82CE9328: A15F00AE  lhz r10, 0xae(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(174 as u32) ) } as u64;
	// 82CE932C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82CE9330: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE9334: 3D0A0001  addis r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 65536;
	// 82CE9338: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82CE933C: 5507043E  clrlwi r7, r8, 0x10
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 82CE9340: C1A90028  lfs f13, 0x28(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CE9344: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CE9348: B0FF00AE  sth r7, 0xae(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(174 as u32), ctx.r[7].u16 ) };
	// 82CE934C: 419A0014  beq cr6, 0x82ce9360
	if ctx.cr[6].eq {
	pc = 0x82CE9360; continue 'dispatch;
	}
	// 82CE9350: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CE9354: C00B4E0C  lfs f0, 0x4e0c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE9358: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CE935C: 48000008  b 0x82ce9364
	pc = 0x82CE9364; continue 'dispatch;
	// 82CE9360: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82CE9364: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE936C: 419A002C  beq cr6, 0x82ce9398
	if ctx.cr[6].eq {
	pc = 0x82CE9398; continue 'dispatch;
	}
	// 82CE9370: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE9374: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE9378: 1D2B0058  mulli r9, r11, 0x58
	ctx.r[9].s64 = ctx.r[11].s64 * 88;
	// 82CE937C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CE9380: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE9384: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE9388: D00A0028  stfs f0, 0x28(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82CE938C: 893F0038  lbz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9390: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE9394: 4198FFE0  blt cr6, 0x82ce9374
	if ctx.cr[6].lt {
	pc = 0x82CE9374; continue 'dispatch;
	}
	// 82CE9398: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE939C: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE93A0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CE93A4: 419AFBF8  beq cr6, 0x82ce8f9c
	if ctx.cr[6].eq {
	pc = 0x82CE8F9C; continue 'dispatch;
	}
	// 82CE93A8: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE93AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE93B0: 409AFBEC  bne cr6, 0x82ce8f9c
	if !ctx.cr[6].eq {
	pc = 0x82CE8F9C; continue 'dispatch;
	}
	// 82CE93B4: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE93B8: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE93BC: 4082FBE0  bne 0x82ce8f9c
	if !ctx.cr[0].eq {
	pc = 0x82CE8F9C; continue 'dispatch;
	}
	// 82CE93C0: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CE93C4: 8BD9000C  lbz r30, 0xc(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE93C8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE93CC: 91590008  stw r10, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE93D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82CE93D4: 9979000C  stb r11, 0xc(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE93D8: 485D0F5D  bl 0x832ba334
	ctx.lr = 0x82CE93DC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE93DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE93E0: 485D0F35  bl 0x832ba314
	ctx.lr = 0x82CE93E4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE93E4: 4BFFFBB8  b 0x82ce8f9c
	pc = 0x82CE8F9C; continue 'dispatch;
	// 82CE93E8: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE93EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE93F0: 419A006C  beq cr6, 0x82ce945c
	if ctx.cr[6].eq {
	pc = 0x82CE945C; continue 'dispatch;
	}
	// 82CE93F4: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 82CE93F8: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82CE93FC: 1D5A0058  mulli r10, r26, 0x58
	ctx.r[10].s64 = ctx.r[26].s64 * 88;
	// 82CE9400: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CE9404: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CE9408: 8BDC000D  lbz r30, 0xd(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CE940C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE9410: 419A0034  beq cr6, 0x82ce9444
	if ctx.cr[6].eq {
	pc = 0x82CE9444; continue 'dispatch;
	}
	// 82CE9414: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CE9418: 419A002C  beq cr6, 0x82ce9444
	if ctx.cr[6].eq {
	pc = 0x82CE9444; continue 'dispatch;
	}
	// 82CE941C: 557B103A  slwi r27, r11, 2
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82CE9420: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 82CE9424: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE9428: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CE942C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CE9430: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82CE9434: 4BFC057D  bl 0x82ca99b0
	ctx.lr = 0x82CE9438;
	sub_82CA99B0(ctx, base);
	// 82CE9438: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CE943C: 3BBD0400  addi r29, r29, 0x400
	ctx.r[29].s64 = ctx.r[29].s64 + 1024;
	// 82CE9440: 4082FFE4  bne 0x82ce9424
	if !ctx.cr[0].eq {
	pc = 0x82CE9424; continue 'dispatch;
	}
	// 82CE9444: 397A0001  addi r11, r26, 1
	ctx.r[11].s64 = ctx.r[26].s64 + 1;
	// 82CE9448: 895F0038  lbz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE944C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CE9450: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82CE9454: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9458: 4198FFA0  blt cr6, 0x82ce93f8
	if ctx.cr[6].lt {
	pc = 0x82CE93F8; continue 'dispatch;
	}
	// 82CE945C: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9460: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE9464: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CE9468: 419A0040  beq cr6, 0x82ce94a8
	if ctx.cr[6].eq {
	pc = 0x82CE94A8; continue 'dispatch;
	}
	// 82CE946C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9470: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE9474: 409A0034  bne cr6, 0x82ce94a8
	if !ctx.cr[6].eq {
	pc = 0x82CE94A8; continue 'dispatch;
	}
	// 82CE9478: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE947C: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9480: 40820028  bne 0x82ce94a8
	if !ctx.cr[0].eq {
	pc = 0x82CE94A8; continue 'dispatch;
	}
	// 82CE9484: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CE9488: 8BF9000C  lbz r31, 0xc(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE948C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE9490: 91590008  stw r10, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE9494: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82CE9498: 9979000C  stb r11, 0xc(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE949C: 485D0E99  bl 0x832ba334
	ctx.lr = 0x82CE94A0;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE94A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE94A4: 485D0E71  bl 0x832ba314
	ctx.lr = 0x82CE94A8;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE94A8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82CE94AC: 4BFFF990  b 0x82ce8e3c
	pc = 0x82CE8E3C; continue 'dispatch;
	// 82CE94B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82CE94B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE94B8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE94BC: 419A0010  beq cr6, 0x82ce94cc
	if ctx.cr[6].eq {
	pc = 0x82CE94CC; continue 'dispatch;
	}
	// 82CE94C0: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE94C4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CE94C8: 48000008  b 0x82ce94d0
	pc = 0x82CE94D0; continue 'dispatch;
	// 82CE94CC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE94D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CE94D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE94D8: 419A0020  beq cr6, 0x82ce94f8
	if ctx.cr[6].eq {
	pc = 0x82CE94F8; continue 'dispatch;
	}
	// 82CE94DC: 896B0074  lbz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82CE94E0: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82CE94E4: 7D660034  cntlzw r6, r11
	ctx.r[6].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82CE94E8: 54C5DFFE  rlwinm r5, r6, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 82CE94EC: 68A40001  xori r4, r5, 1
	ctx.r[4].u64 = ctx.r[5].u64 ^ 1;
	// 82CE94F0: 7C884378  or r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 | ctx.r[8].u64;
	// 82CE94F4: 4BFFFCF4  b 0x82ce91e8
	pc = 0x82CE91E8; continue 'dispatch;
	// 82CE94F8: 550B063E  clrlwi r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CE94FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE9500: 409A0054  bne cr6, 0x82ce9554
	if !ctx.cr[6].eq {
	pc = 0x82CE9554; continue 'dispatch;
	}
	// 82CE9504: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE9508: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82CE950C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82CE9510: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82CE9514: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CE9518: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE951C: 4E800421  bctrl
	ctx.lr = 0x82CE9520;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE9520: 48000030  b 0x82ce9550
	pc = 0x82CE9550; continue 'dispatch;
	// 82CE9524: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82CE9528: 409A002C  bne cr6, 0x82ce9554
	if !ctx.cr[6].eq {
	pc = 0x82CE9554; continue 'dispatch;
	}
	// 82CE952C: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE9530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE9534: 409A0020  bne cr6, 0x82ce9554
	if !ctx.cr[6].eq {
	pc = 0x82CE9554; continue 'dispatch;
	}
	// 82CE9538: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE953C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CE9540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9544: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CE9548: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE954C: 4E800421  bctrl
	ctx.lr = 0x82CE9550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE9550: 80F90004  lwz r7, 4(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9554: 897F00AC  lbz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CE9558: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE955C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE9560: 419A0038  beq cr6, 0x82ce9598
	if ctx.cr[6].eq {
	pc = 0x82CE9598; continue 'dispatch;
	}
	// 82CE9564: A15F00AE  lhz r10, 0xae(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(174 as u32) ) } as u64;
	// 82CE9568: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE956C: 419A0010  beq cr6, 0x82ce957c
	if ctx.cr[6].eq {
	pc = 0x82CE957C; continue 'dispatch;
	}
	// 82CE9570: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE9574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE9578: 419A0020  beq cr6, 0x82ce9598
	if ctx.cr[6].eq {
	pc = 0x82CE9598; continue 'dispatch;
	}
	// 82CE957C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE9580: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CE9584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9588: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CE958C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE9590: 4E800421  bctrl
	ctx.lr = 0x82CE9594;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE9594: 80F90004  lwz r7, 4(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9598: 897F00AC  lbz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CE959C: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CE95A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CE95A4: 419A0010  beq cr6, 0x82ce95b4
	if ctx.cr[6].eq {
	pc = 0x82CE95B4; continue 'dispatch;
	}
	// 82CE95A8: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CE95AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE95B0: 419A01A4  beq cr6, 0x82ce9754
	if ctx.cr[6].eq {
	pc = 0x82CE9754; continue 'dispatch;
	}
	// 82CE95B4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE95B8: 3B7F0014  addi r27, r31, 0x14
	ctx.r[27].s64 = ctx.r[31].s64 + 20;
	// 82CE95BC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE95C0: 419A0010  beq cr6, 0x82ce95d0
	if ctx.cr[6].eq {
	pc = 0x82CE95D0; continue 'dispatch;
	}
	// 82CE95C4: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE95C8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CE95CC: 48000008  b 0x82ce95d4
	pc = 0x82CE95D4; continue 'dispatch;
	// 82CE95D0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE95D4: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82CE95D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE95DC: 419A0178  beq cr6, 0x82ce9754
	if ctx.cr[6].eq {
	pc = 0x82CE9754; continue 'dispatch;
	}
	// 82CE95E0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82CE95E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82CE95E8: 419A0010  beq cr6, 0x82ce95f8
	if ctx.cr[6].eq {
	pc = 0x82CE95F8; continue 'dispatch;
	}
	// 82CE95EC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE95F0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82CE95F4: 48000008  b 0x82ce95fc
	pc = 0x82CE95FC; continue 'dispatch;
	// 82CE95F8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82CE95FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE9600: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE9604: 419A0010  beq cr6, 0x82ce9614
	if ctx.cr[6].eq {
	pc = 0x82CE9614; continue 'dispatch;
	}
	// 82CE9608: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE960C: 7F8A5850  subf r28, r10, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CE9610: 48000008  b 0x82ce9618
	pc = 0x82CE9618; continue 'dispatch;
	// 82CE9614: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82CE9618: 897E0074  lbz r11, 0x74(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 82CE961C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82CE9620: 409A012C  bne cr6, 0x82ce974c
	if !ctx.cr[6].eq {
	pc = 0x82CE974C; continue 'dispatch;
	}
	// 82CE9624: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CE9628: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CE962C: 419A0040  beq cr6, 0x82ce966c
	if ctx.cr[6].eq {
	pc = 0x82CE966C; continue 'dispatch;
	}
	// 82CE9630: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9634: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9638: 409A0034  bne cr6, 0x82ce966c
	if !ctx.cr[6].eq {
	pc = 0x82CE966C; continue 'dispatch;
	}
	// 82CE963C: 3567FFFF  addic. r11, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9640: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9644: 40820028  bne 0x82ce966c
	if !ctx.cr[0].eq {
	pc = 0x82CE966C; continue 'dispatch;
	}
	// 82CE9648: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE964C: 8BB9000C  lbz r29, 0xc(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9650: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CE9654: 9979000C  stb r11, 0xc(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE9658: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82CE965C: 91590008  stw r10, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE9660: 485D0CD5  bl 0x832ba334
	ctx.lr = 0x82CE9664;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE9664: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CE9668: 485D0CAD  bl 0x832ba314
	ctx.lr = 0x82CE966C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE966C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9670: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE9674: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9678: 419A0038  beq cr6, 0x82ce96b0
	if ctx.cr[6].eq {
	pc = 0x82CE96B0; continue 'dispatch;
	}
	// 82CE967C: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9680: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE9684: 409A002C  bne cr6, 0x82ce96b0
	if !ctx.cr[6].eq {
	pc = 0x82CE96B0; continue 'dispatch;
	}
	// 82CE9688: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE968C: 91780004  stw r11, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9690: 40820020  bne 0x82ce96b0
	if !ctx.cr[0].eq {
	pc = 0x82CE96B0; continue 'dispatch;
	}
	// 82CE9694: 8BB8000C  lbz r29, 0xc(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9698: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82CE969C: 9AF8000C  stb r23, 0xc(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[23].u8 ) };
	// 82CE96A0: 92F80008  stw r23, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82CE96A4: 485D0C91  bl 0x832ba334
	ctx.lr = 0x82CE96A8;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE96A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CE96AC: 485D0C69  bl 0x832ba314
	ctx.lr = 0x82CE96B0;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE96B0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE96B4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82CE96B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CE96BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CE96C0: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82CE96C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE96C8: 4E800421  bctrl
	ctx.lr = 0x82CE96CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE96CC: 485D0C39  bl 0x832ba304
	ctx.lr = 0x82CE96D0;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE96D0: 81380004  lwz r9, 4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE96D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE96D8: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE96DC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CE96E0: 419A0010  beq cr6, 0x82ce96f0
	if ctx.cr[6].eq {
	pc = 0x82CE96F0; continue 'dispatch;
	}
	// 82CE96E4: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE96E8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CE96EC: 419A0014  beq cr6, 0x82ce9700
	if ctx.cr[6].eq {
	pc = 0x82CE9700; continue 'dispatch;
	}
	// 82CE96F0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82CE96F4: 485D0C01  bl 0x832ba2f4
	ctx.lr = 0x82CE96F8;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE96F8: 93D80008  stw r30, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE96FC: 9BB8000C  stb r29, 0xc(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CE9700: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9704: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE9708: 91780004  stw r11, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE970C: 485D0BF9  bl 0x832ba304
	ctx.lr = 0x82CE9710;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE9710: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9714: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE9718: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE971C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9720: 419A0010  beq cr6, 0x82ce9730
	if ctx.cr[6].eq {
	pc = 0x82CE9730; continue 'dispatch;
	}
	// 82CE9724: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9728: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE972C: 419A0018  beq cr6, 0x82ce9744
	if ctx.cr[6].eq {
	pc = 0x82CE9744; continue 'dispatch;
	}
	// 82CE9730: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82CE9734: 485D0BC1  bl 0x832ba2f4
	ctx.lr = 0x82CE9738;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE9738: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE973C: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE9740: 9BB9000C  stb r29, 0xc(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CE9744: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82CE9748: 90F90004  stw r7, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CE974C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82CE9750: 409AFE90  bne cr6, 0x82ce95e0
	if !ctx.cr[6].eq {
	pc = 0x82CE95E0; continue 'dispatch;
	}
	// 82CE9754: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CE9758: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CE975C: 419A0040  beq cr6, 0x82ce979c
	if ctx.cr[6].eq {
	pc = 0x82CE979C; continue 'dispatch;
	}
	// 82CE9760: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9764: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9768: 409A0034  bne cr6, 0x82ce979c
	if !ctx.cr[6].eq {
	pc = 0x82CE979C; continue 'dispatch;
	}
	// 82CE976C: 3567FFFF  addic. r11, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9770: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9774: 40820028  bne 0x82ce979c
	if !ctx.cr[0].eq {
	pc = 0x82CE979C; continue 'dispatch;
	}
	// 82CE9778: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CE977C: 8BD9000C  lbz r30, 0xc(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9780: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CE9784: 9979000C  stb r11, 0xc(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE9788: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82CE978C: 91590008  stw r10, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE9790: 485D0BA5  bl 0x832ba334
	ctx.lr = 0x82CE9794;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE9794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE9798: 485D0B7D  bl 0x832ba314
	ctx.lr = 0x82CE979C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE979C: 56CB063E  clrlwi r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 82CE97A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE97A4: 419A007C  beq cr6, 0x82ce9820
	if ctx.cr[6].eq {
	pc = 0x82CE9820; continue 'dispatch;
	}
	// 82CE97A8: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE97AC: 4BFF0755  bl 0x82cd9f00
	ctx.lr = 0x82CE97B0;
	sub_82CD9F00(ctx, base);
	// 82CE97B0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE97B4: 419A006C  beq cr6, 0x82ce9820
	if ctx.cr[6].eq {
	pc = 0x82CE9820; continue 'dispatch;
	}
	// 82CE97B8: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82CE97BC: 4BFF1355  bl 0x82cdab10
	ctx.lr = 0x82CE97C0;
	sub_82CDAB10(ctx, base);
	// 82CE97C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE97C4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CE97C8: 40980058  bge cr6, 0x82ce9820
	if !ctx.cr[6].lt {
	pc = 0x82CE9820; continue 'dispatch;
	}
	// 82CE97CC: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE97D0: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE97D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE97D8: 419A0038  beq cr6, 0x82ce9810
	if ctx.cr[6].eq {
	pc = 0x82CE9810; continue 'dispatch;
	}
	// 82CE97DC: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE97E0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE97E4: 409A002C  bne cr6, 0x82ce9810
	if !ctx.cr[6].eq {
	pc = 0x82CE9810; continue 'dispatch;
	}
	// 82CE97E8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE97EC: 91780004  stw r11, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE97F0: 40820020  bne 0x82ce9810
	if !ctx.cr[0].eq {
	pc = 0x82CE9810; continue 'dispatch;
	}
	// 82CE97F4: 8BD8000C  lbz r30, 0xc(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE97F8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82CE97FC: 92F80008  stw r23, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82CE9800: 9AF8000C  stb r23, 0xc(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[23].u8 ) };
	// 82CE9804: 485D0B31  bl 0x832ba334
	ctx.lr = 0x82CE9808;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE9808: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE980C: 485D0B09  bl 0x832ba314
	ctx.lr = 0x82CE9810;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE9810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9814: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82CE9818: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82CE981C: 4BFBFC24  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 82CE9820: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9824: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE9828: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE982C: 419A0038  beq cr6, 0x82ce9864
	if ctx.cr[6].eq {
	pc = 0x82CE9864; continue 'dispatch;
	}
	// 82CE9830: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9834: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE9838: 409A002C  bne cr6, 0x82ce9864
	if !ctx.cr[6].eq {
	pc = 0x82CE9864; continue 'dispatch;
	}
	// 82CE983C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9840: 91780004  stw r11, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9844: 40820020  bne 0x82ce9864
	if !ctx.cr[0].eq {
	pc = 0x82CE9864; continue 'dispatch;
	}
	// 82CE9848: 8BF8000C  lbz r31, 0xc(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE984C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82CE9850: 92F80008  stw r23, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82CE9854: 9AF8000C  stb r23, 0xc(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[23].u8 ) };
	// 82CE9858: 485D0ADD  bl 0x832ba334
	ctx.lr = 0x82CE985C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE985C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9860: 485D0AB5  bl 0x832ba314
	ctx.lr = 0x82CE9864;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE9864: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9868: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82CE986C: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82CE9870: 4BFBFBD0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9878 size=172
    let mut pc: u32 = 0x82CE9878;
    'dispatch: loop {
        match pc {
            0x82CE9878 => {
    //   block [0x82CE9878..0x82CE9924)
	// 82CE9878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE987C: 4BFBFB91  bl 0x82ca940c
	ctx.lr = 0x82CE9880;
	sub_82CA93D0(ctx, base);
	// 82CE9880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9884: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CE9888: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE988C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CE9890: 38800138  li r4, 0x138
	ctx.r[4].s64 = 312;
	// 82CE9894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9898: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE989C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CE98A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE98A4: 4E800421  bctrl
	ctx.lr = 0x82CE98A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE98A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CE98AC: 419A001C  beq cr6, 0x82ce98c8
	if ctx.cr[6].eq {
	pc = 0x82CE98C8; continue 'dispatch;
	}
	// 82CE98B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CE98B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CE98B8: 4BFFF391  bl 0x82ce8c48
	ctx.lr = 0x82CE98BC;
	sub_82CE8C48(ctx, base);
	// 82CE98BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE98C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CE98C4: 409A0014  bne cr6, 0x82ce98d8
	if !ctx.cr[6].eq {
	pc = 0x82CE98D8; continue 'dispatch;
	}
	// 82CE98C8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CE98CC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CE98D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CE98D4: 4BFBFB88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82CE98D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE98DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE98E0: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82CE98E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE98E8: 4E800421  bctrl
	ctx.lr = 0x82CE98EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE98EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE98F0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CE98F4: 41980010  blt cr6, 0x82ce9904
	if ctx.cr[6].lt {
	pc = 0x82CE9904; continue 'dispatch;
	}
	// 82CE98F8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82CE98FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CE9900: 4BFBFB5C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82CE9904: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9908: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82CE990C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9910: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE9914: 4E800421  bctrl
	ctx.lr = 0x82CE9918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE9918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE991C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CE9920: 4BFBFB3C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9928 size=8
    let mut pc: u32 = 0x82CE9928;
    'dispatch: loop {
        match pc {
            0x82CE9928 => {
    //   block [0x82CE9928..0x82CE9930)
	// 82CE9928: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE992C: 480002AC  b 0x82ce9bd8
	sub_82CE9BD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9930 size=8
    let mut pc: u32 = 0x82CE9930;
    'dispatch: loop {
        match pc {
            0x82CE9930 => {
    //   block [0x82CE9930..0x82CE9938)
	// 82CE9930: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82CE9934: 480002A4  b 0x82ce9bd8
	sub_82CE9BD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9938 size=72
    let mut pc: u32 = 0x82CE9938;
    'dispatch: loop {
        match pc {
            0x82CE9938 => {
    //   block [0x82CE9938..0x82CE9980)
	// 82CE9938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE993C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE9940: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9944: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9948: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82CE994C: 346AFFFF  addic. r3, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE9950: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82CE9954: 4082001C  bne 0x82ce9970
	if !ctx.cr[0].eq {
	pc = 0x82CE9970; continue 'dispatch;
	}
	// 82CE9958: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CE995C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82CE9960: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9964: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CE9968: 4E800421  bctrl
	ctx.lr = 0x82CE996C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE996C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9970: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CE9974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE997C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9980 size=28
    let mut pc: u32 = 0x82CE9980;
    'dispatch: loop {
        match pc {
            0x82CE9980 => {
    //   block [0x82CE9980..0x82CE999C)
	// 82CE9980: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CE9984: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CE9988: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE998C: 99440000  stb r10, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82CE9990: A16B4E08  lhz r11, 0x4e08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(19976 as u32) ) } as u64;
	// 82CE9994: B1640002  sth r11, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 82CE9998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE99A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE99A0 size=8
    let mut pc: u32 = 0x82CE99A0;
    'dispatch: loop {
        match pc {
            0x82CE99A0 => {
    //   block [0x82CE99A0..0x82CE99A8)
	// 82CE99A0: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82CE99A4: 4BFFCE54  b 0x82ce67f8
	sub_82CE67F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE99A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE99A8 size=8
    let mut pc: u32 = 0x82CE99A8;
    'dispatch: loop {
        match pc {
            0x82CE99A8 => {
    //   block [0x82CE99A8..0x82CE99B0)
	// 82CE99A8: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82CE99AC: 4BFFD104  b 0x82ce6ab0
	sub_82CE6AB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE99B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE99B0 size=8
    let mut pc: u32 = 0x82CE99B0;
    'dispatch: loop {
        match pc {
            0x82CE99B0 => {
    //   block [0x82CE99B0..0x82CE99B8)
	// 82CE99B0: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82CE99B4: 4BFFC914  b 0x82ce62c8
	sub_82CE62C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE99B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE99B8 size=16
    let mut pc: u32 = 0x82CE99B8;
    'dispatch: loop {
        match pc {
            0x82CE99B8 => {
    //   block [0x82CE99B8..0x82CE99C8)
	// 82CE99B8: 896300AC  lbz r11, 0xac(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CE99BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE99C0: 99640000  stb r11, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82CE99C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE99C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CE99C8 size=16
    let mut pc: u32 = 0x82CE99C8;
    'dispatch: loop {
        match pc {
            0x82CE99C8 => {
    //   block [0x82CE99C8..0x82CE99D8)
	// 82CE99C8: C0030070  lfs f0, 0x70(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE99CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE99D0: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CE99D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE99D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE99D8 size=72
    let mut pc: u32 = 0x82CE99D8;
    'dispatch: loop {
        match pc {
            0x82CE99D8 => {
    //   block [0x82CE99D8..0x82CE9A20)
	// 82CE99D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE99DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE99E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE99E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE99E8: C0230074  lfs f1, 0x74(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CE99EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CE99F0: 4B50A3C1  bl 0x821f3db0
	ctx.lr = 0x82CE99F4;
	sub_821F3DB0(ctx, base);
	// 82CE99F4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CE99F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CE99FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9A00: C00B3FA8  lfs f0, 0x3fa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE9A04: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CE9A08: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CE9A0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CE9A10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9A14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE9A18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE9A1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CE9A20 size=16
    let mut pc: u32 = 0x82CE9A20;
    'dispatch: loop {
        match pc {
            0x82CE9A20 => {
    //   block [0x82CE9A20..0x82CE9A30)
	// 82CE9A20: C0030074  lfs f0, 0x74(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CE9A24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9A28: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CE9A2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9A30 size=28
    let mut pc: u32 = 0x82CE9A30;
    'dispatch: loop {
        match pc {
            0x82CE9A30 => {
    //   block [0x82CE9A30..0x82CE9A4C)
	// 82CE9A30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CE9A34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9A38: A14B006C  lhz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82CE9A3C: 812B0078  lwz r9, 0x78(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82CE9A40: 7D0A49D6  mullw r8, r10, r9
	ctx.r[8].s64 = (ctx.r[10].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82CE9A44: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82CE9A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9A50 size=16
    let mut pc: u32 = 0x82CE9A50;
    'dispatch: loop {
        match pc {
            0x82CE9A50 => {
    //   block [0x82CE9A50..0x82CE9A60)
	// 82CE9A50: 816300A8  lwz r11, 0xa8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 82CE9A54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9A58: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CE9A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9A60 size=84
    let mut pc: u32 = 0x82CE9A60;
    'dispatch: loop {
        match pc {
            0x82CE9A60 => {
    //   block [0x82CE9A60..0x82CE9AB4)
	// 82CE9A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE9A68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE9A6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9A70: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE9A74: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CE9A78: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82CE9A7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CE9A80: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82CE9A84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE9A88: 4E800421  bctrl
	ctx.lr = 0x82CE9A8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE9A8C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE9A90: 41980010  blt cr6, 0x82ce9aa0
	if ctx.cr[6].lt {
	pc = 0x82CE9AA0; continue 'dispatch;
	}
	// 82CE9A94: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CE9A98: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE9A9C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CE9AA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CE9AA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9AA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE9AAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE9AB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9AB8 size=80
    let mut pc: u32 = 0x82CE9AB8;
    'dispatch: loop {
        match pc {
            0x82CE9AB8 => {
    //   block [0x82CE9AB8..0x82CE9B08)
	// 82CE9AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9ABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE9AC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE9AC4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9AC8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE9ACC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CE9AD0: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82CE9AD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CE9AD8: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82CE9ADC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE9AE0: 4E800421  bctrl
	ctx.lr = 0x82CE9AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE9AE4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE9AE8: 4198000C  blt cr6, 0x82ce9af4
	if ctx.cr[6].lt {
	pc = 0x82CE9AF4; continue 'dispatch;
	}
	// 82CE9AEC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CE9AF0: 93EB0010  stw r31, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82CE9AF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CE9AF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9AFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE9B00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE9B04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9B08 size=84
    let mut pc: u32 = 0x82CE9B08;
    'dispatch: loop {
        match pc {
            0x82CE9B08 => {
    //   block [0x82CE9B08..0x82CE9B5C)
	// 82CE9B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE9B10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE9B14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9B18: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CE9B1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CE9B20: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82CE9B24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CE9B28: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82CE9B2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CE9B30: 4E800421  bctrl
	ctx.lr = 0x82CE9B34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CE9B34: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE9B38: 41980010  blt cr6, 0x82ce9b48
	if ctx.cr[6].lt {
	pc = 0x82CE9B48; continue 'dispatch;
	}
	// 82CE9B3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CE9B40: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CE9B44: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CE9B48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CE9B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE9B54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE9B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9B60 size=100
    let mut pc: u32 = 0x82CE9B60;
    'dispatch: loop {
        match pc {
            0x82CE9B60 => {
    //   block [0x82CE9B60..0x82CE9BC4)
	// 82CE9B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE9B68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CE9B6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE9B70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9B74: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82CE9B78: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82CE9B7C: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 82CE9B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CE9B84: 419A0014  beq cr6, 0x82ce9b98
	if ctx.cr[6].eq {
	pc = 0x82CE9B98; continue 'dispatch;
	}
	// 82CE9B88: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 82CE9B8C: 38A00038  li r5, 0x38
	ctx.r[5].s64 = 56;
	// 82CE9B90: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82CE9B94: 4BFBF8ED  bl 0x82ca9480
	ctx.lr = 0x82CE9B98;
	sub_82CA9480(ctx, base);
	// 82CE9B98: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CE9B9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9BA0: 419A000C  beq cr6, 0x82ce9bac
	if ctx.cr[6].eq {
	pc = 0x82CE9BAC; continue 'dispatch;
	}
	// 82CE9BA4: 897F009D  lbz r11, 0x9d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(157 as u32) ) } as u64;
	// 82CE9BA8: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82CE9BAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CE9BB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9BB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE9BB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CE9BBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE9BC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9BC8 size=8
    let mut pc: u32 = 0x82CE9BC8;
    'dispatch: loop {
        match pc {
            0x82CE9BC8 => {
    //   block [0x82CE9BC8..0x82CE9BD0)
	// 82CE9BC8: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82CE9BCC: 4BFF60AC  b 0x82cdfc78
	sub_82CDFC78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9BD0 size=8
    let mut pc: u32 = 0x82CE9BD0;
    'dispatch: loop {
        match pc {
            0x82CE9BD0 => {
    //   block [0x82CE9BD0..0x82CE9BD8)
	// 82CE9BD0: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82CE9BD4: 4BFF619C  b 0x82cdfd70
	sub_82CDFD70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9BD8 size=88
    let mut pc: u32 = 0x82CE9BD8;
    'dispatch: loop {
        match pc {
            0x82CE9BD8 => {
    //   block [0x82CE9BD8..0x82CE9C30)
	// 82CE9BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE9BE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE9BE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9BE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE9BEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CE9BF0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CE9BF4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CE9BF8: 390B5000  addi r8, r11, 0x5000
	ctx.r[8].s64 = ctx.r[11].s64 + 20480;
	// 82CE9BFC: 38EA4FD8  addi r7, r10, 0x4fd8
	ctx.r[7].s64 = ctx.r[10].s64 + 20440;
	// 82CE9C00: 38C94F78  addi r6, r9, 0x4f78
	ctx.r[6].s64 = ctx.r[9].s64 + 20344;
	// 82CE9C04: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82CE9C08: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CE9C0C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82CE9C10: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82CE9C14: 4BFF6595  bl 0x82ce01a8
	ctx.lr = 0x82CE9C18;
	sub_82CE01A8(ctx, base);
	// 82CE9C18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9C1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CE9C20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9C24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE9C28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE9C2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9C30 size=96
    let mut pc: u32 = 0x82CE9C30;
    'dispatch: loop {
        match pc {
            0x82CE9C30 => {
    //   block [0x82CE9C30..0x82CE9C90)
	// 82CE9C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CE9C38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CE9C3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9C40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CE9C44: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82CE9C48: 4BFFCB11  bl 0x82ce6758
	ctx.lr = 0x82CE9C4C;
	sub_82CE6758(ctx, base);
	// 82CE9C4C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CE9C50: 4198002C  blt cr6, 0x82ce9c7c
	if ctx.cr[6].lt {
	pc = 0x82CE9C7C; continue 'dispatch;
	}
	// 82CE9C54: 897F00C4  lbz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82CE9C58: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CE9C5C: 893F00C5  lbz r9, 0xc5(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(197 as u32) ) } as u64;
	// 82CE9C60: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CE9C64: 38EA5078  addi r7, r10, 0x5078
	ctx.r[7].s64 = ctx.r[10].s64 + 20600;
	// 82CE9C68: 5566103E  rotlwi r6, r11, 2
	ctx.r[6].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82CE9C6C: 7CA6382E  lwzx r5, r6, r7
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82CE9C70: B11F006E  sth r8, 0x6e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(110 as u32), ctx.r[8].u16 ) };
	// 82CE9C74: 7C8549D6  mullw r4, r5, r9
	ctx.r[4].s64 = (ctx.r[5].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82CE9C78: B09F006C  sth r4, 0x6c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[4].u16 ) };
	// 82CE9C7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CE9C80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CE9C84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CE9C88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CE9C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE9C90 size=196
    let mut pc: u32 = 0x82CE9C90;
    'dispatch: loop {
        match pc {
            0x82CE9C90 => {
    //   block [0x82CE9C90..0x82CE9D54)
	// 82CE9C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9C94: 4BFBF775  bl 0x82ca9408
	ctx.lr = 0x82CE9C98;
	sub_82CA93D0(ctx, base);
	// 82CE9C98: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CE9C9C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9CA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CE9CA4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CE9CA8: 485D065D  bl 0x832ba304
	ctx.lr = 0x82CE9CAC;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE9CAC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE9CB0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE9CB4: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CE9CB8: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CE9CBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9CC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9CC4: 419A0010  beq cr6, 0x82ce9cd4
	if ctx.cr[6].eq {
	pc = 0x82CE9CD4; continue 'dispatch;
	}
	// 82CE9CC8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9CCC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9CD0: 419A0018  beq cr6, 0x82ce9ce8
	if ctx.cr[6].eq {
	pc = 0x82CE9CE8; continue 'dispatch;
	}
	// 82CE9CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9CD8: 485D061D  bl 0x832ba2f4
	ctx.lr = 0x82CE9CDC;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE9CDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9CE0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CE9CE4: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE9CE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE9CEC: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE9CF0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9CF4: D3FD0070  stfs f31, 0x70(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82CE9CF8: D3FD00E0  stfs f31, 0xe0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82CE9CFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9D00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9D04: 419A0040  beq cr6, 0x82ce9d44
	if ctx.cr[6].eq {
	pc = 0x82CE9D44; continue 'dispatch;
	}
	// 82CE9D08: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9D0C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE9D10: 409A0034  bne cr6, 0x82ce9d44
	if !ctx.cr[6].eq {
	pc = 0x82CE9D44; continue 'dispatch;
	}
	// 82CE9D14: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9D18: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9D1C: 40820028  bne 0x82ce9d44
	if !ctx.cr[0].eq {
	pc = 0x82CE9D44; continue 'dispatch;
	}
	// 82CE9D20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE9D24: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9D28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE9D2C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE9D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9D34: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE9D38: 485D05FD  bl 0x832ba334
	ctx.lr = 0x82CE9D3C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE9D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE9D40: 485D05D5  bl 0x832ba314
	ctx.lr = 0x82CE9D44;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE9D44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9D48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CE9D4C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CE9D50: 4BFBF708  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE9D58 size=280
    let mut pc: u32 = 0x82CE9D58;
    'dispatch: loop {
        match pc {
            0x82CE9D58 => {
    //   block [0x82CE9D58..0x82CE9E70)
	// 82CE9D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9D5C: 4BFBF6AD  bl 0x82ca9408
	ctx.lr = 0x82CE9D60;
	sub_82CA93D0(ctx, base);
	// 82CE9D60: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CE9D64: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9D68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE9D6C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CE9D70: 485D0595  bl 0x832ba304
	ctx.lr = 0x82CE9D74;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE9D74: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE9D78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE9D7C: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CE9D80: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CE9D84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9D88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9D8C: 419A0010  beq cr6, 0x82ce9d9c
	if ctx.cr[6].eq {
	pc = 0x82CE9D9C; continue 'dispatch;
	}
	// 82CE9D90: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9D94: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9D98: 419A0018  beq cr6, 0x82ce9db0
	if ctx.cr[6].eq {
	pc = 0x82CE9DB0; continue 'dispatch;
	}
	// 82CE9D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9DA0: 485D0555  bl 0x832ba2f4
	ctx.lr = 0x82CE9DA4;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE9DA4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9DA8: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CE9DAC: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE9DB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CE9DB4: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82CE9DB8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CE9DBC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9DC0: C82A0DE8  lfd f1, 0xde8(r10)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3560 as u32) ) };
	// 82CE9DC4: 4B5146E5  bl 0x821fe4a8
	ctx.lr = 0x82CE9DC8;
	sub_821FE4A8(ctx, base);
	// 82CE9DC8: 80FE003C  lwz r7, 0x3c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CE9DCC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CE9DD0: 891E0038  lbz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9DD4: 88DE0034  lbz r6, 0x34(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CE9DD8: D01E0074  stfs f0, 0x74(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82CE9DDC: 991E00C5  stb r8, 0xc5(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(197 as u32), ctx.r[8].u8 ) };
	// 82CE9DE0: 397E00B8  addi r11, r30, 0xb8
	ctx.r[11].s64 = ctx.r[30].s64 + 184;
	// 82CE9DE4: 98DE00C4  stb r6, 0xc4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), ctx.r[6].u8 ) };
	// 82CE9DE8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82CE9DEC: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82CE9DF0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CE9DF4: 809E0108  lwz r4, 0x108(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CE9DF8: 60830001  ori r3, r4, 1
	ctx.r[3].u64 = ctx.r[4].u64 | 1;
	// 82CE9DFC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CE9E00: 907E0108  stw r3, 0x108(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 82CE9E04: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE9E08: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CE9E0C: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CE9E10: FD20565E  fctidz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[10].f64.trunc() as i64 };
	// 82CE9E14: 7D2B2FAE  stfiwx f9, r11, r5
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82CE9E18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9E1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9E20: 419A0040  beq cr6, 0x82ce9e60
	if ctx.cr[6].eq {
	pc = 0x82CE9E60; continue 'dispatch;
	}
	// 82CE9E24: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9E28: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE9E2C: 409A0034  bne cr6, 0x82ce9e60
	if !ctx.cr[6].eq {
	pc = 0x82CE9E60; continue 'dispatch;
	}
	// 82CE9E30: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9E34: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9E38: 40820028  bne 0x82ce9e60
	if !ctx.cr[0].eq {
	pc = 0x82CE9E60; continue 'dispatch;
	}
	// 82CE9E3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE9E40: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9E44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE9E48: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE9E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9E50: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE9E54: 485D04E1  bl 0x832ba334
	ctx.lr = 0x82CE9E58;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE9E58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE9E5C: 485D04B9  bl 0x832ba314
	ctx.lr = 0x82CE9E60;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE9E60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9E64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CE9E68: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CE9E6C: 4BFBF5EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CE9E70 size=260
    let mut pc: u32 = 0x82CE9E70;
    'dispatch: loop {
        match pc {
            0x82CE9E70 => {
    //   block [0x82CE9E70..0x82CE9F74)
	// 82CE9E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9E74: 4BFBF595  bl 0x82ca9408
	ctx.lr = 0x82CE9E78;
	sub_82CA93D0(ctx, base);
	// 82CE9E78: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82CE9E7C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9E80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CE9E84: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82CE9E88: 485D047D  bl 0x832ba304
	ctx.lr = 0x82CE9E8C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CE9E8C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CE9E90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CE9E94: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CE9E98: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CE9E9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9EA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9EA4: 419A0010  beq cr6, 0x82ce9eb4
	if ctx.cr[6].eq {
	pc = 0x82CE9EB4; continue 'dispatch;
	}
	// 82CE9EA8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9EAC: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CE9EB0: 419A0018  beq cr6, 0x82ce9ec8
	if ctx.cr[6].eq {
	pc = 0x82CE9EC8; continue 'dispatch;
	}
	// 82CE9EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9EB8: 485D043D  bl 0x832ba2f4
	ctx.lr = 0x82CE9EBC;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CE9EBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9EC0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CE9EC4: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CE9EC8: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82CE9ECC: 397E00B8  addi r11, r30, 0xb8
	ctx.r[11].s64 = ctx.r[30].s64 + 184;
	// 82CE9ED0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CE9ED4: D3FE0074  stfs f31, 0x74(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82CE9ED8: 813E003C  lwz r9, 0x3c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CE9EDC: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82CE9EE0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CE9EE4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CE9EE8: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82CE9EEC: 891E0038  lbz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CE9EF0: 88FE0034  lbz r7, 0x34(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CE9EF4: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CE9EF8: 98FE00C4  stb r7, 0xc4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), ctx.r[7].u8 ) };
	// 82CE9EFC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82CE9F00: 991E00C5  stb r8, 0xc5(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(197 as u32), ctx.r[8].u8 ) };
	// 82CE9F04: 80BE0108  lwz r5, 0x108(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CE9F08: 60A40001  ori r4, r5, 1
	ctx.r[4].u64 = ctx.r[5].u64 | 1;
	// 82CE9F0C: ED6C07F2  fmuls f11, f12, f31
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82CE9F10: 909E0108  stw r4, 0x108(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), ctx.r[4].u32 ) };
	// 82CE9F14: FD405E5E  fctidz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82CE9F18: 7D4B37AE  stfiwx f10, r11, r6
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82CE9F1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CE9F20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9F24: 419A0040  beq cr6, 0x82ce9f64
	if ctx.cr[6].eq {
	pc = 0x82CE9F64; continue 'dispatch;
	}
	// 82CE9F28: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CE9F2C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CE9F30: 409A0034  bne cr6, 0x82ce9f64
	if !ctx.cr[6].eq {
	pc = 0x82CE9F64; continue 'dispatch;
	}
	// 82CE9F34: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CE9F38: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CE9F3C: 40820028  bne 0x82ce9f64
	if !ctx.cr[0].eq {
	pc = 0x82CE9F64; continue 'dispatch;
	}
	// 82CE9F40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CE9F44: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CE9F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CE9F4C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CE9F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CE9F54: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CE9F58: 485D03DD  bl 0x832ba334
	ctx.lr = 0x82CE9F5C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CE9F5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CE9F60: 485D03B5  bl 0x832ba314
	ctx.lr = 0x82CE9F64;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CE9F64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CE9F68: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CE9F6C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CE9F70: 4BFBF4E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F78 size=8
    let mut pc: u32 = 0x82CE9F78;
    'dispatch: loop {
        match pc {
            0x82CE9F78 => {
    //   block [0x82CE9F78..0x82CE9F80)
	// 82CE9F78: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9F7C: 4BFFFA34  b 0x82ce99b0
	sub_82CE99B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F80 size=8
    let mut pc: u32 = 0x82CE9F80;
    'dispatch: loop {
        match pc {
            0x82CE9F80 => {
    //   block [0x82CE9F80..0x82CE9F88)
	// 82CE9F80: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9F84: 4BFFFCAC  b 0x82ce9c30
	sub_82CE9C30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F88 size=8
    let mut pc: u32 = 0x82CE9F88;
    'dispatch: loop {
        match pc {
            0x82CE9F88 => {
    //   block [0x82CE9F88..0x82CE9F90)
	// 82CE9F88: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82CE9F8C: 4BFFF9F4  b 0x82ce9980
	sub_82CE9980(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F90 size=8
    let mut pc: u32 = 0x82CE9F90;
    'dispatch: loop {
        match pc {
            0x82CE9F90 => {
    //   block [0x82CE9F90..0x82CE9F98)
	// 82CE9F90: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9F94: 4BFFFA0C  b 0x82ce99a0
	sub_82CE99A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9F98 size=8
    let mut pc: u32 = 0x82CE9F98;
    'dispatch: loop {
        match pc {
            0x82CE9F98 => {
    //   block [0x82CE9F98..0x82CE9FA0)
	// 82CE9F98: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9F9C: 4BFFFA84  b 0x82ce9a20
	sub_82CE9A20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FA0 size=8
    let mut pc: u32 = 0x82CE9FA0;
    'dispatch: loop {
        match pc {
            0x82CE9FA0 => {
    //   block [0x82CE9FA0..0x82CE9FA8)
	// 82CE9FA0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FA4: 4BFFFA14  b 0x82ce99b8
	sub_82CE99B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FA8 size=8
    let mut pc: u32 = 0x82CE9FA8;
    'dispatch: loop {
        match pc {
            0x82CE9FA8 => {
    //   block [0x82CE9FA8..0x82CE9FB0)
	// 82CE9FA8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FAC: 4BFFFCE4  b 0x82ce9c90
	sub_82CE9C90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FB0 size=8
    let mut pc: u32 = 0x82CE9FB0;
    'dispatch: loop {
        match pc {
            0x82CE9FB0 => {
    //   block [0x82CE9FB0..0x82CE9FB8)
	// 82CE9FB0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FB4: 4BFFFBAC  b 0x82ce9b60
	sub_82CE9B60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FB8 size=8
    let mut pc: u32 = 0x82CE9FB8;
    'dispatch: loop {
        match pc {
            0x82CE9FB8 => {
    //   block [0x82CE9FB8..0x82CE9FC0)
	// 82CE9FB8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FBC: 4BFFFAFC  b 0x82ce9ab8
	sub_82CE9AB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FC0 size=8
    let mut pc: u32 = 0x82CE9FC0;
    'dispatch: loop {
        match pc {
            0x82CE9FC0 => {
    //   block [0x82CE9FC0..0x82CE9FC8)
	// 82CE9FC0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FC4: 4BFFFD94  b 0x82ce9d58
	sub_82CE9D58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FC8 size=8
    let mut pc: u32 = 0x82CE9FC8;
    'dispatch: loop {
        match pc {
            0x82CE9FC8 => {
    //   block [0x82CE9FC8..0x82CE9FD0)
	// 82CE9FC8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FCC: 4BFFF9FC  b 0x82ce99c8
	sub_82CE99C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FD0 size=8
    let mut pc: u32 = 0x82CE9FD0;
    'dispatch: loop {
        match pc {
            0x82CE9FD0 => {
    //   block [0x82CE9FD0..0x82CE9FD8)
	// 82CE9FD0: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82CE9FD4: 4BFFFBF4  b 0x82ce9bc8
	sub_82CE9BC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FD8 size=8
    let mut pc: u32 = 0x82CE9FD8;
    'dispatch: loop {
        match pc {
            0x82CE9FD8 => {
    //   block [0x82CE9FD8..0x82CE9FE0)
	// 82CE9FD8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FDC: 4BFFF9CC  b 0x82ce99a8
	sub_82CE99A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FE0 size=8
    let mut pc: u32 = 0x82CE9FE0;
    'dispatch: loop {
        match pc {
            0x82CE9FE0 => {
    //   block [0x82CE9FE0..0x82CE9FE8)
	// 82CE9FE0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FE4: 4BFFFE8C  b 0x82ce9e70
	sub_82CE9E70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CE9FE8 size=8
    let mut pc: u32 = 0x82CE9FE8;
    'dispatch: loop {
        match pc {
            0x82CE9FE8 => {
    //   block [0x82CE9FE8..0x82CE9FF0)
	// 82CE9FE8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CE9FEC: 4BFFF9EC  b 0x82ce99d8
	sub_82CE99D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CE9FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CE9FF0 size=208
    let mut pc: u32 = 0x82CE9FF0;
    'dispatch: loop {
        match pc {
            0x82CE9FF0 => {
    //   block [0x82CE9FF0..0x82CEA0C0)
	// 82CE9FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CE9FF4: 4BFBF411  bl 0x82ca9404
	ctx.lr = 0x82CE9FF8;
	sub_82CA93D0(ctx, base);
	// 82CE9FF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CE9FFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEA000: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82CEA004: 485D0301  bl 0x832ba304
	ctx.lr = 0x82CEA008;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA008: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA00C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA010: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA014: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CEA018: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA01C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA020: 419A0010  beq cr6, 0x82cea030
	if ctx.cr[6].eq {
	pc = 0x82CEA030; continue 'dispatch;
	}
	// 82CEA024: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA028: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA02C: 419A0018  beq cr6, 0x82cea044
	if ctx.cr[6].eq {
	pc = 0x82CEA044; continue 'dispatch;
	}
	// 82CEA030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA034: 485D02C1  bl 0x832ba2f4
	ctx.lr = 0x82CEA038;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA038: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA03C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CEA040: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CEA044: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA048: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CEA04C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA050: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA054: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA058: A0FE006C  lhz r7, 0x6c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82CEA05C: 7CC83B96  divwu r6, r8, r7
	ctx.r[6].u32 = ctx.r[8].u32 / ctx.r[7].u32;
	// 82CEA060: 913E0110  stw r9, 0x110(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(272 as u32), ctx.r[9].u32 ) };
	// 82CEA064: 0CC70000  twi 6, r7, 0
	// 82CEA068: 90DE0078  stw r6, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 82CEA06C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA070: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA074: 419A0040  beq cr6, 0x82cea0b4
	if ctx.cr[6].eq {
	pc = 0x82CEA0B4; continue 'dispatch;
	}
	// 82CEA078: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA07C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEA080: 409A0034  bne cr6, 0x82cea0b4
	if !ctx.cr[6].eq {
	pc = 0x82CEA0B4; continue 'dispatch;
	}
	// 82CEA084: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA088: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA08C: 40820028  bne 0x82cea0b4
	if !ctx.cr[0].eq {
	pc = 0x82CEA0B4; continue 'dispatch;
	}
	// 82CEA090: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEA094: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA09C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA0A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA0A4: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA0A8: 485D028D  bl 0x832ba334
	ctx.lr = 0x82CEA0AC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA0AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA0B0: 485D0265  bl 0x832ba314
	ctx.lr = 0x82CEA0B4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEA0B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEA0B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEA0BC: 4BFBF398  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEA0C0 size=244
    let mut pc: u32 = 0x82CEA0C0;
    'dispatch: loop {
        match pc {
            0x82CEA0C0 => {
    //   block [0x82CEA0C0..0x82CEA1B4)
	// 82CEA0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA0C4: 4BFBF345  bl 0x82ca9408
	ctx.lr = 0x82CEA0C8;
	sub_82CA93D0(ctx, base);
	// 82CEA0C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA0CC: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82CEA0D0: 485D0235  bl 0x832ba304
	ctx.lr = 0x82CEA0D4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA0D4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA0D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA0DC: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA0E0: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CEA0E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA0E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA0EC: 419A0010  beq cr6, 0x82cea0fc
	if ctx.cr[6].eq {
	pc = 0x82CEA0FC; continue 'dispatch;
	}
	// 82CEA0F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA0F4: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA0F8: 419A0018  beq cr6, 0x82cea110
	if ctx.cr[6].eq {
	pc = 0x82CEA110; continue 'dispatch;
	}
	// 82CEA0FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA100: 485D01F5  bl 0x832ba2f4
	ctx.lr = 0x82CEA104;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA104: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA108: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CEA10C: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CEA110: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA114: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA118: 895E009C  lbz r10, 0x9c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 82CEA11C: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82CEA120: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA124: 409A0010  bne cr6, 0x82cea134
	if !ctx.cr[6].eq {
	pc = 0x82CEA134; continue 'dispatch;
	}
	// 82CEA128: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82CEA12C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82CEA130: 48000018  b 0x82cea148
	pc = 0x82CEA148; continue 'dispatch;
	// 82CEA134: 554A077A  rlwinm r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA138: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA13C: 419A0024  beq cr6, 0x82cea160
	if ctx.cr[6].eq {
	pc = 0x82CEA160; continue 'dispatch;
	}
	// 82CEA140: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82CEA144: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82CEA148: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA14C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA150: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA154: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA158: 4E800421  bctrl
	ctx.lr = 0x82CEA15C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA15C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA160: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA164: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA168: 419A0040  beq cr6, 0x82cea1a8
	if ctx.cr[6].eq {
	pc = 0x82CEA1A8; continue 'dispatch;
	}
	// 82CEA16C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA170: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEA174: 409A0034  bne cr6, 0x82cea1a8
	if !ctx.cr[6].eq {
	pc = 0x82CEA1A8; continue 'dispatch;
	}
	// 82CEA178: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA17C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA180: 40820028  bne 0x82cea1a8
	if !ctx.cr[0].eq {
	pc = 0x82CEA1A8; continue 'dispatch;
	}
	// 82CEA184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA188: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA18C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEA190: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA198: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA19C: 485D0199  bl 0x832ba334
	ctx.lr = 0x82CEA1A0;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA1A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA1A4: 485D0171  bl 0x832ba314
	ctx.lr = 0x82CEA1A8;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEA1A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEA1AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEA1B0: 4BFBF2A8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEA1B8 size=308
    let mut pc: u32 = 0x82CEA1B8;
    'dispatch: loop {
        match pc {
            0x82CEA1B8 => {
    //   block [0x82CEA1B8..0x82CEA2EC)
	// 82CEA1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA1BC: 4BFBF249  bl 0x82ca9404
	ctx.lr = 0x82CEA1C0;
	sub_82CA93D0(ctx, base);
	// 82CEA1C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA1C4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82CEA1C8: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82CEA1CC: 485D0139  bl 0x832ba304
	ctx.lr = 0x82CEA1D0;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA1D0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA1D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA1D8: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA1DC: 7DBD6B78  mr r29, r13
	ctx.r[29].u64 = ctx.r[13].u64;
	// 82CEA1E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA1E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA1E8: 419A0010  beq cr6, 0x82cea1f8
	if ctx.cr[6].eq {
	pc = 0x82CEA1F8; continue 'dispatch;
	}
	// 82CEA1EC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA1F0: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA1F4: 419A0018  beq cr6, 0x82cea20c
	if ctx.cr[6].eq {
	pc = 0x82CEA20C; continue 'dispatch;
	}
	// 82CEA1F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA1FC: 485D00F9  bl 0x832ba2f4
	ctx.lr = 0x82CEA200;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA200: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA204: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82CEA208: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CEA20C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA210: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA214: 895E009C  lbz r10, 0x9c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 82CEA218: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82CEA21C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA220: 419A0078  beq cr6, 0x82cea298
	if ctx.cr[6].eq {
	pc = 0x82CEA298; continue 'dispatch;
	}
	// 82CEA224: 576907FE  clrlwi r9, r27, 0x1f
	ctx.r[9].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 82CEA228: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA22C: 409A004C  bne cr6, 0x82cea278
	if !ctx.cr[6].eq {
	pc = 0x82CEA278; continue 'dispatch;
	}
	// 82CEA230: 554906FC  rlwinm r9, r10, 0, 0x1b, 0x1e
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA234: 552907B6  rlwinm r9, r9, 0, 0x1e, 0x1b
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA238: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA23C: 409A003C  bne cr6, 0x82cea278
	if !ctx.cr[6].eq {
	pc = 0x82CEA278; continue 'dispatch;
	}
	// 82CEA240: 554A077A  rlwinm r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA248: 409A0050  bne cr6, 0x82cea298
	if !ctx.cr[6].eq {
	pc = 0x82CEA298; continue 'dispatch;
	}
	// 82CEA24C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA250: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82CEA254: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82CEA258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA25C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA260: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA264: 4E800421  bctrl
	ctx.lr = 0x82CEA268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA268: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEA26C: A1694E08  lhz r11, 0x4e08(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(19976 as u32) ) } as u64;
	// 82CEA270: B17E009E  sth r11, 0x9e(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(158 as u32), ctx.r[11].u16 ) };
	// 82CEA274: 48000020  b 0x82cea294
	pc = 0x82CEA294; continue 'dispatch;
	// 82CEA278: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA27C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CEA280: 38800057  li r4, 0x57
	ctx.r[4].s64 = 87;
	// 82CEA284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA288: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA28C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA290: 4E800421  bctrl
	ctx.lr = 0x82CEA294;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA294: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA298: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA29C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA2A0: 419A0040  beq cr6, 0x82cea2e0
	if ctx.cr[6].eq {
	pc = 0x82CEA2E0; continue 'dispatch;
	}
	// 82CEA2A4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA2A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEA2AC: 409A0034  bne cr6, 0x82cea2e0
	if !ctx.cr[6].eq {
	pc = 0x82CEA2E0; continue 'dispatch;
	}
	// 82CEA2B0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA2B4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA2B8: 40820028  bne 0x82cea2e0
	if !ctx.cr[0].eq {
	pc = 0x82CEA2E0; continue 'dispatch;
	}
	// 82CEA2BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA2C0: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA2C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEA2C8: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA2D0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA2D4: 485D0061  bl 0x832ba334
	ctx.lr = 0x82CEA2D8;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA2D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA2DC: 485D0039  bl 0x832ba314
	ctx.lr = 0x82CEA2E0;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEA2E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEA2E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEA2E8: 4BFBF16C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEA2F0 size=240
    let mut pc: u32 = 0x82CEA2F0;
    'dispatch: loop {
        match pc {
            0x82CEA2F0 => {
    //   block [0x82CEA2F0..0x82CEA3E0)
	// 82CEA2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA2F4: 4BFBF115  bl 0x82ca9408
	ctx.lr = 0x82CEA2F8;
	sub_82CA93D0(ctx, base);
	// 82CEA2F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA2FC: 3BA30010  addi r29, r3, 0x10
	ctx.r[29].s64 = ctx.r[3].s64 + 16;
	// 82CEA300: 485D0005  bl 0x832ba304
	ctx.lr = 0x82CEA304;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA304: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA308: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA30C: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA310: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEA314: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA318: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA31C: 419A0010  beq cr6, 0x82cea32c
	if ctx.cr[6].eq {
	pc = 0x82CEA32C; continue 'dispatch;
	}
	// 82CEA320: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA324: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEA328: 419A001C  beq cr6, 0x82cea344
	if ctx.cr[6].eq {
	pc = 0x82CEA344; continue 'dispatch;
	}
	// 82CEA32C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA330: 485CFFC5  bl 0x832ba2f4
	ctx.lr = 0x82CEA334;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA334: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CEA338: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA33C: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CEA340: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CEA344: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA348: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 82CEA34C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA350: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA354: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEA358: 419A0038  beq cr6, 0x82cea390
	if ctx.cr[6].eq {
	pc = 0x82CEA390; continue 'dispatch;
	}
	// 82CEA35C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA360: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82CEA364: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA368: 419A0028  beq cr6, 0x82cea390
	if ctx.cr[6].eq {
	pc = 0x82CEA390; continue 'dispatch;
	}
	// 82CEA36C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEA370: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82CEA374: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82CEA378: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA37C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA380: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA384: 4E800421  bctrl
	ctx.lr = 0x82CEA388;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA388: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA38C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA390: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA394: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA398: 419A003C  beq cr6, 0x82cea3d4
	if ctx.cr[6].eq {
	pc = 0x82CEA3D4; continue 'dispatch;
	}
	// 82CEA39C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEA3A0: 409A0034  bne cr6, 0x82cea3d4
	if !ctx.cr[6].eq {
	pc = 0x82CEA3D4; continue 'dispatch;
	}
	// 82CEA3A4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA3A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA3AC: 40820028  bne 0x82cea3d4
	if !ctx.cr[0].eq {
	pc = 0x82CEA3D4; continue 'dispatch;
	}
	// 82CEA3B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA3B4: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA3B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEA3BC: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA3C4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA3C8: 485CFF6D  bl 0x832ba334
	ctx.lr = 0x82CEA3CC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA3CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA3D0: 485CFF45  bl 0x832ba314
	ctx.lr = 0x82CEA3D4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEA3D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEA3D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEA3DC: 4BFBF07C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEA3E0 size=24
    let mut pc: u32 = 0x82CEA3E0;
    'dispatch: loop {
        match pc {
            0x82CEA3E0 => {
    //   block [0x82CEA3E0..0x82CEA3F8)
	// 82CEA3E0: 89630044  lbz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEA3E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEA3E8: 1D6B0078  mulli r11, r11, 0x78
	ctx.r[11].s64 = ctx.r[11].s64 * 120;
	// 82CEA3EC: 394B0114  addi r10, r11, 0x114
	ctx.r[10].s64 = ctx.r[11].s64 + 276;
	// 82CEA3F0: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEA3F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEA3F8 size=8
    let mut pc: u32 = 0x82CEA3F8;
    'dispatch: loop {
        match pc {
            0x82CEA3F8 => {
    //   block [0x82CEA3F8..0x82CEA400)
	// 82CEA3F8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CEA3FC: 4BFFFEF4  b 0x82cea2f0
	sub_82CEA2F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEA400 size=8
    let mut pc: u32 = 0x82CEA400;
    'dispatch: loop {
        match pc {
            0x82CEA400 => {
    //   block [0x82CEA400..0x82CEA408)
	// 82CEA400: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CEA404: 4BFFFDB4  b 0x82cea1b8
	sub_82CEA1B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEA408 size=8
    let mut pc: u32 = 0x82CEA408;
    'dispatch: loop {
        match pc {
            0x82CEA408 => {
    //   block [0x82CEA408..0x82CEA410)
	// 82CEA408: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82CEA40C: 4BFFFCB4  b 0x82cea0c0
	sub_82CEA0C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEA410 size=272
    let mut pc: u32 = 0x82CEA410;
    'dispatch: loop {
        match pc {
            0x82CEA410 => {
    //   block [0x82CEA410..0x82CEA520)
	// 82CEA410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA414: 4BFBEFF1  bl 0x82ca9404
	ctx.lr = 0x82CEA418;
	sub_82CA93D0(ctx, base);
	// 82CEA418: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEA420: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CEA424: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82CEA428: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82CEA42C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA430: 4BFF5A89  bl 0x82cdfeb8
	ctx.lr = 0x82CEA434;
	sub_82CDFEB8(ctx, base);
	// 82CEA434: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEA438: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEA43C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEA440: 3BDF00B8  addi r30, r31, 0xb8
	ctx.r[30].s64 = ctx.r[31].s64 + 184;
	// 82CEA444: 390B5000  addi r8, r11, 0x5000
	ctx.r[8].s64 = ctx.r[11].s64 + 20480;
	// 82CEA448: 38EA4FD8  addi r7, r10, 0x4fd8
	ctx.r[7].s64 = ctx.r[10].s64 + 20440;
	// 82CEA44C: 38C94F78  addi r6, r9, 0x4f78
	ctx.r[6].s64 = ctx.r[9].s64 + 20344;
	// 82CEA450: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82CEA454: 38A0004C  li r5, 0x4c
	ctx.r[5].s64 = 76;
	// 82CEA458: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CEA45C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEA460: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82CEA464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA468: 4BFBF549  bl 0x82ca99b0
	ctx.lr = 0x82CEA46C;
	sub_82CA99B0(ctx, base);
	// 82CEA46C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEA470: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CEA474: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82CEA478: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CEA47C: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82CEA480: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA484: 4BFF57C5  bl 0x82cdfc48
	ctx.lr = 0x82CEA488;
	sub_82CDFC48(ctx, base);
	// 82CEA488: 3C800000  lis r4, 0
	ctx.r[4].s64 = 0;
	// 82CEA48C: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEA490: 891C0045  lbz r8, 0x45(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEA494: 608BBB80  ori r11, r4, 0xbb80
	ctx.r[11].u64 = ctx.r[4].u64 | 48000;
	// 82CEA498: 88DF0038  lbz r6, 0x38(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEA49C: 3C608201  lis r3, -0x7dff
	ctx.r[3].s64 = -2113863680;
	// 82CEA4A0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82CEA4A4: 39435078  addi r10, r3, 0x5078
	ctx.r[10].s64 = ctx.r[3].s64 + 20600;
	// 82CEA4A8: 911F010C  stw r8, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[8].u32 ) };
	// 82CEA4AC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CEA4B0: 809F003C  lwz r4, 0x3c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEA4B4: 811F0108  lwz r8, 0x108(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82CEA4B8: 61070001  ori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 | 1;
	// 82CEA4BC: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82CEA4C0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CEA4C4: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CEA4C8: 887F0034  lbz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEA4CC: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CEA4D0: 98DF00C5  stb r6, 0xc5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(197 as u32), ctx.r[6].u8 ) };
	// 82CEA4D4: 54E6003E  slwi r6, r7, 0
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CEA4D8: 987F00C4  stb r3, 0xc4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[3].u8 ) };
	// 82CEA4DC: 90FF0108  stw r7, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[7].u32 ) };
	// 82CEA4E0: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CEA4E4: FD20565E  fctidz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[10].f64.trunc() as i64 };
	// 82CEA4E8: 7D3E2FAE  stfiwx f9, r30, r5
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82CEA4EC: 60C50002  ori r5, r6, 2
	ctx.r[5].u64 = ctx.r[6].u64 | 2;
	// 82CEA4F0: 917F00D8  stw r11, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 82CEA4F4: 90BF0108  stw r5, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[5].u32 ) };
	// 82CEA4F8: 889F00C5  lbz r4, 0xc5(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(197 as u32) ) } as u64;
	// 82CEA4FC: 887F00C4  lbz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82CEA500: 546B103E  rotlwi r11, r3, 2
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(2)) as u64;
	// 82CEA504: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEA508: 7D0A21D6  mullw r8, r10, r4
	ctx.r[8].s64 = (ctx.r[10].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CEA50C: B13F006E  sth r9, 0x6e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(110 as u32), ctx.r[9].u16 ) };
	// 82CEA510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA514: B11F006C  sth r8, 0x6c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[8].u16 ) };
	// 82CEA518: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEA51C: 4BFBEF38  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEA520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEA520 size=1808
    let mut pc: u32 = 0x82CEA520;
    'dispatch: loop {
        match pc {
            0x82CEA520 => {
    //   block [0x82CEA520..0x82CEAC30)
	// 82CEA520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEA524: 4BFBEED1  bl 0x82ca93f4
	ctx.lr = 0x82CEA528;
	sub_82CA93D0(ctx, base);
	// 82CEA528: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82CEA52C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEA530: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82CEA534: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82CEA538: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82CEA53C: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82CEA540: 3B85FFF8  addi r28, r5, -8
	ctx.r[28].s64 = ctx.r[5].s64 + -8;
	// 82CEA544: 409A0008  bne cr6, 0x82cea54c
	if !ctx.cr[6].eq {
	pc = 0x82CEA54C; continue 'dispatch;
	}
	// 82CEA548: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82CEA54C: 485CFDB9  bl 0x832ba304
	ctx.lr = 0x82CEA550;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA550: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEA554: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEA558: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEA55C: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEA560: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA564: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA568: 419A0010  beq cr6, 0x82cea578
	if ctx.cr[6].eq {
	pc = 0x82CEA578; continue 'dispatch;
	}
	// 82CEA56C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA570: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA574: 419A0018  beq cr6, 0x82cea58c
	if ctx.cr[6].eq {
	pc = 0x82CEA58C; continue 'dispatch;
	}
	// 82CEA578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA57C: 485CFD79  bl 0x832ba2f4
	ctx.lr = 0x82CEA580;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA580: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA584: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEA588: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEA58C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEA590: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEA594: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA598: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEA59C: 4BFF3FED  bl 0x82cde588
	ctx.lr = 0x82CEA5A0;
	sub_82CDE588(ctx, base);
	// 82CEA5A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEA5A4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEA5A8: 41980028  blt cr6, 0x82cea5d0
	if ctx.cr[6].lt {
	pc = 0x82CEA5D0; continue 'dispatch;
	}
	// 82CEA5AC: 897A0038  lbz r11, 0x38(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEA5B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82CEA5B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEA5B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEA5BC: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82CEA5C0: 4BFF4129  bl 0x82cde6e8
	ctx.lr = 0x82CEA5C4;
	sub_82CDE6E8(ctx, base);
	// 82CEA5C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEA5C8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEA5CC: 409800DC  bge cr6, 0x82cea6a8
	if !ctx.cr[6].lt {
	pc = 0x82CEA6A8; continue 'dispatch;
	}
	// 82CEA5D0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA5D4: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA5D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA5DC: 419A0040  beq cr6, 0x82cea61c
	if ctx.cr[6].eq {
	pc = 0x82CEA61C; continue 'dispatch;
	}
	// 82CEA5E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA5E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEA5E8: 409A0034  bne cr6, 0x82cea61c
	if !ctx.cr[6].eq {
	pc = 0x82CEA61C; continue 'dispatch;
	}
	// 82CEA5EC: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA5F0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA5F4: 40820028  bne 0x82cea61c
	if !ctx.cr[0].eq {
	pc = 0x82CEA61C; continue 'dispatch;
	}
	// 82CEA5F8: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEA5FC: 8BBF000C  lbz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA600: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEA604: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA60C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA610: 485CFD25  bl 0x832ba334
	ctx.lr = 0x82CEA614;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA618: 485CFCFD  bl 0x832ba314
	ctx.lr = 0x82CEA61C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEA61C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA620: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEA624: 409A0600  bne cr6, 0x82ceac24
	if !ctx.cr[6].eq {
	pc = 0x82CEAC24; continue 'dispatch;
	}
	// 82CEA628: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEA62C: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 82CEA630: 4BFF97F9  bl 0x82ce3e28
	ctx.lr = 0x82CEA634;
	sub_82CE3E28(ctx, base);
	// 82CEA634: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82CEA638: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82CEA63C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82CEA640: 419A0258  beq cr6, 0x82cea898
	if ctx.cr[6].eq {
	pc = 0x82CEA898; continue 'dispatch;
	}
	// 82CEA644: 817A00BC  lwz r11, 0xbc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(188 as u32) ) } as u64;
	// 82CEA648: 815A00C0  lwz r10, 0xc0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(192 as u32) ) } as u64;
	// 82CEA64C: 7D2A5851  subf. r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA650: 40820248  bne 0x82cea898
	if !ctx.cr[0].eq {
	pc = 0x82CEA898; continue 'dispatch;
	}
	// 82CEA654: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEA658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEA65C: 419A021C  beq cr6, 0x82cea878
	if ctx.cr[6].eq {
	pc = 0x82CEA878; continue 'dispatch;
	}
	// 82CEA660: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82CEA664: 419A000C  beq cr6, 0x82cea670
	if ctx.cr[6].eq {
	pc = 0x82CEA670; continue 'dispatch;
	}
	// 82CEA668: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82CEA66C: 91790010  stw r11, 0x10(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82CEA670: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEA674: 917A0078  stw r11, 0x78(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82CEA678: 817A00B4  lwz r11, 0xb4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(180 as u32) ) } as u64;
	// 82CEA67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEA680: 419A0218  beq cr6, 0x82cea898
	if ctx.cr[6].eq {
	pc = 0x82CEA898; continue 'dispatch;
	}
	// 82CEA684: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CEA68C: 81390024  lwz r9, 0x24(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEA690: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82CEA694: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CEA698: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82CEA69C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82CEA6A0: 4E800421  bctrl
	ctx.lr = 0x82CEA6A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA6A4: 480001F4  b 0x82cea898
	pc = 0x82CEA898; continue 'dispatch;
	// 82CEA6A8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82CEA6AC: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 82CEA6B0: 92FA00D4  stw r23, 0xd4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(212 as u32), ctx.r[23].u32 ) };
	// 82CEA6B4: 3BDA00B8  addi r30, r26, 0xb8
	ctx.r[30].s64 = ctx.r[26].s64 + 184;
	// 82CEA6B8: 915A00D0  stw r10, 0xd0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82CEA6BC: 917A00CC  stw r11, 0xcc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82CEA6C0: 897A00AC  lbz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CEA6C4: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEA6C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA6CC: 419A010C  beq cr6, 0x82cea7d8
	if ctx.cr[6].eq {
	pc = 0x82CEA7D8; continue 'dispatch;
	}
	// 82CEA6D0: 556A06F6  rlwinm r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA6D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA6D8: 409A0100  bne cr6, 0x82cea7d8
	if !ctx.cr[6].eq {
	pc = 0x82CEA7D8; continue 'dispatch;
	}
	// 82CEA6DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CEA6E0: 556907BC  rlwinm r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA6E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEA6E8: C3EA0C18  lfs f31, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82CEA6EC: 419A0050  beq cr6, 0x82cea73c
	if ctx.cr[6].eq {
	pc = 0x82CEA73C; continue 'dispatch;
	}
	// 82CEA6F0: C01A0070  lfs f0, 0x70(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEA6F4: 397E0034  addi r11, r30, 0x34
	ctx.r[11].s64 = ctx.r[30].s64 + 52;
	// 82CEA6F8: D01A00E0  stfs f0, 0xe0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82CEA6FC: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82CEA700: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEA704: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82CEA708: D1BE0024  stfs f13, 0x24(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEA70C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA710: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEA714: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CEA718: 4200FFF8  bdnz 0x82cea710
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82CEA710; continue 'dispatch;
	}
	// 82CEA71C: D3FE0030  stfs f31, 0x30(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82CEA720: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEA724: 387A0010  addi r3, r26, 0x10
	ctx.r[3].s64 = ctx.r[26].s64 + 16;
	// 82CEA728: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CEA72C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82CEA730: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEA734: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA738: 4E800421  bctrl
	ctx.lr = 0x82CEA73C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA73C: 897A00AC  lbz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CEA740: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEA744: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA748: 419A0040  beq cr6, 0x82cea788
	if ctx.cr[6].eq {
	pc = 0x82CEA788; continue 'dispatch;
	}
	// 82CEA74C: A15A00AE  lhz r10, 0xae(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(174 as u32) ) } as u64;
	// 82CEA750: C1BA00E0  lfs f13, 0xe0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEA754: 397A0010  addi r11, r26, 0x10
	ctx.r[11].s64 = ctx.r[26].s64 + 16;
	// 82CEA758: 3D2A0001  addis r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 65536;
	// 82CEA75C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82CEA760: 5528043E  clrlwi r8, r9, 0x10
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82CEA764: B11A00AE  sth r8, 0xae(r26)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[26].u32.wrapping_add(174 as u32), ctx.r[8].u16 ) };
	// 82CEA768: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CEA76C: 419A0014  beq cr6, 0x82cea780
	if ctx.cr[6].eq {
	pc = 0x82CEA780; continue 'dispatch;
	}
	// 82CEA770: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEA774: C00B4E0C  lfs f0, 0x4e0c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEA778: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CEA77C: 48000008  b 0x82cea784
	pc = 0x82CEA784; continue 'dispatch;
	// 82CEA780: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82CEA784: D01A00E0  stfs f0, 0xe0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82CEA788: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA78C: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA790: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA794: 419AFE94  beq cr6, 0x82cea628
	if ctx.cr[6].eq {
	pc = 0x82CEA628; continue 'dispatch;
	}
	// 82CEA798: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA79C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEA7A0: 409AFE88  bne cr6, 0x82cea628
	if !ctx.cr[6].eq {
	pc = 0x82CEA628; continue 'dispatch;
	}
	// 82CEA7A4: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA7A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA7AC: 4082FE7C  bne 0x82cea628
	if !ctx.cr[0].eq {
	pc = 0x82CEA628; continue 'dispatch;
	}
	// 82CEA7B0: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEA7B4: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA7B8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEA7BC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA7C4: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA7C8: 485CFB6D  bl 0x832ba334
	ctx.lr = 0x82CEA7CC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA7CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA7D0: 485CFB45  bl 0x832ba314
	ctx.lr = 0x82CEA7D4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEA7D4: 4BFFFE54  b 0x82cea628
	pc = 0x82CEA628; continue 'dispatch;
	// 82CEA7D8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CEA7DC: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEA7E0: 8BBE000D  lbz r29, 0xd(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CEA7E4: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEA7E8: 41820034  beq 0x82cea81c
	if ctx.cr[0].eq {
	pc = 0x82CEA81C; continue 'dispatch;
	}
	// 82CEA7EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82CEA7F0: 419A002C  beq cr6, 0x82cea81c
	if ctx.cr[6].eq {
	pc = 0x82CEA81C; continue 'dispatch;
	}
	// 82CEA7F4: 555B103A  slwi r27, r10, 2
	ctx.r[27].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82CEA7F8: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82CEA7FC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEA800: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CEA804: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEA808: 7C7C5A14  add r3, r28, r11
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82CEA80C: 4BFBF1A5  bl 0x82ca99b0
	ctx.lr = 0x82CEA810;
	sub_82CA99B0(ctx, base);
	// 82CEA810: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82CEA814: 3B9C0400  addi r28, r28, 0x400
	ctx.r[28].s64 = ctx.r[28].s64 + 1024;
	// 82CEA818: 4082FFE4  bne 0x82cea7fc
	if !ctx.cr[0].eq {
	pc = 0x82CEA7FC; continue 'dispatch;
	}
	// 82CEA81C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA820: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEA824: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA828: 419A0040  beq cr6, 0x82cea868
	if ctx.cr[6].eq {
	pc = 0x82CEA868; continue 'dispatch;
	}
	// 82CEA82C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA830: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEA834: 409A0034  bne cr6, 0x82cea868
	if !ctx.cr[6].eq {
	pc = 0x82CEA868; continue 'dispatch;
	}
	// 82CEA838: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA83C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA840: 40820028  bne 0x82cea868
	if !ctx.cr[0].eq {
	pc = 0x82CEA868; continue 'dispatch;
	}
	// 82CEA844: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEA848: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA84C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEA850: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA858: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA85C: 485CFAD9  bl 0x832ba334
	ctx.lr = 0x82CEA860;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEA864: 485CFAB1  bl 0x832ba314
	ctx.lr = 0x82CEA868;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEA868: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82CEA86C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82CEA870: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82CEA874: 4BFBEBD0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 82CEA878: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEA87C: 387A0010  addi r3, r26, 0x10
	ctx.r[3].s64 = ctx.r[26].s64 + 16;
	// 82CEA880: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CEA884: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82CEA888: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82CEA88C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEA890: 4E800421  bctrl
	ctx.lr = 0x82CEA894;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEA894: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82CEA898: 817A00D0  lwz r11, 0xd0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(208 as u32) ) } as u64;
	// 82CEA89C: 3B9A00B8  addi r28, r26, 0xb8
	ctx.r[28].s64 = ctx.r[26].s64 + 184;
	// 82CEA8A0: 815A00D4  lwz r10, 0xd4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 82CEA8A4: 7D2A5851  subf. r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA8A8: 418201F4  beq 0x82ceaa9c
	if ctx.cr[0].eq {
	pc = 0x82CEAA9C; continue 'dispatch;
	}
	// 82CEA8AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CEA8B0: 409A00EC  bne cr6, 0x82cea99c
	if !ctx.cr[6].eq {
	pc = 0x82CEA99C; continue 'dispatch;
	}
	// 82CEA8B4: 485CFA51  bl 0x832ba304
	ctx.lr = 0x82CEA8B8;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA8B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA8BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEA8C0: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEA8C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA8C8: 419A0010  beq cr6, 0x82cea8d8
	if ctx.cr[6].eq {
	pc = 0x82CEA8D8; continue 'dispatch;
	}
	// 82CEA8CC: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA8D0: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEA8D4: 419A001C  beq cr6, 0x82cea8f0
	if ctx.cr[6].eq {
	pc = 0x82CEA8F0; continue 'dispatch;
	}
	// 82CEA8D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA8DC: 485CFA19  bl 0x832ba2f4
	ctx.lr = 0x82CEA8E0;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEA8E0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CEA8E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA8E8: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEA8EC: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CEA8F0: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82CEA8F4: 397A0014  addi r11, r26, 0x14
	ctx.r[11].s64 = ctx.r[26].s64 + 20;
	// 82CEA8F8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82CEA8FC: 815A0014  lwz r10, 0x14(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEA900: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEA904: 419A0010  beq cr6, 0x82cea914
	if ctx.cr[6].eq {
	pc = 0x82CEA914; continue 'dispatch;
	}
	// 82CEA908: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA90C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CEA910: 48000008  b 0x82cea918
	pc = 0x82CEA918; continue 'dispatch;
	// 82CEA914: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEA918: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82CEA91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEA920: 419A0038  beq cr6, 0x82cea958
	if ctx.cr[6].eq {
	pc = 0x82CEA958; continue 'dispatch;
	}
	// 82CEA924: 894B0075  lbz r10, 0x75(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(117 as u32) ) } as u64;
	// 82CEA928: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEA92C: 409A002C  bne cr6, 0x82cea958
	if !ctx.cr[6].eq {
	pc = 0x82CEA958; continue 'dispatch;
	}
	// 82CEA930: 815A0110  lwz r10, 0x110(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(272 as u32) ) } as u64;
	// 82CEA934: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEA938: 419A000C  beq cr6, 0x82cea944
	if ctx.cr[6].eq {
	pc = 0x82CEA944; continue 'dispatch;
	}
	// 82CEA93C: 92FA0110  stw r23, 0x110(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(272 as u32), ctx.r[23].u32 ) };
	// 82CEA940: 4800000C  b 0x82cea94c
	pc = 0x82CEA94C; continue 'dispatch;
	// 82CEA944: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CEA948: 915A0078  stw r10, 0x78(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82CEA94C: 9B0B0075  stb r24, 0x75(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(117 as u32), ctx.r[24].u8 ) };
	// 82CEA950: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA954: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA958: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CEA95C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEA960: 419A003C  beq cr6, 0x82cea99c
	if ctx.cr[6].eq {
	pc = 0x82CEA99C; continue 'dispatch;
	}
	// 82CEA964: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEA968: 409A0034  bne cr6, 0x82cea99c
	if !ctx.cr[6].eq {
	pc = 0x82CEA99C; continue 'dispatch;
	}
	// 82CEA96C: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEA970: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA974: 40820028  bne 0x82cea99c
	if !ctx.cr[0].eq {
	pc = 0x82CEA99C; continue 'dispatch;
	}
	// 82CEA978: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEA97C: 8BBF000C  lbz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEA980: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEA984: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEA988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEA98C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEA990: 485CF9A5  bl 0x832ba334
	ctx.lr = 0x82CEA994;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEA994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEA998: 485CF97D  bl 0x832ba314
	ctx.lr = 0x82CEA99C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEA99C: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 82CEA9A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CEA9A4: 419A00F8  beq cr6, 0x82ceaa9c
	if ctx.cr[6].eq {
	pc = 0x82CEAA9C; continue 'dispatch;
	}
	// 82CEA9A8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEA9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEA9B0: 419A000C  beq cr6, 0x82cea9bc
	if ctx.cr[6].eq {
	pc = 0x82CEA9BC; continue 'dispatch;
	}
	// 82CEA9B4: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEA9B8: 48000008  b 0x82cea9c0
	pc = 0x82CEA9C0; continue 'dispatch;
	// 82CEA9BC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CEA9C0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEA9C4: 837A0078  lwz r27, 0x78(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) } as u64;
	// 82CEA9C8: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEA9CC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEA9D0: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEA9D4: 40980008  bge cr6, 0x82cea9dc
	if !ctx.cr[6].lt {
	pc = 0x82CEA9DC; continue 'dispatch;
	}
	// 82CEA9D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82CEA9DC: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82CEA9E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEA9E4: 4800357D  bl 0x82cedf60
	ctx.lr = 0x82CEA9E8;
	sub_82CEDF60(ctx, base);
	// 82CEA9E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEA9EC: 485CF919  bl 0x832ba304
	ctx.lr = 0x82CEA9F0;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEA9F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEA9F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEA9F8: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEA9FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEAA00: 419A0010  beq cr6, 0x82ceaa10
	if ctx.cr[6].eq {
	pc = 0x82CEAA10; continue 'dispatch;
	}
	// 82CEAA04: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAA08: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEAA0C: 419A0018  beq cr6, 0x82ceaa24
	if ctx.cr[6].eq {
	pc = 0x82CEAA24; continue 'dispatch;
	}
	// 82CEAA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAA14: 485CF8E1  bl 0x832ba2f4
	ctx.lr = 0x82CEAA18;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEAA18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAA1C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEAA20: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEAA24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEAA28: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEAA2C: 817A0078  lwz r11, 0x78(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) } as u64;
	// 82CEAA30: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEAA34: 409A000C  bne cr6, 0x82ceaa40
	if !ctx.cr[6].eq {
	pc = 0x82CEAA40; continue 'dispatch;
	}
	// 82CEAA38: 7D7CDA14  add r11, r28, r27
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82CEAA3C: 917A0078  stw r11, 0x78(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82CEAA40: 817A00A8  lwz r11, 0xa8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(168 as u32) ) } as u64;
	// 82CEAA44: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEAA48: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82CEAA4C: 917A00A8  stw r11, 0xa8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82CEAA50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAA54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEAA58: 419AFBE0  beq cr6, 0x82cea638
	if ctx.cr[6].eq {
	pc = 0x82CEA638; continue 'dispatch;
	}
	// 82CEAA5C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAA60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEAA64: 409AFBD4  bne cr6, 0x82cea638
	if !ctx.cr[6].eq {
	pc = 0x82CEA638; continue 'dispatch;
	}
	// 82CEAA68: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEAA6C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEAA70: 4082FBC8  bne 0x82cea638
	if !ctx.cr[0].eq {
	pc = 0x82CEA638; continue 'dispatch;
	}
	// 82CEAA74: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEAA78: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEAA7C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEAA80: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEAA84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAA88: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEAA8C: 485CF8A9  bl 0x832ba334
	ctx.lr = 0x82CEAA90;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEAA90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEAA94: 485CF881  bl 0x832ba314
	ctx.lr = 0x82CEAA98;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEAA98: 4BFFFBA0  b 0x82cea638
	pc = 0x82CEA638; continue 'dispatch;
	// 82CEAA9C: 485CF869  bl 0x832ba304
	ctx.lr = 0x82CEAAA0;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEAAA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAAA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEAAA8: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEAAAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEAAB0: 419A0010  beq cr6, 0x82ceaac0
	if ctx.cr[6].eq {
	pc = 0x82CEAAC0; continue 'dispatch;
	}
	// 82CEAAB4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAAB8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEAABC: 419A0018  beq cr6, 0x82ceaad4
	if ctx.cr[6].eq {
	pc = 0x82CEAAD4; continue 'dispatch;
	}
	// 82CEAAC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAAC4: 485CF831  bl 0x832ba2f4
	ctx.lr = 0x82CEAAC8;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEAAC8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAACC: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEAAD0: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEAAD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEAAD8: 3BDA00B8  addi r30, r26, 0xb8
	ctx.r[30].s64 = ctx.r[26].s64 + 184;
	// 82CEAADC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEAAE0: C01A00E0  lfs f0, 0xe0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEAAE4: D01A00DC  stfs f0, 0xdc(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82CEAAE8: 8BBA00C5  lbz r29, 0xc5(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(197 as u32) ) } as u64;
	// 82CEAAEC: 817A00D4  lwz r11, 0xd4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 82CEAAF0: 815A00D0  lwz r10, 0xd0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(208 as u32) ) } as u64;
	// 82CEAAF4: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEAAF8: 4182009C  beq 0x82ceab94
	if ctx.cr[0].eq {
	pc = 0x82CEAB94; continue 'dispatch;
	}
	// 82CEAAFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82CEAB00: 419A002C  beq cr6, 0x82ceab2c
	if ctx.cr[6].eq {
	pc = 0x82CEAB2C; continue 'dispatch;
	}
	// 82CEAB04: 555B103A  slwi r27, r10, 2
	ctx.r[27].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82CEAB08: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82CEAB0C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEAB10: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CEAB14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEAB18: 7C7C5A14  add r3, r28, r11
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82CEAB1C: 4BFBEE95  bl 0x82ca99b0
	ctx.lr = 0x82CEAB20;
	sub_82CA99B0(ctx, base);
	// 82CEAB20: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82CEAB24: 3B9C0400  addi r28, r28, 0x400
	ctx.r[28].s64 = ctx.r[28].s64 + 1024;
	// 82CEAB28: 4082FFE4  bne 0x82ceab0c
	if !ctx.cr[0].eq {
	pc = 0x82CEAB0C; continue 'dispatch;
	}
	// 82CEAB2C: 897A00AC  lbz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CEAB30: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEAB34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEAB38: 409A0044  bne cr6, 0x82ceab7c
	if !ctx.cr[6].eq {
	pc = 0x82CEAB7C; continue 'dispatch;
	}
	// 82CEAB3C: 815A0014  lwz r10, 0x14(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEAB40: 397A0014  addi r11, r26, 0x14
	ctx.r[11].s64 = ctx.r[26].s64 + 20;
	// 82CEAB44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEAB48: 419A0014  beq cr6, 0x82ceab5c
	if ctx.cr[6].eq {
	pc = 0x82CEAB5C; continue 'dispatch;
	}
	// 82CEAB4C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAB50: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CEAB54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEAB58: 409A003C  bne cr6, 0x82ceab94
	if !ctx.cr[6].eq {
	pc = 0x82CEAB94; continue 'dispatch;
	}
	// 82CEAB5C: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEAB60: 387A0010  addi r3, r26, 0x10
	ctx.r[3].s64 = ctx.r[26].s64 + 16;
	// 82CEAB64: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82CEAB68: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82CEAB6C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEAB70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAB74: 4E800421  bctrl
	ctx.lr = 0x82CEAB78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAB78: 4800001C  b 0x82ceab94
	pc = 0x82CEAB94; continue 'dispatch;
	// 82CEAB7C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAB80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEAB84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82CEAB88: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEAB8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAB90: 4E800421  bctrl
	ctx.lr = 0x82CEAB94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAB94: 897A00AC  lbz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 82CEAB98: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEAB9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEABA0: 419A0034  beq cr6, 0x82ceabd4
	if ctx.cr[6].eq {
	pc = 0x82CEABD4; continue 'dispatch;
	}
	// 82CEABA4: A15A00AE  lhz r10, 0xae(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(174 as u32) ) } as u64;
	// 82CEABA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEABAC: 419A0010  beq cr6, 0x82ceabbc
	if ctx.cr[6].eq {
	pc = 0x82CEABBC; continue 'dispatch;
	}
	// 82CEABB0: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEABB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEABB8: 419A001C  beq cr6, 0x82ceabd4
	if ctx.cr[6].eq {
	pc = 0x82CEABD4; continue 'dispatch;
	}
	// 82CEABBC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEABC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEABC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82CEABC8: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEABCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEABD0: 4E800421  bctrl
	ctx.lr = 0x82CEABD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEABD4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEABD8: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEABDC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CEABE0: 419A0040  beq cr6, 0x82ceac20
	if ctx.cr[6].eq {
	pc = 0x82CEAC20; continue 'dispatch;
	}
	// 82CEABE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEABE8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEABEC: 409A0034  bne cr6, 0x82ceac20
	if !ctx.cr[6].eq {
	pc = 0x82CEAC20; continue 'dispatch;
	}
	// 82CEABF0: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEABF4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEABF8: 40820028  bne 0x82ceac20
	if !ctx.cr[0].eq {
	pc = 0x82CEAC20; continue 'dispatch;
	}
	// 82CEABFC: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82CEAC00: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEAC04: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82CEAC08: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEAC0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAC10: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEAC14: 485CF721  bl 0x832ba334
	ctx.lr = 0x82CEAC18;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEAC18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEAC1C: 485CF6F9  bl 0x832ba314
	ctx.lr = 0x82CEAC20;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEAC20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEAC24: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82CEAC28: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82CEAC2C: 4BFBE818  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAC30 size=112
    let mut pc: u32 = 0x82CEAC30;
    'dispatch: loop {
        match pc {
            0x82CEAC30 => {
    //   block [0x82CEAC30..0x82CEACA0)
	// 82CEAC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAC34: 4BFBE7D9  bl 0x82ca940c
	ctx.lr = 0x82CEAC38;
	sub_82CA93D0(ctx, base);
	// 82CEAC38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAC3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEAC40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEAC44: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CEAC48: 38800114  li r4, 0x114
	ctx.r[4].s64 = 276;
	// 82CEAC4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAC50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAC54: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEAC58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAC5C: 4E800421  bctrl
	ctx.lr = 0x82CEAC60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAC60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEAC64: 419A002C  beq cr6, 0x82ceac90
	if ctx.cr[6].eq {
	pc = 0x82CEAC90; continue 'dispatch;
	}
	// 82CEAC68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CEAC6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CEAC70: 4BFFF7A1  bl 0x82cea410
	ctx.lr = 0x82CEAC74;
	sub_82CEA410(ctx, base);
	// 82CEAC74: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CEAC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEAC7C: 419A0014  beq cr6, 0x82ceac90
	if ctx.cr[6].eq {
	pc = 0x82CEAC90; continue 'dispatch;
	}
	// 82CEAC80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEAC84: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEAC88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEAC8C: 4BFBE7D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82CEAC90: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEAC94: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEAC98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEAC9C: 4BFBE7C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEACA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEACA0 size=112
    let mut pc: u32 = 0x82CEACA0;
    'dispatch: loop {
        match pc {
            0x82CEACA0 => {
    //   block [0x82CEACA0..0x82CEAD10)
	// 82CEACA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEACA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEACA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEACAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEACB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEACB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEACB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEACBC: 394B5088  addi r10, r11, 0x5088
	ctx.r[10].s64 = ctx.r[11].s64 + 20616;
	// 82CEACC0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEACC4: 48001E2D  bl 0x82cecaf0
	ctx.lr = 0x82CEACC8;
	sub_82CECAF0(ctx, base);
	// 82CEACC8: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEACCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEACD0: 419A0024  beq cr6, 0x82ceacf4
	if ctx.cr[6].eq {
	pc = 0x82CEACF4; continue 'dispatch;
	}
	// 82CEACD4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEACD8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82CEACDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEACE0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEACE4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEACE8: 4E800421  bctrl
	ctx.lr = 0x82CEACEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEACEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CEACF0: 911F0044  stw r8, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[8].u32 ) };
	// 82CEACF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEACF8: 480016D9  bl 0x82cec3d0
	ctx.lr = 0x82CEACFC;
	sub_82CEC3D0(ctx, base);
	// 82CEACFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEAD00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAD04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAD08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAD0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAD10 size=92
    let mut pc: u32 = 0x82CEAD10;
    'dispatch: loop {
        match pc {
            0x82CEAD10 => {
    //   block [0x82CEAD10..0x82CEAD6C)
	// 82CEAD10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAD14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAD18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEAD1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAD20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAD24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAD28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEAD2C: 480022BD  bl 0x82cecfe8
	ctx.lr = 0x82CEAD30;
	sub_82CECFE8(ctx, base);
	// 82CEAD30: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEAD34: 41980020  blt cr6, 0x82cead54
	if ctx.cr[6].lt {
	pc = 0x82CEAD54; continue 'dispatch;
	}
	// 82CEAD38: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEAD3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CEAD40: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAD44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAD48: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEAD4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAD50: 4E800421  bctrl
	ctx.lr = 0x82CEAD54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAD54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEAD58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAD5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAD60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEAD64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAD68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEAD70 size=12
    let mut pc: u32 = 0x82CEAD70;
    'dispatch: loop {
        match pc {
            0x82CEAD70 => {
    //   block [0x82CEAD70..0x82CEAD7C)
	// 82CEAD70: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEAD74: 806B72AC  lwz r3, 0x72ac(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEAD78: 4BFF6E98  b 0x82ce1c10
	sub_82CE1C10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAD80 size=128
    let mut pc: u32 = 0x82CEAD80;
    'dispatch: loop {
        match pc {
            0x82CEAD80 => {
    //   block [0x82CEAD80..0x82CEAE00)
	// 82CEAD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAD88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEAD8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAD90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAD94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEAD98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEAD9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEADA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEADA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEADA8: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEADAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEADB0: 4E800421  bctrl
	ctx.lr = 0x82CEADB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEADB4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEADB8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CEADBC: 41980028  blt cr6, 0x82ceade4
	if ctx.cr[6].lt {
	pc = 0x82CEADE4; continue 'dispatch;
	}
	// 82CEADC0: 419A0010  beq cr6, 0x82ceadd0
	if ctx.cr[6].eq {
	pc = 0x82CEADD0; continue 'dispatch;
	}
	// 82CEADC4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82CEADC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEADCC: 4800001C  b 0x82ceade8
	pc = 0x82CEADE8; continue 'dispatch;
	// 82CEADD0: 897F004C  lbz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CEADD4: 815E007C  lwz r10, 0x7c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82CEADD8: 1D6B002C  mulli r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 * 44;
	// 82CEADDC: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEADE0: 48000008  b 0x82ceade8
	pc = 0x82CEADE8; continue 'dispatch;
	// 82CEADE4: 387E0050  addi r3, r30, 0x50
	ctx.r[3].s64 = ctx.r[30].s64 + 80;
	// 82CEADE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEADEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEADF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEADF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEADF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEADFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAE00 size=48
    let mut pc: u32 = 0x82CEAE00;
    'dispatch: loop {
        match pc {
            0x82CEAE00 => {
    //   block [0x82CEAE00..0x82CEAE30)
	// 82CEAE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAE04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAE08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAE0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAE10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAE14: 4BFFFE8D  bl 0x82ceaca0
	ctx.lr = 0x82CEAE18;
	sub_82CEACA0(ctx, base);
	// 82CEAE18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAE1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEAE20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAE24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAE28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAE2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAE30 size=296
    let mut pc: u32 = 0x82CEAE30;
    'dispatch: loop {
        match pc {
            0x82CEAE30 => {
    //   block [0x82CEAE30..0x82CEAF58)
	// 82CEAE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAE38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEAE3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAE40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAE44: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82CEAE48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEAE4C: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82CEAE50: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82CEAE54: 6148BB80  ori r8, r10, 0xbb80
	ctx.r[8].u64 = ctx.r[10].u64 | 48000;
	// 82CEAE58: FBCB0000  std r30, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 82CEAE5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAE60: FBCB0008  std r30, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u64 ) };
	// 82CEAE64: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CEAE68: FBCB0010  std r30, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u64 ) };
	// 82CEAE6C: 9BC10060  stb r30, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 82CEAE70: 99210061  stb r9, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[9].u8 ) };
	// 82CEAE74: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82CEAE78: 419A001C  beq cr6, 0x82ceae94
	if ctx.cr[6].eq {
	pc = 0x82CEAE94; continue 'dispatch;
	}
	// 82CEAE7C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAE80: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEAE84: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAE88: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82CEAE8C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82CEAE90: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82CEAE94: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82CEAE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAE9C: 48002015  bl 0x82ceceb0
	ctx.lr = 0x82CEAEA0;
	sub_82CECEB0(ctx, base);
	// 82CEAEA0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEAEA4: 4198009C  blt cr6, 0x82ceaf40
	if ctx.cr[6].lt {
	pc = 0x82CEAF40; continue 'dispatch;
	}
	// 82CEAEA8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82CEAEAC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAEB0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82CEAEB4: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82CEAEB8: FBCB0000  std r30, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 82CEAEBC: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEAEC0: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82CEAEC4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82CEAEC8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAECC: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEAED0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEAED4: 4E800421  bctrl
	ctx.lr = 0x82CEAED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEAEDC: 419A0014  beq cr6, 0x82ceaef0
	if ctx.cr[6].eq {
	pc = 0x82CEAEF0; continue 'dispatch;
	}
	// 82CEAEE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEAEE4: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAEE8: 4BFF3CD9  bl 0x82cdebc0
	ctx.lr = 0x82CEAEEC;
	sub_82CDEBC0(ctx, base);
	// 82CEAEEC: 48000008  b 0x82ceaef4
	pc = 0x82CEAEF4; continue 'dispatch;
	// 82CEAEF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEAEF4: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82CEAEF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEAEFC: 409A0010  bne cr6, 0x82ceaf0c
	if !ctx.cr[6].eq {
	pc = 0x82CEAF0C; continue 'dispatch;
	}
	// 82CEAF00: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEAF04: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEAF08: 48000038  b 0x82ceaf40
	pc = 0x82CEAF40; continue 'dispatch;
	// 82CEAF0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAF10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEAF14: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEAF18: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEAF1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAF20: 4E800421  bctrl
	ctx.lr = 0x82CEAF24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAF24: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEAF28: 41980018  blt cr6, 0x82ceaf40
	if ctx.cr[6].lt {
	pc = 0x82CEAF40; continue 'dispatch;
	}
	// 82CEAF2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEAF30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAF34: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEAF38: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEAF3C: 4E800421  bctrl
	ctx.lr = 0x82CEAF40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEAF40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEAF44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAF48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAF4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEAF50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAF54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAF58 size=84
    let mut pc: u32 = 0x82CEAF58;
    'dispatch: loop {
        match pc {
            0x82CEAF58 => {
    //   block [0x82CEAF58..0x82CEAFAC)
	// 82CEAF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAF60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEAF64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAF68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAF6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEAF70: 48001291  bl 0x82cec200
	ctx.lr = 0x82CEAF74;
	sub_82CEC200(ctx, base);
	// 82CEAF74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAF78: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82CEAF7C: 41980014  blt cr6, 0x82ceaf90
	if ctx.cr[6].lt {
	pc = 0x82CEAF90; continue 'dispatch;
	}
	// 82CEAF80: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82CEAF84: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CEAF88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEAF8C: 4BFF3885  bl 0x82cde810
	ctx.lr = 0x82CEAF90;
	sub_82CDE810(ctx, base);
	// 82CEAF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEAF94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEAF98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAF9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAFA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEAFA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAFA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEAFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEAFB0 size=104
    let mut pc: u32 = 0x82CEAFB0;
    'dispatch: loop {
        match pc {
            0x82CEAFB0 => {
    //   block [0x82CEAFB0..0x82CEB018)
	// 82CEAFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEAFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEAFB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEAFBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEAFC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEAFC4: 897F003D  lbz r11, 0x3d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEAFC8: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEAFCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEAFD0: 419A001C  beq cr6, 0x82ceafec
	if ctx.cr[6].eq {
	pc = 0x82CEAFEC; continue 'dispatch;
	}
	// 82CEAFD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEAFD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEAFDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEAFE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEAFE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEAFE8: 4E800020  blr
	return;
	// 82CEAFEC: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82CEAFF0: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CEAFF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEAFF8: 4BFF3819  bl 0x82cde810
	ctx.lr = 0x82CEAFFC;
	sub_82CDE810(ctx, base);
	// 82CEAFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB000: 480018C9  bl 0x82cec8c8
	ctx.lr = 0x82CEB004;
	sub_82CEC8C8(ctx, base);
	// 82CEB004: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB00C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB018 size=224
    let mut pc: u32 = 0x82CEB018;
    'dispatch: loop {
        match pc {
            0x82CEB018 => {
    //   block [0x82CEB018..0x82CEB0F8)
	// 82CEB018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB01C: 4BFBE3ED  bl 0x82ca9408
	ctx.lr = 0x82CEB020;
	sub_82CA93D0(ctx, base);
	// 82CEB020: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB024: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEB028: 485CF2DD  bl 0x832ba304
	ctx.lr = 0x82CEB02C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEB02C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB030: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEB034: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEB038: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEB03C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB040: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEB044: 419A0010  beq cr6, 0x82ceb054
	if ctx.cr[6].eq {
	pc = 0x82CEB054; continue 'dispatch;
	}
	// 82CEB048: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB04C: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEB050: 419A001C  beq cr6, 0x82ceb06c
	if ctx.cr[6].eq {
	pc = 0x82CEB06C; continue 'dispatch;
	}
	// 82CEB054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB058: 485CF29D  bl 0x832ba2f4
	ctx.lr = 0x82CEB05C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEB05C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CEB060: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB064: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEB068: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CEB06C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CEB070: 397C0018  addi r11, r28, 0x18
	ctx.r[11].s64 = ctx.r[28].s64 + 24;
	// 82CEB074: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEB078: 813C0018  lwz r9, 0x18(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEB07C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEB080: 419A0028  beq cr6, 0x82ceb0a8
	if ctx.cr[6].eq {
	pc = 0x82CEB0A8; continue 'dispatch;
	}
	// 82CEB084: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB088: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEB08C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB090: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB094: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB098: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB09C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB0A0: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB0A4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB0A8: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CEB0AC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEB0B0: 419A003C  beq cr6, 0x82ceb0ec
	if ctx.cr[6].eq {
	pc = 0x82CEB0EC; continue 'dispatch;
	}
	// 82CEB0B4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEB0B8: 409A0034  bne cr6, 0x82ceb0ec
	if !ctx.cr[6].eq {
	pc = 0x82CEB0EC; continue 'dispatch;
	}
	// 82CEB0BC: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEB0C0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB0C4: 40820028  bne 0x82ceb0ec
	if !ctx.cr[0].eq {
	pc = 0x82CEB0EC; continue 'dispatch;
	}
	// 82CEB0C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB0CC: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB0D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEB0D4: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEB0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB0DC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEB0E0: 485CF255  bl 0x832ba334
	ctx.lr = 0x82CEB0E4;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEB0E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEB0E8: 485CF22D  bl 0x832ba314
	ctx.lr = 0x82CEB0EC;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEB0EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB0F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB0F4: 4BFBE364  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB0F8 size=148
    let mut pc: u32 = 0x82CEB0F8;
    'dispatch: loop {
        match pc {
            0x82CEB0F8 => {
    //   block [0x82CEB0F8..0x82CEB18C)
	// 82CEB0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB0FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB104: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB108: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82CEB10C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB110: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82CEB114: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82CEB118: 6127BB80  ori r7, r9, 0xbb80
	ctx.r[7].u64 = ctx.r[9].u64 | 48000;
	// 82CEB11C: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82CEB120: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEB124: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82CEB128: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEB12C: F96A0010  std r11, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 82CEB130: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82CEB134: 99010061  stb r8, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[8].u8 ) };
	// 82CEB138: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82CEB13C: 419A001C  beq cr6, 0x82ceb158
	if ctx.cr[6].eq {
	pc = 0x82CEB158; continue 'dispatch;
	}
	// 82CEB140: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB144: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB148: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB14C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82CEB150: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82CEB154: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82CEB158: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEB15C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82CEB160: 48001189  bl 0x82cec2e8
	ctx.lr = 0x82CEB164;
	sub_82CEC2E8(ctx, base);
	// 82CEB164: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB168: 41980010  blt cr6, 0x82ceb178
	if ctx.cr[6].lt {
	pc = 0x82CEB178; continue 'dispatch;
	}
	// 82CEB16C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB170: 394B001C  addi r10, r11, 0x1c
	ctx.r[10].s64 = ctx.r[11].s64 + 28;
	// 82CEB174: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEB178: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEB17C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB184: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB190 size=240
    let mut pc: u32 = 0x82CEB190;
    'dispatch: loop {
        match pc {
            0x82CEB190 => {
    //   block [0x82CEB190..0x82CEB280)
	// 82CEB190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB194: 4BFBE271  bl 0x82ca9404
	ctx.lr = 0x82CEB198;
	sub_82CA93D0(ctx, base);
	// 82CEB198: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB19C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB1A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEB1A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CEB1A8: 806B72AC  lwz r3, 0x72ac(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEB1AC: 4BFFFBD5  bl 0x82cead80
	ctx.lr = 0x82CEB1B0;
	sub_82CEAD80(ctx, base);
	// 82CEB1B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82CEB1B4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CEB1B8: 419A00BC  beq cr6, 0x82ceb274
	if ctx.cr[6].eq {
	pc = 0x82CEB274; continue 'dispatch;
	}
	// 82CEB1BC: 485CF149  bl 0x832ba304
	ctx.lr = 0x82CEB1C0;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEB1C0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB1C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEB1C8: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEB1CC: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEB1D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB1D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEB1D8: 419A0010  beq cr6, 0x82ceb1e8
	if ctx.cr[6].eq {
	pc = 0x82CEB1E8; continue 'dispatch;
	}
	// 82CEB1DC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB1E0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEB1E4: 419A0018  beq cr6, 0x82ceb1fc
	if ctx.cr[6].eq {
	pc = 0x82CEB1FC; continue 'dispatch;
	}
	// 82CEB1E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB1EC: 485CF109  bl 0x832ba2f4
	ctx.lr = 0x82CEB1F0;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEB1F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB1F4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEB1F8: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEB1FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEB200: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEB204: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB208: 813B0028  lwz r9, 0x28(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEB20C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB210: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82CEB214: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB218: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB21C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEB220: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB224: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB228: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB22C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB230: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEB234: 419A0040  beq cr6, 0x82ceb274
	if ctx.cr[6].eq {
	pc = 0x82CEB274; continue 'dispatch;
	}
	// 82CEB238: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB23C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEB240: 409A0034  bne cr6, 0x82ceb274
	if !ctx.cr[6].eq {
	pc = 0x82CEB274; continue 'dispatch;
	}
	// 82CEB244: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEB248: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEB24C: 40820028  bne 0x82ceb274
	if !ctx.cr[0].eq {
	pc = 0x82CEB274; continue 'dispatch;
	}
	// 82CEB250: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEB254: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB25C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEB260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB264: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEB268: 485CF0CD  bl 0x832ba334
	ctx.lr = 0x82CEB26C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEB26C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEB270: 485CF0A5  bl 0x832ba314
	ctx.lr = 0x82CEB274;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEB274: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB278: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB27C: 4BFBE1D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB280 size=264
    let mut pc: u32 = 0x82CEB280;
    'dispatch: loop {
        match pc {
            0x82CEB280 => {
    //   block [0x82CEB280..0x82CEB388)
	// 82CEB280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB284: 4BFBE185  bl 0x82ca9408
	ctx.lr = 0x82CEB288;
	sub_82CA93D0(ctx, base);
	// 82CEB288: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB28C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB290: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CEB294: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CEB298: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82CEB29C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEB2A0: 4BFFFE59  bl 0x82ceb0f8
	ctx.lr = 0x82CEB2A4;
	sub_82CEB0F8(ctx, base);
	// 82CEB2A4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB2A8: 41980010  blt cr6, 0x82ceb2b8
	if ctx.cr[6].lt {
	pc = 0x82CEB2B8; continue 'dispatch;
	}
	// 82CEB2AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEB2B0: 388B0048  addi r4, r11, 0x48
	ctx.r[4].s64 = ctx.r[11].s64 + 72;
	// 82CEB2B4: 48000008  b 0x82ceb2bc
	pc = 0x82CEB2BC; continue 'dispatch;
	// 82CEB2B8: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEB2BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEB2C0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB2C4: 4198009C  blt cr6, 0x82ceb360
	if ctx.cr[6].lt {
	pc = 0x82CEB360; continue 'dispatch;
	}
	// 82CEB2C8: 3C606182  lis r3, 0x6182
	ctx.r[3].s64 = 1635909632;
	// 82CEB2CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEB2D0: 60630006  ori r3, r3, 6
	ctx.r[3].u64 = ctx.r[3].u64 | 6;
	// 82CEB2D4: 4800053D  bl 0x82ceb810
	ctx.lr = 0x82CEB2D8;
	sub_82CEB810(ctx, base);
	// 82CEB2D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEB2DC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEB2E0: 41980080  blt cr6, 0x82ceb360
	if ctx.cr[6].lt {
	pc = 0x82CEB360; continue 'dispatch;
	}
	// 82CEB2E4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB2E8: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 82CEB2EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB2F0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEB2F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB2F8: 4E800421  bctrl
	ctx.lr = 0x82CEB2FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB300: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CEB304: 419A003C  beq cr6, 0x82ceb340
	if ctx.cr[6].eq {
	pc = 0x82CEB340; continue 'dispatch;
	}
	// 82CEB308: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82CEB30C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB310: 48001329  bl 0x82cec638
	ctx.lr = 0x82CEB314;
	sub_82CEC638(ctx, base);
	// 82CEB314: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB318: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82CEB31C: 394B5088  addi r10, r11, 0x5088
	ctx.r[10].s64 = ctx.r[11].s64 + 20616;
	// 82CEB320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB324: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEB328: 4BFFFB09  bl 0x82ceae30
	ctx.lr = 0x82CEB32C;
	sub_82CEAE30(ctx, base);
	// 82CEB32C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEB330: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82CEB334: 41980018  blt cr6, 0x82ceb34c
	if ctx.cr[6].lt {
	pc = 0x82CEB34C; continue 'dispatch;
	}
	// 82CEB338: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82CEB33C: 48000024  b 0x82ceb360
	pc = 0x82CEB360; continue 'dispatch;
	// 82CEB340: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 82CEB344: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 82CEB348: 48000018  b 0x82ceb360
	pc = 0x82CEB360; continue 'dispatch;
	// 82CEB34C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB354: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB358: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB35C: 4E800421  bctrl
	ctx.lr = 0x82CEB360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB360: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEB368: 419A0014  beq cr6, 0x82ceb37c
	if ctx.cr[6].eq {
	pc = 0x82CEB37C; continue 'dispatch;
	}
	// 82CEB36C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB370: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEB374: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB378: 4E800421  bctrl
	ctx.lr = 0x82CEB37C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB37C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEB380: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB384: 4BFBE0D4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEB388 size=24
    let mut pc: u32 = 0x82CEB388;
    'dispatch: loop {
        match pc {
            0x82CEB388 => {
    //   block [0x82CEB388..0x82CEB3A0)
	// 82CEB388: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 82CEB38C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEB390: 556B003A  rlwinm r11, r11, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEB394: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEB398: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82CEB39C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB3A0 size=116
    let mut pc: u32 = 0x82CEB3A0;
    'dispatch: loop {
        match pc {
            0x82CEB3A0 => {
    //   block [0x82CEB3A0..0x82CEB414)
	// 82CEB3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB3A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB3AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB3B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB3B4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82CEB3B8: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEB3BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CEB3C0: 409A001C  bne cr6, 0x82ceb3dc
	if !ctx.cr[6].eq {
	pc = 0x82CEB3DC; continue 'dispatch;
	}
	// 82CEB3C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB3C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB3CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB3D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB3D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB3D8: 4E800020  blr
	return;
	// 82CEB3DC: 90BF000C  stw r5, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82CEB3E0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB3E4: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB3E8: 4BFF5431  bl 0x82ce0818
	ctx.lr = 0x82CEB3EC;
	sub_82CE0818(ctx, base);
	// 82CEB3EC: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82CEB3F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEB3F4: 409AFFD0  bne cr6, 0x82ceb3c4
	if !ctx.cr[6].eq {
	pc = 0x82CEB3C4; continue 'dispatch;
	}
	// 82CEB3F8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEB3FC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEB400: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB40C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB418 size=108
    let mut pc: u32 = 0x82CEB418;
    'dispatch: loop {
        match pc {
            0x82CEB418 => {
    //   block [0x82CEB418..0x82CEB484)
	// 82CEB418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB430: 39440003  addi r10, r4, 3
	ctx.r[10].s64 = ctx.r[4].s64 + 3;
	// 82CEB434: 555E003A  rlwinm r30, r10, 0, 0, 0x1d
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEB438: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB43C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEB440: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEB444: 4E800421  bctrl
	ctx.lr = 0x82CEB448;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB448: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82CEB44C: 4099000C  ble cr6, 0x82ceb458
	if !ctx.cr[6].gt {
	pc = 0x82CEB458; continue 'dispatch;
	}
	// 82CEB450: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB454: 48000018  b 0x82ceb46c
	pc = 0x82CEB46C; continue 'dispatch;
	// 82CEB458: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEB45C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEB460: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEB464: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CEB468: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82CEB46C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB470: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB474: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB478: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB47C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB488 size=124
    let mut pc: u32 = 0x82CEB488;
    'dispatch: loop {
        match pc {
            0x82CEB488 => {
    //   block [0x82CEB488..0x82CEB504)
	// 82CEB488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB49C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB4A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB4A4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB4A8: 392B50F4  addi r9, r11, 0x50f4
	ctx.r[9].s64 = ctx.r[11].s64 + 20724;
	// 82CEB4AC: 390A50E0  addi r8, r10, 0x50e0
	ctx.r[8].s64 = ctx.r[10].s64 + 20704;
	// 82CEB4B0: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEB4B4: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82CEB4B8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB4BC: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEB4C0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CEB4C4: 419A001C  beq cr6, 0x82ceb4e0
	if ctx.cr[6].eq {
	pc = 0x82CEB4E0; continue 'dispatch;
	}
	// 82CEB4C8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB4CC: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB4D0: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB4D4: 4BFF5355  bl 0x82ce0828
	ctx.lr = 0x82CEB4D8;
	sub_82CE0828(ctx, base);
	// 82CEB4D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEB4DC: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82CEB4E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB4E4: 394B3DD0  addi r10, r11, 0x3dd0
	ctx.r[10].s64 = ctx.r[11].s64 + 15824;
	// 82CEB4E8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEB4EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB4F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB4F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB4F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB4FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEB508 size=8
    let mut pc: u32 = 0x82CEB508;
    'dispatch: loop {
        match pc {
            0x82CEB508 => {
    //   block [0x82CEB508..0x82CEB510)
	// 82CEB508: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82CEB50C: 4800008C  b 0x82ceb598
	sub_82CEB598(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEB510 size=16
    let mut pc: u32 = 0x82CEB510;
    'dispatch: loop {
        match pc {
            0x82CEB510 => {
    //   block [0x82CEB510..0x82CEB520)
	// 82CEB510: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEB514: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEB518: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CEB51C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEB520 size=8
    let mut pc: u32 = 0x82CEB520;
    'dispatch: loop {
        match pc {
            0x82CEB520 => {
    //   block [0x82CEB520..0x82CEB528)
	// 82CEB520: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82CEB524: 480000D4  b 0x82ceb5f8
	sub_82CEB5F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEB528 size=8
    let mut pc: u32 = 0x82CEB528;
    'dispatch: loop {
        match pc {
            0x82CEB528 => {
    //   block [0x82CEB528..0x82CEB530)
	// 82CEB528: 3863FFFC  addi r3, r3, -4
	ctx.r[3].s64 = ctx.r[3].s64 + -4;
	// 82CEB52C: 48000144  b 0x82ceb670
	sub_82CEB670(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB530 size=100
    let mut pc: u32 = 0x82CEB530;
    'dispatch: loop {
        match pc {
            0x82CEB530 => {
    //   block [0x82CEB530..0x82CEB594)
	// 82CEB530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB53C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB544: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB548: 3BE3FFFC  addi r31, r3, -4
	ctx.r[31].s64 = ctx.r[3].s64 + -4;
	// 82CEB54C: 83C30008  lwz r30, 8(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB550: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEB554: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB558: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB55C: 4E800421  bctrl
	ctx.lr = 0x82CEB560;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB560: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CEB564: 419A0018  beq cr6, 0x82ceb57c
	if ctx.cr[6].eq {
	pc = 0x82CEB57C; continue 'dispatch;
	}
	// 82CEB568: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB56C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82CEB570: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEB578: 4BFF52B1  bl 0x82ce0828
	ctx.lr = 0x82CEB57C;
	sub_82CE0828(ctx, base);
	// 82CEB57C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB588: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB58C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB598 size=92
    let mut pc: u32 = 0x82CEB598;
    'dispatch: loop {
        match pc {
            0x82CEB598 => {
    //   block [0x82CEB598..0x82CEB5F4)
	// 82CEB598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB5A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB5A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB5A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB5AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB5B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB5B4: 4BFFFED5  bl 0x82ceb488
	ctx.lr = 0x82CEB5B8;
	sub_82CEB488(ctx, base);
	// 82CEB5B8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CEB5BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEB5C0: 419A0018  beq cr6, 0x82ceb5d8
	if ctx.cr[6].eq {
	pc = 0x82CEB5D8; continue 'dispatch;
	}
	// 82CEB5C4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB5C8: 3CA06182  lis r5, 0x6182
	ctx.r[5].s64 = 1635909632;
	// 82CEB5CC: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB5D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEB5D4: 4BFF5255  bl 0x82ce0828
	ctx.lr = 0x82CEB5D8;
	sub_82CE0828(ctx, base);
	// 82CEB5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB5DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB5E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB5E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB5E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB5EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB5F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB5F8 size=116
    let mut pc: u32 = 0x82CEB5F8;
    'dispatch: loop {
        match pc {
            0x82CEB5F8 => {
    //   block [0x82CEB5F8..0x82CEB66C)
	// 82CEB5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB600: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB604: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB60C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB610: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB614: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB618: 392B50F4  addi r9, r11, 0x50f4
	ctx.r[9].s64 = ctx.r[11].s64 + 20724;
	// 82CEB61C: 390A510C  addi r8, r10, 0x510c
	ctx.r[8].s64 = ctx.r[10].s64 + 20748;
	// 82CEB620: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB624: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB628: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEB62C: 4BFFFE5D  bl 0x82ceb488
	ctx.lr = 0x82CEB630;
	sub_82CEB488(ctx, base);
	// 82CEB630: 57C707FE  clrlwi r7, r30, 0x1f
	ctx.r[7].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CEB634: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CEB638: 419A0018  beq cr6, 0x82ceb650
	if ctx.cr[6].eq {
	pc = 0x82CEB650; continue 'dispatch;
	}
	// 82CEB63C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB640: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82CEB644: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB648: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEB64C: 4BFF51DD  bl 0x82ce0828
	ctx.lr = 0x82CEB650;
	sub_82CE0828(ctx, base);
	// 82CEB650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB65C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB660: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB670 size=80
    let mut pc: u32 = 0x82CEB670;
    'dispatch: loop {
        match pc {
            0x82CEB670 => {
    //   block [0x82CEB670..0x82CEB6C0)
	// 82CEB670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB67C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB680: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB684: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB688: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB68C: 392B50F4  addi r9, r11, 0x50f4
	ctx.r[9].s64 = ctx.r[11].s64 + 20724;
	// 82CEB690: 390A5120  addi r8, r10, 0x5120
	ctx.r[8].s64 = ctx.r[10].s64 + 20768;
	// 82CEB694: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CEB698: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEB69C: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEB6A0: 90FF0018  stw r7, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 82CEB6A4: 4BFFFDE5  bl 0x82ceb488
	ctx.lr = 0x82CEB6A8;
	sub_82CEB488(ctx, base);
	// 82CEB6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB6AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB6B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB6B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB6B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB6BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB6C0 size=176
    let mut pc: u32 = 0x82CEB6C0;
    'dispatch: loop {
        match pc {
            0x82CEB6C0 => {
    //   block [0x82CEB6C0..0x82CEB770)
	// 82CEB6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB6C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB6CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB6D0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB6D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB6D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82CEB6DC: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB6E0: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82CEB6E4: 4BFF5135  bl 0x82ce0818
	ctx.lr = 0x82CEB6E8;
	sub_82CE0818(ctx, base);
	// 82CEB6E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CEB6EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEB6F0: 419A0064  beq cr6, 0x82ceb754
	if ctx.cr[6].eq {
	pc = 0x82CEB754; continue 'dispatch;
	}
	// 82CEB6F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB6F8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEB6FC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEB700: 38EA3DD0  addi r7, r10, 0x3dd0
	ctx.r[7].s64 = ctx.r[10].s64 + 15824;
	// 82CEB704: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CEB708: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEB70C: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CEB710: 38A950F4  addi r5, r9, 0x50f4
	ctx.r[5].s64 = ctx.r[9].s64 + 20724;
	// 82CEB714: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82CEB718: 3888510C  addi r4, r8, 0x510c
	ctx.r[4].s64 = ctx.r[8].s64 + 20748;
	// 82CEB71C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82CEB720: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82CEB724: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 82CEB728: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82CEB72C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82CEB730: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82CEB734: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82CEB738: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82CEB73C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB740: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB744: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB748: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB74C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB750: 4E800020  blr
	return;
	// 82CEB754: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEB758: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEB75C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB768: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB76C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB770 size=156
    let mut pc: u32 = 0x82CEB770;
    'dispatch: loop {
        match pc {
            0x82CEB770 => {
    //   block [0x82CEB770..0x82CEB80C)
	// 82CEB770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB774: 4BFBDC99  bl 0x82ca940c
	ctx.lr = 0x82CEB778;
	sub_82CA93D0(ctx, base);
	// 82CEB778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB780: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB784: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEB788: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82CEB78C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82CEB790: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEB794: 389E001C  addi r4, r30, 0x1c
	ctx.r[4].s64 = ctx.r[30].s64 + 28;
	// 82CEB798: 4BFF5081  bl 0x82ce0818
	ctx.lr = 0x82CEB79C;
	sub_82CE0818(ctx, base);
	// 82CEB79C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CEB7A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEB7A4: 409A0014  bne cr6, 0x82ceb7b8
	if !ctx.cr[6].eq {
	pc = 0x82CEB7B8; continue 'dispatch;
	}
	// 82CEB7A8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEB7AC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEB7B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB7B4: 4BFBDCA8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82CEB7B8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEB7BC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEB7C0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEB7C4: 38EA3DD0  addi r7, r10, 0x3dd0
	ctx.r[7].s64 = ctx.r[10].s64 + 15824;
	// 82CEB7C8: 38A950F4  addi r5, r9, 0x50f4
	ctx.r[5].s64 = ctx.r[9].s64 + 20724;
	// 82CEB7CC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CEB7D0: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CEB7D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEB7D8: 38885120  addi r4, r8, 0x5120
	ctx.r[4].s64 = ctx.r[8].s64 + 20768;
	// 82CEB7DC: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82CEB7E0: 392B001C  addi r9, r11, 0x1c
	ctx.r[9].s64 = ctx.r[11].s64 + 28;
	// 82CEB7E4: 906B0014  stw r3, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82CEB7E8: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82CEB7EC: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82CEB7F0: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82CEB7F4: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82CEB7F8: 93CB0010  stw r30, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82CEB7FC: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82CEB800: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB804: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB808: 4BFBDC54  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB810 size=172
    let mut pc: u32 = 0x82CEB810;
    'dispatch: loop {
        match pc {
            0x82CEB810 => {
    //   block [0x82CEB810..0x82CEB8BC)
	// 82CEB810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB814: 4BFBDBF5  bl 0x82ca9408
	ctx.lr = 0x82CEB818;
	sub_82CA93D0(ctx, base);
	// 82CEB818: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB81C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82CEB820: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEB824: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB828: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB82C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CEB830: 409A0040  bne cr6, 0x82ceb870
	if !ctx.cr[6].eq {
	pc = 0x82CEB870; continue 'dispatch;
	}
	// 82CEB834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB838: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CEB83C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CEB840: 419A0010  beq cr6, 0x82ceb850
	if ctx.cr[6].eq {
	pc = 0x82CEB850; continue 'dispatch;
	}
	// 82CEB844: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEB848: 4BFFFF29  bl 0x82ceb770
	ctx.lr = 0x82CEB84C;
	sub_82CEB770(ctx, base);
	// 82CEB84C: 4800000C  b 0x82ceb858
	pc = 0x82CEB858; continue 'dispatch;
	// 82CEB850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CEB854: 4BFFFE6D  bl 0x82ceb6c0
	ctx.lr = 0x82CEB858;
	sub_82CEB6C0(ctx, base);
	// 82CEB858: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB85C: 41980058  blt cr6, 0x82ceb8b4
	if ctx.cr[6].lt {
	pc = 0x82CEB8B4; continue 'dispatch;
	}
	// 82CEB860: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB864: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEB868: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB86C: 4BFBDBEC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82CEB870: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB878: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB87C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB880: 4E800421  bctrl
	ctx.lr = 0x82CEB884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB884: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB888: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CEB88C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB890: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEB894: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEB898: 4E800421  bctrl
	ctx.lr = 0x82CEB89C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB89C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB8A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82CEB8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB8A8: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEB8AC: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82CEB8B0: 4E800421  bctrl
	ctx.lr = 0x82CEB8B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB8B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEB8B8: 4BFBDBA0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB8C0 size=60
    let mut pc: u32 = 0x82CEB8C0;
    'dispatch: loop {
        match pc {
            0x82CEB8C0 => {
    //   block [0x82CEB8C0..0x82CEB8FC)
	// 82CEB8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB8C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB8CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB8D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB8D4: 48000D65  bl 0x82cec638
	ctx.lr = 0x82CEB8D8;
	sub_82CEC638(ctx, base);
	// 82CEB8D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEB8DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB8E0: 394B5138  addi r10, r11, 0x5138
	ctx.r[10].s64 = ctx.r[11].s64 + 20792;
	// 82CEB8E4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEB8E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEB8EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB8F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB900 size=80
    let mut pc: u32 = 0x82CEB900;
    'dispatch: loop {
        match pc {
            0x82CEB900 => {
    //   block [0x82CEB900..0x82CEB950)
	// 82CEB900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB90C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB918: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82CEB91C: 480009B5  bl 0x82cec2d0
	ctx.lr = 0x82CEB920;
	sub_82CEC2D0(ctx, base);
	// 82CEB920: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEB924: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82CEB928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEB92C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEB930: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEB934: 4E800421  bctrl
	ctx.lr = 0x82CEB938;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEB938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEB93C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB944: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEB94C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEB950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEB950 size=180
    let mut pc: u32 = 0x82CEB950;
    'dispatch: loop {
        match pc {
            0x82CEB950 => {
    //   block [0x82CEB950..0x82CEBA04)
	// 82CEB950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEB954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEB958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEB95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEB960: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEB964: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEB968: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82CEB96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEB970: 48000979  bl 0x82cec2e8
	ctx.lr = 0x82CEB974;
	sub_82CEC2E8(ctx, base);
	// 82CEB974: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB978: 41980074  blt cr6, 0x82ceb9ec
	if ctx.cr[6].lt {
	pc = 0x82CEB9EC; continue 'dispatch;
	}
	// 82CEB97C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82CEB980: 893F0019  lbz r9, 0x19(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82CEB984: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEB988: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CEB98C: 3CE08333  lis r7, -0x7ccd
	ctx.r[7].s64 = -2093809664;
	// 82CEB990: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEB994: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82CEB998: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82CEB99C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82CEB9A0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82CEB9A4: 99610069  stb r11, 0x69(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82CEB9A8: 99210068  stb r9, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u8 ) };
	// 82CEB9AC: 99010060  stb r8, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u8 ) };
	// 82CEB9B0: 816772AC  lwz r11, 0x72ac(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEB9B4: 806B003C  lwz r3, 0x3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEB9B8: 4BFF6919  bl 0x82ce22d0
	ctx.lr = 0x82CEB9BC;
	sub_82CE22D0(ctx, base);
	// 82CEB9BC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEB9C0: 4198002C  blt cr6, 0x82ceb9ec
	if ctx.cr[6].lt {
	pc = 0x82CEB9EC; continue 'dispatch;
	}
	// 82CEB9C4: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEB9C8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEB9CC: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 82CEB9D0: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEB9D4: 7D4B51D6  mullw r10, r11, r10
	ctx.r[10].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CEB9D8: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CEB9DC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82CEB9E0: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEB9E4: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEB9E8: 90DE0000  stw r6, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82CEB9EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEB9F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEB9F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEB9F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEB9FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEBA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBA08 size=276
    let mut pc: u32 = 0x82CEBA08;
    'dispatch: loop {
        match pc {
            0x82CEBA08 => {
    //   block [0x82CEBA08..0x82CEBB1C)
	// 82CEBA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBA0C: 4BFBD9FD  bl 0x82ca9408
	ctx.lr = 0x82CEBA10;
	sub_82CA93D0(ctx, base);
	// 82CEBA10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBA14: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CEBA18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEBA1C: 897C0018  lbz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEBA20: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82CEBA24: 4800148D  bl 0x82ceceb0
	ctx.lr = 0x82CEBA28;
	sub_82CECEB0(ctx, base);
	// 82CEBA28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBA2C: 419800D8  blt cr6, 0x82cebb04
	if ctx.cr[6].lt {
	pc = 0x82CEBB04; continue 'dispatch;
	}
	// 82CEBA30: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBA34: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEBA38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBA3C: 419A0034  beq cr6, 0x82ceba70
	if ctx.cr[6].eq {
	pc = 0x82CEBA70; continue 'dispatch;
	}
	// 82CEBA40: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEBA44: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CEBA48: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEBA4C: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CEBA50: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBA54: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CEBA58: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEBA5C: 4E800421  bctrl
	ctx.lr = 0x82CEBA60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBA60: 907F0048  stw r3, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82CEBA64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEBA68: 419A00A4  beq cr6, 0x82cebb0c
	if ctx.cr[6].eq {
	pc = 0x82CEBB0C; continue 'dispatch;
	}
	// 82CEBA6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEBA70: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBA74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBA78: 419A006C  beq cr6, 0x82cebae4
	if ctx.cr[6].eq {
	pc = 0x82CEBAE4; continue 'dispatch;
	}
	// 82CEBA7C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82CEBA80: 893C0019  lbz r9, 0x19(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25 as u32) ) } as u64;
	// 82CEBA84: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CEBA88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBA8C: FBCA0000  std r30, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 82CEBA90: FBCA0008  std r30, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[30].u64 ) };
	// 82CEBA94: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82CEBA98: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 82CEBA9C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82CEBAA0: 9BC10059  stb r30, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[30].u8 ) };
	// 82CEBAA4: 419A0040  beq cr6, 0x82cebae4
	if ctx.cr[6].eq {
	pc = 0x82CEBAE4; continue 'dispatch;
	}
	// 82CEBAA8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82CEBAAC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBAB0: 41980054  blt cr6, 0x82cebb04
	if ctx.cr[6].lt {
	pc = 0x82CEBB04; continue 'dispatch;
	}
	// 82CEBAB4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBAB8: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82CEBABC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEBAC0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82CEBAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBAC8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82CEBACC: 480009D5  bl 0x82cec4a0
	ctx.lr = 0x82CEBAD0;
	sub_82CEC4A0(ctx, base);
	// 82CEBAD0: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBAD4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82CEBAD8: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82CEBADC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEBAE0: 4198FFCC  blt cr6, 0x82cebaac
	if ctx.cr[6].lt {
	pc = 0x82CEBAAC; continue 'dispatch;
	}
	// 82CEBAE4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBAE8: 4198001C  blt cr6, 0x82cebb04
	if ctx.cr[6].lt {
	pc = 0x82CEBB04; continue 'dispatch;
	}
	// 82CEBAEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBAF4: 809C001C  lwz r4, 0x1c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CEBAF8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEBAFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBB00: 4E800421  bctrl
	ctx.lr = 0x82CEBB04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBB04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEBB08: 4BFBD950  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82CEBB0C: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEBB10: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CEBB14: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEBB18: 4BFBD940  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBB20 size=192
    let mut pc: u32 = 0x82CEBB20;
    'dispatch: loop {
        match pc {
            0x82CEBB20 => {
    //   block [0x82CEBB20..0x82CEBBE0)
	// 82CEBB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBB24: 4BFBD8E9  bl 0x82ca940c
	ctx.lr = 0x82CEBB28;
	sub_82CA93D0(ctx, base);
	// 82CEBB28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBB2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEBB30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEBB34: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82CEBB38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82CEBB3C: 409A000C  bne cr6, 0x82cebb48
	if !ctx.cr[6].eq {
	pc = 0x82CEBB48; continue 'dispatch;
	}
	// 82CEBB40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEBB44: 3BEB5194  addi r31, r11, 0x5194
	ctx.r[31].s64 = ctx.r[11].s64 + 20884;
	// 82CEBB48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBB50: 419A000C  beq cr6, 0x82cebb5c
	if ctx.cr[6].eq {
	pc = 0x82CEBB5C; continue 'dispatch;
	}
	// 82CEBB54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEBB58: 48000014  b 0x82cebb6c
	pc = 0x82CEBB6C; continue 'dispatch;
	// 82CEBB5C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEBB60: 816B72AC  lwz r11, 0x72ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEBB64: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82CEBB68: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEBB6C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB74: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBB78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBB7C: 4E800421  bctrl
	ctx.lr = 0x82CEBB80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBB80: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBB88: 409A0038  bne cr6, 0x82cebbc0
	if !ctx.cr[6].eq {
	pc = 0x82CEBBC0; continue 'dispatch;
	}
	// 82CEBB8C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEBB94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBB98: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82CEBB9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBBA0: 4E800421  bctrl
	ctx.lr = 0x82CEBBA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBBA4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBBA8: 41980030  blt cr6, 0x82cebbd8
	if ctx.cr[6].lt {
	pc = 0x82CEBBD8; continue 'dispatch;
	}
	// 82CEBBAC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82CEBBB0: 88810051  lbz r4, 0x51(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82CEBBB4: 887D0035  lbz r3, 0x35(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(53 as u32) ) } as u64;
	// 82CEBBB8: 4BFED301  bl 0x82cd8eb8
	ctx.lr = 0x82CEBBBC;
	sub_82CD8EB8(ctx, base);
	// 82CEBBBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82CEBBC0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBBC4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82CEBBC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBBCC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEBBD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBBD4: 4E800421  bctrl
	ctx.lr = 0x82CEBBD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBBD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBBDC: 4BFBD880  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBBE0 size=96
    let mut pc: u32 = 0x82CEBBE0;
    'dispatch: loop {
        match pc {
            0x82CEBBE0 => {
    //   block [0x82CEBBE0..0x82CEBC40)
	// 82CEBBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBBE4: 4BFBD825  bl 0x82ca9408
	ctx.lr = 0x82CEBBE8;
	sub_82CA93D0(ctx, base);
	// 82CEBBE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBBEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEBBF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82CEBBF4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82CEBBF8: 897E0045  lbz r11, 0x45(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBBFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBC00: 419A0034  beq cr6, 0x82cebc34
	if ctx.cr[6].eq {
	pc = 0x82CEBC34; continue 'dispatch;
	}
	// 82CEBC04: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82CEBC08: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBC0C: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CEBC10: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBC14: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEBC18: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEBC1C: 4E800421  bctrl
	ctx.lr = 0x82CEBC20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBC20: 891E0045  lbz r8, 0x45(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBC24: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82CEBC28: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82CEBC2C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEBC30: 4198FFD8  blt cr6, 0x82cebc08
	if ctx.cr[6].lt {
	pc = 0x82CEBC08; continue 'dispatch;
	}
	// 82CEBC34: 9B9E0045  stb r28, 0x45(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(69 as u32), ctx.r[28].u8 ) };
	// 82CEBC38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBC3C: 4BFBD81C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBC40 size=152
    let mut pc: u32 = 0x82CEBC40;
    'dispatch: loop {
        match pc {
            0x82CEBC40 => {
    //   block [0x82CEBC40..0x82CEBCD8)
	// 82CEBC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBC44: 4BFBD7C1  bl 0x82ca9404
	ctx.lr = 0x82CEBC48;
	sub_82CA93D0(ctx, base);
	// 82CEBC48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBC4C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEBC50: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82CEBC54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CEBC58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEBC5C: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEBC60: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBC64: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 82CEBC68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEBC6C: 553B07FE  clrlwi r27, r9, 0x1f
	ctx.r[27].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82CEBC70: 419A0060  beq cr6, 0x82cebcd0
	if ctx.cr[6].eq {
	pc = 0x82CEBCD0; continue 'dispatch;
	}
	// 82CEBC74: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEBC78: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBC7C: 41980054  blt cr6, 0x82cebcd0
	if ctx.cr[6].lt {
	pc = 0x82CEBCD0; continue 'dispatch;
	}
	// 82CEBC80: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBC84: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82CEBC88: 813C0048  lwz r9, 0x48(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBC8C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEBC90: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBC94: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBC98: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CEBC9C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CEBCA0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEBCA4: 7D4B4A14  add r10, r11, r9
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CEBCA8: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBCAC: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBCB0: 81090038  lwz r8, 0x38(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEBCB4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEBCB8: 4E800421  bctrl
	ctx.lr = 0x82CEBCBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBCBC: 88FD0000  lbz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBCC0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82CEBCC4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82CEBCC8: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CEBCCC: 4198FFAC  blt cr6, 0x82cebc78
	if ctx.cr[6].lt {
	pc = 0x82CEBC78; continue 'dispatch;
	}
	// 82CEBCD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBCD4: 4BFBD780  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBCD8 size=156
    let mut pc: u32 = 0x82CEBCD8;
    'dispatch: loop {
        match pc {
            0x82CEBCD8 => {
    //   block [0x82CEBCD8..0x82CEBD74)
	// 82CEBCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBCDC: 4BFBD72D  bl 0x82ca9408
	ctx.lr = 0x82CEBCE0;
	sub_82CA93D0(ctx, base);
	// 82CEBCE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBCE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEBCE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEBCEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEBCF0: 394B5138  addi r10, r11, 0x5138
	ctx.r[10].s64 = ctx.r[11].s64 + 20792;
	// 82CEBCF4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEBCF8: 48000DF9  bl 0x82cecaf0
	ctx.lr = 0x82CEBCFC;
	sub_82CECAF0(ctx, base);
	// 82CEBCFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBD00: 4BFFFEE1  bl 0x82cebbe0
	ctx.lr = 0x82CEBD04;
	sub_82CEBBE0(ctx, base);
	// 82CEBD04: 893F0044  lbz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBD08: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82CEBD0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEBD10: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82CEBD14: 419A0050  beq cr6, 0x82cebd64
	if ctx.cr[6].eq {
	pc = 0x82CEBD64; continue 'dispatch;
	}
	// 82CEBD18: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82CEBD1C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBD20: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEBD24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBD28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEBD2C: 419A0024  beq cr6, 0x82cebd50
	if ctx.cr[6].eq {
	pc = 0x82CEBD50; continue 'dispatch;
	}
	// 82CEBD30: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82CEBD34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBD38: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBD3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBD40: 4E800421  bctrl
	ctx.lr = 0x82CEBD44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBD44: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBD48: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEBD4C: 93890004  stw r28, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82CEBD50: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBD54: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82CEBD58: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82CEBD5C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEBD60: 4198FFBC  blt cr6, 0x82cebd1c
	if ctx.cr[6].lt {
	pc = 0x82CEBD1C; continue 'dispatch;
	}
	// 82CEBD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBD68: 48000669  bl 0x82cec3d0
	ctx.lr = 0x82CEBD6C;
	sub_82CEC3D0(ctx, base);
	// 82CEBD6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBD70: 4BFBD6E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBD78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBD78 size=200
    let mut pc: u32 = 0x82CEBD78;
    'dispatch: loop {
        match pc {
            0x82CEBD78 => {
    //   block [0x82CEBD78..0x82CEBE40)
	// 82CEBD78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBD7C: 4BFBD685  bl 0x82ca9400
	ctx.lr = 0x82CEBD80;
	sub_82CA93D0(ctx, base);
	// 82CEBD80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBD84: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEBD88: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82CEBD8C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82CEBD90: 4BFFFE51  bl 0x82cebbe0
	ctx.lr = 0x82CEBD94;
	sub_82CEBBE0(ctx, base);
	// 82CEBD94: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CEBD98: 419A0074  beq cr6, 0x82cebe0c
	if ctx.cr[6].eq {
	pc = 0x82CEBE0C; continue 'dispatch;
	}
	// 82CEBD9C: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBDA0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82CEBDA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBDA8: 419A0050  beq cr6, 0x82cebdf8
	if ctx.cr[6].eq {
	pc = 0x82CEBDF8; continue 'dispatch;
	}
	// 82CEBDAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEBDB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CEBDB4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82CEBDB8: 41980048  blt cr6, 0x82cebe00
	if ctx.cr[6].lt {
	pc = 0x82CEBE00; continue 'dispatch;
	}
	// 82CEBDBC: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBDC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEBDC4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBDC8: 7CAAFA14  add r5, r10, r31
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82CEBDCC: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82CEBDD0: 4BFFFD51  bl 0x82cebb20
	ctx.lr = 0x82CEBDD4;
	sub_82CEBB20(ctx, base);
	// 82CEBDD4: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBDD8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82CEBDDC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82CEBDE0: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82CEBDE4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82CEBDE8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEBDEC: 4198FFC8  blt cr6, 0x82cebdb4
	if ctx.cr[6].lt {
	pc = 0x82CEBDB4; continue 'dispatch;
	}
	// 82CEBDF0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82CEBDF4: 4198000C  blt cr6, 0x82cebe00
	if ctx.cr[6].lt {
	pc = 0x82CEBE00; continue 'dispatch;
	}
	// 82CEBDF8: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBDFC: 997C0045  stb r11, 0x45(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(69 as u32), ctx.r[11].u8 ) };
	// 82CEBE00: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82CEBE04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEBE08: 4BFBD648  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 82CEBE0C: 897C0044  lbz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 82CEBE10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBE14: 419AFFEC  beq cr6, 0x82cebe00
	if ctx.cr[6].eq {
	pc = 0x82CEBE00; continue 'dispatch;
	}
	// 82CEBE18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEBE1C: 80BC0048  lwz r5, 0x48(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBE20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CEBE24: 4BFFFCFD  bl 0x82cebb20
	ctx.lr = 0x82CEBE28;
	sub_82CEBB20(ctx, base);
	// 82CEBE28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBE2C: 4198FFD8  blt cr6, 0x82cebe04
	if ctx.cr[6].lt {
	pc = 0x82CEBE04; continue 'dispatch;
	}
	// 82CEBE30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CEBE34: 997C0045  stb r11, 0x45(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(69 as u32), ctx.r[11].u8 ) };
	// 82CEBE38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEBE3C: 4BFBD614  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBE40 size=144
    let mut pc: u32 = 0x82CEBE40;
    'dispatch: loop {
        match pc {
            0x82CEBE40 => {
    //   block [0x82CEBE40..0x82CEBED0)
	// 82CEBE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBE44: 4BFBD5C5  bl 0x82ca9408
	ctx.lr = 0x82CEBE48;
	sub_82CA93D0(ctx, base);
	// 82CEBE48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBE4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEBE50: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82CEBE54: 48001195  bl 0x82cecfe8
	ctx.lr = 0x82CEBE58;
	sub_82CECFE8(ctx, base);
	// 82CEBE58: 897E0045  lbz r11, 0x45(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBE5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82CEBE60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBE64: 419A0064  beq cr6, 0x82cebec8
	if ctx.cr[6].eq {
	pc = 0x82CEBEC8; continue 'dispatch;
	}
	// 82CEBE68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CEBE6C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBE70: 41980058  blt cr6, 0x82cebec8
	if ctx.cr[6].lt {
	pc = 0x82CEBEC8; continue 'dispatch;
	}
	// 82CEBE74: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBE78: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CEBE7C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82CEBE80: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBE84: 81090048  lwz r8, 0x48(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBE88: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEBE8C: 4E800421  bctrl
	ctx.lr = 0x82CEBE90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBE90: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBE94: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82CEBE98: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBE9C: 7CEBFA14  add r7, r11, r31
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82CEBEA0: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBEA4: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBEA8: 81660018  lwz r11, 0x18(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEBEAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82CEBEB0: 4E800421  bctrl
	ctx.lr = 0x82CEBEB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBEB4: 895E0045  lbz r10, 0x45(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBEB8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82CEBEBC: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82CEBEC0: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEBEC4: 4198FFA8  blt cr6, 0x82cebe6c
	if ctx.cr[6].lt {
	pc = 0x82CEBE6C; continue 'dispatch;
	}
	// 82CEBEC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEBECC: 4BFBD58C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEBED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEBED0 size=324
    let mut pc: u32 = 0x82CEBED0;
    'dispatch: loop {
        match pc {
            0x82CEBED0 => {
    //   block [0x82CEBED0..0x82CEC014)
	// 82CEBED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEBED4: 4BFBD535  bl 0x82ca9408
	ctx.lr = 0x82CEBED8;
	sub_82CA93D0(ctx, base);
	// 82CEBED8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEBEDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEBEE0: 485CE425  bl 0x832ba304
	ctx.lr = 0x82CEBEE4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEBEE4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEBEE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEBEEC: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEBEF0: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEBEF4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBEF8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEBEFC: 419A0010  beq cr6, 0x82cebf0c
	if ctx.cr[6].eq {
	pc = 0x82CEBF0C; continue 'dispatch;
	}
	// 82CEBF00: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEBF04: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEBF08: 419A001C  beq cr6, 0x82cebf24
	if ctx.cr[6].eq {
	pc = 0x82CEBF24; continue 'dispatch;
	}
	// 82CEBF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBF10: 485CE3E5  bl 0x832ba2f4
	ctx.lr = 0x82CEBF14;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEBF14: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CEBF18: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBF1C: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEBF20: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CEBF24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CEBF28: 397C0018  addi r11, r28, 0x18
	ctx.r[11].s64 = ctx.r[28].s64 + 24;
	// 82CEBF2C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEBF30: 813C0018  lwz r9, 0x18(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEBF34: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEBF38: 419A0028  beq cr6, 0x82cebf60
	if ctx.cr[6].eq {
	pc = 0x82CEBF60; continue 'dispatch;
	}
	// 82CEBF3C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBF40: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEBF44: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBF48: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBF4C: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEBF50: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEBF54: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEBF58: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEBF5C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEBF60: 7DAB6B78  mr r11, r13
	ctx.r[11].u64 = ctx.r[13].u64;
	// 82CEBF64: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CEBF68: 419A003C  beq cr6, 0x82cebfa4
	if ctx.cr[6].eq {
	pc = 0x82CEBFA4; continue 'dispatch;
	}
	// 82CEBF6C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CEBF70: 409A0034  bne cr6, 0x82cebfa4
	if !ctx.cr[6].eq {
	pc = 0x82CEBFA4; continue 'dispatch;
	}
	// 82CEBF74: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEBF78: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEBF7C: 40820028  bne 0x82cebfa4
	if !ctx.cr[0].eq {
	pc = 0x82CEBFA4; continue 'dispatch;
	}
	// 82CEBF80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEBF84: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEBF88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEBF8C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEBF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEBF94: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEBF98: 485CE39D  bl 0x832ba334
	ctx.lr = 0x82CEBF9C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEBF9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEBFA0: 485CE375  bl 0x832ba314
	ctx.lr = 0x82CEBFA4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEBFA4: 897C0045  lbz r11, 0x45(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBFA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEBFAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEBFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEBFB4: 419A0058  beq cr6, 0x82cec00c
	if ctx.cr[6].eq {
	pc = 0x82CEC00C; continue 'dispatch;
	}
	// 82CEBFB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CEBFBC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEBFC0: 4198004C  blt cr6, 0x82cec00c
	if ctx.cr[6].lt {
	pc = 0x82CEC00C; continue 'dispatch;
	}
	// 82CEBFC4: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEBFC8: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CEBFCC: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEBFD0: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEBFD4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82CEBFD8: 4182000C  beq 0x82cebfe4
	if ctx.cr[0].eq {
	pc = 0x82CEBFE4; continue 'dispatch;
	}
	// 82CEBFDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEBFE0: 48000018  b 0x82cebff8
	pc = 0x82CEBFF8; continue 'dispatch;
	// 82CEBFE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEBFE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82CEBFEC: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEBFF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEBFF4: 4E800421  bctrl
	ctx.lr = 0x82CEBFF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEBFF8: 897C0045  lbz r11, 0x45(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEBFFC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82CEC000: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82CEC004: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEC008: 4198FFB4  blt cr6, 0x82cebfbc
	if ctx.cr[6].lt {
	pc = 0x82CEBFBC; continue 'dispatch;
	}
	// 82CEC00C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEC010: 4BFBD448  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC018 size=92
    let mut pc: u32 = 0x82CEC018;
    'dispatch: loop {
        match pc {
            0x82CEC018 => {
    //   block [0x82CEC018..0x82CEC074)
	// 82CEC018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC01C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEC024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEC028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC02C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC030: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEC034: 4BFFFCA5  bl 0x82cebcd8
	ctx.lr = 0x82CEC038;
	sub_82CEBCD8(ctx, base);
	// 82CEC038: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CEC03C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC040: 419A0018  beq cr6, 0x82cec058
	if ctx.cr[6].eq {
	pc = 0x82CEC058; continue 'dispatch;
	}
	// 82CEC044: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC048: 3CA06182  lis r5, 0x6182
	ctx.r[5].s64 = 1635909632;
	// 82CEC04C: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEC050: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEC054: 4BFF47D5  bl 0x82ce0828
	ctx.lr = 0x82CEC058;
	sub_82CE0828(ctx, base);
	// 82CEC058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC05C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC068: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEC06C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEC070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC078 size=388
    let mut pc: u32 = 0x82CEC078;
    'dispatch: loop {
        match pc {
            0x82CEC078 => {
    //   block [0x82CEC078..0x82CEC1FC)
	// 82CEC078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC07C: 4BFBD389  bl 0x82ca9404
	ctx.lr = 0x82CEC080;
	sub_82CA93D0(ctx, base);
	// 82CEC080: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC084: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEC088: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC08C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CEC090: 897D0045  lbz r11, 0x45(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEC094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC098: 419A0050  beq cr6, 0x82cec0e8
	if ctx.cr[6].eq {
	pc = 0x82CEC0E8; continue 'dispatch;
	}
	// 82CEC09C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82CEC0A0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC0A4: 41980150  blt cr6, 0x82cec1f4
	if ctx.cr[6].lt {
	pc = 0x82CEC1F4; continue 'dispatch;
	}
	// 82CEC0A8: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEC0AC: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82CEC0B0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEC0B4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82CEC0B8: 91430028  stw r10, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82CEC0BC: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC0C0: 81090038  lwz r8, 0x38(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 82CEC0C4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82CEC0C8: 4E800421  bctrl
	ctx.lr = 0x82CEC0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC0CC: 88FD0045  lbz r7, 0x45(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(69 as u32) ) } as u64;
	// 82CEC0D0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82CEC0D4: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82CEC0D8: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CEC0DC: 4198FFC4  blt cr6, 0x82cec0a0
	if ctx.cr[6].lt {
	pc = 0x82CEC0A0; continue 'dispatch;
	}
	// 82CEC0E0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC0E4: 41980110  blt cr6, 0x82cec1f4
	if ctx.cr[6].lt {
	pc = 0x82CEC1F4; continue 'dispatch;
	}
	// 82CEC0E8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC0EC: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82CEC0F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEC0F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82CEC0F8: 83EA72AC  lwz r31, 0x72ac(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEC0FC: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CEC100: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82CEC104: 4E800421  bctrl
	ctx.lr = 0x82CEC108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC108: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC10C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82CEC110: 4198001C  blt cr6, 0x82cec12c
	if ctx.cr[6].lt {
	pc = 0x82CEC12C; continue 'dispatch;
	}
	// 82CEC114: 409A00DC  bne cr6, 0x82cec1f0
	if !ctx.cr[6].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC118: 895D004C  lbz r10, 0x4c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CEC11C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82CEC120: 1D4A002C  mulli r10, r10, 0x2c
	ctx.r[10].s64 = ctx.r[10].s64 * 44;
	// 82CEC124: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CEC128: 48000008  b 0x82cec130
	pc = 0x82CEC130; continue 'dispatch;
	// 82CEC12C: 3B7F0050  addi r27, r31, 0x50
	ctx.r[27].s64 = ctx.r[31].s64 + 80;
	// 82CEC130: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82CEC134: 419A00BC  beq cr6, 0x82cec1f0
	if ctx.cr[6].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC138: 485CE1CD  bl 0x832ba304
	ctx.lr = 0x82CEC13C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEC13C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC140: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEC144: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEC148: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEC14C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC150: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC154: 419A0010  beq cr6, 0x82cec164
	if ctx.cr[6].eq {
	pc = 0x82CEC164; continue 'dispatch;
	}
	// 82CEC158: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC15C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC160: 419A0018  beq cr6, 0x82cec178
	if ctx.cr[6].eq {
	pc = 0x82CEC178; continue 'dispatch;
	}
	// 82CEC164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC168: 485CE18D  bl 0x832ba2f4
	ctx.lr = 0x82CEC16C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEC16C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC170: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEC174: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82CEC178: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEC17C: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEC180: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC184: 813B0028  lwz r9, 0x28(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82CEC188: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC18C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82CEC190: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEC194: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC198: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82CEC19C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC1A0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC1A4: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEC1A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC1AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC1B0: 419A0040  beq cr6, 0x82cec1f0
	if ctx.cr[6].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC1B4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC1B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEC1BC: 409A0034  bne cr6, 0x82cec1f0
	if !ctx.cr[6].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC1C0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC1C4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC1C8: 40820028  bne 0x82cec1f0
	if !ctx.cr[0].eq {
	pc = 0x82CEC1F0; continue 'dispatch;
	}
	// 82CEC1CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEC1D0: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC1D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEC1D8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEC1DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC1E0: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEC1E4: 485CE151  bl 0x832ba334
	ctx.lr = 0x82CEC1E8;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEC1E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEC1EC: 485CE129  bl 0x832ba314
	ctx.lr = 0x82CEC1F0;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEC1F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC1F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CEC1F8: 4BFBD25C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC200 size=208
    let mut pc: u32 = 0x82CEC200;
    'dispatch: loop {
        match pc {
            0x82CEC200 => {
    //   block [0x82CEC200..0x82CEC2D0)
	// 82CEC200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEC20C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC214: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC218: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82CEC21C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC220: 4E800421  bctrl
	ctx.lr = 0x82CEC224;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC224: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82CEC228: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82CEC22C: 4BC11275  bl 0x828fd4a0
	ctx.lr = 0x82CEC230;
	sub_828FD4A0(ctx, base);
	// 82CEC230: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82CEC234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC238: 419A0018  beq cr6, 0x82cec250
	if ctx.cr[6].eq {
	pc = 0x82CEC250; continue 'dispatch;
	}
	// 82CEC23C: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82CEC240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CEC244: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82CEC248: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82CEC24C: 4E800421  bctrl
	ctx.lr = 0x82CEC250;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC250: 897F003D  lbz r11, 0x3d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEC254: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEC258: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC25C: 419A001C  beq cr6, 0x82cec278
	if ctx.cr[6].eq {
	pc = 0x82CEC278; continue 'dispatch;
	}
	// 82CEC260: A17F0040  lhz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82CEC264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC268: 419A004C  beq cr6, 0x82cec2b4
	if ctx.cr[6].eq {
	pc = 0x82CEC2B4; continue 'dispatch;
	}
	// 82CEC26C: 3D6B0001  addis r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 65536;
	// 82CEC270: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82CEC274: B17F0040  sth r11, 0x40(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u16 ) };
	// 82CEC278: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC27C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82CEC280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC284: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEC288: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC28C: 4E800421  bctrl
	ctx.lr = 0x82CEC290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC294: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82CEC298: 4BC11209  bl 0x828fd4a0
	ctx.lr = 0x82CEC29C;
	sub_828FD4A0(ctx, base);
	// 82CEC29C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC2A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC2A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC2A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC2AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEC2B0: 4E800020  blr
	return;
	// 82CEC2B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC2B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CEC2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC2C0: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC2C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC2C8: 4E800421  bctrl
	ctx.lr = 0x82CEC2CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC2CC: 4BFFFFC4  b 0x82cec290
	pc = 0x82CEC290; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC2D0 size=20
    let mut pc: u32 = 0x82CEC2D0;
    'dispatch: loop {
        match pc {
            0x82CEC2D0 => {
    //   block [0x82CEC2D0..0x82CEC2E4)
	// 82CEC2D0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC2D4: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82CEC2D8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC2DC: 91430038  stw r10, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82CEC2E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC2E8 size=228
    let mut pc: u32 = 0x82CEC2E8;
    'dispatch: loop {
        match pc {
            0x82CEC2E8 => {
    //   block [0x82CEC2E8..0x82CEC3CC)
	// 82CEC2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC2EC: 4BFBD115  bl 0x82ca9400
	ctx.lr = 0x82CEC2F0;
	sub_82CA93D0(ctx, base);
	// 82CEC2F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC2F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEC2F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CEC2FC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82CEC300: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82CEC304: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82CEC308: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC30C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC314: 409A0048  bne cr6, 0x82cec35c
	if !ctx.cr[6].eq {
	pc = 0x82CEC35C; continue 'dispatch;
	}
	// 82CEC318: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82CEC31C: 895C0001  lbz r10, 1(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CEC320: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82CEC324: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEC328: 6128BB80  ori r8, r9, 0xbb80
	ctx.r[8].u64 = ctx.r[9].u64 | 48000;
	// 82CEC32C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82CEC330: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82CEC334: FBEB0008  std r31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 82CEC338: 93EB0010  stw r31, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82CEC33C: 9BE10064  stb r31, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u8 ) };
	// 82CEC340: 99410065  stb r10, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[10].u8 ) };
	// 82CEC344: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82CEC348: 9BE10060  stb r31, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u8 ) };
	// 82CEC34C: 4BFF24DD  bl 0x82cde828
	ctx.lr = 0x82CEC350;
	sub_82CDE828(ctx, base);
	// 82CEC350: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC354: 41980070  blt cr6, 0x82cec3c4
	if ctx.cr[6].lt {
	pc = 0x82CEC3C4; continue 'dispatch;
	}
	// 82CEC358: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC35C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC364: 419A0054  beq cr6, 0x82cec3b8
	if ctx.cr[6].eq {
	pc = 0x82CEC3B8; continue 'dispatch;
	}
	// 82CEC368: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC36C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC370: 419A0048  beq cr6, 0x82cec3b8
	if ctx.cr[6].eq {
	pc = 0x82CEC3B8; continue 'dispatch;
	}
	// 82CEC374: 3F608333  lis r27, -0x7ccd
	ctx.r[27].s64 = -2093809664;
	// 82CEC378: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC37C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82CEC380: 817B72AC  lwz r11, 0x72ac(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEC384: 7C8AF82E  lwzx r4, r10, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82CEC388: 806B003C  lwz r3, 0x3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC38C: 4BFF5F45  bl 0x82ce22d0
	ctx.lr = 0x82CEC390;
	sub_82CE22D0(ctx, base);
	// 82CEC390: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC394: 41980030  blt cr6, 0x82cec3c4
	if ctx.cr[6].lt {
	pc = 0x82CEC3C4; continue 'dispatch;
	}
	// 82CEC398: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC39C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82CEC3A0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC3A4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82CEC3A8: 7FAAEA14  add r29, r10, r29
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82CEC3AC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC3B0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC3B4: 4198FFC4  blt cr6, 0x82cec378
	if ctx.cr[6].lt {
	pc = 0x82CEC378; continue 'dispatch;
	}
	// 82CEC3B8: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC3BC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82CEC3C0: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEC3C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82CEC3C8: 4BFBD088  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC3D0 size=204
    let mut pc: u32 = 0x82CEC3D0;
    'dispatch: loop {
        match pc {
            0x82CEC3D0 => {
    //   block [0x82CEC3D0..0x82CEC49C)
	// 82CEC3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC3D4: 4BFBD035  bl 0x82ca9408
	ctx.lr = 0x82CEC3D8;
	sub_82CA93D0(ctx, base);
	// 82CEC3D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC3DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC3E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEC3E4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82CEC3E8: 392B51A0  addi r9, r11, 0x51a0
	ctx.r[9].s64 = ctx.r[11].s64 + 20896;
	// 82CEC3EC: 895F003C  lbz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC3F0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEC3F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC3F8: 419A0050  beq cr6, 0x82cec448
	if ctx.cr[6].eq {
	pc = 0x82CEC448; continue 'dispatch;
	}
	// 82CEC3FC: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82CEC400: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC404: 57BE1838  slwi r30, r29, 3
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82CEC408: 7D7E502E  lwzx r11, r30, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEC40C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC410: 419A0020  beq cr6, 0x82cec430
	if ctx.cr[6].eq {
	pc = 0x82CEC430; continue 'dispatch;
	}
	// 82CEC414: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC418: 7C7E502E  lwzx r3, r30, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEC41C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC420: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC424: 4E800421  bctrl
	ctx.lr = 0x82CEC428;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC428: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC42C: 7F9E492E  stwx r28, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[28].u32) };
	// 82CEC430: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82CEC434: 895F003C  lbz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC438: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CEC43C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82CEC440: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC444: 4198FFBC  blt cr6, 0x82cec400
	if ctx.cr[6].lt {
	pc = 0x82CEC400; continue 'dispatch;
	}
	// 82CEC448: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CEC44C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEC450: 419A000C  beq cr6, 0x82cec45c
	if ctx.cr[6].eq {
	pc = 0x82CEC45C; continue 'dispatch;
	}
	// 82CEC454: 4BFF2115  bl 0x82cde568
	ctx.lr = 0x82CEC458;
	sub_82CDE568(ctx, base);
	// 82CEC458: 939F0020  stw r28, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 82CEC45C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEC460: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC464: 394B3FAC  addi r10, r11, 0x3fac
	ctx.r[10].s64 = ctx.r[11].s64 + 16300;
	// 82CEC468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CEC46C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEC470: 419A0018  beq cr6, 0x82cec488
	if ctx.cr[6].eq {
	pc = 0x82CEC488; continue 'dispatch;
	}
	// 82CEC474: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC478: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC47C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC480: 4E800421  bctrl
	ctx.lr = 0x82CEC484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC484: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82CEC488: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEC48C: 394B3DD0  addi r10, r11, 0x3dd0
	ctx.r[10].s64 = ctx.r[11].s64 + 15824;
	// 82CEC490: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEC494: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEC498: 4BFBCFC0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC4A0 size=152
    let mut pc: u32 = 0x82CEC4A0;
    'dispatch: loop {
        match pc {
            0x82CEC4A0 => {
    //   block [0x82CEC4A0..0x82CEC538)
	// 82CEC4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC4A4: 4BFBCF69  bl 0x82ca940c
	ctx.lr = 0x82CEC4A8;
	sub_82CA93D0(ctx, base);
	// 82CEC4A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC4AC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC4B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEC4B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEC4B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEC4BC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82CEC4C0: 816B72AC  lwz r11, 0x72ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEC4C4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82CEC4C8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82CEC4CC: 806B003C  lwz r3, 0x3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC4D0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82CEC4D4: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC4D8: 4BFF5E19  bl 0x82ce22f0
	ctx.lr = 0x82CEC4DC;
	sub_82CE22F0(ctx, base);
	// 82CEC4DC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC4E0: 41980050  blt cr6, 0x82cec530
	if ctx.cr[6].lt {
	pc = 0x82CEC530; continue 'dispatch;
	}
	// 82CEC4E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC4E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82CEC4EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC4F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC4F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC4F8: 4E800421  bctrl
	ctx.lr = 0x82CEC4FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC4FC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC500: 41980030  blt cr6, 0x82cec530
	if ctx.cr[6].lt {
	pc = 0x82CEC530; continue 'dispatch;
	}
	// 82CEC504: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC508: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CEC50C: A1610052  lhz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82CEC510: 9BBF0004  stb r29, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u8 ) };
	// 82CEC514: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82CEC518: 993F0005  stb r9, 5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5 as u32), ctx.r[9].u8 ) };
	// 82CEC51C: 995F0006  stb r10, 6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u8 ) };
	// 82CEC520: A0FE003E  lhz r7, 0x3e(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(62 as u32) ) } as u64;
	// 82CEC524: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CEC528: 40990008  ble cr6, 0x82cec530
	if !ctx.cr[6].gt {
	pc = 0x82CEC530; continue 'dispatch;
	}
	// 82CEC52C: B17E003E  sth r11, 0x3e(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(62 as u32), ctx.r[11].u16 ) };
	// 82CEC530: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CEC534: 4BFBCF28  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC538 size=36
    let mut pc: u32 = 0x82CEC538;
    'dispatch: loop {
        match pc {
            0x82CEC538 => {
    //   block [0x82CEC538..0x82CEC55C)
	// 82CEC538: 8943003C  lbz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC53C: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CEC540: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82CEC544: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82CEC548: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC54C: 41980010  blt cr6, 0x82cec55c
	if ctx.cr[6].lt {
		sub_82CEC55C(ctx, base);
		return;
	}
	// 82CEC550: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEC554: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82CEC558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC55C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC55C size=36
    let mut pc: u32 = 0x82CEC55C;
    'dispatch: loop {
        match pc {
            0x82CEC55C => {
    //   block [0x82CEC55C..0x82CEC580)
	// 82CEC55C: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC560: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC564: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 82CEC568: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82CEC56C: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEC570: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC574: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC578: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC57C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC580 size=36
    let mut pc: u32 = 0x82CEC580;
    'dispatch: loop {
        match pc {
            0x82CEC580 => {
    //   block [0x82CEC580..0x82CEC5A4)
	// 82CEC580: 8943003C  lbz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC584: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CEC588: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82CEC58C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82CEC590: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC594: 41980010  blt cr6, 0x82cec5a4
	if ctx.cr[6].lt {
		sub_82CEC5A4(ctx, base);
		return;
	}
	// 82CEC598: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEC59C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82CEC5A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC5A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC5A4 size=36
    let mut pc: u32 = 0x82CEC5A4;
    'dispatch: loop {
        match pc {
            0x82CEC5A4 => {
    //   block [0x82CEC5A4..0x82CEC5C8)
	// 82CEC5A4: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC5A8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC5AC: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 82CEC5B0: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82CEC5B4: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82CEC5B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC5BC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEC5C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC5C4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC5C8 size=28
    let mut pc: u32 = 0x82CEC5C8;
    'dispatch: loop {
        match pc {
            0x82CEC5C8 => {
    //   block [0x82CEC5C8..0x82CEC5E4)
	// 82CEC5C8: 8943003C  lbz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC5CC: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CEC5D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC5D4: 41980010  blt cr6, 0x82cec5e4
	if ctx.cr[6].lt {
		sub_82CEC5E4(ctx, base);
		return;
	}
	// 82CEC5D8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEC5DC: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82CEC5E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC5E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC5E4 size=28
    let mut pc: u32 = 0x82CEC5E4;
    'dispatch: loop {
        match pc {
            0x82CEC5E4 => {
    //   block [0x82CEC5E4..0x82CEC600)
	// 82CEC5E4: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC5E8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC5EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC5F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEC5F4: 896B0005  lbz r11, 5(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 82CEC5F8: 99650000  stb r11, 0(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82CEC5FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC600 size=28
    let mut pc: u32 = 0x82CEC600;
    'dispatch: loop {
        match pc {
            0x82CEC600 => {
    //   block [0x82CEC600..0x82CEC61C)
	// 82CEC600: 8943003C  lbz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CEC604: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CEC608: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC60C: 41980010  blt cr6, 0x82cec61c
	if ctx.cr[6].lt {
		sub_82CEC61C(ctx, base);
		return;
	}
	// 82CEC610: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CEC614: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82CEC618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC61C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CEC61C size=24
    let mut pc: u32 = 0x82CEC61C;
    'dispatch: loop {
        match pc {
            0x82CEC61C => {
    //   block [0x82CEC61C..0x82CEC634)
	// 82CEC61C: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC620: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC624: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC628: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEC62C: 98AB0005  stb r5, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[5].u8 ) };
	// 82CEC630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC638 size=156
    let mut pc: u32 = 0x82CEC638;
    'dispatch: loop {
        match pc {
            0x82CEC638 => {
    //   block [0x82CEC638..0x82CEC6D4)
	// 82CEC638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEC644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEC648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC64C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC650: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEC654: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82CEC658: 392B3FAC  addi r9, r11, 0x3fac
	ctx.r[9].s64 = ctx.r[11].s64 + 16300;
	// 82CEC65C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82CEC660: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82CEC664: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CEC668: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82CEC66C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEC670: 419A0018  beq cr6, 0x82cec688
	if ctx.cr[6].eq {
	pc = 0x82CEC688; continue 'dispatch;
	}
	// 82CEC674: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC678: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82CEC67C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC680: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC684: 4E800421  bctrl
	ctx.lr = 0x82CEC688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC688: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEC68C: 9BDF000C  stb r30, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 82CEC690: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82CEC694: 392A51A0  addi r9, r10, 0x51a0
	ctx.r[9].s64 = ctx.r[10].s64 + 20896;
	// 82CEC698: 395F0018  addi r10, r31, 0x18
	ctx.r[10].s64 = ctx.r[31].s64 + 24;
	// 82CEC69C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CEC6A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CEC6A4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82CEC6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC6AC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82CEC6B0: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82CEC6B4: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CEC6B8: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82CEC6BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC6C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC6C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC6C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEC6CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEC6D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC6D8 size=92
    let mut pc: u32 = 0x82CEC6D8;
    'dispatch: loop {
        match pc {
            0x82CEC6D8 => {
    //   block [0x82CEC6D8..0x82CEC734)
	// 82CEC6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC6DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC6E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEC6E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEC6E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC6EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEC6F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CEC6F4: 4BFFFCDD  bl 0x82cec3d0
	ctx.lr = 0x82CEC6F8;
	sub_82CEC3D0(ctx, base);
	// 82CEC6F8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82CEC6FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC700: 419A0018  beq cr6, 0x82cec718
	if ctx.cr[6].eq {
	pc = 0x82CEC718; continue 'dispatch;
	}
	// 82CEC704: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC708: 3CA06182  lis r5, 0x6182
	ctx.r[5].s64 = 1635909632;
	// 82CEC70C: 386B7254  addi r3, r11, 0x7254
	ctx.r[3].s64 = ctx.r[11].s64 + 29268;
	// 82CEC710: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82CEC714: 4BFF4115  bl 0x82ce0828
	ctx.lr = 0x82CEC718;
	sub_82CE0828(ctx, base);
	// 82CEC718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC71C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC728: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEC72C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEC730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC738 size=112
    let mut pc: u32 = 0x82CEC738;
    'dispatch: loop {
        match pc {
            0x82CEC738 => {
    //   block [0x82CEC738..0x82CEC7A8)
	// 82CEC738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC73C: 4BFBCCD1  bl 0x82ca940c
	ctx.lr = 0x82CEC740;
	sub_82CA93D0(ctx, base);
	// 82CEC740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC744: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CEC748: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82CEC74C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC750: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CEC754: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC75C: 419A0044  beq cr6, 0x82cec7a0
	if ctx.cr[6].eq {
	pc = 0x82CEC7A0; continue 'dispatch;
	}
	// 82CEC760: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CEC764: 4198003C  blt cr6, 0x82cec7a0
	if ctx.cr[6].lt {
	pc = 0x82CEC7A0; continue 'dispatch;
	}
	// 82CEC768: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC76C: 54C815BA  rlwinm r8, r6, 2, 0x16, 0x1d
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x3FFFFFFFu64;
	// 82CEC770: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CEC774: 54CB1D78  rlwinm r11, r6, 3, 0x15, 0x1c
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x1FFFFFFFu64;
	// 82CEC778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEC77C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEC780: 54DD063E  clrlwi r29, r6, 0x18
	ctx.r[29].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CEC784: 7CA8482E  lwzx r5, r8, r9
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82CEC788: 4BFFFD19  bl 0x82cec4a0
	ctx.lr = 0x82CEC78C;
	sub_82CEC4A0(ctx, base);
	// 82CEC78C: 38FD0001  addi r7, r29, 1
	ctx.r[7].s64 = ctx.r[29].s64 + 1;
	// 82CEC790: 88BF0000  lbz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC794: 54E6063E  clrlwi r6, r7, 0x18
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82CEC798: 7F062840  cmplw cr6, r6, r5
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82CEC79C: 4198FFC4  blt cr6, 0x82cec760
	if ctx.cr[6].lt {
	pc = 0x82CEC760; continue 'dispatch;
	}
	// 82CEC7A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEC7A4: 4BFBCCB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC7A8 size=288
    let mut pc: u32 = 0x82CEC7A8;
    'dispatch: loop {
        match pc {
            0x82CEC7A8 => {
    //   block [0x82CEC7A8..0x82CEC8C8)
	// 82CEC7A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC7AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEC7B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC7B4: 89640005  lbz r11, 5(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 82CEC7B8: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEC7BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC7C0: 409A0018  bne cr6, 0x82cec7d8
	if !ctx.cr[6].eq {
	pc = 0x82CEC7D8; continue 'dispatch;
	}
	// 82CEC7C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEC7C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEC7CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC7D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC7D4: 4E800020  blr
	return;
	// 82CEC7D8: 89640006  lbz r11, 6(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CEC7DC: 556A077C  rlwinm r10, r11, 0, 0x1d, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEC7E0: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 82CEC7E4: 409A0080  bne cr6, 0x82cec864
	if !ctx.cr[6].eq {
	pc = 0x82CEC864; continue 'dispatch;
	}
	// 82CEC7E8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC7EC: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC7F0: 892D010C  lbz r9, 0x10c(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[13].u32.wrapping_add(268 as u32) ) } as u64;
	// 82CEC7F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CEC7F8: 810B72AC  lwz r8, 0x72ac(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CEC7FC: 419A0030  beq cr6, 0x82cec82c
	if ctx.cr[6].eq {
	pc = 0x82CEC82C; continue 'dispatch;
	}
	// 82CEC800: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CEC804: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEC808: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82CEC80C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82CEC810: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC814: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CEC818: 419A0028  beq cr6, 0x82cec840
	if ctx.cr[6].eq {
	pc = 0x82CEC840; continue 'dispatch;
	}
	// 82CEC81C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEC820: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CEC824: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82CEC828: 4198FFE8  blt cr6, 0x82cec810
	if ctx.cr[6].lt {
	pc = 0x82CEC810; continue 'dispatch;
	}
	// 82CEC82C: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEC830: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82CEC834: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC838: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEC83C: 48000060  b 0x82cec89c
	pc = 0x82CEC89C; continue 'dispatch;
	// 82CEC840: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82CEC844: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CEC848: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEC84C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEC850: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 82CEC854: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CEC858: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82CEC85C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CEC860: 4800003C  b 0x82cec89c
	pc = 0x82CEC89C; continue 'dispatch;
	// 82CEC864: 556A07BE  clrlwi r10, r11, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82CEC868: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC86C: 419A0010  beq cr6, 0x82cec87c
	if ctx.cr[6].eq {
	pc = 0x82CEC87C; continue 'dispatch;
	}
	// 82CEC870: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC874: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEC878: 48000024  b 0x82cec89c
	pc = 0x82CEC89C; continue 'dispatch;
	// 82CEC87C: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEC880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEC884: 419A0010  beq cr6, 0x82cec894
	if ctx.cr[6].eq {
	pc = 0x82CEC894; continue 'dispatch;
	}
	// 82CEC888: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC88C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82CEC890: 4800000C  b 0x82cec89c
	pc = 0x82CEC89C; continue 'dispatch;
	// 82CEC894: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC898: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEC89C: 80640000  lwz r3, 0(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC8A0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82CEC8A4: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82CEC8A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CEC8AC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEC8B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CEC8B4: 4E800421  bctrl
	ctx.lr = 0x82CEC8B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEC8B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CEC8BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEC8C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEC8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEC8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CEC8C8 size=548
    let mut pc: u32 = 0x82CEC8C8;
    'dispatch: loop {
        match pc {
            0x82CEC8C8 => {
    //   block [0x82CEC8C8..0x82CECAEC)
	// 82CEC8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEC8CC: 4BFBCB3D  bl 0x82ca9408
	ctx.lr = 0x82CEC8D0;
	sub_82CA93D0(ctx, base);
	// 82CEC8D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEC8D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CEC8D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82CEC8DC: 4BC10BC5  bl 0x828fd4a0
	ctx.lr = 0x82CEC8E0;
	sub_828FD4A0(ctx, base);
	// 82CEC8E0: 485CDA25  bl 0x832ba304
	ctx.lr = 0x82CEC8E4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEC8E4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CEC8E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEC8EC: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CEC8F0: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEC8F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC8F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC8FC: 419A0010  beq cr6, 0x82cec90c
	if ctx.cr[6].eq {
	pc = 0x82CEC90C; continue 'dispatch;
	}
	// 82CEC900: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC904: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC908: 419A0018  beq cr6, 0x82cec920
	if ctx.cr[6].eq {
	pc = 0x82CEC920; continue 'dispatch;
	}
	// 82CEC90C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC910: 485CD9E5  bl 0x832ba2f4
	ctx.lr = 0x82CEC914;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEC914: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC918: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEC91C: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEC920: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEC924: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC928: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEC92C: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEC930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CEC934: 419A00A4  beq cr6, 0x82cec9d8
	if ctx.cr[6].eq {
	pc = 0x82CEC9D8; continue 'dispatch;
	}
	// 82CEC938: 485CD9CD  bl 0x832ba304
	ctx.lr = 0x82CEC93C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEC93C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC940: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEC944: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEC948: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC94C: 419A0010  beq cr6, 0x82cec95c
	if ctx.cr[6].eq {
	pc = 0x82CEC95C; continue 'dispatch;
	}
	// 82CEC950: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC954: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC958: 419A0018  beq cr6, 0x82cec970
	if ctx.cr[6].eq {
	pc = 0x82CEC970; continue 'dispatch;
	}
	// 82CEC95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC960: 485CD995  bl 0x832ba2f4
	ctx.lr = 0x82CEC964;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CEC964: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC968: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CEC96C: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CEC970: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CEC974: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CEC978: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC97C: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CEC980: 5569063E  clrlwi r9, r11, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CEC984: 552907B8  rlwinm r9, r9, 0, 0x1e, 0x1c
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEC988: 993C003D  stb r9, 0x3d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(61 as u32), ctx.r[9].u8 ) };
	// 82CEC98C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC990: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC994: 419A00FC  beq cr6, 0x82ceca90
	if ctx.cr[6].eq {
	pc = 0x82CECA90; continue 'dispatch;
	}
	// 82CEC998: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC99C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CEC9A0: 409A00F0  bne cr6, 0x82ceca90
	if !ctx.cr[6].eq {
	pc = 0x82CECA90; continue 'dispatch;
	}
	// 82CEC9A4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC9A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CEC9AC: 408200E4  bne 0x82ceca90
	if !ctx.cr[0].eq {
	pc = 0x82CECA90; continue 'dispatch;
	}
	// 82CEC9B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CEC9B4: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEC9B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEC9BC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CEC9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEC9C4: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CEC9C8: 485CD96D  bl 0x832ba334
	ctx.lr = 0x82CEC9CC;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CEC9CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CEC9D0: 485CD945  bl 0x832ba314
	ctx.lr = 0x82CEC9D4;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CEC9D4: 480000B8  b 0x82ceca8c
	pc = 0x82CECA8C; continue 'dispatch;
	// 82CEC9D8: 485CD92D  bl 0x832ba304
	ctx.lr = 0x82CEC9DC;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CEC9DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEC9E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CEC9E4: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CEC9E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CEC9EC: 419A0010  beq cr6, 0x82cec9fc
	if ctx.cr[6].eq {
	pc = 0x82CEC9FC; continue 'dispatch;
	}
	// 82CEC9F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEC9F4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEC9F8: 419A0018  beq cr6, 0x82ceca10
	if ctx.cr[6].eq {
	pc = 0x82CECA10; continue 'dispatch;
	}
	// 82CEC9FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECA00: 485CD8F5  bl 0x832ba2f4
	ctx.lr = 0x82CECA04;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECA04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECA08: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CECA0C: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CECA10: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECA14: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECA18: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECA1C: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECA20: 5569063C  rlwinm r9, r11, 0, 0x18, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CECA24: 552906B0  rlwinm r9, r9, 0, 0x1a, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CECA28: 61280001  ori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 | 1;
	// 82CECA2C: 991C003D  stb r8, 0x3d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(61 as u32), ctx.r[8].u8 ) };
	// 82CECA30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECA34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECA38: 419A0040  beq cr6, 0x82ceca78
	if ctx.cr[6].eq {
	pc = 0x82CECA78; continue 'dispatch;
	}
	// 82CECA3C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECA40: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECA44: 409A0034  bne cr6, 0x82ceca78
	if !ctx.cr[6].eq {
	pc = 0x82CECA78; continue 'dispatch;
	}
	// 82CECA48: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECA4C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECA50: 40820028  bne 0x82ceca78
	if !ctx.cr[0].eq {
	pc = 0x82CECA78; continue 'dispatch;
	}
	// 82CECA54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECA58: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECA5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECA60: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECA68: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECA6C: 485CD8C9  bl 0x832ba334
	ctx.lr = 0x82CECA70;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECA70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECA74: 485CD8A1  bl 0x832ba314
	ctx.lr = 0x82CECA78;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECA78: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECA7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CECA80: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CECA84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CECA88: 4E800421  bctrl
	ctx.lr = 0x82CECA8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CECA8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECA90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECA94: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECA98: 419A0040  beq cr6, 0x82cecad8
	if ctx.cr[6].eq {
	pc = 0x82CECAD8; continue 'dispatch;
	}
	// 82CECA9C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECAA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECAA4: 409A0034  bne cr6, 0x82cecad8
	if !ctx.cr[6].eq {
	pc = 0x82CECAD8; continue 'dispatch;
	}
	// 82CECAA8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECAAC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECAB0: 40820028  bne 0x82cecad8
	if !ctx.cr[0].eq {
	pc = 0x82CECAD8; continue 'dispatch;
	}
	// 82CECAB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECAB8: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECABC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECAC0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECAC8: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECACC: 485CD869  bl 0x832ba334
	ctx.lr = 0x82CECAD0;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECAD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECAD4: 485CD841  bl 0x832ba314
	ctx.lr = 0x82CECAD8;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECAD8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82CECADC: 4BC109C5  bl 0x828fd4a0
	ctx.lr = 0x82CECAE0;
	sub_828FD4A0(ctx, base);
	// 82CECAE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECAE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECAE8: 4BFBC970  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CECAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CECAF0 size=960
    let mut pc: u32 = 0x82CECAF0;
    'dispatch: loop {
        match pc {
            0x82CECAF0 => {
    //   block [0x82CECAF0..0x82CECEB0)
	// 82CECAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CECAF4: 4BFBC915  bl 0x82ca9408
	ctx.lr = 0x82CECAF8;
	sub_82CA93D0(ctx, base);
	// 82CECAF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CECAFC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CECB00: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECB04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82CECB08: 4BC10999  bl 0x828fd4a0
	ctx.lr = 0x82CECB0C;
	sub_828FD4A0(ctx, base);
	// 82CECB0C: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 82CECB10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECB14: 419A01DC  beq cr6, 0x82ceccf0
	if ctx.cr[6].eq {
	pc = 0x82CECCF0; continue 'dispatch;
	}
	// 82CECB18: 485CD7ED  bl 0x832ba304
	ctx.lr = 0x82CECB1C;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CECB1C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CECB20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CECB24: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CECB28: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CECB2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECB30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECB34: 419A0010  beq cr6, 0x82cecb44
	if ctx.cr[6].eq {
	pc = 0x82CECB44; continue 'dispatch;
	}
	// 82CECB38: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECB3C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECB40: 419A0018  beq cr6, 0x82cecb58
	if ctx.cr[6].eq {
	pc = 0x82CECB58; continue 'dispatch;
	}
	// 82CECB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECB48: 485CD7AD  bl 0x832ba2f4
	ctx.lr = 0x82CECB4C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECB4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECB50: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CECB54: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CECB58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECB5C: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82CECB60: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECB64: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82CECB68: 806A72AC  lwz r3, 0x72ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29356 as u32) ) } as u64;
	// 82CECB6C: 4BFF415D  bl 0x82ce0cc8
	ctx.lr = 0x82CECB70;
	sub_82CE0CC8(ctx, base);
	// 82CECB70: 893C003D  lbz r9, 0x3d(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECB74: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82CECB78: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CECB7C: 409A0064  bne cr6, 0x82cecbe0
	if !ctx.cr[6].eq {
	pc = 0x82CECBE0; continue 'dispatch;
	}
	// 82CECB80: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECB84: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECB88: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CECB8C: 419A0310  beq cr6, 0x82cece9c
	if ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECB90: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECB94: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CECB98: 409A0304  bne cr6, 0x82cece9c
	if !ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECB9C: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECBA0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECBA4: 408202F8  bne 0x82cece9c
	if !ctx.cr[0].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECBA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECBAC: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECBB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECBB4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECBBC: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECBC0: 485CD775  bl 0x832ba334
	ctx.lr = 0x82CECBC4;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECBC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECBC8: 485CD74D  bl 0x832ba314
	ctx.lr = 0x82CECBCC;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECBCC: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECBD0: 4BC108D1  bl 0x828fd4a0
	ctx.lr = 0x82CECBD4;
	sub_828FD4A0(ctx, base);
	// 82CECBD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECBD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECBDC: 4BFBC87C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82CECBE0: 485CD725  bl 0x832ba304
	ctx.lr = 0x82CECBE4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CECBE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECBE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CECBEC: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CECBF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECBF4: 419A0010  beq cr6, 0x82cecc04
	if ctx.cr[6].eq {
	pc = 0x82CECC04; continue 'dispatch;
	}
	// 82CECBF8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECBFC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECC00: 419A0018  beq cr6, 0x82cecc18
	if ctx.cr[6].eq {
	pc = 0x82CECC18; continue 'dispatch;
	}
	// 82CECC04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECC08: 485CD6ED  bl 0x832ba2f4
	ctx.lr = 0x82CECC0C;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECC0C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECC10: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CECC14: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CECC18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECC1C: 398000BA  li r12, 0xba
	ctx.r[12].s64 = 186;
	// 82CECC20: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECC24: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECC28: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECC2C: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82CECC30: 993C003D  stb r9, 0x3d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(61 as u32), ctx.r[9].u8 ) };
	// 82CECC34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECC38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECC3C: 419A0040  beq cr6, 0x82cecc7c
	if ctx.cr[6].eq {
	pc = 0x82CECC7C; continue 'dispatch;
	}
	// 82CECC40: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECC44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECC48: 409A0034  bne cr6, 0x82cecc7c
	if !ctx.cr[6].eq {
	pc = 0x82CECC7C; continue 'dispatch;
	}
	// 82CECC4C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECC50: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECC54: 40820028  bne 0x82cecc7c
	if !ctx.cr[0].eq {
	pc = 0x82CECC7C; continue 'dispatch;
	}
	// 82CECC58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECC5C: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECC60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECC64: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECC6C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECC70: 485CD6C5  bl 0x832ba334
	ctx.lr = 0x82CECC74;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECC74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECC78: 485CD69D  bl 0x832ba314
	ctx.lr = 0x82CECC7C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECC7C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECC80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CECC84: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CECC88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CECC8C: 4E800421  bctrl
	ctx.lr = 0x82CECC90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CECC90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECC94: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECC98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECC9C: 419A0200  beq cr6, 0x82cece9c
	if ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECCA0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECCA4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECCA8: 409A01F4  bne cr6, 0x82cece9c
	if !ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECCAC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECCB0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECCB4: 408201E8  bne 0x82cece9c
	if !ctx.cr[0].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECCB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECCBC: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECCC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECCC4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECCC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECCCC: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECCD0: 485CD665  bl 0x832ba334
	ctx.lr = 0x82CECCD4;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECCD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECCD8: 485CD63D  bl 0x832ba314
	ctx.lr = 0x82CECCDC;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECCDC: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECCE0: 4BC107C1  bl 0x828fd4a0
	ctx.lr = 0x82CECCE4;
	sub_828FD4A0(ctx, base);
	// 82CECCE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECCE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECCEC: 4BFBC76C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82CECCF0: 485CD615  bl 0x832ba304
	ctx.lr = 0x82CECCF4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CECCF4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82CECCF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CECCFC: 3BEB7238  addi r31, r11, 0x7238
	ctx.r[31].s64 = ctx.r[11].s64 + 29240;
	// 82CECD00: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CECD04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECD08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECD0C: 419A0010  beq cr6, 0x82cecd1c
	if ctx.cr[6].eq {
	pc = 0x82CECD1C; continue 'dispatch;
	}
	// 82CECD10: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECD14: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECD18: 419A0024  beq cr6, 0x82cecd3c
	if ctx.cr[6].eq {
	pc = 0x82CECD3C; continue 'dispatch;
	}
	// 82CECD1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECD20: 485CD5D5  bl 0x832ba2f4
	ctx.lr = 0x82CECD24;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECD24: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82CECD28: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82CECD2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECD30: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECD34: 993F000C  stb r9, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 82CECD38: 48000008  b 0x82cecd40
	pc = 0x82CECD40; continue 'dispatch;
	// 82CECD3C: 893F000C  lbz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECD40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECD44: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECD48: 891C003D  lbz r8, 0x3d(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECD4C: 550707FE  clrlwi r7, r8, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 82CECD50: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CECD54: 409A005C  bne cr6, 0x82cecdb0
	if !ctx.cr[6].eq {
	pc = 0x82CECDB0; continue 'dispatch;
	}
	// 82CECD58: 7DA86B78  mr r8, r13
	ctx.r[8].u64 = ctx.r[13].u64;
	// 82CECD5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECD60: 419A013C  beq cr6, 0x82cece9c
	if ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECD64: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECD68: 409A0134  bne cr6, 0x82cece9c
	if !ctx.cr[6].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECD6C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECD70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECD74: 40820128  bne 0x82cece9c
	if !ctx.cr[0].eq {
	pc = 0x82CECE9C; continue 'dispatch;
	}
	// 82CECD78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECD7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECD80: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECD84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECD88: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECD8C: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82CECD90: 485CD5A5  bl 0x832ba334
	ctx.lr = 0x82CECD94;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECD94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECD98: 485CD57D  bl 0x832ba314
	ctx.lr = 0x82CECD9C;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECD9C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECDA0: 4BC10701  bl 0x828fd4a0
	ctx.lr = 0x82CECDA4;
	sub_828FD4A0(ctx, base);
	// 82CECDA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECDA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECDAC: 4BFBC6AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82CECDB0: 485CD555  bl 0x832ba304
	ctx.lr = 0x82CECDB4;
	// extern call 0x832BA304 → crate::xboxkrnl::KeRaiseIrqlToDpcLevel
	crate::xboxkrnl::KeRaiseIrqlToDpcLevel(ctx, base);
	// 82CECDB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECDB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82CECDBC: 7DBE6B78  mr r30, r13
	ctx.r[30].u64 = ctx.r[13].u64;
	// 82CECDC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECDC4: 419A0010  beq cr6, 0x82cecdd4
	if ctx.cr[6].eq {
	pc = 0x82CECDD4; continue 'dispatch;
	}
	// 82CECDC8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECDCC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CECDD0: 419A0018  beq cr6, 0x82cecde8
	if ctx.cr[6].eq {
	pc = 0x82CECDE8; continue 'dispatch;
	}
	// 82CECDD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECDD8: 485CD51D  bl 0x832ba2f4
	ctx.lr = 0x82CECDDC;
	// extern call 0x832BA2F4 → crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql
	crate::xboxkrnl::KeAcquireSpinLockAtRaisedIrql(ctx, base);
	// 82CECDDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECDE0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82CECDE4: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 82CECDE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CECDEC: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECDF0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECDF4: 897C003D  lbz r11, 0x3d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(61 as u32) ) } as u64;
	// 82CECDF8: 61690004  ori r9, r11, 4
	ctx.r[9].u64 = ctx.r[11].u64 | 4;
	// 82CECDFC: 993C003D  stb r9, 0x3d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(61 as u32), ctx.r[9].u8 ) };
	// 82CECE00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECE04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECE08: 419A0044  beq cr6, 0x82cece4c
	if ctx.cr[6].eq {
	pc = 0x82CECE4C; continue 'dispatch;
	}
	// 82CECE0C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECE10: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECE14: 409A0038  bne cr6, 0x82cece4c
	if !ctx.cr[6].eq {
	pc = 0x82CECE4C; continue 'dispatch;
	}
	// 82CECE18: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECE1C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECE20: 4082002C  bne 0x82cece4c
	if !ctx.cr[0].eq {
	pc = 0x82CECE4C; continue 'dispatch;
	}
	// 82CECE24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECE28: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECE2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECE30: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECE38: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECE3C: 485CD4F9  bl 0x832ba334
	ctx.lr = 0x82CECE40;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECE40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECE44: 485CD4D1  bl 0x832ba314
	ctx.lr = 0x82CECE48;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECE48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECE4C: 7DAA6B78  mr r10, r13
	ctx.r[10].u64 = ctx.r[13].u64;
	// 82CECE50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECE54: 419A0040  beq cr6, 0x82cece94
	if ctx.cr[6].eq {
	pc = 0x82CECE94; continue 'dispatch;
	}
	// 82CECE58: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECE5C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CECE60: 409A0034  bne cr6, 0x82cece94
	if !ctx.cr[6].eq {
	pc = 0x82CECE94; continue 'dispatch;
	}
	// 82CECE64: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CECE68: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CECE6C: 40820028  bne 0x82cece94
	if !ctx.cr[0].eq {
	pc = 0x82CECE94; continue 'dispatch;
	}
	// 82CECE70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CECE74: 8BDF000C  lbz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECE78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CECE7C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CECE80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECE84: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82CECE88: 485CD4AD  bl 0x832ba334
	ctx.lr = 0x82CECE8C;
	// extern call 0x832BA334 → crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql
	crate::xboxkrnl::KeReleaseSpinLockFromRaisedIrql(ctx, base);
	// 82CECE8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82CECE90: 485CD485  bl 0x832ba314
	ctx.lr = 0x82CECE94;
	// extern call 0x832BA314 → crate::xboxkrnl::KfLowerIrql
	crate::xboxkrnl::KfLowerIrql(ctx, base);
	// 82CECE94: A17C003E  lhz r11, 0x3e(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(62 as u32) ) } as u64;
	// 82CECE98: B17C0040  sth r11, 0x40(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), ctx.r[11].u16 ) };
	// 82CECE9C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82CECEA0: 4BC10601  bl 0x828fd4a0
	ctx.lr = 0x82CECEA4;
	sub_828FD4A0(ctx, base);
	// 82CECEA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CECEA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82CECEAC: 4BFBC5AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CECEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CECEB0 size=308
    let mut pc: u32 = 0x82CECEB0;
    'dispatch: loop {
        match pc {
            0x82CECEB0 => {
    //   block [0x82CECEB0..0x82CECFE4)
	// 82CECEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CECEB4: 4BFBC555  bl 0x82ca9408
	ctx.lr = 0x82CECEB8;
	sub_82CA93D0(ctx, base);
	// 82CECEB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CECEBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82CECEC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CECEC4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82CECEC8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82CECECC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CECED0: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82CECED4: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CECED8: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82CECEDC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECEE0: 913F0034  stw r9, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 82CECEE4: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CECEE8: 911F0038  stw r8, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[8].u32 ) };
	// 82CECEEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECEF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECEF4: 419A000C  beq cr6, 0x82cecf00
	if ctx.cr[6].eq {
	pc = 0x82CECF00; continue 'dispatch;
	}
	// 82CECEF8: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECEFC: 48000008  b 0x82cecf04
	pc = 0x82CECF04; continue 'dispatch;
	// 82CECF00: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82CECF04: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82CECF08: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECF0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECF10: 419A001C  beq cr6, 0x82cecf2c
	if ctx.cr[6].eq {
	pc = 0x82CECF2C; continue 'dispatch;
	}
	// 82CECF14: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82CECF18: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CECF1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CECF20: 419A0054  beq cr6, 0x82cecf74
	if ctx.cr[6].eq {
	pc = 0x82CECF74; continue 'dispatch;
	}
	// 82CECF24: 4BFF1625  bl 0x82cde548
	ctx.lr = 0x82CECF28;
	sub_82CDE548(ctx, base);
	// 82CECF28: 4800004C  b 0x82cecf74
	pc = 0x82CECF74; continue 'dispatch;
	// 82CECF2C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82CECF30: 895E0001  lbz r10, 1(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CECF34: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82CECF38: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECF3C: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 82CECF40: 6128BB80  ori r8, r9, 0xbb80
	ctx.r[8].u64 = ctx.r[9].u64 | 48000;
	// 82CECF44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82CECF48: FBAB0000  std r29, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 82CECF4C: FBAB0008  std r29, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 82CECF50: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82CECF54: 9BA10054  stb r29, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u8 ) };
	// 82CECF58: 99410055  stb r10, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[10].u8 ) };
	// 82CECF5C: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82CECF60: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82CECF64: 4BFF191D  bl 0x82cde880
	ctx.lr = 0x82CECF68;
	sub_82CDE880(ctx, base);
	// 82CECF68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82CECF6C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82CECF70: 41980068  blt cr6, 0x82cecfd8
	if ctx.cr[6].lt {
	pc = 0x82CECFD8; continue 'dispatch;
	}
	// 82CECF74: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CECF78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECF7C: 419A002C  beq cr6, 0x82cecfa8
	if ctx.cr[6].eq {
	pc = 0x82CECFA8; continue 'dispatch;
	}
	// 82CECF80: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECF84: 55641838  slwi r4, r11, 3
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CECF88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CECF8C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CECF90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CECF94: 4E800421  bctrl
	ctx.lr = 0x82CECF98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CECF98: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 82CECF9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82CECFA0: 419A0028  beq cr6, 0x82cecfc8
	if ctx.cr[6].eq {
	pc = 0x82CECFC8; continue 'dispatch;
	}
	// 82CECFA4: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82CECFA8: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CECFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CECFB0: 419A0028  beq cr6, 0x82cecfd8
	if ctx.cr[6].eq {
	pc = 0x82CECFD8; continue 'dispatch;
	}
	// 82CECFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CECFB8: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CECFBC: 4BFFF77D  bl 0x82cec738
	ctx.lr = 0x82CECFC0;
	sub_82CEC738(ctx, base);
	// 82CECFC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CECFC4: 4BFBC494  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82CECFC8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82CECFCC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 82CECFD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CECFD4: 4BFBC484  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82CECFD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82CECFDC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CECFE0: 4BFBC478  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CECFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CECFE8 size=104
    let mut pc: u32 = 0x82CECFE8;
    'dispatch: loop {
        match pc {
            0x82CECFE8 => {
    //   block [0x82CECFE8..0x82CED050)
	// 82CECFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CECFEC: 4BFBC421  bl 0x82ca940c
	ctx.lr = 0x82CECFF0;
	sub_82CA93D0(ctx, base);
	// 82CECFF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CECFF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CECFF8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82CECFFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CED000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CED004: 895F003C  lbz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CED008: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CED00C: 419A003C  beq cr6, 0x82ced048
	if ctx.cr[6].eq {
	pc = 0x82CED048; continue 'dispatch;
	}
	// 82CED010: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82CED014: 41980034  blt cr6, 0x82ced048
	if ctx.cr[6].lt {
	pc = 0x82CED048; continue 'dispatch;
	}
	// 82CED018: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82CED01C: 556A1D78  rlwinm r10, r11, 3, 0x15, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82CED020: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82CED024: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82CED028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CED02C: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CED030: 4BFFF779  bl 0x82cec7a8
	ctx.lr = 0x82CED034;
	sub_82CEC7A8(ctx, base);
	// 82CED034: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82CED038: 895F003C  lbz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82CED03C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CED040: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CED044: 4198FFCC  blt cr6, 0x82ced010
	if ctx.cr[6].lt {
	pc = 0x82CED010; continue 'dispatch;
	}
	// 82CED048: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CED04C: 4BFBC410  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CED050 size=16
    let mut pc: u32 = 0x82CED050;
    'dispatch: loop {
        match pc {
            0x82CED050 => {
    //   block [0x82CED050..0x82CED060)
	// 82CED050: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82CED054: 4199000C  bgt cr6, 0x82ced060
	if ctx.cr[6].gt {
		sub_82CED060(ctx, base);
		return;
	}
	// 82CED058: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82CED05C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CED060 size=16
    let mut pc: u32 = 0x82CED060;
    'dispatch: loop {
        match pc {
            0x82CED060 => {
    //   block [0x82CED060..0x82CED070)
	// 82CED060: 2B0326F5  cmplwi cr6, r3, 0x26f5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 9973 as u32, &mut ctx.xer);
	// 82CED064: 4198000C  blt cr6, 0x82ced070
	if ctx.cr[6].lt {
		sub_82CED070(ctx, base);
		return;
	}
	// 82CED068: 386026F5  li r3, 0x26f5
	ctx.r[3].s64 = 9973;
	// 82CED06C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CED070 size=60
    let mut pc: u32 = 0x82CED070;
    'dispatch: loop {
        match pc {
            0x82CED070 => {
    //   block [0x82CED070..0x82CED0AC)
	// 82CED070: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CED074: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CED078: 390004CD  li r8, 0x4cd
	ctx.r[8].s64 = 1229;
	// 82CED07C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CED080: 38CA51F8  addi r6, r10, 0x51f8
	ctx.r[6].s64 = ctx.r[10].s64 + 20984;
	// 82CED084: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CED088: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82CED08C: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CED090: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CED094: 7D45302E  lwzx r10, r5, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82CED098: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82CED09C: 419A001C  beq cr6, 0x82ced0b8
	if ctx.cr[6].eq {
		sub_82CED0AC(ctx, base);
		return;
	}
	// 82CED0A0: 4099000C  ble cr6, 0x82ced0ac
	if !ctx.cr[6].gt {
		sub_82CED0AC(ctx, base);
		return;
	}
	// 82CED0A4: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82CED0A8: 48000008  b 0x82ced0b0
	sub_82CED0AC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED0AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CED0AC size=24
    let mut pc: u32 = 0x82CED0AC;
    'dispatch: loop {
        match pc {
            0x82CED0AC => {
    //   block [0x82CED0AC..0x82CED0C4)
	// 82CED0AC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82CED0B0: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CED0B4: 409AFFD0  bne cr6, 0x82ced084
	if !ctx.cr[6].eq {
		sub_82CED070(ctx, base);
		return;
	}
	// 82CED0B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CED0BC: 7C6B302E  lwzx r3, r11, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82CED0C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CED0C8 size=56
    let mut pc: u32 = 0x82CED0C8;
    'dispatch: loop {
        match pc {
            0x82CED0C8 => {
    //   block [0x82CED0C8..0x82CED100)
	// 82CED0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CED0D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CED0D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CED0DC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82CED0E0: 4BFF4479  bl 0x82ce1558
	ctx.lr = 0x82CED0E4;
	sub_82CE1558(ctx, base);
	// 82CED0E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CED0E8: 4BFF4471  bl 0x82ce1558
	ctx.lr = 0x82CED0EC;
	sub_82CE1558(ctx, base);
	// 82CED0EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CED0F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CED0F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CED0F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CED0FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82CED100 size=188
    let mut pc: u32 = 0x82CED100;
    'dispatch: loop {
        match pc {
            0x82CED100 => {
    //   block [0x82CED100..0x82CED1BC)
	// 82CED100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CED108: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CED10C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CED110: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED114: 549E063E  clrlwi r30, r4, 0x18
	ctx.r[30].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CED118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CED11C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CED120: 419A0084  beq cr6, 0x82ced1a4
	if ctx.cr[6].eq {
	pc = 0x82CED1A4; continue 'dispatch;
	}
	// 82CED124: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CED128: 1C9E0078  mulli r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 * 120;
	// 82CED12C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CED130: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82CED134: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82CED138: 4E800421  bctrl
	ctx.lr = 0x82CED13C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CED13C: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82CED140: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82CED144: 419A0060  beq cr6, 0x82ced1a4
	if ctx.cr[6].eq {
	pc = 0x82CED1A4; continue 'dispatch;
	}
	// 82CED148: 393F000C  addi r9, r31, 0xc
	ctx.r[9].s64 = ctx.r[31].s64 + 12;
	// 82CED14C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CED150: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82CED154: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CED158: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CED15C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CED160: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CED164: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CED168: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CED16C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CED170: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82CED174: 80FF0018  lwz r7, 0x18(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CED178: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CED17C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CED180: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82CED184: 394A0078  addi r10, r10, 0x78
	ctx.r[10].s64 = ctx.r[10].s64 + 120;
	// 82CED188: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82CED18C: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CED190: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82CED194: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82CED198: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CED19C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82CED1A0: 4082FFB4  bne 0x82ced154
	if !ctx.cr[0].eq {
	pc = 0x82CED154; continue 'dispatch;
	}
	// 82CED1A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CED1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CED1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CED1B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CED1B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CED1B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CED1C0 size=36
    let mut pc: u32 = 0x82CED1C0;
    'dispatch: loop {
        match pc {
            0x82CED1C0 => {
    //   block [0x82CED1C0..0x82CED1E4)
	// 82CED1C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CED1C4: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82CED1C8: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 82CED1CC: 90630004  stw r3, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82CED1D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CED1D4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82CED1D8: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82CED1DC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82CED1E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CED1E8 size=616
    let mut pc: u32 = 0x82CED1E8;
    'dispatch: loop {
        match pc {
            0x82CED1E8 => {
    //   block [0x82CED1E8..0x82CED450)
	// 82CED1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED1EC: 4BFBC21D  bl 0x82ca9408
	ctx.lr = 0x82CED1F0;
	sub_82CA93D0(ctx, base);
	// 82CED1F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED1F4: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CED1F8: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CED1FC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CED200: 7C001A2C  dcbt 0, r3
	// 82CED204: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CED208: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CED20C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CED210: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CED214: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CED218: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CED21C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CED220: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CED224: 38886880  addi r4, r8, 0x6880
	ctx.r[4].s64 = ctx.r[8].s64 + 26752;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CED450 size=716
    let mut pc: u32 = 0x82CED450;
    'dispatch: loop {
        match pc {
            0x82CED450 => {
    //   block [0x82CED450..0x82CED71C)
	// 82CED450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED454: 4BFBBFAD  bl 0x82ca9400
	ctx.lr = 0x82CED458;
	sub_82CA93D0(ctx, base);
	// 82CED458: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED45C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82CED460: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CED464: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CED468: 7C001A2C  dcbt 0, r3
	// 82CED46C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CED470: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CED474: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CED478: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CED47C: C17E002C  lfs f11, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CED480: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CED484: 38E96890  addi r7, r9, 0x6890
	ctx.r[7].s64 = ctx.r[9].s64 + 26768;
	// 82CED488: D1BE0024  stfs f13, 0x24(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CED48C: 38886880  addi r4, r8, 0x6880
	ctx.r[4].s64 = ctx.r[8].s64 + 26752;
	// 82CED490: C15E0030  lfs f10, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CED494: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CED498: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CED49C: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CED4A0: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82CED4A4: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CED4A8: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CED720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CED720 size=928
    let mut pc: u32 = 0x82CED720;
    'dispatch: loop {
        match pc {
            0x82CED720 => {
    //   block [0x82CED720..0x82CEDAC0)
	// 82CED720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CED724: 4BFBBCBD  bl 0x82ca93e0
	ctx.lr = 0x82CED728;
	sub_82CA93D0(ctx, base);
	// 82CED728: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CED72C: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82CED730: C0180024  lfs f0, 0x24(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CED734: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CED738: 7C001A2C  dcbt 0, r3
	// 82CED73C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CED740: C1B80028  lfs f13, 0x28(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CED744: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CED748: C178002C  lfs f11, 0x2c(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CED74C: 7CC807B4  extsw r8, r6
	ctx.r[8].s64 = ctx.r[6].s32 as i64;
	// 82CED750: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 82CED754: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CED758: C1580030  lfs f10, 0x30(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CED75C: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82CED760: D1B80024  stfs f13, 0x24(r24)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CED764: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CED768: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CED76C: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CED770: 3FA08204  lis r29, -0x7dfc
	ctx.r[29].s64 = -2113667072;
	// 82CED774: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CED778: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82CED77C: 390B6890  addi r8, r11, 0x6890
	ctx.r[8].s64 = ctx.r[11].s64 + 26768;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEDAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEDAC0 size=1184
    let mut pc: u32 = 0x82CEDAC0;
    'dispatch: loop {
        match pc {
            0x82CEDAC0 => {
    //   block [0x82CEDAC0..0x82CEDF60)
	// 82CEDAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEDAC4: 4BFBB90D  bl 0x82ca93d0
	ctx.lr = 0x82CEDAC8;
	sub_82CA93D0(ctx, base);
	// 82CEDAC8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEDACC: C0070024  lfs f0, 0x24(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEDAD0: 90C1013C  stw r6, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[6].u32 ) };
	// 82CEDAD4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEDAD8: 90E10144  stw r7, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[7].u32 ) };
	// 82CEDADC: 7C001A2C  dcbt 0, r3
	// 82CEDAE0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEDAE4: C1A70028  lfs f13, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEDAE8: 3AC00004  li r22, 4
	ctx.r[22].s64 = 4;
	// 82CEDAEC: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEDAF0: C167002C  lfs f11, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEDAF4: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82CEDAF8: C1470030  lfs f10, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEDAFC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEDF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEDF60 size=444
    let mut pc: u32 = 0x82CEDF60;
    'dispatch: loop {
        match pc {
            0x82CEDF60 => {
    //   block [0x82CEDF60..0x82CEE0A8)
	// 82CEDF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEDF64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CEDF68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82CEDF6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CEDF70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEDF74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82CEDF78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CEDF7C: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEDF80: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CEDF84: 4198000C  blt cr6, 0x82cedf90
	if ctx.cr[6].lt {
	pc = 0x82CEDF90; continue 'dispatch;
	}
	// 82CEDF88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82CEDF8C: 48000178  b 0x82cee104
	pc = 0x82CEE104; continue 'dispatch;
	// 82CEDF90: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CEDF94: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CEDF98: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEDF9C: 4098FFEC  bge cr6, 0x82cedf88
	if !ctx.cr[6].lt {
	pc = 0x82CEDF88; continue 'dispatch;
	}
	// 82CEDFA0: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82CEDFA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEDFA8: 419A0144  beq cr6, 0x82cee0ec
	if ctx.cr[6].eq {
	pc = 0x82CEE0EC; continue 'dispatch;
	}
	// 82CEDFAC: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82CEDFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82CEDFB4: 419A0130  beq cr6, 0x82cee0e4
	if ctx.cr[6].eq {
	pc = 0x82CEE0E4; continue 'dispatch;
	}
	// 82CEDFB8: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82CEDFBC: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEDFC0: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CEDFC4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82CEDFC8: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82CEDFCC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CEDFD0: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 82CEDFD4: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82CEDFD8: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82CEDFDC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CEDFE0: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CEDFE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEDFE8: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82CEDFEC: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CEDFF0: ED0A4824  fdivs f8, f10, f9
	ctx.f[8].f64 = ((ctx.f[10].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CEDFF4: D11F002C  stfs f8, 0x2c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82CEDFF8: 419A0058  beq cr6, 0x82cee050
	if ctx.cr[6].eq {
	pc = 0x82CEE050; continue 'dispatch;
	}
	// 82CEDFFC: 54E8003E  slwi r8, r7, 0
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CEE000: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEE004: 409A001C  bne cr6, 0x82cee020
	if !ctx.cr[6].eq {
	pc = 0x82CEE020; continue 'dispatch;
	}
	// 82CEE008: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE00C: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 82CEE010: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82CEE014: 552B07FA  rlwinm r11, r9, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE018: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82CEE01C: 48000048  b 0x82cee064
	pc = 0x82CEE064; continue 'dispatch;
	// 82CEE020: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CEE024: 419A002C  beq cr6, 0x82cee050
	if ctx.cr[6].eq {
	pc = 0x82CEE050; continue 'dispatch;
	}
	// 82CEE028: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82CEE02C: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CEE030: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CEE034: 409A001C  bne cr6, 0x82cee050
	if !ctx.cr[6].eq {
	pc = 0x82CEE050; continue 'dispatch;
	}
	// 82CEE038: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE03C: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 82CEE040: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82CEE044: 552B07FA  rlwinm r11, r9, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE048: 394B0005  addi r10, r11, 5
	ctx.r[10].s64 = ctx.r[11].s64 + 5;
	// 82CEE04C: 48000018  b 0x82cee064
	pc = 0x82CEE064; continue 'dispatch;
	// 82CEE050: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE054: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 82CEE058: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82CEE05C: 552B07FA  rlwinm r11, r9, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82CEE060: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 82CEE064: 897F000D  lbz r11, 0xd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CEE068: 891F000C  lbz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82CEE06C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82CEE070: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 82CEE074: 41990040  bgt cr6, 0x82cee0b4
	if ctx.cr[6].gt {
	pc = 0x82CEE0B4; continue 'dispatch;
	}
	// 82CEE078: 3D8082CF  lis r12, -0x7d31
	ctx.r[12].s64 = -2100363264;
	// 82CEE07C: 398CE090  addi r12, r12, -0x1f70
	ctx.r[12].s64 = ctx.r[12].s64 + -8048;
	// 82CEE080: 5520103A  slwi r0, r9, 2
	ctx.r[0].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82CEE084: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82CEE088: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82CEE08C: 4E800420  bctr
	match ctx.r[9].u64 {
		0 => {
	pc = 0x82CEE0A8; continue 'dispatch;
		},
		1 => {
	pc = 0x82CEE0A8; continue 'dispatch;
		},
		2 => {
	pc = 0x82CEE0B4; continue 'dispatch;
		},
		3 => {
	pc = 0x82CEE0A8; continue 'dispatch;
		},
		4 => {
	pc = 0x82CEE0B4; continue 'dispatch;
		},
		5 => {
	pc = 0x82CEE0A8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82CEE090: 82CEE0A8  lwz r22, -0x1f58(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8024 as u32) ) } as u64;
	// 82CEE094: 82CEE0A8  lwz r22, -0x1f58(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8024 as u32) ) } as u64;
	// 82CEE098: 82CEE0B4  lwz r22, -0x1f4c(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8012 as u32) ) } as u64;
	// 82CEE09C: 82CEE0A8  lwz r22, -0x1f58(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8024 as u32) ) } as u64;
	// 82CEE0A0: 82CEE0B4  lwz r22, -0x1f4c(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8012 as u32) ) } as u64;
	// 82CEE0A4: 82CEE0A8  lwz r22, -0x1f58(r14)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8024 as u32) ) } as u64;
            }
            0x82CEE0A8 => {
    //   block [0x82CEE0A8..0x82CEE0B4)
	// 82CEE0A8: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEE0AC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82CEE0B0: 48000008  b 0x82cee0b8
	pc = 0x82CEE0B8; continue 'dispatch;
            }
            0x82CEE0B4 => {
    //   block [0x82CEE0B4..0x82CEE11C)
	// 82CEE0B4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CEE0B8: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CEE0BC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CEE0C0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CEE0C4: 38C76530  addi r6, r7, 0x6530
	ctx.r[6].s64 = ctx.r[7].s64 + 25904;
	// 82CEE0C8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82CEE0CC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CEE0D0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CEE0D4: 7CAB4A14  add r5, r11, r9
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82CEE0D8: 54A4103A  slwi r4, r5, 2
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CEE0DC: 7C64302E  lwzx r3, r4, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82CEE0E0: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 82CEE0E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CEE0E8: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82CEE0EC: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82CEE0F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82CEE0F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82CEE0F8: 4E800421  bctrl
	ctx.lr = 0x82CEE0FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82CEE0FC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CEE100: 7C7E5050  subf r3, r30, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 82CEE104: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82CEE108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CEE10C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CEE110: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CEE114: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CEE118: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEE120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEE120 size=508
    let mut pc: u32 = 0x82CEE120;
    'dispatch: loop {
        match pc {
            0x82CEE120 => {
    //   block [0x82CEE120..0x82CEE31C)
	// 82CEE120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEE124: 4BFBB2E9  bl 0x82ca940c
	ctx.lr = 0x82CEE128;
	sub_82CA93D0(ctx, base);
	// 82CEE128: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEE12C: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CEE130: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEE134: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEE138: 7C001A2C  dcbt 0, r3
	// 82CEE13C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEE140: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEE144: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEE148: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEE14C: C15F002C  lfs f10, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEE150: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CEE154: 38EA6880  addi r7, r10, 0x6880
	ctx.r[7].s64 = ctx.r[10].s64 + 26752;
	// 82CEE158: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEE15C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82CEE160: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CEE164: C8096878  lfd f0, 0x6878(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(26744 as u32) ) };
	// 82CEE168: FC805E9C  fcfid f4, f11
	ctx.f[4].f64 = (ctx.f[11].s64 as f64);
	// 82CEE16C: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEE320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEE320 size=560
    let mut pc: u32 = 0x82CEE320;
    'dispatch: loop {
        match pc {
            0x82CEE320 => {
    //   block [0x82CEE320..0x82CEE550)
	// 82CEE320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEE324: 4BFBB0E5  bl 0x82ca9408
	ctx.lr = 0x82CEE328;
	sub_82CA93D0(ctx, base);
	// 82CEE328: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEE32C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82CEE330: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEE334: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEE338: 7C001A2C  dcbt 0, r3
	// 82CEE33C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEE340: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEE344: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEE348: C15E002C  lfs f10, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEE34C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CEE350: D1BE0024  stfs f13, 0x24(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEE354: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CEE358: C13E0030  lfs f9, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CEE35C: 38EA6880  addi r7, r10, 0x6880
	ctx.r[7].s64 = ctx.r[10].s64 + 26752;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEE550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEE550 size=664
    let mut pc: u32 = 0x82CEE550;
    'dispatch: loop {
        match pc {
            0x82CEE550 => {
    //   block [0x82CEE550..0x82CEE7E8)
	// 82CEE550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEE554: 4BFBAE9D  bl 0x82ca93f0
	ctx.lr = 0x82CEE558;
	sub_82CA93D0(ctx, base);
	// 82CEE558: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEE55C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82CEE560: C01A0024  lfs f0, 0x24(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEE564: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEE568: 7C001A2C  dcbt 0, r3
	// 82CEE56C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEE570: C1BA0028  lfs f13, 0x28(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEE574: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEE578: C17A002C  lfs f11, 0x2c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEE57C: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CEE580: C15A0030  lfs f10, 0x30(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEE584: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CEE588: D1BA0024  stfs f13, 0x24(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEE58C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEE590: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEE594: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEE598: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEE59C: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEE5A0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82CEE5A4: 38E96880  addi r7, r9, 0x6880
	ctx.r[7].s64 = ctx.r[9].s64 + 26752;
	// 82CEE5A8: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEE7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEE7E8 size=784
    let mut pc: u32 = 0x82CEE7E8;
    'dispatch: loop {
        match pc {
            0x82CEE7E8 => {
    //   block [0x82CEE7E8..0x82CEEAF8)
	// 82CEE7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEE7EC: 4BFBABE9  bl 0x82ca93d4
	ctx.lr = 0x82CEE7F0;
	sub_82CA93D0(ctx, base);
	// 82CEE7F0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEE7F4: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 82CEE7F8: C0140024  lfs f0, 0x24(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEE7FC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEE800: 7C001A2C  dcbt 0, r3
	// 82CEE804: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEE808: C1B40028  lfs f13, 0x28(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEE80C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEE810: C174002C  lfs f11, 0x2c(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEE814: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CEE818: C1540030  lfs f10, 0x30(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEE81C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CEE820: D1B40024  stfs f13, 0x24(r20)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEE824: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEEAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEEAF8 size=788
    let mut pc: u32 = 0x82CEEAF8;
    'dispatch: loop {
        match pc {
            0x82CEEAF8 => {
    //   block [0x82CEEAF8..0x82CEEE0C)
	// 82CEEAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEEAFC: 4BFBA90D  bl 0x82ca9408
	ctx.lr = 0x82CEEB00;
	sub_82CA93D0(ctx, base);
	// 82CEEB00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEEB04: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CEEB08: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEEB0C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEEB10: 7C001A2C  dcbt 0, r3
	// 82CEEB14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEEB18: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEEB1C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEEB20: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEEB24: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEEB28: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEEB2C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEEB30: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEEB34: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEEB38: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEEB3C: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEEB40: 396968B0  addi r11, r9, 0x68b0
	ctx.r[11].s64 = ctx.r[9].s64 + 26800;
	// 82CEEB44: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CEEB48: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CEEB4C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CEEB50: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEEB54: 3BC10068  addi r30, r1, 0x68
	ctx.r[30].s64 = ctx.r[1].s64 + 104;
	// 82CEEB58: 1007030C  vspltisb v0, 7
	for i in 0..16 {
		ctx.v[0].u8[i] = 7 as u8;
	}
	// 82CEEB5C: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEEE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEEE10 size=1008
    let mut pc: u32 = 0x82CEEE10;
    'dispatch: loop {
        match pc {
            0x82CEEE10 => {
    //   block [0x82CEEE10..0x82CEF200)
	// 82CEEE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEEE14: 4BFBA5DD  bl 0x82ca93f0
	ctx.lr = 0x82CEEE18;
	sub_82CA93D0(ctx, base);
	// 82CEEE18: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEEE1C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82CEEE20: C01C0024  lfs f0, 0x24(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEEE24: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEEE28: 7C001A2C  dcbt 0, r3
	// 82CEEE2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEEE30: C1BC0028  lfs f13, 0x28(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEEE34: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEEE38: C15C0030  lfs f10, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEEE3C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEEE40: D1BC0024  stfs f13, 0x24(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEEE44: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEEE48: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEEE4C: 394968B0  addi r10, r9, 0x68b0
	ctx.r[10].s64 = ctx.r[9].s64 + 26800;
	// 82CEEE50: C17C002C  lfs f11, 0x2c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEEE54: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEEE58: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEEE5C: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CEEE60: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CEEE64: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CEEE68: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEEE6C: 392868A0  addi r9, r8, 0x68a0
	ctx.r[9].s64 = ctx.r[8].s64 + 26784;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEF200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEF200 size=1520
    let mut pc: u32 = 0x82CEF200;
    'dispatch: loop {
        match pc {
            0x82CEF200 => {
    //   block [0x82CEF200..0x82CEF7F0)
	// 82CEF200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEF204: 4BFBA1CD  bl 0x82ca93d0
	ctx.lr = 0x82CEF208;
	sub_82CA93D0(ctx, base);
	// 82CEF208: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEF20C: C0070024  lfs f0, 0x24(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEF210: 90C1016C  stw r6, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[6].u32 ) };
	// 82CEF214: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CEF218: 90E10174  stw r7, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[7].u32 ) };
	// 82CEF21C: 7C001A2C  dcbt 0, r3
	// 82CEF220: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEF224: C1A70028  lfs f13, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEF228: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEF22C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEF230: C1470030  lfs f10, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEF234: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEF238: D1A70024  stfs f13, 0x24(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEF23C: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82CEF240: C167002C  lfs f11, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEF244: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEF248: 388968B0  addi r4, r9, 0x68b0
	ctx.r[4].s64 = ctx.r[9].s64 + 26800;
	// 82CEF24C: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CEF250: 39266880  addi r9, r6, 0x6880
	ctx.r[9].s64 = ctx.r[6].s64 + 26752;
	// 82CEF254: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEF258: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CEF25C: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEF260: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 82CEF264: 39476890  addi r10, r7, 0x6890
	ctx.r[10].s64 = ctx.r[7].s64 + 26768;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CEF7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CEF7F0 size=2124
    let mut pc: u32 = 0x82CEF7F0;
    'dispatch: loop {
        match pc {
            0x82CEF7F0 => {
    //   block [0x82CEF7F0..0x82CF003C)
	// 82CEF7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CEF7F4: 4BFB9BDD  bl 0x82ca93d0
	ctx.lr = 0x82CEF7F8;
	sub_82CA93D0(ctx, base);
	// 82CEF7F8: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CEF7FC: C0070024  lfs f0, 0x24(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CEF800: 90C101CC  stw r6, 0x1cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[6].u32 ) };
	// 82CEF804: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82CEF808: 90E101D4  stw r7, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[7].u32 ) };
	// 82CEF80C: 7C001A2C  dcbt 0, r3
	// 82CEF810: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CEF814: C1A70028  lfs f13, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CEF818: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CEF81C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CEF820: C1470030  lfs f10, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CEF824: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CEF828: C167002C  lfs f11, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CEF82C: 38C968B0  addi r6, r9, 0x68b0
	ctx.r[6].s64 = ctx.r[9].s64 + 26800;
	// 82CEF830: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82CEF834: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CEF838: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CEF83C: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CEF840: 3AC00004  li r22, 4
	ctx.r[22].s64 = 4;
	// 82CEF844: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CEF848: 388868A0  addi r4, r8, 0x68a0
	ctx.r[4].s64 = ctx.r[8].s64 + 26784;
	// 82CEF84C: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82CEF850: D1A70024  stfs f13, 0x24(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CEF854: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF0040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CF0040 size=644
    let mut pc: u32 = 0x82CF0040;
    'dispatch: loop {
        match pc {
            0x82CF0040 => {
    //   block [0x82CF0040..0x82CF02C4)
	// 82CF0040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF0044: 4BFB93C5  bl 0x82ca9408
	ctx.lr = 0x82CF0048;
	sub_82CA93D0(ctx, base);
	// 82CF0048: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CF004C: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82CF0050: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF0054: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CF0058: 7C001A2C  dcbt 0, r3
	// 82CF005C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF0060: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF0064: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF0068: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF006C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CF0070: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF0074: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CF0078: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF007C: 38886880  addi r4, r8, 0x6880
	ctx.r[4].s64 = ctx.r[8].s64 + 26752;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF02C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CF02C8 size=744
    let mut pc: u32 = 0x82CF02C8;
    'dispatch: loop {
        match pc {
            0x82CF02C8 => {
    //   block [0x82CF02C8..0x82CF05B0)
	// 82CF02C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF02CC: 4BFB9135  bl 0x82ca9400
	ctx.lr = 0x82CF02D0;
	sub_82CA93D0(ctx, base);
	// 82CF02D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CF02D4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82CF02D8: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF02DC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CF02E0: 7C001A2C  dcbt 0, r3
	// 82CF02E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF02E8: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF02EC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CF02F0: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF02F4: C17E002C  lfs f11, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF02F8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CF02FC: 38E96890  addi r7, r9, 0x6890
	ctx.r[7].s64 = ctx.r[9].s64 + 26768;
	// 82CF0300: D1BE0024  stfs f13, 0x24(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF0304: 38886880  addi r4, r8, 0x6880
	ctx.r[4].s64 = ctx.r[8].s64 + 26752;
	// 82CF0308: C15E0030  lfs f10, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF030C: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CF0310: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CF0314: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CF0318: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82CF031C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF0320: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF05B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CF05B0 size=956
    let mut pc: u32 = 0x82CF05B0;
    'dispatch: loop {
        match pc {
            0x82CF05B0 => {
    //   block [0x82CF05B0..0x82CF096C)
	// 82CF05B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF05B4: 4BFB8E2D  bl 0x82ca93e0
	ctx.lr = 0x82CF05B8;
	sub_82CA93D0(ctx, base);
	// 82CF05B8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CF05BC: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82CF05C0: C0180024  lfs f0, 0x24(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF05C4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CF05C8: 7C001A2C  dcbt 0, r3
	// 82CF05CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF05D0: C1B80028  lfs f13, 0x28(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF05D4: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF05D8: C178002C  lfs f11, 0x2c(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF05DC: 7CC407B4  extsw r4, r6
	ctx.r[4].s64 = ctx.r[6].s32 as i64;
	// 82CF05E0: F8810068  std r4, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u64 ) };
	// 82CF05E4: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CF05E8: C1580030  lfs f10, 0x30(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF05EC: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82CF05F0: D1B80024  stfs f13, 0x24(r24)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF05F4: C80B6878  lfd f0, 0x6878(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) };
	// 82CF05F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF05FC: FD2B0032  fmul f9, f11, f0
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 82CF0600: 3FA08204  lis r29, -0x7dfc
	ctx.r[29].s64 = -2113667072;
	// 82CF0604: FD0A0032  fmul f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 * ctx.f[0].f64;
	// 82CF0608: 388B6890  addi r4, r11, 0x6890
	ctx.r[4].s64 = ctx.r[11].s64 + 26768;
	// 82CF060C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF0970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CF0970 size=1212
    let mut pc: u32 = 0x82CF0970;
    'dispatch: loop {
        match pc {
            0x82CF0970 => {
    //   block [0x82CF0970..0x82CF0E2C)
	// 82CF0970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF0974: 4BFB8A5D  bl 0x82ca93d0
	ctx.lr = 0x82CF0978;
	sub_82CA93D0(ctx, base);
	// 82CF0978: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CF097C: C0070024  lfs f0, 0x24(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF0980: 90C1013C  stw r6, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[6].u32 ) };
	// 82CF0984: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CF0988: 90E10144  stw r7, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[7].u32 ) };
	// 82CF098C: 7C001A2C  dcbt 0, r3
	// 82CF0990: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF0994: C1A70028  lfs f13, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF0998: 3AC00004  li r22, 4
	ctx.r[22].s64 = 4;
	// 82CF099C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF09A0: C167002C  lfs f11, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF09A4: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82CF09A8: C1470030  lfs f10, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF09AC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF0E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF0E30 size=876
    let mut pc: u32 = 0x82CF0E30;
    'dispatch: loop {
        match pc {
            0x82CF0E30 => {
    //   block [0x82CF0E30..0x82CF119C)
	// 82CF0E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF0E34: 4BFB85A9  bl 0x82ca93dc
	ctx.lr = 0x82CF0E38;
	sub_82CA93D0(ctx, base);
	// 82CF0E38: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF0E3C: 3B03000D  addi r24, r3, 0xd
	ctx.r[24].s64 = ctx.r[3].s64 + 13;
	// 82CF0E40: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF0E44: 3A830008  addi r20, r3, 8
	ctx.r[20].s64 = ctx.r[3].s64 + 8;
	// 82CF0E48: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF0E4C: 3A23001C  addi r17, r3, 0x1c
	ctx.r[17].s64 = ctx.r[3].s64 + 28;
	// 82CF0E50: 80C30018  lwz r6, 0x18(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF0E54: 7D2551D6  mullw r9, r5, r10
	ctx.r[9].s64 = (ctx.r[5].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF0E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF0E5C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF0E60: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF0E64: 7FE43050  subf r31, r4, r6
	ctx.r[31].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF0E68: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF0E6C: 5487103A  slwi r7, r4, 2
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF0E70: 93E1FF70  stw r31, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[31].u32 ) };
	// 82CF0E74: 3A430018  addi r18, r3, 0x18
	ctx.r[18].s64 = ctx.r[3].s64 + 24;
	// 82CF0E78: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82CF0E7C: 3A630014  addi r19, r3, 0x14
	ctx.r[19].s64 = ctx.r[3].s64 + 20;
	// 82CF0E80: 3B630034  addi r27, r3, 0x34
	ctx.r[27].s64 = ctx.r[3].s64 + 52;
	// 82CF0E84: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF0E88: 7F25F050  subf r25, r5, r30
	ctx.r[25].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF0E8C: 7C874214  add r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF0E90: 7C00322C  dcbt 0, r6
	// 82CF0E94: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CF0E98: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF0E9C: 39200028  li r9, 0x28
	ctx.r[9].s64 = 40;
	// 82CF0EA0: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF0EA4: 790507E6  rldicr r5, r8, 0x20, 0x3f
	ctx.r[5].u64 = (ctx.r[8].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF0EA8: 38E1FF70  addi r7, r1, -0x90
	ctx.r[7].s64 = ctx.r[1].s64 + -144;
	// 82CF0EAC: F8A1FF78  std r5, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[5].u64 ) };
	// 82CF0EB0: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF0EB4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF0EB8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82CF0EBC: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF0EC0: 13834C07  vcmpneb. (lvlx128) v28, v3, v9
	tmp.u32 = ctx.r[3].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF0EC4: 3921FF70  addi r9, r1, -0x90
	ctx.r[9].s64 = ctx.r[1].s64 + -144;
	// 82CF0EC8: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF11A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF11A0 size=736
    let mut pc: u32 = 0x82CF11A0;
    'dispatch: loop {
        match pc {
            0x82CF11A0 => {
    //   block [0x82CF11A0..0x82CF1480)
	// 82CF11A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF11A4: 4BFB823D  bl 0x82ca93e0
	ctx.lr = 0x82CF11A8;
	sub_82CA93D0(ctx, base);
	// 82CF11A8: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF11AC: 3AE30008  addi r23, r3, 8
	ctx.r[23].s64 = ctx.r[3].s64 + 8;
	// 82CF11B0: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF11B4: 3BA3000D  addi r29, r3, 0xd
	ctx.r[29].s64 = ctx.r[3].s64 + 13;
	// 82CF11B8: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF11BC: 3A83001C  addi r20, r3, 0x1c
	ctx.r[20].s64 = ctx.r[3].s64 + 28;
	// 82CF11C0: 7CC429D6  mullw r6, r4, r5
	ctx.r[6].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF11C4: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF11C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF11CC: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF11D0: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF11D4: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF11D8: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF11DC: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82CF11E0: 3AA30018  addi r21, r3, 0x18
	ctx.r[21].s64 = ctx.r[3].s64 + 24;
	// 82CF11E4: 3B830004  addi r28, r3, 4
	ctx.r[28].s64 = ctx.r[3].s64 + 4;
	// 82CF11E8: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF11EC: 3AC30014  addi r22, r3, 0x14
	ctx.r[22].s64 = ctx.r[3].s64 + 20;
	// 82CF11F0: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 82CF11F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF11F8: 7F252050  subf r25, r5, r4
	ctx.r[25].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82CF11FC: 7D064214  add r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82CF1200: 7C004A2C  dcbt 0, r9
	// 82CF1204: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF1208: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF120C: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF1210: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF1214: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF1218: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF121C: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF1220: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF1224: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF1228: 3BC1FF70  addi r30, r1, -0x90
	ctx.r[30].s64 = ctx.r[1].s64 + -144;
	// 82CF122C: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF1230: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF1234: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF1238: C80B0CB8  lfd f0, 0xcb8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF1480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF1480 size=808
    let mut pc: u32 = 0x82CF1480;
    'dispatch: loop {
        match pc {
            0x82CF1480 => {
    //   block [0x82CF1480..0x82CF17A8)
	// 82CF1480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF1484: 4BFB7F5D  bl 0x82ca93e0
	ctx.lr = 0x82CF1488;
	sub_82CA93D0(ctx, base);
	// 82CF1488: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF148C: 3AA30008  addi r21, r3, 8
	ctx.r[21].s64 = ctx.r[3].s64 + 8;
	// 82CF1490: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF1494: 3B63000D  addi r27, r3, 0xd
	ctx.r[27].s64 = ctx.r[3].s64 + 13;
	// 82CF1498: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF149C: 3A43001C  addi r18, r3, 0x1c
	ctx.r[18].s64 = ctx.r[3].s64 + 28;
	// 82CF14A0: 80C30018  lwz r6, 0x18(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF14A4: 7C8429D6  mullw r4, r4, r5
	ctx.r[4].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF14A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF14AC: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF14B0: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF14B4: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF14B8: 7CC83050  subf r6, r8, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	// 82CF14BC: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF14C0: 3A630018  addi r19, r3, 0x18
	ctx.r[19].s64 = ctx.r[3].s64 + 24;
	// 82CF14C4: 90C1FF70  stw r6, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[6].u32 ) };
	// 82CF14C8: 3B430004  addi r26, r3, 4
	ctx.r[26].s64 = ctx.r[3].s64 + 4;
	// 82CF14CC: 3A830014  addi r20, r3, 0x14
	ctx.r[20].s64 = ctx.r[3].s64 + 20;
	// 82CF14D0: 3BA30034  addi r29, r3, 0x34
	ctx.r[29].s64 = ctx.r[3].s64 + 52;
	// 82CF14D4: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF14D8: 7EC5F850  subf r22, r5, r31
	ctx.r[22].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF14DC: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF14E0: 7C00422C  dcbt 0, r8
	// 82CF14E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF14E8: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF14EC: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 82CF14F0: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF14F4: 796707E6  rldicr r7, r11, 0x20, 0x3f
	ctx.r[7].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF14F8: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF14FC: F8E1FF78  std r7, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[7].u64 ) };
	// 82CF1500: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF1504: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF1508: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CF150C: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF1510: 13832C07  vcmpneb. (lvlx128) v28, v3, v5
	tmp.u32 = ctx.r[3].u32 + ctx.r[5].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF1514: 38A1FF70  addi r5, r1, -0x90
	ctx.r[5].s64 = ctx.r[1].s64 + -144;
	// 82CF1518: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF17A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF17A8 size=1012
    let mut pc: u32 = 0x82CF17A8;
    'dispatch: loop {
        match pc {
            0x82CF17A8 => {
    //   block [0x82CF17A8..0x82CF1B9C)
	// 82CF17A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF17AC: 4BFB7C2D  bl 0x82ca93d8
	ctx.lr = 0x82CF17B0;
	sub_82CA93D0(ctx, base);
	// 82CF17B0: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 82CF17B4: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF17B8: 3923001C  addi r9, r3, 0x1c
	ctx.r[9].s64 = ctx.r[3].s64 + 28;
	// 82CF17BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17C0: 9141FF64  stw r10, -0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-156 as u32), ctx.r[10].u32 ) };
	// 82CF17C4: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 82CF17C8: 9121FF50  stw r9, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[9].u32 ) };
	// 82CF17CC: 3AE3000D  addi r23, r3, 0xd
	ctx.r[23].s64 = ctx.r[3].s64 + 13;
	// 82CF17D0: 9101FF68  stw r8, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u32 ) };
	// 82CF17D4: 3AC30004  addi r22, r3, 4
	ctx.r[22].s64 = ctx.r[3].s64 + 4;
	// 82CF17D8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17DC: 39430014  addi r10, r3, 0x14
	ctx.r[10].s64 = ctx.r[3].s64 + 20;
	// 82CF17E0: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17E4: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 82CF17E8: 7CA639D6  mullw r5, r6, r7
	ctx.r[5].s64 = (ctx.r[6].s32 as i64) * (ctx.r[7].s32 as i64);
	// 82CF17EC: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17F0: 9141FF60  stw r10, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[10].u32 ) };
	// 82CF17F4: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF17F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF17FC: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF1800: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF1804: 7CA43050  subf r5, r4, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF1808: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF180C: 90A1FF58  stw r5, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[5].u32 ) };
	// 82CF1810: 7E67F050  subf r19, r7, r30
	ctx.r[19].s64 = ctx.r[30].s64 - ctx.r[7].s64;
	// 82CF1814: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF1818: 7C005A2C  dcbt 0, r11
	// 82CF181C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CF1820: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF1824: 38E00028  li r7, 0x28
	ctx.r[7].s64 = 40;
	// 82CF1828: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF182C: 788807E6  rldicr r8, r4, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[4].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF1830: 3921FF58  addi r9, r1, -0xa8
	ctx.r[9].s64 = ctx.r[1].s64 + -168;
	// 82CF1834: F901FF70  std r8, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[8].u64 ) };
	// 82CF1838: C981FF70  lfd f12, -0x90(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82CF183C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF1840: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF1844: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF1848: 13833C07  vcmpneb. (lvlx128) v28, v3, v7
	tmp.u32 = ctx.r[3].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF184C: 38E1FF58  addi r7, r1, -0xa8
	ctx.r[7].s64 = ctx.r[1].s64 + -168;
	// 82CF1850: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF1BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF1BA0 size=1280
    let mut pc: u32 = 0x82CF1BA0;
    'dispatch: loop {
        match pc {
            0x82CF1BA0 => {
    //   block [0x82CF1BA0..0x82CF20A0)
	// 82CF1BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF1BA4: 4BFB783D  bl 0x82ca93e0
	ctx.lr = 0x82CF1BA8;
	sub_82CA93D0(ctx, base);
	// 82CF1BA8: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 82CF1BAC: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF1BB0: 3903001C  addi r8, r3, 0x1c
	ctx.r[8].s64 = ctx.r[3].s64 + 28;
	// 82CF1BB4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BB8: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82CF1BBC: 9121FF6C  stw r9, -0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-148 as u32), ctx.r[9].u32 ) };
	// 82CF1BC0: 38C30018  addi r6, r3, 0x18
	ctx.r[6].s64 = ctx.r[3].s64 + 24;
	// 82CF1BC4: 9101FF5C  stw r8, -0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-164 as u32), ctx.r[8].u32 ) };
	// 82CF1BC8: 90E1FF60  stw r7, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[7].u32 ) };
	// 82CF1BCC: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BD0: 39230014  addi r9, r3, 0x14
	ctx.r[9].s64 = ctx.r[3].s64 + 20;
	// 82CF1BD4: 90C1FF70  stw r6, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[6].u32 ) };
	// 82CF1BD8: 7CAB21D6  mullw r5, r11, r4
	ctx.r[5].s64 = (ctx.r[11].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CF1BDC: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BE0: 80C60000  lwz r6, 0(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BE4: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BE8: 9121FF68  stw r9, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[9].u32 ) };
	// 82CF1BEC: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF1BF0: 3963000D  addi r11, r3, 0xd
	ctx.r[11].s64 = ctx.r[3].s64 + 13;
	// 82CF1BF4: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF1BF8: 7CE4F050  subf r7, r4, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[4].s64;
	// 82CF1BFC: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF1C00: 7CBF3050  subf r5, r31, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[31].s64;
	// 82CF1C04: 90E1FF58  stw r7, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[7].u32 ) };
	// 82CF1C08: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF1C0C: 90A1FF50  stw r5, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[5].u32 ) };
	// 82CF1C10: 38830034  addi r4, r3, 0x34
	ctx.r[4].s64 = ctx.r[3].s64 + 52;
	// 82CF1C14: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF1C18: 7C005A2C  dcbt 0, r11
	// 82CF1C1C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF1C20: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF1C24: 39230030  addi r9, r3, 0x30
	ctx.r[9].s64 = ctx.r[3].s64 + 48;
	// 82CF1C28: 78C807E6  rldicr r8, r6, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF1C2C: 38C00028  li r6, 0x28
	ctx.r[6].s64 = 40;
	// 82CF1C30: 9121FF64  stw r9, -0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-156 as u32), ctx.r[9].u32 ) };
	// 82CF1C34: F901FF78  std r8, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[8].u64 ) };
	// 82CF1C38: C9A1FF78  lfd f13, -0x88(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF1C3C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CF1C40: 38E1FF50  addi r7, r1, -0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + -176;
	// 82CF1C44: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF1C48: FD400332  fmul f10, f0, f12
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[12].f64;
	// 82CF1C4C: FD2B0332  fmul f9, f11, f12
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 82CF1C50: 13A33407  vcmpneb. (lvlx128) v29, v3, v6
	tmp.u32 = ctx.r[3].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF1C54: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF1C58: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF1C5C: 3BE1FF78  addi r31, r1, -0x88
	ctx.r[31].s64 = ctx.r[1].s64 + -136;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF20A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF20A0 size=936
    let mut pc: u32 = 0x82CF20A0;
    'dispatch: loop {
        match pc {
            0x82CF20A0 => {
    //   block [0x82CF20A0..0x82CF2448)
	// 82CF20A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF20A4: 4BFB7339  bl 0x82ca93dc
	ctx.lr = 0x82CF20A8;
	sub_82CA93D0(ctx, base);
	// 82CF20A8: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF20AC: 3B03000D  addi r24, r3, 0xd
	ctx.r[24].s64 = ctx.r[3].s64 + 13;
	// 82CF20B0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF20B4: 3A830008  addi r20, r3, 8
	ctx.r[20].s64 = ctx.r[3].s64 + 8;
	// 82CF20B8: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF20BC: 3A23001C  addi r17, r3, 0x1c
	ctx.r[17].s64 = ctx.r[3].s64 + 28;
	// 82CF20C0: 80C30018  lwz r6, 0x18(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF20C4: 7D2A29D6  mullw r9, r10, r5
	ctx.r[9].s64 = (ctx.r[10].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF20C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF20CC: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF20D0: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF20D4: 7FE43050  subf r31, r4, r6
	ctx.r[31].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF20D8: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF20DC: 5487103A  slwi r7, r4, 2
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF20E0: 93E1FF70  stw r31, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[31].u32 ) };
	// 82CF20E4: 3A430018  addi r18, r3, 0x18
	ctx.r[18].s64 = ctx.r[3].s64 + 24;
	// 82CF20E8: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82CF20EC: 3A630014  addi r19, r3, 0x14
	ctx.r[19].s64 = ctx.r[3].s64 + 20;
	// 82CF20F0: 3B430034  addi r26, r3, 0x34
	ctx.r[26].s64 = ctx.r[3].s64 + 52;
	// 82CF20F4: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF20F8: 7F25F050  subf r25, r5, r30
	ctx.r[25].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF20FC: 7C874214  add r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF2100: 7C00322C  dcbt 0, r6
	// 82CF2104: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CF2108: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF210C: 39200028  li r9, 0x28
	ctx.r[9].s64 = 40;
	// 82CF2110: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF2114: 790507E6  rldicr r5, r8, 0x20, 0x3f
	ctx.r[5].u64 = (ctx.r[8].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF2118: 38E1FF70  addi r7, r1, -0x90
	ctx.r[7].s64 = ctx.r[1].s64 + -144;
	// 82CF211C: F8A1FF78  std r5, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[5].u64 ) };
	// 82CF2120: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF2124: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF2128: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82CF212C: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF2130: 13834C07  vcmpneb. (lvlx128) v28, v3, v9
	tmp.u32 = ctx.r[3].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF2134: 3921FF70  addi r9, r1, -0x90
	ctx.r[9].s64 = ctx.r[1].s64 + -144;
	// 82CF2138: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF2448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF2448 size=792
    let mut pc: u32 = 0x82CF2448;
    'dispatch: loop {
        match pc {
            0x82CF2448 => {
    //   block [0x82CF2448..0x82CF2760)
	// 82CF2448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF244C: 4BFB6F95  bl 0x82ca93e0
	ctx.lr = 0x82CF2450;
	sub_82CA93D0(ctx, base);
	// 82CF2450: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF2454: 3AE30008  addi r23, r3, 8
	ctx.r[23].s64 = ctx.r[3].s64 + 8;
	// 82CF2458: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF245C: 3BA3000D  addi r29, r3, 0xd
	ctx.r[29].s64 = ctx.r[3].s64 + 13;
	// 82CF2460: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF2464: 3A83001C  addi r20, r3, 0x1c
	ctx.r[20].s64 = ctx.r[3].s64 + 28;
	// 82CF2468: 7CC429D6  mullw r6, r4, r5
	ctx.r[6].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF246C: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF2470: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2474: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF2478: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF247C: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF2480: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF2484: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82CF2488: 3AA30018  addi r21, r3, 0x18
	ctx.r[21].s64 = ctx.r[3].s64 + 24;
	// 82CF248C: 3B830004  addi r28, r3, 4
	ctx.r[28].s64 = ctx.r[3].s64 + 4;
	// 82CF2490: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF2494: 3AC30014  addi r22, r3, 0x14
	ctx.r[22].s64 = ctx.r[3].s64 + 20;
	// 82CF2498: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 82CF249C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF24A0: 7F252050  subf r25, r5, r4
	ctx.r[25].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82CF24A4: 7D064214  add r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82CF24A8: 7C004A2C  dcbt 0, r9
	// 82CF24AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF24B0: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF24B4: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF24B8: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF24BC: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF24C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF24C4: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF24C8: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF24CC: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF24D0: 3BC1FF70  addi r30, r1, -0x90
	ctx.r[30].s64 = ctx.r[1].s64 + -144;
	// 82CF24D4: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF24D8: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF24DC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF24E0: C80B0CB8  lfd f0, 0xcb8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF2760 size=916
    let mut pc: u32 = 0x82CF2760;
    'dispatch: loop {
        match pc {
            0x82CF2760 => {
    //   block [0x82CF2760..0x82CF2AF4)
	// 82CF2760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF2764: 4BFB6C7D  bl 0x82ca93e0
	ctx.lr = 0x82CF2768;
	sub_82CA93D0(ctx, base);
	// 82CF2768: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF276C: 3AA30008  addi r21, r3, 8
	ctx.r[21].s64 = ctx.r[3].s64 + 8;
	// 82CF2770: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF2774: 3B63000D  addi r27, r3, 0xd
	ctx.r[27].s64 = ctx.r[3].s64 + 13;
	// 82CF2778: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF277C: 3A43001C  addi r18, r3, 0x1c
	ctx.r[18].s64 = ctx.r[3].s64 + 28;
	// 82CF2780: 7CC429D6  mullw r6, r4, r5
	ctx.r[6].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF2784: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF2788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF278C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF2790: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF2794: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF2798: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF279C: 7CE83850  subf r7, r8, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 82CF27A0: 3A630018  addi r19, r3, 0x18
	ctx.r[19].s64 = ctx.r[3].s64 + 24;
	// 82CF27A4: 3B430004  addi r26, r3, 4
	ctx.r[26].s64 = ctx.r[3].s64 + 4;
	// 82CF27A8: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF27AC: 3A830014  addi r20, r3, 0x14
	ctx.r[20].s64 = ctx.r[3].s64 + 20;
	// 82CF27B0: 3BA30034  addi r29, r3, 0x34
	ctx.r[29].s64 = ctx.r[3].s64 + 52;
	// 82CF27B4: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF27B8: 7EC52050  subf r22, r5, r4
	ctx.r[22].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82CF27BC: 7D264A14  add r9, r6, r9
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 82CF27C0: 7C00422C  dcbt 0, r8
	// 82CF27C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF27C8: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF27CC: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF27D0: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF27D4: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF27D8: 3B81FF70  addi r28, r1, -0x90
	ctx.r[28].s64 = ctx.r[1].s64 + -144;
	// 82CF27DC: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF27E0: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF27E4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF27E8: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 82CF27EC: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF27F0: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF27F4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF2AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF2AF8 size=1220
    let mut pc: u32 = 0x82CF2AF8;
    'dispatch: loop {
        match pc {
            0x82CF2AF8 => {
    //   block [0x82CF2AF8..0x82CF2FBC)
	// 82CF2AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF2AFC: 4BFB68E1  bl 0x82ca93dc
	ctx.lr = 0x82CF2B00;
	sub_82CA93D0(ctx, base);
	// 82CF2B00: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 82CF2B04: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF2B08: 3923001C  addi r9, r3, 0x1c
	ctx.r[9].s64 = ctx.r[3].s64 + 28;
	// 82CF2B0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B10: 9141FF64  stw r10, -0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-156 as u32), ctx.r[10].u32 ) };
	// 82CF2B14: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 82CF2B18: 9121FF50  stw r9, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[9].u32 ) };
	// 82CF2B1C: 3B03000D  addi r24, r3, 0xd
	ctx.r[24].s64 = ctx.r[3].s64 + 13;
	// 82CF2B20: 9101FF68  stw r8, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u32 ) };
	// 82CF2B24: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82CF2B28: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B2C: 39430014  addi r10, r3, 0x14
	ctx.r[10].s64 = ctx.r[3].s64 + 20;
	// 82CF2B30: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B34: 7CA639D6  mullw r5, r6, r7
	ctx.r[5].s64 = (ctx.r[6].s32 as i64) * (ctx.r[7].s32 as i64);
	// 82CF2B38: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B3C: 9141FF60  stw r10, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[10].u32 ) };
	// 82CF2B40: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF2B44: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2B48: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF2B4C: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF2B50: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF2B54: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF2B58: 90C1FF58  stw r6, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[6].u32 ) };
	// 82CF2B5C: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF2B60: 7E87F850  subf r20, r7, r31
	ctx.r[20].s64 = ctx.r[31].s64 - ctx.r[7].s64;
	// 82CF2B64: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF2B68: 7C005A2C  dcbt 0, r11
	// 82CF2B6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82CF2B70: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF2B74: 3921FF58  addi r9, r1, -0xa8
	ctx.r[9].s64 = ctx.r[1].s64 + -168;
	// 82CF2B78: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF2B7C: 788807E6  rldicr r8, r4, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[4].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF2B80: 3B61FF58  addi r27, r1, -0xa8
	ctx.r[27].s64 = ctx.r[1].s64 + -168;
	// 82CF2B84: F901FF70  std r8, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[8].u64 ) };
	// 82CF2B88: C981FF70  lfd f12, -0x90(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82CF2B8C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF2B90: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CF2B94: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF2B98: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF2FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF2FC0 size=1572
    let mut pc: u32 = 0x82CF2FC0;
    'dispatch: loop {
        match pc {
            0x82CF2FC0 => {
    //   block [0x82CF2FC0..0x82CF35E4)
	// 82CF2FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF2FC4: 4BFB6415  bl 0x82ca93d8
	ctx.lr = 0x82CF2FC8;
	sub_82CA93D0(ctx, base);
	// 82CF2FC8: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 82CF2FCC: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF2FD0: 3903001C  addi r8, r3, 0x1c
	ctx.r[8].s64 = ctx.r[3].s64 + 28;
	// 82CF2FD4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2FD8: 38A30018  addi r5, r3, 0x18
	ctx.r[5].s64 = ctx.r[3].s64 + 24;
	// 82CF2FDC: 9121FF5C  stw r9, -0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-164 as u32), ctx.r[9].u32 ) };
	// 82CF2FE0: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82CF2FE4: 9101FF4C  stw r8, -0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-180 as u32), ctx.r[8].u32 ) };
	// 82CF2FE8: 90A1FF60  stw r5, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[5].u32 ) };
	// 82CF2FEC: 3963000D  addi r11, r3, 0xd
	ctx.r[11].s64 = ctx.r[3].s64 + 13;
	// 82CF2FF0: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2FF4: 39230014  addi r9, r3, 0x14
	ctx.r[9].s64 = ctx.r[3].s64 + 20;
	// 82CF2FF8: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF2FFC: 7C8431D6  mullw r4, r4, r6
	ctx.r[4].s64 = (ctx.r[4].s32 as i64) * (ctx.r[6].s32 as i64);
	// 82CF3000: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF3004: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF3008: 9121FF58  stw r9, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[9].u32 ) };
	// 82CF300C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF3010: 90E1FF50  stw r7, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[7].u32 ) };
	// 82CF3014: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF3018: 7C86F050  subf r4, r6, r30
	ctx.r[4].s64 = ctx.r[30].s64 - ctx.r[6].s64;
	// 82CF301C: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF3020: 7CBF2850  subf r5, r31, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[31].s64;
	// 82CF3024: 9081FF48  stw r4, -0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-184 as u32), ctx.r[4].u32 ) };
	// 82CF3028: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF302C: 90A1FF40  stw r5, -0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-192 as u32), ctx.r[5].u32 ) };
	// 82CF3030: 38C30034  addi r6, r3, 0x34
	ctx.r[6].s64 = ctx.r[3].s64 + 52;
	// 82CF3034: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF3038: 7C005A2C  dcbt 0, r11
	// 82CF303C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CF3040: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF3044: 39030030  addi r8, r3, 0x30
	ctx.r[8].s64 = ctx.r[3].s64 + 48;
	// 82CF3048: 792707E6  rldicr r7, r9, 0x20, 0x3f
	ctx.r[7].u64 = (ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF304C: 39200028  li r9, 0x28
	ctx.r[9].s64 = 40;
	// 82CF3050: 9101FF54  stw r8, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[8].u32 ) };
	// 82CF3054: F8E1FF68  std r7, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[7].u64 ) };
	// 82CF3058: C9A1FF68  lfd f13, -0x98(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82CF305C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CF3060: 3881FF40  addi r4, r1, -0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + -192;
	// 82CF3064: C1680000  lfs f11, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF3068: 39030024  addi r8, r3, 0x24
	ctx.r[8].s64 = ctx.r[3].s64 + 36;
	// 82CF306C: FD4B0332  fmul f10, f11, f12
	ctx.f[10].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 82CF3070: 13A34C07  vcmpneb. (lvlx128) v29, v3, v9
	tmp.u32 = ctx.r[3].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3074: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82CF3078: 13E02407  vcmpneb. (lvlx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF307C: 3BE1FF40  addi r31, r1, -0xc0
	ctx.r[31].s64 = ctx.r[1].s64 + -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF35E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF35E8 size=936
    let mut pc: u32 = 0x82CF35E8;
    'dispatch: loop {
        match pc {
            0x82CF35E8 => {
    //   block [0x82CF35E8..0x82CF3990)
	// 82CF35E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF35EC: 4BFB5DF5  bl 0x82ca93e0
	ctx.lr = 0x82CF35F0;
	sub_82CA93D0(ctx, base);
	// 82CF35F0: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF35F4: 3B43000D  addi r26, r3, 0xd
	ctx.r[26].s64 = ctx.r[3].s64 + 13;
	// 82CF35F8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF35FC: 3AA30008  addi r21, r3, 8
	ctx.r[21].s64 = ctx.r[3].s64 + 8;
	// 82CF3600: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF3604: 3A43001C  addi r18, r3, 0x1c
	ctx.r[18].s64 = ctx.r[3].s64 + 28;
	// 82CF3608: 80A30018  lwz r5, 0x18(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF360C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF3610: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF3614: 7D4459D6  mullw r10, r4, r11
	ctx.r[10].s64 = (ctx.r[4].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82CF3618: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF361C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF3620: 7CA62850  subf r5, r6, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[6].s64;
	// 82CF3624: 7F64F850  subf r27, r4, r31
	ctx.r[27].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 82CF3628: 3A630018  addi r19, r3, 0x18
	ctx.r[19].s64 = ctx.r[3].s64 + 24;
	// 82CF362C: 90A1FF70  stw r5, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[5].u32 ) };
	// 82CF3630: 3B230004  addi r25, r3, 4
	ctx.r[25].s64 = ctx.r[3].s64 + 4;
	// 82CF3634: 3A830014  addi r20, r3, 0x14
	ctx.r[20].s64 = ctx.r[3].s64 + 20;
	// 82CF3638: 3AC30034  addi r22, r3, 0x34
	ctx.r[22].s64 = ctx.r[3].s64 + 52;
	// 82CF363C: 7CC95214  add r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CF3640: 7C874214  add r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF3644: 7C00322C  dcbt 0, r6
	// 82CF3648: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82CF364C: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF3650: 38E00028  li r7, 0x28
	ctx.r[7].s64 = 40;
	// 82CF3654: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF3658: 794807E6  rldicr r8, r10, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF365C: 3921FF70  addi r9, r1, -0x90
	ctx.r[9].s64 = ctx.r[1].s64 + -144;
	// 82CF3660: F901FF78  std r8, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[8].u64 ) };
	// 82CF3664: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF3668: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF366C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF3670: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF3674: 3BA1FF70  addi r29, r1, -0x90
	ctx.r[29].s64 = ctx.r[1].s64 + -144;
	// 82CF3678: 13833C07  vcmpneb. (lvlx128) v28, v3, v7
	tmp.u32 = ctx.r[3].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF367C: FD2D02F2  fmul f9, f13, f11
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[11].f64;
	// 82CF3680: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3684: 3AE30024  addi r23, r3, 0x24
	ctx.r[23].s64 = ctx.r[3].s64 + 36;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF3990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF3990 size=824
    let mut pc: u32 = 0x82CF3990;
    'dispatch: loop {
        match pc {
            0x82CF3990 => {
    //   block [0x82CF3990..0x82CF3CC8)
	// 82CF3990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF3994: 4BFB5A51  bl 0x82ca93e4
	ctx.lr = 0x82CF3998;
	sub_82CA93D0(ctx, base);
	// 82CF3998: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF399C: 3AC30008  addi r22, r3, 8
	ctx.r[22].s64 = ctx.r[3].s64 + 8;
	// 82CF39A0: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF39A4: 3B83000D  addi r28, r3, 0xd
	ctx.r[28].s64 = ctx.r[3].s64 + 13;
	// 82CF39A8: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF39AC: 3A63001C  addi r19, r3, 0x1c
	ctx.r[19].s64 = ctx.r[3].s64 + 28;
	// 82CF39B0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF39B4: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF39B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF39BC: 7CE44850  subf r7, r4, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CF39C0: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF39C4: 7D4A29D6  mullw r10, r10, r5
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF39C8: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF39CC: 90E1FF80  stw r7, -0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.r[7].u32 ) };
	// 82CF39D0: 3A830018  addi r20, r3, 0x18
	ctx.r[20].s64 = ctx.r[3].s64 + 24;
	// 82CF39D4: 3B630004  addi r27, r3, 4
	ctx.r[27].s64 = ctx.r[3].s64 + 4;
	// 82CF39D8: 3AA30014  addi r21, r3, 0x14
	ctx.r[21].s64 = ctx.r[3].s64 + 20;
	// 82CF39DC: 3BC30034  addi r30, r3, 0x34
	ctx.r[30].s64 = ctx.r[3].s64 + 52;
	// 82CF39E0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF39E4: 7F05F850  subf r24, r5, r31
	ctx.r[24].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF39E8: 7D064214  add r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82CF39EC: 7C004A2C  dcbt 0, r9
	// 82CF39F0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF39F4: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF39F8: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 82CF39FC: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF3A00: 78C407E6  rldicr r4, r6, 0x20, 0x3f
	ctx.r[4].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF3A04: 38A1FF80  addi r5, r1, -0x80
	ctx.r[5].s64 = ctx.r[1].s64 + -128;
	// 82CF3A08: F881FF88  std r4, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.r[4].u64 ) };
	// 82CF3A0C: C981FF88  lfd f12, -0x78(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82CF3A10: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF3A14: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF3A18: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF3A1C: 3BA1FF80  addi r29, r1, -0x80
	ctx.r[29].s64 = ctx.r[1].s64 + -128;
	// 82CF3A20: 13835C07  vcmpneb. (lvlx128) v28, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3A24: FD2D02F2  fmul f9, f13, f11
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[11].f64;
	// 82CF3A28: 13E02C07  vcmpneb. (lvlx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3A2C: 3B230024  addi r25, r3, 0x24
	ctx.r[25].s64 = ctx.r[3].s64 + 36;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF3CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF3CC8 size=980
    let mut pc: u32 = 0x82CF3CC8;
    'dispatch: loop {
        match pc {
            0x82CF3CC8 => {
    //   block [0x82CF3CC8..0x82CF409C)
	// 82CF3CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF3CCC: 4BFB5715  bl 0x82ca93e0
	ctx.lr = 0x82CF3CD0;
	sub_82CA93D0(ctx, base);
	// 82CF3CD0: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF3CD4: 3AA30008  addi r21, r3, 8
	ctx.r[21].s64 = ctx.r[3].s64 + 8;
	// 82CF3CD8: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF3CDC: 3B63000D  addi r27, r3, 0xd
	ctx.r[27].s64 = ctx.r[3].s64 + 13;
	// 82CF3CE0: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF3CE4: 3A43001C  addi r18, r3, 0x1c
	ctx.r[18].s64 = ctx.r[3].s64 + 28;
	// 82CF3CE8: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF3CEC: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF3CF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF3CF4: 7CE44050  subf r7, r4, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CF3CF8: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF3CFC: 7D4A29D6  mullw r10, r10, r5
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF3D00: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF3D04: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF3D08: 3A630018  addi r19, r3, 0x18
	ctx.r[19].s64 = ctx.r[3].s64 + 24;
	// 82CF3D0C: 3B430004  addi r26, r3, 4
	ctx.r[26].s64 = ctx.r[3].s64 + 4;
	// 82CF3D10: 3A830014  addi r20, r3, 0x14
	ctx.r[20].s64 = ctx.r[3].s64 + 20;
	// 82CF3D14: 3BA30034  addi r29, r3, 0x34
	ctx.r[29].s64 = ctx.r[3].s64 + 52;
	// 82CF3D18: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF3D1C: 7EC5F850  subf r22, r5, r31
	ctx.r[22].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF3D20: 7D264A14  add r9, r6, r9
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 82CF3D24: 7C00422C  dcbt 0, r8
	// 82CF3D28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF3D2C: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF3D30: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 82CF3D34: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF3D38: 78C407E6  rldicr r4, r6, 0x20, 0x3f
	ctx.r[4].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF3D3C: 38A1FF70  addi r5, r1, -0x90
	ctx.r[5].s64 = ctx.r[1].s64 + -144;
	// 82CF3D40: F881FF78  std r4, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[4].u64 ) };
	// 82CF3D44: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF3D48: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF3D4C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF3D50: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF3D54: 3AE1FF70  addi r23, r1, -0x90
	ctx.r[23].s64 = ctx.r[1].s64 + -144;
	// 82CF3D58: 13835C07  vcmpneb. (lvlx128) v28, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3D5C: FD2D02F2  fmul f9, f13, f11
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[11].f64;
	// 82CF3D60: 13E02C07  vcmpneb. (lvlx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF3D64: 3B030024  addi r24, r3, 0x24
	ctx.r[24].s64 = ctx.r[3].s64 + 36;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF40A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF40A0 size=1312
    let mut pc: u32 = 0x82CF40A0;
    'dispatch: loop {
        match pc {
            0x82CF40A0 => {
    //   block [0x82CF40A0..0x82CF45C0)
	// 82CF40A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF40A4: 4BFB5341  bl 0x82ca93e4
	ctx.lr = 0x82CF40A8;
	sub_82CA93D0(ctx, base);
	// 82CF40A8: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 82CF40AC: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF40B0: 3923001C  addi r9, r3, 0x1c
	ctx.r[9].s64 = ctx.r[3].s64 + 28;
	// 82CF40B4: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF40B8: 38E30018  addi r7, r3, 0x18
	ctx.r[7].s64 = ctx.r[3].s64 + 24;
	// 82CF40BC: 9141FF7C  stw r10, -0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-132 as u32), ctx.r[10].u32 ) };
	// 82CF40C0: 39030014  addi r8, r3, 0x14
	ctx.r[8].s64 = ctx.r[3].s64 + 20;
	// 82CF40C4: 9121FF60  stw r9, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[9].u32 ) };
	// 82CF40C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40CC: 3AC3000D  addi r22, r3, 0xd
	ctx.r[22].s64 = ctx.r[3].s64 + 13;
	// 82CF40D0: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40D4: 3AA30004  addi r21, r3, 4
	ctx.r[21].s64 = ctx.r[3].s64 + 4;
	// 82CF40D8: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40DC: 7D4429D6  mullw r10, r4, r5
	ctx.r[10].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF40E0: 80870000  lwz r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40E4: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF40E8: 9101FF74  stw r8, -0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-140 as u32), ctx.r[8].u32 ) };
	// 82CF40EC: 90E1FF78  stw r7, -0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[7].u32 ) };
	// 82CF40F0: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF40F4: 7E65F850  subf r19, r5, r31
	ctx.r[19].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF40F8: 7CC62050  subf r6, r6, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	// 82CF40FC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF4100: 9261FF70  stw r19, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[19].u32 ) };
	// 82CF4104: 90C1FF68  stw r6, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[6].u32 ) };
	// 82CF4108: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF410C: 7D684A14  add r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF4110: 7C00522C  dcbt 0, r10
	// 82CF4114: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82CF4118: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF411C: 39230024  addi r9, r3, 0x24
	ctx.r[9].s64 = ctx.r[3].s64 + 36;
	// 82CF4120: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF4124: 790707E6  rldicr r7, r8, 0x20, 0x3f
	ctx.r[7].u64 = (ctx.r[8].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF4128: 39000028  li r8, 0x28
	ctx.r[8].s64 = 40;
	// 82CF412C: F8E1FF80  std r7, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.r[7].u64 ) };
	// 82CF4130: C981FF80  lfd f12, -0x80(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82CF4134: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF4138: 3881FF68  addi r4, r1, -0x98
	ctx.r[4].s64 = ctx.r[1].s64 + -152;
	// 82CF413C: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF4140: 13834407  vcmpneb. (lvlx128) v28, v3, v8
	tmp.u32 = ctx.r[3].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4144: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CF4148: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF414C: 3B81FF68  addi r28, r1, -0x98
	ctx.r[28].s64 = ctx.r[1].s64 + -152;
	// 82CF4150: 13C02407  vcmpneb. (lvlx128) v30, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF45C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF45C0 size=1680
    let mut pc: u32 = 0x82CF45C0;
    'dispatch: loop {
        match pc {
            0x82CF45C0 => {
    //   block [0x82CF45C0..0x82CF4C50)
	// 82CF45C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF45C4: 4BFB4E25  bl 0x82ca93e8
	ctx.lr = 0x82CF45C8;
	sub_82CA93D0(ctx, base);
	// 82CF45C8: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 82CF45CC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF45D0: 3903001C  addi r8, r3, 0x1c
	ctx.r[8].s64 = ctx.r[3].s64 + 28;
	// 82CF45D4: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82CF45D8: 9121FF80  stw r9, -0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.r[9].u32 ) };
	// 82CF45DC: 38830018  addi r4, r3, 0x18
	ctx.r[4].s64 = ctx.r[3].s64 + 24;
	// 82CF45E0: 9101FF6C  stw r8, -0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-148 as u32), ctx.r[8].u32 ) };
	// 82CF45E4: 38C30014  addi r6, r3, 0x14
	ctx.r[6].s64 = ctx.r[3].s64 + 20;
	// 82CF45E8: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF45EC: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF45F0: 3963000D  addi r11, r3, 0xd
	ctx.r[11].s64 = ctx.r[3].s64 + 13;
	// 82CF45F4: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF45F8: 9081FF7C  stw r4, -0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-132 as u32), ctx.r[4].u32 ) };
	// 82CF45FC: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF4600: 7D6929D6  mullw r11, r9, r5
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF4604: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF4608: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF460C: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF4610: 90C1FF78  stw r6, -0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u32 ) };
	// 82CF4614: 7CE5F050  subf r7, r5, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF4618: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF461C: 7C9F2050  subf r4, r31, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 82CF4620: 90E1FF68  stw r7, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[7].u32 ) };
	// 82CF4624: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF4628: 9081FF60  stw r4, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[4].u32 ) };
	// 82CF462C: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF4630: 7D684A14  add r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF4634: 7C00522C  dcbt 0, r10
	// 82CF4638: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF463C: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF4640: 39230030  addi r9, r3, 0x30
	ctx.r[9].s64 = ctx.r[3].s64 + 48;
	// 82CF4644: 78C807E6  rldicr r8, r6, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF4648: 38C00028  li r6, 0x28
	ctx.r[6].s64 = 40;
	// 82CF464C: 9121FF74  stw r9, -0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-140 as u32), ctx.r[9].u32 ) };
	// 82CF4650: F901FF88  std r8, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.r[8].u64 ) };
	// 82CF4654: C9A1FF88  lfd f13, -0x78(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82CF4658: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CF465C: 38E1FF60  addi r7, r1, -0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + -160;
	// 82CF4660: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF4664: FD400332  fmul f10, f0, f12
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[12].f64;
	// 82CF4668: FD2B0332  fmul f9, f11, f12
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 82CF466C: 13A33407  vcmpneb. (lvlx128) v29, v3, v6
	tmp.u32 = ctx.r[3].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4670: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF4674: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4678: 3BE1FF88  addi r31, r1, -0x78
	ctx.r[31].s64 = ctx.r[1].s64 + -120;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF4C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF4C50 size=964
    let mut pc: u32 = 0x82CF4C50;
    'dispatch: loop {
        match pc {
            0x82CF4C50 => {
    //   block [0x82CF4C50..0x82CF5014)
	// 82CF4C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF4C54: 4BFB4785  bl 0x82ca93d8
	ctx.lr = 0x82CF4C58;
	sub_82CA93D0(ctx, base);
	// 82CF4C58: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF4C5C: 3B03000D  addi r24, r3, 0xd
	ctx.r[24].s64 = ctx.r[3].s64 + 13;
	// 82CF4C60: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF4C64: 3A630008  addi r19, r3, 8
	ctx.r[19].s64 = ctx.r[3].s64 + 8;
	// 82CF4C68: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82CF4C6C: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF4C70: 80C30018  lwz r6, 0x18(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF4C74: 7D6B29D6  mullw r11, r11, r5
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF4C78: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF4C7C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF4C80: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF4C84: 7FE43050  subf r31, r4, r6
	ctx.r[31].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82CF4C88: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF4C8C: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF4C90: 93E1FF60  stw r31, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[31].u32 ) };
	// 82CF4C94: 3A03001C  addi r16, r3, 0x1c
	ctx.r[16].s64 = ctx.r[3].s64 + 28;
	// 82CF4C98: 3A230018  addi r17, r3, 0x18
	ctx.r[17].s64 = ctx.r[3].s64 + 24;
	// 82CF4C9C: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82CF4CA0: 3A430014  addi r18, r3, 0x14
	ctx.r[18].s64 = ctx.r[3].s64 + 20;
	// 82CF4CA4: 3B230034  addi r25, r3, 0x34
	ctx.r[25].s64 = ctx.r[3].s64 + 52;
	// 82CF4CA8: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF4CAC: 7EC5F050  subf r22, r5, r30
	ctx.r[22].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF4CB0: 7C884A14  add r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF4CB4: 7C00322C  dcbt 0, r6
	// 82CF4CB8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82CF4CBC: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF4CC0: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 82CF4CC4: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF4CC8: 794807E6  rldicr r8, r10, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF4CCC: 3921FF60  addi r9, r1, -0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + -160;
	// 82CF4CD0: F901FF68  std r8, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u64 ) };
	// 82CF4CD4: C981FF68  lfd f12, -0x98(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82CF4CD8: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF4CDC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF4CE0: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF4CE4: 3B61FF60  addi r27, r1, -0xa0
	ctx.r[27].s64 = ctx.r[1].s64 + -160;
	// 82CF4CE8: 13832C07  vcmpneb. (lvlx128) v28, v3, v5
	tmp.u32 = ctx.r[3].u32 + ctx.r[5].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4CEC: FD2D02F2  fmul f9, f13, f11
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[11].f64;
	// 82CF4CF0: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF4CF4: 3A830024  addi r20, r3, 0x24
	ctx.r[20].s64 = ctx.r[3].s64 + 36;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF5018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF5018 size=816
    let mut pc: u32 = 0x82CF5018;
    'dispatch: loop {
        match pc {
            0x82CF5018 => {
    //   block [0x82CF5018..0x82CF5348)
	// 82CF5018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF501C: 4BFB43C1  bl 0x82ca93dc
	ctx.lr = 0x82CF5020;
	sub_82CA93D0(ctx, base);
	// 82CF5020: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF5024: 3AC30008  addi r22, r3, 8
	ctx.r[22].s64 = ctx.r[3].s64 + 8;
	// 82CF5028: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF502C: 3B83000D  addi r28, r3, 0xd
	ctx.r[28].s64 = ctx.r[3].s64 + 13;
	// 82CF5030: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF5034: 3A63001C  addi r19, r3, 0x1c
	ctx.r[19].s64 = ctx.r[3].s64 + 28;
	// 82CF5038: 7CC429D6  mullw r6, r4, r5
	ctx.r[6].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF503C: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF5040: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5044: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF5048: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF504C: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF5050: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF5054: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82CF5058: 3A830018  addi r20, r3, 0x18
	ctx.r[20].s64 = ctx.r[3].s64 + 24;
	// 82CF505C: 3B630004  addi r27, r3, 4
	ctx.r[27].s64 = ctx.r[3].s64 + 4;
	// 82CF5060: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF5064: 3AA30014  addi r21, r3, 0x14
	ctx.r[21].s64 = ctx.r[3].s64 + 20;
	// 82CF5068: 3BC30034  addi r30, r3, 0x34
	ctx.r[30].s64 = ctx.r[3].s64 + 52;
	// 82CF506C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF5070: 7F052050  subf r24, r5, r4
	ctx.r[24].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82CF5074: 7D064214  add r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82CF5078: 7C004A2C  dcbt 0, r9
	// 82CF507C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF5080: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF5084: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 82CF5088: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF508C: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF5090: 3AE1FF70  addi r23, r1, -0x90
	ctx.r[23].s64 = ctx.r[1].s64 + -144;
	// 82CF5094: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF5098: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF509C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF50A0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF50A4: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF50A8: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF5348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF5348 size=956
    let mut pc: u32 = 0x82CF5348;
    'dispatch: loop {
        match pc {
            0x82CF5348 => {
    //   block [0x82CF5348..0x82CF5704)
	// 82CF5348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF534C: 4BFB4091  bl 0x82ca93dc
	ctx.lr = 0x82CF5350;
	sub_82CA93D0(ctx, base);
	// 82CF5350: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF5354: 3A830008  addi r20, r3, 8
	ctx.r[20].s64 = ctx.r[3].s64 + 8;
	// 82CF5358: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF535C: 3B43000D  addi r26, r3, 0xd
	ctx.r[26].s64 = ctx.r[3].s64 + 13;
	// 82CF5360: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF5364: 3A23001C  addi r17, r3, 0x1c
	ctx.r[17].s64 = ctx.r[3].s64 + 28;
	// 82CF5368: 7CE429D6  mullw r7, r4, r5
	ctx.r[7].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF536C: 80830018  lwz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF5370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5374: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF5378: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF537C: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF5380: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF5384: 7CE82050  subf r7, r8, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF5388: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF538C: 3A430018  addi r18, r3, 0x18
	ctx.r[18].s64 = ctx.r[3].s64 + 24;
	// 82CF5390: 90E1FF70  stw r7, -0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u32 ) };
	// 82CF5394: 3B230004  addi r25, r3, 4
	ctx.r[25].s64 = ctx.r[3].s64 + 4;
	// 82CF5398: 3A630014  addi r19, r3, 0x14
	ctx.r[19].s64 = ctx.r[3].s64 + 20;
	// 82CF539C: 3B830034  addi r28, r3, 0x34
	ctx.r[28].s64 = ctx.r[3].s64 + 52;
	// 82CF53A0: 7EA5F850  subf r21, r5, r31
	ctx.r[21].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF53A4: 7D464A14  add r10, r6, r9
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 82CF53A8: 7C00422C  dcbt 0, r8
	// 82CF53AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82CF53B0: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF53B4: 3921FF70  addi r9, r1, -0x90
	ctx.r[9].s64 = ctx.r[1].s64 + -144;
	// 82CF53B8: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF53BC: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF53C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF53C4: F8C1FF78  std r6, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.r[6].u64 ) };
	// 82CF53C8: C981FF78  lfd f12, -0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82CF53CC: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF53D0: 3BC1FF70  addi r30, r1, -0x90
	ctx.r[30].s64 = ctx.r[1].s64 + -144;
	// 82CF53D4: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF53D8: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF53DC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82CF53E0: C80B0CB8  lfd f0, 0xcb8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF5708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF5708 size=1304
    let mut pc: u32 = 0x82CF5708;
    'dispatch: loop {
        match pc {
            0x82CF5708 => {
    //   block [0x82CF5708..0x82CF5C20)
	// 82CF5708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF570C: 4BFB3CD1  bl 0x82ca93dc
	ctx.lr = 0x82CF5710;
	sub_82CA93D0(ctx, base);
	// 82CF5710: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 82CF5714: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF5718: 3923001C  addi r9, r3, 0x1c
	ctx.r[9].s64 = ctx.r[3].s64 + 28;
	// 82CF571C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF5720: 9141FF64  stw r10, -0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-156 as u32), ctx.r[10].u32 ) };
	// 82CF5724: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 82CF5728: 9121FF54  stw r9, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[9].u32 ) };
	// 82CF572C: 3AE3000D  addi r23, r3, 0xd
	ctx.r[23].s64 = ctx.r[3].s64 + 13;
	// 82CF5730: 9101FF68  stw r8, -0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u32 ) };
	// 82CF5734: 3AC30004  addi r22, r3, 4
	ctx.r[22].s64 = ctx.r[3].s64 + 4;
	// 82CF5738: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF573C: 39430014  addi r10, r3, 0x14
	ctx.r[10].s64 = ctx.r[3].s64 + 20;
	// 82CF5740: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5744: 7CC639D6  mullw r6, r6, r7
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[7].s32 as i64);
	// 82CF5748: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF574C: 9141FF60  stw r10, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[10].u32 ) };
	// 82CF5750: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5754: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5758: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF575C: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF5760: 7C872050  subf r4, r7, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 82CF5764: 7CA5F850  subf r5, r5, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82CF5768: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF576C: 9081FF50  stw r4, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[4].u32 ) };
	// 82CF5770: 90A1FF58  stw r5, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[5].u32 ) };
	// 82CF5774: 38830034  addi r4, r3, 0x34
	ctx.r[4].s64 = ctx.r[3].s64 + 52;
	// 82CF5778: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF577C: 7C005A2C  dcbt 0, r11
	// 82CF5780: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82CF5784: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF5788: 3901FF58  addi r8, r1, -0xa8
	ctx.r[8].s64 = ctx.r[1].s64 + -168;
	// 82CF578C: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF5790: 792707E6  rldicr r7, r9, 0x20, 0x3f
	ctx.r[7].u64 = (ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF5794: 3BA1FF58  addi r29, r1, -0xa8
	ctx.r[29].s64 = ctx.r[1].s64 + -168;
	// 82CF5798: F8E1FF70  std r7, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u64 ) };
	// 82CF579C: C981FF70  lfd f12, -0x90(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82CF57A0: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82CF57A4: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82CF57A8: FD4002F2  fmul f10, f0, f11
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[11].f64;
	// 82CF57AC: 13E04407  vcmpneb. (lvlx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF57B0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF5C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF5C20 size=1680
    let mut pc: u32 = 0x82CF5C20;
    'dispatch: loop {
        match pc {
            0x82CF5C20 => {
    //   block [0x82CF5C20..0x82CF62B0)
	// 82CF5C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF5C24: 4BFB37B1  bl 0x82ca93d4
	ctx.lr = 0x82CF5C28;
	sub_82CA93D0(ctx, base);
	// 82CF5C28: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 82CF5C2C: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF5C30: 3903001C  addi r8, r3, 0x1c
	ctx.r[8].s64 = ctx.r[3].s64 + 28;
	// 82CF5C34: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C38: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82CF5C3C: 9121FF5C  stw r9, -0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-164 as u32), ctx.r[9].u32 ) };
	// 82CF5C40: 38C30018  addi r6, r3, 0x18
	ctx.r[6].s64 = ctx.r[3].s64 + 24;
	// 82CF5C44: 9101FF4C  stw r8, -0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-180 as u32), ctx.r[8].u32 ) };
	// 82CF5C48: 3963000D  addi r11, r3, 0xd
	ctx.r[11].s64 = ctx.r[3].s64 + 13;
	// 82CF5C4C: 90E1FF50  stw r7, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[7].u32 ) };
	// 82CF5C50: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C54: 39230014  addi r9, r3, 0x14
	ctx.r[9].s64 = ctx.r[3].s64 + 20;
	// 82CF5C58: 90C1FF60  stw r6, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[6].u32 ) };
	// 82CF5C5C: 7C8429D6  mullw r4, r4, r5
	ctx.r[4].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF5C60: 83E80000  lwz r31, 0(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C64: 80C60000  lwz r6, 0(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C68: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C6C: 9121FF58  stw r9, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[9].u32 ) };
	// 82CF5C70: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF5C74: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF5C78: 7CE5F050  subf r7, r5, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82CF5C7C: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF5C80: 7C9F3050  subf r4, r31, r6
	ctx.r[4].s64 = ctx.r[6].s64 - ctx.r[31].s64;
	// 82CF5C84: 90E1FF48  stw r7, -0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-184 as u32), ctx.r[7].u32 ) };
	// 82CF5C88: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82CF5C8C: 9081FF40  stw r4, -0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-192 as u32), ctx.r[4].u32 ) };
	// 82CF5C90: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF5C94: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF5C98: 7C005A2C  dcbt 0, r11
	// 82CF5C9C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82CF5CA0: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF5CA4: 39230030  addi r9, r3, 0x30
	ctx.r[9].s64 = ctx.r[3].s64 + 48;
	// 82CF5CA8: 78C807E6  rldicr r8, r6, 0x20, 0x3f
	ctx.r[8].u64 = (ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82CF5CAC: 38E1FF40  addi r7, r1, -0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + -192;
	// 82CF5CB0: 9121FF54  stw r9, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[9].u32 ) };
	// 82CF5CB4: F901FF68  std r8, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u64 ) };
	// 82CF5CB8: C9A1FF68  lfd f13, -0x98(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82CF5CBC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82CF5CC0: 38C00028  li r6, 0x28
	ctx.r[6].s64 = 40;
	// 82CF5CC4: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF5CC8: FD400332  fmul f10, f0, f12
	ctx.f[10].f64 = ctx.f[0].f64 * ctx.f[12].f64;
	// 82CF5CCC: FD2B0332  fmul f9, f11, f12
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 82CF5CD0: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF5CD4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82CF5CD8: 13A33407  vcmpneb. (lvlx128) v29, v3, v6
	tmp.u32 = ctx.r[3].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82CF5CDC: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF62B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF62B0 size=280
    let mut pc: u32 = 0x82CF62B0;
    'dispatch: loop {
        match pc {
            0x82CF62B0 => {
    //   block [0x82CF62B0..0x82CF63C8)
	// 82CF62B0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF62B4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF62B8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF62BC: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF62C0: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF62C4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF62C8: 7D0559D6  mullw r8, r5, r11
	ctx.r[8].s64 = (ctx.r[5].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82CF62CC: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF62D0: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF62D4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF62D8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF62DC: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF62E0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF62E4: 7D64F850  subf r11, r4, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 82CF62E8: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF62EC: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF62F0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF62F4: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF62F8: 41980008  blt cr6, 0x82cf6300
	if ctx.cr[6].lt {
	pc = 0x82CF6300; continue 'dispatch;
	}
	// 82CF62FC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82CF6300: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF6304: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6308: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF630C: 54A4103A  slwi r4, r5, 2
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF6310: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF6314: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6318: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF631C: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6320: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF6324: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82CF6328: 419A002C  beq cr6, 0x82cf6354
	if ctx.cr[6].eq {
	pc = 0x82CF6354; continue 'dispatch;
	}
	// 82CF632C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82CF6330: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82CF6334: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82CF6338: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF633C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF6340: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6344: D1690000  stfs f11, 0(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6348: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF634C: 39290400  addi r9, r9, 0x400
	ctx.r[9].s64 = ctx.r[9].s64 + 1024;
	// 82CF6350: 4082FFE8  bne 0x82cf6338
	if !ctx.cr[0].eq {
	pc = 0x82CF6338; continue 'dispatch;
	}
	// 82CF6354: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF6358: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF635C: 7D044214  add r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 82CF6360: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF6364: 4082FFC0  bne 0x82cf6324
	if !ctx.cr[0].eq {
	pc = 0x82CF6324; continue 'dispatch;
	}
	// 82CF6368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF636C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6370: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF6374: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6378: 5548103E  rotlwi r8, r10, 2
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF637C: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF6380: 0CC80000  twi 6, r8, 0
	// 82CF6384: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6388: 41980008  blt cr6, 0x82cf6390
	if ctx.cr[6].lt {
	pc = 0x82CF6390; continue 'dispatch;
	}
	// 82CF638C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF6390: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6394: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6398: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF639C: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF63A0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF63A4: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF63A8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF63AC: 40980010  bge cr6, 0x82cf63bc
	if !ctx.cr[6].lt {
	pc = 0x82CF63BC; continue 'dispatch;
	}
	// 82CF63B0: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF63B4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF63B8: 4E800020  blr
	return;
	// 82CF63BC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF63C0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF63C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF63C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF63C8 size=284
    let mut pc: u32 = 0x82CF63C8;
    'dispatch: loop {
        match pc {
            0x82CF63C8 => {
    //   block [0x82CF63C8..0x82CF64E4)
	// 82CF63C8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF63CC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF63D0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF63D4: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF63D8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF63DC: 7C8A59D6  mullw r4, r10, r11
	ctx.r[4].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82CF63E0: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF63E4: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF63E8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF63EC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF63F0: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF63F4: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF63F8: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF63FC: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6400: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CF6404: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6408: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF640C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF6410: 41980008  blt cr6, 0x82cf6418
	if ctx.cr[6].lt {
	pc = 0x82CF6418; continue 'dispatch;
	}
	// 82CF6414: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82CF6418: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF641C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CF6420: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF6424: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF6428: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF642C: 419A0018  beq cr6, 0x82cf6444
	if ctx.cr[6].eq {
	pc = 0x82CF6444; continue 'dispatch;
	}
	// 82CF6430: 55653830  slwi r5, r11, 7
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6434: 7C05522C  dcbt r5, r10
	// 82CF6438: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF643C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF6440: 4198FFF0  blt cr6, 0x82cf6430
	if ctx.cr[6].lt {
	pc = 0x82CF6430; continue 'dispatch;
	}
	// 82CF6444: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CF6448: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF644C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6450: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF6454: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6458: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF645C: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6460: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF6464: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF6468: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF646C: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6470: D1670000  stfs f11, 0(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6474: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF6478: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF647C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF6480: 4082FFE4  bne 0x82cf6464
	if !ctx.cr[0].eq {
	pc = 0x82CF6464; continue 'dispatch;
	}
	// 82CF6484: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6488: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF648C: 5568103E  rotlwi r8, r11, 2
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82CF6490: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6494: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82CF6498: 0CC80000  twi 6, r8, 0
	// 82CF649C: 7D464396  divwu r10, r6, r8
	ctx.r[10].u32 = ctx.r[6].u32 / ctx.r[8].u32;
	// 82CF64A0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF64A4: 41980008  blt cr6, 0x82cf64ac
	if ctx.cr[6].lt {
	pc = 0x82CF64AC; continue 'dispatch;
	}
	// 82CF64A8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF64AC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF64B0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF64B4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF64B8: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF64BC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF64C0: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF64C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF64C8: 40980010  bge cr6, 0x82cf64d8
	if !ctx.cr[6].lt {
	pc = 0x82CF64D8; continue 'dispatch;
	}
	// 82CF64CC: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF64D0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF64D4: 4E800020  blr
	return;
	// 82CF64D8: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF64DC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF64E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF64E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF64E8 size=296
    let mut pc: u32 = 0x82CF64E8;
    'dispatch: loop {
        match pc {
            0x82CF64E8 => {
    //   block [0x82CF64E8..0x82CF6610)
	// 82CF64E8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF64EC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF64F0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF64F4: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF64F8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF64FC: 7C8951D6  mullw r4, r9, r10
	ctx.r[4].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF6500: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6504: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF650C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6510: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF6514: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6518: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82CF651C: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6520: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF6524: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6528: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF652C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF6530: 41980008  blt cr6, 0x82cf6538
	if ctx.cr[6].lt {
	pc = 0x82CF6538; continue 'dispatch;
	}
	// 82CF6534: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82CF6538: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF653C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF6540: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF6544: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6548: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF654C: 419A0018  beq cr6, 0x82cf6564
	if ctx.cr[6].eq {
	pc = 0x82CF6564; continue 'dispatch;
	}
	// 82CF6550: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6554: 7C055A2C  dcbt r5, r11
	// 82CF6558: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF655C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6560: 4198FFF0  blt cr6, 0x82cf6550
	if ctx.cr[6].lt {
	pc = 0x82CF6550; continue 'dispatch;
	}
	// 82CF6564: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF6568: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF656C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6570: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF6574: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6578: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF657C: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6580: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF6584: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF6588: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF658C: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6590: D1680400  stfs f11, 0x400(r8)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6594: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF6598: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF659C: D1280000  stfs f9, 0(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF65A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF65A4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF65A8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF65AC: 4082FFD8  bne 0x82cf6584
	if !ctx.cr[0].eq {
	pc = 0x82CF6584; continue 'dispatch;
	}
	// 82CF65B0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF65B4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF65B8: 5547103E  rotlwi r7, r10, 2
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF65BC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF65C0: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF65C4: 0CC70000  twi 6, r7, 0
	// 82CF65C8: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF65CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF65D0: 40980008  bge cr6, 0x82cf65d8
	if !ctx.cr[6].lt {
	pc = 0x82CF65D8; continue 'dispatch;
	}
	// 82CF65D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF65D8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF65DC: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF65E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF65E4: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF65E8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF65EC: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF65F0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF65F4: 40980010  bge cr6, 0x82cf6604
	if !ctx.cr[6].lt {
	pc = 0x82CF6604; continue 'dispatch;
	}
	// 82CF65F8: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF65FC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6600: 4E800020  blr
	return;
	// 82CF6604: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6608: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF660C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6610 size=320
    let mut pc: u32 = 0x82CF6610;
    'dispatch: loop {
        match pc {
            0x82CF6610 => {
    //   block [0x82CF6610..0x82CF6750)
	// 82CF6610: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6614: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6618: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF661C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6620: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6624: 7CA951D6  mullw r5, r9, r10
	ctx.r[5].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF6628: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF662C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6630: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6634: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6638: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF663C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6640: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF6644: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6648: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF664C: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6650: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6654: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF6658: 41980008  blt cr6, 0x82cf6660
	if ctx.cr[6].lt {
	pc = 0x82CF6660; continue 'dispatch;
	}
	// 82CF665C: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82CF6660: 55072036  slwi r7, r8, 4
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6664: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF6668: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF666C: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6670: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF6674: 419A0018  beq cr6, 0x82cf668c
	if ctx.cr[6].eq {
	pc = 0x82CF668C; continue 'dispatch;
	}
	// 82CF6678: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF667C: 7C055A2C  dcbt r5, r11
	// 82CF6680: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF6684: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6688: 4198FFF0  blt cr6, 0x82cf6678
	if ctx.cr[6].lt {
	pc = 0x82CF6678; continue 'dispatch;
	}
	// 82CF668C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF6690: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6694: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6698: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF669C: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF66A0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF66A4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF66A8: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF66AC: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF66B0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF66B4: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF66B8: D1690C00  stfs f11, 0xc00(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF66BC: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF66C0: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF66C4: D1290800  stfs f9, 0x800(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF66C8: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF66CC: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF66D0: D0E90400  stfs f7, 0x400(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF66D4: C0CB0000  lfs f6, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF66D8: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF66DC: D0A90000  stfs f5, 0(r9)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF66E0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82CF66E4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF66E8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF66EC: 4082FFC0  bne 0x82cf66ac
	if !ctx.cr[0].eq {
	pc = 0x82CF66AC; continue 'dispatch;
	}
	// 82CF66F0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF66F4: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF66F8: 5547103E  rotlwi r7, r10, 2
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF66FC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6700: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF6704: 0CC70000  twi 6, r7, 0
	// 82CF6708: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF670C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF6710: 40980008  bge cr6, 0x82cf6718
	if !ctx.cr[6].lt {
	pc = 0x82CF6718; continue 'dispatch;
	}
	// 82CF6714: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF6718: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF671C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6720: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF6724: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF6728: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF672C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6730: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6734: 40980010  bge cr6, 0x82cf6744
	if !ctx.cr[6].lt {
	pc = 0x82CF6744; continue 'dispatch;
	}
	// 82CF6738: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF673C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6740: 4E800020  blr
	return;
	// 82CF6744: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6748: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF674C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6750 size=348
    let mut pc: u32 = 0x82CF6750;
    'dispatch: loop {
        match pc {
            0x82CF6750 => {
    //   block [0x82CF6750..0x82CF68AC)
	// 82CF6750: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6754: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6758: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF675C: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6760: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6764: 7CA741D6  mullw r5, r7, r8
	ctx.r[5].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF6768: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF676C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6770: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6774: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6778: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF677C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6780: 7D082050  subf r8, r8, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF6784: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6788: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF678C: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF6790: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6794: 41980008  blt cr6, 0x82cf679c
	if ctx.cr[6].lt {
	pc = 0x82CF679C; continue 'dispatch;
	}
	// 82CF6798: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82CF679C: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF67A0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF67A4: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82CF67A8: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF67AC: 38A7007F  addi r5, r7, 0x7f
	ctx.r[5].s64 = ctx.r[7].s64 + 127;
	// 82CF67B0: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF67B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF67B8: 419A0018  beq cr6, 0x82cf67d0
	if ctx.cr[6].eq {
	pc = 0x82CF67D0; continue 'dispatch;
	}
	// 82CF67BC: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF67C0: 7C055A2C  dcbt r5, r11
	// 82CF67C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF67C8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF67CC: 4198FFF0  blt cr6, 0x82cf67bc
	if ctx.cr[6].lt {
	pc = 0x82CF67BC; continue 'dispatch;
	}
	// 82CF67D0: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CF67D4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF67D8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF67DC: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82CF67E0: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF67E4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF67E8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF67EC: EDAC4824  fdivs f13, f12, f9
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF67F0: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF67F4: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF67F8: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF67FC: D16A1400  stfs f11, 0x1400(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF6800: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF6804: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6808: D12A1000  stfs f9, 0x1000(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF680C: C10B000C  lfs f8, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF6810: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6814: D0EA0C00  stfs f7, 0xc00(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF6818: C0CB0008  lfs f6, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF681C: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6820: D0AA0800  stfs f5, 0x800(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF6824: C08B0004  lfs f4, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF6828: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF682C: D06A0400  stfs f3, 0x400(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6830: C04B0000  lfs f2, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CF6834: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6838: D02A0000  stfs f1, 0(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF683C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82CF6840: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF6844: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6848: 4082FFA8  bne 0x82cf67f0
	if !ctx.cr[0].eq {
	pc = 0x82CF67F0; continue 'dispatch;
	}
	// 82CF684C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6850: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6854: 5527103E  rotlwi r7, r9, 2
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 82CF6858: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF685C: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF6860: 0CC70000  twi 6, r7, 0
	// 82CF6864: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF6868: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF686C: 40980008  bge cr6, 0x82cf6874
	if !ctx.cr[6].lt {
	pc = 0x82CF6874; continue 'dispatch;
	}
	// 82CF6870: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF6874: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6878: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF687C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6880: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF6884: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF6888: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF688C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6890: 40980010  bge cr6, 0x82cf68a0
	if !ctx.cr[6].lt {
	pc = 0x82CF68A0; continue 'dispatch;
	}
	// 82CF6894: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF6898: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF689C: 4E800020  blr
	return;
	// 82CF68A0: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF68A4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF68A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF68B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF68B0 size=312
    let mut pc: u32 = 0x82CF68B0;
    'dispatch: loop {
        match pc {
            0x82CF68B0 => {
    //   block [0x82CF68B0..0x82CF69E8)
	// 82CF68B0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF68B4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF68B8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF68BC: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF68C0: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF68C4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF68C8: 7D0559D6  mullw r8, r5, r11
	ctx.r[8].s64 = (ctx.r[5].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82CF68CC: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF68D0: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF68D4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF68D8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF68DC: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF68E0: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF68E4: 7D64F850  subf r11, r4, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 82CF68E8: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF68EC: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF68F0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF68F4: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF68F8: 41980008  blt cr6, 0x82cf6900
	if ctx.cr[6].lt {
	pc = 0x82CF6900; continue 'dispatch;
	}
	// 82CF68FC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82CF6900: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF6904: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6908: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF690C: 54A4083C  slwi r4, r5, 1
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF6910: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF6914: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6918: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF691C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF6920: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6924: C1AB0C58  lfs f13, 0xc58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6928: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF692C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82CF6930: 419A0044  beq cr6, 0x82cf6974
	if ctx.cr[6].eq {
	pc = 0x82CF6974; continue 'dispatch;
	}
	// 82CF6934: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82CF6938: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82CF693C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82CF6940: A3EA0000  lhz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6944: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF6948: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82CF694C: 7FFF0734  extsh r31, r31
	ctx.r[31].s64 = ctx.r[31].s16 as i64;
	// 82CF6950: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82CF6954: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6958: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF695C: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6960: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6964: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6968: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF696C: 39290400  addi r9, r9, 0x400
	ctx.r[9].s64 = ctx.r[9].s64 + 1024;
	// 82CF6970: 4082FFD0  bne 0x82cf6940
	if !ctx.cr[0].eq {
	pc = 0x82CF6940; continue 'dispatch;
	}
	// 82CF6974: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF6978: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF697C: 7D044214  add r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 82CF6980: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF6984: 4082FFA8  bne 0x82cf692c
	if !ctx.cr[0].eq {
	pc = 0x82CF692C; continue 'dispatch;
	}
	// 82CF6988: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF698C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6990: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF6994: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6998: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF699C: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF69A0: 0CC80000  twi 6, r8, 0
	// 82CF69A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF69A8: 41980008  blt cr6, 0x82cf69b0
	if ctx.cr[6].lt {
	pc = 0x82CF69B0; continue 'dispatch;
	}
	// 82CF69AC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF69B0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF69B4: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF69B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF69BC: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF69C0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF69C4: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF69C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF69CC: 40980010  bge cr6, 0x82cf69dc
	if !ctx.cr[6].lt {
	pc = 0x82CF69DC; continue 'dispatch;
	}
	// 82CF69D0: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF69D4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF69D8: 4E800020  blr
	return;
	// 82CF69DC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF69E0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF69E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF69E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF69E8 size=316
    let mut pc: u32 = 0x82CF69E8;
    'dispatch: loop {
        match pc {
            0x82CF69E8 => {
    //   block [0x82CF69E8..0x82CF6B24)
	// 82CF69E8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF69EC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF69F0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF69F4: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF69F8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF69FC: 7C8A59D6  mullw r4, r10, r11
	ctx.r[4].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82CF6A00: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6A04: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6A08: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6A0C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6A10: 5489083C  slwi r9, r4, 1
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF6A14: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6A18: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF6A1C: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6A20: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CF6A24: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6A28: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6A2C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF6A30: 41980008  blt cr6, 0x82cf6a38
	if ctx.cr[6].lt {
	pc = 0x82CF6A38; continue 'dispatch;
	}
	// 82CF6A34: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82CF6A38: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF6A3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CF6A40: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF6A44: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF6A48: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF6A4C: 419A0018  beq cr6, 0x82cf6a64
	if ctx.cr[6].eq {
	pc = 0x82CF6A64; continue 'dispatch;
	}
	// 82CF6A50: 55653830  slwi r5, r11, 7
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6A54: 7C05522C  dcbt r5, r10
	// 82CF6A58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF6A5C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF6A60: 4198FFF0  blt cr6, 0x82cf6a50
	if ctx.cr[6].lt {
	pc = 0x82CF6A50; continue 'dispatch;
	}
	// 82CF6A64: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CF6A68: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6A6C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6A70: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF6A74: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6A78: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6A7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF6A80: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6A84: C1AB0C58  lfs f13, 0xc58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6A88: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF6A8C: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6A90: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF6A94: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82CF6A98: 7D660734  extsh r6, r11
	ctx.r[6].s64 = ctx.r[11].s16 as i64;
	// 82CF6A9C: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82CF6AA0: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF6AA4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6AA8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6AAC: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6AB0: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6AB4: D0E70000  stfs f7, 0(r7)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6AB8: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF6ABC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6AC0: 4082FFCC  bne 0x82cf6a8c
	if !ctx.cr[0].eq {
	pc = 0x82CF6A8C; continue 'dispatch;
	}
	// 82CF6AC4: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6AC8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6ACC: 5568083E  rotlwi r8, r11, 1
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 82CF6AD0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6AD4: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82CF6AD8: 0CC80000  twi 6, r8, 0
	// 82CF6ADC: 7D464396  divwu r10, r6, r8
	ctx.r[10].u32 = ctx.r[6].u32 / ctx.r[8].u32;
	// 82CF6AE0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6AE4: 41980008  blt cr6, 0x82cf6aec
	if ctx.cr[6].lt {
	pc = 0x82CF6AEC; continue 'dispatch;
	}
	// 82CF6AE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF6AEC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6AF0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6AF4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF6AF8: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF6AFC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6B00: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6B04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6B08: 40980010  bge cr6, 0x82cf6b18
	if !ctx.cr[6].lt {
	pc = 0x82CF6B18; continue 'dispatch;
	}
	// 82CF6B0C: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF6B10: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6B14: 4E800020  blr
	return;
	// 82CF6B18: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6B1C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6B20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6B28 size=352
    let mut pc: u32 = 0x82CF6B28;
    'dispatch: loop {
        match pc {
            0x82CF6B28 => {
    //   block [0x82CF6B28..0x82CF6C88)
	// 82CF6B28: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6B2C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6B30: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF6B34: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6B38: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6B3C: 7C8951D6  mullw r4, r9, r10
	ctx.r[4].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF6B40: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6B44: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6B48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6B4C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6B50: 5489083C  slwi r9, r4, 1
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF6B54: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6B58: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82CF6B5C: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6B60: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF6B64: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6B68: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6B6C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF6B70: 41980008  blt cr6, 0x82cf6b78
	if ctx.cr[6].lt {
	pc = 0x82CF6B78; continue 'dispatch;
	}
	// 82CF6B74: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82CF6B78: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6B7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF6B80: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF6B84: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6B88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF6B8C: 419A0018  beq cr6, 0x82cf6ba4
	if ctx.cr[6].eq {
	pc = 0x82CF6BA4; continue 'dispatch;
	}
	// 82CF6B90: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6B94: 7C055A2C  dcbt r5, r11
	// 82CF6B98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF6B9C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6BA0: 4198FFF0  blt cr6, 0x82cf6b90
	if ctx.cr[6].lt {
	pc = 0x82CF6B90; continue 'dispatch;
	}
	// 82CF6BA4: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF6BA8: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6BAC: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6BB0: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82CF6BB4: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF6BB8: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6BBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF6BC0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6BC4: C1AA0C58  lfs f13, 0xc58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6BC8: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF6BCC: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF6BD0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF6BD4: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF6BD8: F8C1FFE0  std r6, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u64 ) };
	// 82CF6BDC: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF6BE0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6BE4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6BE8: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6BEC: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6BF0: D0E80400  stfs f7, 0x400(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6BF4: A0AB0000  lhz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6BF8: 7CAA0734  extsh r10, r5
	ctx.r[10].s64 = ctx.r[5].s16 as i64;
	// 82CF6BFC: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 82CF6C00: C8C1FFE8  lfd f6, -0x18(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF6C04: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF6C08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF6C0C: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF6C10: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6C14: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6C18: D0480000  stfs f2, 0(r8)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6C1C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF6C20: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6C24: 4082FFA8  bne 0x82cf6bcc
	if !ctx.cr[0].eq {
	pc = 0x82CF6BCC; continue 'dispatch;
	}
	// 82CF6C28: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6C2C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6C30: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF6C34: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6C38: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF6C3C: 0CC70000  twi 6, r7, 0
	// 82CF6C40: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF6C44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF6C48: 40980008  bge cr6, 0x82cf6c50
	if !ctx.cr[6].lt {
	pc = 0x82CF6C50; continue 'dispatch;
	}
	// 82CF6C4C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF6C50: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6C54: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6C58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF6C5C: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF6C60: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6C64: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6C68: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6C6C: 40980010  bge cr6, 0x82cf6c7c
	if !ctx.cr[6].lt {
	pc = 0x82CF6C7C; continue 'dispatch;
	}
	// 82CF6C70: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF6C74: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6C78: 4E800020  blr
	return;
	// 82CF6C7C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6C80: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6C88 size=424
    let mut pc: u32 = 0x82CF6C88;
    'dispatch: loop {
        match pc {
            0x82CF6C88 => {
    //   block [0x82CF6C88..0x82CF6E30)
	// 82CF6C88: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6C8C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6C90: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF6C94: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6C98: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6C9C: 7CA951D6  mullw r5, r9, r10
	ctx.r[5].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF6CA0: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6CA4: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6CA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6CAC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6CB0: 54A9083C  slwi r9, r5, 1
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF6CB4: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6CB8: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF6CBC: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6CC0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF6CC4: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF6CC8: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6CCC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF6CD0: 41980008  blt cr6, 0x82cf6cd8
	if ctx.cr[6].lt {
	pc = 0x82CF6CD8; continue 'dispatch;
	}
	// 82CF6CD4: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82CF6CD8: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6CDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF6CE0: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF6CE4: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6CE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF6CEC: 419A0018  beq cr6, 0x82cf6d04
	if ctx.cr[6].eq {
	pc = 0x82CF6D04; continue 'dispatch;
	}
	// 82CF6CF0: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6CF4: 7C055A2C  dcbt r5, r11
	// 82CF6CF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF6CFC: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6D00: 4198FFF0  blt cr6, 0x82cf6cf0
	if ctx.cr[6].lt {
	pc = 0x82CF6CF0; continue 'dispatch;
	}
	// 82CF6D04: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF6D08: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6D0C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6D10: F941FFD0  std r10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[10].u64 ) };
	// 82CF6D14: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF6D18: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6D1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF6D20: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6D24: C1AA0C58  lfs f13, 0xc58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6D28: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF6D2C: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF6D30: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF6D34: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF6D38: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CF6D3C: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF6D40: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6D44: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6D48: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6D4C: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6D50: D0E90C00  stfs f7, 0xc00(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF6D54: A0AB0004  lhz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6D58: 7CAA0734  extsh r10, r5
	ctx.r[10].s64 = ctx.r[5].s16 as i64;
	// 82CF6D5C: F941FFD8  std r10, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[10].u64 ) };
	// 82CF6D60: C8C1FFD8  lfd f6, -0x28(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF6D64: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF6D68: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF6D6C: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6D70: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6D74: D0490800  stfs f2, 0x800(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF6D78: A0EB0002  lhz r7, 2(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF6D7C: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF6D80: F8A1FFE0  std r5, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[5].u64 ) };
	// 82CF6D84: C821FFE0  lfd f1, -0x20(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF6D88: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 82CF6D8C: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF6D90: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6D94: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6D98: D1090400  stfs f8, 0x400(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6D9C: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6DA0: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF6DA4: F8E1FFE8  std r7, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[7].u64 ) };
	// 82CF6DA8: C8E1FFE8  lfd f7, -0x18(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF6DAC: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF6DB0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF6DB4: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF6DB8: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6DBC: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6DC0: D0690000  stfs f3, 0(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6DC4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF6DC8: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6DCC: 4082FF60  bne 0x82cf6d2c
	if !ctx.cr[0].eq {
	pc = 0x82CF6D2C; continue 'dispatch;
	}
	// 82CF6DD0: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6DD4: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6DD8: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF6DDC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6DE0: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF6DE4: 0CC70000  twi 6, r7, 0
	// 82CF6DE8: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF6DEC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF6DF0: 40980008  bge cr6, 0x82cf6df8
	if !ctx.cr[6].lt {
	pc = 0x82CF6DF8; continue 'dispatch;
	}
	// 82CF6DF4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF6DF8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6DFC: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6E00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF6E04: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF6E08: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6E0C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6E10: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF6E14: 40980010  bge cr6, 0x82cf6e24
	if !ctx.cr[6].lt {
	pc = 0x82CF6E24; continue 'dispatch;
	}
	// 82CF6E18: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF6E1C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6E20: 4E800020  blr
	return;
	// 82CF6E24: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF6E28: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF6E2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF6E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF6E30 size=500
    let mut pc: u32 = 0x82CF6E30;
    'dispatch: loop {
        match pc {
            0x82CF6E30 => {
    //   block [0x82CF6E30..0x82CF7024)
	// 82CF6E30: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF6E34: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6E38: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF6E3C: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6E40: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF6E44: 7CA741D6  mullw r5, r7, r8
	ctx.r[5].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF6E48: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6E4C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6E50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6E54: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6E58: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF6E5C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6E60: 7D082050  subf r8, r8, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF6E64: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF6E68: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF6E6C: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF6E70: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF6E74: 41980008  blt cr6, 0x82cf6e7c
	if ctx.cr[6].lt {
	pc = 0x82CF6E7C; continue 'dispatch;
	}
	// 82CF6E78: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82CF6E7C: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6E80: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF6E84: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82CF6E88: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6E8C: 38A7007F  addi r5, r7, 0x7f
	ctx.r[5].s64 = ctx.r[7].s64 + 127;
	// 82CF6E90: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF6E94: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF6E98: 419A0018  beq cr6, 0x82cf6eb0
	if ctx.cr[6].eq {
	pc = 0x82CF6EB0; continue 'dispatch;
	}
	// 82CF6E9C: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF6EA0: 7C055A2C  dcbt r5, r11
	// 82CF6EA4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF6EA8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF6EAC: 4198FFF0  blt cr6, 0x82cf6e9c
	if ctx.cr[6].lt {
	pc = 0x82CF6E9C; continue 'dispatch;
	}
	// 82CF6EB0: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CF6EB4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6EB8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF6EBC: F921FFC0  std r9, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[9].u64 ) };
	// 82CF6EC0: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF6EC4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6EC8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF6ECC: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6ED0: C1A90C58  lfs f13, 0xc58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF6ED4: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF6ED8: A12B000A  lhz r9, 0xa(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 82CF6EDC: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF6EE0: 7D260734  extsh r6, r9
	ctx.r[6].s64 = ctx.r[9].s16 as i64;
	// 82CF6EE4: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CF6EE8: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF6EEC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF6EF0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF6EF4: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6EF8: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6EFC: D0EA1400  stfs f7, 0x1400(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF6F00: A0AB0008  lhz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF6F04: 7CA90734  extsh r9, r5
	ctx.r[9].s64 = ctx.r[5].s16 as i64;
	// 82CF6F08: F921FFC8  std r9, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[9].u64 ) };
	// 82CF6F0C: C8C1FFC8  lfd f6, -0x38(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CF6F10: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF6F14: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF6F18: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6F1C: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6F20: D04A1000  stfs f2, 0x1000(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF6F24: A0EB0006  lhz r7, 6(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF6F28: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF6F2C: F8A1FFD0  std r5, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[5].u64 ) };
	// 82CF6F30: C821FFD0  lfd f1, -0x30(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF6F34: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 82CF6F38: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF6F3C: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6F40: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6F44: D10A0C00  stfs f8, 0xc00(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF6F48: A08B0004  lhz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6F4C: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF6F50: F8E1FFD8  std r7, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[7].u64 ) };
	// 82CF6F54: C8E1FFD8  lfd f7, -0x28(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF6F58: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF6F5C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF6F60: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6F64: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6F68: D06A0800  stfs f3, 0x800(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF6F6C: A0CB0002  lhz r6, 2(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF6F70: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CF6F74: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CF6F78: C841FFE0  lfd f2, -0x20(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF6F7C: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF6F80: FD600818  frsp f11, f1
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF6F84: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6F88: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6F8C: D12A0400  stfs f9, 0x400(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF6F90: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6F94: 7D260734  extsh r6, r9
	ctx.r[6].s64 = ctx.r[9].s16 as i64;
	// 82CF6F98: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF6F9C: C901FFE8  lfd f8, -0x18(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF6FA0: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82CF6FA4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82CF6FA8: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82CF6FAC: ECA60372  fmuls f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF6FB0: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF6FB4: D08A0000  stfs f4, 0(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF6FB8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF6FBC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF6FC0: 4082FF18  bne 0x82cf6ed8
	if !ctx.cr[0].eq {
	pc = 0x82CF6ED8; continue 'dispatch;
	}
	// 82CF6FC4: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF6FC8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF6FCC: 5527083E  rotlwi r7, r9, 1
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82CF6FD0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF6FD4: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF6FD8: 0CC70000  twi 6, r7, 0
	// 82CF6FDC: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF6FE0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF6FE4: 40980008  bge cr6, 0x82cf6fec
	if !ctx.cr[6].lt {
	pc = 0x82CF6FEC; continue 'dispatch;
	}
	// 82CF6FE8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF6FEC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF6FF0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF6FF4: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF6FF8: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF6FFC: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF7000: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7004: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7008: 40980010  bge cr6, 0x82cf7018
	if !ctx.cr[6].lt {
	pc = 0x82CF7018; continue 'dispatch;
	}
	// 82CF700C: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7010: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7014: 4E800020  blr
	return;
	// 82CF7018: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF701C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7028 size=304
    let mut pc: u32 = 0x82CF7028;
    'dispatch: loop {
        match pc {
            0x82CF7028 => {
    //   block [0x82CF7028..0x82CF7158)
	// 82CF7028: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF702C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7030: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7034: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7038: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF703C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7040: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7044: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7048: 7CE959D6  mullw r7, r9, r11
	ctx.r[7].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82CF704C: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7050: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7054: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82CF7058: 7D4AF850  subf r10, r10, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82CF705C: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7060: 7CC53214  add r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF7064: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF7068: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82CF706C: 41980008  blt cr6, 0x82cf7074
	if ctx.cr[6].lt {
	pc = 0x82CF7074; continue 'dispatch;
	}
	// 82CF7070: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82CF7074: 7D4B07B4  extsw r11, r10
	ctx.r[11].s64 = ctx.r[10].s32 as i64;
	// 82CF7078: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF707C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7080: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF7084: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF7088: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF708C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7090: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF7094: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7098: C1AA67A4  lfs f13, 0x67a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF709C: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF70A0: C18B67A0  lfs f12, 0x67a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF70A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CF70A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82CF70AC: 419A003C  beq cr6, 0x82cf70e8
	if ctx.cr[6].eq {
	pc = 0x82CF70E8; continue 'dispatch;
	}
	// 82CF70B0: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 82CF70B4: 7C8B40AE  lbzx r4, r11, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82CF70B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF70BC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF70C0: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82CF70C4: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF70C8: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF70CC: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF70D0: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF70D4: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF70D8: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF70DC: D0AA0000  stfs f5, 0(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF70E0: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CF70E4: 4198FFD0  blt cr6, 0x82cf70b4
	if ctx.cr[6].lt {
	pc = 0x82CF70B4; continue 'dispatch;
	}
	// 82CF70E8: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF70EC: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF70F0: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF70F4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82CF70F8: 4082FFAC  bne 0x82cf70a4
	if !ctx.cr[0].eq {
	pc = 0x82CF70A4; continue 'dispatch;
	}
	// 82CF70FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7100: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7104: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF7108: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF710C: 0CCA0000  twi 6, r10, 0
	// 82CF7110: 7D495396  divwu r10, r9, r10
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[10].u32;
	// 82CF7114: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7118: 41980008  blt cr6, 0x82cf7120
	if ctx.cr[6].lt {
	pc = 0x82CF7120; continue 'dispatch;
	}
	// 82CF711C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF7120: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7124: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7128: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF712C: 7D4B3050  subf r10, r11, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 82CF7130: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7134: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7138: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF713C: 40980010  bge cr6, 0x82cf714c
	if !ctx.cr[6].lt {
	pc = 0x82CF714C; continue 'dispatch;
	}
	// 82CF7140: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7144: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7148: 4E800020  blr
	return;
	// 82CF714C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7150: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7158 size=312
    let mut pc: u32 = 0x82CF7158;
    'dispatch: loop {
        match pc {
            0x82CF7158 => {
    //   block [0x82CF7158..0x82CF7290)
	// 82CF7158: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF715C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7160: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7164: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7168: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF716C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7170: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7174: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7178: 7D2551D6  mullw r9, r5, r10
	ctx.r[9].s64 = (ctx.r[5].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF717C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7180: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7184: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF7188: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF718C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF7190: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7194: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF7198: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF719C: 41980008  blt cr6, 0x82cf71a4
	if ctx.cr[6].lt {
	pc = 0x82CF71A4; continue 'dispatch;
	}
	// 82CF71A0: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82CF71A4: 3909007F  addi r8, r9, 0x7f
	ctx.r[8].s64 = ctx.r[9].s64 + 127;
	// 82CF71A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF71AC: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF71B0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF71B4: 419A0018  beq cr6, 0x82cf71cc
	if ctx.cr[6].eq {
	pc = 0x82CF71CC; continue 'dispatch;
	}
	// 82CF71B8: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF71BC: 7C055A2C  dcbt r5, r11
	// 82CF71C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF71C4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF71C8: 4198FFF0  blt cr6, 0x82cf71b8
	if ctx.cr[6].lt {
	pc = 0x82CF71B8; continue 'dispatch;
	}
	// 82CF71CC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF71D0: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF71D4: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF71D8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82CF71DC: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF71E0: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF71E4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF71E8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF71EC: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF71F0: C1A867A4  lfs f13, 0x67a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF71F4: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF71F8: C18A67A0  lfs f12, 0x67a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF71FC: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7200: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF7204: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF7208: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 82CF720C: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF7210: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF7214: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF7218: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF721C: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7220: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7224: D0A70000  stfs f5, 0(r7)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7228: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF722C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7230: 4082FFCC  bne 0x82cf71fc
	if !ctx.cr[0].eq {
	pc = 0x82CF71FC; continue 'dispatch;
	}
	// 82CF7234: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7238: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF723C: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF7240: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7244: 0CC90000  twi 6, r9, 0
	// 82CF7248: 7D484B96  divwu r10, r8, r9
	ctx.r[10].u32 = ctx.r[8].u32 / ctx.r[9].u32;
	// 82CF724C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7250: 41980008  blt cr6, 0x82cf7258
	if ctx.cr[6].lt {
	pc = 0x82CF7258; continue 'dispatch;
	}
	// 82CF7254: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF7258: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF725C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7260: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7264: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF7268: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF726C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7270: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7274: 40980010  bge cr6, 0x82cf7284
	if !ctx.cr[6].lt {
	pc = 0x82CF7284; continue 'dispatch;
	}
	// 82CF7278: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF727C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7280: 4E800020  blr
	return;
	// 82CF7284: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7288: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF728C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7290 size=352
    let mut pc: u32 = 0x82CF7290;
    'dispatch: loop {
        match pc {
            0x82CF7290 => {
    //   block [0x82CF7290..0x82CF73F0)
	// 82CF7290: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7294: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7298: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF729C: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF72A0: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF72A4: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF72A8: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF72AC: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF72B0: 7D2551D6  mullw r9, r5, r10
	ctx.r[9].s64 = (ctx.r[5].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF72B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF72B8: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF72BC: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF72C0: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF72C4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF72C8: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF72CC: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF72D0: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF72D4: 41980008  blt cr6, 0x82cf72dc
	if ctx.cr[6].lt {
	pc = 0x82CF72DC; continue 'dispatch;
	}
	// 82CF72D8: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82CF72DC: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF72E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF72E4: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF72E8: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF72EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF72F0: 419A0018  beq cr6, 0x82cf7308
	if ctx.cr[6].eq {
	pc = 0x82CF7308; continue 'dispatch;
	}
	// 82CF72F4: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF72F8: 7C055A2C  dcbt r5, r11
	// 82CF72FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF7300: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7304: 4198FFF0  blt cr6, 0x82cf72f4
	if ctx.cr[6].lt {
	pc = 0x82CF72F4; continue 'dispatch;
	}
	// 82CF7308: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF730C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7310: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7314: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CF7318: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82CF731C: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7320: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7324: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF7328: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF732C: C1A767A4  lfs f13, 0x67a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7330: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7334: C18A67A0  lfs f12, 0x67a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF7338: 88EB0001  lbz r7, 1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF733C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF7340: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF7344: C941FFE0  lfd f10, -0x20(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7348: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF734C: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF7350: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF7354: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7358: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF735C: D0A80400  stfs f5, 0x400(r8)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7360: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7364: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82CF7368: F8A1FFE8  std r5, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[5].u64 ) };
	// 82CF736C: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF7370: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF7374: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF7378: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF737C: ED410332  fmuls f10, f1, f12
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7380: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7384: D1280000  stfs f9, 0(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7388: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF738C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7390: 4082FFA8  bne 0x82cf7338
	if !ctx.cr[0].eq {
	pc = 0x82CF7338; continue 'dispatch;
	}
	// 82CF7394: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7398: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF739C: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF73A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF73A4: 0CC90000  twi 6, r9, 0
	// 82CF73A8: 7D474B96  divwu r10, r7, r9
	ctx.r[10].u32 = ctx.r[7].u32 / ctx.r[9].u32;
	// 82CF73AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF73B0: 41980008  blt cr6, 0x82cf73b8
	if ctx.cr[6].lt {
	pc = 0x82CF73B8; continue 'dispatch;
	}
	// 82CF73B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF73B8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF73BC: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF73C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF73C4: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF73C8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF73CC: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF73D0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF73D4: 40980010  bge cr6, 0x82cf73e4
	if !ctx.cr[6].lt {
	pc = 0x82CF73E4; continue 'dispatch;
	}
	// 82CF73D8: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF73DC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF73E0: 4E800020  blr
	return;
	// 82CF73E4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF73E8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF73EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF73F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF73F0 size=404
    let mut pc: u32 = 0x82CF73F0;
    'dispatch: loop {
        match pc {
            0x82CF73F0 => {
    //   block [0x82CF73F0..0x82CF7584)
	// 82CF73F0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF73F4: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF73F8: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF73FC: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7400: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7404: 7D2951D6  mullw r9, r9, r10
	ctx.r[9].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF7408: 80830018  lwz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF740C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7410: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7414: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7418: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82CF741C: 7CC62050  subf r6, r6, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	// 82CF7420: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF7424: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7428: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF742C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF7430: 41980008  blt cr6, 0x82cf7438
	if ctx.cr[6].lt {
	pc = 0x82CF7438; continue 'dispatch;
	}
	// 82CF7434: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82CF7438: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF743C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF7440: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF7444: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7448: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF744C: 419A0018  beq cr6, 0x82cf7464
	if ctx.cr[6].eq {
	pc = 0x82CF7464; continue 'dispatch;
	}
	// 82CF7450: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7454: 7C055A2C  dcbt r5, r11
	// 82CF7458: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF745C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7460: 4198FFF0  blt cr6, 0x82cf7450
	if ctx.cr[6].lt {
	pc = 0x82CF7450; continue 'dispatch;
	}
	// 82CF7464: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF7468: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF746C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7470: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CF7474: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82CF7478: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF747C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7480: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF7484: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7488: C1A767A4  lfs f13, 0x67a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF748C: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7490: C18A67A0  lfs f12, 0x67a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF7494: 88EB0003  lbz r7, 3(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82CF7498: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF749C: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF74A0: C941FFE0  lfd f10, -0x20(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF74A4: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF74A8: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF74AC: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF74B0: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF74B4: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF74B8: D0A90C00  stfs f5, 0xc00(r9)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF74BC: 88AB0002  lbz r5, 2(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF74C0: F8A1FFE8  std r5, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[5].u64 ) };
	// 82CF74C4: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF74C8: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF74CC: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF74D0: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF74D4: ED410332  fmuls f10, f1, f12
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF74D8: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF74DC: D1290800  stfs f9, 0x800(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF74E0: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF74E4: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF74E8: C901FFF0  lfd f8, -0x10(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF74EC: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82CF74F0: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82CF74F4: ECA66828  fsubs f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF74F8: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF74FC: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7500: D0690400  stfs f3, 0x400(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7504: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7508: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF750C: F8C1FFF8  std r6, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[6].u64 ) };
	// 82CF7510: C841FFF8  lfd f2, -8(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7514: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF7518: FD400818  frsp f10, f1
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF751C: ED2A6828  fsubs f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF7520: ED090332  fmuls f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7524: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7528: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF752C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF7530: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7534: 4082FF60  bne 0x82cf7494
	if !ctx.cr[0].eq {
	pc = 0x82CF7494; continue 'dispatch;
	}
	// 82CF7538: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF753C: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7540: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF7544: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7548: 0CC80000  twi 6, r8, 0
	// 82CF754C: 7D474396  divwu r10, r7, r8
	ctx.r[10].u32 = ctx.r[7].u32 / ctx.r[8].u32;
	// 82CF7550: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7554: 41980008  blt cr6, 0x82cf755c
	if ctx.cr[6].lt {
	pc = 0x82CF755C; continue 'dispatch;
	}
	// 82CF7558: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF755C: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7560: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7564: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7568: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF756C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7570: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7574: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7578: 4098000C  bge cr6, 0x82cf7584
	if !ctx.cr[6].lt {
		sub_82CF7584(ctx, base);
		return;
	}
	// 82CF757C: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7584(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CF7584 size=8
    let mut pc: u32 = 0x82CF7584;
    'dispatch: loop {
        match pc {
            0x82CF7584 => {
    //   block [0x82CF7584..0x82CF758C)
	// 82CF7584: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7590 size=480
    let mut pc: u32 = 0x82CF7590;
    'dispatch: loop {
        match pc {
            0x82CF7590 => {
    //   block [0x82CF7590..0x82CF7770)
	// 82CF7590: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7594: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7598: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF759C: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF75A0: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF75A4: 7D4741D6  mullw r10, r7, r8
	ctx.r[10].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF75A8: 80830018  lwz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF75AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF75B0: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF75B4: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF75B8: 7D082850  subf r8, r8, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 82CF75BC: 7CC62050  subf r6, r6, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	// 82CF75C0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF75C4: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF75C8: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF75CC: 41980008  blt cr6, 0x82cf75d4
	if ctx.cr[6].lt {
	pc = 0x82CF75D4; continue 'dispatch;
	}
	// 82CF75D0: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82CF75D4: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF75D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF75DC: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82CF75E0: 54E7083C  slwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF75E4: 38A7007F  addi r5, r7, 0x7f
	ctx.r[5].s64 = ctx.r[7].s64 + 127;
	// 82CF75E8: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF75EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF75F0: 419A0018  beq cr6, 0x82cf7608
	if ctx.cr[6].eq {
	pc = 0x82CF7608; continue 'dispatch;
	}
	// 82CF75F4: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF75F8: 7C055A2C  dcbt r5, r11
	// 82CF75FC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF7600: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7604: 4198FFF0  blt cr6, 0x82cf75f4
	if ctx.cr[6].lt {
	pc = 0x82CF75F4; continue 'dispatch;
	}
	// 82CF7608: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CF760C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7610: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7614: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CF7618: F921FFD0  std r9, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[9].u64 ) };
	// 82CF761C: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7620: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7624: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CF7628: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF762C: C1A767A4  lfs f13, 0x67a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7630: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7634: C18967A0  lfs f12, 0x67a0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF7638: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 82CF763C: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF7640: F8E1FFD0  std r7, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[7].u64 ) };
	// 82CF7644: C941FFD0  lfd f10, -0x30(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7648: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF764C: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF7650: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF7654: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7658: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF765C: D0AA1400  stfs f5, 0x1400(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF7660: 88AB0004  lbz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7664: F8A1FFD8  std r5, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[5].u64 ) };
	// 82CF7668: C881FFD8  lfd f4, -0x28(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF766C: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF7670: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF7674: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF7678: ED410332  fmuls f10, f1, f12
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF767C: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7680: D12A1000  stfs f9, 0x1000(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF7684: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82CF7688: F921FFE0  std r9, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[9].u64 ) };
	// 82CF768C: C901FFE0  lfd f8, -0x20(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7690: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82CF7694: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82CF7698: ECA66828  fsubs f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF769C: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF76A0: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF76A4: D06A0C00  stfs f3, 0xc00(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF76A8: 88CB0002  lbz r6, 2(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF76AC: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF76B0: C841FFE8  lfd f2, -0x18(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF76B4: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF76B8: FD400818  frsp f10, f1
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF76BC: ED2A6828  fsubs f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF76C0: ED090332  fmuls f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF76C4: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF76C8: D0EA0800  stfs f7, 0x800(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF76CC: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF76D0: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82CF76D4: C8C1FFF0  lfd f6, -0x10(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF76D8: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF76DC: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF76E0: EC646828  fsubs f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF76E4: EC430332  fmuls f2, f3, f12
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF76E8: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF76EC: D02A0400  stfs f1, 0x400(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF76F0: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF76F4: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 82CF76F8: F8E1FFF8  std r7, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[7].u64 ) };
	// 82CF76FC: C941FFF8  lfd f10, -8(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7700: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF7704: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF7708: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF770C: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF7710: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7714: D0AA0000  stfs f5, 0(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7718: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF771C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7720: 4082FF18  bne 0x82cf7638
	if !ctx.cr[0].eq {
	pc = 0x82CF7638; continue 'dispatch;
	}
	// 82CF7724: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7728: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF772C: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF7730: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7734: 0CC80000  twi 6, r8, 0
	// 82CF7738: 7D274396  divwu r9, r7, r8
	ctx.r[9].u32 = ctx.r[7].u32 / ctx.r[8].u32;
	// 82CF773C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7740: 41980008  blt cr6, 0x82cf7748
	if ctx.cr[6].lt {
	pc = 0x82CF7748; continue 'dispatch;
	}
	// 82CF7744: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF7748: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF774C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7750: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7754: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF7758: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF775C: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7760: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7764: 4098000C  bge cr6, 0x82cf7770
	if !ctx.cr[6].lt {
		sub_82CF7770(ctx, base);
		return;
	}
	// 82CF7768: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF776C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CF7770 size=8
    let mut pc: u32 = 0x82CF7770;
    'dispatch: loop {
        match pc {
            0x82CF7770 => {
    //   block [0x82CF7770..0x82CF7778)
	// 82CF7770: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7778 size=332
    let mut pc: u32 = 0x82CF7778;
    'dispatch: loop {
        match pc {
            0x82CF7778 => {
    //   block [0x82CF7778..0x82CF78C4)
	// 82CF7778: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82CF777C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7780: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7784: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7788: 88A3000D  lbz r5, 0xd(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF778C: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7790: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7794: 7D0559D6  mullw r8, r5, r11
	ctx.r[8].s64 = (ctx.r[5].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82CF7798: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF779C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF77A0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF77A4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF77A8: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF77AC: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF77B0: 7D64F850  subf r11, r4, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 82CF77B4: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF77B8: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF77BC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF77C0: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF77C4: 41980008  blt cr6, 0x82cf77cc
	if ctx.cr[6].lt {
	pc = 0x82CF77CC; continue 'dispatch;
	}
	// 82CF77C8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82CF77CC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF77D0: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF77D4: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF77D8: 54A4083C  slwi r4, r5, 1
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF77DC: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82CF77E0: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF77E4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF77E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF77EC: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF77F0: C1AB0C58  lfs f13, 0xc58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF77F4: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF77F8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82CF77FC: 419A004C  beq cr6, 0x82cf7848
	if ctx.cr[6].eq {
	pc = 0x82CF7848; continue 'dispatch;
	}
	// 82CF7800: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82CF7804: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82CF7808: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82CF780C: A3EA0000  lhz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7810: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF7814: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82CF7818: 57FEC63E  rlwinm r30, r31, 0x18, 0x18, 0x1f
	ctx.r[30].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82CF781C: 53FE442E  rlwimi r30, r31, 8, 0x10, 0x17
	ctx.r[30].u64 = (((ctx.r[31].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[30].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7820: 7FDF0734  extsh r31, r30
	ctx.r[31].s64 = ctx.r[30].s16 as i64;
	// 82CF7824: FBE1FFE0  std r31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[31].u64 ) };
	// 82CF7828: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF782C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7830: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7834: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7838: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF783C: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7840: 39290400  addi r9, r9, 0x400
	ctx.r[9].s64 = ctx.r[9].s64 + 1024;
	// 82CF7844: 4082FFC8  bne 0x82cf780c
	if !ctx.cr[0].eq {
	pc = 0x82CF780C; continue 'dispatch;
	}
	// 82CF7848: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF784C: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7850: 7D044214  add r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 82CF7854: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF7858: 4082FFA0  bne 0x82cf77f8
	if !ctx.cr[0].eq {
	pc = 0x82CF77F8; continue 'dispatch;
	}
	// 82CF785C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7860: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7864: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF7868: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF786C: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF7870: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF7874: 0CC80000  twi 6, r8, 0
	// 82CF7878: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF787C: 41980008  blt cr6, 0x82cf7884
	if ctx.cr[6].lt {
	pc = 0x82CF7884; continue 'dispatch;
	}
	// 82CF7880: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF7884: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7888: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF788C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7890: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF7894: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7898: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF789C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF78A0: 40980014  bge cr6, 0x82cf78b4
	if !ctx.cr[6].lt {
	pc = 0x82CF78B4; continue 'dispatch;
	}
	// 82CF78A4: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF78A8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF78AC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF78B0: 4E800020  blr
	return;
	// 82CF78B4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF78B8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF78BC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF78C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF78C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF78C8 size=324
    let mut pc: u32 = 0x82CF78C8;
    'dispatch: loop {
        match pc {
            0x82CF78C8 => {
    //   block [0x82CF78C8..0x82CF7A0C)
	// 82CF78C8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF78CC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF78D0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF78D4: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF78D8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF78DC: 7C8A59D6  mullw r4, r10, r11
	ctx.r[4].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82CF78E0: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF78E4: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF78E8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF78EC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF78F0: 5489083C  slwi r9, r4, 1
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF78F4: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF78F8: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF78FC: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF7900: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82CF7904: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7908: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF790C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF7910: 41980008  blt cr6, 0x82cf7918
	if ctx.cr[6].lt {
	pc = 0x82CF7918; continue 'dispatch;
	}
	// 82CF7914: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82CF7918: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF791C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CF7920: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF7924: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF7928: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF792C: 419A0018  beq cr6, 0x82cf7944
	if ctx.cr[6].eq {
	pc = 0x82CF7944; continue 'dispatch;
	}
	// 82CF7930: 55653830  slwi r5, r11, 7
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7934: 7C05522C  dcbt r5, r10
	// 82CF7938: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF793C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF7940: 4198FFF0  blt cr6, 0x82cf7930
	if ctx.cr[6].lt {
	pc = 0x82CF7930; continue 'dispatch;
	}
	// 82CF7944: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 82CF7948: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF794C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7950: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82CF7954: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF7958: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF795C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF7960: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7964: C1AB0C58  lfs f13, 0xc58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7968: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF796C: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7970: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF7974: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82CF7978: 5568C63E  rlwinm r8, r11, 0x18, 0x18, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CF797C: 5168442E  rlwimi r8, r11, 8, 0x10, 0x17
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7980: 7D050734  extsh r5, r8
	ctx.r[5].s64 = ctx.r[8].s16 as i64;
	// 82CF7984: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 82CF7988: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF798C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7990: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7994: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7998: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF799C: D0E70000  stfs f7, 0(r7)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF79A0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF79A4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF79A8: 4082FFC4  bne 0x82cf796c
	if !ctx.cr[0].eq {
	pc = 0x82CF796C; continue 'dispatch;
	}
	// 82CF79AC: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF79B0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF79B4: 5568083E  rotlwi r8, r11, 1
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 82CF79B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF79BC: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82CF79C0: 0CC80000  twi 6, r8, 0
	// 82CF79C4: 7D464396  divwu r10, r6, r8
	ctx.r[10].u32 = ctx.r[6].u32 / ctx.r[8].u32;
	// 82CF79C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF79CC: 41980008  blt cr6, 0x82cf79d4
	if ctx.cr[6].lt {
	pc = 0x82CF79D4; continue 'dispatch;
	}
	// 82CF79D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF79D4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF79D8: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF79DC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF79E0: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF79E4: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF79E8: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF79EC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF79F0: 40980010  bge cr6, 0x82cf7a00
	if !ctx.cr[6].lt {
	pc = 0x82CF7A00; continue 'dispatch;
	}
	// 82CF79F4: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF79F8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF79FC: 4E800020  blr
	return;
	// 82CF7A00: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7A04: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7A10 size=368
    let mut pc: u32 = 0x82CF7A10;
    'dispatch: loop {
        match pc {
            0x82CF7A10 => {
    //   block [0x82CF7A10..0x82CF7B80)
	// 82CF7A10: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7A14: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7A18: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7A1C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7A20: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7A24: 7C8951D6  mullw r4, r9, r10
	ctx.r[4].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF7A28: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7A2C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7A30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7A34: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7A38: 5489083C  slwi r9, r4, 1
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF7A3C: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7A40: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82CF7A44: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF7A48: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF7A4C: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7A50: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF7A54: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF7A58: 41980008  blt cr6, 0x82cf7a60
	if ctx.cr[6].lt {
	pc = 0x82CF7A60; continue 'dispatch;
	}
	// 82CF7A5C: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82CF7A60: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7A64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF7A68: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF7A6C: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7A70: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF7A74: 419A0018  beq cr6, 0x82cf7a8c
	if ctx.cr[6].eq {
	pc = 0x82CF7A8C; continue 'dispatch;
	}
	// 82CF7A78: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7A7C: 7C055A2C  dcbt r5, r11
	// 82CF7A80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF7A84: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7A88: 4198FFF0  blt cr6, 0x82cf7a78
	if ctx.cr[6].lt {
	pc = 0x82CF7A78; continue 'dispatch;
	}
	// 82CF7A8C: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF7A90: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7A94: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7A98: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82CF7A9C: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7AA0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7AA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF7AA8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7AAC: C1AA0C58  lfs f13, 0xc58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7AB0: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7AB4: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF7AB8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF7ABC: 5547C63E  rlwinm r7, r10, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CF7AC0: 5147442E  rlwimi r7, r10, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7AC4: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF7AC8: F8A1FFE0  std r5, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[5].u64 ) };
	// 82CF7ACC: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7AD0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7AD4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7AD8: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7ADC: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7AE0: D0E80400  stfs f7, 0x400(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7AE4: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7AE8: 548AC63E  rlwinm r10, r4, 0x18, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CF7AEC: 508A442E  rlwimi r10, r4, 8, 0x10, 0x17
	ctx.r[10].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7AF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF7AF4: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF7AF8: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF7AFC: C8C1FFE8  lfd f6, -0x18(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF7B00: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF7B04: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF7B08: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7B0C: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7B10: D0480000  stfs f2, 0(r8)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7B14: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF7B18: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7B1C: 4082FF98  bne 0x82cf7ab4
	if !ctx.cr[0].eq {
	pc = 0x82CF7AB4; continue 'dispatch;
	}
	// 82CF7B20: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7B24: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7B28: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF7B2C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7B30: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF7B34: 0CC70000  twi 6, r7, 0
	// 82CF7B38: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF7B3C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF7B40: 40980008  bge cr6, 0x82cf7b48
	if !ctx.cr[6].lt {
	pc = 0x82CF7B48; continue 'dispatch;
	}
	// 82CF7B44: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF7B48: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7B4C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7B50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7B54: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF7B58: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7B5C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7B60: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7B64: 40980010  bge cr6, 0x82cf7b74
	if !ctx.cr[6].lt {
	pc = 0x82CF7B74; continue 'dispatch;
	}
	// 82CF7B68: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7B6C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7B70: 4E800020  blr
	return;
	// 82CF7B74: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7B78: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7B7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7B80 size=456
    let mut pc: u32 = 0x82CF7B80;
    'dispatch: loop {
        match pc {
            0x82CF7B80 => {
    //   block [0x82CF7B80..0x82CF7D48)
	// 82CF7B80: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7B84: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7B88: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7B8C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7B90: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7B94: 7CA951D6  mullw r5, r9, r10
	ctx.r[5].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CF7B98: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7B9C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7BA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7BA4: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7BA8: 54A9083C  slwi r9, r5, 1
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF7BAC: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7BB0: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82CF7BB4: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF7BB8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF7BBC: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF7BC0: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF7BC4: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF7BC8: 41980008  blt cr6, 0x82cf7bd0
	if ctx.cr[6].lt {
	pc = 0x82CF7BD0; continue 'dispatch;
	}
	// 82CF7BCC: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82CF7BD0: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7BD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF7BD8: 38E7007F  addi r7, r7, 0x7f
	ctx.r[7].s64 = ctx.r[7].s64 + 127;
	// 82CF7BDC: 54E7C9FE  srwi r7, r7, 7
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7BE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF7BE4: 419A0018  beq cr6, 0x82cf7bfc
	if ctx.cr[6].eq {
	pc = 0x82CF7BFC; continue 'dispatch;
	}
	// 82CF7BE8: 55453830  slwi r5, r10, 7
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7BEC: 7C055A2C  dcbt r5, r11
	// 82CF7BF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF7BF4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7BF8: 4198FFF0  blt cr6, 0x82cf7be8
	if ctx.cr[6].lt {
	pc = 0x82CF7BE8; continue 'dispatch;
	}
	// 82CF7BFC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CF7C00: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7C04: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7C08: F941FFD0  std r10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[10].u64 ) };
	// 82CF7C0C: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7C10: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7C14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF7C18: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7C1C: C1AA0C58  lfs f13, 0xc58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7C20: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7C24: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF7C28: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF7C2C: 5547C63E  rlwinm r7, r10, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CF7C30: 5147442E  rlwimi r7, r10, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7C34: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF7C38: F8A1FFD0  std r5, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[5].u64 ) };
	// 82CF7C3C: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7C40: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7C44: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7C48: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7C4C: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7C50: D0E90C00  stfs f7, 0xc00(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF7C54: A08B0004  lhz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7C58: 548AC63E  rlwinm r10, r4, 0x18, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CF7C5C: 508A442E  rlwimi r10, r4, 8, 0x10, 0x17
	ctx.r[10].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7C60: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF7C64: F8C1FFD8  std r6, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[6].u64 ) };
	// 82CF7C68: C8C1FFD8  lfd f6, -0x28(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF7C6C: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF7C70: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF7C74: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7C78: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7C7C: D0490800  stfs f2, 0x800(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF7C80: A0AB0002  lhz r5, 2(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF7C84: 54A4C63E  rlwinm r4, r5, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82CF7C88: 50A4442E  rlwimi r4, r5, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7C8C: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF7C90: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF7C94: C821FFE0  lfd f1, -0x20(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7C98: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 82CF7C9C: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF7CA0: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7CA4: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7CA8: D1090400  stfs f8, 0x400(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7CAC: A0CB0000  lhz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7CB0: 54C5C63E  rlwinm r5, r6, 0x18, 0x18, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CF7CB4: 50C5442E  rlwimi r5, r6, 8, 0x10, 0x17
	ctx.r[5].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7CB8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF7CBC: 7CAA0734  extsh r10, r5
	ctx.r[10].s64 = ctx.r[5].s16 as i64;
	// 82CF7CC0: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 82CF7CC4: C8E1FFE8  lfd f7, -0x18(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF7CC8: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF7CCC: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF7CD0: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7CD4: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7CD8: D0690000  stfs f3, 0(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7CDC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF7CE0: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7CE4: 4082FF40  bne 0x82cf7c24
	if !ctx.cr[0].eq {
	pc = 0x82CF7C24; continue 'dispatch;
	}
	// 82CF7CE8: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7CEC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7CF0: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF7CF4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7CF8: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF7CFC: 0CC70000  twi 6, r7, 0
	// 82CF7D00: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF7D04: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF7D08: 40980008  bge cr6, 0x82cf7d10
	if !ctx.cr[6].lt {
	pc = 0x82CF7D10; continue 'dispatch;
	}
	// 82CF7D0C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF7D10: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7D14: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7D18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF7D1C: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF7D20: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7D24: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7D28: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7D2C: 40980010  bge cr6, 0x82cf7d3c
	if !ctx.cr[6].lt {
	pc = 0x82CF7D3C; continue 'dispatch;
	}
	// 82CF7D30: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7D34: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7D38: 4E800020  blr
	return;
	// 82CF7D3C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7D40: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7D44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7D48 size=548
    let mut pc: u32 = 0x82CF7D48;
    'dispatch: loop {
        match pc {
            0x82CF7D48 => {
    //   block [0x82CF7D48..0x82CF7F6C)
	// 82CF7D48: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7D4C: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7D50: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7D54: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7D58: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7D5C: 7CA741D6  mullw r5, r7, r8
	ctx.r[5].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF7D60: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7D64: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7D68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7D6C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7D70: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7D74: 54C7103A  slwi r7, r6, 2
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7D78: 7D082050  subf r8, r8, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF7D7C: 7CC6F850  subf r6, r6, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82CF7D80: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF7D84: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF7D88: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CF7D8C: 41980008  blt cr6, 0x82cf7d94
	if ctx.cr[6].lt {
	pc = 0x82CF7D94; continue 'dispatch;
	}
	// 82CF7D90: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82CF7D94: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7D98: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF7D9C: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82CF7DA0: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7DA4: 38A7007F  addi r5, r7, 0x7f
	ctx.r[5].s64 = ctx.r[7].s64 + 127;
	// 82CF7DA8: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF7DAC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF7DB0: 419A0018  beq cr6, 0x82cf7dc8
	if ctx.cr[6].eq {
	pc = 0x82CF7DC8; continue 'dispatch;
	}
	// 82CF7DB4: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF7DB8: 7C055A2C  dcbt r5, r11
	// 82CF7DBC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF7DC0: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF7DC4: 4198FFF0  blt cr6, 0x82cf7db4
	if ctx.cr[6].lt {
	pc = 0x82CF7DB4; continue 'dispatch;
	}
	// 82CF7DC8: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CF7DCC: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7DD0: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7DD4: F921FFC0  std r9, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[9].u64 ) };
	// 82CF7DD8: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF7DDC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7DE0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF7DE4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7DE8: C1A90C58  lfs f13, 0xc58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7DEC: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7DF0: A12B000A  lhz r9, 0xa(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 82CF7DF4: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF7DF8: 5527C63E  rlwinm r7, r9, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CF7DFC: 5127442E  rlwimi r7, r9, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7E00: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF7E04: F8A1FFC0  std r5, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[5].u64 ) };
	// 82CF7E08: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF7E0C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7E10: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7E14: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7E18: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7E1C: D0EA1400  stfs f7, 0x1400(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF7E20: A08B0008  lhz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7E24: 5489C63E  rlwinm r9, r4, 0x18, 0x18, 0x1f
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82CF7E28: 5089442E  rlwimi r9, r4, 8, 0x10, 0x17
	ctx.r[9].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7E2C: 7D260734  extsh r6, r9
	ctx.r[6].s64 = ctx.r[9].s16 as i64;
	// 82CF7E30: F8C1FFC8  std r6, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[6].u64 ) };
	// 82CF7E34: C8C1FFC8  lfd f6, -0x38(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CF7E38: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF7E3C: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF7E40: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7E44: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7E48: D04A1000  stfs f2, 0x1000(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF7E4C: A0AB0006  lhz r5, 6(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF7E50: 54A4C63E  rlwinm r4, r5, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82CF7E54: 50A4442E  rlwimi r4, r5, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7E58: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF7E5C: F8E1FFD0  std r7, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[7].u64 ) };
	// 82CF7E60: C821FFD0  lfd f1, -0x30(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF7E64: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 82CF7E68: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF7E6C: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7E70: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7E74: D10A0C00  stfs f8, 0xc00(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF7E78: A0CB0004  lhz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7E7C: 54C5C63E  rlwinm r5, r6, 0x18, 0x18, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CF7E80: 50C5442E  rlwimi r5, r6, 8, 0x10, 0x17
	ctx.r[5].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7E84: 7CA90734  extsh r9, r5
	ctx.r[9].s64 = ctx.r[5].s16 as i64;
	// 82CF7E88: F921FFD8  std r9, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[9].u64 ) };
	// 82CF7E8C: C8E1FFD8  lfd f7, -0x28(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF7E90: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF7E94: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF7E98: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7E9C: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7EA0: D06A0800  stfs f3, 0x800(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF7EA4: A0EB0002  lhz r7, 2(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF7EA8: 54E6C63E  rlwinm r6, r7, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82CF7EAC: 50E6442E  rlwimi r6, r7, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[7].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7EB0: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CF7EB4: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CF7EB8: C841FFE0  lfd f2, -0x20(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7EBC: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF7EC0: FD600818  frsp f11, f1
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF7EC4: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7EC8: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7ECC: D12A0400  stfs f9, 0x400(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF7ED0: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7ED4: 5527C63E  rlwinm r7, r9, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CF7ED8: 5127442E  rlwimi r7, r9, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CF7EDC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82CF7EE0: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CF7EE4: F8A1FFE8  std r5, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[5].u64 ) };
	// 82CF7EE8: C901FFE8  lfd f8, -0x18(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF7EEC: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 82CF7EF0: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82CF7EF4: ECA60372  fmuls f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF7EF8: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF7EFC: D08A0000  stfs f4, 0(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF7F00: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF7F04: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF7F08: 4082FEE8  bne 0x82cf7df0
	if !ctx.cr[0].eq {
	pc = 0x82CF7DF0; continue 'dispatch;
	}
	// 82CF7F0C: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7F10: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7F14: 5527083E  rotlwi r7, r9, 1
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82CF7F18: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7F1C: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF7F20: 0CC70000  twi 6, r7, 0
	// 82CF7F24: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF7F28: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF7F2C: 40980008  bge cr6, 0x82cf7f34
	if !ctx.cr[6].lt {
	pc = 0x82CF7F34; continue 'dispatch;
	}
	// 82CF7F30: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF7F34: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7F38: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF7F3C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7F40: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF7F44: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF7F48: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF7F4C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF7F50: 40980010  bge cr6, 0x82cf7f60
	if !ctx.cr[6].lt {
	pc = 0x82CF7F60; continue 'dispatch;
	}
	// 82CF7F54: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF7F58: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7F5C: 4E800020  blr
	return;
	// 82CF7F60: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF7F64: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF7F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF7F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF7F70 size=400
    let mut pc: u32 = 0x82CF7F70;
    'dispatch: loop {
        match pc {
            0x82CF7F70 => {
    //   block [0x82CF7F70..0x82CF8100)
	// 82CF7F70: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82CF7F74: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF7F78: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF7F7C: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF7F80: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF7F84: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 82CF7F88: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF7F8C: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF7F90: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF7F94: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF7F98: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF7F9C: 7D0429D6  mullw r8, r4, r5
	ctx.r[8].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF7FA0: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF7FA4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF7FA8: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82CF7FAC: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82CF7FB0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF7FB4: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82CF7FB8: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF7FBC: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF7FC0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF7FC4: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF7FC8: 41980008  blt cr6, 0x82cf7fd0
	if ctx.cr[6].lt {
	pc = 0x82CF7FD0; continue 'dispatch;
	}
	// 82CF7FCC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82CF7FD0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF7FD4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7FD8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF7FDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF7FE0: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82CF7FE4: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF7FE8: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF7FEC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF7FF0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF7FF4: C1AA0C4C  lfs f13, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF7FF8: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF7FFC: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8000: 419A0018  beq cr6, 0x82cf8018
	if ctx.cr[6].eq {
	pc = 0x82CF8018; continue 'dispatch;
	}
	// 82CF8004: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82CF8008: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82CF800C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF8010: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF8014: 4082FFF8  bne 0x82cf800c
	if !ctx.cr[0].eq {
	pc = 0x82CF800C; continue 'dispatch;
	}
	// 82CF8018: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF801C: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82CF8020: C18B0BFC  lfs f12, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF8024: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF8028: 419A004C  beq cr6, 0x82cf8074
	if ctx.cr[6].eq {
	pc = 0x82CF8074; continue 'dispatch;
	}
	// 82CF802C: EDAB002A  fadds f13, f11, f0
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8030: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82CF8034: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82CF8038: 7D1F2850  subf r8, r31, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[31].s64;
	// 82CF803C: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82CF8040: 7D285C2E  lfsx f9, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF8044: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF8048: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF804C: ECED0272  fmuls f7, f13, f9
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[9].f64) as f32) as f64);
	// 82CF8050: ECC9402A  fadds f6, f9, f8
	ctx.f[6].f64 = ((ctx.f[9].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF8054: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8058: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF805C: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8060: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8064: D08A0000  stfs f4, 0(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8068: D0EA0004  stfs f7, 4(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF806C: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CF8070: 4082FFD0  bne 0x82cf8040
	if !ctx.cr[0].eq {
	pc = 0x82CF8040; continue 'dispatch;
	}
	// 82CF8074: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF8078: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF807C: 7CBE2A14  add r5, r30, r5
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[5].u64;
	// 82CF8080: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82CF8084: 4082FFA0  bne 0x82cf8024
	if !ctx.cr[0].eq {
	pc = 0x82CF8024; continue 'dispatch;
	}
	// 82CF8088: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF808C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8090: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF8094: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8098: 5548103E  rotlwi r8, r10, 2
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF809C: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF80A0: 0CC80000  twi 6, r8, 0
	// 82CF80A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF80A8: 41980008  blt cr6, 0x82cf80b0
	if ctx.cr[6].lt {
	pc = 0x82CF80B0; continue 'dispatch;
	}
	// 82CF80AC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF80B0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF80B4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF80B8: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF80BC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF80C0: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF80C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF80C8: 40980008  bge cr6, 0x82cf80d0
	if !ctx.cr[6].lt {
	pc = 0x82CF80D0; continue 'dispatch;
	}
	// 82CF80CC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF80D0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF80D4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF80D8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF80DC: 419A0018  beq cr6, 0x82cf80f4
	if ctx.cr[6].eq {
	pc = 0x82CF80F4; continue 'dispatch;
	}
	// 82CF80E0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82CF80E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82CF80E8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF80EC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF80F0: 4082FFF8  bne 0x82cf80e8
	if !ctx.cr[0].eq {
	pc = 0x82CF80E8; continue 'dispatch;
	}
	// 82CF80F4: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF80F8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF80FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8100 size=316
    let mut pc: u32 = 0x82CF8100;
    'dispatch: loop {
        match pc {
            0x82CF8100 => {
    //   block [0x82CF8100..0x82CF823C)
	// 82CF8100: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8104: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8108: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF810C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8110: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8114: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8118: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF811C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8120: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82CF8124: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8128: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF812C: 7CA50E70  srawi r5, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82CF8130: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8134: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82CF8138: 7D450194  addze r10, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CF813C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CF8140: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF8144: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF8148: 41980008  blt cr6, 0x82cf8150
	if ctx.cr[6].lt {
	pc = 0x82CF8150; continue 'dispatch;
	}
	// 82CF814C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF8150: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82CF8154: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8158: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF815C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8160: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CF8164: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8168: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF816C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF8170: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8174: 38AA007F  addi r5, r10, 0x7f
	ctx.r[5].s64 = ctx.r[10].s64 + 127;
	// 82CF8178: C1860C4C  lfs f12, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF817C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF8180: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF8184: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF8188: EDAB4024  fdivs f13, f11, f8
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CF818C: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8190: 419A0018  beq cr6, 0x82cf81a8
	if ctx.cr[6].eq {
	pc = 0x82CF81A8; continue 'dispatch;
	}
	// 82CF8194: 55463830  slwi r6, r10, 7
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8198: 7C065A2C  dcbt r6, r11
	// 82CF819C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF81A0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF81A4: 4198FFF0  blt cr6, 0x82cf8194
	if ctx.cr[6].lt {
	pc = 0x82CF8194; continue 'dispatch;
	}
	// 82CF81A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF81AC: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF81B0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF81B4: ED2D002A  fadds f9, f13, f0
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF81B8: C1030034  lfs f8, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF81BC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF81C0: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF81C4: D1430034  stfs f10, 0x34(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CF81C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF81CC: ECC902B2  fmuls f6, f9, f10
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF81D0: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF81D4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF81D8: EC8502F2  fmuls f4, f5, f11
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF81DC: D0880000  stfs f4, 0(r8)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF81E0: D0C80004  stfs f6, 4(r8)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF81E4: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82CF81E8: 4082FFC8  bne 0x82cf81b0
	if !ctx.cr[0].eq {
	pc = 0x82CF81B0; continue 'dispatch;
	}
	// 82CF81EC: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF81F0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF81F4: 5547103E  rotlwi r7, r10, 2
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82CF81F8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF81FC: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF8200: 0CC70000  twi 6, r7, 0
	// 82CF8204: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF8208: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF820C: 40980008  bge cr6, 0x82cf8214
	if !ctx.cr[6].lt {
	pc = 0x82CF8214; continue 'dispatch;
	}
	// 82CF8210: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF8214: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8218: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF821C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF8220: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF8224: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8228: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF822C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF8230: 4098000C  bge cr6, 0x82cf823c
	if !ctx.cr[6].lt {
		sub_82CF823C(ctx, base);
		return;
	}
	// 82CF8234: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82CF8238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF823C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CF823C size=8
    let mut pc: u32 = 0x82CF823C;
    'dispatch: loop {
        match pc {
            0x82CF823C => {
    //   block [0x82CF823C..0x82CF8244)
	// 82CF823C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF8240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8248 size=404
    let mut pc: u32 = 0x82CF8248;
    'dispatch: loop {
        match pc {
            0x82CF8248 => {
    //   block [0x82CF8248..0x82CF83DC)
	// 82CF8248: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF824C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8250: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8254: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8258: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF825C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8260: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8264: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8268: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF826C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8270: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82CF8274: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8278: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF827C: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF8280: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8284: 7D09F850  subf r8, r9, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 82CF8288: 7D240194  addze r9, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[9].s64 = tmp.s64;
	// 82CF828C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF8290: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF8294: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82CF8298: 41980008  blt cr6, 0x82cf82a0
	if ctx.cr[6].lt {
	pc = 0x82CF82A0; continue 'dispatch;
	}
	// 82CF829C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CF82A0: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82CF82A4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF82A8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF82AC: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF82B0: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CF82B4: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF82B8: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF82BC: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF82C0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF82C4: 3889007F  addi r4, r9, 0x7f
	ctx.r[4].s64 = ctx.r[9].s64 + 127;
	// 82CF82C8: C1A60C4C  lfs f13, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF82CC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF82D0: 5487C9FE  srwi r7, r4, 7
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF82D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF82D8: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF82DC: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF82E0: 419A0018  beq cr6, 0x82cf82f8
	if ctx.cr[6].eq {
	pc = 0x82CF82F8; continue 'dispatch;
	}
	// 82CF82E4: 55263830  slwi r6, r9, 7
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF82E8: 7C065A2C  dcbt r6, r11
	// 82CF82EC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF82F0: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF82F4: 4198FFF0  blt cr6, 0x82cf82e4
	if ctx.cr[6].lt {
	pc = 0x82CF82E4; continue 'dispatch;
	}
	// 82CF82F8: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82CF82FC: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82CF8300: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF8304: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82CF8308: 4082FFF8  bne 0x82cf8300
	if !ctx.cr[0].eq {
	pc = 0x82CF8300; continue 'dispatch;
	}
	// 82CF830C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF8310: C1A90BFC  lfs f13, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8314: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF8318: ED2C002A  fadds f9, f12, f0
	ctx.f[9].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF831C: C1050004  lfs f8, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF8320: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF8324: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF8328: D1450004  stfs f10, 4(r5)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF832C: ECC902B2  fmuls f6, f9, f10
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8330: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8334: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8338: D08A0400  stfs f4, 0x400(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF833C: D0CA0404  stfs f6, 0x404(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8340: C0250000  lfs f1, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CF8344: C06B0000  lfs f3, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF8348: EC4900F2  fmuls f2, f9, f3
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF834C: ED43082A  fadds f10, f3, f1
	ctx.f[10].f64 = ((ctx.f[3].f64 + ctx.f[1].f64) as f32) as f64;
	// 82CF8350: D0650000  stfs f3, 0(r5)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8354: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF8358: ED2A0032  fmuls f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF835C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8360: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8364: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8368: D04A0004  stfs f2, 4(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF836C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CF8370: 4082FFA4  bne 0x82cf8314
	if !ctx.cr[0].eq {
	pc = 0x82CF8314; continue 'dispatch;
	}
	// 82CF8374: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8378: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF837C: 5527103E  rotlwi r7, r9, 2
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 82CF8380: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8384: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF8388: 0CC70000  twi 6, r7, 0
	// 82CF838C: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF8390: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF8394: 40980008  bge cr6, 0x82cf839c
	if !ctx.cr[6].lt {
	pc = 0x82CF839C; continue 'dispatch;
	}
	// 82CF8398: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF839C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF83A0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF83A4: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF83A8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF83AC: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF83B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF83B4: 40980008  bge cr6, 0x82cf83bc
	if !ctx.cr[6].lt {
	pc = 0x82CF83BC; continue 'dispatch;
	}
	// 82CF83B8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF83BC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF83C0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF83C4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82CF83C8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF83CC: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82CF83D0: 4082FFF8  bne 0x82cf83c8
	if !ctx.cr[0].eq {
	pc = 0x82CF83C8; continue 'dispatch;
	}
	// 82CF83D4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF83D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF83E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF83E0 size=476
    let mut pc: u32 = 0x82CF83E0;
    'dispatch: loop {
        match pc {
            0x82CF83E0 => {
    //   block [0x82CF83E0..0x82CF85BC)
	// 82CF83E0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF83E4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF83E8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF83EC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF83F0: 39230034  addi r9, r3, 0x34
	ctx.r[9].s64 = ctx.r[3].s64 + 52;
	// 82CF83F4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF83F8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF83FC: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8400: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8404: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8408: 7D4741D6  mullw r10, r7, r8
	ctx.r[10].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF840C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8410: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8414: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF8418: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CF841C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8420: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF8424: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF8428: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF842C: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF8430: 41980008  blt cr6, 0x82cf8438
	if ctx.cr[6].lt {
	pc = 0x82CF8438; continue 'dispatch;
	}
	// 82CF8434: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82CF8438: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF843C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8440: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8444: 54E82036  slwi r8, r7, 4
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8448: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82CF844C: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8450: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF8454: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CF8458: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF845C: 3888007F  addi r4, r8, 0x7f
	ctx.r[4].s64 = ctx.r[8].s64 + 127;
	// 82CF8460: C1A50C4C  lfs f13, 0xc4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8464: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CF8468: 5486C9FE  srwi r6, r4, 7
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF846C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF8470: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF8474: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8478: 419A0018  beq cr6, 0x82cf8490
	if ctx.cr[6].eq {
	pc = 0x82CF8490; continue 'dispatch;
	}
	// 82CF847C: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF8480: 7C05522C  dcbt r5, r10
	// 82CF8484: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF8488: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF848C: 4198FFF0  blt cr6, 0x82cf847c
	if ctx.cr[6].lt {
	pc = 0x82CF847C; continue 'dispatch;
	}
	// 82CF8490: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 82CF8494: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82CF8498: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF849C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82CF84A0: 4082FFF8  bne 0x82cf8498
	if !ctx.cr[0].eq {
	pc = 0x82CF8498; continue 'dispatch;
	}
	// 82CF84A4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF84A8: C1A80BFC  lfs f13, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF84AC: C14A000C  lfs f10, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF84B0: ED2C002A  fadds f9, f12, f0
	ctx.f[9].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF84B4: C109000C  lfs f8, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF84B8: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF84BC: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF84C0: D149000C  stfs f10, 0xc(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF84C4: ECC902B2  fmuls f6, f9, f10
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF84C8: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF84CC: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF84D0: D08B0C00  stfs f4, 0xc00(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF84D4: D0CB0C04  stfs f6, 0xc04(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF84D8: C06A0008  lfs f3, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF84DC: EC4900F2  fmuls f2, f9, f3
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF84E0: C0290008  lfs f1, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CF84E4: ED43082A  fadds f10, f3, f1
	ctx.f[10].f64 = ((ctx.f[3].f64 + ctx.f[1].f64) as f32) as f64;
	// 82CF84E8: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF84EC: D0690008  stfs f3, 8(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF84F0: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF84F4: D0EB0800  stfs f7, 0x800(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF84F8: D04B0804  stfs f2, 0x804(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF84FC: C0CA0004  lfs f6, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF8500: ECA901B2  fmuls f5, f9, f6
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF8504: C0890004  lfs f4, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF8508: EC66202A  fadds f3, f6, f4
	ctx.f[3].f64 = ((ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CF850C: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8510: D0C90004  stfs f6, 4(r9)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8514: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8518: D02B0400  stfs f1, 0x400(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF851C: D0AB0404  stfs f5, 0x404(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8520: C14A0000  lfs f10, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF8524: ED2902B2  fmuls f9, f9, f10
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8528: C1090000  lfs f8, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF852C: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF8530: ECC70032  fmuls f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8534: D1490000  stfs f10, 0(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8538: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82CF853C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8540: ECA60372  fmuls f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8544: D0AB0000  stfs f5, 0(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8548: D12B0004  stfs f9, 4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF854C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF8550: 4082FF5C  bne 0x82cf84ac
	if !ctx.cr[0].eq {
	pc = 0x82CF84AC; continue 'dispatch;
	}
	// 82CF8554: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8558: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF855C: 5506103E  rotlwi r6, r8, 2
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 82CF8560: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8564: 7CA75050  subf r5, r7, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 82CF8568: 0CC60000  twi 6, r6, 0
	// 82CF856C: 7D453396  divwu r10, r5, r6
	ctx.r[10].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CF8570: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF8574: 40980008  bge cr6, 0x82cf857c
	if !ctx.cr[6].lt {
	pc = 0x82CF857C; continue 'dispatch;
	}
	// 82CF8578: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF857C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8580: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8584: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF8588: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF858C: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF8590: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF8594: 41980008  blt cr6, 0x82cf859c
	if ctx.cr[6].lt {
	pc = 0x82CF859C; continue 'dispatch;
	}
	// 82CF8598: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF859C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF85A0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF85A4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82CF85A8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF85AC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF85B0: 4082FFF8  bne 0x82cf85a8
	if !ctx.cr[0].eq {
	pc = 0x82CF85A8; continue 'dispatch;
	}
	// 82CF85B4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF85B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF85C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF85C0 size=556
    let mut pc: u32 = 0x82CF85C0;
    'dispatch: loop {
        match pc {
            0x82CF85C0 => {
    //   block [0x82CF85C0..0x82CF87EC)
	// 82CF85C0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF85C4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF85C8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF85CC: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF85D0: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 82CF85D4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF85D8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF85DC: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF85E0: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF85E4: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF85E8: 7D2741D6  mullw r9, r7, r8
	ctx.r[9].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF85EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF85F0: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF85F4: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF85F8: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CF85FC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF8600: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF8604: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF8608: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF860C: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF8610: 41980008  blt cr6, 0x82cf8618
	if ctx.cr[6].lt {
	pc = 0x82CF8618; continue 'dispatch;
	}
	// 82CF8614: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82CF8618: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF861C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8620: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8624: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8628: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82CF862C: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8630: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF8634: 7CA74214  add r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF8638: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF863C: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8640: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF8644: 38C8007F  addi r6, r8, 0x7f
	ctx.r[6].s64 = ctx.r[8].s64 + 127;
	// 82CF8648: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CF864C: 54C6C9FE  srwi r6, r6, 7
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8650: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8654: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF8658: ED8C4824  fdivs f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF865C: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8660: 419A0018  beq cr6, 0x82cf8678
	if ctx.cr[6].eq {
	pc = 0x82CF8678; continue 'dispatch;
	}
	// 82CF8664: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF8668: 7C054A2C  dcbt r5, r9
	// 82CF866C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF8670: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF8674: 4198FFF0  blt cr6, 0x82cf8664
	if ctx.cr[6].lt {
	pc = 0x82CF8664; continue 'dispatch;
	}
	// 82CF8678: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF867C: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82CF8680: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF8684: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82CF8688: 4082FFF8  bne 0x82cf8680
	if !ctx.cr[0].eq {
	pc = 0x82CF8680; continue 'dispatch;
	}
	// 82CF868C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF8690: C1A80BFC  lfs f13, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8694: C1490014  lfs f10, 0x14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF8698: ED2C002A  fadds f9, f12, f0
	ctx.f[9].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF869C: C10A0014  lfs f8, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF86A0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF86A4: ECEA402A  fadds f7, f10, f8
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF86A8: D14A0014  stfs f10, 0x14(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82CF86AC: ECC902B2  fmuls f6, f9, f10
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF86B0: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF86B4: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF86B8: D08B1400  stfs f4, 0x1400(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF86BC: D0CB1404  stfs f6, 0x1404(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5124 as u32), tmp.u32 ) };
	// 82CF86C0: C0690010  lfs f3, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF86C4: EC4900F2  fmuls f2, f9, f3
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF86C8: C02A0010  lfs f1, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CF86CC: ED43082A  fadds f10, f3, f1
	ctx.f[10].f64 = ((ctx.f[3].f64 + ctx.f[1].f64) as f32) as f64;
	// 82CF86D0: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF86D4: D06A0010  stfs f3, 0x10(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82CF86D8: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF86DC: D0EB1000  stfs f7, 0x1000(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF86E0: D04B1004  stfs f2, 0x1004(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4100 as u32), tmp.u32 ) };
	// 82CF86E4: C0C9000C  lfs f6, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF86E8: ECA901B2  fmuls f5, f9, f6
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF86EC: C08A000C  lfs f4, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF86F0: EC66202A  fadds f3, f6, f4
	ctx.f[3].f64 = ((ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CF86F4: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF86F8: D0CA000C  stfs f6, 0xc(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF86FC: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8700: D02B0C00  stfs f1, 0xc00(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF8704: D0AB0C04  stfs f5, 0xc04(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF8708: C1490008  lfs f10, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF870C: ED0902B2  fmuls f8, f9, f10
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8710: C0EA0008  lfs f7, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF8714: ECCA382A  fadds f6, f10, f7
	ctx.f[6].f64 = ((ctx.f[10].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF8718: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF871C: D14A0008  stfs f10, 8(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF8720: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8724: D08B0800  stfs f4, 0x800(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF8728: D10B0804  stfs f8, 0x804(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF872C: C0690004  lfs f3, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF8730: EC4900F2  fmuls f2, f9, f3
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF8734: C02A0004  lfs f1, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82CF8738: ED43082A  fadds f10, f3, f1
	ctx.f[10].f64 = ((ctx.f[3].f64 + ctx.f[1].f64) as f32) as f64;
	// 82CF873C: ED0A0032  fmuls f8, f10, f0
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8740: D06A0004  stfs f3, 4(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8744: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8748: D0EB0400  stfs f7, 0x400(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF874C: D04B0404  stfs f2, 0x404(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8750: C0C90000  lfs f6, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF8754: ECA901B2  fmuls f5, f9, f6
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF8758: C08A0000  lfs f4, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF875C: EC66202A  fadds f3, f6, f4
	ctx.f[3].f64 = ((ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CF8760: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8764: D0CA0000  stfs f6, 0(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8768: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82CF876C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8770: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8774: D02B0000  stfs f1, 0(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8778: D0AB0004  stfs f5, 4(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF877C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF8780: 4082FF14  bne 0x82cf8694
	if !ctx.cr[0].eq {
	pc = 0x82CF8694; continue 'dispatch;
	}
	// 82CF8784: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8788: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF878C: 5506103E  rotlwi r6, r8, 2
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 82CF8790: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8794: 7CA74850  subf r5, r7, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82CF8798: 0CC60000  twi 6, r6, 0
	// 82CF879C: 7D253396  divwu r9, r5, r6
	ctx.r[9].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CF87A0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF87A4: 40980008  bge cr6, 0x82cf87ac
	if !ctx.cr[6].lt {
	pc = 0x82CF87AC; continue 'dispatch;
	}
	// 82CF87A8: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CF87AC: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF87B0: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF87B4: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF87B8: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF87BC: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF87C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF87C4: 41980008  blt cr6, 0x82cf87cc
	if ctx.cr[6].lt {
	pc = 0x82CF87CC; continue 'dispatch;
	}
	// 82CF87C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82CF87CC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF87D0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF87D4: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82CF87D8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF87DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF87E0: 4082FFF8  bne 0x82cf87d8
	if !ctx.cr[0].eq {
	pc = 0x82CF87D8; continue 'dispatch;
	}
	// 82CF87E4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF87E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF87F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF87F0 size=528
    let mut pc: u32 = 0x82CF87F0;
    'dispatch: loop {
        match pc {
            0x82CF87F0 => {
    //   block [0x82CF87F0..0x82CF8A00)
	// 82CF87F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF87F4: 4BFB0C19  bl 0x82ca940c
	ctx.lr = 0x82CF87F8;
	sub_82CA93D0(ctx, base);
	// 82CF87F8: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF87FC: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8800: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8804: 3BC30034  addi r30, r3, 0x34
	ctx.r[30].s64 = ctx.r[3].s64 + 52;
	// 82CF8808: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF880C: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8810: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8814: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8818: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF881C: 7D0429D6  mullw r8, r4, r5
	ctx.r[8].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CF8820: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8824: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8828: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82CF882C: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82CF8830: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8834: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82CF8838: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF883C: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CF8840: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF8844: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CF8848: 41980008  blt cr6, 0x82cf8850
	if ctx.cr[6].lt {
	pc = 0x82CF8850; continue 'dispatch;
	}
	// 82CF884C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82CF8850: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF8854: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8858: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF885C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF8860: F961FFD0  std r11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u64 ) };
	// 82CF8864: C941FFD0  lfd f10, -0x30(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8868: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF886C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF8870: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8874: C1AA0C4C  lfs f13, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8878: C1890C58  lfs f12, 0xc58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF887C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF8880: ED4B4024  fdivs f10, f11, f8
	ctx.f[10].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CF8884: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8888: 419A0038  beq cr6, 0x82cf88c0
	if ctx.cr[6].eq {
	pc = 0x82CF88C0; continue 'dispatch;
	}
	// 82CF888C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CF8890: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82CF8894: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8898: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF889C: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 82CF88A0: F921FFD0  std r9, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[9].u64 ) };
	// 82CF88A4: C9A1FFD0  lfd f13, -0x30(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF88A8: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 82CF88AC: FD005818  frsp f8, f11
	ctx.f[8].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CF88B0: ECE80332  fmuls f7, f8, f12
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF88B4: D0EB0000  stfs f7, 0(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF88B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF88BC: 4082FFD8  bne 0x82cf8894
	if !ctx.cr[0].eq {
	pc = 0x82CF8894; continue 'dispatch;
	}
	// 82CF88C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF88C4: 549F083C  slwi r31, r4, 1
	ctx.r[31].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82CF88C8: C16B0BFC  lfs f11, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF88CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF88D0: 419A0068  beq cr6, 0x82cf8938
	if ctx.cr[6].eq {
	pc = 0x82CF8938; continue 'dispatch;
	}
	// 82CF88D4: EDAA002A  fadds f13, f10, f0
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF88D8: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82CF88DC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CF88E0: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82CF88E4: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82CF88E8: A3A80000  lhz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF88EC: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF88F0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF88F4: 7FBD0734  extsh r29, r29
	ctx.r[29].s64 = ctx.r[29].s16 as i64;
	// 82CF88F8: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 82CF88FC: FBA1FFD0  std r29, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[29].u64 ) };
	// 82CF8900: C8E1FFD0  lfd f7, -0x30(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8904: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF8908: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF890C: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8910: D08B0000  stfs f4, 0(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8914: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF8918: EC64402A  fadds f3, f4, f8
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF891C: EC4D0132  fmuls f2, f13, f4
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF8920: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8924: ED0102F2  fmuls f8, f1, f11
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF8928: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF892C: D04A0004  stfs f2, 4(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8930: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CF8934: 4082FFB4  bne 0x82cf88e8
	if !ctx.cr[0].eq {
	pc = 0x82CF88E8; continue 'dispatch;
	}
	// 82CF8938: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF893C: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8940: 7CBF2A14  add r5, r31, r5
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[5].u64;
	// 82CF8944: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82CF8948: 4082FF84  bne 0x82cf88cc
	if !ctx.cr[0].eq {
	pc = 0x82CF88CC; continue 'dispatch;
	}
	// 82CF894C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8950: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8954: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CF8958: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF895C: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF8960: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CF8964: 0CC80000  twi 6, r8, 0
	// 82CF8968: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF896C: 41980008  blt cr6, 0x82cf8974
	if ctx.cr[6].lt {
	pc = 0x82CF8974; continue 'dispatch;
	}
	// 82CF8970: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF8974: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8978: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF897C: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF8980: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8984: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8988: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF898C: 40980008  bge cr6, 0x82cf8994
	if !ctx.cr[6].lt {
	pc = 0x82CF8994; continue 'dispatch;
	}
	// 82CF8990: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF8994: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF8998: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF899C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CF89A0: 419A005C  beq cr6, 0x82cf89fc
	if ctx.cr[6].eq {
	pc = 0x82CF89FC; continue 'dispatch;
	}
	// 82CF89A4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CF89A8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CF89AC: 39007FFF  li r8, 0x7fff
	ctx.r[8].s64 = 32767;
	// 82CF89B0: 3920801E  li r9, -0x7fe2
	ctx.r[9].s64 = -32738;
	// 82CF89B4: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF89B8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF89BC: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF89C0: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF89C4: D961FFD0  stfd f11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[11].u64 ) };
	// 82CF89C8: 8141FFD4  lwz r10, -0x2c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82CF89CC: 2F0A7FFF  cmpwi cr6, r10, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32767, &mut ctx.xer);
	// 82CF89D0: 4198000C  blt cr6, 0x82cf89dc
	if ctx.cr[6].lt {
	pc = 0x82CF89DC; continue 'dispatch;
	}
	// 82CF89D4: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CF89D8: 48000018  b 0x82cf89f0
	pc = 0x82CF89F0; continue 'dispatch;
	// 82CF89DC: 2F0A8000  cmpwi cr6, r10, -0x8000
	ctx.cr[6].compare_i32(ctx.r[10].s32, -32768, &mut ctx.xer);
	// 82CF89E0: 4199000C  bgt cr6, 0x82cf89ec
	if ctx.cr[6].gt {
	pc = 0x82CF89EC; continue 'dispatch;
	}
	// 82CF89E4: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82CF89E8: 48000008  b 0x82cf89f0
	pc = 0x82CF89F0; continue 'dispatch;
	// 82CF89EC: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82CF89F0: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CF89F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF89F8: 4082FFC0  bne 0x82cf89b8
	if !ctx.cr[0].eq {
	pc = 0x82CF89B8; continue 'dispatch;
	}
	// 82CF89FC: 4BFB0A60  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8A00 size=428
    let mut pc: u32 = 0x82CF8A00;
    'dispatch: loop {
        match pc {
            0x82CF8A00 => {
    //   block [0x82CF8A00..0x82CF8BAC)
	// 82CF8A00: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8A04: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8A08: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8A0C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8A10: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8A14: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8A18: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8A1C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8A20: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82CF8A24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8A28: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8A2C: 7CA50E70  srawi r5, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82CF8A30: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8A34: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82CF8A38: 7D450194  addze r10, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CF8A3C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CF8A40: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF8A44: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF8A48: 41980008  blt cr6, 0x82cf8a50
	if ctx.cr[6].lt {
	pc = 0x82CF8A50; continue 'dispatch;
	}
	// 82CF8A4C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF8A50: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82CF8A54: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8A58: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8A5C: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8A60: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CF8A64: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8A68: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF8A6C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF8A70: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8A74: 38AA007F  addi r5, r10, 0x7f
	ctx.r[5].s64 = ctx.r[10].s64 + 127;
	// 82CF8A78: C1860C4C  lfs f12, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF8A7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF8A80: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF8A84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF8A88: EDAB4024  fdivs f13, f11, f8
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CF8A8C: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8A90: 419A0018  beq cr6, 0x82cf8aa8
	if ctx.cr[6].eq {
	pc = 0x82CF8AA8; continue 'dispatch;
	}
	// 82CF8A94: 55463830  slwi r6, r10, 7
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8A98: 7C065A2C  dcbt r6, r11
	// 82CF8A9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF8AA0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF8AA4: 4198FFF0  blt cr6, 0x82cf8a94
	if ctx.cr[6].lt {
	pc = 0x82CF8A94; continue 'dispatch;
	}
	// 82CF8AA8: A1430034  lhz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CF8AAC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82CF8AB0: 7D450734  extsh r5, r10
	ctx.r[5].s64 = ctx.r[10].s16 as i64;
	// 82CF8AB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF8AB8: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 82CF8ABC: C1470C58  lfs f10, 0xc58(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3160 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF8AC0: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8AC4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CF8AC8: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF8ACC: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8AD0: ECE802B2  fmuls f7, f8, f10
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8AD4: D0E30034  stfs f7, 0x34(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CF8AD8: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8ADC: C1230034  lfs f9, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF8AE0: ED0D002A  fadds f8, f13, f0
	ctx.f[8].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8AE4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF8AE8: 7D460734  extsh r6, r10
	ctx.r[6].s64 = ctx.r[10].s16 as i64;
	// 82CF8AEC: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82CF8AF0: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82CF8AF4: C8E1FFF0  lfd f7, -0x10(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF8AF8: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF8AFC: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF8B00: EC8502B2  fmuls f4, f5, f10
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF8B04: D0830034  stfs f4, 0x34(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CF8B08: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CF8B0C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF8B10: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8B14: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8B18: ED2102F2  fmuls f9, f1, f11
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF8B1C: D1280000  stfs f9, 0(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8B20: D0480004  stfs f2, 4(r8)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8B24: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82CF8B28: 4082FFB0  bne 0x82cf8ad8
	if !ctx.cr[0].eq {
	pc = 0x82CF8AD8; continue 'dispatch;
	}
	// 82CF8B2C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8B30: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8B34: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CF8B38: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8B3C: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CF8B40: 0CC70000  twi 6, r7, 0
	// 82CF8B44: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF8B48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF8B4C: 40980008  bge cr6, 0x82cf8b54
	if !ctx.cr[6].lt {
	pc = 0x82CF8B54; continue 'dispatch;
	}
	// 82CF8B50: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF8B54: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8B58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF8B5C: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF8B60: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8B64: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8B68: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF8B6C: 40980008  bge cr6, 0x82cf8b74
	if !ctx.cr[6].lt {
	pc = 0x82CF8B74; continue 'dispatch;
	}
	// 82CF8B70: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF8B74: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CF8B78: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF8B7C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF8B80: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8B84: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8B88: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8B8C: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF8B90: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 82CF8B94: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82CF8B98: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CF8B9C: 41980010  blt cr6, 0x82cf8bac
	if ctx.cr[6].lt {
		sub_82CF8BAC(ctx, base);
		return;
	}
	// 82CF8BA0: 39607FFF  li r11, 0x7fff
	ctx.r[11].s64 = 32767;
	// 82CF8BA4: B1630034  sth r11, 0x34(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u16 ) };
	// 82CF8BA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8BAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CF8BAC size=20
    let mut pc: u32 = 0x82CF8BAC;
    'dispatch: loop {
        match pc {
            0x82CF8BAC => {
    //   block [0x82CF8BAC..0x82CF8BC0)
	// 82CF8BAC: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CF8BB0: 41990008  bgt cr6, 0x82cf8bb8
	if ctx.cr[6].gt {
	pc = 0x82CF8BB8; continue 'dispatch;
	}
	// 82CF8BB4: 3960801E  li r11, -0x7fe2
	ctx.r[11].s64 = -32738;
	// 82CF8BB8: B1630034  sth r11, 0x34(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u16 ) };
	// 82CF8BBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8BC0 size=568
    let mut pc: u32 = 0x82CF8BC0;
    'dispatch: loop {
        match pc {
            0x82CF8BC0 => {
    //   block [0x82CF8BC0..0x82CF8DF8)
	// 82CF8BC0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF8BC4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8BC8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8BCC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8BD0: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF8BD4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8BD8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8BDC: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8BE0: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8BE4: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8BE8: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82CF8BEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8BF0: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8BF4: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF8BF8: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8BFC: 7D09F850  subf r8, r9, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 82CF8C00: 7D240194  addze r9, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[9].s64 = tmp.s64;
	// 82CF8C04: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF8C08: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF8C0C: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82CF8C10: 41980008  blt cr6, 0x82cf8c18
	if ctx.cr[6].lt {
	pc = 0x82CF8C18; continue 'dispatch;
	}
	// 82CF8C14: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CF8C18: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82CF8C1C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8C20: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8C24: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF8C28: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF8C2C: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF8C30: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF8C34: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF8C38: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF8C3C: 3889007F  addi r4, r9, 0x7f
	ctx.r[4].s64 = ctx.r[9].s64 + 127;
	// 82CF8C40: C1A60C4C  lfs f13, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8C44: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CF8C48: 5487C9FE  srwi r7, r4, 7
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF8C4C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF8C50: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF8C54: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8C58: 419A0018  beq cr6, 0x82cf8c70
	if ctx.cr[6].eq {
	pc = 0x82CF8C70; continue 'dispatch;
	}
	// 82CF8C5C: 55263830  slwi r6, r9, 7
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8C60: 7C065A2C  dcbt r6, r11
	// 82CF8C64: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF8C68: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF8C6C: 4198FFF0  blt cr6, 0x82cf8c5c
	if ctx.cr[6].lt {
	pc = 0x82CF8C5C; continue 'dispatch;
	}
	// 82CF8C70: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF8C74: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82CF8C78: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82CF8C7C: C1A60C58  lfs f13, 0xc58(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8C80: A0C90000  lhz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8C84: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF8C88: 7CC60734  extsh r6, r6
	ctx.r[6].s64 = ctx.r[6].s16 as i64;
	// 82CF8C8C: F8C1FFE0  std r6, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u64 ) };
	// 82CF8C90: C981FFE0  lfd f12, -0x20(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF8C94: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CF8C98: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8C9C: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8CA0: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8CA4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF8CA8: 4082FFD8  bne 0x82cf8c80
	if !ctx.cr[0].eq {
	pc = 0x82CF8C80; continue 'dispatch;
	}
	// 82CF8CAC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CF8CB0: C1890BFC  lfs f12, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF8CB4: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF8CB8: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF8CBC: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8CC0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF8CC4: 7D260734  extsh r6, r9
	ctx.r[6].s64 = ctx.r[9].s16 as i64;
	// 82CF8CC8: F8C1FFE0  std r6, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u64 ) };
	// 82CF8CCC: C8E1FFE0  lfd f7, -0x20(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF8CD0: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF8CD4: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF8CD8: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8CDC: D0850004  stfs f4, 4(r5)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8CE0: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CF8CE4: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF8CE8: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8CEC: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8CF0: D12A0400  stfs f9, 0x400(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF8CF4: D04A0404  stfs f2, 0x404(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8CF8: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8CFC: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 82CF8D00: F8E1FFE8  std r7, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[7].u64 ) };
	// 82CF8D04: C8C1FFE8  lfd f6, -0x18(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF8D08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF8D0C: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF8D10: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF8D14: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF8D18: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8D1C: D0650000  stfs f3, 0(r5)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8D20: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF8D24: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8D28: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF8D2C: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8D30: ED090332  fmuls f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8D34: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8D38: D02A0004  stfs f1, 4(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8D3C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CF8D40: 4082FF74  bne 0x82cf8cb4
	if !ctx.cr[0].eq {
	pc = 0x82CF8CB4; continue 'dispatch;
	}
	// 82CF8D44: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8D48: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8D4C: 5527083E  rotlwi r7, r9, 1
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82CF8D50: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8D54: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CF8D58: 0CC70000  twi 6, r7, 0
	// 82CF8D5C: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF8D60: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF8D64: 40980008  bge cr6, 0x82cf8d6c
	if !ctx.cr[6].lt {
	pc = 0x82CF8D6C; continue 'dispatch;
	}
	// 82CF8D68: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CF8D6C: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8D70: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8D74: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF8D78: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CF8D7C: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8D80: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF8D84: 40980008  bge cr6, 0x82cf8d8c
	if !ctx.cr[6].lt {
	pc = 0x82CF8D8C; continue 'dispatch;
	}
	// 82CF8D88: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF8D8C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CF8D90: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF8D94: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF8D98: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82CF8D9C: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82CF8DA0: 38E07FFF  li r7, 0x7fff
	ctx.r[7].s64 = 32767;
	// 82CF8DA4: 3900801E  li r8, -0x7fe2
	ctx.r[8].s64 = -32738;
	// 82CF8DA8: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8DAC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8DB0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8DB4: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF8DB8: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF8DBC: 8141FFEC  lwz r10, -0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF8DC0: 2F0A7FFF  cmpwi cr6, r10, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32767, &mut ctx.xer);
	// 82CF8DC4: 4198000C  blt cr6, 0x82cf8dd0
	if ctx.cr[6].lt {
	pc = 0x82CF8DD0; continue 'dispatch;
	}
	// 82CF8DC8: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CF8DCC: 48000018  b 0x82cf8de4
	pc = 0x82CF8DE4; continue 'dispatch;
	// 82CF8DD0: 2F0A8000  cmpwi cr6, r10, -0x8000
	ctx.cr[6].compare_i32(ctx.r[10].s32, -32768, &mut ctx.xer);
	// 82CF8DD4: 4199000C  bgt cr6, 0x82cf8de0
	if ctx.cr[6].gt {
	pc = 0x82CF8DE0; continue 'dispatch;
	}
	// 82CF8DD8: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CF8DDC: 48000008  b 0x82cf8de4
	pc = 0x82CF8DE4; continue 'dispatch;
	// 82CF8DE0: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82CF8DE4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF8DE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF8DEC: 4082FFC0  bne 0x82cf8dac
	if !ctx.cr[0].eq {
	pc = 0x82CF8DAC; continue 'dispatch;
	}
	// 82CF8DF0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF8DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF8DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF8DF8 size=684
    let mut pc: u32 = 0x82CF8DF8;
    'dispatch: loop {
        match pc {
            0x82CF8DF8 => {
    //   block [0x82CF8DF8..0x82CF90A4)
	// 82CF8DF8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF8DFC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF8E00: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF8E04: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF8E08: 39230034  addi r9, r3, 0x34
	ctx.r[9].s64 = ctx.r[3].s64 + 52;
	// 82CF8E0C: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF8E10: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF8E14: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8E18: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF8E1C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8E20: 7D4741D6  mullw r10, r7, r8
	ctx.r[10].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF8E24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8E28: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF8E2C: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF8E30: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CF8E34: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF8E38: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF8E3C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF8E40: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF8E44: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF8E48: 41980008  blt cr6, 0x82cf8e50
	if ctx.cr[6].lt {
	pc = 0x82CF8E50; continue 'dispatch;
	}
	// 82CF8E4C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82CF8E50: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF8E54: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8E58: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF8E5C: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF8E60: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CF8E64: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8E68: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF8E6C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CF8E70: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF8E74: 3888007F  addi r4, r8, 0x7f
	ctx.r[4].s64 = ctx.r[8].s64 + 127;
	// 82CF8E78: C1A50C4C  lfs f13, 0xc4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8E7C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CF8E80: 5486C9FE  srwi r6, r4, 7
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF8E84: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF8E88: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF8E8C: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8E90: 419A0018  beq cr6, 0x82cf8ea8
	if ctx.cr[6].eq {
	pc = 0x82CF8EA8; continue 'dispatch;
	}
	// 82CF8E94: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF8E98: 7C05522C  dcbt r5, r10
	// 82CF8E9C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF8EA0: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF8EA4: 4198FFF0  blt cr6, 0x82cf8e94
	if ctx.cr[6].lt {
	pc = 0x82CF8E94; continue 'dispatch;
	}
	// 82CF8EA8: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CF8EAC: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CF8EB0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF8EB4: C1A50C58  lfs f13, 0xc58(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF8EB8: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8EBC: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF8EC0: 7CA50734  extsh r5, r5
	ctx.r[5].s64 = ctx.r[5].s16 as i64;
	// 82CF8EC4: F8A1FFD0  std r5, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[5].u64 ) };
	// 82CF8EC8: C981FFD0  lfd f12, -0x30(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8ECC: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CF8ED0: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF8ED4: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8ED8: D0E80000  stfs f7, 0(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8EDC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF8EE0: 4082FFD8  bne 0x82cf8eb8
	if !ctx.cr[0].eq {
	pc = 0x82CF8EB8; continue 'dispatch;
	}
	// 82CF8EE4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF8EE8: C1880BFC  lfs f12, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF8EEC: A10A0006  lhz r8, 6(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF8EF0: C129000C  lfs f9, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF8EF4: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8EF8: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF8EFC: 7D050734  extsh r5, r8
	ctx.r[5].s64 = ctx.r[8].s16 as i64;
	// 82CF8F00: F8A1FFD0  std r5, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[5].u64 ) };
	// 82CF8F04: C8E1FFD0  lfd f7, -0x30(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF8F08: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF8F0C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF8F10: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8F14: D089000C  stfs f4, 0xc(r9)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF8F18: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CF8F1C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF8F20: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8F24: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8F28: D12B0C00  stfs f9, 0xc00(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF8F2C: D04B0C04  stfs f2, 0xc04(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF8F30: A08A0004  lhz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF8F34: 7C860734  extsh r6, r4
	ctx.r[6].s64 = ctx.r[4].s16 as i64;
	// 82CF8F38: F8C1FFD8  std r6, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[6].u64 ) };
	// 82CF8F3C: C8C1FFD8  lfd f6, -0x28(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF8F40: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF8F44: C0E90008  lfs f7, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF8F48: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF8F4C: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8F50: D0690008  stfs f3, 8(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF8F54: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF8F58: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8F5C: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF8F60: ECE90332  fmuls f7, f9, f12
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8F64: D0EB0800  stfs f7, 0x800(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF8F68: D02B0804  stfs f1, 0x804(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF8F6C: A0AA0002  lhz r5, 2(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF8F70: 7CA80734  extsh r8, r5
	ctx.r[8].s64 = ctx.r[5].s16 as i64;
	// 82CF8F74: F901FFE0  std r8, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u64 ) };
	// 82CF8F78: C8A1FFE0  lfd f5, -0x20(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF8F7C: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF8F80: C0C90004  lfs f6, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF8F84: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF8F88: EC430372  fmuls f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8F8C: D0490004  stfs f2, 4(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8F90: EC22302A  fadds f1, f2, f6
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF8F94: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8F98: ED2800B2  fmuls f9, f8, f2
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF8F9C: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8FA0: D0CB0400  stfs f6, 0x400(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF8FA4: D12B0404  stfs f9, 0x404(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF8FA8: A0CA0000  lhz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8FAC: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CF8FB0: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CF8FB4: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF8FB8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CF8FBC: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF8FC0: C0A90000  lfs f5, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CF8FC4: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF8FC8: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF8FCC: D0290000  stfs f1, 0(r9)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8FD0: ED21282A  fadds f9, f1, f5
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 82CF8FD4: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF8FD8: ED080072  fmuls f8, f8, f1
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CF8FDC: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF8FE0: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF8FE4: D0CB0000  stfs f6, 0(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF8FE8: D10B0004  stfs f8, 4(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF8FEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF8FF0: 4082FEFC  bne 0x82cf8eec
	if !ctx.cr[0].eq {
	pc = 0x82CF8EEC; continue 'dispatch;
	}
	// 82CF8FF4: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF8FF8: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF8FFC: 5506083E  rotlwi r6, r8, 1
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82CF9000: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9004: 7CA75050  subf r5, r7, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 82CF9008: 0CC60000  twi 6, r6, 0
	// 82CF900C: 7D453396  divwu r10, r5, r6
	ctx.r[10].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CF9010: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF9014: 40980008  bge cr6, 0x82cf901c
	if !ctx.cr[6].lt {
	pc = 0x82CF901C; continue 'dispatch;
	}
	// 82CF9018: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF901C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9020: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9024: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF9028: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF902C: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF9030: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF9034: 41980008  blt cr6, 0x82cf903c
	if ctx.cr[6].lt {
	pc = 0x82CF903C; continue 'dispatch;
	}
	// 82CF9038: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF903C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9040: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82CF9044: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9048: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF904C: 38E07FFF  li r7, 0x7fff
	ctx.r[7].s64 = 32767;
	// 82CF9050: 3900801E  li r8, -0x7fe2
	ctx.r[8].s64 = -32738;
	// 82CF9054: C00B0F28  lfs f0, 0xf28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9058: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF905C: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9060: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF9064: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF9068: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF906C: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CF9070: 4198000C  blt cr6, 0x82cf907c
	if ctx.cr[6].lt {
	pc = 0x82CF907C; continue 'dispatch;
	}
	// 82CF9074: B0E90000  sth r7, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CF9078: 48000018  b 0x82cf9090
	pc = 0x82CF9090; continue 'dispatch;
	// 82CF907C: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CF9080: 4199000C  bgt cr6, 0x82cf908c
	if ctx.cr[6].gt {
	pc = 0x82CF908C; continue 'dispatch;
	}
	// 82CF9084: B1090000  sth r8, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CF9088: 48000008  b 0x82cf9090
	pc = 0x82CF9090; continue 'dispatch;
	// 82CF908C: B1690000  sth r11, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 82CF9090: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF9094: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF9098: 4082FFC0  bne 0x82cf9058
	if !ctx.cr[0].eq {
	pc = 0x82CF9058; continue 'dispatch;
	}
	// 82CF909C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF90A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF90A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF90A8 size=812
    let mut pc: u32 = 0x82CF90A8;
    'dispatch: loop {
        match pc {
            0x82CF90A8 => {
    //   block [0x82CF90A8..0x82CF93D4)
	// 82CF90A8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF90AC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF90B0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF90B4: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF90B8: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 82CF90BC: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF90C0: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF90C4: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF90C8: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF90CC: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF90D0: 7D2741D6  mullw r9, r7, r8
	ctx.r[9].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF90D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF90D8: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF90DC: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CF90E0: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CF90E4: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CF90E8: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF90EC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF90F0: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF90F4: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF90F8: 41980008  blt cr6, 0x82cf9100
	if ctx.cr[6].lt {
	pc = 0x82CF9100; continue 'dispatch;
	}
	// 82CF90FC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82CF9100: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF9104: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9108: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF910C: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9110: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CF9114: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9118: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF911C: 7CA74214  add r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF9120: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9124: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9128: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF912C: 38C8007F  addi r6, r8, 0x7f
	ctx.r[6].s64 = ctx.r[8].s64 + 127;
	// 82CF9130: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CF9134: 54C6C9FE  srwi r6, r6, 7
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9138: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF913C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF9140: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF9144: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9148: 419A0018  beq cr6, 0x82cf9160
	if ctx.cr[6].eq {
	pc = 0x82CF9160; continue 'dispatch;
	}
	// 82CF914C: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF9150: 7C054A2C  dcbt r5, r9
	// 82CF9154: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF9158: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF915C: 4198FFF0  blt cr6, 0x82cf914c
	if ctx.cr[6].lt {
	pc = 0x82CF914C; continue 'dispatch;
	}
	// 82CF9160: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CF9164: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF9168: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82CF916C: C1A50C58  lfs f13, 0xc58(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9170: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9174: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF9178: 7CA50734  extsh r5, r5
	ctx.r[5].s64 = ctx.r[5].s16 as i64;
	// 82CF917C: F8A1FFC0  std r5, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[5].u64 ) };
	// 82CF9180: C981FFC0  lfd f12, -0x40(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9184: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CF9188: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF918C: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9190: D0E80000  stfs f7, 0(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9194: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF9198: 4082FFD8  bne 0x82cf9170
	if !ctx.cr[0].eq {
	pc = 0x82CF9170; continue 'dispatch;
	}
	// 82CF919C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF91A0: C1880BFC  lfs f12, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF91A4: A109000A  lhz r8, 0xa(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(10 as u32) ) } as u64;
	// 82CF91A8: C12A0014  lfs f9, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CF91AC: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF91B0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF91B4: 7D050734  extsh r5, r8
	ctx.r[5].s64 = ctx.r[8].s16 as i64;
	// 82CF91B8: F8A1FFC0  std r5, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[5].u64 ) };
	// 82CF91BC: C8E1FFC0  lfd f7, -0x40(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF91C0: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CF91C4: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CF91C8: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF91CC: D08A0014  stfs f4, 0x14(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82CF91D0: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CF91D4: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF91D8: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF91DC: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF91E0: D12B1400  stfs f9, 0x1400(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF91E4: D04B1404  stfs f2, 0x1404(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5124 as u32), tmp.u32 ) };
	// 82CF91E8: A0890008  lhz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF91EC: 7C860734  extsh r6, r4
	ctx.r[6].s64 = ctx.r[4].s16 as i64;
	// 82CF91F0: F8C1FFC8  std r6, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[6].u64 ) };
	// 82CF91F4: C8C1FFC8  lfd f6, -0x38(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CF91F8: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF91FC: C0EA0010  lfs f7, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF9200: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF9204: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9208: D06A0010  stfs f3, 0x10(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82CF920C: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF9210: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9214: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF9218: ECE90332  fmuls f7, f9, f12
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF921C: D0EB1000  stfs f7, 0x1000(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF9220: D02B1004  stfs f1, 0x1004(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4100 as u32), tmp.u32 ) };
	// 82CF9224: A0A90006  lhz r5, 6(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CF9228: 7CA80734  extsh r8, r5
	ctx.r[8].s64 = ctx.r[5].s16 as i64;
	// 82CF922C: F901FFD0  std r8, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u64 ) };
	// 82CF9230: C8A1FFD0  lfd f5, -0x30(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9234: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF9238: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF923C: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF9240: EC430372  fmuls f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9244: D04A000C  stfs f2, 0xc(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF9248: EC22302A  fadds f1, f2, f6
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF924C: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9250: ED2800B2  fmuls f9, f8, f2
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9254: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9258: D0CB0C00  stfs f6, 0xc00(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF925C: D12B0C04  stfs f9, 0xc04(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF9260: A0C90004  lhz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9264: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CF9268: F881FFD8  std r4, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[4].u64 ) };
	// 82CF926C: C881FFD8  lfd f4, -0x28(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF9270: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF9274: C0AA0008  lfs f5, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CF9278: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF927C: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9280: D02A0008  stfs f1, 8(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF9284: ED21282A  fadds f9, f1, f5
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 82CF9288: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF928C: ECE80072  fmuls f7, f8, f1
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CF9290: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9294: D0AB0800  stfs f5, 0x800(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF9298: D0EB0804  stfs f7, 0x804(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF929C: A1090002  lhz r8, 2(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF92A0: 7D050734  extsh r5, r8
	ctx.r[5].s64 = ctx.r[8].s16 as i64;
	// 82CF92A4: F8A1FFE0  std r5, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[5].u64 ) };
	// 82CF92A8: C861FFE0  lfd f3, -0x20(r1)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF92AC: FC401E9C  fcfid f2, f3
	ctx.f[2].f64 = (ctx.f[3].s64 as f64);
	// 82CF92B0: C08A0004  lfs f4, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CF92B4: FC201018  frsp f1, f2
	ctx.f[1].f64 = (ctx.f[2].f64 as f32) as f64;
	// 82CF92B8: ED210372  fmuls f9, f1, f13
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF92BC: D12A0004  stfs f9, 4(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF92C0: ECE9202A  fadds f7, f9, f4
	ctx.f[7].f64 = ((ctx.f[9].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CF92C4: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF92C8: ECC80272  fmuls f6, f8, f9
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 82CF92CC: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF92D0: D08B0400  stfs f4, 0x400(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF92D4: D0CB0404  stfs f6, 0x404(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF92D8: A0890000  lhz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF92DC: C06A0000  lfs f3, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF92E0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 82CF92E4: 7C860734  extsh r6, r4
	ctx.r[6].s64 = ctx.r[4].s16 as i64;
	// 82CF92E8: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF92EC: C841FFE8  lfd f2, -0x18(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF92F0: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF92F4: FD200818  frsp f9, f1
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF92F8: ECE90372  fmuls f7, f9, f13
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF92FC: D0EA0000  stfs f7, 0(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9300: ECC7182A  fadds f6, f7, f3
	ctx.f[6].f64 = ((ctx.f[7].f64 + ctx.f[3].f64) as f32) as f64;
	// 82CF9304: ECA801F2  fmuls f5, f8, f7
	ctx.f[5].f64 = (((ctx.f[8].f64 * ctx.f[7].f64) as f32) as f64);
	// 82CF9308: EC860032  fmuls f4, f6, f0
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF930C: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9310: EC640332  fmuls f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9314: D06B0000  stfs f3, 0(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9318: D0AB0004  stfs f5, 4(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF931C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF9320: 4082FE84  bne 0x82cf91a4
	if !ctx.cr[0].eq {
	pc = 0x82CF91A4; continue 'dispatch;
	}
	// 82CF9324: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9328: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF932C: 5506083E  rotlwi r6, r8, 1
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82CF9330: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9334: 7CA74850  subf r5, r7, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82CF9338: 0CC60000  twi 6, r6, 0
	// 82CF933C: 7D253396  divwu r9, r5, r6
	ctx.r[9].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CF9340: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF9344: 40980008  bge cr6, 0x82cf934c
	if !ctx.cr[6].lt {
	pc = 0x82CF934C; continue 'dispatch;
	}
	// 82CF9348: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CF934C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9350: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9354: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF9358: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF935C: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF9360: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF9364: 41980008  blt cr6, 0x82cf936c
	if ctx.cr[6].lt {
	pc = 0x82CF936C; continue 'dispatch;
	}
	// 82CF9368: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82CF936C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9370: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82CF9374: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9378: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82CF937C: 38E07FFF  li r7, 0x7fff
	ctx.r[7].s64 = 32767;
	// 82CF9380: 3900801E  li r8, -0x7fe2
	ctx.r[8].s64 = -32738;
	// 82CF9384: C00B0F28  lfs f0, 0xf28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9388: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF938C: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9390: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF9394: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF9398: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF939C: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CF93A0: 4198000C  blt cr6, 0x82cf93ac
	if ctx.cr[6].lt {
	pc = 0x82CF93AC; continue 'dispatch;
	}
	// 82CF93A4: B0EA0000  sth r7, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CF93A8: 48000018  b 0x82cf93c0
	pc = 0x82CF93C0; continue 'dispatch;
	// 82CF93AC: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CF93B0: 4199000C  bgt cr6, 0x82cf93bc
	if ctx.cr[6].gt {
	pc = 0x82CF93BC; continue 'dispatch;
	}
	// 82CF93B4: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CF93B8: 48000008  b 0x82cf93c0
	pc = 0x82CF93C0; continue 'dispatch;
	// 82CF93BC: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 82CF93C0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF93C4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF93C8: 4082FFC0  bne 0x82cf9388
	if !ctx.cr[0].eq {
	pc = 0x82CF9388; continue 'dispatch;
	}
	// 82CF93CC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF93D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF93D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF93D8 size=532
    let mut pc: u32 = 0x82CF93D8;
    'dispatch: loop {
        match pc {
            0x82CF93D8 => {
    //   block [0x82CF93D8..0x82CF95EC)
	// 82CF93D8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82CF93DC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF93E0: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF93E4: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF93E8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF93EC: 38830034  addi r4, r3, 0x34
	ctx.r[4].s64 = ctx.r[3].s64 + 52;
	// 82CF93F0: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF93F4: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF93F8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF93FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9400: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9404: 7D3E0E70  srawi r30, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82CF9408: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF940C: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82CF9410: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9414: 7CE8F9D6  mullw r7, r8, r31
	ctx.r[7].s64 = (ctx.r[8].s32 as i64) * (ctx.r[31].s32 as i64);
	// 82CF9418: 7D7E0194  addze r11, r30
	tmp.s64 = ctx.r[30].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[30].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82CF941C: 7CC53214  add r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF9420: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82CF9424: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CF9428: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82CF942C: 41980008  blt cr6, 0x82cf9434
	if ctx.cr[6].lt {
	pc = 0x82CF9434; continue 'dispatch;
	}
	// 82CF9430: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82CF9434: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CF9438: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF943C: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9440: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF9444: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82CF9448: C921FFE0  lfd f9, -0x20(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF944C: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82CF9450: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82CF9454: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9458: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF945C: C1AA0C4C  lfs f13, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9460: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF9464: C16967A0  lfs f11, 0x67a0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26528 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF9468: C18B67A4  lfs f12, 0x67a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26532 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF946C: ED2A3824  fdivs f9, f10, f7
	ctx.f[9].f64 = ((ctx.f[10].f64 / ctx.f[7].f64) as f32) as f64;
	// 82CF9470: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9474: 419A0038  beq cr6, 0x82cf94ac
	if ctx.cr[6].eq {
	pc = 0x82CF94AC; continue 'dispatch;
	}
	// 82CF9478: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82CF947C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82CF9480: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9484: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF9488: F921FFE0  std r9, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[9].u64 ) };
	// 82CF948C: C9A1FFE0  lfd f13, -0x20(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF9490: FD406E9C  fcfid f10, f13
	ctx.f[10].f64 = (ctx.f[13].s64 as f64);
	// 82CF9494: FCE05018  frsp f7, f10
	ctx.f[7].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9498: ECC76028  fsubs f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CF949C: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF94A0: D0AB0000  stfs f5, 0(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF94A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF94A8: 4082FFD8  bne 0x82cf9480
	if !ctx.cr[0].eq {
	pc = 0x82CF9480; continue 'dispatch;
	}
	// 82CF94AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CF94B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82CF94B4: C14B0BFC  lfs f10, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF94B8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82CF94BC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF94C0: 419A0060  beq cr6, 0x82cf9520
	if ctx.cr[6].eq {
	pc = 0x82CF9520; continue 'dispatch;
	}
	// 82CF94C4: EDA9002A  fadds f13, f9, f0
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF94C8: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 82CF94CC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82CF94D0: 7FC938AE  lbzx r30, r9, r7
	ctx.r[30].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82CF94D4: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CF94D8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CF94DC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CF94E0: FBC1FFE0  std r30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[30].u64 ) };
	// 82CF94E4: C8C1FFE0  lfd f6, -0x20(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF94E8: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF94EC: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF94F0: EC646028  fsubs f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CF94F4: EC4302F2  fmuls f2, f3, f11
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF94F8: D04B0000  stfs f2, 0(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF94FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF9500: EC22382A  fadds f1, f2, f7
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CF9504: ECED00B2  fmuls f7, f13, f2
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9508: ECC10032  fmuls f6, f1, f0
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF950C: ECA602B2  fmuls f5, f6, f10
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF9510: D0AA0000  stfs f5, 0(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9514: D0EA0004  stfs f7, 4(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9518: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CF951C: 4198FFB4  blt cr6, 0x82cf94d0
	if ctx.cr[6].lt {
	pc = 0x82CF94D0; continue 'dispatch;
	}
	// 82CF9520: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82CF9524: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9528: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF952C: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 82CF9530: 4082FF88  bne 0x82cf94b8
	if !ctx.cr[0].eq {
	pc = 0x82CF94B8; continue 'dispatch;
	}
	// 82CF9534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9538: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF953C: 7D2B3850  subf r9, r11, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CF9540: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9544: 0CCA0000  twi 6, r10, 0
	// 82CF9548: 7D495396  divwu r10, r9, r10
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[10].u32;
	// 82CF954C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9550: 41980008  blt cr6, 0x82cf9558
	if ctx.cr[6].lt {
	pc = 0x82CF9558; continue 'dispatch;
	}
	// 82CF9554: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF9558: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF955C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF9560: 7D4B3050  subf r10, r11, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 82CF9564: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9568: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF956C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9570: 40980008  bge cr6, 0x82cf9578
	if !ctx.cr[6].lt {
	pc = 0x82CF9578; continue 'dispatch;
	}
	// 82CF9574: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF9578: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF957C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9580: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CF9584: 419A005C  beq cr6, 0x82cf95e0
	if ctx.cr[6].eq {
	pc = 0x82CF95E0; continue 'dispatch;
	}
	// 82CF9588: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF958C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82CF9590: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 82CF9594: C00A67A8  lfs f0, 0x67a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9598: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF959C: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF95A0: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF95A4: D961FFE0  stfd f11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[11].u64 ) };
	// 82CF95A8: 8141FFE4  lwz r10, -0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) } as u64;
	// 82CF95AC: 214A0080  subfic r10, r10, 0x80
	ctx.xer.ca = ctx.r[10].u32 <= 128 as u32;
	ctx.r[10].s64 = (128 as i64) - ctx.r[10].s64;
	// 82CF95B0: 2F0A00FF  cmpwi cr6, r10, 0xff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 255, &mut ctx.xer);
	// 82CF95B4: 4198000C  blt cr6, 0x82cf95c0
	if ctx.cr[6].lt {
	pc = 0x82CF95C0; continue 'dispatch;
	}
	// 82CF95B8: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82CF95BC: 48000018  b 0x82cf95d4
	pc = 0x82CF95D4; continue 'dispatch;
	// 82CF95C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF95C4: 4199000C  bgt cr6, 0x82cf95d0
	if ctx.cr[6].gt {
	pc = 0x82CF95D0; continue 'dispatch;
	}
	// 82CF95C8: 9BEB0000  stb r31, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82CF95CC: 48000008  b 0x82cf95d4
	pc = 0x82CF95D4; continue 'dispatch;
	// 82CF95D0: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82CF95D4: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF95D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF95DC: 4082FFBC  bne 0x82cf9598
	if !ctx.cr[0].eq {
	pc = 0x82CF9598; continue 'dispatch;
	}
	// 82CF95E0: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF95E4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF95E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF95F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF95F0 size=428
    let mut pc: u32 = 0x82CF95F0;
    'dispatch: loop {
        match pc {
            0x82CF95F0 => {
    //   block [0x82CF95F0..0x82CF979C)
	// 82CF95F0: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF95F4: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF95F8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF95FC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF9600: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9604: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF9608: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF960C: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9610: 7D040E70  srawi r4, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 82CF9614: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9618: 7D0749D6  mullw r8, r7, r9
	ctx.r[8].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82CF961C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9620: 7D292850  subf r9, r9, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 82CF9624: 7D440194  addze r10, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CF9628: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CF962C: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF9630: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF9634: 41980008  blt cr6, 0x82cf963c
	if ctx.cr[6].lt {
	pc = 0x82CF963C; continue 'dispatch;
	}
	// 82CF9638: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CF963C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82CF9640: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9644: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9648: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CF964C: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82CF9650: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF9654: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CF9658: 38A9007F  addi r5, r9, 0x7f
	ctx.r[5].s64 = ctx.r[9].s64 + 127;
	// 82CF965C: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CF9660: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF9664: C1860C4C  lfs f12, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF9668: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CF966C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF9670: EDAB4024  fdivs f13, f11, f8
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CF9674: ED2D0332  fmuls f9, f13, f12
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9678: 419A0018  beq cr6, 0x82cf9690
	if ctx.cr[6].eq {
	pc = 0x82CF9690; continue 'dispatch;
	}
	// 82CF967C: 55463830  slwi r6, r10, 7
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9680: 7C065A2C  dcbt r6, r11
	// 82CF9684: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF9688: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF968C: 4198FFF0  blt cr6, 0x82cf967c
	if ctx.cr[6].lt {
	pc = 0x82CF967C; continue 'dispatch;
	}
	// 82CF9690: 88A30034  lbz r5, 0x34(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CF9694: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82CF9698: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82CF969C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF96A0: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 82CF96A4: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF96A8: FD00569C  fcfid f8, f10
	ctx.f[8].f64 = (ctx.f[10].s64 as f64);
	// 82CF96AC: C18767A4  lfs f12, 0x67a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26532 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF96B0: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF96B4: C16667A0  lfs f11, 0x67a0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(26528 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF96B8: C14A0BFC  lfs f10, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CF96BC: ECC76028  fsubs f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CF96C0: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF96C4: D0A30034  stfs f5, 0x34(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CF96C8: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF96CC: C1030034  lfs f8, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF96D0: ECED002A  fadds f7, f13, f0
	ctx.f[7].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF96D4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF96D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CF96DC: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CF96E0: C8C1FFF0  lfd f6, -0x10(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CF96E4: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF96E8: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF96EC: EC646028  fsubs f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[12].f64) as f32) as f64);
	// 82CF96F0: EC4302F2  fmuls f2, f3, f11
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF96F4: D0430034  stfs f2, 0x34(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CF96F8: EC22402A  fadds f1, f2, f8
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF96FC: ED0700B2  fmuls f8, f7, f2
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9700: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9704: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9708: ECC702B2  fmuls f6, f7, f10
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CF970C: D0C80000  stfs f6, 0(r8)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9710: D1080004  stfs f8, 4(r8)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9714: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82CF9718: 4082FFB0  bne 0x82cf96c8
	if !ctx.cr[0].eq {
	pc = 0x82CF96C8; continue 'dispatch;
	}
	// 82CF971C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9720: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9724: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF9728: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF972C: 0CC90000  twi 6, r9, 0
	// 82CF9730: 7D474B96  divwu r10, r7, r9
	ctx.r[10].u32 = ctx.r[7].u32 / ctx.r[9].u32;
	// 82CF9734: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9738: 41980008  blt cr6, 0x82cf9740
	if ctx.cr[6].lt {
	pc = 0x82CF9740; continue 'dispatch;
	}
	// 82CF973C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF9740: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9744: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF9748: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CF974C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9750: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF9754: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9758: 40980008  bge cr6, 0x82cf9760
	if !ctx.cr[6].lt {
	pc = 0x82CF9760; continue 'dispatch;
	}
	// 82CF975C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF9760: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9764: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF9768: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF976C: C00A67A8  lfs f0, 0x67a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9770: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9774: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9778: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF977C: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 82CF9780: 8121FFF4  lwz r9, -0xc(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82CF9784: 21690080  subfic r11, r9, 0x80
	ctx.xer.ca = ctx.r[9].u32 <= 128 as u32;
	ctx.r[11].s64 = (128 as i64) - ctx.r[9].s64;
	// 82CF9788: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82CF978C: 41980010  blt cr6, 0x82cf979c
	if ctx.cr[6].lt {
		sub_82CF979C(ctx, base);
		return;
	}
	// 82CF9790: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82CF9794: 99630034  stb r11, 0x34(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82CF9798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF979C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CF979C size=20
    let mut pc: u32 = 0x82CF979C;
    'dispatch: loop {
        match pc {
            0x82CF979C => {
    //   block [0x82CF979C..0x82CF97B0)
	// 82CF979C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF97A0: 41990008  bgt cr6, 0x82cf97a8
	if ctx.cr[6].gt {
	pc = 0x82CF97A8; continue 'dispatch;
	}
	// 82CF97A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CF97A8: 99630034  stb r11, 0x34(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82CF97AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF97B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF97B0 size=572
    let mut pc: u32 = 0x82CF97B0;
    'dispatch: loop {
        match pc {
            0x82CF97B0 => {
    //   block [0x82CF97B0..0x82CF99EC)
	// 82CF97B0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF97B4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF97B8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF97BC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF97C0: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CF97C4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF97C8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF97CC: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF97D0: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF97D4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF97D8: 7CFF0E70  srawi r31, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 82CF97DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF97E0: 7D2441D6  mullw r9, r4, r8
	ctx.r[9].s64 = (ctx.r[4].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF97E4: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF97E8: 7D085050  subf r8, r8, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF97EC: 7D5F0194  addze r10, r31
	tmp.s64 = ctx.r[31].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[31].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CF97F0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF97F4: 7D263A14  add r9, r6, r7
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CF97F8: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CF97FC: 41980008  blt cr6, 0x82cf9804
	if ctx.cr[6].lt {
	pc = 0x82CF9804; continue 'dispatch;
	}
	// 82CF9800: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF9804: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82CF9808: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF980C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9810: 550A083C  slwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF9814: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF9818: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF981C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF9820: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF9824: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9828: 394A007F  addi r10, r10, 0x7f
	ctx.r[10].s64 = ctx.r[10].s64 + 127;
	// 82CF982C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82CF9830: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9834: 5547C9FE  srwi r7, r10, 7
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CF9838: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 82CF983C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CF9840: ED4C4824  fdivs f10, f12, f9
	ctx.f[10].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF9844: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9848: 419A0018  beq cr6, 0x82cf9860
	if ctx.cr[6].eq {
	pc = 0x82CF9860; continue 'dispatch;
	}
	// 82CF984C: 55443830  slwi r4, r10, 7
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF9850: 7C045A2C  dcbt r4, r11
	// 82CF9854: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CF9858: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CF985C: 4198FFF0  blt cr6, 0x82cf984c
	if ctx.cr[6].lt {
	pc = 0x82CF984C; continue 'dispatch;
	}
	// 82CF9860: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CF9864: 3FE08201  lis r31, -0x7dff
	ctx.r[31].s64 = -2113863680;
	// 82CF9868: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 82CF986C: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82CF9870: C18467A0  lfs f12, 0x67a0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF9874: C1BF67A4  lfs f13, 0x67a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9878: 888A0000  lbz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF987C: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF9880: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CF9884: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF9888: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 82CF988C: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9890: ECC76828  fsubs f6, f7, f13
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9894: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9898: D0AA0000  stfs f5, 0(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF989C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF98A0: 4082FFD8  bne 0x82cf9878
	if !ctx.cr[0].eq {
	pc = 0x82CF9878; continue 'dispatch;
	}
	// 82CF98A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CF98A8: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF98AC: 88EB0001  lbz r7, 1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF98B0: C1050004  lfs f8, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF98B4: ECEA002A  fadds f7, f10, f0
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF98B8: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CF98BC: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CF98C0: C8C1FFE0  lfd f6, -0x20(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF98C4: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF98C8: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF98CC: EC646828  fsubs f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF98D0: EC430332  fmuls f2, f3, f12
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF98D4: D0450004  stfs f2, 4(r5)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF98D8: EC22402A  fadds f1, f2, f8
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF98DC: ED0700B2  fmuls f8, f7, f2
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF98E0: ECC10032  fmuls f6, f1, f0
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF98E4: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF98E8: D0A90400  stfs f5, 0x400(r9)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF98EC: D1090404  stfs f8, 0x404(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF98F0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF98F4: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 82CF98F8: C0450000  lfs f2, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CF98FC: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF9900: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82CF9904: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF9908: FC201818  frsp f1, f3
	ctx.f[1].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF990C: ED016828  fsubs f8, f1, f13
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9910: ECC80332  fmuls f6, f8, f12
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9914: D0C50000  stfs f6, 0(r5)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9918: ECA6102A  fadds f5, f6, f2
	ctx.f[5].f64 = ((ctx.f[6].f64 + ctx.f[2].f64) as f32) as f64;
	// 82CF991C: EC6701B2  fmuls f3, f7, f6
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF9920: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9924: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9928: EC4402F2  fmuls f2, f4, f11
	ctx.f[2].f64 = (((ctx.f[4].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF992C: D0490000  stfs f2, 0(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9930: D0690004  stfs f3, 4(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9934: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82CF9938: 4082FF74  bne 0x82cf98ac
	if !ctx.cr[0].eq {
	pc = 0x82CF98AC; continue 'dispatch;
	}
	// 82CF993C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9940: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9944: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82CF9948: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF994C: 0CC80000  twi 6, r8, 0
	// 82CF9950: 7D474396  divwu r10, r7, r8
	ctx.r[10].u32 = ctx.r[7].u32 / ctx.r[8].u32;
	// 82CF9954: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9958: 41980008  blt cr6, 0x82cf9960
	if ctx.cr[6].lt {
	pc = 0x82CF9960; continue 'dispatch;
	}
	// 82CF995C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CF9960: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9964: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CF9968: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF996C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9970: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CF9974: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CF9978: 40980008  bge cr6, 0x82cf9980
	if !ctx.cr[6].lt {
	pc = 0x82CF9980; continue 'dispatch;
	}
	// 82CF997C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF9980: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CF9984: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9988: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF998C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82CF9990: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82CF9994: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 82CF9998: C00A67A8  lfs f0, 0x67a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF999C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF99A0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF99A4: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF99A8: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF99AC: 8141FFEC  lwz r10, -0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF99B0: 214A0080  subfic r10, r10, 0x80
	ctx.xer.ca = ctx.r[10].u32 <= 128 as u32;
	ctx.r[10].s64 = (128 as i64) - ctx.r[10].s64;
	// 82CF99B4: 2F0A00FF  cmpwi cr6, r10, 0xff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 255, &mut ctx.xer);
	// 82CF99B8: 4198000C  blt cr6, 0x82cf99c4
	if ctx.cr[6].lt {
	pc = 0x82CF99C4; continue 'dispatch;
	}
	// 82CF99BC: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82CF99C0: 48000018  b 0x82cf99d8
	pc = 0x82CF99D8; continue 'dispatch;
	// 82CF99C4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF99C8: 4199000C  bgt cr6, 0x82cf99d4
	if ctx.cr[6].gt {
	pc = 0x82CF99D4; continue 'dispatch;
	}
	// 82CF99CC: 98CB0000  stb r6, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 82CF99D0: 48000008  b 0x82cf99d8
	pc = 0x82CF99D8; continue 'dispatch;
	// 82CF99D4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82CF99D8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF99DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CF99E0: 4082FFBC  bne 0x82cf999c
	if !ctx.cr[0].eq {
	pc = 0x82CF999C; continue 'dispatch;
	}
	// 82CF99E4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF99E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF99F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF99F0 size=688
    let mut pc: u32 = 0x82CF99F0;
    'dispatch: loop {
        match pc {
            0x82CF99F0 => {
    //   block [0x82CF99F0..0x82CF9CA0)
	// 82CF99F0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF99F4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF99F8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF99FC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9A00: 39230034  addi r9, r3, 0x34
	ctx.r[9].s64 = ctx.r[3].s64 + 52;
	// 82CF9A04: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF9A08: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF9A0C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF9A10: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9A14: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9A18: 7CFF0E70  srawi r31, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 82CF9A1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9A20: 7D4641D6  mullw r10, r6, r8
	ctx.r[10].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF9A24: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9A28: 7CE82050  subf r7, r8, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF9A2C: 7D1F0194  addze r8, r31
	tmp.s64 = ctx.r[31].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[31].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF9A30: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CF9A34: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF9A38: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF9A3C: 41980008  blt cr6, 0x82cf9a44
	if ctx.cr[6].lt {
	pc = 0x82CF9A44; continue 'dispatch;
	}
	// 82CF9A40: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82CF9A44: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF9A48: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9A4C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9A50: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9A54: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CF9A58: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9A5C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF9A60: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF9A64: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9A68: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF9A6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CF9A70: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9A74: 5506C9FE  srwi r6, r8, 7
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9A78: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82CF9A7C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF9A80: ED4C4824  fdivs f10, f12, f9
	ctx.f[10].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF9A84: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9A88: 419A0018  beq cr6, 0x82cf9aa0
	if ctx.cr[6].eq {
	pc = 0x82CF9AA0; continue 'dispatch;
	}
	// 82CF9A8C: 55043830  slwi r4, r8, 7
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF9A90: 7C04522C  dcbt r4, r10
	// 82CF9A94: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF9A98: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF9A9C: 4198FFF0  blt cr6, 0x82cf9a8c
	if ctx.cr[6].lt {
	pc = 0x82CF9A8C; continue 'dispatch;
	}
	// 82CF9AA0: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CF9AA4: 3FE08201  lis r31, -0x7dff
	ctx.r[31].s64 = -2113863680;
	// 82CF9AA8: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CF9AAC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CF9AB0: C18467A0  lfs f12, 0x67a0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF9AB4: C1BF67A4  lfs f13, 0x67a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9AB8: 88880000  lbz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9ABC: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF9AC0: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CF9AC4: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9AC8: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 82CF9ACC: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9AD0: ECC76828  fsubs f6, f7, f13
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9AD4: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9AD8: D0A80000  stfs f5, 0(r8)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9ADC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF9AE0: 4082FFD8  bne 0x82cf9ab8
	if !ctx.cr[0].eq {
	pc = 0x82CF9AB8; continue 'dispatch;
	}
	// 82CF9AE4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF9AE8: C1680BFC  lfs f11, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF9AEC: 88CA0003  lbz r6, 3(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 82CF9AF0: C109000C  lfs f8, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF9AF4: ECEA002A  fadds f7, f10, f0
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9AF8: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF9AFC: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CF9B00: C8C1FFD0  lfd f6, -0x30(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9B04: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF9B08: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF9B0C: EC646828  fsubs f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9B10: EC430332  fmuls f2, f3, f12
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9B14: D049000C  stfs f2, 0xc(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF9B18: EC22402A  fadds f1, f2, f8
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF9B1C: ED0700B2  fmuls f8, f7, f2
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9B20: ECC10032  fmuls f6, f1, f0
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9B24: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9B28: D0AB0C00  stfs f5, 0xc00(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF9B2C: D10B0C04  stfs f8, 0xc04(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF9B30: 890A0002  lbz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF9B34: F901FFD8  std r8, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[8].u64 ) };
	// 82CF9B38: C0490008  lfs f2, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CF9B3C: C881FFD8  lfd f4, -0x28(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF9B40: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF9B44: FC201818  frsp f1, f3
	ctx.f[1].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF9B48: ED016828  fsubs f8, f1, f13
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9B4C: ECC80332  fmuls f6, f8, f12
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9B50: D0C90008  stfs f6, 8(r9)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF9B54: ECA6102A  fadds f5, f6, f2
	ctx.f[5].f64 = ((ctx.f[6].f64 + ctx.f[2].f64) as f32) as f64;
	// 82CF9B58: EC6701B2  fmuls f3, f7, f6
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF9B5C: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9B60: EC4402F2  fmuls f2, f4, f11
	ctx.f[2].f64 = (((ctx.f[4].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9B64: D04B0800  stfs f2, 0x800(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF9B68: D06B0804  stfs f3, 0x804(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF9B6C: 888A0001  lbz r4, 1(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF9B70: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CF9B74: C0C90004  lfs f6, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF9B78: C821FFE0  lfd f1, -0x20(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF9B7C: FD000E9C  fcfid f8, f1
	ctx.f[8].f64 = (ctx.f[1].s64 as f64);
	// 82CF9B80: FCA04018  frsp f5, f8
	ctx.f[5].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9B84: EC856828  fsubs f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9B88: EC640332  fmuls f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9B8C: D0690004  stfs f3, 4(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9B90: EC43302A  fadds f2, f3, f6
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF9B94: ED0700F2  fmuls f8, f7, f3
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF9B98: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9B9C: ECC102F2  fmuls f6, f1, f11
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9BA0: D0CB0400  stfs f6, 0x400(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF9BA4: D10B0404  stfs f8, 0x404(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF9BA8: 88CA0000  lbz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9BAC: F8C1FFE8  std r6, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[6].u64 ) };
	// 82CF9BB0: C0690000  lfs f3, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF9BB4: C8A1FFE8  lfd f5, -0x18(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF9BB8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF9BBC: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF9BC0: FC402018  frsp f2, f4
	ctx.f[2].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF9BC4: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9BC8: ED010332  fmuls f8, f1, f12
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9BCC: D1090000  stfs f8, 0(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9BD0: ECC8182A  fadds f6, f8, f3
	ctx.f[6].f64 = ((ctx.f[8].f64 + ctx.f[3].f64) as f32) as f64;
	// 82CF9BD4: EC870232  fmuls f4, f7, f8
	ctx.f[4].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82CF9BD8: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9BDC: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9BE0: EC6502F2  fmuls f3, f5, f11
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9BE4: D06B0000  stfs f3, 0(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9BE8: D08B0004  stfs f4, 4(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9BEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF9BF0: 4082FEFC  bne 0x82cf9aec
	if !ctx.cr[0].eq {
	pc = 0x82CF9AEC; continue 'dispatch;
	}
	// 82CF9BF4: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9BF8: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9BFC: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CF9C00: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9C04: 0CC70000  twi 6, r7, 0
	// 82CF9C08: 7D063B96  divwu r8, r6, r7
	ctx.r[8].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF9C0C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF9C10: 41980008  blt cr6, 0x82cf9c18
	if ctx.cr[6].lt {
	pc = 0x82CF9C18; continue 'dispatch;
	}
	// 82CF9C14: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF9C18: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9C1C: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9C20: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF9C24: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF9C28: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF9C2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CF9C30: 41980008  blt cr6, 0x82cf9c38
	if ctx.cr[6].lt {
	pc = 0x82CF9C38; continue 'dispatch;
	}
	// 82CF9C34: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CF9C38: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9C3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF9C40: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9C44: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CF9C48: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 82CF9C4C: C00B67A8  lfs f0, 0x67a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9C50: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9C54: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9C58: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF9C5C: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF9C60: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF9C64: 216B0080  subfic r11, r11, 0x80
	ctx.xer.ca = ctx.r[11].u32 <= 128 as u32;
	ctx.r[11].s64 = (128 as i64) - ctx.r[11].s64;
	// 82CF9C68: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82CF9C6C: 4198000C  blt cr6, 0x82cf9c78
	if ctx.cr[6].lt {
	pc = 0x82CF9C78; continue 'dispatch;
	}
	// 82CF9C70: 99090000  stb r8, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82CF9C74: 48000018  b 0x82cf9c8c
	pc = 0x82CF9C8C; continue 'dispatch;
	// 82CF9C78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF9C7C: 4199000C  bgt cr6, 0x82cf9c88
	if ctx.cr[6].gt {
	pc = 0x82CF9C88; continue 'dispatch;
	}
	// 82CF9C80: 98A90000  stb r5, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82CF9C84: 48000008  b 0x82cf9c8c
	pc = 0x82CF9C8C; continue 'dispatch;
	// 82CF9C88: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82CF9C8C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CF9C90: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CF9C94: 4082FFBC  bne 0x82cf9c50
	if !ctx.cr[0].eq {
	pc = 0x82CF9C50; continue 'dispatch;
	}
	// 82CF9C98: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF9C9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF9CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF9CA0 size=816
    let mut pc: u32 = 0x82CF9CA0;
    'dispatch: loop {
        match pc {
            0x82CF9CA0 => {
    //   block [0x82CF9CA0..0x82CF9FD0)
	// 82CF9CA0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CF9CA4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF9CA8: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9CAC: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9CB0: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 82CF9CB4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF9CB8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CF9CBC: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CF9CC0: 88C3000D  lbz r6, 0xd(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9CC4: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9CC8: 7CFF0E70  srawi r31, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 82CF9CCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9CD0: 7D2641D6  mullw r9, r6, r8
	ctx.r[9].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CF9CD4: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9CD8: 7CE82050  subf r7, r8, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82CF9CDC: 7D1F0194  addze r8, r31
	tmp.s64 = ctx.r[31].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[31].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CF9CE0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CF9CE4: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CF9CE8: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CF9CEC: 41980008  blt cr6, 0x82cf9cf4
	if ctx.cr[6].lt {
	pc = 0x82CF9CF4; continue 'dispatch;
	}
	// 82CF9CF0: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82CF9CF4: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CF9CF8: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9CFC: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CF9D00: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9D04: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CF9D08: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9D0C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CF9D10: 7CA74214  add r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CF9D14: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CF9D18: 54A8083C  slwi r8, r5, 1
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CF9D1C: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CF9D20: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CF9D24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82CF9D28: 5506C9FE  srwi r6, r8, 7
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9D2C: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82CF9D30: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9D34: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CF9D38: ED4C4824  fdivs f10, f12, f9
	ctx.f[10].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CF9D3C: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CF9D40: 419A0018  beq cr6, 0x82cf9d58
	if ctx.cr[6].eq {
	pc = 0x82CF9D58; continue 'dispatch;
	}
	// 82CF9D44: 55043830  slwi r4, r8, 7
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82CF9D48: 7C044A2C  dcbt r4, r9
	// 82CF9D4C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CF9D50: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CF9D54: 4198FFF0  blt cr6, 0x82cf9d44
	if ctx.cr[6].lt {
	pc = 0x82CF9D44; continue 'dispatch;
	}
	// 82CF9D58: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82CF9D5C: 3FE08201  lis r31, -0x7dff
	ctx.r[31].s64 = -2113863680;
	// 82CF9D60: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CF9D64: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82CF9D68: C18467A0  lfs f12, 0x67a0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(26528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CF9D6C: C1BF67A4  lfs f13, 0x67a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(26532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9D70: 88880000  lbz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9D74: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CF9D78: F881FFC0  std r4, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[4].u64 ) };
	// 82CF9D7C: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9D80: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 82CF9D84: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9D88: ECC76828  fsubs f6, f7, f13
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9D8C: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9D90: D0A80000  stfs f5, 0(r8)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9D94: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CF9D98: 4082FFD8  bne 0x82cf9d70
	if !ctx.cr[0].eq {
	pc = 0x82CF9D70; continue 'dispatch;
	}
	// 82CF9D9C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CF9DA0: C1680BFC  lfs f11, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CF9DA4: 88C90005  lbz r6, 5(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(5 as u32) ) } as u64;
	// 82CF9DA8: C10A0014  lfs f8, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF9DAC: ECEA002A  fadds f7, f10, f0
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9DB0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CF9DB4: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CF9DB8: C8C1FFC0  lfd f6, -0x40(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CF9DBC: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CF9DC0: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CF9DC4: EC646828  fsubs f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9DC8: EC430332  fmuls f2, f3, f12
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9DCC: D04A0014  stfs f2, 0x14(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82CF9DD0: EC22402A  fadds f1, f2, f8
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF9DD4: ED0700B2  fmuls f8, f7, f2
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CF9DD8: ECC10032  fmuls f6, f1, f0
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9DDC: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9DE0: D0AB1400  stfs f5, 0x1400(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CF9DE4: D10B1404  stfs f8, 0x1404(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5124 as u32), tmp.u32 ) };
	// 82CF9DE8: 89090004  lbz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9DEC: F901FFC8  std r8, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[8].u64 ) };
	// 82CF9DF0: C04A0010  lfs f2, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82CF9DF4: C881FFC8  lfd f4, -0x38(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CF9DF8: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CF9DFC: FC201818  frsp f1, f3
	ctx.f[1].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CF9E00: ED016828  fsubs f8, f1, f13
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9E04: ECC80332  fmuls f6, f8, f12
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9E08: D0CA0010  stfs f6, 0x10(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82CF9E0C: ECA6102A  fadds f5, f6, f2
	ctx.f[5].f64 = ((ctx.f[6].f64 + ctx.f[2].f64) as f32) as f64;
	// 82CF9E10: EC6701B2  fmuls f3, f7, f6
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82CF9E14: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9E18: EC4402F2  fmuls f2, f4, f11
	ctx.f[2].f64 = (((ctx.f[4].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9E1C: D04B1000  stfs f2, 0x1000(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CF9E20: D06B1004  stfs f3, 0x1004(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4100 as u32), tmp.u32 ) };
	// 82CF9E24: 88890003  lbz r4, 3(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(3 as u32) ) } as u64;
	// 82CF9E28: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CF9E2C: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF9E30: C821FFD0  lfd f1, -0x30(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CF9E34: FD000E9C  fcfid f8, f1
	ctx.f[8].f64 = (ctx.f[1].s64 as f64);
	// 82CF9E38: FCA04018  frsp f5, f8
	ctx.f[5].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82CF9E3C: EC856828  fsubs f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9E40: EC640332  fmuls f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9E44: D06A000C  stfs f3, 0xc(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CF9E48: EC43302A  fadds f2, f3, f6
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF9E4C: ED0700F2  fmuls f8, f7, f3
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CF9E50: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9E54: ECC102F2  fmuls f6, f1, f11
	ctx.f[6].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9E58: D0CB0C00  stfs f6, 0xc00(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CF9E5C: D10B0C04  stfs f8, 0xc04(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CF9E60: 88C90002  lbz r6, 2(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CF9E64: F8C1FFD8  std r6, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[6].u64 ) };
	// 82CF9E68: C06A0008  lfs f3, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CF9E6C: C8A1FFD8  lfd f5, -0x28(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CF9E70: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF9E74: FC402018  frsp f2, f4
	ctx.f[2].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF9E78: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9E7C: ED010332  fmuls f8, f1, f12
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9E80: D10A0008  stfs f8, 8(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CF9E84: ECC8182A  fadds f6, f8, f3
	ctx.f[6].f64 = ((ctx.f[8].f64 + ctx.f[3].f64) as f32) as f64;
	// 82CF9E88: EC870232  fmuls f4, f7, f8
	ctx.f[4].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82CF9E8C: ECA60032  fmuls f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9E90: EC6502F2  fmuls f3, f5, f11
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9E94: D06B0800  stfs f3, 0x800(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CF9E98: D08B0804  stfs f4, 0x804(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CF9E9C: 89090001  lbz r8, 1(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 82CF9EA0: F901FFE0  std r8, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u64 ) };
	// 82CF9EA4: C10A0004  lfs f8, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CF9EA8: C841FFE0  lfd f2, -0x20(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CF9EAC: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CF9EB0: FCC00818  frsp f6, f1
	ctx.f[6].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CF9EB4: ECA66828  fsubs f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9EB8: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9EBC: D08A0004  stfs f4, 4(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9EC0: EC64402A  fadds f3, f4, f8
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CF9EC4: EC270132  fmuls f1, f7, f4
	ctx.f[1].f64 = (((ctx.f[7].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CF9EC8: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9ECC: ED0202F2  fmuls f8, f2, f11
	ctx.f[8].f64 = (((ctx.f[2].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9ED0: D10B0400  stfs f8, 0x400(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CF9ED4: D02B0404  stfs f1, 0x404(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CF9ED8: 88890000  lbz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9EDC: C0CA0000  lfs f6, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CF9EE0: 39290006  addi r9, r9, 6
	ctx.r[9].s64 = ctx.r[9].s64 + 6;
	// 82CF9EE4: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CF9EE8: C8A1FFE8  lfd f5, -0x18(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CF9EEC: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CF9EF0: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CF9EF4: EC436828  fsubs f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 - ctx.f[13].f64) as f32) as f64);
	// 82CF9EF8: EC220332  fmuls f1, f2, f12
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CF9EFC: D02A0000  stfs f1, 0(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9F00: ED01302A  fadds f8, f1, f6
	ctx.f[8].f64 = ((ctx.f[1].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CF9F04: ECE70072  fmuls f7, f7, f1
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CF9F08: ECC80032  fmuls f6, f8, f0
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9F0C: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CF9F10: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CF9F14: D0AB0000  stfs f5, 0(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CF9F18: D0EB0004  stfs f7, 4(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CF9F1C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CF9F20: 4082FE84  bne 0x82cf9da4
	if !ctx.cr[0].eq {
	pc = 0x82CF9DA4; continue 'dispatch;
	}
	// 82CF9F24: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CF9F28: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9F2C: 7CC84850  subf r6, r8, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82CF9F30: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9F34: 0CC70000  twi 6, r7, 0
	// 82CF9F38: 7D063B96  divwu r8, r6, r7
	ctx.r[8].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CF9F3C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF9F40: 41980008  blt cr6, 0x82cf9f48
	if ctx.cr[6].lt {
	pc = 0x82CF9F48; continue 'dispatch;
	}
	// 82CF9F44: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CF9F48: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CF9F4C: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9F50: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CF9F54: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CF9F58: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CF9F5C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CF9F60: 41980008  blt cr6, 0x82cf9f68
	if ctx.cr[6].lt {
	pc = 0x82CF9F68; continue 'dispatch;
	}
	// 82CF9F64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82CF9F68: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CF9F6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82CF9F70: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CF9F74: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82CF9F78: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 82CF9F7C: C00B67A8  lfs f0, 0x67a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9F80: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CF9F84: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CF9F88: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CF9F8C: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CF9F90: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CF9F94: 216B0080  subfic r11, r11, 0x80
	ctx.xer.ca = ctx.r[11].u32 <= 128 as u32;
	ctx.r[11].s64 = (128 as i64) - ctx.r[11].s64;
	// 82CF9F98: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82CF9F9C: 4198000C  blt cr6, 0x82cf9fa8
	if ctx.cr[6].lt {
	pc = 0x82CF9FA8; continue 'dispatch;
	}
	// 82CF9FA0: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82CF9FA4: 48000018  b 0x82cf9fbc
	pc = 0x82CF9FBC; continue 'dispatch;
	// 82CF9FA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CF9FAC: 4199000C  bgt cr6, 0x82cf9fb8
	if ctx.cr[6].gt {
	pc = 0x82CF9FB8; continue 'dispatch;
	}
	// 82CF9FB0: 98AA0000  stb r5, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82CF9FB4: 48000008  b 0x82cf9fbc
	pc = 0x82CF9FBC; continue 'dispatch;
	// 82CF9FB8: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82CF9FBC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CF9FC0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CF9FC4: 4082FFBC  bne 0x82cf9f80
	if !ctx.cr[0].eq {
	pc = 0x82CF9F80; continue 'dispatch;
	}
	// 82CF9FC8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CF9FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CF9FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CF9FD0 size=560
    let mut pc: u32 = 0x82CF9FD0;
    'dispatch: loop {
        match pc {
            0x82CF9FD0 => {
    //   block [0x82CF9FD0..0x82CFA200)
	// 82CF9FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CF9FD4: 4BFAF435  bl 0x82ca9408
	ctx.lr = 0x82CF9FD8;
	sub_82CA93D0(ctx, base);
	// 82CF9FD8: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CF9FDC: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CF9FE0: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CF9FE4: 3BC30034  addi r30, r3, 0x34
	ctx.r[30].s64 = ctx.r[3].s64 + 52;
	// 82CF9FE8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CF9FEC: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CF9FF0: 8883000D  lbz r4, 0xd(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CF9FF4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CF9FF8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CF9FFC: 7D0429D6  mullw r8, r4, r5
	ctx.r[8].s64 = (ctx.r[4].s32 as i64) * (ctx.r[5].s32 as i64);
	// 82CFA000: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA004: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA008: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82CFA00C: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82CFA010: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA014: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82CFA018: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CFA01C: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82CFA020: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82CFA024: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82CFA028: 41980008  blt cr6, 0x82cfa030
	if ctx.cr[6].lt {
	pc = 0x82CFA030; continue 'dispatch;
	}
	// 82CFA02C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82CFA030: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82CFA034: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA038: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA03C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFA040: F961FFD0  std r11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u64 ) };
	// 82CFA044: C941FFD0  lfd f10, -0x30(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA048: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CFA04C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFA050: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA054: C1AA0C4C  lfs f13, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA058: C1890C58  lfs f12, 0xc58(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFA05C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CFA060: ED4B4024  fdivs f10, f11, f8
	ctx.f[10].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CFA064: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA068: 419A0040  beq cr6, 0x82cfa0a8
	if ctx.cr[6].eq {
	pc = 0x82CFA0A8; continue 'dispatch;
	}
	// 82CFA06C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CFA070: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82CFA074: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA078: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CFA07C: 5528C63E  rlwinm r8, r9, 0x18, 0x18, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CFA080: 5128442E  rlwimi r8, r9, 8, 0x10, 0x17
	ctx.r[8].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA084: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 82CFA088: F901FFD0  std r8, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u64 ) };
	// 82CFA08C: C9A1FFD0  lfd f13, -0x30(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA090: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 82CFA094: FD005818  frsp f8, f11
	ctx.f[8].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82CFA098: ECE80332  fmuls f7, f8, f12
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA09C: D0EB0000  stfs f7, 0(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA0A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA0A4: 4082FFD0  bne 0x82cfa074
	if !ctx.cr[0].eq {
	pc = 0x82CFA074; continue 'dispatch;
	}
	// 82CFA0A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFA0AC: 549F083C  slwi r31, r4, 1
	ctx.r[31].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82CFA0B0: C16B0BFC  lfs f11, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFA0B4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CFA0B8: 419A0070  beq cr6, 0x82cfa128
	if ctx.cr[6].eq {
	pc = 0x82CFA128; continue 'dispatch;
	}
	// 82CFA0BC: EDAA002A  fadds f13, f10, f0
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA0C0: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82CFA0C4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CFA0C8: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82CFA0CC: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82CFA0D0: A3A80000  lhz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA0D4: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82CFA0D8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFA0DC: 57BCC63E  rlwinm r28, r29, 0x18, 0x18, 0x1f
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82CFA0E0: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 82CFA0E4: 53BC442E  rlwimi r28, r29, 8, 0x10, 0x17
	ctx.r[28].u64 = (((ctx.r[29].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[28].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA0E8: 7F9D0734  extsh r29, r28
	ctx.r[29].s64 = ctx.r[28].s16 as i64;
	// 82CFA0EC: FBA1FFD0  std r29, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[29].u64 ) };
	// 82CFA0F0: C8E1FFD0  lfd f7, -0x30(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA0F4: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFA0F8: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFA0FC: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA100: D08B0000  stfs f4, 0(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA104: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA108: EC64402A  fadds f3, f4, f8
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[8].f64) as f32) as f64;
	// 82CFA10C: EC4D0132  fmuls f2, f13, f4
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFA110: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA114: ED0102F2  fmuls f8, f1, f11
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFA118: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA11C: D04A0004  stfs f2, 4(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA120: 394A0400  addi r10, r10, 0x400
	ctx.r[10].s64 = ctx.r[10].s64 + 1024;
	// 82CFA124: 4082FFAC  bne 0x82cfa0d0
	if !ctx.cr[0].eq {
	pc = 0x82CFA0D0; continue 'dispatch;
	}
	// 82CFA128: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CFA12C: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA130: 7CBF2A14  add r5, r31, r5
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[5].u64;
	// 82CFA134: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82CFA138: 4082FF7C  bne 0x82cfa0b4
	if !ctx.cr[0].eq {
	pc = 0x82CFA0B4; continue 'dispatch;
	}
	// 82CFA13C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA140: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA144: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82CFA148: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA14C: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CFA150: 7D494396  divwu r10, r9, r8
	ctx.r[10].u32 = ctx.r[9].u32 / ctx.r[8].u32;
	// 82CFA154: 0CC80000  twi 6, r8, 0
	// 82CFA158: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFA15C: 41980008  blt cr6, 0x82cfa164
	if ctx.cr[6].lt {
	pc = 0x82CFA164; continue 'dispatch;
	}
	// 82CFA160: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CFA164: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA168: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CFA16C: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82CFA170: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA174: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA178: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFA17C: 40980008  bge cr6, 0x82cfa184
	if !ctx.cr[6].lt {
	pc = 0x82CFA184; continue 'dispatch;
	}
	// 82CFA180: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CFA184: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFA188: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFA18C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82CFA190: 419A006C  beq cr6, 0x82cfa1fc
	if ctx.cr[6].eq {
	pc = 0x82CFA1FC; continue 'dispatch;
	}
	// 82CFA194: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CFA198: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82CFA19C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82CFA1A0: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 82CFA1A4: 6129FF7F  ori r9, r9, 0xff7f
	ctx.r[9].u64 = ctx.r[9].u64 | 65407;
	// 82CFA1A8: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA1AC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA1B0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA1B4: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFA1B8: D961FFD0  stfd f11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[11].u64 ) };
	// 82CFA1BC: 8141FFD4  lwz r10, -0x2c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82CFA1C0: 2F0A7FFF  cmpwi cr6, r10, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32767, &mut ctx.xer);
	// 82CFA1C4: 4198000C  blt cr6, 0x82cfa1d0
	if ctx.cr[6].lt {
	pc = 0x82CFA1D0; continue 'dispatch;
	}
	// 82CFA1C8: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82CFA1CC: 48000024  b 0x82cfa1f0
	pc = 0x82CFA1F0; continue 'dispatch;
	// 82CFA1D0: 2F0A8000  cmpwi cr6, r10, -0x8000
	ctx.cr[6].compare_i32(ctx.r[10].s32, -32768, &mut ctx.xer);
	// 82CFA1D4: 4199000C  bgt cr6, 0x82cfa1e0
	if ctx.cr[6].gt {
	pc = 0x82CFA1E0; continue 'dispatch;
	}
	// 82CFA1D8: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CFA1DC: 48000014  b 0x82cfa1f0
	pc = 0x82CFA1F0; continue 'dispatch;
	// 82CFA1E0: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82CFA1E4: 5547C63E  rlwinm r7, r10, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CFA1E8: 5147442E  rlwimi r7, r10, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA1EC: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CFA1F0: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFA1F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA1F8: 4082FFB4  bne 0x82cfa1ac
	if !ctx.cr[0].eq {
	pc = 0x82CFA1AC; continue 'dispatch;
	}
	// 82CFA1FC: 4BFAF25C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFA200 size=444
    let mut pc: u32 = 0x82CFA200;
    'dispatch: loop {
        match pc {
            0x82CFA200 => {
    //   block [0x82CFA200..0x82CFA3BC)
	// 82CFA200: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFA204: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA208: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA20C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFA210: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA214: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA218: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CFA21C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA220: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82CFA224: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA228: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA22C: 7CA50E70  srawi r5, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82CFA230: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA234: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82CFA238: 7D450194  addze r10, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82CFA23C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82CFA240: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CFA244: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82CFA248: 41980008  blt cr6, 0x82cfa250
	if ctx.cr[6].lt {
	pc = 0x82CFA250; continue 'dispatch;
	}
	// 82CFA24C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82CFA250: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 82CFA254: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA258: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA25C: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA260: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82CFA264: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFA268: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82CFA26C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CFA270: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA274: 38AA007F  addi r5, r10, 0x7f
	ctx.r[5].s64 = ctx.r[10].s64 + 127;
	// 82CFA278: C1860C4C  lfs f12, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFA27C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFA280: 54A7C9FE  srwi r7, r5, 7
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFA284: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFA288: EDAB4024  fdivs f13, f11, f8
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[8].f64) as f32) as f64;
	// 82CFA28C: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA290: 419A0018  beq cr6, 0x82cfa2a8
	if ctx.cr[6].eq {
	pc = 0x82CFA2A8; continue 'dispatch;
	}
	// 82CFA294: 55463830  slwi r6, r10, 7
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA298: 7C065A2C  dcbt r6, r11
	// 82CFA29C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CFA2A0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CFA2A4: 4198FFF0  blt cr6, 0x82cfa294
	if ctx.cr[6].lt {
	pc = 0x82CFA294; continue 'dispatch;
	}
	// 82CFA2A8: A1430034  lhz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82CFA2AC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82CFA2B0: 5546C63E  rlwinm r6, r10, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CFA2B4: 5146442E  rlwimi r6, r10, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA2B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFA2BC: C1470C58  lfs f10, 0xc58(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3160 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82CFA2C0: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA2C4: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82CFA2C8: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFA2CC: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFA2D0: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA2D4: C16A0BFC  lfs f11, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82CFA2D8: ECE802B2  fmuls f7, f8, f10
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CFA2DC: D0E30034  stfs f7, 0x34(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CFA2E0: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA2E4: C1230034  lfs f9, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFA2E8: ED0D002A  fadds f8, f13, f0
	ctx.f[8].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA2EC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFA2F0: 5547C63E  rlwinm r7, r10, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CFA2F4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82CFA2F8: 5147442E  rlwimi r7, r10, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA2FC: 7CE50734  extsh r5, r7
	ctx.r[5].s64 = ctx.r[7].s16 as i64;
	// 82CFA300: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 82CFA304: C8E1FFF0  lfd f7, -0x10(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82CFA308: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFA30C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFA310: EC8502B2  fmuls f4, f5, f10
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[10].f64) as f32) as f64);
	// 82CFA314: D0830034  stfs f4, 0x34(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82CFA318: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CFA31C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFA320: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA324: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA328: ED2102F2  fmuls f9, f1, f11
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82CFA32C: D1280000  stfs f9, 0(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA330: D0480004  stfs f2, 4(r8)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA334: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82CFA338: 4082FFA8  bne 0x82cfa2e0
	if !ctx.cr[0].eq {
	pc = 0x82CFA2E0; continue 'dispatch;
	}
	// 82CFA33C: 8943000D  lbz r10, 0xd(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA340: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA344: 5547083E  rotlwi r7, r10, 1
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82CFA348: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA34C: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82CFA350: 0CC70000  twi 6, r7, 0
	// 82CFA354: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CFA358: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFA35C: 40980008  bge cr6, 0x82cfa364
	if !ctx.cr[6].lt {
	pc = 0x82CFA364; continue 'dispatch;
	}
	// 82CFA360: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82CFA364: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA368: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82CFA36C: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82CFA370: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA374: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA378: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFA37C: 40980008  bge cr6, 0x82cfa384
	if !ctx.cr[6].lt {
	pc = 0x82CFA384; continue 'dispatch;
	}
	// 82CFA380: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CFA384: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CFA388: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFA38C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFA390: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA394: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA398: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA39C: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFA3A0: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 82CFA3A4: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82CFA3A8: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CFA3AC: 41980010  blt cr6, 0x82cfa3bc
	if ctx.cr[6].lt {
		sub_82CFA3BC(ctx, base);
		return;
	}
	// 82CFA3B0: 3960FF7F  li r11, -0x81
	ctx.r[11].s64 = -129;
	// 82CFA3B4: B1630034  sth r11, 0x34(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u16 ) };
	// 82CFA3B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA3BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CFA3BC size=20
    let mut pc: u32 = 0x82CFA3BC;
    'dispatch: loop {
        match pc {
            0x82CFA3BC => {
    //   block [0x82CFA3BC..0x82CFA3D0)
	// 82CFA3BC: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CFA3C0: 41990010  bgt cr6, 0x82cfa3d0
	if ctx.cr[6].gt {
		sub_82CFA3D0(ctx, base);
		return;
	}
	// 82CFA3C4: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 82CFA3C8: B1630034  sth r11, 0x34(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u16 ) };
	// 82CFA3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82CFA3D0 size=20
    let mut pc: u32 = 0x82CFA3D0;
    'dispatch: loop {
        match pc {
            0x82CFA3D0 => {
    //   block [0x82CFA3D0..0x82CFA3E4)
	// 82CFA3D0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82CFA3D4: 556AC63E  rlwinm r10, r11, 0x18, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CFA3D8: 516A442E  rlwimi r10, r11, 8, 0x10, 0x17
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA3DC: B1430034  sth r10, 0x34(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[10].u16 ) };
	// 82CFA3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFA3E8 size=608
    let mut pc: u32 = 0x82CFA3E8;
    'dispatch: loop {
        match pc {
            0x82CFA3E8 => {
    //   block [0x82CFA3E8..0x82CFA648)
	// 82CFA3E8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CFA3EC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFA3F0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA3F4: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA3F8: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 82CFA3FC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFA400: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA404: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA408: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CFA40C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA410: 7D4849D6  mullw r10, r8, r9
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82CFA414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA418: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA41C: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CFA420: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA424: 7D09F850  subf r8, r9, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 82CFA428: 7D240194  addze r9, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[9].s64 = tmp.s64;
	// 82CFA42C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFA430: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82CFA434: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82CFA438: 41980008  blt cr6, 0x82cfa440
	if ctx.cr[6].lt {
	pc = 0x82CFA440; continue 'dispatch;
	}
	// 82CFA43C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CFA440: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82CFA444: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA448: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA44C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFA450: F8E1FFE0  std r7, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[7].u64 ) };
	// 82CFA454: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFA458: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CFA45C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CFA460: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFA464: 3889007F  addi r4, r9, 0x7f
	ctx.r[4].s64 = ctx.r[9].s64 + 127;
	// 82CFA468: C1A60C4C  lfs f13, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA46C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFA470: 5487C9FE  srwi r7, r4, 7
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82CFA474: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82CFA478: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CFA47C: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA480: 419A0018  beq cr6, 0x82cfa498
	if ctx.cr[6].eq {
	pc = 0x82CFA498; continue 'dispatch;
	}
	// 82CFA484: 55263830  slwi r6, r9, 7
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA488: 7C065A2C  dcbt r6, r11
	// 82CFA48C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CFA490: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82CFA494: 4198FFF0  blt cr6, 0x82cfa484
	if ctx.cr[6].lt {
	pc = 0x82CFA484; continue 'dispatch;
	}
	// 82CFA498: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82CFA49C: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82CFA4A0: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82CFA4A4: C1A60C58  lfs f13, 0xc58(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA4A8: A0C90000  lhz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA4AC: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFA4B0: 54C4C63E  rlwinm r4, r6, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 82CFA4B4: 50C4442E  rlwimi r4, r6, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA4B8: 7C840734  extsh r4, r4
	ctx.r[4].s64 = ctx.r[4].s16 as i64;
	// 82CFA4BC: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CFA4C0: C981FFE0  lfd f12, -0x20(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFA4C4: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CFA4C8: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA4CC: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA4D0: D0E90000  stfs f7, 0(r9)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA4D4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CFA4D8: 4082FFD0  bne 0x82cfa4a8
	if !ctx.cr[0].eq {
	pc = 0x82CFA4A8; continue 'dispatch;
	}
	// 82CFA4DC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82CFA4E0: C1890BFC  lfs f12, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFA4E4: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CFA4E8: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFA4EC: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA4F0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CFA4F4: 5527C63E  rlwinm r7, r9, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CFA4F8: 5127442E  rlwimi r7, r9, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA4FC: 7CE40734  extsh r4, r7
	ctx.r[4].s64 = ctx.r[7].s16 as i64;
	// 82CFA500: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CFA504: C8E1FFE0  lfd f7, -0x20(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFA508: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFA50C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFA510: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA514: D0850004  stfs f4, 4(r5)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA518: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CFA51C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFA520: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA524: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA528: D12A0400  stfs f9, 0x400(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CFA52C: D04A0404  stfs f2, 0x404(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CFA530: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA534: 5527C63E  rlwinm r7, r9, 0x18, 0x18, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82CFA538: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFA53C: 5127442E  rlwimi r7, r9, 8, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA540: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA544: 7CE40734  extsh r4, r7
	ctx.r[4].s64 = ctx.r[7].s16 as i64;
	// 82CFA548: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CFA54C: C8C1FFE8  lfd f6, -0x18(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CFA550: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CFA554: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CFA558: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA55C: D0650000  stfs f3, 0(r5)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA560: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CFA564: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CFA568: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA56C: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA570: ED090332  fmuls f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA574: D10A0000  stfs f8, 0(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA578: D02A0004  stfs f1, 4(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA57C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CFA580: 4082FF64  bne 0x82cfa4e4
	if !ctx.cr[0].eq {
	pc = 0x82CFA4E4; continue 'dispatch;
	}
	// 82CFA584: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA588: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA58C: 5527083E  rotlwi r7, r9, 1
	ctx.r[7].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82CFA590: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA594: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82CFA598: 0CC70000  twi 6, r7, 0
	// 82CFA59C: 7D663B96  divwu r11, r6, r7
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[7].u32;
	// 82CFA5A0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CFA5A4: 40980008  bge cr6, 0x82cfa5ac
	if !ctx.cr[6].lt {
	pc = 0x82CFA5AC; continue 'dispatch;
	}
	// 82CFA5A8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82CFA5AC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA5B0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA5B4: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82CFA5B8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82CFA5BC: 54EAF0BE  srwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA5C0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82CFA5C4: 40980008  bge cr6, 0x82cfa5cc
	if !ctx.cr[6].lt {
	pc = 0x82CFA5CC; continue 'dispatch;
	}
	// 82CFA5C8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CFA5CC: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82CFA5D0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFA5D4: 3D000000  lis r8, 0
	ctx.r[8].s64 = 0;
	// 82CFA5D8: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFA5DC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82CFA5E0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82CFA5E4: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82CFA5E8: C00A0F28  lfs f0, 0xf28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA5EC: 6108FF7F  ori r8, r8, 0xff7f
	ctx.r[8].u64 = ctx.r[8].u64 | 65407;
	// 82CFA5F0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA5F4: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA5F8: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFA5FC: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CFA600: 8141FFEC  lwz r10, -0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CFA604: 2F0A7FFF  cmpwi cr6, r10, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32767, &mut ctx.xer);
	// 82CFA608: 4198000C  blt cr6, 0x82cfa614
	if ctx.cr[6].lt {
	pc = 0x82CFA614; continue 'dispatch;
	}
	// 82CFA60C: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CFA610: 48000024  b 0x82cfa634
	pc = 0x82CFA634; continue 'dispatch;
	// 82CFA614: 2F0A8000  cmpwi cr6, r10, -0x8000
	ctx.cr[6].compare_i32(ctx.r[10].s32, -32768, &mut ctx.xer);
	// 82CFA618: 4199000C  bgt cr6, 0x82cfa624
	if ctx.cr[6].gt {
	pc = 0x82CFA624; continue 'dispatch;
	}
	// 82CFA61C: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CFA620: 48000014  b 0x82cfa634
	pc = 0x82CFA634; continue 'dispatch;
	// 82CFA624: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82CFA628: 5546C63E  rlwinm r6, r10, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82CFA62C: 5146442E  rlwimi r6, r10, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA630: B0CB0000  sth r6, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	// 82CFA634: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFA638: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82CFA63C: 4082FFB4  bne 0x82cfa5f0
	if !ctx.cr[0].eq {
	pc = 0x82CFA5F0; continue 'dispatch;
	}
	// 82CFA640: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CFA644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFA648 size=740
    let mut pc: u32 = 0x82CFA648;
    'dispatch: loop {
        match pc {
            0x82CFA648 => {
    //   block [0x82CFA648..0x82CFA92C)
	// 82CFA648: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CFA64C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFA650: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA654: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA658: 39230034  addi r9, r3, 0x34
	ctx.r[9].s64 = ctx.r[3].s64 + 52;
	// 82CFA65C: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFA660: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFA664: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA668: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82CFA66C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA670: 7D4741D6  mullw r10, r7, r8
	ctx.r[10].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CFA674: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA678: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA67C: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CFA680: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CFA684: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFA688: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CFA68C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFA690: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CFA694: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CFA698: 41980008  blt cr6, 0x82cfa6a0
	if ctx.cr[6].lt {
	pc = 0x82CFA6A0; continue 'dispatch;
	}
	// 82CFA69C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82CFA6A0: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFA6A4: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA6A8: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA6AC: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA6B0: F8C1FFD0  std r6, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[6].u64 ) };
	// 82CFA6B4: C961FFD0  lfd f11, -0x30(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA6B8: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CFA6BC: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFA6C0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFA6C4: 3888007F  addi r4, r8, 0x7f
	ctx.r[4].s64 = ctx.r[8].s64 + 127;
	// 82CFA6C8: C1A50C4C  lfs f13, 0xc4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA6CC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFA6D0: 5486C9FE  srwi r6, r4, 7
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA6D4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CFA6D8: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CFA6DC: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA6E0: 419A0018  beq cr6, 0x82cfa6f8
	if ctx.cr[6].eq {
	pc = 0x82CFA6F8; continue 'dispatch;
	}
	// 82CFA6E4: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFA6E8: 7C05522C  dcbt r5, r10
	// 82CFA6EC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CFA6F0: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CFA6F4: 4198FFF0  blt cr6, 0x82cfa6e4
	if ctx.cr[6].lt {
	pc = 0x82CFA6E4; continue 'dispatch;
	}
	// 82CFA6F8: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFA6FC: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CFA700: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82CFA704: C1A50C58  lfs f13, 0xc58(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA708: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA70C: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CFA710: 54A4C63E  rlwinm r4, r5, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82CFA714: 50A4442E  rlwimi r4, r5, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA718: 7C840734  extsh r4, r4
	ctx.r[4].s64 = ctx.r[4].s16 as i64;
	// 82CFA71C: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CFA720: C981FFD0  lfd f12, -0x30(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA724: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CFA728: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFA72C: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA730: D0E80000  stfs f7, 0(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA734: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CFA738: 4082FFD0  bne 0x82cfa708
	if !ctx.cr[0].eq {
	pc = 0x82CFA708; continue 'dispatch;
	}
	// 82CFA73C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CFA740: C1880BFC  lfs f12, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFA744: A10A0006  lhz r8, 6(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CFA748: C129000C  lfs f9, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFA74C: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA750: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFA754: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFA758: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA75C: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA760: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CFA764: C8E1FFD0  lfd f7, -0x30(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFA768: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFA76C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFA770: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA774: D089000C  stfs f4, 0xc(r9)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CFA778: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CFA77C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFA780: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA784: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA788: D12B0C00  stfs f9, 0xc00(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CFA78C: D04B0C04  stfs f2, 0xc04(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CFA790: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA794: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFA798: C0E90008  lfs f7, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFA79C: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA7A0: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA7A4: F881FFD8  std r4, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[4].u64 ) };
	// 82CFA7A8: C8C1FFD8  lfd f6, -0x28(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFA7AC: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CFA7B0: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CFA7B4: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA7B8: D0690008  stfs f3, 8(r9)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CFA7BC: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CFA7C0: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CFA7C4: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA7C8: ECE90332  fmuls f7, f9, f12
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA7CC: D0EB0800  stfs f7, 0x800(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CFA7D0: D02B0804  stfs f1, 0x804(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CFA7D4: A10A0002  lhz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CFA7D8: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFA7DC: C0C90004  lfs f6, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CFA7E0: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA7E4: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA7E8: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CFA7EC: C8A1FFE0  lfd f5, -0x20(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFA7F0: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CFA7F4: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CFA7F8: EC430372  fmuls f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA7FC: D0490004  stfs f2, 4(r9)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA800: EC22302A  fadds f1, f2, f6
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CFA804: ED2800B2  fmuls f9, f8, f2
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CFA808: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA80C: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA810: D0CB0400  stfs f6, 0x400(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CFA814: D12B0404  stfs f9, 0x404(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CFA818: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA81C: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFA820: C0A90000  lfs f5, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CFA824: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA828: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82CFA82C: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFA830: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CFA834: C881FFE8  lfd f4, -0x18(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CFA838: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CFA83C: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CFA840: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA844: D0290000  stfs f1, 0(r9)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA848: ED21282A  fadds f9, f1, f5
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 82CFA84C: ED080072  fmuls f8, f8, f1
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CFA850: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA854: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFA858: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFA85C: D0CB0000  stfs f6, 0(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFA860: D10B0004  stfs f8, 4(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFA864: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CFA868: 4082FEDC  bne 0x82cfa744
	if !ctx.cr[0].eq {
	pc = 0x82CFA744; continue 'dispatch;
	}
	// 82CFA86C: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA870: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA874: 5506083E  rotlwi r6, r8, 1
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82CFA878: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA87C: 7CA75050  subf r5, r7, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 82CFA880: 0CC60000  twi 6, r6, 0
	// 82CFA884: 7D453396  divwu r10, r5, r6
	ctx.r[10].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CFA888: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFA88C: 40980008  bge cr6, 0x82cfa894
	if !ctx.cr[6].lt {
	pc = 0x82CFA894; continue 'dispatch;
	}
	// 82CFA890: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CFA894: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA898: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA89C: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CFA8A0: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CFA8A4: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFA8A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFA8AC: 41980008  blt cr6, 0x82cfa8b4
	if ctx.cr[6].lt {
	pc = 0x82CFA8B4; continue 'dispatch;
	}
	// 82CFA8B0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82CFA8B4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFA8B8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82CFA8BC: 3D000000  lis r8, 0
	ctx.r[8].s64 = 0;
	// 82CFA8C0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFA8C4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82CFA8C8: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82CFA8CC: 6108FF7F  ori r8, r8, 0xff7f
	ctx.r[8].u64 = ctx.r[8].u64 | 65407;
	// 82CFA8D0: C00B0F28  lfs f0, 0xf28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA8D4: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA8D8: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFA8DC: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFA8E0: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CFA8E4: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CFA8E8: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CFA8EC: 4198000C  blt cr6, 0x82cfa8f8
	if ctx.cr[6].lt {
	pc = 0x82CFA8F8; continue 'dispatch;
	}
	// 82CFA8F0: B1090000  sth r8, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CFA8F4: 48000024  b 0x82cfa918
	pc = 0x82CFA918; continue 'dispatch;
	// 82CFA8F8: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CFA8FC: 4199000C  bgt cr6, 0x82cfa908
	if ctx.cr[6].gt {
	pc = 0x82CFA908; continue 'dispatch;
	}
	// 82CFA900: B0E90000  sth r7, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CFA904: 48000014  b 0x82cfa918
	pc = 0x82CFA918; continue 'dispatch;
	// 82CFA908: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82CFA90C: 5566C63E  rlwinm r6, r11, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CFA910: 5166442E  rlwimi r6, r11, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFA914: B0C90000  sth r6, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	// 82CFA918: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82CFA91C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82CFA920: 4082FFB4  bne 0x82cfa8d4
	if !ctx.cr[0].eq {
	pc = 0x82CFA8D4; continue 'dispatch;
	}
	// 82CFA924: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CFA928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFA930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82CFA930 size=884
    let mut pc: u32 = 0x82CFA930;
    'dispatch: loop {
        match pc {
            0x82CFA930 => {
    //   block [0x82CFA930..0x82CFACA4)
	// 82CFA930: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82CFA934: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFA938: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFA93C: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFA940: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 82CFA944: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFA948: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFA94C: 88E3000D  lbz r7, 0xd(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFA950: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82CFA954: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFA958: 7D2741D6  mullw r9, r7, r8
	ctx.r[9].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82CFA95C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA960: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFA964: 7C840E70  srawi r4, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 82CFA968: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82CFA96C: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFA970: 7D040194  addze r8, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82CFA974: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CFA978: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 82CFA97C: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82CFA980: 41980008  blt cr6, 0x82cfa988
	if ctx.cr[6].lt {
	pc = 0x82CFA988; continue 'dispatch;
	}
	// 82CFA984: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82CFA988: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFA98C: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA990: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFA994: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA998: F8C1FFC0  std r6, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[6].u64 ) };
	// 82CFA99C: C961FFC0  lfd f11, -0x40(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CFA9A0: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82CFA9A4: 7CA74214  add r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82CFA9A8: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFA9AC: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFA9B0: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82CFA9B4: 38C8007F  addi r6, r8, 0x7f
	ctx.r[6].s64 = ctx.r[8].s64 + 127;
	// 82CFA9B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82CFA9BC: 54C6C9FE  srwi r6, r6, 7
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFA9C0: C1A40C4C  lfs f13, 0xc4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA9C4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82CFA9C8: ED6C4824  fdivs f11, f12, f9
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82CFA9CC: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFA9D0: 419A0018  beq cr6, 0x82cfa9e8
	if ctx.cr[6].eq {
	pc = 0x82CFA9E8; continue 'dispatch;
	}
	// 82CFA9D4: 55053830  slwi r5, r8, 7
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFA9D8: 7C054A2C  dcbt r5, r9
	// 82CFA9DC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82CFA9E0: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82CFA9E4: 4198FFF0  blt cr6, 0x82cfa9d4
	if ctx.cr[6].lt {
	pc = 0x82CFA9D4; continue 'dispatch;
	}
	// 82CFA9E8: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFA9EC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82CFA9F0: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82CFA9F4: C1A50C58  lfs f13, 0xc58(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFA9F8: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFA9FC: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82CFAA00: 54A4C63E  rlwinm r4, r5, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82CFAA04: 50A4442E  rlwimi r4, r5, 8, 0x10, 0x17
	ctx.r[4].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAA08: 7C840734  extsh r4, r4
	ctx.r[4].s64 = ctx.r[4].s16 as i64;
	// 82CFAA0C: F881FFC0  std r4, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[4].u64 ) };
	// 82CFAA10: C981FFC0  lfd f12, -0x40(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CFAA14: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82CFAA18: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAA1C: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAA20: D0E80000  stfs f7, 0(r8)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFAA24: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82CFAA28: 4082FFD0  bne 0x82cfa9f8
	if !ctx.cr[0].eq {
	pc = 0x82CFA9F8; continue 'dispatch;
	}
	// 82CFAA2C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82CFAA30: C1880BFC  lfs f12, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFAA34: A109000A  lhz r8, 0xa(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(10 as u32) ) } as u64;
	// 82CFAA38: C12A0014  lfs f9, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82CFAA3C: ED0B002A  fadds f8, f11, f0
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFAA40: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFAA44: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAA48: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAA4C: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAA50: F881FFC0  std r4, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.r[4].u64 ) };
	// 82CFAA54: C8E1FFC0  lfd f7, -0x40(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82CFAA58: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 82CFAA5C: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82CFAA60: EC850372  fmuls f4, f5, f13
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAA64: D08A0014  stfs f4, 0x14(r10)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82CFAA68: EC64482A  fadds f3, f4, f9
	ctx.f[3].f64 = ((ctx.f[4].f64 + ctx.f[9].f64) as f32) as f64;
	// 82CFAA6C: EC480132  fmuls f2, f8, f4
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[4].f64) as f32) as f64);
	// 82CFAA70: EC230032  fmuls f1, f3, f0
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAA74: ED210332  fmuls f9, f1, f12
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAA78: D12B1400  stfs f9, 0x1400(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5120 as u32), tmp.u32 ) };
	// 82CFAA7C: D04B1404  stfs f2, 0x1404(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5124 as u32), tmp.u32 ) };
	// 82CFAA80: A1090008  lhz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFAA84: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAA88: C0EA0010  lfs f7, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82CFAA8C: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAA90: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAA94: F881FFC8  std r4, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[4].u64 ) };
	// 82CFAA98: C8C1FFC8  lfd f6, -0x38(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82CFAA9C: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82CFAAA0: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82CFAAA4: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAAA8: D06A0010  stfs f3, 0x10(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82CFAAAC: EC43382A  fadds f2, f3, f7
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 82CFAAB0: EC2800F2  fmuls f1, f8, f3
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82CFAAB4: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAAB8: ECE90332  fmuls f7, f9, f12
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAABC: D0EB1000  stfs f7, 0x1000(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4096 as u32), tmp.u32 ) };
	// 82CFAAC0: D02B1004  stfs f1, 0x1004(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4100 as u32), tmp.u32 ) };
	// 82CFAAC4: A1090006  lhz r8, 6(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(6 as u32) ) } as u64;
	// 82CFAAC8: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAACC: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82CFAAD0: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAAD4: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAAD8: F881FFD0  std r4, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[4].u64 ) };
	// 82CFAADC: C8A1FFD0  lfd f5, -0x30(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82CFAAE0: FC802E9C  fcfid f4, f5
	ctx.f[4].f64 = (ctx.f[5].s64 as f64);
	// 82CFAAE4: FC602018  frsp f3, f4
	ctx.f[3].f64 = (ctx.f[4].f64 as f32) as f64;
	// 82CFAAE8: EC430372  fmuls f2, f3, f13
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAAEC: D04A000C  stfs f2, 0xc(r10)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82CFAAF0: EC22302A  fadds f1, f2, f6
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[6].f64) as f32) as f64;
	// 82CFAAF4: ED2800B2  fmuls f9, f8, f2
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[2].f64) as f32) as f64);
	// 82CFAAF8: ECE10032  fmuls f7, f1, f0
	ctx.f[7].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAAFC: ECC70332  fmuls f6, f7, f12
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAB00: D0CB0C00  stfs f6, 0xc00(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3072 as u32), tmp.u32 ) };
	// 82CFAB04: D12B0C04  stfs f9, 0xc04(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3076 as u32), tmp.u32 ) };
	// 82CFAB08: A1090004  lhz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFAB0C: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAB10: C0AA0008  lfs f5, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82CFAB14: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAB18: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAB1C: F881FFD8  std r4, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[4].u64 ) };
	// 82CFAB20: C881FFD8  lfd f4, -0x28(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82CFAB24: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82CFAB28: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82CFAB2C: EC220372  fmuls f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAB30: D02A0008  stfs f1, 8(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82CFAB34: ED21282A  fadds f9, f1, f5
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 82CFAB38: ECE80072  fmuls f7, f8, f1
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82CFAB3C: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAB40: ECA60332  fmuls f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAB44: D0AB0800  stfs f5, 0x800(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 82CFAB48: D0EB0804  stfs f7, 0x804(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 82CFAB4C: A1090002  lhz r8, 2(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 82CFAB50: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAB54: C08A0004  lfs f4, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82CFAB58: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAB5C: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFAB60: F881FFE0  std r4, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u64 ) };
	// 82CFAB64: C861FFE0  lfd f3, -0x20(r1)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82CFAB68: FC401E9C  fcfid f2, f3
	ctx.f[2].f64 = (ctx.f[3].s64 as f64);
	// 82CFAB6C: FC201018  frsp f1, f2
	ctx.f[1].f64 = (ctx.f[2].f64 as f32) as f64;
	// 82CFAB70: ED210372  fmuls f9, f1, f13
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFAB74: D12A0004  stfs f9, 4(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFAB78: ECE9202A  fadds f7, f9, f4
	ctx.f[7].f64 = ((ctx.f[9].f64 + ctx.f[4].f64) as f32) as f64;
	// 82CFAB7C: ECC80272  fmuls f6, f8, f9
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 82CFAB80: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAB84: EC850332  fmuls f4, f5, f12
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFAB88: D08B0400  stfs f4, 0x400(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82CFAB8C: D0CB0404  stfs f6, 0x404(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82CFAB90: C06A0000  lfs f3, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82CFAB94: A1090000  lhz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFAB98: 5506C63E  rlwinm r6, r8, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82CFAB9C: 5106442E  rlwimi r6, r8, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFABA0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 82CFABA4: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 82CFABA8: F881FFE8  std r4, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[4].u64 ) };
	// 82CFABAC: C841FFE8  lfd f2, -0x18(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82CFABB0: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 82CFABB4: FD200818  frsp f9, f1
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82CFABB8: ECE90372  fmuls f7, f9, f13
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82CFABBC: D0EA0000  stfs f7, 0(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFABC0: ECC7182A  fadds f6, f7, f3
	ctx.f[6].f64 = ((ctx.f[7].f64 + ctx.f[3].f64) as f32) as f64;
	// 82CFABC4: ECA801F2  fmuls f5, f8, f7
	ctx.f[5].f64 = (((ctx.f[8].f64 * ctx.f[7].f64) as f32) as f64);
	// 82CFABC8: EC860032  fmuls f4, f6, f0
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFABCC: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82CFABD0: EC640332  fmuls f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 82CFABD4: D06B0000  stfs f3, 0(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82CFABD8: D0AB0004  stfs f5, 4(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82CFABDC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82CFABE0: 4082FE54  bne 0x82cfaa34
	if !ctx.cr[0].eq {
	pc = 0x82CFAA34; continue 'dispatch;
	}
	// 82CFABE4: 8903000D  lbz r8, 0xd(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFABE8: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFABEC: 5506083E  rotlwi r6, r8, 1
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82CFABF0: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFABF4: 7CA74850  subf r5, r7, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82CFABF8: 0CC60000  twi 6, r6, 0
	// 82CFABFC: 7D253396  divwu r9, r5, r6
	ctx.r[9].u32 = ctx.r[5].u32 / ctx.r[6].u32;
	// 82CFAC00: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFAC04: 40980008  bge cr6, 0x82cfac0c
	if !ctx.cr[6].lt {
	pc = 0x82CFAC0C; continue 'dispatch;
	}
	// 82CFAC08: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82CFAC0C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFAC10: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFAC14: 7CC75850  subf r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82CFAC18: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82CFAC1C: 54CBF0BE  srwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFAC20: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82CFAC24: 41980008  blt cr6, 0x82cfac2c
	if ctx.cr[6].lt {
	pc = 0x82CFAC2C; continue 'dispatch;
	}
	// 82CFAC28: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82CFAC2C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82CFAC30: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82CFAC34: 3D000000  lis r8, 0
	ctx.r[8].s64 = 0;
	// 82CFAC38: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82CFAC3C: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82CFAC40: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82CFAC44: 6108FF7F  ori r8, r8, 0xff7f
	ctx.r[8].u64 = ctx.r[8].u64 | 65407;
	// 82CFAC48: C00B0F28  lfs f0, 0xf28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAC4C: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFAC50: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82CFAC54: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82CFAC58: D961FFE8  stfd f11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[11].u64 ) };
	// 82CFAC5C: 8161FFEC  lwz r11, -0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82CFAC60: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82CFAC64: 4198000C  blt cr6, 0x82cfac70
	if ctx.cr[6].lt {
	pc = 0x82CFAC70; continue 'dispatch;
	}
	// 82CFAC68: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82CFAC6C: 48000024  b 0x82cfac90
	pc = 0x82CFAC90; continue 'dispatch;
	// 82CFAC70: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82CFAC74: 4199000C  bgt cr6, 0x82cfac80
	if ctx.cr[6].gt {
	pc = 0x82CFAC80; continue 'dispatch;
	}
	// 82CFAC78: B0EA0000  sth r7, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 82CFAC7C: 48000014  b 0x82cfac90
	pc = 0x82CFAC90; continue 'dispatch;
	// 82CFAC80: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82CFAC84: 5566C63E  rlwinm r6, r11, 0x18, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82CFAC88: 5166442E  rlwimi r6, r11, 8, 0x10, 0x17
	ctx.r[6].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[6].u64 & 0xFFFFFFFFFFFF00FF);
	// 82CFAC8C: B0CA0000  sth r6, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	// 82CFAC90: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFAC94: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82CFAC98: 4082FFB4  bne 0x82cfac4c
	if !ctx.cr[0].eq {
	pc = 0x82CFAC4C; continue 'dispatch;
	}
	// 82CFAC9C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82CFACA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFACA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFACA8 size=216
    let mut pc: u32 = 0x82CFACA8;
    'dispatch: loop {
        match pc {
            0x82CFACA8 => {
    //   block [0x82CFACA8..0x82CFAD80)
	// 82CFACA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFACAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFACB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFACB4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFACB8: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFACBC: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFACC0: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFACC4: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFACC8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFACCC: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFACD0: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFACD4: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFACD8: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFACDC: 54CA07BE  clrlwi r10, r6, 0x1e
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 82CFACE0: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFACE4: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFACE8: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFACEC: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFACF0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFACF4: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFACF8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFACFC: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFAD00: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFAD04: 409A0064  bne cr6, 0x82cfad68
	if !ctx.cr[6].eq {
	pc = 0x82CFAD68; continue 'dispatch;
	}
	// 82CFAD08: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFAD0C: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAD10: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFAD14: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFAD18: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFAD1C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAD20: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFAD24: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAD28: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFAD2C: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFAD30: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFAD34: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAD38: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFAD3C: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFAD40: 40990028  ble cr6, 0x82cfad68
	if !ctx.cr[6].gt {
	pc = 0x82CFAD68; continue 'dispatch;
	}
	// 82CFAD44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFAD48: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAD4C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFAD50: 41980018  blt cr6, 0x82cfad68
	if ctx.cr[6].lt {
	pc = 0x82CFAD68; continue 'dispatch;
	}
	// 82CFAD54: 4BFF33CD  bl 0x82cee120
	ctx.lr = 0x82CFAD58;
	sub_82CEE120(ctx, base);
	// 82CFAD58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAD5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAD60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAD64: 4E800020  blr
	return;
	// 82CFAD68: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFAD6C: 4BFF6435  bl 0x82cf11a0
	ctx.lr = 0x82CFAD70;
	sub_82CF11A0(ctx, base);
	// 82CFAD70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAD74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAD78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAD7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFAD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFAD80 size=216
    let mut pc: u32 = 0x82CFAD80;
    'dispatch: loop {
        match pc {
            0x82CFAD80 => {
    //   block [0x82CFAD80..0x82CFAE58)
	// 82CFAD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFAD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFAD88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFAD8C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFAD90: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFAD94: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFAD98: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFAD9C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFADA0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFADA4: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFADA8: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFADAC: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFADB0: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFADB4: 54CA07BE  clrlwi r10, r6, 0x1e
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 82CFADB8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFADBC: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFADC0: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFADC4: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFADC8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFADCC: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFADD0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFADD4: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFADD8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFADDC: 409A0064  bne cr6, 0x82cfae40
	if !ctx.cr[6].eq {
	pc = 0x82CFAE40; continue 'dispatch;
	}
	// 82CFADE0: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFADE4: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFADE8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFADEC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFADF0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFADF4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFADF8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFADFC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAE00: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFAE04: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFAE08: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFAE0C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAE10: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFAE14: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFAE18: 40990028  ble cr6, 0x82cfae40
	if !ctx.cr[6].gt {
	pc = 0x82CFAE40; continue 'dispatch;
	}
	// 82CFAE1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFAE20: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAE24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFAE28: 41980018  blt cr6, 0x82cfae40
	if ctx.cr[6].lt {
	pc = 0x82CFAE40; continue 'dispatch;
	}
	// 82CFAE2C: 4BFF34F5  bl 0x82cee320
	ctx.lr = 0x82CFAE30;
	sub_82CEE320(ctx, base);
	// 82CFAE30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAE34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAE38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAE3C: 4E800020  blr
	return;
	// 82CFAE40: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFAE44: 4BFF663D  bl 0x82cf1480
	ctx.lr = 0x82CFAE48;
	sub_82CF1480(ctx, base);
	// 82CFAE48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAE4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAE50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAE54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFAE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFAE58 size=216
    let mut pc: u32 = 0x82CFAE58;
    'dispatch: loop {
        match pc {
            0x82CFAE58 => {
    //   block [0x82CFAE58..0x82CFAF30)
	// 82CFAE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFAE5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFAE60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFAE64: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFAE68: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFAE6C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFAE70: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFAE74: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFAE78: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFAE7C: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFAE80: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFAE84: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFAE88: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFAE8C: 54CA07BE  clrlwi r10, r6, 0x1e
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 82CFAE90: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFAE94: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFAE98: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFAE9C: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFAEA0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFAEA4: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFAEA8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFAEAC: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFAEB0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFAEB4: 409A0064  bne cr6, 0x82cfaf18
	if !ctx.cr[6].eq {
	pc = 0x82CFAF18; continue 'dispatch;
	}
	// 82CFAEB8: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFAEBC: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAEC0: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFAEC4: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFAEC8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFAECC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAED0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFAED4: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAED8: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFAEDC: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFAEE0: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFAEE4: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAEE8: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFAEEC: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFAEF0: 40990028  ble cr6, 0x82cfaf18
	if !ctx.cr[6].gt {
	pc = 0x82CFAF18; continue 'dispatch;
	}
	// 82CFAEF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFAEF8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAEFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFAF00: 41980018  blt cr6, 0x82cfaf18
	if ctx.cr[6].lt {
	pc = 0x82CFAF18; continue 'dispatch;
	}
	// 82CFAF04: 4BFF364D  bl 0x82cee550
	ctx.lr = 0x82CFAF08;
	sub_82CEE550(ctx, base);
	// 82CFAF08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAF0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAF10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAF14: 4E800020  blr
	return;
	// 82CFAF18: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFAF1C: 4BFF688D  bl 0x82cf17a8
	ctx.lr = 0x82CFAF20;
	sub_82CF17A8(ctx, base);
	// 82CFAF20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAF24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAF28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAF2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFAF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFAF30 size=216
    let mut pc: u32 = 0x82CFAF30;
    'dispatch: loop {
        match pc {
            0x82CFAF30 => {
    //   block [0x82CFAF30..0x82CFB008)
	// 82CFAF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFAF34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFAF38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFAF3C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFAF40: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFAF44: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFAF48: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFAF4C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFAF50: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFAF54: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFAF58: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFAF5C: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFAF60: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFAF64: 54CA07BE  clrlwi r10, r6, 0x1e
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 82CFAF68: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFAF6C: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFAF70: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFAF74: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFAF78: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFAF7C: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFAF80: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFAF84: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFAF88: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFAF8C: 409A0064  bne cr6, 0x82cfaff0
	if !ctx.cr[6].eq {
	pc = 0x82CFAFF0; continue 'dispatch;
	}
	// 82CFAF90: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFAF94: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAF98: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFAF9C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFAFA0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFAFA4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAFA8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFAFAC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFAFB0: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFAFB4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFAFB8: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFAFBC: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFAFC0: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFAFC4: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFAFC8: 40990028  ble cr6, 0x82cfaff0
	if !ctx.cr[6].gt {
	pc = 0x82CFAFF0; continue 'dispatch;
	}
	// 82CFAFCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFAFD0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFAFD4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFAFD8: 41980018  blt cr6, 0x82cfaff0
	if ctx.cr[6].lt {
	pc = 0x82CFAFF0; continue 'dispatch;
	}
	// 82CFAFDC: 4BFF380D  bl 0x82cee7e8
	ctx.lr = 0x82CFAFE0;
	sub_82CEE7E8(ctx, base);
	// 82CFAFE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAFE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFAFE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFAFEC: 4E800020  blr
	return;
	// 82CFAFF0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFAFF4: 4BFF6BAD  bl 0x82cf1ba0
	ctx.lr = 0x82CFAFF8;
	sub_82CF1BA0(ctx, base);
	// 82CFAFF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFAFFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB008 size=216
    let mut pc: u32 = 0x82CFB008;
    'dispatch: loop {
        match pc {
            0x82CFB008 => {
    //   block [0x82CFB008..0x82CFB0E0)
	// 82CFB008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB00C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB010: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB014: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB018: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB01C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB020: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB024: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB028: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB02C: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB030: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB034: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB038: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB03C: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB040: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB044: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB048: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB04C: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB050: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB054: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB058: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB05C: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB060: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB064: 409A0064  bne cr6, 0x82cfb0c8
	if !ctx.cr[6].eq {
	pc = 0x82CFB0C8; continue 'dispatch;
	}
	// 82CFB068: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB06C: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB070: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB074: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB078: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB07C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB080: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB084: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB088: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB08C: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB090: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB094: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB098: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB09C: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB0A0: 40990028  ble cr6, 0x82cfb0c8
	if !ctx.cr[6].gt {
	pc = 0x82CFB0C8; continue 'dispatch;
	}
	// 82CFB0A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB0A8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB0AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB0B0: 41980018  blt cr6, 0x82cfb0c8
	if ctx.cr[6].lt {
	pc = 0x82CFB0C8; continue 'dispatch;
	}
	// 82CFB0B4: 4BFF2135  bl 0x82ced1e8
	ctx.lr = 0x82CFB0B8;
	sub_82CED1E8(ctx, base);
	// 82CFB0B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB0BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB0C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB0C4: 4E800020  blr
	return;
	// 82CFB0C8: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB0CC: 4BFF737D  bl 0x82cf2448
	ctx.lr = 0x82CFB0D0;
	sub_82CF2448(ctx, base);
	// 82CFB0D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB0D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB0D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB0DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB0E0 size=216
    let mut pc: u32 = 0x82CFB0E0;
    'dispatch: loop {
        match pc {
            0x82CFB0E0 => {
    //   block [0x82CFB0E0..0x82CFB1B8)
	// 82CFB0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB0E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB0E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB0EC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB0F0: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB0F4: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB0F8: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB0FC: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB100: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB104: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB108: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB10C: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB110: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB114: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB118: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB11C: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB120: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB124: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB128: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB12C: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB130: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB134: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB138: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB13C: 409A0064  bne cr6, 0x82cfb1a0
	if !ctx.cr[6].eq {
	pc = 0x82CFB1A0; continue 'dispatch;
	}
	// 82CFB140: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB144: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB148: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB14C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB150: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB154: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB158: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB15C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB160: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB164: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB168: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB16C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB170: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB174: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB178: 40990028  ble cr6, 0x82cfb1a0
	if !ctx.cr[6].gt {
	pc = 0x82CFB1A0; continue 'dispatch;
	}
	// 82CFB17C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB180: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB184: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB188: 41980018  blt cr6, 0x82cfb1a0
	if ctx.cr[6].lt {
	pc = 0x82CFB1A0; continue 'dispatch;
	}
	// 82CFB18C: 4BFF22C5  bl 0x82ced450
	ctx.lr = 0x82CFB190;
	sub_82CED450(ctx, base);
	// 82CFB190: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB194: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB198: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB19C: 4E800020  blr
	return;
	// 82CFB1A0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB1A4: 4BFF75BD  bl 0x82cf2760
	ctx.lr = 0x82CFB1A8;
	sub_82CF2760(ctx, base);
	// 82CFB1A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB1AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB1B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB1B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB1B8 size=216
    let mut pc: u32 = 0x82CFB1B8;
    'dispatch: loop {
        match pc {
            0x82CFB1B8 => {
    //   block [0x82CFB1B8..0x82CFB290)
	// 82CFB1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB1BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB1C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB1C4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB1C8: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB1CC: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB1D0: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB1D4: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB1D8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB1DC: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB1E0: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB1E4: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB1E8: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB1EC: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB1F0: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB1F4: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB1F8: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB1FC: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB200: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB204: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB208: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB20C: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB210: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB214: 409A0064  bne cr6, 0x82cfb278
	if !ctx.cr[6].eq {
	pc = 0x82CFB278; continue 'dispatch;
	}
	// 82CFB218: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB21C: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB220: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB224: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB228: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB22C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB230: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB234: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB238: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB23C: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB240: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB244: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB248: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB24C: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB250: 40990028  ble cr6, 0x82cfb278
	if !ctx.cr[6].gt {
	pc = 0x82CFB278; continue 'dispatch;
	}
	// 82CFB254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB258: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB25C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB260: 41980018  blt cr6, 0x82cfb278
	if ctx.cr[6].lt {
	pc = 0x82CFB278; continue 'dispatch;
	}
	// 82CFB264: 4BFF24BD  bl 0x82ced720
	ctx.lr = 0x82CFB268;
	sub_82CED720(ctx, base);
	// 82CFB268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB274: 4E800020  blr
	return;
	// 82CFB278: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB27C: 4BFF787D  bl 0x82cf2af8
	ctx.lr = 0x82CFB280;
	sub_82CF2AF8(ctx, base);
	// 82CFB280: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB28C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB290 size=216
    let mut pc: u32 = 0x82CFB290;
    'dispatch: loop {
        match pc {
            0x82CFB290 => {
    //   block [0x82CFB290..0x82CFB368)
	// 82CFB290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB298: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB29C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB2A0: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB2A4: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB2A8: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB2AC: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB2B0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB2B4: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB2B8: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB2BC: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB2C0: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB2C4: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB2C8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB2CC: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB2D0: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB2D4: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB2D8: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB2DC: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB2E0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB2E4: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB2E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB2EC: 409A0064  bne cr6, 0x82cfb350
	if !ctx.cr[6].eq {
	pc = 0x82CFB350; continue 'dispatch;
	}
	// 82CFB2F0: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB2F4: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB2F8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB2FC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB300: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB304: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB308: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB30C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB310: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB314: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB318: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB31C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB320: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB324: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB328: 40990028  ble cr6, 0x82cfb350
	if !ctx.cr[6].gt {
	pc = 0x82CFB350; continue 'dispatch;
	}
	// 82CFB32C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB330: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB334: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB338: 41980018  blt cr6, 0x82cfb350
	if ctx.cr[6].lt {
	pc = 0x82CFB350; continue 'dispatch;
	}
	// 82CFB33C: 4BFF2785  bl 0x82cedac0
	ctx.lr = 0x82CFB340;
	sub_82CEDAC0(ctx, base);
	// 82CFB340: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB344: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB348: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB34C: 4E800020  blr
	return;
	// 82CFB350: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB354: 4BFF7C6D  bl 0x82cf2fc0
	ctx.lr = 0x82CFB358;
	sub_82CF2FC0(ctx, base);
	// 82CFB358: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB35C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB368 size=208
    let mut pc: u32 = 0x82CFB368;
    'dispatch: loop {
        match pc {
            0x82CFB368 => {
    //   block [0x82CFB368..0x82CFB438)
	// 82CFB368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB370: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB374: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB378: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB37C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB380: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB384: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB388: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB38C: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB390: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB394: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB398: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB39C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB3A0: 7D4321D6  mullw r10, r3, r4
	ctx.r[10].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB3A4: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB3A8: 7CC82B78  or r8, r6, r5
	ctx.r[8].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82CFB3AC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB3B0: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82CFB3B4: 7C844850  subf r4, r4, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CFB3B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFB3BC: 409A0064  bne cr6, 0x82cfb420
	if !ctx.cr[6].eq {
	pc = 0x82CFB420; continue 'dispatch;
	}
	// 82CFB3C0: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB3C4: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB3C8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB3CC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB3D0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB3D4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB3D8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB3DC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB3E0: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB3E4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB3E8: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB3EC: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB3F0: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB3F4: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB3F8: 40990028  ble cr6, 0x82cfb420
	if !ctx.cr[6].gt {
	pc = 0x82CFB420; continue 'dispatch;
	}
	// 82CFB3FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB400: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB404: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB408: 41980018  blt cr6, 0x82cfb420
	if ctx.cr[6].lt {
	pc = 0x82CFB420; continue 'dispatch;
	}
	// 82CFB40C: 4BFF36ED  bl 0x82ceeaf8
	ctx.lr = 0x82CFB410;
	sub_82CEEAF8(ctx, base);
	// 82CFB410: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB41C: 4E800020  blr
	return;
	// 82CFB420: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB424: 4BFF856D  bl 0x82cf3990
	ctx.lr = 0x82CFB428;
	sub_82CF3990(ctx, base);
	// 82CFB428: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB42C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB430: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB438 size=208
    let mut pc: u32 = 0x82CFB438;
    'dispatch: loop {
        match pc {
            0x82CFB438 => {
    //   block [0x82CFB438..0x82CFB508)
	// 82CFB438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB440: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB444: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB448: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB44C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB450: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB454: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB458: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB45C: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB460: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB464: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB468: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB46C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB470: 7D4321D6  mullw r10, r3, r4
	ctx.r[10].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB474: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB478: 7CC82B78  or r8, r6, r5
	ctx.r[8].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82CFB47C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB480: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82CFB484: 7C844850  subf r4, r4, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CFB488: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFB48C: 409A0064  bne cr6, 0x82cfb4f0
	if !ctx.cr[6].eq {
	pc = 0x82CFB4F0; continue 'dispatch;
	}
	// 82CFB490: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB494: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB498: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB49C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB4A0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB4A4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB4A8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB4AC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB4B0: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB4B4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB4B8: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB4BC: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB4C0: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB4C4: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB4C8: 40990028  ble cr6, 0x82cfb4f0
	if !ctx.cr[6].gt {
	pc = 0x82CFB4F0; continue 'dispatch;
	}
	// 82CFB4CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB4D0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB4D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB4D8: 41980018  blt cr6, 0x82cfb4f0
	if ctx.cr[6].lt {
	pc = 0x82CFB4F0; continue 'dispatch;
	}
	// 82CFB4DC: 4BFF3935  bl 0x82ceee10
	ctx.lr = 0x82CFB4E0;
	sub_82CEEE10(ctx, base);
	// 82CFB4E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB4E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB4E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB4EC: 4E800020  blr
	return;
	// 82CFB4F0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB4F4: 4BFF87D5  bl 0x82cf3cc8
	ctx.lr = 0x82CFB4F8;
	sub_82CF3CC8(ctx, base);
	// 82CFB4F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB4FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB508 size=208
    let mut pc: u32 = 0x82CFB508;
    'dispatch: loop {
        match pc {
            0x82CFB508 => {
    //   block [0x82CFB508..0x82CFB5D8)
	// 82CFB508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB510: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB514: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB518: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB51C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB520: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB524: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB528: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB52C: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB530: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB534: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB538: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB53C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB540: 7D4321D6  mullw r10, r3, r4
	ctx.r[10].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB544: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB548: 7CC82B78  or r8, r6, r5
	ctx.r[8].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82CFB54C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB550: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82CFB554: 7C844850  subf r4, r4, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CFB558: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFB55C: 409A0064  bne cr6, 0x82cfb5c0
	if !ctx.cr[6].eq {
	pc = 0x82CFB5C0; continue 'dispatch;
	}
	// 82CFB560: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB564: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB568: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB56C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB570: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB574: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB578: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB57C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB580: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB584: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB588: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB58C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB590: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB594: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB598: 40990028  ble cr6, 0x82cfb5c0
	if !ctx.cr[6].gt {
	pc = 0x82CFB5C0; continue 'dispatch;
	}
	// 82CFB59C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB5A0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB5A4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB5A8: 41980018  blt cr6, 0x82cfb5c0
	if ctx.cr[6].lt {
	pc = 0x82CFB5C0; continue 'dispatch;
	}
	// 82CFB5AC: 4BFF3C55  bl 0x82cef200
	ctx.lr = 0x82CFB5B0;
	sub_82CEF200(ctx, base);
	// 82CFB5B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB5B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB5B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB5BC: 4E800020  blr
	return;
	// 82CFB5C0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB5C4: 4BFF8ADD  bl 0x82cf40a0
	ctx.lr = 0x82CFB5C8;
	sub_82CF40A0(ctx, base);
	// 82CFB5C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB5CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB5D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB5D8 size=208
    let mut pc: u32 = 0x82CFB5D8;
    'dispatch: loop {
        match pc {
            0x82CFB5D8 => {
    //   block [0x82CFB5D8..0x82CFB6A8)
	// 82CFB5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB5E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB5E4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB5E8: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB5EC: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB5F0: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB5F4: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB5F8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB5FC: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB600: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB604: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB608: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB60C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB610: 7D4321D6  mullw r10, r3, r4
	ctx.r[10].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB614: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB618: 7CC82B78  or r8, r6, r5
	ctx.r[8].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82CFB61C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB620: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82CFB624: 7C844850  subf r4, r4, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82CFB628: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82CFB62C: 409A0064  bne cr6, 0x82cfb690
	if !ctx.cr[6].eq {
	pc = 0x82CFB690; continue 'dispatch;
	}
	// 82CFB630: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB634: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB638: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB63C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB640: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB644: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB648: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB64C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB650: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB654: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB658: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB65C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB660: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB664: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB668: 40990028  ble cr6, 0x82cfb690
	if !ctx.cr[6].gt {
	pc = 0x82CFB690; continue 'dispatch;
	}
	// 82CFB66C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB670: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB674: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB678: 41980018  blt cr6, 0x82cfb690
	if ctx.cr[6].lt {
	pc = 0x82CFB690; continue 'dispatch;
	}
	// 82CFB67C: 4BFF4175  bl 0x82cef7f0
	ctx.lr = 0x82CFB680;
	sub_82CEF7F0(ctx, base);
	// 82CFB680: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB68C: 4E800020  blr
	return;
	// 82CFB690: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB694: 4BFF8F2D  bl 0x82cf45c0
	ctx.lr = 0x82CFB698;
	sub_82CF45C0(ctx, base);
	// 82CFB698: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB69C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB6A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB6A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB6A8 size=216
    let mut pc: u32 = 0x82CFB6A8;
    'dispatch: loop {
        match pc {
            0x82CFB6A8 => {
    //   block [0x82CFB6A8..0x82CFB780)
	// 82CFB6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB6B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB6B4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB6B8: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB6BC: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB6C0: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB6C4: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB6C8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB6CC: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB6D0: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB6D4: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB6D8: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB6DC: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB6E0: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB6E4: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB6E8: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB6EC: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB6F0: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB6F4: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB6F8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB6FC: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB700: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB704: 409A0064  bne cr6, 0x82cfb768
	if !ctx.cr[6].eq {
	pc = 0x82CFB768; continue 'dispatch;
	}
	// 82CFB708: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB70C: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB710: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB714: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB718: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB71C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB720: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB724: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB728: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB72C: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB730: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB734: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB738: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB73C: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB740: 40990028  ble cr6, 0x82cfb768
	if !ctx.cr[6].gt {
	pc = 0x82CFB768; continue 'dispatch;
	}
	// 82CFB744: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB748: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB74C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB750: 41980018  blt cr6, 0x82cfb768
	if ctx.cr[6].lt {
	pc = 0x82CFB768; continue 'dispatch;
	}
	// 82CFB754: 4BFF48ED  bl 0x82cf0040
	ctx.lr = 0x82CFB758;
	sub_82CF0040(ctx, base);
	// 82CFB758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB75C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB764: 4E800020  blr
	return;
	// 82CFB768: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB76C: 4BFF98AD  bl 0x82cf5018
	ctx.lr = 0x82CFB770;
	sub_82CF5018(ctx, base);
	// 82CFB770: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB77C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB780 size=216
    let mut pc: u32 = 0x82CFB780;
    'dispatch: loop {
        match pc {
            0x82CFB780 => {
    //   block [0x82CFB780..0x82CFB858)
	// 82CFB780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB788: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB78C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB790: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB794: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB798: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB79C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB7A0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB7A4: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB7A8: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB7AC: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB7B0: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB7B4: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB7B8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB7BC: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB7C0: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB7C4: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB7C8: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB7CC: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB7D0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB7D4: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB7D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB7DC: 409A0064  bne cr6, 0x82cfb840
	if !ctx.cr[6].eq {
	pc = 0x82CFB840; continue 'dispatch;
	}
	// 82CFB7E0: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB7E4: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB7E8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB7EC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB7F0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB7F4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB7F8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB7FC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB800: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB804: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB808: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB80C: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB810: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB814: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB818: 40990028  ble cr6, 0x82cfb840
	if !ctx.cr[6].gt {
	pc = 0x82CFB840; continue 'dispatch;
	}
	// 82CFB81C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB820: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB824: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB828: 41980018  blt cr6, 0x82cfb840
	if ctx.cr[6].lt {
	pc = 0x82CFB840; continue 'dispatch;
	}
	// 82CFB82C: 4BFF4A9D  bl 0x82cf02c8
	ctx.lr = 0x82CFB830;
	sub_82CF02C8(ctx, base);
	// 82CFB830: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB834: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB838: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB83C: 4E800020  blr
	return;
	// 82CFB840: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB844: 4BFF9B05  bl 0x82cf5348
	ctx.lr = 0x82CFB848;
	sub_82CF5348(ctx, base);
	// 82CFB848: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB84C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB854: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB858 size=216
    let mut pc: u32 = 0x82CFB858;
    'dispatch: loop {
        match pc {
            0x82CFB858 => {
    //   block [0x82CFB858..0x82CFB930)
	// 82CFB858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB860: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB864: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB868: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB86C: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB870: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB874: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB878: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB87C: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB880: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB884: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB888: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB88C: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB890: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB894: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB898: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB89C: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB8A0: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB8A4: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB8A8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB8AC: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB8B0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB8B4: 409A0064  bne cr6, 0x82cfb918
	if !ctx.cr[6].eq {
	pc = 0x82CFB918; continue 'dispatch;
	}
	// 82CFB8B8: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB8BC: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB8C0: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB8C4: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB8C8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB8CC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB8D0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB8D4: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB8D8: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB8DC: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB8E0: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB8E4: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB8E8: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB8EC: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB8F0: 40990028  ble cr6, 0x82cfb918
	if !ctx.cr[6].gt {
	pc = 0x82CFB918; continue 'dispatch;
	}
	// 82CFB8F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB8F8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB8FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB900: 41980018  blt cr6, 0x82cfb918
	if ctx.cr[6].lt {
	pc = 0x82CFB918; continue 'dispatch;
	}
	// 82CFB904: 4BFF4CAD  bl 0x82cf05b0
	ctx.lr = 0x82CFB908;
	sub_82CF05B0(ctx, base);
	// 82CFB908: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB90C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB910: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB914: 4E800020  blr
	return;
	// 82CFB918: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB91C: 4BFF9DED  bl 0x82cf5708
	ctx.lr = 0x82CFB920;
	sub_82CF5708(ctx, base);
	// 82CFB920: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB92C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFB930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFB930 size=216
    let mut pc: u32 = 0x82CFB930;
    'dispatch: loop {
        match pc {
            0x82CFB930 => {
    //   block [0x82CFB930..0x82CFBA08)
	// 82CFB930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFB934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82CFB938: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFB93C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82CFB940: 8127001C  lwz r9, 0x1c(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFB944: C1A70030  lfs f13, 0x30(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFB948: 81070018  lwz r8, 0x18(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFB94C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFB950: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB954: 7CC94050  subf r6, r9, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82CFB958: 80870008  lwz r4, 8(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFB95C: 8867000D  lbz r3, 0xd(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFB960: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB964: 54CA077E  clrlwi r10, r6, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x00000007u64;
	// 82CFB968: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFB96C: 7D2321D6  mullw r9, r3, r4
	ctx.r[9].s64 = (ctx.r[3].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82CFB970: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFB974: 7D432B78  or r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82CFB978: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFB97C: 5469073E  clrlwi r9, r3, 0x1c
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 82CFB980: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82CFB984: 7C844050  subf r4, r4, r8
	ctx.r[4].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 82CFB988: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82CFB98C: 409A0064  bne cr6, 0x82cfb9f0
	if !ctx.cr[6].eq {
	pc = 0x82CFB9F0; continue 'dispatch;
	}
	// 82CFB990: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82CFB994: C007002C  lfs f0, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB998: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFB99C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82CFB9A0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82CFB9A4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB9A8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82CFB9AC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82CFB9B0: FD40669C  fcfid f10, f12
	ctx.f[10].f64 = (ctx.f[12].s64 as f64);
	// 82CFB9B4: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82CFB9B8: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82CFB9BC: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82CFB9C0: ECC06A3A  fmadds f6, f0, f8, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82CFB9C4: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82CFB9C8: 40990028  ble cr6, 0x82cfb9f0
	if !ctx.cr[6].gt {
	pc = 0x82CFB9F0; continue 'dispatch;
	}
	// 82CFB9CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82CFB9D0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFB9D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82CFB9D8: 41980018  blt cr6, 0x82cfb9f0
	if ctx.cr[6].lt {
	pc = 0x82CFB9F0; continue 'dispatch;
	}
	// 82CFB9DC: 4BFF4F95  bl 0x82cf0970
	ctx.lr = 0x82CFB9E0;
	sub_82CF0970(ctx, base);
	// 82CFB9E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFB9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFB9EC: 4E800020  blr
	return;
	// 82CFB9F0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82CFB9F4: 4BFFA22D  bl 0x82cf5c20
	ctx.lr = 0x82CFB9F8;
	sub_82CF5C20(ctx, base);
	// 82CFB9F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82CFB9FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82CFBA00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82CFBA04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFBA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFBA08 size=448
    let mut pc: u32 = 0x82CFBA08;
    'dispatch: loop {
        match pc {
            0x82CFBA08 => {
    //   block [0x82CFBA08..0x82CFBBC8)
	// 82CFBA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFBA0C: 4BFAD9FD  bl 0x82ca9408
	ctx.lr = 0x82CFBA10;
	sub_82CA93D0(ctx, base);
	// 82CFBA10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFBA14: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFBA18: 8BC3000D  lbz r30, 0xd(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFBA1C: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFBA20: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFBA24: 7CFE51D6  mullw r7, r30, r10
	ctx.r[7].s64 = (ctx.r[30].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CFBA28: 83A30018  lwz r29, 0x18(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFBA2C: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFBA30: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFBA34: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFBA38: 7D4AF850  subf r10, r10, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82CFBA3C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFBA40: 7CC8E850  subf r6, r8, r29
	ctx.r[6].s64 = ctx.r[29].s64 - ctx.r[8].s64;
	// 82CFBA44: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82CFBA48: 7D292214  add r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 82CFBA4C: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CFBA50: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82CFBA54: 41980008  blt cr6, 0x82cfba5c
	if ctx.cr[6].lt {
	pc = 0x82CFBA5C; continue 'dispatch;
	}
	// 82CFBA58: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82CFBA5C: 54EA077E  clrlwi r10, r7, 0x1d
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 82CFBA60: 7D484B78  or r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82CFBA64: 7D0A5B78  or r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 82CFBA68: 5548073E  clrlwi r8, r10, 0x1c
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82CFBA6C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CFBA70: 419A0010  beq cr6, 0x82cfba80
	if ctx.cr[6].eq {
	pc = 0x82CFBA80; continue 'dispatch;
	}
	// 82CFBA74: 4BFFA955  bl 0x82cf63c8
	ctx.lr = 0x82CFBA78;
	sub_82CF63C8(ctx, base);
	// 82CFBA78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CFBA7C: 4BFAD9DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82CFBA80: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBA84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82CFBA88: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CFBA8C: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBA90: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CFBA94: 419A0018  beq cr6, 0x82cfbaac
	if ctx.cr[6].eq {
	pc = 0x82CFBAAC; continue 'dispatch;
	}
	// 82CFBA98: 555C3830  slwi r28, r10, 7
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82CFBA9C: 7C1C5A2C  dcbt r28, r11
	// 82CFBAA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82CFBAA4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFBAA8: 4198FFF0  blt cr6, 0x82cfba98
	if ctx.cr[6].lt {
	pc = 0x82CFBA98; continue 'dispatch;
	}
	// 82CFBAAC: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82CFBAB0: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFBAB4: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBAB8: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFBABC: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82CFBAC0: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBAC4: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFBAC8: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFBACC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82CFBAD0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFBAD4: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFBAD8: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBADC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82CFBAE0: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82CFBAE4: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82CFBAE8: C18A0A4C  lfs f12, 0xa4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFBAEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82CFBAF0: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFBAF4: 394A6880  addi r10, r10, 0x6880
	ctx.r[10].s64 = ctx.r[10].s64 + 26752;
	// 82CFBAF8: 13E0E407  vcmpneb. (lvlx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFBBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFBBC8 size=528
    let mut pc: u32 = 0x82CFBBC8;
    'dispatch: loop {
        match pc {
            0x82CFBBC8 => {
    //   block [0x82CFBBC8..0x82CFBDD8)
	// 82CFBBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFBBCC: 4BFAD839  bl 0x82ca9404
	ctx.lr = 0x82CFBBD0;
	sub_82CA93D0(ctx, base);
	// 82CFBBD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFBBD4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFBBD8: 8B83000D  lbz r28, 0xd(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFBBDC: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFBBE0: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFBBE4: 7CFC51D6  mullw r7, r28, r10
	ctx.r[7].s64 = (ctx.r[28].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82CFBBE8: 83630018  lwz r27, 0x18(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFBBEC: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFBBF0: 83C30014  lwz r30, 0x14(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFBBF4: 7D2AE850  subf r9, r10, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[10].s64;
	// 82CFBBF8: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82CFBBFC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBC00: 7CC8D850  subf r6, r8, r27
	ctx.r[6].s64 = ctx.r[27].s64 - ctx.r[8].s64;
	// 82CFBC04: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82CFBC08: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82CFBC0C: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82CFBC10: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 82CFBC14: 41980008  blt cr6, 0x82cfbc1c
	if ctx.cr[6].lt {
	pc = 0x82CFBC1C; continue 'dispatch;
	}
	// 82CFBC18: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82CFBC1C: 54E9077E  clrlwi r9, r7, 0x1d
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 82CFBC20: 7D285378  or r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82CFBC24: 7D055B78  or r5, r8, r11
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 82CFBC28: 54A4073E  clrlwi r4, r5, 0x1c
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 82CFBC2C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFBC30: 419A0010  beq cr6, 0x82cfbc40
	if ctx.cr[6].eq {
	pc = 0x82CFBC40; continue 'dispatch;
	}
	// 82CFBC34: 4BFFA8B5  bl 0x82cf64e8
	ctx.lr = 0x82CFBC38;
	sub_82CF64E8(ctx, base);
	// 82CFBC38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82CFBC3C: 4BFAD818  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82CFBC40: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBC44: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82CFBC48: 3908007F  addi r8, r8, 0x7f
	ctx.r[8].s64 = ctx.r[8].s64 + 127;
	// 82CFBC4C: 5508C9FE  srwi r8, r8, 7
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(7);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBC50: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82CFBC54: 419A0018  beq cr6, 0x82cfbc6c
	if ctx.cr[6].eq {
	pc = 0x82CFBC6C; continue 'dispatch;
	}
	// 82CFBC58: 55253830  slwi r5, r9, 7
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82CFBC5C: 7C055A2C  dcbt r5, r11
	// 82CFBC60: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82CFBC64: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82CFBC68: 4198FFF0  blt cr6, 0x82cfbc58
	if ctx.cr[6].lt {
	pc = 0x82CFBC58; continue 'dispatch;
	}
	// 82CFBC6C: 7CC907B4  extsw r9, r6
	ctx.r[9].s64 = ctx.r[6].s32 as i64;
	// 82CFBC70: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFBC74: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82CFBC78: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFBC7C: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82CFBC80: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBC84: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82CFBC88: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFBC8C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFBC90: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFBC94: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFBC98: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBC9C: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82CFBCA0: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82CFBCA4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CFBCA8: C1850A4C  lfs f12, 0xa4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFBCAC: 38A66880  addi r5, r6, 0x6880
	ctx.r[5].s64 = ctx.r[6].s64 + 26752;
	// 82CFBCB0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82CFBCB4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82CFBCB8: 13E04407  vcmpneb. (lvlx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82CFBDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82CFBDD8 size=832
    let mut pc: u32 = 0x82CFBDD8;
    'dispatch: loop {
        match pc {
            0x82CFBDD8 => {
    //   block [0x82CFBDD8..0x82CFC118)
	// 82CFBDD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82CFBDDC: 4BFAD601  bl 0x82ca93dc
	ctx.lr = 0x82CFBDE0;
	sub_82CA93D0(ctx, base);
	// 82CFBDE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82CFBDE4: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82CFBDE8: 8923000D  lbz r9, 0xd(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 82CFBDEC: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82CFBDF0: 80E30018  lwz r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82CFBDF4: 7D2931D6  mullw r9, r9, r6
	ctx.r[9].s64 = (ctx.r[9].s32 as i64) * (ctx.r[6].s32 as i64);
	// 82CFBDF8: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82CFBDFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82CFBE00: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82CFBE04: 906100F4  stw r3, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 82CFBE08: 7D064050  subf r8, r6, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 82CFBE0C: 7CA43850  subf r5, r4, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 82CFBE10: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82CFBE14: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFBE18: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82CFBE1C: 7CE65214  add r7, r6, r10
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 82CFBE20: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82CFBE24: 41980008  blt cr6, 0x82cfbe2c
	if ctx.cr[6].lt {
	pc = 0x82CFBE2C; continue 'dispatch;
	}
	// 82CFBE28: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82CFBE2C: 550B077E  clrlwi r11, r8, 0x1d
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00000007u64;
	// 82CFBE30: 7D6A3B78  or r10, r11, r7
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	// 82CFBE34: 7D464B78  or r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82CFBE38: 54C4073E  clrlwi r4, r6, 0x1c
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x0000000Fu64;
	// 82CFBE3C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82CFBE40: 419A0010  beq cr6, 0x82cfbe50
	if ctx.cr[6].eq {
	pc = 0x82CFBE50; continue 'dispatch;
	}
	// 82CFBE44: 4BFFA90D  bl 0x82cf6750
	ctx.lr = 0x82CFBE48;
	sub_82CF6750(ctx, base);
	// 82CFBE48: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82CFBE4C: 4BFAD5E0  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
	// 82CFBE50: 550A083C  slwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBE54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82CFBE58: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82CFBE5C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBE60: 38CA007F  addi r6, r10, 0x7f
	ctx.r[6].s64 = ctx.r[10].s64 + 127;
	// 82CFBE64: 54CAC9FE  srwi r10, r6, 7
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shr(7);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBE68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82CFBE6C: 419A0018  beq cr6, 0x82cfbe84
	if ctx.cr[6].eq {
	pc = 0x82CFBE84; continue 'dispatch;
	}
	// 82CFBE70: 55663830  slwi r6, r11, 7
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82CFBE74: 7C064A2C  dcbt r6, r9
	// 82CFBE78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82CFBE7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82CFBE80: 4198FFF0  blt cr6, 0x82cfbe70
	if ctx.cr[6].lt {
	pc = 0x82CFBE70; continue 'dispatch;
	}
	// 82CFBE84: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 82CFBE88: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82CFBE8C: 550A083C  slwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82CFBE90: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82CFBE94: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82CFBE98: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBE9C: 7D4607B4  extsw r6, r10
	ctx.r[6].s64 = ctx.r[10].s32 as i64;
	// 82CFBEA0: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82CFBEA4: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82CFBEA8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82CFBEAC: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82CFBEB0: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82CFBEB4: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82CFBEB8: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82CFBEBC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82CFBEC0: C1850A4C  lfs f12, 0xa4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82CFBEC4: 38A66880  addi r5, r6, 0x6880
	ctx.r[5].s64 = ctx.r[6].s64 + 26752;
	// 82CFBEC8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82CFBECC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82CFBED0: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


