pub fn sub_82C4AAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4AAB0 size=1140
    let mut pc: u32 = 0x82C4AAB0;
    'dispatch: loop {
        match pc {
            0x82C4AAB0 => {
    //   block [0x82C4AAB0..0x82C4AF24)
	// 82C4AAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4AAB4: 4805E93D  bl 0x82ca93f0
	ctx.lr = 0x82C4AAB8;
	sub_82CA93D0(ctx, base);
	// 82C4AAB8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4AABC: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82C4AAC0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4AAC4: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82C4AAC8: 419A0450  beq cr6, 0x82c4af18
	if ctx.cr[6].eq {
	pc = 0x82C4AF18; continue 'dispatch;
	}
	// 82C4AACC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4AAD0: 3ADC0004  addi r22, r28, 4
	ctx.r[22].s64 = ctx.r[28].s64 + 4;
	// 82C4AAD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4AAD8: 409A0440  bne cr6, 0x82c4af18
	if !ctx.cr[6].eq {
	pc = 0x82C4AF18; continue 'dispatch;
	}
	// 82C4AADC: 38C04000  li r6, 0x4000
	ctx.r[6].s64 = 16384;
	// 82C4AAE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C4AAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4AAE8: 4BF03909  bl 0x82b4e3f0
	ctx.lr = 0x82C4AAEC;
	sub_82B4E3F0(ctx, base);
	// 82C4AAEC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4AAF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4AAF4: 419A0424  beq cr6, 0x82c4af18
	if ctx.cr[6].eq {
	pc = 0x82C4AF18; continue 'dispatch;
	}
	// 82C4AAF8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82C4AAFC: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82C4AB00: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 82C4AB04: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82C4AB08: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82C4AB0C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82C4AB10: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AB14: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4AB18: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4AB1C: 4E800421  bctrl
	ctx.lr = 0x82C4AB20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AB20: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4AB24: 419803D8  blt cr6, 0x82c4aefc
	if ctx.cr[6].lt {
	pc = 0x82C4AEFC; continue 'dispatch;
	}
	// 82C4AB28: 3D405249  lis r10, 0x5249
	ctx.r[10].s64 = 1380515840;
	// 82C4AB2C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C4AB30: 61494646  ori r9, r10, 0x4646
	ctx.r[9].u64 = ctx.r[10].u64 | 17990;
	// 82C4AB34: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4AB38: 409A0010  bne cr6, 0x82c4ab48
	if !ctx.cr[6].eq {
	pc = 0x82C4AB48; continue 'dispatch;
	}
	// 82C4AB3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4AB40: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4AB44: 48000018  b 0x82c4ab5c
	pc = 0x82C4AB5C; continue 'dispatch;
	// 82C4AB48: 3D405249  lis r10, 0x5249
	ctx.r[10].s64 = 1380515840;
	// 82C4AB4C: 61494658  ori r9, r10, 0x4658
	ctx.r[9].u64 = ctx.r[10].u64 | 18008;
	// 82C4AB50: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4AB54: 409A03A8  bne cr6, 0x82c4aefc
	if !ctx.cr[6].eq {
	pc = 0x82C4AEFC; continue 'dispatch;
	}
	// 82C4AB58: 933C0008  stw r25, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82C4AB5C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4AB60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4AB64: 419A002C  beq cr6, 0x82c4ab90
	if ctx.cr[6].eq {
	pc = 0x82C4AB90; continue 'dispatch;
	}
	// 82C4AB68: 8961006C  lbz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4AB6C: 8941006F  lbz r10, 0x6f(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 82C4AB70: 8921006E  lbz r9, 0x6e(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 82C4AB74: 8901006D  lbz r8, 0x6d(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(109 as u32) ) } as u64;
	// 82C4AB78: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 82C4AB7C: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 82C4AB80: 99210055  stb r9, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[9].u8 ) };
	// 82C4AB84: 99010056  stb r8, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[8].u8 ) };
	// 82C4AB88: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4AB8C: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82C4AB90: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82C4AB94: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82C4AB98: 93210084  stw r25, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[25].u32 ) };
	// 82C4AB9C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4ABA0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82C4ABA4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C4ABA8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4ABAC: 82E1006C  lwz r23, 0x6c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4ABB0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4ABB4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4ABB8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4ABBC: 4E800421  bctrl
	ctx.lr = 0x82C4ABC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4ABC0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4ABC4: 41980338  blt cr6, 0x82c4aefc
	if ctx.cr[6].lt {
	pc = 0x82C4AEFC; continue 'dispatch;
	}
	// 82C4ABC8: 3D605741  lis r11, 0x5741
	ctx.r[11].s64 = 1463877632;
	// 82C4ABCC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C4ABD0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4ABD4: 61695645  ori r9, r11, 0x5645
	ctx.r[9].u64 = ctx.r[11].u64 | 22085;
	// 82C4ABD8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4ABDC: 409A0324  bne cr6, 0x82c4af00
	if !ctx.cr[6].eq {
	pc = 0x82C4AF00; continue 'dispatch;
	}
	// 82C4ABE0: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 82C4ABE4: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82C4ABE8: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82C4ABEC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82C4ABF0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C4ABF4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4ABF8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4ABFC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4AC00: 4E800421  bctrl
	ctx.lr = 0x82C4AC04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AC04: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4AC08: 419802A4  blt cr6, 0x82c4aeac
	if ctx.cr[6].lt {
	pc = 0x82C4AEAC; continue 'dispatch;
	}
	// 82C4AC0C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4AC10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AC14: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4AC18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4AC1C: 4E800421  bctrl
	ctx.lr = 0x82C4AC20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AC20: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AC24: 547B003E  slwi r27, r3, 0
	ctx.r[27].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82C4AC28: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C4AC2C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4AC30: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4AC34: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4AC38: 4E800421  bctrl
	ctx.lr = 0x82C4AC3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AC3C: 80FC0008  lwz r7, 8(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4AC40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4AC44: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C4AC48: 419A002C  beq cr6, 0x82c4ac74
	if ctx.cr[6].eq {
	pc = 0x82C4AC74; continue 'dispatch;
	}
	// 82C4AC4C: 8961006F  lbz r11, 0x6f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 82C4AC50: 8941006D  lbz r10, 0x6d(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(109 as u32) ) } as u64;
	// 82C4AC54: 8921006C  lbz r9, 0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4AC58: 8901006E  lbz r8, 0x6e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 82C4AC5C: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82C4AC60: 99410056  stb r10, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[10].u8 ) };
	// 82C4AC64: 99210057  stb r9, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[9].u8 ) };
	// 82C4AC68: 99010055  stb r8, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[8].u8 ) };
	// 82C4AC6C: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4AC70: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82C4AC74: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82C4AC78: 2B1F0004  cmplwi cr6, r31, 4
	ctx.cr[6].compare_u32(ctx.r[31].u32, 4 as u32, &mut ctx.xer);
	// 82C4AC7C: 409801BC  bge cr6, 0x82c4ae38
	if !ctx.cr[6].lt {
	pc = 0x82C4AE38; continue 'dispatch;
	}
	// 82C4AC80: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AC84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4AC88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4AC8C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4AC90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4AC94: 4E800421  bctrl
	ctx.lr = 0x82C4AC98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AC98: 81380000  lwz r9, 0(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AC9C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C4ACA0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82C4ACA4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82C4ACA8: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4ACAC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4ACB0: 4E800421  bctrl
	ctx.lr = 0x82C4ACB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4ACB4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82C4ACB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C4ACBC: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4ACC0: 4BF07EF9  bl 0x82b52bb8
	ctx.lr = 0x82C4ACC4;
	sub_82B52BB8(ctx, base);
	// 82C4ACC4: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4ACC8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C4ACCC: 7CBE3050  subf r5, r30, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[30].s64;
	// 82C4ACD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4ACD4: 7CA40034  cntlzw r4, r5
	ctx.r[4].u64 = if ctx.r[5].u32 == 0 { 32 } else { ctx.r[5].u32.leading_zeros() as u64 };
	// 82C4ACD8: 549EDFFE  rlwinm r30, r4, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 82C4ACDC: 419A0018  beq cr6, 0x82c4acf4
	if ctx.cr[6].eq {
	pc = 0x82C4ACF4; continue 'dispatch;
	}
	// 82C4ACE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4ACE4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4ACE8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4ACEC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4ACF0: 4E800421  bctrl
	ctx.lr = 0x82C4ACF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4ACF4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C4ACF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4ACFC: 419A0014  beq cr6, 0x82c4ad10
	if ctx.cr[6].eq {
	pc = 0x82C4AD10; continue 'dispatch;
	}
	// 82C4AD00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AD04: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4AD08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4AD0C: 4E800421  bctrl
	ctx.lr = 0x82C4AD10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AD10: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4AD14: 80A1006C  lwz r5, 0x6c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4AD18: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C4AD1C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82C4AD20: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4AD24: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C4AD28: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 82C4AD2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4AD30: 4800C6E1  bl 0x82c57410
	ctx.lr = 0x82C4AD34;
	sub_82C57410(ctx, base);
	// 82C4AD34: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4AD38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4AD3C: 419A01C0  beq cr6, 0x82c4aefc
	if ctx.cr[6].eq {
	pc = 0x82C4AEFC; continue 'dispatch;
	}
	// 82C4AD40: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C4AD44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4AD48: 419A00F0  beq cr6, 0x82c4ae38
	if ctx.cr[6].eq {
	pc = 0x82C4AE38; continue 'dispatch;
	}
	// 82C4AD4C: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82C4AD50: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C4AD54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4AD58: 419A0090  beq cr6, 0x82c4ade8
	if ctx.cr[6].eq {
	pc = 0x82C4ADE8; continue 'dispatch;
	}
	// 82C4AD5C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4AD60: 83A1006C  lwz r29, 0x6c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4AD64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AD68: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4AD6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4AD70: 4E800421  bctrl
	ctx.lr = 0x82C4AD74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AD74: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C4AD78: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82C4AD7C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82C4AD80: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82C4AD84: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82C4AD88: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C4AD8C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C4AD90: 4BF08FD9  bl 0x82b53d68
	ctx.lr = 0x82C4AD94;
	sub_82B53D68(ctx, base);
	// 82C4AD94: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C4AD98: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C4AD9C: 419A004C  beq cr6, 0x82c4ade8
	if ctx.cr[6].eq {
	pc = 0x82C4ADE8; continue 'dispatch;
	}
	// 82C4ADA0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4ADA4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82C4ADA8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4ADAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4ADB0: 4E800421  bctrl
	ctx.lr = 0x82C4ADB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4ADB4: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4ADB8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C4ADBC: 419A0010  beq cr6, 0x82c4adcc
	if ctx.cr[6].eq {
	pc = 0x82C4ADCC; continue 'dispatch;
	}
	// 82C4ADC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4ADC4: 4800C89D  bl 0x82c57660
	ctx.lr = 0x82C4ADC8;
	sub_82C57660(ctx, base);
	// 82C4ADC8: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82C4ADCC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C4ADD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4ADD4: 419A0014  beq cr6, 0x82c4ade8
	if ctx.cr[6].eq {
	pc = 0x82C4ADE8; continue 'dispatch;
	}
	// 82C4ADD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4ADDC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4ADE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4ADE4: 4E800421  bctrl
	ctx.lr = 0x82C4ADE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4ADE8: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82C4ADEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4ADF0: 419A0048  beq cr6, 0x82c4ae38
	if ctx.cr[6].eq {
	pc = 0x82C4AE38; continue 'dispatch;
	}
	// 82C4ADF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4ADF8: 4800C7F1  bl 0x82c575e8
	ctx.lr = 0x82C4ADFC;
	sub_82C575E8(ctx, base);
	// 82C4ADFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C4AE00: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4AE04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4AE08: 419A00F8  beq cr6, 0x82c4af00
	if ctx.cr[6].eq {
	pc = 0x82C4AF00; continue 'dispatch;
	}
	// 82C4AE0C: 9321008C  stw r25, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[25].u32 ) };
	// 82C4AE10: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82C4AE14: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82C4AE18: 80A1006C  lwz r5, 0x6c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4AE1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AE20: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4AE24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4AE28: 4E800421  bctrl
	ctx.lr = 0x82C4AE2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AE2C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4AE30: 419800CC  blt cr6, 0x82c4aefc
	if ctx.cr[6].lt {
	pc = 0x82C4AEFC; continue 'dispatch;
	}
	// 82C4AE34: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82C4AE38: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4AE3C: 39570008  addi r10, r23, 8
	ctx.r[10].s64 = ctx.r[23].s64 + 8;
	// 82C4AE40: 7D3B5A14  add r9, r27, r11
	ctx.r[9].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82C4AE44: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4AE48: 40980064  bge cr6, 0x82c4aeac
	if !ctx.cr[6].lt {
	pc = 0x82C4AEAC; continue 'dispatch;
	}
	// 82C4AE4C: 574A063E  clrlwi r10, r26, 0x18
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82C4AE50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4AE54: 419A0028  beq cr6, 0x82c4ae7c
	if ctx.cr[6].eq {
	pc = 0x82C4AE7C; continue 'dispatch;
	}
	// 82C4AE58: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4AE5C: 79640020  clrldi r4, r11, 0x20
	ctx.r[4].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82C4AE60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C4AE64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AE68: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4AE6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4AE70: 4E800421  bctrl
	ctx.lr = 0x82C4AE74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AE74: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4AE78: 41980084  blt cr6, 0x82c4aefc
	if ctx.cr[6].lt {
	pc = 0x82C4AEFC; continue 'dispatch;
	}
	// 82C4AE7C: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82C4AE80: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 82C4AE84: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4AE88: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82C4AE8C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82C4AE90: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C4AE94: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AE98: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4AE9C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4AEA0: 4E800421  bctrl
	ctx.lr = 0x82C4AEA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AEA4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4AEA8: 4098FD64  bge cr6, 0x82c4ac0c
	if !ctx.cr[6].lt {
	pc = 0x82C4AC0C; continue 'dispatch;
	}
	// 82C4AEAC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82C4AEB0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C4AEB4: 4BC1FEDD  bl 0x8286ad90
	ctx.lr = 0x82C4AEB8;
	sub_8286AD90(ctx, base);
	// 82C4AEB8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AEBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4AEC0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4AEC4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4AEC8: 4E800421  bctrl
	ctx.lr = 0x82C4AECC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AECC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4AED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4AED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4AED8: 419A0018  beq cr6, 0x82c4aef0
	if ctx.cr[6].eq {
	pc = 0x82C4AEF0; continue 'dispatch;
	}
	// 82C4AEDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AEE0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4AEE4: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4AEE8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4AEEC: 4E800421  bctrl
	ctx.lr = 0x82C4AEF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AEF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4AEF4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C4AEF8: 4805E548  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 82C4AEFC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4AF00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4AF04: 419A0014  beq cr6, 0x82c4af18
	if ctx.cr[6].eq {
	pc = 0x82C4AF18; continue 'dispatch;
	}
	// 82C4AF08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AF0C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4AF10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4AF14: 4E800421  bctrl
	ctx.lr = 0x82C4AF18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AF18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4AF1C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C4AF20: 4805E520  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4AF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4AF28 size=76
    let mut pc: u32 = 0x82C4AF28;
    'dispatch: loop {
        match pc {
            0x82C4AF28 => {
    //   block [0x82C4AF28..0x82C4AF74)
	// 82C4AF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4AF2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4AF30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4AF34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4AF38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4AF3C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AF40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4AF44: 419A001C  beq cr6, 0x82c4af60
	if ctx.cr[6].eq {
	pc = 0x82C4AF60; continue 'dispatch;
	}
	// 82C4AF48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AF4C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C4AF50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4AF54: 4E800421  bctrl
	ctx.lr = 0x82C4AF58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4AF58: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C4AF5C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4AF60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4AF64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4AF68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4AF6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4AF70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4AF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4AF78 size=412
    let mut pc: u32 = 0x82C4AF78;
    'dispatch: loop {
        match pc {
            0x82C4AF78 => {
    //   block [0x82C4AF78..0x82C4B114)
	// 82C4AF78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4AF7C: 4805E489  bl 0x82ca9404
	ctx.lr = 0x82C4AF80;
	sub_82CA93D0(ctx, base);
	// 82C4AF80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4AF84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4AF88: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82C4AF8C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C4AF90: 409A0010  bne cr6, 0x82c4afa0
	if !ctx.cr[6].eq {
	pc = 0x82C4AFA0; continue 'dispatch;
	}
	// 82C4AF94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4AF98: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4AF9C: 4805E4B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4AFA0: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82C4AFA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4AFA8: 4BFFFB09  bl 0x82c4aab0
	ctx.lr = 0x82C4AFAC;
	sub_82C4AAB0(ctx, base);
	// 82C4AFAC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4AFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4AFB4: 409A0018  bne cr6, 0x82c4afcc
	if !ctx.cr[6].eq {
	pc = 0x82C4AFCC; continue 'dispatch;
	}
	// 82C4AFB8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82C4AFBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4AFC0: 917F00BC  stw r11, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82C4AFC4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4AFC8: 4805E48C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4AFCC: 4BFB7C65  bl 0x82c02c30
	ctx.lr = 0x82C4AFD0;
	sub_82C02C30(ctx, base);
	// 82C4AFD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C4AFD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4AFD8: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C4AFDC: 995F00BB  stb r10, 0xbb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(187 as u32), ctx.r[10].u8 ) };
	// 82C4AFE0: 4800BC01  bl 0x82c56be0
	ctx.lr = 0x82C4AFE4;
	sub_82C56BE0(ctx, base);
	// 82C4AFE4: 5469083C  slwi r9, r3, 1
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C4AFE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4AFEC: 83BF007C  lwz r29, 0x7c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82C4AFF0: 913F00AC  stw r9, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 82C4AFF4: 4BF07BC5  bl 0x82b52bb8
	ctx.lr = 0x82C4AFF8;
	sub_82B52BB8(ctx, base);
	// 82C4AFF8: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4AFFC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82C4B000: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4B004: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4B008: 80C80020  lwz r6, 0x20(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4B00C: 83A70000  lwz r29, 0(r7)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B010: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C4B014: 4E800421  bctrl
	ctx.lr = 0x82C4B018;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4B018: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B01C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4B020: 7C85E850  subf r4, r5, r29
	ctx.r[4].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 82C4B024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B028: 7C830034  cntlzw r3, r4
	ctx.r[3].u64 = if ctx.r[4].u32 == 0 { 32 } else { ctx.r[4].u32.leading_zeros() as u64 };
	// 82C4B02C: 546ADFFE  rlwinm r10, r3, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 82C4B030: 995F00BA  stb r10, 0xba(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(186 as u32), ctx.r[10].u8 ) };
	// 82C4B034: 419A0018  beq cr6, 0x82c4b04c
	if ctx.cr[6].eq {
	pc = 0x82C4B04C; continue 'dispatch;
	}
	// 82C4B038: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B03C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4B040: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B044: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4B048: 4E800421  bctrl
	ctx.lr = 0x82C4B04C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4B04C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4B050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4B054: 419A0014  beq cr6, 0x82c4b068
	if ctx.cr[6].eq {
	pc = 0x82C4B068; continue 'dispatch;
	}
	// 82C4B058: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B05C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B060: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4B064: 4E800421  bctrl
	ctx.lr = 0x82C4B068;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4B068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B06C: 4800BAFD  bl 0x82c56b68
	ctx.lr = 0x82C4B070;
	sub_82C56B68(ctx, base);
	// 82C4B070: 2B030007  cmplwi cr6, r3, 7
	ctx.cr[6].compare_u32(ctx.r[3].u32, 7 as u32, &mut ctx.xer);
	// 82C4B074: 4199FF44  bgt cr6, 0x82c4afb8
	if ctx.cr[6].gt {
	pc = 0x82C4AFB8; continue 'dispatch;
	}
	// 82C4B078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B07C: 4800BB4D  bl 0x82c56bc8
	ctx.lr = 0x82C4B080;
	sub_82C56BC8(ctx, base);
	// 82C4B080: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C4B084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B088: 4800BB29  bl 0x82c56bb0
	ctx.lr = 0x82C4B08C;
	sub_82C56BB0(ctx, base);
	// 82C4B08C: 897F00BA  lbz r11, 0xba(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(186 as u32) ) } as u64;
	// 82C4B090: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82C4B094: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4B098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B09C: 409A0020  bne cr6, 0x82c4b0bc
	if !ctx.cr[6].eq {
	pc = 0x82C4B0BC; continue 'dispatch;
	}
	// 82C4B0A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4B0A4: 4BFC3575  bl 0x82c0e618
	ctx.lr = 0x82C4B0A8;
	sub_82C0E618(ctx, base);
	// 82C4B0A8: 2B1D0004  cmplwi cr6, r29, 4
	ctx.cr[6].compare_u32(ctx.r[29].u32, 4 as u32, &mut ctx.xer);
	// 82C4B0AC: 4199000C  bgt cr6, 0x82c4b0b8
	if ctx.cr[6].gt {
	pc = 0x82C4B0B8; continue 'dispatch;
	}
	// 82C4B0B0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82C4B0B4: 40990008  ble cr6, 0x82c4b0bc
	if !ctx.cr[6].gt {
	pc = 0x82C4B0BC; continue 'dispatch;
	}
	// 82C4B0B8: 937F0080  stw r27, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 82C4B0BC: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4B0C0: 4BFC3559  bl 0x82c0e618
	ctx.lr = 0x82C4B0C4;
	sub_82C0E618(ctx, base);
	// 82C4B0C4: 7D63E396  divwu r11, r3, r28
	ctx.r[11].u32 = ctx.r[3].u32 / ctx.r[28].u32;
	// 82C4B0C8: 907F009C  stw r3, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[3].u32 ) };
	// 82C4B0CC: 7D4BE1D6  mullw r10, r11, r28
	ctx.r[10].s64 = (ctx.r[11].s32 as i64) * (ctx.r[28].s32 as i64);
	// 82C4B0D0: 7D2A1851  subf. r9, r10, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C4B0D4: 4082FEE4  bne 0x82c4afb8
	if !ctx.cr[0].eq {
	pc = 0x82C4AFB8; continue 'dispatch;
	}
	// 82C4B0D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4B0DC: 38FF00A8  addi r7, r31, 0xa8
	ctx.r[7].s64 = ctx.r[31].s64 + 168;
	// 82C4B0E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C4B0E4: 38DF00A4  addi r6, r31, 0xa4
	ctx.r[6].s64 = ctx.r[31].s64 + 164;
	// 82C4B0E8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82C4B0EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C4B0F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B0F4: 4800BB5D  bl 0x82c56c50
	ctx.lr = 0x82C4B0F8;
	sub_82C56C50(ctx, base);
	// 82C4B0F8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4B0FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4B100: 419AFEB8  beq cr6, 0x82c4afb8
	if ctx.cr[6].eq {
	pc = 0x82C4AFB8; continue 'dispatch;
	}
	// 82C4B104: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4B108: 937F00BC  stw r27, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[27].u32 ) };
	// 82C4B10C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4B110: 4805E344  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B118 size=80
    let mut pc: u32 = 0x82C4B118;
    'dispatch: loop {
        match pc {
            0x82C4B118 => {
    //   block [0x82C4B118..0x82C4B168)
	// 82C4B118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B11C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4B120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4B124: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B128: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4B12C: 3BEB4FE0  addi r31, r11, 0x4fe0
	ctx.r[31].s64 = ctx.r[11].s64 + 20448;
	// 82C4B130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4B134: 4BEFE0ED  bl 0x82b49220
	ctx.lr = 0x82C4B138;
	sub_82B49220(ctx, base);
	// 82C4B138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4B13C: 419A0018  beq cr6, 0x82c4b154
	if ctx.cr[6].eq {
	pc = 0x82C4B154; continue 'dispatch;
	}
	// 82C4B140: 4BFFFE39  bl 0x82c4af78
	ctx.lr = 0x82C4B144;
	sub_82C4AF78(ctx, base);
	// 82C4B144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4B148: 4BEFE0D9  bl 0x82b49220
	ctx.lr = 0x82C4B14C;
	sub_82B49220(ctx, base);
	// 82C4B14C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4B150: 409AFFF0  bne cr6, 0x82c4b140
	if !ctx.cr[6].eq {
	pc = 0x82C4B140; continue 'dispatch;
	}
	// 82C4B154: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4B158: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B15C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4B164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B168 size=188
    let mut pc: u32 = 0x82C4B168;
    'dispatch: loop {
        match pc {
            0x82C4B168 => {
    //   block [0x82C4B168..0x82C4B224)
	// 82C4B168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B16C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4B170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4B174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4B178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B17C: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 82C4B180: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4B184: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82C4B188: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4B18C: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82C4B190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B194: 409A0008  bne cr6, 0x82c4b19c
	if !ctx.cr[6].eq {
	pc = 0x82C4B19C; continue 'dispatch;
	}
	// 82C4B198: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4B19C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B1A0: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C4B1A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4B1A8: 409A0008  bne cr6, 0x82c4b1b0
	if !ctx.cr[6].eq {
	pc = 0x82C4B1B0; continue 'dispatch;
	}
	// 82C4B1AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4B1B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B1B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4B1B8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B1BC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4B1C0: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 82C4B1C4: 419A003C  beq cr6, 0x82c4b200
	if ctx.cr[6].eq {
	pc = 0x82C4B200; continue 'dispatch;
	}
	// 82C4B1C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B1CC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4B1D0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B1D4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4B1D8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B1DC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B1E0: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82C4B1E4: 4BBFA5CD  bl 0x828457b0
	ctx.lr = 0x82C4B1E8;
	sub_828457B0(ctx, base);
	// 82C4B1E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B1EC: E8C10090  ld r6, 0x90(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82C4B1F0: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82C4B1F4: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82C4B1F8: F8DE0000  std r6, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82C4B1FC: 4800000C  b 0x82c4b208
	pc = 0x82C4B208; continue 'dispatch;
	// 82C4B200: E9610090  ld r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82C4B204: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C4B208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B20C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4B210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B218: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4B21C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4B220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B228 size=120
    let mut pc: u32 = 0x82C4B228;
    'dispatch: loop {
        match pc {
            0x82C4B228 => {
    //   block [0x82C4B228..0x82C4B2A0)
	// 82C4B228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B22C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4B230: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4B234: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B238: 3FE08333  lis r31, -0x7ccd
	ctx.r[31].s64 = -2093809664;
	// 82C4B23C: 897F4FD0  lbz r11, 0x4fd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20432 as u32) ) } as u64;
	// 82C4B240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B244: 419A001C  beq cr6, 0x82c4b260
	if ctx.cr[6].eq {
	pc = 0x82C4B260; continue 'dispatch;
	}
	// 82C4B248: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4B24C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4B250: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B254: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B258: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4B25C: 4E800020  blr
	return;
	// 82C4B260: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 82C4B264: 3D6082C5  lis r11, -0x7d3b
	ctx.r[11].s64 = -2101018624;
	// 82C4B268: 392A6230  addi r9, r10, 0x6230
	ctx.r[9].s64 = ctx.r[10].s64 + 25136;
	// 82C4B26C: 396BB118  addi r11, r11, -0x4ee8
	ctx.r[11].s64 = ctx.r[11].s64 + -20200;
	// 82C4B270: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82C4B274: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82C4B278: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4B27C: 4BFC3305  bl 0x82c0e580
	ctx.lr = 0x82C4B280;
	sub_82C0E580(ctx, base);
	// 82C4B280: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4B284: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4B288: 997F4FD0  stb r11, 0x4fd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20432 as u32), ctx.r[11].u8 ) };
	// 82C4B28C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4B290: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B294: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B298: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4B29C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B2A0 size=100
    let mut pc: u32 = 0x82C4B2A0;
    'dispatch: loop {
        match pc {
            0x82C4B2A0 => {
    //   block [0x82C4B2A0..0x82C4B304)
	// 82C4B2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4B2A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4B2AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4B2B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B2B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4B2B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4B2BC: 3FE08333  lis r31, -0x7ccd
	ctx.r[31].s64 = -2093809664;
	// 82C4B2C0: 394BC97C  addi r10, r11, -0x3684
	ctx.r[10].s64 = ctx.r[11].s64 + -13956;
	// 82C4B2C4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4B2C8: 817F4FD4  lwz r11, 0x4fd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20436 as u32) ) } as u64;
	// 82C4B2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B2D0: 409A0010  bne cr6, 0x82c4b2e0
	if !ctx.cr[6].eq {
	pc = 0x82C4B2E0; continue 'dispatch;
	}
	// 82C4B2D4: 4808E8ED  bl 0x82cd9bc0
	ctx.lr = 0x82C4B2D8;
	sub_82CD9BC0(ctx, base);
	// 82C4B2D8: 4BFFFF51  bl 0x82c4b228
	ctx.lr = 0x82C4B2DC;
	sub_82C4B228(ctx, base);
	// 82C4B2DC: 817F4FD4  lwz r11, 0x4fd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20436 as u32) ) } as u64;
	// 82C4B2E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4B2E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B2E8: 917F4FD4  stw r11, 0x4fd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20436 as u32), ctx.r[11].u32 ) };
	// 82C4B2EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4B2F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B2F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B2F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4B2FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4B300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B308 size=68
    let mut pc: u32 = 0x82C4B308;
    'dispatch: loop {
        match pc {
            0x82C4B308 => {
    //   block [0x82C4B308..0x82C4B34C)
	// 82C4B308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4B310: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B314: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82C4B318: 4B5D3F41  bl 0x8221f258
	ctx.lr = 0x82C4B31C;
	sub_8221F258(ctx, base);
	// 82C4B31C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4B320: 419A0018  beq cr6, 0x82c4b338
	if ctx.cr[6].eq {
	pc = 0x82C4B338; continue 'dispatch;
	}
	// 82C4B324: 4BFFFF7D  bl 0x82c4b2a0
	ctx.lr = 0x82C4B328;
	sub_82C4B2A0(ctx, base);
	// 82C4B328: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4B32C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B334: 4E800020  blr
	return;
	// 82C4B338: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4B33C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4B340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B350 size=232
    let mut pc: u32 = 0x82C4B350;
    'dispatch: loop {
        match pc {
            0x82C4B350 => {
    //   block [0x82C4B350..0x82C4B438)
	// 82C4B350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B354: 4805E0B9  bl 0x82ca940c
	ctx.lr = 0x82C4B358;
	sub_82CA93D0(ctx, base);
	// 82C4B358: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B35C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4B360: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4B364: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4B368: 394BC994  addi r10, r11, -0x366c
	ctx.r[10].s64 = ctx.r[11].s64 + -13932;
	// 82C4B36C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C4B370: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82C4B374: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4B378: 4800BB91  bl 0x82c56f08
	ctx.lr = 0x82C4B37C;
	sub_82C56F08(ctx, base);
	// 82C4B37C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C4B380: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C4B384: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82C4B388: 93BF007C  stw r29, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 82C4B38C: 419A0018  beq cr6, 0x82c4b3a4
	if ctx.cr[6].eq {
	pc = 0x82C4B3A4; continue 'dispatch;
	}
	// 82C4B390: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B394: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4B398: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B39C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4B3A0: 4E800421  bctrl
	ctx.lr = 0x82C4B3A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4B3A4: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82C4B3A8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C4B3AC: 4B5D3EAD  bl 0x8221f258
	ctx.lr = 0x82C4B3B0;
	sub_8221F258(ctx, base);
	// 82C4B3B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4B3B4: 419A0008  beq cr6, 0x82c4b3bc
	if ctx.cr[6].eq {
	pc = 0x82C4B3BC; continue 'dispatch;
	}
	// 82C4B3B8: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C4B3BC: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4B3C0: 41820008  beq 0x82c4b3c8
	if ctx.cr[0].eq {
	pc = 0x82C4B3C8; continue 'dispatch;
	}
	// 82C4B3C4: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C4B3C8: 907F0088  stw r3, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 82C4B3CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C4B3D0: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 82C4B3D4: 4B5D3E85  bl 0x8221f258
	ctx.lr = 0x82C4B3D8;
	sub_8221F258(ctx, base);
	// 82C4B3D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4B3DC: 419A0008  beq cr6, 0x82c4b3e4
	if ctx.cr[6].eq {
	pc = 0x82C4B3E4; continue 'dispatch;
	}
	// 82C4B3E0: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C4B3E4: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4B3E8: 41820008  beq 0x82c4b3f0
	if ctx.cr[0].eq {
	pc = 0x82C4B3F0; continue 'dispatch;
	}
	// 82C4B3EC: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C4B3F0: 907F0094  stw r3, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82C4B3F4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82C4B3F8: 93DF0098  stw r30, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82C4B3FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4B400: 93DF009C  stw r30, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 82C4B404: 93DF00A0  stw r30, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 82C4B408: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82C4B40C: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 82C4B410: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 82C4B414: 93DF00B0  stw r30, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 82C4B418: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 82C4B41C: 9BDF00B8  stb r30, 0xb8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u8 ) };
	// 82C4B420: 9BDF00B9  stb r30, 0xb9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(185 as u32), ctx.r[30].u8 ) };
	// 82C4B424: 9BDF00BA  stb r30, 0xba(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(186 as u32), ctx.r[30].u8 ) };
	// 82C4B428: 9BDF00BB  stb r30, 0xbb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(187 as u32), ctx.r[30].u8 ) };
	// 82C4B42C: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 82C4B430: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4B434: 4805E028  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B438 size=392
    let mut pc: u32 = 0x82C4B438;
    'dispatch: loop {
        match pc {
            0x82C4B438 => {
    //   block [0x82C4B438..0x82C4B5C0)
	// 82C4B438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B43C: 4805DFD1  bl 0x82ca940c
	ctx.lr = 0x82C4B440;
	sub_82CA93D0(ctx, base);
	// 82C4B440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4B448: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B44C: 4808F415  bl 0x82cda860
	ctx.lr = 0x82C4B450;
	sub_82CDA860(ctx, base);
	// 82C4B450: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4B454: 41980164  blt cr6, 0x82c4b5b8
	if ctx.cr[6].lt {
	pc = 0x82C4B5B8; continue 'dispatch;
	}
	// 82C4B458: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82C4B45C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B460: 40990078  ble cr6, 0x82c4b4d8
	if !ctx.cr[6].gt {
	pc = 0x82C4B4D8; continue 'dispatch;
	}
	// 82C4B464: 3BDF0084  addi r30, r31, 0x84
	ctx.r[30].s64 = ctx.r[31].s64 + 132;
	// 82C4B468: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B46C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4B470: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B474: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4B478: 409A0008  bne cr6, 0x82c4b480
	if !ctx.cr[6].eq {
	pc = 0x82C4B480; continue 'dispatch;
	}
	// 82C4B47C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4B480: 897F00BB  lbz r11, 0xbb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(187 as u32) ) } as u64;
	// 82C4B484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B488: 419A0014  beq cr6, 0x82c4b49c
	if ctx.cr[6].eq {
	pc = 0x82C4B49C; continue 'dispatch;
	}
	// 82C4B48C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4B490: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C4B494: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B498: 480769C9  bl 0x82cc1e60
	ctx.lr = 0x82C4B49C;
	sub_82CC1E60(ctx, base);
	// 82C4B49C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4B4A0: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B4A4: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4B4A8: 4BFC35E9  bl 0x82c0ea90
	ctx.lr = 0x82C4B4AC;
	sub_82C0EA90(ctx, base);
	// 82C4B4AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B4B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4B4B4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82C4B4B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4B4BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B4C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C4B4C4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4B4C8: 4BFFFCA1  bl 0x82c4b168
	ctx.lr = 0x82C4B4CC;
	sub_82C4B168(ctx, base);
	// 82C4B4CC: 813F008C  lwz r9, 0x8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82C4B4D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4B4D4: 4199FF94  bgt cr6, 0x82c4b468
	if ctx.cr[6].gt {
	pc = 0x82C4B468; continue 'dispatch;
	}
	// 82C4B4D8: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B4DC: 4808F41D  bl 0x82cda8f8
	ctx.lr = 0x82C4B4E0;
	sub_82CDA8F8(ctx, base);
	// 82C4B4E0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4B4E4: 40980014  bge cr6, 0x82c4b4f8
	if !ctx.cr[6].lt {
	pc = 0x82C4B4F8; continue 'dispatch;
	}
	// 82C4B4E8: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B4EC: 4808F625  bl 0x82cdab10
	ctx.lr = 0x82C4B4F0;
	sub_82CDAB10(ctx, base);
	// 82C4B4F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4B4F4: 4805DF68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82C4B4F8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4B4FC: 4800B66D  bl 0x82c56b68
	ctx.lr = 0x82C4B500;
	sub_82C56B68(ctx, base);
	// 82C4B500: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C4B504: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C4B508: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C4B50C: 419A001C  beq cr6, 0x82c4b528
	if ctx.cr[6].eq {
	pc = 0x82C4B528; continue 'dispatch;
	}
	// 82C4B510: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4B514: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B518: 4808EF91  bl 0x82cda4a8
	ctx.lr = 0x82C4B51C;
	sub_82CDA4A8(ctx, base);
	// 82C4B51C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C4B520: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C4B524: 4198FFEC  blt cr6, 0x82c4b510
	if ctx.cr[6].lt {
	pc = 0x82C4B510; continue 'dispatch;
	}
	// 82C4B528: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C4B52C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B530: 40990078  ble cr6, 0x82c4b5a8
	if !ctx.cr[6].gt {
	pc = 0x82C4B5A8; continue 'dispatch;
	}
	// 82C4B534: 3BDF0090  addi r30, r31, 0x90
	ctx.r[30].s64 = ctx.r[31].s64 + 144;
	// 82C4B538: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B53C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4B540: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B544: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4B548: 409A0008  bne cr6, 0x82c4b550
	if !ctx.cr[6].eq {
	pc = 0x82C4B550; continue 'dispatch;
	}
	// 82C4B54C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4B550: 897F00BB  lbz r11, 0xbb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(187 as u32) ) } as u64;
	// 82C4B554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B558: 419A0014  beq cr6, 0x82c4b56c
	if ctx.cr[6].eq {
	pc = 0x82C4B56C; continue 'dispatch;
	}
	// 82C4B55C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4B560: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C4B564: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B568: 480768F9  bl 0x82cc1e60
	ctx.lr = 0x82C4B56C;
	sub_82CC1E60(ctx, base);
	// 82C4B56C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4B570: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B574: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4B578: 4BFC3519  bl 0x82c0ea90
	ctx.lr = 0x82C4B57C;
	sub_82C0EA90(ctx, base);
	// 82C4B57C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82C4B580: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4B588: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4B58C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B590: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C4B594: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4B598: 4BFFFBD1  bl 0x82c4b168
	ctx.lr = 0x82C4B59C;
	sub_82C4B168(ctx, base);
	// 82C4B59C: 813F0098  lwz r9, 0x98(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C4B5A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4B5A4: 4199FF94  bgt cr6, 0x82c4b538
	if ctx.cr[6].gt {
	pc = 0x82C4B538; continue 'dispatch;
	}
	// 82C4B5A8: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B5AC: 4808F565  bl 0x82cdab10
	ctx.lr = 0x82C4B5B0;
	sub_82CDAB10(ctx, base);
	// 82C4B5B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4B5B4: 997F00B8  stb r11, 0xb8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[11].u8 ) };
	// 82C4B5B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4B5BC: 4805DEA0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B5C0 size=80
    let mut pc: u32 = 0x82C4B5C0;
    'dispatch: loop {
        match pc {
            0x82C4B5C0 => {
    //   block [0x82C4B5C0..0x82C4B610)
	// 82C4B5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B5C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4B5C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4B5CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B5D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4B5D4: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B5D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B5DC: 419A0020  beq cr6, 0x82c4b5fc
	if ctx.cr[6].eq {
	pc = 0x82C4B5FC; continue 'dispatch;
	}
	// 82C4B5E0: 4BFFFE59  bl 0x82c4b438
	ctx.lr = 0x82C4B5E4;
	sub_82C4B438(ctx, base);
	// 82C4B5E4: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B5E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4B5EC: 419A0010  beq cr6, 0x82c4b5fc
	if ctx.cr[6].eq {
	pc = 0x82C4B5FC; continue 'dispatch;
	}
	// 82C4B5F0: 4808E7E9  bl 0x82cd9dd8
	ctx.lr = 0x82C4B5F4;
	sub_82CD9DD8(ctx, base);
	// 82C4B5F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4B5F8: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82C4B5FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4B600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B608: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4B60C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B610 size=304
    let mut pc: u32 = 0x82C4B610;
    'dispatch: loop {
        match pc {
            0x82C4B610 => {
    //   block [0x82C4B610..0x82C4B740)
	// 82C4B610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4B618: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4B61C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4B620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B624: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4B628: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 82C4B62C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4B630: 4B5D3C29  bl 0x8221f258
	ctx.lr = 0x82C4B634;
	sub_8221F258(ctx, base);
	// 82C4B634: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4B638: 419A0018  beq cr6, 0x82c4b650
	if ctx.cr[6].eq {
	pc = 0x82C4B650; continue 'dispatch;
	}
	// 82C4B63C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C4B640: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4B644: 4BFFFD0D  bl 0x82c4b350
	ctx.lr = 0x82C4B648;
	sub_82C4B350(ctx, base);
	// 82C4B648: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4B64C: 48000008  b 0x82c4b654
	pc = 0x82C4B654; continue 'dispatch;
	// 82C4B650: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C4B654: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82C4B658: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C4B65C: 419A00B0  beq cr6, 0x82c4b70c
	if ctx.cr[6].eq {
	pc = 0x82C4B70C; continue 'dispatch;
	}
	// 82C4B660: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B664: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4B668: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4B66C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4B670: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4B674: 4E800421  bctrl
	ctx.lr = 0x82C4B678;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4B678: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C4B67C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4B680: 83E90000  lwz r31, 0(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B684: 4BF07535  bl 0x82b52bb8
	ctx.lr = 0x82C4B688;
	sub_82B52BB8(ctx, base);
	// 82C4B688: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B68C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4B690: 7CFF4050  subf r7, r31, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[31].s64;
	// 82C4B694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B698: 7CE60034  cntlzw r6, r7
	ctx.r[6].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 82C4B69C: 54DFDFFE  rlwinm r31, r6, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 82C4B6A0: 419A0018  beq cr6, 0x82c4b6b8
	if ctx.cr[6].eq {
	pc = 0x82C4B6B8; continue 'dispatch;
	}
	// 82C4B6A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B6A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4B6AC: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B6B0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4B6B4: 4E800421  bctrl
	ctx.lr = 0x82C4B6B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4B6B8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C4B6BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4B6C0: 419A0014  beq cr6, 0x82c4b6d4
	if ctx.cr[6].eq {
	pc = 0x82C4B6D4; continue 'dispatch;
	}
	// 82C4B6C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B6C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B6CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4B6D0: 4E800421  bctrl
	ctx.lr = 0x82C4B6D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4B6D4: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82C4B6D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B6DC: 419A0038  beq cr6, 0x82c4b714
	if ctx.cr[6].eq {
	pc = 0x82C4B714; continue 'dispatch;
	}
	// 82C4B6E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B6E4: 4BFFF895  bl 0x82c4af78
	ctx.lr = 0x82C4B6E8;
	sub_82C4AF78(ctx, base);
	// 82C4B6E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4B6EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4B6F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B6F4: 419A0014  beq cr6, 0x82c4b708
	if ctx.cr[6].eq {
	pc = 0x82C4B708; continue 'dispatch;
	}
	// 82C4B6F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4B6FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C4B700: 4BFFF829  bl 0x82c4af28
	ctx.lr = 0x82C4B704;
	sub_82C4AF28(ctx, base);
	// 82C4B704: 48000020  b 0x82c4b724
	pc = 0x82C4B724; continue 'dispatch;
	// 82C4B708: 4BFFF821  bl 0x82c4af28
	ctx.lr = 0x82C4B70C;
	sub_82C4AF28(ctx, base);
	// 82C4B70C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4B710: 48000018  b 0x82c4b728
	pc = 0x82C4B728; continue 'dispatch;
	// 82C4B714: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4B718: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4B71C: 386B4FE0  addi r3, r11, 0x4fe0
	ctx.r[3].s64 = ctx.r[11].s64 + 20448;
	// 82C4B720: 4BEFD909  bl 0x82b49028
	ctx.lr = 0x82C4B724;
	sub_82B49028(ctx, base);
	// 82C4B724: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B728: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4B72C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B730: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B734: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4B738: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4B73C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B740 size=116
    let mut pc: u32 = 0x82C4B740;
    'dispatch: loop {
        match pc {
            0x82C4B740 => {
    //   block [0x82C4B740..0x82C4B7B4)
	// 82C4B740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B744: 4805DCC5  bl 0x82ca9408
	ctx.lr = 0x82C4B748;
	sub_82CA93D0(ctx, base);
	// 82C4B748: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B74C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4B750: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C4B754: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C4B758: 897F00B8  lbz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C4B75C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B760: 419A0008  beq cr6, 0x82c4b768
	if ctx.cr[6].eq {
	pc = 0x82C4B768; continue 'dispatch;
	}
	// 82C4B764: 4BFFFCD5  bl 0x82c4b438
	ctx.lr = 0x82C4B768;
	sub_82C4B438(ctx, base);
	// 82C4B768: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82C4B76C: 38FF00A8  addi r7, r31, 0xa8
	ctx.r[7].s64 = ctx.r[31].s64 + 168;
	// 82C4B770: 38DF00A4  addi r6, r31, 0xa4
	ctx.r[6].s64 = ctx.r[31].s64 + 164;
	// 82C4B774: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C4B778: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4B77C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B780: 4800B4D1  bl 0x82c56c50
	ctx.lr = 0x82C4B784;
	sub_82C56C50(ctx, base);
	// 82C4B784: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4B788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4B78C: 409A0010  bne cr6, 0x82c4b79c
	if !ctx.cr[6].eq {
	pc = 0x82C4B79C; continue 'dispatch;
	}
	// 82C4B790: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4B794: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4B798: 4805DCC0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82C4B79C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4B7A0: 4800B9A1  bl 0x82c57140
	ctx.lr = 0x82C4B7A4;
	sub_82C57140(ctx, base);
	// 82C4B7A4: 987F00B9  stb r3, 0xb9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(185 as u32), ctx.r[3].u8 ) };
	// 82C4B7A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4B7AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4B7B0: 4805DCA8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B7B8 size=160
    let mut pc: u32 = 0x82C4B7B8;
    'dispatch: loop {
        match pc {
            0x82C4B7B8 => {
    //   block [0x82C4B7B8..0x82C4B858)
	// 82C4B7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4B7C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4B7C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4B7C8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B7CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4B7D0: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82C4B7D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4B7D8: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 82C4B7DC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B7E0: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C4B7E4: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C4B7E8: 4098004C  bge cr6, 0x82c4b834
	if !ctx.cr[6].lt {
	pc = 0x82C4B834; continue 'dispatch;
	}
	// 82C4B7EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C4B7F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4B7F4: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82C4B7F8: 4B6A6749  bl 0x822f1f40
	ctx.lr = 0x82C4B7FC;
	sub_822F1F40(ctx, base);
	// 82C4B7FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C4B800: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C4B804: 4B6A656D  bl 0x822f1d70
	ctx.lr = 0x82C4B808;
	sub_822F1D70(ctx, base);
	// 82C4B808: 4B6A6619  bl 0x822f1e20
	ctx.lr = 0x82C4B80C;
	sub_822F1E20(ctx, base);
	// 82C4B80C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C4B810: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C4B814: 392A1720  addi r9, r10, 0x1720
	ctx.r[9].s64 = ctx.r[10].s64 + 5920;
	// 82C4B818: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82C4B81C: 4BA2FFC5  bl 0x8267b7e0
	ctx.lr = 0x82C4B820;
	sub_8267B7E0(ctx, base);
	// 82C4B820: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C4B824: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82C4B828: 4198000C  blt cr6, 0x82c4b834
	if ctx.cr[6].lt {
	pc = 0x82C4B834; continue 'dispatch;
	}
	// 82C4B82C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4B830: 4BBF9F81  bl 0x828457b0
	ctx.lr = 0x82C4B834;
	sub_828457B0(ctx, base);
	// 82C4B834: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4B838: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C4B83C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4B840: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C4B844: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4B848: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4B84C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4B850: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4B854: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B858 size=128
    let mut pc: u32 = 0x82C4B858;
    'dispatch: loop {
        match pc {
            0x82C4B858 => {
    //   block [0x82C4B858..0x82C4B8D8)
	// 82C4B858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B85C: 4805DBA5  bl 0x82ca9400
	ctx.lr = 0x82C4B860;
	sub_82CA93D0(ctx, base);
	// 82C4B860: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B864: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82C4B868: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82C4B86C: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82C4B870: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C4B874: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C4B878: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B87C: 4B5D39DD  bl 0x8221f258
	ctx.lr = 0x82C4B880;
	sub_8221F258(ctx, base);
	// 82C4B880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4B884: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C4B888: 419A0008  beq cr6, 0x82c4b890
	if ctx.cr[6].eq {
	pc = 0x82C4B890; continue 'dispatch;
	}
	// 82C4B88C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C4B890: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82C4B894: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C4B898: 419A0008  beq cr6, 0x82c4b8a0
	if ctx.cr[6].eq {
	pc = 0x82C4B8A0; continue 'dispatch;
	}
	// 82C4B89C: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82C4B8A0: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4B8A4: 41820014  beq 0x82c4b8b8
	if ctx.cr[0].eq {
	pc = 0x82C4B8B8; continue 'dispatch;
	}
	// 82C4B8A8: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B8AC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4B8B0: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B8B4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C4B8B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C4B8BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C4B8C0: 4BFFFEF9  bl 0x82c4b7b8
	ctx.lr = 0x82C4B8C4;
	sub_82C4B7B8(ctx, base);
	// 82C4B8C4: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C4B8C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B8CC: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C4B8D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4B8D4: 4805DB7C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4B8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4B8D8 size=348
    let mut pc: u32 = 0x82C4B8D8;
    'dispatch: loop {
        match pc {
            0x82C4B8D8 => {
    //   block [0x82C4B8D8..0x82C4BA34)
	// 82C4B8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4B8DC: 4805DB21  bl 0x82ca93fc
	ctx.lr = 0x82C4B8E0;
	sub_82CA93D0(ctx, base);
	// 82C4B8E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4B8E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4B8E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4B8EC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4B8F0: 4800B279  bl 0x82c56b68
	ctx.lr = 0x82C4B8F4;
	sub_82C56B68(ctx, base);
	// 82C4B8F4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C4B8F8: 3B3F0084  addi r25, r31, 0x84
	ctx.r[25].s64 = ctx.r[31].s64 + 132;
	// 82C4B8FC: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4B900: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4B904: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B908: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4B90C: 409A0008  bne cr6, 0x82c4b914
	if !ctx.cr[6].eq {
	pc = 0x82C4B914; continue 'dispatch;
	}
	// 82C4B910: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4B914: 57CA063E  clrlwi r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82C4B918: 3B6B0008  addi r27, r11, 8
	ctx.r[27].s64 = ctx.r[11].s64 + 8;
	// 82C4B91C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4B920: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C4B924: 419A0054  beq cr6, 0x82c4b978
	if ctx.cr[6].eq {
	pc = 0x82C4B978; continue 'dispatch;
	}
	// 82C4B928: 83BF00A4  lwz r29, 0xa4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82C4B92C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C4B930: 419A003C  beq cr6, 0x82c4b96c
	if ctx.cr[6].eq {
	pc = 0x82C4B96C; continue 'dispatch;
	}
	// 82C4B934: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4B938: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B93C: 80BB0000  lwz r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B940: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B944: 4808E5CD  bl 0x82cd9f10
	ctx.lr = 0x82C4B948;
	sub_82CD9F10(ctx, base);
	// 82C4B948: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C4B94C: 80DF00A8  lwz r6, 0xa8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82C4B950: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4B954: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B958: 4808EDE9  bl 0x82cda740
	ctx.lr = 0x82C4B95C;
	sub_82CDA740(ctx, base);
	// 82C4B95C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C4B960: 3BBD4000  addi r29, r29, 0x4000
	ctx.r[29].s64 = ctx.r[29].s64 + 16384;
	// 82C4B964: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C4B968: 4198FFCC  blt cr6, 0x82c4b934
	if ctx.cr[6].lt {
	pc = 0x82C4B934; continue 'dispatch;
	}
	// 82C4B96C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82C4B970: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82C4B974: 4800002C  b 0x82c4b9a0
	pc = 0x82C4B9A0; continue 'dispatch;
	// 82C4B978: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C4B97C: 419A0024  beq cr6, 0x82c4b9a0
	if ctx.cr[6].eq {
	pc = 0x82C4B9A0; continue 'dispatch;
	}
	// 82C4B980: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4B984: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B988: 80BB0000  lwz r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B98C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4B990: 4808E581  bl 0x82cd9f10
	ctx.lr = 0x82C4B994;
	sub_82CD9F10(ctx, base);
	// 82C4B994: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C4B998: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C4B99C: 4198FFE4  blt cr6, 0x82c4b980
	if ctx.cr[6].lt {
	pc = 0x82C4B980; continue 'dispatch;
	}
	// 82C4B9A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4B9A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C4B9A8: 997F00B8  stb r11, 0xb8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[11].u8 ) };
	// 82C4B9AC: 3B9F0090  addi r28, r31, 0x90
	ctx.r[28].s64 = ctx.r[31].s64 + 144;
	// 82C4B9B0: 83DF0094  lwz r30, 0x94(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C4B9B4: 835E0004  lwz r26, 4(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B9B8: 4B5D38A1  bl 0x8221f258
	ctx.lr = 0x82C4B9BC;
	sub_8221F258(ctx, base);
	// 82C4B9BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4B9C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C4B9C4: 419A0008  beq cr6, 0x82c4b9cc
	if ctx.cr[6].eq {
	pc = 0x82C4B9CC; continue 'dispatch;
	}
	// 82C4B9C8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C4B9CC: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82C4B9D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C4B9D4: 419A0008  beq cr6, 0x82c4b9dc
	if ctx.cr[6].eq {
	pc = 0x82C4B9DC; continue 'dispatch;
	}
	// 82C4B9D8: 935D0000  stw r26, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C4B9DC: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4B9E0: 41820014  beq 0x82c4b9f4
	if ctx.cr[0].eq {
	pc = 0x82C4B9F4; continue 'dispatch;
	}
	// 82C4B9E4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4B9E8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4B9EC: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4B9F0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C4B9F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C4B9F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4B9FC: 4BFFFDBD  bl 0x82c4b7b8
	ctx.lr = 0x82C4BA00;
	sub_82C4B7B8(ctx, base);
	// 82C4BA00: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C4BA04: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BA08: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82C4BA0C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C4BA10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4BA14: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4BA18: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82C4BA1C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BA20: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82C4BA24: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4BA28: 4BFFF741  bl 0x82c4b168
	ctx.lr = 0x82C4BA2C;
	sub_82C4B168(ctx, base);
	// 82C4BA2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C4BA30: 4805DA1C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4BA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4BA38 size=196
    let mut pc: u32 = 0x82C4BA38;
    'dispatch: loop {
        match pc {
            0x82C4BA38 => {
    //   block [0x82C4BA38..0x82C4BAFC)
	// 82C4BA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4BA3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4BA40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4BA44: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4BA48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4BA4C: 897F00B9  lbz r11, 0xb9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(185 as u32) ) } as u64;
	// 82C4BA50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BA54: 409A0094  bne cr6, 0x82c4bae8
	if !ctx.cr[6].eq {
	pc = 0x82C4BAE8; continue 'dispatch;
	}
	// 82C4BA58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4BA5C: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4BA60: 4BFC31A1  bl 0x82c0ec00
	ctx.lr = 0x82C4BA64;
	sub_82C0EC00(ctx, base);
	// 82C4BA64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C4BA68: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82C4BA6C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C4BA70: 419A006C  beq cr6, 0x82c4badc
	if ctx.cr[6].eq {
	pc = 0x82C4BADC; continue 'dispatch;
	}
	// 82C4BA74: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82C4BA78: 80BF009C  lwz r5, 0x9c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C4BA7C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4BA80: 4800B501  bl 0x82c56f80
	ctx.lr = 0x82C4BA84;
	sub_82C56F80(ctx, base);
	// 82C4BA84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4BA88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BA8C: 419A0040  beq cr6, 0x82c4bacc
	if ctx.cr[6].eq {
	pc = 0x82C4BACC; continue 'dispatch;
	}
	// 82C4BA90: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C4BA94: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82C4BA98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4BA9C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82C4BAA0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C4BAA4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C4BAA8: 4BFFFDB1  bl 0x82c4b858
	ctx.lr = 0x82C4BAAC;
	sub_82C4B858(ctx, base);
	// 82C4BAAC: 895F00BB  lbz r10, 0xbb(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(187 as u32) ) } as u64;
	// 82C4BAB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4BAB4: 419A0028  beq cr6, 0x82c4badc
	if ctx.cr[6].eq {
	pc = 0x82C4BADC; continue 'dispatch;
	}
	// 82C4BAB8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82C4BABC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4BAC0: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C4BAC4: 4807639D  bl 0x82cc1e60
	ctx.lr = 0x82C4BAC8;
	sub_82CC1E60(ctx, base);
	// 82C4BAC8: 48000014  b 0x82c4badc
	pc = 0x82C4BADC; continue 'dispatch;
	// 82C4BACC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4BAD0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4BAD4: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4BAD8: 4BFC2FB9  bl 0x82c0ea90
	ctx.lr = 0x82C4BADC;
	sub_82C0EA90(ctx, base);
	// 82C4BADC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4BAE0: 4800B661  bl 0x82c57140
	ctx.lr = 0x82C4BAE4;
	sub_82C57140(ctx, base);
	// 82C4BAE4: 987F00B9  stb r3, 0xb9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(185 as u32), ctx.r[3].u8 ) };
	// 82C4BAE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4BAEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4BAF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4BAF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4BAF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4BB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4BB00 size=428
    let mut pc: u32 = 0x82C4BB00;
    'dispatch: loop {
        match pc {
            0x82C4BB00 => {
    //   block [0x82C4BB00..0x82C4BCAC)
	// 82C4BB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4BB04: 4805D905  bl 0x82ca9408
	ctx.lr = 0x82C4BB08;
	sub_82CA93D0(ctx, base);
	// 82C4BB08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4BB0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4BB10: 3B9F00A0  addi r28, r31, 0xa0
	ctx.r[28].s64 = ctx.r[31].s64 + 160;
	// 82C4BB14: 807F00A0  lwz r3, 0xa0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C4BB18: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4BB1C: 419A00FC  beq cr6, 0x82c4bc18
	if ctx.cr[6].eq {
	pc = 0x82C4BC18; continue 'dispatch;
	}
	// 82C4BB20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BB24: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4BB28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4BB2C: 4E800421  bctrl
	ctx.lr = 0x82C4BB30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4BB30: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4BB34: 419A0170  beq cr6, 0x82c4bca4
	if ctx.cr[6].eq {
	pc = 0x82C4BCA4; continue 'dispatch;
	}
	// 82C4BB38: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BB3C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82C4BB40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C4BB44: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BB48: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4BB4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4BB50: 409A008C  bne cr6, 0x82c4bbdc
	if !ctx.cr[6].eq {
	pc = 0x82C4BBDC; continue 'dispatch;
	}
	// 82C4BB54: 4E800421  bctrl
	ctx.lr = 0x82C4BB58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4BB58: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BB5C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82C4BB60: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82C4BB64: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BB68: 83C80000  lwz r30, 0(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BB6C: 80C70018  lwz r6, 0x18(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4BB70: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82C4BB74: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C4BB78: 4E800421  bctrl
	ctx.lr = 0x82C4BB7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4BB7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C4BB80: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82C4BB84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C4BB88: 419A004C  beq cr6, 0x82c4bbd4
	if ctx.cr[6].eq {
	pc = 0x82C4BBD4; continue 'dispatch;
	}
	// 82C4BB8C: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C4BB90: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82C4BB94: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82C4BB98: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82C4BB9C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82C4BBA0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C4BBA4: 4BFFFCB5  bl 0x82c4b858
	ctx.lr = 0x82C4BBA8;
	sub_82C4B858(ctx, base);
	// 82C4BBA8: 895F00BB  lbz r10, 0xbb(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(187 as u32) ) } as u64;
	// 82C4BBAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4BBB0: 419A0014  beq cr6, 0x82c4bbc4
	if ctx.cr[6].eq {
	pc = 0x82C4BBC4; continue 'dispatch;
	}
	// 82C4BBB4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82C4BBB8: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C4BBBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4BBC0: 480762A1  bl 0x82cc1e60
	ctx.lr = 0x82C4BBC4;
	sub_82CC1E60(ctx, base);
	// 82C4BBC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4BBC8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4BBCC: 4800B075  bl 0x82c56c40
	ctx.lr = 0x82C4BBD0;
	sub_82C56C40(ctx, base);
	// 82C4BBD0: 48000024  b 0x82c4bbf4
	pc = 0x82C4BBF4; continue 'dispatch;
	// 82C4BBD4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C4BBD8: 48000010  b 0x82c4bbe8
	pc = 0x82C4BBE8; continue 'dispatch;
	// 82C4BBDC: 4E800421  bctrl
	ctx.lr = 0x82C4BBE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4BBE0: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C4BBE4: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BBE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4BBEC: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4BBF0: 4BFC2EA1  bl 0x82c0ea90
	ctx.lr = 0x82C4BBF4;
	sub_82C0EA90(ctx, base);
	// 82C4BBF4: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BBF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4BBFC: 419A0014  beq cr6, 0x82c4bc10
	if ctx.cr[6].eq {
	pc = 0x82C4BC10; continue 'dispatch;
	}
	// 82C4BC00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BC04: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4BC08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4BC0C: 4E800421  bctrl
	ctx.lr = 0x82C4BC10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4BC10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4BC14: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4BC18: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 82C4BC1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4BC20: 4800B521  bl 0x82c57140
	ctx.lr = 0x82C4BC24;
	sub_82C57140(ctx, base);
	// 82C4BC24: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4BC28: 987F00B9  stb r3, 0xb9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(185 as u32), ctx.r[3].u8 ) };
	// 82C4BC2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BC30: 409A0074  bne cr6, 0x82c4bca4
	if !ctx.cr[6].eq {
	pc = 0x82C4BCA4; continue 'dispatch;
	}
	// 82C4BC34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4BC38: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4BC3C: 4BFC2FC5  bl 0x82c0ec00
	ctx.lr = 0x82C4BC40;
	sub_82C0EC00(ctx, base);
	// 82C4BC40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4BC44: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C4BC48: 419A005C  beq cr6, 0x82c4bca4
	if ctx.cr[6].eq {
	pc = 0x82C4BCA4; continue 'dispatch;
	}
	// 82C4BC4C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C4BC50: 80DF009C  lwz r6, 0x9c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C4BC54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4BC58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4BC5C: 4800B425  bl 0x82c57080
	ctx.lr = 0x82C4BC60;
	sub_82C57080(ctx, base);
	// 82C4BC60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C4BC64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4BC68: 4B8DEDB1  bl 0x8252aa18
	ctx.lr = 0x82C4BC6C;
	sub_8252AA18(ctx, base);
	// 82C4BC6C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4BC70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4BC74: 419A0014  beq cr6, 0x82c4bc88
	if ctx.cr[6].eq {
	pc = 0x82C4BC88; continue 'dispatch;
	}
	// 82C4BC78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BC7C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4BC80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4BC84: 4E800421  bctrl
	ctx.lr = 0x82C4BC88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4BC88: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BC8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4BC90: 409A0014  bne cr6, 0x82c4bca4
	if !ctx.cr[6].eq {
	pc = 0x82C4BCA4; continue 'dispatch;
	}
	// 82C4BC94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C4BC98: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4BC9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4BCA0: 4BFC2DF1  bl 0x82c0ea90
	ctx.lr = 0x82C4BCA4;
	sub_82C0EA90(ctx, base);
	// 82C4BCA4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4BCA8: 4805D7B0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4BCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4BCB0 size=152
    let mut pc: u32 = 0x82C4BCB0;
    'dispatch: loop {
        match pc {
            0x82C4BCB0 => {
    //   block [0x82C4BCB0..0x82C4BD48)
	// 82C4BCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4BCB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4BCB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4BCBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4BCC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4BCC4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C4BCC8: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 82C4BCCC: F8C10098  std r6, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[6].u64 ) };
	// 82C4BCD0: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82C4BCD4: F8E100A0  std r7, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u64 ) };
	// 82C4BCD8: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C4BCDC: 419A0018  beq cr6, 0x82c4bcf4
	if ctx.cr[6].eq {
	pc = 0x82C4BCF4; continue 'dispatch;
	}
	// 82C4BCE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4BCE4: 4BFFFAD5  bl 0x82c4b7b8
	ctx.lr = 0x82C4BCE8;
	sub_82C4B7B8(ctx, base);
	// 82C4BCE8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4BCEC: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82C4BCF0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4BCF4: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C4BCF8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82C4BCFC: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82C4BD00: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4BD04: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4BD08: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4BD0C: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4BD10: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4BD14: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4BD18: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4BD1C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4BD20: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82C4BD24: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4BD28: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82C4BD2C: 90A90004  stw r5, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82C4BD30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4BD34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4BD38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4BD3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4BD40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4BD44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4BD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C4BD48 size=696
    let mut pc: u32 = 0x82C4BD48;
    'dispatch: loop {
        match pc {
            0x82C4BD48 => {
    //   block [0x82C4BD48..0x82C4C000)
	// 82C4BD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4BD4C: 4805D69D  bl 0x82ca93e8
	ctx.lr = 0x82C4BD50;
	sub_82CA93D0(ctx, base);
	// 82C4BD50: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4BD54: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 82C4BD58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4BD5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4BD60: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82C4BD64: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82C4BD68: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4BD6C: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 82C4BD70: 4BFFE7C1  bl 0x82c4a530
	ctx.lr = 0x82C4BD74;
	sub_82C4A530(ctx, base);
	// 82C4BD74: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4BD78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4BD7C: 409A0010  bne cr6, 0x82c4bd8c
	if !ctx.cr[6].eq {
	pc = 0x82C4BD8C; continue 'dispatch;
	}
	// 82C4BD80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4BD84: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82C4BD88: 4805D6B0  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
	// 82C4BD8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C4BD90: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4BD94: 4808E7C5  bl 0x82cda558
	ctx.lr = 0x82C4BD98;
	sub_82CDA558(ctx, base);
	// 82C4BD98: 907F00B0  stw r3, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82C4BD9C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C4BDA0: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4BDA4: 4808E7F5  bl 0x82cda598
	ctx.lr = 0x82C4BDA8;
	sub_82CDA598(ctx, base);
	// 82C4BDA8: 897F00BA  lbz r11, 0xba(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(186 as u32) ) } as u64;
	// 82C4BDAC: 907F00B4  stw r3, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82C4BDB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4BDB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BDB8: 419A000C  beq cr6, 0x82c4bdc4
	if ctx.cr[6].eq {
	pc = 0x82C4BDC4; continue 'dispatch;
	}
	// 82C4BDBC: 4BFFFC7D  bl 0x82c4ba38
	ctx.lr = 0x82C4BDC0;
	sub_82C4BA38(ctx, base);
	// 82C4BDC0: 48000008  b 0x82c4bdc8
	pc = 0x82C4BDC8; continue 'dispatch;
	// 82C4BDC4: 4BFFFD3D  bl 0x82c4bb00
	ctx.lr = 0x82C4BDC8;
	sub_82C4BB00(ctx, base);
	// 82C4BDC8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4BDCC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82C4BDD0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82C4BDD4: 4800AD95  bl 0x82c56b68
	ctx.lr = 0x82C4BDD8;
	sub_82C56B68(ctx, base);
	// 82C4BDD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C4BDDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C4BDE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C4BDE4: 419A0040  beq cr6, 0x82c4be24
	if ctx.cr[6].eq {
	pc = 0x82C4BE24; continue 'dispatch;
	}
	// 82C4BDE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4BDEC: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4BDF0: 4808E2E1  bl 0x82cda0d0
	ctx.lr = 0x82C4BDF4;
	sub_82CDA0D0(ctx, base);
	// 82C4BDF4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4BDF8: 409A0008  bne cr6, 0x82c4be00
	if !ctx.cr[6].eq {
	pc = 0x82C4BE00; continue 'dispatch;
	}
	// 82C4BDFC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C4BE00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4BE04: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4BE08: 4808E261  bl 0x82cda068
	ctx.lr = 0x82C4BE0C;
	sub_82CDA068(ctx, base);
	// 82C4BE0C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4BE10: 409A0008  bne cr6, 0x82c4be18
	if !ctx.cr[6].eq {
	pc = 0x82C4BE18; continue 'dispatch;
	}
	// 82C4BE14: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C4BE18: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C4BE1C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C4BE20: 4198FFC8  blt cr6, 0x82c4bde8
	if ctx.cr[6].lt {
	pc = 0x82C4BDE8; continue 'dispatch;
	}
	// 82C4BE24: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82C4BE28: 895F00B9  lbz r10, 0xb9(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(185 as u32) ) } as u64;
	// 82C4BE2C: 212B0000  subfic r9, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[9].s64 = (0 as i64) - ctx.r[11].s64;
	// 82C4BE30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4BE34: 7D094910  subfe r8, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[8].u32 = res;
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82C4BE38: 550B07FE  clrlwi r11, r8, 0x1f
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 82C4BE3C: 419A002C  beq cr6, 0x82c4be68
	if ctx.cr[6].eq {
	pc = 0x82C4BE68; continue 'dispatch;
	}
	// 82C4BE40: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82C4BE44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4BE48: 419A0020  beq cr6, 0x82c4be68
	if ctx.cr[6].eq {
	pc = 0x82C4BE68; continue 'dispatch;
	}
	// 82C4BE4C: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4BE50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4BE54: 409A0014  bne cr6, 0x82c4be68
	if !ctx.cr[6].eq {
	pc = 0x82C4BE68; continue 'dispatch;
	}
	// 82C4BE58: 815F00A0  lwz r10, 0xa0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C4BE5C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82C4BE60: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C4BE64: 419A0008  beq cr6, 0x82c4be6c
	if ctx.cr[6].eq {
	pc = 0x82C4BE6C; continue 'dispatch;
	}
	// 82C4BE68: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82C4BE6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4BE70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BE74: 419A0014  beq cr6, 0x82c4be88
	if ctx.cr[6].eq {
	pc = 0x82C4BE88; continue 'dispatch;
	}
	// 82C4BE78: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 82C4BE7C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82C4BE80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BE84: 409A0008  bne cr6, 0x82c4be8c
	if !ctx.cr[6].eq {
	pc = 0x82C4BE8C; continue 'dispatch;
	}
	// 82C4BE88: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82C4BE8C: 579A063E  clrlwi r26, r28, 0x18
	ctx.r[26].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82C4BE90: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82C4BE94: 419A000C  beq cr6, 0x82c4bea0
	if ctx.cr[6].eq {
	pc = 0x82C4BEA0; continue 'dispatch;
	}
	// 82C4BE98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4BE9C: 48000014  b 0x82c4beb0
	pc = 0x82C4BEB0; continue 'dispatch;
	// 82C4BEA0: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 82C4BEA4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C4BEA8: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C4BEAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4BEB0: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C4BEB4: 557C063E  clrlwi r28, r11, 0x18
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4BEB8: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C4BEBC: 40990078  ble cr6, 0x82c4bf34
	if !ctx.cr[6].gt {
	pc = 0x82C4BF34; continue 'dispatch;
	}
	// 82C4BEC0: 3BDF0090  addi r30, r31, 0x90
	ctx.r[30].s64 = ctx.r[31].s64 + 144;
	// 82C4BEC4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4BEC8: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4BECC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BED0: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4BED4: 409A0008  bne cr6, 0x82c4bedc
	if !ctx.cr[6].eq {
	pc = 0x82C4BEDC; continue 'dispatch;
	}
	// 82C4BED8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4BEDC: 897F00BB  lbz r11, 0xbb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(187 as u32) ) } as u64;
	// 82C4BEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BEE4: 419A0014  beq cr6, 0x82c4bef8
	if ctx.cr[6].eq {
	pc = 0x82C4BEF8; continue 'dispatch;
	}
	// 82C4BEE8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4BEEC: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C4BEF0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4BEF4: 48075F6D  bl 0x82cc1e60
	ctx.lr = 0x82C4BEF8;
	sub_82CC1E60(ctx, base);
	// 82C4BEF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4BEFC: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4BF00: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4BF04: 4BFC2B8D  bl 0x82c0ea90
	ctx.lr = 0x82C4BF08;
	sub_82C0EA90(ctx, base);
	// 82C4BF08: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4BF0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4BF10: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82C4BF14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4BF18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BF1C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C4BF20: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4BF24: 4BFFF245  bl 0x82c4b168
	ctx.lr = 0x82C4BF28;
	sub_82C4B168(ctx, base);
	// 82C4BF28: 813F0098  lwz r9, 0x98(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C4BF2C: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C4BF30: 4199FF94  bgt cr6, 0x82c4bec4
	if ctx.cr[6].gt {
	pc = 0x82C4BEC4; continue 'dispatch;
	}
	// 82C4BF34: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4BF38: 4808E929  bl 0x82cda860
	ctx.lr = 0x82C4BF3C;
	sub_82CDA860(ctx, base);
	// 82C4BF3C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4BF40: 4198001C  blt cr6, 0x82c4bf5c
	if ctx.cr[6].lt {
	pc = 0x82C4BF5C; continue 'dispatch;
	}
	// 82C4BF44: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4BF48: 4808E9B1  bl 0x82cda8f8
	ctx.lr = 0x82C4BF4C;
	sub_82CDA8F8(ctx, base);
	// 82C4BF4C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4BF50: 40980018  bge cr6, 0x82c4bf68
	if !ctx.cr[6].lt {
	pc = 0x82C4BF68; continue 'dispatch;
	}
	// 82C4BF54: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4BF58: 4808EBB9  bl 0x82cdab10
	ctx.lr = 0x82C4BF5C;
	sub_82CDAB10(ctx, base);
	// 82C4BF5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4BF60: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82C4BF64: 4805D4D4  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
	// 82C4BF68: 2F16FFFF  cmpwi cr6, r22, -1
	ctx.cr[6].compare_i32(ctx.r[22].s32, -1, &mut ctx.xer);
	// 82C4BF6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4BF70: 409A0014  bne cr6, 0x82c4bf84
	if !ctx.cr[6].eq {
	pc = 0x82C4BF84; continue 'dispatch;
	}
	// 82C4BF74: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82C4BF78: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82C4BF7C: 4BFFE76D  bl 0x82c4a6e8
	ctx.lr = 0x82C4BF80;
	sub_82C4A6E8(ctx, base);
	// 82C4BF80: 48000014  b 0x82c4bf94
	pc = 0x82C4BF94; continue 'dispatch;
	// 82C4BF84: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 82C4BF88: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82C4BF8C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82C4BF90: 4BFFE901  bl 0x82c4a890
	ctx.lr = 0x82C4BF94;
	sub_82C4A890(ctx, base);
	// 82C4BF94: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82C4BF98: 90750000  stw r3, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C4BF9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BFA0: 419A0028  beq cr6, 0x82c4bfc8
	if ctx.cr[6].eq {
	pc = 0x82C4BFC8; continue 'dispatch;
	}
	// 82C4BFA4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82C4BFA8: 409A0014  bne cr6, 0x82c4bfbc
	if !ctx.cr[6].eq {
	pc = 0x82C4BFBC; continue 'dispatch;
	}
	// 82C4BFAC: 897F00B8  lbz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C4BFB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C4BFB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BFB8: 409A0008  bne cr6, 0x82c4bfc0
	if !ctx.cr[6].eq {
	pc = 0x82C4BFC0; continue 'dispatch;
	}
	// 82C4BFBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C4BFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4BFC4: 4BFFF915  bl 0x82c4b8d8
	ctx.lr = 0x82C4BFC8;
	sub_82C4B8D8(ctx, base);
	// 82C4BFC8: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4BFCC: 4808EB45  bl 0x82cdab10
	ctx.lr = 0x82C4BFD0;
	sub_82CDAB10(ctx, base);
	// 82C4BFD0: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 82C4BFD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BFD8: 419A0010  beq cr6, 0x82c4bfe8
	if ctx.cr[6].eq {
	pc = 0x82C4BFE8; continue 'dispatch;
	}
	// 82C4BFDC: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BFE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4BFE4: 419AFD9C  beq cr6, 0x82c4bd80
	if ctx.cr[6].eq {
	pc = 0x82C4BD80; continue 'dispatch;
	}
	// 82C4BFE8: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4BFEC: 7D4BA050  subf r10, r11, r20
	ctx.r[10].s64 = ctx.r[20].s64 - ctx.r[11].s64;
	// 82C4BFF0: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82C4BFF4: 5523DFFE  rlwinm r3, r9, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82C4BFF8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82C4BFFC: 4805D43C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C000 size=4
    let mut pc: u32 = 0x82C4C000;
    'dispatch: loop {
        match pc {
            0x82C4C000 => {
    //   block [0x82C4C000..0x82C4C004)
	// 82C4C000: 4BFFFD48  b 0x82c4bd48
	sub_82C4BD48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4C008 size=532
    let mut pc: u32 = 0x82C4C008;
    'dispatch: loop {
        match pc {
            0x82C4C008 => {
    //   block [0x82C4C008..0x82C4C21C)
	// 82C4C008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C00C: 4805D3F9  bl 0x82ca9404
	ctx.lr = 0x82C4C010;
	sub_82CA93D0(ctx, base);
	// 82C4C010: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4C018: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4C01C: 394BC994  addi r10, r11, -0x366c
	ctx.r[10].s64 = ctx.r[11].s64 + -13932;
	// 82C4C020: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4C024: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C4C028: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4C02C: 419AFFF8  beq cr6, 0x82c4c024
	if ctx.cr[6].eq {
	pc = 0x82C4C024; continue 'dispatch;
	}
	// 82C4C030: 807F00A0  lwz r3, 0xa0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C4C034: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C4C038: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4C03C: 419A0074  beq cr6, 0x82c4c0b0
	if ctx.cr[6].eq {
	pc = 0x82C4C0B0; continue 'dispatch;
	}
	// 82C4C040: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C044: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4C048: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C04C: 4E800421  bctrl
	ctx.lr = 0x82C4C050;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C050: 807F00A0  lwz r3, 0xa0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C4C054: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C058: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4C05C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4C060: 4E800421  bctrl
	ctx.lr = 0x82C4C064;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C064: 809F00A0  lwz r4, 0xa0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C4C068: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C4C06C: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C070: 80C70014  lwz r6, 0x14(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4C074: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C4C078: 4E800421  bctrl
	ctx.lr = 0x82C4C07C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C07C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C4C080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4C084: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4C088: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C08C: 4BFC2A05  bl 0x82c0ea90
	ctx.lr = 0x82C4C090;
	sub_82C0EA90(ctx, base);
	// 82C4C090: 807F00A0  lwz r3, 0xa0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C4C094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C098: 419A0014  beq cr6, 0x82c4c0ac
	if ctx.cr[6].eq {
	pc = 0x82C4C0AC; continue 'dispatch;
	}
	// 82C4C09C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C0A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C0A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C0A8: 4E800421  bctrl
	ctx.lr = 0x82C4C0AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C0AC: 937F00A0  stw r27, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[27].u32 ) };
	// 82C4C0B0: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C4C0B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C0B8: 419A000C  beq cr6, 0x82c4c0c4
	if ctx.cr[6].eq {
	pc = 0x82C4C0C4; continue 'dispatch;
	}
	// 82C4C0BC: 4808DD1D  bl 0x82cd9dd8
	ctx.lr = 0x82C4C0C0;
	sub_82CD9DD8(ctx, base);
	// 82C4C0C0: 937F0078  stw r27, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 82C4C0C4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C4C0C8: 3BDF0084  addi r30, r31, 0x84
	ctx.r[30].s64 = ctx.r[31].s64 + 132;
	// 82C4C0CC: 3B9F0090  addi r28, r31, 0x90
	ctx.r[28].s64 = ctx.r[31].s64 + 144;
	// 82C4C0D0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82C4C0D4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C4C0D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C0DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C4C0E0: 419A0044  beq cr6, 0x82c4c124
	if ctx.cr[6].eq {
	pc = 0x82C4C124; continue 'dispatch;
	}
	// 82C4C0E4: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C0E8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C4C0EC: 419A0038  beq cr6, 0x82c4c124
	if ctx.cr[6].eq {
	pc = 0x82C4C124; continue 'dispatch;
	}
	// 82C4C0F0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C0F4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C4C0F8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C4C0FC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82C4C100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4C104: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82C4C108: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4C10C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C110: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C4C114: E8E10058  ld r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C4C118: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82C4C11C: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C4C120: 4BFFFB91  bl 0x82c4bcb0
	ctx.lr = 0x82C4C124;
	sub_82C4BCB0(ctx, base);
	// 82C4C124: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82C4C128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4C12C: 40990074  ble cr6, 0x82c4c1a0
	if !ctx.cr[6].gt {
	pc = 0x82C4C1A0; continue 'dispatch;
	}
	// 82C4C130: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C134: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4C138: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C13C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4C140: 409A0008  bne cr6, 0x82c4c148
	if !ctx.cr[6].eq {
	pc = 0x82C4C148; continue 'dispatch;
	}
	// 82C4C144: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4C148: 897F00BB  lbz r11, 0xbb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(187 as u32) ) } as u64;
	// 82C4C14C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4C150: 419A0014  beq cr6, 0x82c4c164
	if ctx.cr[6].eq {
	pc = 0x82C4C164; continue 'dispatch;
	}
	// 82C4C154: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4C158: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C4C15C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C160: 48075D01  bl 0x82cc1e60
	ctx.lr = 0x82C4C164;
	sub_82CC1E60(ctx, base);
	// 82C4C164: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4C168: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C16C: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C4C170: 4BFC2921  bl 0x82c0ea90
	ctx.lr = 0x82C4C174;
	sub_82C0EA90(ctx, base);
	// 82C4C174: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C178: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4C17C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82C4C180: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4C184: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C188: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82C4C18C: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C4C190: 4BFFEFD9  bl 0x82c4b168
	ctx.lr = 0x82C4C194;
	sub_82C4B168(ctx, base);
	// 82C4C194: 813F008C  lwz r9, 0x8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82C4C198: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4C19C: 4199FF94  bgt cr6, 0x82c4c130
	if ctx.cr[6].gt {
	pc = 0x82C4C130; continue 'dispatch;
	}
	// 82C4C1A0: 807F00A0  lwz r3, 0xa0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C4C1A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C1A8: 419A0014  beq cr6, 0x82c4c1bc
	if ctx.cr[6].eq {
	pc = 0x82C4C1BC; continue 'dispatch;
	}
	// 82C4C1AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C1B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C1B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C1B8: 4E800421  bctrl
	ctx.lr = 0x82C4C1BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C1BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4C1C0: 4BFBE509  bl 0x82c0a6c8
	ctx.lr = 0x82C4C1C4;
	sub_82C0A6C8(ctx, base);
	// 82C4C1C4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C1C8: 4BBF95E9  bl 0x828457b0
	ctx.lr = 0x82C4C1CC;
	sub_828457B0(ctx, base);
	// 82C4C1CC: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82C4C1D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4C1D4: 4BFBE4F5  bl 0x82c0a6c8
	ctx.lr = 0x82C4C1D8;
	sub_82C0A6C8(ctx, base);
	// 82C4C1D8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C1DC: 4BBF95D5  bl 0x828457b0
	ctx.lr = 0x82C4C1E0;
	sub_828457B0(ctx, base);
	// 82C4C1E0: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82C4C1E4: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82C4C1E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C1EC: 419A0014  beq cr6, 0x82c4c200
	if ctx.cr[6].eq {
	pc = 0x82C4C200; continue 'dispatch;
	}
	// 82C4C1F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C1F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C1F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C1FC: 4E800421  bctrl
	ctx.lr = 0x82C4C200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C200: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4C204: 4800AD5D  bl 0x82c56f60
	ctx.lr = 0x82C4C208;
	sub_82C56F60(ctx, base);
	// 82C4C208: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4C20C: 394BC940  addi r10, r11, -0x36c0
	ctx.r[10].s64 = ctx.r[11].s64 + -14016;
	// 82C4C210: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4C214: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C4C218: 4805D23C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C220 size=20
    let mut pc: u32 = 0x82C4C220;
    'dispatch: loop {
        match pc {
            0x82C4C220 => {
    //   block [0x82C4C220..0x82C4C234)
	// 82C4C220: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82C4C224: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82C4C228: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82C4C22C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 82C4C230: 4BFFFB18  b 0x82c4bd48
	sub_82C4BD48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4C238 size=80
    let mut pc: u32 = 0x82C4C238;
    'dispatch: loop {
        match pc {
            0x82C4C238 => {
    //   block [0x82C4C238..0x82C4C288)
	// 82C4C238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4C240: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4C244: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4C248: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C24C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4C250: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4C254: 4BFFFDB5  bl 0x82c4c008
	ctx.lr = 0x82C4C258;
	sub_82C4C008(ctx, base);
	// 82C4C258: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C4C25C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4C260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4C264: 419A000C  beq cr6, 0x82c4c270
	if ctx.cr[6].eq {
	pc = 0x82C4C270; continue 'dispatch;
	}
	// 82C4C268: 4BBF9549  bl 0x828457b0
	ctx.lr = 0x82C4C26C;
	sub_828457B0(ctx, base);
	// 82C4C26C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4C270: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4C274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4C278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4C27C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4C280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4C284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C288 size=12
    let mut pc: u32 = 0x82C4C288;
    'dispatch: loop {
        match pc {
            0x82C4C288 => {
    //   block [0x82C4C288..0x82C4C294)
	// 82C4C288: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4C28C: 386B5008  addi r3, r11, 0x5008
	ctx.r[3].s64 = ctx.r[11].s64 + 20488;
	// 82C4C290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C298 size=12
    let mut pc: u32 = 0x82C4C298;
    'dispatch: loop {
        match pc {
            0x82C4C298 => {
    //   block [0x82C4C298..0x82C4C2A4)
	// 82C4C298: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4C29C: 386B500C  addi r3, r11, 0x500c
	ctx.r[3].s64 = ctx.r[11].s64 + 20492;
	// 82C4C2A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C2A8 size=8
    let mut pc: u32 = 0x82C4C2A8;
    'dispatch: loop {
        match pc {
            0x82C4C2A8 => {
    //   block [0x82C4C2A8..0x82C4C2B0)
	// 82C4C2A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C2AC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C2B0 size=20
    let mut pc: u32 = 0x82C4C2B0;
    'dispatch: loop {
        match pc {
            0x82C4C2B0 => {
    //   block [0x82C4C2B0..0x82C4C2C4)
	// 82C4C2B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C2B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C4C2B8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4C2BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C2C0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C2C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C2C4 size=4
    let mut pc: u32 = 0x82C4C2C4;
    'dispatch: loop {
        match pc {
            0x82C4C2C4 => {
    //   block [0x82C4C2C4..0x82C4C2C8)
	// 82C4C2C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C4C2C8 size=68
    let mut pc: u32 = 0x82C4C2C8;
    'dispatch: loop {
        match pc {
            0x82C4C2C8 => {
    //   block [0x82C4C2C8..0x82C4C30C)
	// 82C4C2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4C2D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4C2D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C2D8: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82C4C2DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4C2E0: 4800B649  bl 0x82c57928
	ctx.lr = 0x82C4C2E4;
	sub_82C57928(ctx, base);
	// 82C4C2E4: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82C4C2E8: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 82C4C2EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4C2F0: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82C4C2F4: 552307FE  clrlwi r3, r9, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82C4C2F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4C2FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4C300: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4C304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4C308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C4C310 size=64
    let mut pc: u32 = 0x82C4C310;
    'dispatch: loop {
        match pc {
            0x82C4C310 => {
    //   block [0x82C4C310..0x82C4C350)
	// 82C4C310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4C318: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4C31C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C320: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82C4C324: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4C328: 4800B621  bl 0x82c57948
	ctx.lr = 0x82C4C32C;
	sub_82C57948(ctx, base);
	// 82C4C32C: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82C4C330: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C4C334: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82C4C338: 554307FE  clrlwi r3, r10, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82C4C33C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4C340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4C344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4C348: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4C34C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4C350 size=88
    let mut pc: u32 = 0x82C4C350;
    'dispatch: loop {
        match pc {
            0x82C4C350 => {
    //   block [0x82C4C350..0x82C4C3A8)
	// 82C4C350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4C358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4C35C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4C360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C364: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82C4C368: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4C36C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C4C370: 4800B749  bl 0x82c57ab8
	ctx.lr = 0x82C4C374;
	sub_82C57AB8(ctx, base);
	// 82C4C374: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4C378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4C37C: 419A0010  beq cr6, 0x82c4c38c
	if ctx.cr[6].eq {
	pc = 0x82C4C38C; continue 'dispatch;
	}
	// 82C4C380: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C4C384: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4C388: 48000008  b 0x82c4c390
	pc = 0x82C4C390; continue 'dispatch;
	// 82C4C38C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4C390: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4C394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4C398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4C39C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4C3A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4C3A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C4C3A8 size=64
    let mut pc: u32 = 0x82C4C3A8;
    'dispatch: loop {
        match pc {
            0x82C4C3A8 => {
    //   block [0x82C4C3A8..0x82C4C3E8)
	// 82C4C3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4C3B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4C3B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C3B8: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82C4C3BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4C3C0: 4800B5A9  bl 0x82c57968
	ctx.lr = 0x82C4C3C4;
	sub_82C57968(ctx, base);
	// 82C4C3C4: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82C4C3C8: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C4C3CC: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82C4C3D0: 554307FE  clrlwi r3, r10, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82C4C3D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4C3D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4C3DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4C3E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4C3E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C3E8 size=24
    let mut pc: u32 = 0x82C4C3E8;
    'dispatch: loop {
        match pc {
            0x82C4C3E8 => {
    //   block [0x82C4C3E8..0x82C4C400)
	// 82C4C3E8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82C4C3EC: 409A0014  bne cr6, 0x82c4c400
	if !ctx.cr[6].eq {
		sub_82C4C400(ctx, base);
		return;
	}
	// 82C4C3F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4C3F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4C3F8: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4C3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C400 size=8
    let mut pc: u32 = 0x82C4C400;
    'dispatch: loop {
        match pc {
            0x82C4C400 => {
    //   block [0x82C4C400..0x82C4C408)
	// 82C4C400: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82C4C404: 4800B5C4  b 0x82c579c8
	sub_82C579C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C408 size=16
    let mut pc: u32 = 0x82C4C408;
    'dispatch: loop {
        match pc {
            0x82C4C408 => {
    //   block [0x82C4C408..0x82C4C418)
	// 82C4C408: 89630054  lbz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4C40C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C4C410: 5543E7BC  rlwinm r3, r10, 0x1c, 0x1e, 0x1e
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82C4C414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C418 size=8
    let mut pc: u32 = 0x82C4C418;
    'dispatch: loop {
        match pc {
            0x82C4C418 => {
    //   block [0x82C4C418..0x82C4C420)
	// 82C4C418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C41C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C420 size=20
    let mut pc: u32 = 0x82C4C420;
    'dispatch: loop {
        match pc {
            0x82C4C420 => {
    //   block [0x82C4C420..0x82C4C434)
	// 82C4C420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C424: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C4C428: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C4C42C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C430: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C434(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4C434 size=4
    let mut pc: u32 = 0x82C4C434;
    'dispatch: loop {
        match pc {
            0x82C4C434 => {
    //   block [0x82C4C434..0x82C4C438)
	// 82C4C434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4C438 size=132
    let mut pc: u32 = 0x82C4C438;
    'dispatch: loop {
        match pc {
            0x82C4C438 => {
    //   block [0x82C4C438..0x82C4C4BC)
	// 82C4C438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4C440: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4C444: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4C448: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C44C: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4C450: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C4C454: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C4C458: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4C45C: 419A0044  beq cr6, 0x82c4c4a0
	if ctx.cr[6].eq {
	pc = 0x82C4C4A0; continue 'dispatch;
	}
	// 82C4C460: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4C464: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82C4C468: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C46C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C4C470: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C4C474: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C478: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4C47C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4C480: 4E800421  bctrl
	ctx.lr = 0x82C4C484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C484: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4C488: 41980018  blt cr6, 0x82c4c4a0
	if ctx.cr[6].lt {
	pc = 0x82C4C4A0; continue 'dispatch;
	}
	// 82C4C48C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C490: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4C494: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C4C498: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4C49C: 48000008  b 0x82c4c4a4
	pc = 0x82C4C4A4; continue 'dispatch;
	// 82C4C4A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4C4A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4C4A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4C4AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4C4B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4C4B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4C4B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4C4C0 size=200
    let mut pc: u32 = 0x82C4C4C0;
    'dispatch: loop {
        match pc {
            0x82C4C4C0 => {
    //   block [0x82C4C4C0..0x82C4C588)
	// 82C4C4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C4C4: 4805CF45  bl 0x82ca9408
	ctx.lr = 0x82C4C4C8;
	sub_82CA93D0(ctx, base);
	// 82C4C4C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C4CC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C4C4D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4C4D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4C4D8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C4DC: 4B5D2D7D  bl 0x8221f258
	ctx.lr = 0x82C4C4E0;
	sub_8221F258(ctx, base);
	// 82C4C4E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4C4E4: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C4E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4C4EC: 4805CF95  bl 0x82ca9480
	ctx.lr = 0x82C4C4F0;
	sub_82CA9480(ctx, base);
	// 82C4C4F0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4C4F4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82C4C4F8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82C4C4FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C4C500: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C4C504: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82C4C508: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4C50C: 40990058  ble cr6, 0x82c4c564
	if !ctx.cr[6].gt {
	pc = 0x82C4C564; continue 'dispatch;
	}
	// 82C4C510: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C514: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C4C518: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82C4C51C: 40990028  ble cr6, 0x82c4c544
	if !ctx.cr[6].gt {
	pc = 0x82C4C544; continue 'dispatch;
	}
	// 82C4C520: A0AB0000  lhz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C524: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C4C528: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 82C4C52C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82C4C530: B0A90000  sth r5, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u16 ) };
	// 82C4C534: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 82C4C538: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C53C: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C4C540: 4198FFE0  blt cr6, 0x82c4c520
	if ctx.cr[6].lt {
	pc = 0x82C4C520; continue 'dispatch;
	}
	// 82C4C544: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C548: 38E70002  addi r7, r7, 2
	ctx.r[7].s64 = ctx.r[7].s64 + 2;
	// 82C4C54C: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4C550: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82C4C554: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4C558: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4C55C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C4C560: 4198FFB0  blt cr6, 0x82c4c510
	if ctx.cr[6].lt {
	pc = 0x82C4C510; continue 'dispatch;
	}
	// 82C4C564: 911D0000  stw r8, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C4C568: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4C56C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C570: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4C574: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82C4C578: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4C57C: 4BBF9235  bl 0x828457b0
	ctx.lr = 0x82C4C580;
	sub_828457B0(ctx, base);
	// 82C4C580: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4C584: 4805CED4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4C588 size=76
    let mut pc: u32 = 0x82C4C588;
    'dispatch: loop {
        match pc {
            0x82C4C588 => {
    //   block [0x82C4C588..0x82C4C5D4)
	// 82C4C588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C58C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4C590: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C594: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82C4C598: 4B5D2CC1  bl 0x8221f258
	ctx.lr = 0x82C4C59C;
	sub_8221F258(ctx, base);
	// 82C4C59C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C5A0: 419A0020  beq cr6, 0x82c4c5c0
	if ctx.cr[6].eq {
	pc = 0x82C4C5C0; continue 'dispatch;
	}
	// 82C4C5A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4C5A8: 394BC9DC  addi r10, r11, -0x3624
	ctx.r[10].s64 = ctx.r[11].s64 + -13860;
	// 82C4C5AC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4C5B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4C5B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4C5B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4C5BC: 4E800020  blr
	return;
	// 82C4C5C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4C5C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4C5C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4C5CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4C5D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4C5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4C5D8 size=1140
    let mut pc: u32 = 0x82C4C5D8;
    'dispatch: loop {
        match pc {
            0x82C4C5D8 => {
    //   block [0x82C4C5D8..0x82C4CA4C)
	// 82C4C5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4C5DC: 4805CE15  bl 0x82ca93f0
	ctx.lr = 0x82C4C5E0;
	sub_82CA93D0(ctx, base);
	// 82C4C5E0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4C5E4: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82C4C5E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4C5EC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82C4C5F0: 419A0450  beq cr6, 0x82c4ca40
	if ctx.cr[6].eq {
	pc = 0x82C4CA40; continue 'dispatch;
	}
	// 82C4C5F4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C5F8: 3ADC0004  addi r22, r28, 4
	ctx.r[22].s64 = ctx.r[28].s64 + 4;
	// 82C4C5FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4C600: 409A0440  bne cr6, 0x82c4ca40
	if !ctx.cr[6].eq {
	pc = 0x82C4CA40; continue 'dispatch;
	}
	// 82C4C604: 38C04000  li r6, 0x4000
	ctx.r[6].s64 = 16384;
	// 82C4C608: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C4C60C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4C610: 4BF01DE1  bl 0x82b4e3f0
	ctx.lr = 0x82C4C614;
	sub_82B4E3F0(ctx, base);
	// 82C4C614: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4C618: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C61C: 419A0424  beq cr6, 0x82c4ca40
	if ctx.cr[6].eq {
	pc = 0x82C4CA40; continue 'dispatch;
	}
	// 82C4C620: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82C4C624: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82C4C628: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 82C4C62C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82C4C630: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82C4C634: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82C4C638: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C63C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4C640: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4C644: 4E800421  bctrl
	ctx.lr = 0x82C4C648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C648: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4C64C: 419803D8  blt cr6, 0x82c4ca24
	if ctx.cr[6].lt {
	pc = 0x82C4CA24; continue 'dispatch;
	}
	// 82C4C650: 3D405249  lis r10, 0x5249
	ctx.r[10].s64 = 1380515840;
	// 82C4C654: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C4C658: 61494646  ori r9, r10, 0x4646
	ctx.r[9].u64 = ctx.r[10].u64 | 17990;
	// 82C4C65C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4C660: 409A0010  bne cr6, 0x82c4c670
	if !ctx.cr[6].eq {
	pc = 0x82C4C670; continue 'dispatch;
	}
	// 82C4C664: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4C668: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4C66C: 48000018  b 0x82c4c684
	pc = 0x82C4C684; continue 'dispatch;
	// 82C4C670: 3D405249  lis r10, 0x5249
	ctx.r[10].s64 = 1380515840;
	// 82C4C674: 61494658  ori r9, r10, 0x4658
	ctx.r[9].u64 = ctx.r[10].u64 | 18008;
	// 82C4C678: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4C67C: 409A03A8  bne cr6, 0x82c4ca24
	if !ctx.cr[6].eq {
	pc = 0x82C4CA24; continue 'dispatch;
	}
	// 82C4C680: 933C0008  stw r25, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82C4C684: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C688: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4C68C: 419A002C  beq cr6, 0x82c4c6b8
	if ctx.cr[6].eq {
	pc = 0x82C4C6B8; continue 'dispatch;
	}
	// 82C4C690: 8961006C  lbz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4C694: 8941006F  lbz r10, 0x6f(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 82C4C698: 8921006E  lbz r9, 0x6e(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 82C4C69C: 8901006D  lbz r8, 0x6d(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(109 as u32) ) } as u64;
	// 82C4C6A0: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 82C4C6A4: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 82C4C6A8: 99210055  stb r9, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[9].u8 ) };
	// 82C4C6AC: 99010056  stb r8, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[8].u8 ) };
	// 82C4C6B0: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4C6B4: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82C4C6B8: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82C4C6BC: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82C4C6C0: 93210084  stw r25, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[25].u32 ) };
	// 82C4C6C4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4C6C8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82C4C6CC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C4C6D0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4C6D4: 82E1006C  lwz r23, 0x6c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4C6D8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C6DC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4C6E0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4C6E4: 4E800421  bctrl
	ctx.lr = 0x82C4C6E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C6E8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4C6EC: 41980338  blt cr6, 0x82c4ca24
	if ctx.cr[6].lt {
	pc = 0x82C4CA24; continue 'dispatch;
	}
	// 82C4C6F0: 3D605741  lis r11, 0x5741
	ctx.r[11].s64 = 1463877632;
	// 82C4C6F4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C4C6F8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4C6FC: 61695645  ori r9, r11, 0x5645
	ctx.r[9].u64 = ctx.r[11].u64 | 22085;
	// 82C4C700: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4C704: 409A0324  bne cr6, 0x82c4ca28
	if !ctx.cr[6].eq {
	pc = 0x82C4CA28; continue 'dispatch;
	}
	// 82C4C708: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 82C4C70C: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82C4C710: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82C4C714: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82C4C718: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C4C71C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C720: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4C724: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4C728: 4E800421  bctrl
	ctx.lr = 0x82C4C72C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C72C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4C730: 419802A4  blt cr6, 0x82c4c9d4
	if ctx.cr[6].lt {
	pc = 0x82C4C9D4; continue 'dispatch;
	}
	// 82C4C734: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4C738: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C73C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4C740: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C744: 4E800421  bctrl
	ctx.lr = 0x82C4C748;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C748: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C74C: 547B003E  slwi r27, r3, 0
	ctx.r[27].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82C4C750: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C4C754: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4C758: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C75C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4C760: 4E800421  bctrl
	ctx.lr = 0x82C4C764;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C764: 80FC0008  lwz r7, 8(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4C76C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C4C770: 419A002C  beq cr6, 0x82c4c79c
	if ctx.cr[6].eq {
	pc = 0x82C4C79C; continue 'dispatch;
	}
	// 82C4C774: 8961006F  lbz r11, 0x6f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 82C4C778: 8941006D  lbz r10, 0x6d(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(109 as u32) ) } as u64;
	// 82C4C77C: 8921006C  lbz r9, 0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4C780: 8901006E  lbz r8, 0x6e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 82C4C784: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82C4C788: 99410056  stb r10, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[10].u8 ) };
	// 82C4C78C: 99210057  stb r9, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[9].u8 ) };
	// 82C4C790: 99010055  stb r8, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[8].u8 ) };
	// 82C4C794: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4C798: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82C4C79C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82C4C7A0: 2B1F0002  cmplwi cr6, r31, 2
	ctx.cr[6].compare_u32(ctx.r[31].u32, 2 as u32, &mut ctx.xer);
	// 82C4C7A4: 409801BC  bge cr6, 0x82c4c960
	if !ctx.cr[6].lt {
	pc = 0x82C4C960; continue 'dispatch;
	}
	// 82C4C7A8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C7AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4C7B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4C7B4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4C7B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C7BC: 4E800421  bctrl
	ctx.lr = 0x82C4C7C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C7C0: 81380000  lwz r9, 0(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C7C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C4C7C8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82C4C7CC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82C4C7D0: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4C7D4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4C7D8: 4E800421  bctrl
	ctx.lr = 0x82C4C7DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C7DC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82C4C7E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C4C7E4: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C7E8: 4BF063D1  bl 0x82b52bb8
	ctx.lr = 0x82C4C7EC;
	sub_82B52BB8(ctx, base);
	// 82C4C7EC: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C7F0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C4C7F4: 7CBE3050  subf r5, r30, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[30].s64;
	// 82C4C7F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4C7FC: 7CA40034  cntlzw r4, r5
	ctx.r[4].u64 = if ctx.r[5].u32 == 0 { 32 } else { ctx.r[5].u32.leading_zeros() as u64 };
	// 82C4C800: 549EDFFE  rlwinm r30, r4, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 82C4C804: 419A0018  beq cr6, 0x82c4c81c
	if ctx.cr[6].eq {
	pc = 0x82C4C81C; continue 'dispatch;
	}
	// 82C4C808: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C80C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4C810: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C814: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4C818: 4E800421  bctrl
	ctx.lr = 0x82C4C81C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C81C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C4C820: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C824: 419A0014  beq cr6, 0x82c4c838
	if ctx.cr[6].eq {
	pc = 0x82C4C838; continue 'dispatch;
	}
	// 82C4C828: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C82C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C830: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C834: 4E800421  bctrl
	ctx.lr = 0x82C4C838;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C838: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4C83C: 80A1006C  lwz r5, 0x6c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4C840: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C4C844: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82C4C848: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4C84C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C4C850: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 82C4C854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4C858: 4800ABB9  bl 0x82c57410
	ctx.lr = 0x82C4C85C;
	sub_82C57410(ctx, base);
	// 82C4C85C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4C860: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4C864: 419A01C0  beq cr6, 0x82c4ca24
	if ctx.cr[6].eq {
	pc = 0x82C4CA24; continue 'dispatch;
	}
	// 82C4C868: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C4C86C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4C870: 419A00F0  beq cr6, 0x82c4c960
	if ctx.cr[6].eq {
	pc = 0x82C4C960; continue 'dispatch;
	}
	// 82C4C874: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82C4C878: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C4C87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4C880: 419A0090  beq cr6, 0x82c4c910
	if ctx.cr[6].eq {
	pc = 0x82C4C910; continue 'dispatch;
	}
	// 82C4C884: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4C888: 83A1006C  lwz r29, 0x6c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4C88C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C890: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4C894: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C898: 4E800421  bctrl
	ctx.lr = 0x82C4C89C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C89C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C4C8A0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82C4C8A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82C4C8A8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82C4C8AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82C4C8B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C4C8B4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C4C8B8: 4BF074B1  bl 0x82b53d68
	ctx.lr = 0x82C4C8BC;
	sub_82B53D68(ctx, base);
	// 82C4C8BC: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C4C8C0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C4C8C4: 419A004C  beq cr6, 0x82c4c910
	if ctx.cr[6].eq {
	pc = 0x82C4C910; continue 'dispatch;
	}
	// 82C4C8C8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C8CC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82C4C8D0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4C8D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C8D8: 4E800421  bctrl
	ctx.lr = 0x82C4C8DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C8DC: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C8E0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C4C8E4: 419A0010  beq cr6, 0x82c4c8f4
	if ctx.cr[6].eq {
	pc = 0x82C4C8F4; continue 'dispatch;
	}
	// 82C4C8E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4C8EC: 4800AD75  bl 0x82c57660
	ctx.lr = 0x82C4C8F0;
	sub_82C57660(ctx, base);
	// 82C4C8F0: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82C4C8F4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C4C8F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4C8FC: 419A0014  beq cr6, 0x82c4c910
	if ctx.cr[6].eq {
	pc = 0x82C4C910; continue 'dispatch;
	}
	// 82C4C900: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C904: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4C908: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C90C: 4E800421  bctrl
	ctx.lr = 0x82C4C910;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C910: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82C4C914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4C918: 419A0048  beq cr6, 0x82c4c960
	if ctx.cr[6].eq {
	pc = 0x82C4C960; continue 'dispatch;
	}
	// 82C4C91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4C920: 4800ACC9  bl 0x82c575e8
	ctx.lr = 0x82C4C924;
	sub_82C575E8(ctx, base);
	// 82C4C924: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C4C928: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4C92C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4C930: 419A00F8  beq cr6, 0x82c4ca28
	if ctx.cr[6].eq {
	pc = 0x82C4CA28; continue 'dispatch;
	}
	// 82C4C934: 9321008C  stw r25, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[25].u32 ) };
	// 82C4C938: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82C4C93C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82C4C940: 80A1006C  lwz r5, 0x6c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4C944: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C948: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4C94C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C950: 4E800421  bctrl
	ctx.lr = 0x82C4C954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C954: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4C958: 419800CC  blt cr6, 0x82c4ca24
	if ctx.cr[6].lt {
	pc = 0x82C4CA24; continue 'dispatch;
	}
	// 82C4C95C: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82C4C960: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4C964: 39570008  addi r10, r23, 8
	ctx.r[10].s64 = ctx.r[23].s64 + 8;
	// 82C4C968: 7D3B5A14  add r9, r27, r11
	ctx.r[9].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82C4C96C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4C970: 40980064  bge cr6, 0x82c4c9d4
	if !ctx.cr[6].lt {
	pc = 0x82C4C9D4; continue 'dispatch;
	}
	// 82C4C974: 574A063E  clrlwi r10, r26, 0x18
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82C4C978: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4C97C: 419A0028  beq cr6, 0x82c4c9a4
	if ctx.cr[6].eq {
	pc = 0x82C4C9A4; continue 'dispatch;
	}
	// 82C4C980: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4C984: 79640020  clrldi r4, r11, 0x20
	ctx.r[4].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82C4C988: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C4C98C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C990: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4C994: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C998: 4E800421  bctrl
	ctx.lr = 0x82C4C99C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C99C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4C9A0: 41980084  blt cr6, 0x82c4ca24
	if ctx.cr[6].lt {
	pc = 0x82C4CA24; continue 'dispatch;
	}
	// 82C4C9A4: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82C4C9A8: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 82C4C9AC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4C9B0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82C4C9B4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82C4C9B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C4C9BC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C9C0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4C9C4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4C9C8: 4E800421  bctrl
	ctx.lr = 0x82C4C9CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C9CC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4C9D0: 4098FD64  bge cr6, 0x82c4c734
	if !ctx.cr[6].lt {
	pc = 0x82C4C734; continue 'dispatch;
	}
	// 82C4C9D4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82C4C9D8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C4C9DC: 4BC1E3B5  bl 0x8286ad90
	ctx.lr = 0x82C4C9E0;
	sub_8286AD90(ctx, base);
	// 82C4C9E0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4C9E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4C9E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4C9EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4C9F0: 4E800421  bctrl
	ctx.lr = 0x82C4C9F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4C9F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4C9F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4C9FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CA00: 419A0018  beq cr6, 0x82c4ca18
	if ctx.cr[6].eq {
	pc = 0x82C4CA18; continue 'dispatch;
	}
	// 82C4CA04: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CA08: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4CA0C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4CA10: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4CA14: 4E800421  bctrl
	ctx.lr = 0x82C4CA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4CA18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4CA1C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C4CA20: 4805CA20  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 82C4CA24: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4CA28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4CA2C: 419A0014  beq cr6, 0x82c4ca40
	if ctx.cr[6].eq {
	pc = 0x82C4CA40; continue 'dispatch;
	}
	// 82C4CA30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CA34: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4CA38: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4CA3C: 4E800421  bctrl
	ctx.lr = 0x82C4CA40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4CA40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4CA44: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C4CA48: 4805C9F8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4CA50 size=100
    let mut pc: u32 = 0x82C4CA50;
    'dispatch: loop {
        match pc {
            0x82C4CA50 => {
    //   block [0x82C4CA50..0x82C4CAB4)
	// 82C4CA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4CA54: 4805C9B9  bl 0x82ca940c
	ctx.lr = 0x82C4CA58;
	sub_82CA93D0(ctx, base);
	// 82C4CA58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4CA5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C4CA60: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4CA64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4CA68: 419A0044  beq cr6, 0x82c4caac
	if ctx.cr[6].eq {
	pc = 0x82C4CAAC; continue 'dispatch;
	}
	// 82C4CA6C: 3BDD000C  addi r30, r29, 0xc
	ctx.r[30].s64 = ctx.r[29].s64 + 12;
	// 82C4CA70: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 82C4CA74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4CA78: 4800A9D1  bl 0x82c57448
	ctx.lr = 0x82C4CA7C;
	sub_82C57448(ctx, base);
	// 82C4CA7C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82C4CA80: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82C4CA84: 4082FFF0  bne 0x82c4ca74
	if !ctx.cr[0].eq {
	pc = 0x82C4CA74; continue 'dispatch;
	}
	// 82C4CA88: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4CA8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4CA90: 419A001C  beq cr6, 0x82c4caac
	if ctx.cr[6].eq {
	pc = 0x82C4CAAC; continue 'dispatch;
	}
	// 82C4CA94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CA98: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4CA9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4CAA0: 4E800421  bctrl
	ctx.lr = 0x82C4CAA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4CAA4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C4CAA8: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C4CAAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4CAB0: 4805C9AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4CAB8 size=100
    let mut pc: u32 = 0x82C4CAB8;
    'dispatch: loop {
        match pc {
            0x82C4CAB8 => {
    //   block [0x82C4CAB8..0x82C4CB1C)
	// 82C4CAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4CABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4CAC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4CAC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4CAC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4CACC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4CAD0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82C4CAD4: 4B5D2785  bl 0x8221f258
	ctx.lr = 0x82C4CAD8;
	sub_8221F258(ctx, base);
	// 82C4CAD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4CADC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C4CAE0: 419A0020  beq cr6, 0x82c4cb00
	if ctx.cr[6].eq {
	pc = 0x82C4CB00; continue 'dispatch;
	}
	// 82C4CAE4: 4BFC48F5  bl 0x82c113d8
	ctx.lr = 0x82C4CAE8;
	sub_82C113D8(ctx, base);
	// 82C4CAE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4CAEC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82C4CAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4CAF4: 394BCA30  addi r10, r11, -0x35d0
	ctx.r[10].s64 = ctx.r[11].s64 + -13776;
	// 82C4CAF8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4CAFC: 48000008  b 0x82c4cb04
	pc = 0x82C4CB04; continue 'dispatch;
	// 82C4CB00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4CB04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4CB08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4CB0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4CB10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4CB14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4CB18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4CB20 size=204
    let mut pc: u32 = 0x82C4CB20;
    'dispatch: loop {
        match pc {
            0x82C4CB20 => {
    //   block [0x82C4CB20..0x82C4CBEC)
	// 82C4CB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4CB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4CB28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4CB2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4CB30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4CB34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4CB38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4CB3C: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82C4CB40: 4BFFFA99  bl 0x82c4c5d8
	ctx.lr = 0x82C4CB44;
	sub_82C4C5D8(ctx, base);
	// 82C4CB44: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CB48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CB4C: 409A000C  bne cr6, 0x82c4cb58
	if !ctx.cr[6].eq {
	pc = 0x82C4CB58; continue 'dispatch;
	}
	// 82C4CB50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4CB54: 48000080  b 0x82c4cbd4
	pc = 0x82C4CBD4; continue 'dispatch;
	// 82C4CB58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CB5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4CB60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4CB64: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4CB68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4CB6C: 4E800421  bctrl
	ctx.lr = 0x82C4CB70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4CB70: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C4CB74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4CB78: 83E90000  lwz r31, 0(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CB7C: 4BF0603D  bl 0x82b52bb8
	ctx.lr = 0x82C4CB80;
	sub_82B52BB8(ctx, base);
	// 82C4CB80: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CB84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4CB88: 7CFF4050  subf r7, r31, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[31].s64;
	// 82C4CB8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CB90: 7CE60034  cntlzw r6, r7
	ctx.r[6].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 82C4CB94: 54C5DFFE  rlwinm r5, r6, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 82C4CB98: 98BE0054  stb r5, 0x54(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[5].u8 ) };
	// 82C4CB9C: 419A0018  beq cr6, 0x82c4cbb4
	if ctx.cr[6].eq {
	pc = 0x82C4CBB4; continue 'dispatch;
	}
	// 82C4CBA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CBA4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4CBA8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4CBAC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4CBB0: 4E800421  bctrl
	ctx.lr = 0x82C4CBB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4CBB4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4CBB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4CBBC: 419A0014  beq cr6, 0x82c4cbd0
	if ctx.cr[6].eq {
	pc = 0x82C4CBD0; continue 'dispatch;
	}
	// 82C4CBC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CBC4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4CBC8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4CBCC: 4E800421  bctrl
	ctx.lr = 0x82C4CBD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4CBD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4CBD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4CBD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4CBDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4CBE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4CBE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4CBE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4CBF0 size=116
    let mut pc: u32 = 0x82C4CBF0;
    'dispatch: loop {
        match pc {
            0x82C4CBF0 => {
    //   block [0x82C4CBF0..0x82C4CC64)
	// 82C4CBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4CBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4CBF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4CBFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4CC00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4CC04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4CC08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4CC0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4CC10: 394BAAD4  addi r10, r11, -0x552c
	ctx.r[10].s64 = ctx.r[11].s64 + -21804;
	// 82C4CC14: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4CC18: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4CC1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4CC20: 419A0014  beq cr6, 0x82c4cc34
	if ctx.cr[6].eq {
	pc = 0x82C4CC34; continue 'dispatch;
	}
	// 82C4CC24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CC28: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4CC2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4CC30: 4E800421  bctrl
	ctx.lr = 0x82C4CC34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4CC34: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C4CC38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4CC3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CC40: 419A000C  beq cr6, 0x82c4cc4c
	if ctx.cr[6].eq {
	pc = 0x82C4CC4C; continue 'dispatch;
	}
	// 82C4CC44: 4BBF8B6D  bl 0x828457b0
	ctx.lr = 0x82C4CC48;
	sub_828457B0(ctx, base);
	// 82C4CC48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4CC4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4CC50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4CC54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4CC58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4CC5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4CC60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CC68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4CC68 size=572
    let mut pc: u32 = 0x82C4CC68;
    'dispatch: loop {
        match pc {
            0x82C4CC68 => {
    //   block [0x82C4CC68..0x82C4CEA4)
	// 82C4CC68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4CC6C: 4805C799  bl 0x82ca9404
	ctx.lr = 0x82C4CC70;
	sub_82CA93D0(ctx, base);
	// 82C4CC70: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4CC74: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4CC78: 90A100D4  stw r5, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[5].u32 ) };
	// 82C4CC7C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C4CC80: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4CC84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CC88: 419A000C  beq cr6, 0x82c4cc94
	if ctx.cr[6].eq {
	pc = 0x82C4CC94; continue 'dispatch;
	}
	// 82C4CC8C: 38A100D4  addi r5, r1, 0xd4
	ctx.r[5].s64 = ctx.r[1].s64 + 212;
	// 82C4CC90: 4BFFF831  bl 0x82c4c4c0
	ctx.lr = 0x82C4CC94;
	sub_82C4C4C0(ctx, base);
	// 82C4CC94: 3D008333  lis r8, -0x7ccd
	ctx.r[8].s64 = -2093809664;
	// 82C4CC98: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4CC9C: 80FC0008  lwz r7, 8(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4CCA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C4CCA4: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82C4CCA8: 7CA749D6  mullw r5, r7, r9
	ctx.r[5].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82C4CCAC: B1410070  sth r10, 0x70(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u16 ) };
	// 82C4CCB0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82C4CCB4: 8168500C  lwz r11, 0x500c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20492 as u32) ) } as u64;
	// 82C4CCB8: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82C4CCBC: B0610062  sth r3, 0x62(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[3].u16 ) };
	// 82C4CCC0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C4CCC4: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82C4CCC8: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4CCCC: B0C10060  sth r6, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u16 ) };
	// 82C4CCD0: 55290C3C  rlwinm r9, r9, 1, 0x10, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 82C4CCD4: B081006E  sth r4, 0x6e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(110 as u32), ctx.r[4].u16 ) };
	// 82C4CCD8: 39000012  li r8, 0x12
	ctx.r[8].s64 = 18;
	// 82C4CCDC: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82C4CCE0: B121006C  sth r9, 0x6c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u16 ) };
	// 82C4CCE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CCE8: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82C4CCEC: 409A0010  bne cr6, 0x82c4ccfc
	if !ctx.cr[6].eq {
	pc = 0x82C4CCFC; continue 'dispatch;
	}
	// 82C4CCF0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82C4CCF4: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82C4CCF8: 48000008  b 0x82c4cd00
	pc = 0x82C4CD00; continue 'dispatch;
	// 82C4CCFC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CD00: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82C4CD04: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CD08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CD0C: 4BFFF72D  bl 0x82c4c438
	ctx.lr = 0x82C4CD10;
	sub_82C4C438(ctx, base);
	// 82C4CD10: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CD14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CD18: 409A0010  bne cr6, 0x82c4cd28
	if !ctx.cr[6].eq {
	pc = 0x82C4CD28; continue 'dispatch;
	}
	// 82C4CD1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4CD20: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C4CD24: 4805C730  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4CD28: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4CD2C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82C4CD30: 388BCA50  addi r4, r11, -0x35b0
	ctx.r[4].s64 = ctx.r[11].s64 + -13744;
	// 82C4CD34: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CD38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CD3C: 4BFFF6FD  bl 0x82c4c438
	ctx.lr = 0x82C4CD40;
	sub_82C4C438(ctx, base);
	// 82C4CD40: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CD44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4CD48: 419AFFD4  beq cr6, 0x82c4cd1c
	if ctx.cr[6].eq {
	pc = 0x82C4CD1C; continue 'dispatch;
	}
	// 82C4CD4C: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82C4CD50: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82C4CD54: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4CD58: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CD5C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C4CD60: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C4CD64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CD68: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82C4CD6C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C4CD70: 4BFFF6C9  bl 0x82c4c438
	ctx.lr = 0x82C4CD74;
	sub_82C4C438(ctx, base);
	// 82C4CD74: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CD78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4CD7C: 419AFFA0  beq cr6, 0x82c4cd1c
	if ctx.cr[6].eq {
	pc = 0x82C4CD1C; continue 'dispatch;
	}
	// 82C4CD80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4CD84: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82C4CD88: 388BCA48  addi r4, r11, -0x35b8
	ctx.r[4].s64 = ctx.r[11].s64 + -13752;
	// 82C4CD8C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CD90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CD94: 4BFFF6A5  bl 0x82c4c438
	ctx.lr = 0x82C4CD98;
	sub_82C4C438(ctx, base);
	// 82C4CD98: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CD9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4CDA0: 419AFF7C  beq cr6, 0x82c4cd1c
	if ctx.cr[6].eq {
	pc = 0x82C4CD1C; continue 'dispatch;
	}
	// 82C4CDA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4CDA8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82C4CDAC: 388BCA40  addi r4, r11, -0x35c0
	ctx.r[4].s64 = ctx.r[11].s64 + -13760;
	// 82C4CDB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CDB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CDB8: 4BFFF681  bl 0x82c4c438
	ctx.lr = 0x82C4CDBC;
	sub_82C4C438(ctx, base);
	// 82C4CDBC: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CDC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4CDC4: 419AFF58  beq cr6, 0x82c4cd1c
	if ctx.cr[6].eq {
	pc = 0x82C4CD1C; continue 'dispatch;
	}
	// 82C4CDC8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82C4CDCC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CDD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C4CDD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CDD8: 4BFFF661  bl 0x82c4c438
	ctx.lr = 0x82C4CDDC;
	sub_82C4C438(ctx, base);
	// 82C4CDDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CDE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CDE4: 419AFF38  beq cr6, 0x82c4cd1c
	if ctx.cr[6].eq {
	pc = 0x82C4CD1C; continue 'dispatch;
	}
	// 82C4CDE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CDEC: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4CDF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C4CDF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CDF8: 4BFFF641  bl 0x82c4c438
	ctx.lr = 0x82C4CDFC;
	sub_82C4C438(ctx, base);
	// 82C4CDFC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CE00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CE04: 419AFF18  beq cr6, 0x82c4cd1c
	if ctx.cr[6].eq {
	pc = 0x82C4CD1C; continue 'dispatch;
	}
	// 82C4CE08: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82C4CE0C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82C4CE10: 388BF22C  addi r4, r11, -0xdd4
	ctx.r[4].s64 = ctx.r[11].s64 + -3540;
	// 82C4CE14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CE18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CE1C: 4BFFF61D  bl 0x82c4c438
	ctx.lr = 0x82C4CE20;
	sub_82C4C438(ctx, base);
	// 82C4CE20: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CE24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4CE28: 419AFEF4  beq cr6, 0x82c4cd1c
	if ctx.cr[6].eq {
	pc = 0x82C4CD1C; continue 'dispatch;
	}
	// 82C4CE2C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82C4CE30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CE34: 388100D4  addi r4, r1, 0xd4
	ctx.r[4].s64 = ctx.r[1].s64 + 212;
	// 82C4CE38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CE3C: 4BFFF5FD  bl 0x82c4c438
	ctx.lr = 0x82C4CE40;
	sub_82C4C438(ctx, base);
	// 82C4CE40: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CE44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CE48: 419AFED4  beq cr6, 0x82c4cd1c
	if ctx.cr[6].eq {
	pc = 0x82C4CD1C; continue 'dispatch;
	}
	// 82C4CE4C: 83C100D4  lwz r30, 0xd4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82C4CE50: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C4CE54: 419A0044  beq cr6, 0x82c4ce98
	if ctx.cr[6].eq {
	pc = 0x82C4CE98; continue 'dispatch;
	}
	// 82C4CE58: 3F600010  lis r27, 0x10
	ctx.r[27].s64 = 1048576;
	// 82C4CE5C: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C4CE60: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82C4CE64: 41980008  blt cr6, 0x82c4ce6c
	if ctx.cr[6].lt {
	pc = 0x82C4CE6C; continue 'dispatch;
	}
	// 82C4CE68: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82C4CE6C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C4CE70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C4CE74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4CE78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4CE7C: 4BFFF5BD  bl 0x82c4c438
	ctx.lr = 0x82C4CE80;
	sub_82C4C438(ctx, base);
	// 82C4CE80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CE88: 419AFE94  beq cr6, 0x82c4cd1c
	if ctx.cr[6].eq {
	pc = 0x82C4CD1C; continue 'dispatch;
	}
	// 82C4CE8C: 7FDFF051  subf. r30, r31, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C4CE90: 7FBFEA14  add r29, r31, r29
	ctx.r[29].u64 = ctx.r[31].u64 + ctx.r[29].u64;
	// 82C4CE94: 4082FFC8  bne 0x82c4ce5c
	if !ctx.cr[0].eq {
	pc = 0x82C4CE5C; continue 'dispatch;
	}
	// 82C4CE98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4CE9C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C4CEA0: 4805C5B4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4CEA8 size=140
    let mut pc: u32 = 0x82C4CEA8;
    'dispatch: loop {
        match pc {
            0x82C4CEA8 => {
    //   block [0x82C4CEA8..0x82C4CF34)
	// 82C4CEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4CEAC: 4805C561  bl 0x82ca940c
	ctx.lr = 0x82C4CEB0;
	sub_82CA93D0(ctx, base);
	// 82C4CEB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4CEB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4CEB8: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 82C4CEBC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C4CEC0: 4B5D2399  bl 0x8221f258
	ctx.lr = 0x82C4CEC4;
	sub_8221F258(ctx, base);
	// 82C4CEC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4CEC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C4CECC: 419A0050  beq cr6, 0x82c4cf1c
	if ctx.cr[6].eq {
	pc = 0x82C4CF1C; continue 'dispatch;
	}
	// 82C4CED0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4CED4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C4CED8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4CEDC: 394BC9F4  addi r10, r11, -0x360c
	ctx.r[10].s64 = ctx.r[11].s64 + -13836;
	// 82C4CEE0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4CEE4: 4800A9ED  bl 0x82c578d0
	ctx.lr = 0x82C4CEE8;
	sub_82C578D0(ctx, base);
	// 82C4CEE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C4CEEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4CEF0: 993F0054  stb r9, 0x54(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[9].u8 ) };
	// 82C4CEF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4CEF8: 4BFFFC29  bl 0x82c4cb20
	ctx.lr = 0x82C4CEFC;
	sub_82C4CB20(ctx, base);
	// 82C4CEFC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4CF00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4CF04: 409A0024  bne cr6, 0x82c4cf28
	if !ctx.cr[6].eq {
	pc = 0x82C4CF28; continue 'dispatch;
	}
	// 82C4CF08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4CF10: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C4CF14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4CF18: 4E800421  bctrl
	ctx.lr = 0x82C4CF1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4CF1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4CF20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4CF24: 4805C538  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82C4CF28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4CF2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4CF30: 4805C52C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4CF38 size=128
    let mut pc: u32 = 0x82C4CF38;
    'dispatch: loop {
        match pc {
            0x82C4CF38 => {
    //   block [0x82C4CF38..0x82C4CFB8)
	// 82C4CF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4CF3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4CF40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4CF44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4CF48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4CF4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4CF50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4CF54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4CF58: 392BC9F4  addi r9, r11, -0x360c
	ctx.r[9].s64 = ctx.r[11].s64 + -13836;
	// 82C4CF5C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4CF60: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4CF64: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C4CF68: 419A000C  beq cr6, 0x82c4cf74
	if ctx.cr[6].eq {
	pc = 0x82C4CF74; continue 'dispatch;
	}
	// 82C4CF6C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4CF70: 4BFFFAE1  bl 0x82c4ca50
	ctx.lr = 0x82C4CF74;
	sub_82C4CA50(ctx, base);
	// 82C4CF74: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C4CF78: 4800A9A1  bl 0x82c57918
	ctx.lr = 0x82C4CF7C;
	sub_82C57918(ctx, base);
	// 82C4CF7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4CF80: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C4CF84: 392BC940  addi r9, r11, -0x36c0
	ctx.r[9].s64 = ctx.r[11].s64 + -14016;
	// 82C4CF88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4CF8C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4CF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4CF94: 419A000C  beq cr6, 0x82c4cfa0
	if ctx.cr[6].eq {
	pc = 0x82C4CFA0; continue 'dispatch;
	}
	// 82C4CF98: 4BBF8819  bl 0x828457b0
	ctx.lr = 0x82C4CF9C;
	sub_828457B0(ctx, base);
	// 82C4CF9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4CFA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4CFA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4CFA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4CFAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4CFB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4CFB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4CFB8 size=56
    let mut pc: u32 = 0x82C4CFB8;
    'dispatch: loop {
        match pc {
            0x82C4CFB8 => {
    //   block [0x82C4CFB8..0x82C4CFF0)
	// 82C4CFB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CFBC: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4CFC0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CFC4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4CFC8: 419A0028  beq cr6, 0x82c4cff0
	if ctx.cr[6].eq {
		sub_82C4CFF0(ctx, base);
		return;
	}
	// 82C4CFCC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4CFD0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4CFD4: 419A000C  beq cr6, 0x82c4cfe0
	if ctx.cr[6].eq {
	pc = 0x82C4CFE0; continue 'dispatch;
	}
	// 82C4CFD8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C4CFDC: 409AFFF0  bne cr6, 0x82c4cfcc
	if !ctx.cr[6].eq {
	pc = 0x82C4CFCC; continue 'dispatch;
	}
	// 82C4CFE0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4CFE4: 419A000C  beq cr6, 0x82c4cff0
	if ctx.cr[6].eq {
		sub_82C4CFF0(ctx, base);
		return;
	}
	// 82C4CFE8: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4CFEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4CFF0 size=8
    let mut pc: u32 = 0x82C4CFF0;
    'dispatch: loop {
        match pc {
            0x82C4CFF0 => {
    //   block [0x82C4CFF0..0x82C4CFF8)
	// 82C4CFF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4CFF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4CFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4CFF8 size=192
    let mut pc: u32 = 0x82C4CFF8;
    'dispatch: loop {
        match pc {
            0x82C4CFF8 => {
    //   block [0x82C4CFF8..0x82C4D0B8)
	// 82C4CFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4CFFC: 4805C40D  bl 0x82ca9408
	ctx.lr = 0x82C4D000;
	sub_82CA93D0(ctx, base);
	// 82C4D000: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4D004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4D008: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4D00C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C4D010: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D014: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D018: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4D01C: 4E800421  bctrl
	ctx.lr = 0x82C4D020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D020: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D024: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4D028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D02C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4D030: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D034: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4D038: 4E800421  bctrl
	ctx.lr = 0x82C4D03C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D03C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D040: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C4D044: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4D048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D04C: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D050: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C4D054: 4E800421  bctrl
	ctx.lr = 0x82C4D058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D058: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4D05C: 409A0054  bne cr6, 0x82c4d0b0
	if !ctx.cr[6].eq {
	pc = 0x82C4D0B0; continue 'dispatch;
	}
	// 82C4D060: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D064: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4D068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D06C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D070: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4D074: 4E800421  bctrl
	ctx.lr = 0x82C4D078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D078: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D07C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4D080: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4D084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D088: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D08C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4D090: 4E800421  bctrl
	ctx.lr = 0x82C4D094;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D094: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D098: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C4D09C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4D0A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D0A4: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D0A8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C4D0AC: 4E800421  bctrl
	ctx.lr = 0x82C4D0B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D0B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4D0B4: 4805C3A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4D0B8 size=172
    let mut pc: u32 = 0x82C4D0B8;
    'dispatch: loop {
        match pc {
            0x82C4D0B8 => {
    //   block [0x82C4D0B8..0x82C4D164)
	// 82C4D0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4D0BC: 4805C349  bl 0x82ca9404
	ctx.lr = 0x82C4D0C0;
	sub_82CA93D0(ctx, base);
	// 82C4D0C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4D0C4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4D0C8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C4D0CC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C4D0D0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D0D4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4D0D8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4D0DC: 83BC0000  lwz r29, 0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D0E0: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D0E4: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D0E8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4D0EC: 419A0038  beq cr6, 0x82c4d124
	if ctx.cr[6].eq {
	pc = 0x82C4D124; continue 'dispatch;
	}
	// 82C4D0F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C4D0F4: 80BE0010  lwz r5, 0x10(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4D0F8: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4D0FC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C4D100: 4BFFFEF9  bl 0x82c4cff8
	ctx.lr = 0x82C4D104;
	sub_82C4CFF8(ctx, base);
	// 82C4D104: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4D108: 4099000C  ble cr6, 0x82c4d114
	if !ctx.cr[6].gt {
	pc = 0x82C4D114; continue 'dispatch;
	}
	// 82C4D10C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D110: 48000008  b 0x82c4d118
	pc = 0x82C4D118; continue 'dispatch;
	// 82C4D114: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D118: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D11C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4D120: 409AFFD0  bne cr6, 0x82c4d0f0
	if !ctx.cr[6].eq {
	pc = 0x82C4D0F0; continue 'dispatch;
	}
	// 82C4D124: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C4D128: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D12C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4D130: 419A001C  beq cr6, 0x82c4d14c
	if ctx.cr[6].eq {
	pc = 0x82C4D14C; continue 'dispatch;
	}
	// 82C4D134: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C4D138: 80BE0010  lwz r5, 0x10(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4D13C: 809D0010  lwz r4, 0x10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4D140: 4BFFFEB9  bl 0x82c4cff8
	ctx.lr = 0x82C4D144;
	sub_82C4CFF8(ctx, base);
	// 82C4D144: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4D148: 40990010  ble cr6, 0x82c4d158
	if !ctx.cr[6].gt {
	pc = 0x82C4D158; continue 'dispatch;
	}
	// 82C4D14C: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C4D150: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4D154: 4805C300  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4D158: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C4D15C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4D160: 4805C2F4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D168 size=52
    let mut pc: u32 = 0x82C4D168;
    'dispatch: loop {
        match pc {
            0x82C4D168 => {
    //   block [0x82C4D168..0x82C4D19C)
	// 82C4D168: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D16C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D170: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4D174: 419A0028  beq cr6, 0x82c4d19c
	if ctx.cr[6].eq {
		sub_82C4D19C(ctx, base);
		return;
	}
	// 82C4D178: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D17C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4D180: 419A0014  beq cr6, 0x82c4d194
	if ctx.cr[6].eq {
	pc = 0x82C4D194; continue 'dispatch;
	}
	// 82C4D184: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C4D188: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D18C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4D190: 409AFFF4  bne cr6, 0x82c4d184
	if !ctx.cr[6].eq {
	pc = 0x82C4D184; continue 'dispatch;
	}
	// 82C4D194: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82C4D198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D19C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D19C size=52
    let mut pc: u32 = 0x82C4D19C;
    'dispatch: loop {
        match pc {
            0x82C4D19C => {
    //   block [0x82C4D19C..0x82C4D1D0)
	// 82C4D19C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D1A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D1A4: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4D1A8: 409A0018  bne cr6, 0x82c4d1c0
	if !ctx.cr[6].eq {
	pc = 0x82C4D1C0; continue 'dispatch;
	}
	// 82C4D1AC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C4D1B0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D1B4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D1B8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C4D1BC: 419AFFF0  beq cr6, 0x82c4d1ac
	if ctx.cr[6].eq {
	pc = 0x82C4D1AC; continue 'dispatch;
	}
	// 82C4D1C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D1C4: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82C4D1C8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4D1CC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D1D0 size=8
    let mut pc: u32 = 0x82C4D1D0;
    'dispatch: loop {
        match pc {
            0x82C4D1D0 => {
    //   block [0x82C4D1D0..0x82C4D1D8)
	// 82C4D1D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4D1D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4D1D8 size=228
    let mut pc: u32 = 0x82C4D1D8;
    'dispatch: loop {
        match pc {
            0x82C4D1D8 => {
    //   block [0x82C4D1D8..0x82C4D2BC)
	// 82C4D1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4D1DC: 4805C225  bl 0x82ca9400
	ctx.lr = 0x82C4D1E0;
	sub_82CA93D0(ctx, base);
	// 82C4D1E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4D1E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C4D1E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4D1EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C4D1F0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82C4D1F4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D1F8: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D1FC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D200: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4D204: 419A00A0  beq cr6, 0x82c4d2a4
	if ctx.cr[6].eq {
	pc = 0x82C4D2A4; continue 'dispatch;
	}
	// 82C4D208: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D20C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D210: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4D214: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4D218: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D21C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4D220: 4E800421  bctrl
	ctx.lr = 0x82C4D224;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D224: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D228: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C4D22C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4D230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D234: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D238: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4D23C: 4E800421  bctrl
	ctx.lr = 0x82C4D240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D240: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4D244: 409A0044  bne cr6, 0x82c4d288
	if !ctx.cr[6].eq {
	pc = 0x82C4D288; continue 'dispatch;
	}
	// 82C4D248: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D24C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4D250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D254: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D258: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4D25C: 4E800421  bctrl
	ctx.lr = 0x82C4D260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D260: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D264: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C4D268: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C4D26C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D270: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D274: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4D278: 4E800421  bctrl
	ctx.lr = 0x82C4D27C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D27C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4D280: 419A0030  beq cr6, 0x82c4d2b0
	if ctx.cr[6].eq {
	pc = 0x82C4D2B0; continue 'dispatch;
	}
	// 82C4D284: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4D288: 4098000C  bge cr6, 0x82c4d294
	if !ctx.cr[6].lt {
	pc = 0x82C4D294; continue 'dispatch;
	}
	// 82C4D28C: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D290: 48000008  b 0x82c4d298
	pc = 0x82C4D298; continue 'dispatch;
	// 82C4D294: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D298: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D29C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4D2A0: 409AFF68  bne cr6, 0x82c4d208
	if !ctx.cr[6].eq {
	pc = 0x82C4D208; continue 'dispatch;
	}
	// 82C4D2A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4D2A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4D2AC: 4805C1A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 82C4D2B0: 807D0010  lwz r3, 0x10(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4D2B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4D2B8: 4805C198  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4D2C0 size=648
    let mut pc: u32 = 0x82C4D2C0;
    'dispatch: loop {
        match pc {
            0x82C4D2C0 => {
    //   block [0x82C4D2C0..0x82C4D548)
	// 82C4D2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4D2C4: 4805C145  bl 0x82ca9408
	ctx.lr = 0x82C4D2C8;
	sub_82CA93D0(ctx, base);
	// 82C4D2C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4D2CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C4D2D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4D2D4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C4D2D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4D2DC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D2E0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4D2E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4D2E8: 4E800421  bctrl
	ctx.lr = 0x82C4D2EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D2EC: 7FE3E214  add r31, r3, r28
	ctx.r[31].u64 = ctx.r[3].u64 + ctx.r[28].u64;
	// 82C4D2F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4D2F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4D2F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C4D2FC: 939F0010  stw r28, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 82C4D300: 4BFFFDB9  bl 0x82c4d0b8
	ctx.lr = 0x82C4D304;
	sub_82C4D0B8(ctx, base);
	// 82C4D304: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82C4D308: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C4D30C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D310: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D314: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D318: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C4D31C: 419A0218  beq cr6, 0x82c4d534
	if ctx.cr[6].eq {
	pc = 0x82C4D534; continue 'dispatch;
	}
	// 82C4D320: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D324: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D328: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4D32C: 409A0100  bne cr6, 0x82c4d42c
	if !ctx.cr[6].eq {
	pc = 0x82C4D42C; continue 'dispatch;
	}
	// 82C4D330: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D334: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D338: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C4D33C: 419A0028  beq cr6, 0x82c4d364
	if ctx.cr[6].eq {
	pc = 0x82C4D364; continue 'dispatch;
	}
	// 82C4D340: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D344: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D348: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D34C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D350: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D354: 90E9000C  stw r7, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D358: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D35C: 83E60008  lwz r31, 8(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D360: 480001C4  b 0x82c4d524
	pc = 0x82C4D524; continue 'dispatch;
	// 82C4D364: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D368: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4D36C: 409A0054  bne cr6, 0x82c4d3c0
	if !ctx.cr[6].eq {
	pc = 0x82C4D3C0; continue 'dispatch;
	}
	// 82C4D370: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4D374: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C4D378: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D37C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C4D380: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D384: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D388: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C4D38C: 419A0008  beq cr6, 0x82c4d394
	if ctx.cr[6].eq {
	pc = 0x82C4D394; continue 'dispatch;
	}
	// 82C4D390: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C4D394: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D398: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D39C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D3A0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D3A4: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4D3A8: 409A000C  bne cr6, 0x82c4d3b4
	if !ctx.cr[6].eq {
	pc = 0x82C4D3B4; continue 'dispatch;
	}
	// 82C4D3AC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D3B0: 48000008  b 0x82c4d3b8
	pc = 0x82C4D3B8; continue 'dispatch;
	// 82C4D3B4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D3B8: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C4D3BC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4D3C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D3C4: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D3C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D3CC: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D3D0: 90E9000C  stw r7, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D3D4: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D3D8: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D3DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D3E0: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D3E4: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82C4D3E8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D3EC: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D3F0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4D3F4: 419A0008  beq cr6, 0x82c4d3fc
	if ctx.cr[6].eq {
	pc = 0x82C4D3FC; continue 'dispatch;
	}
	// 82C4D3F8: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D3FC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D400: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C4D404: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D408: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D40C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C4D410: 409A0010  bne cr6, 0x82c4d420
	if !ctx.cr[6].eq {
	pc = 0x82C4D420; continue 'dispatch;
	}
	// 82C4D414: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D418: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4D41C: 48000104  b 0x82c4d520
	pc = 0x82C4D520; continue 'dispatch;
	// 82C4D420: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D424: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4D428: 480000F8  b 0x82c4d520
	pc = 0x82C4D520; continue 'dispatch;
	// 82C4D42C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D430: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D434: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C4D438: 419A0028  beq cr6, 0x82c4d460
	if ctx.cr[6].eq {
	pc = 0x82C4D460; continue 'dispatch;
	}
	// 82C4D43C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D440: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D444: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D448: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D44C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D450: 90E9000C  stw r7, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D454: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D458: 83E60008  lwz r31, 8(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D45C: 480000C8  b 0x82c4d524
	pc = 0x82C4D524; continue 'dispatch;
	// 82C4D460: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D464: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4D468: 409A0054  bne cr6, 0x82c4d4bc
	if !ctx.cr[6].eq {
	pc = 0x82C4D4BC; continue 'dispatch;
	}
	// 82C4D46C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4D470: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C4D474: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D478: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4D47C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D480: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D484: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4D488: 419A0008  beq cr6, 0x82c4d490
	if ctx.cr[6].eq {
	pc = 0x82C4D490; continue 'dispatch;
	}
	// 82C4D48C: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C4D490: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D494: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D498: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D49C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D4A0: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4D4A4: 409A000C  bne cr6, 0x82c4d4b0
	if !ctx.cr[6].eq {
	pc = 0x82C4D4B0; continue 'dispatch;
	}
	// 82C4D4A8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D4AC: 48000008  b 0x82c4d4b4
	pc = 0x82C4D4B4; continue 'dispatch;
	// 82C4D4B0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D4B4: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C4D4B8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4D4BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D4C0: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D4C4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D4C8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D4CC: 90E9000C  stw r7, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D4D0: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D4D4: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D4D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D4DC: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D4E0: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82C4D4E4: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D4E8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D4EC: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C4D4F0: 419A0008  beq cr6, 0x82c4d4f8
	if ctx.cr[6].eq {
	pc = 0x82C4D4F8; continue 'dispatch;
	}
	// 82C4D4F4: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D4F8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D4FC: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C4D500: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D504: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D508: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C4D50C: 409A000C  bne cr6, 0x82c4d518
	if !ctx.cr[6].eq {
	pc = 0x82C4D518; continue 'dispatch;
	}
	// 82C4D510: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D514: 48000008  b 0x82c4d51c
	pc = 0x82C4D51C; continue 'dispatch;
	// 82C4D518: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D51C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4D520: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4D524: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D528: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D52C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C4D530: 409AFDF0  bne cr6, 0x82c4d320
	if !ctx.cr[6].eq {
	pc = 0x82C4D320; continue 'dispatch;
	}
	// 82C4D534: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D538: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D53C: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D540: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4D544: 4805BF14  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4D548 size=88
    let mut pc: u32 = 0x82C4D548;
    'dispatch: loop {
        match pc {
            0x82C4D548 => {
    //   block [0x82C4D548..0x82C4D5A0)
	// 82C4D548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4D54C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4D550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4D554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4D558: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4D55C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D560: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4D564: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C4D568: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C4D56C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4D570: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4D574: 4E800421  bctrl
	ctx.lr = 0x82C4D578;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4D578: 7C83F214  add r4, r3, r30
	ctx.r[4].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 82C4D57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4D580: 4BFFFBE9  bl 0x82c4d168
	ctx.lr = 0x82C4D584;
	sub_82C4D168(ctx, base);
	// 82C4D584: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4D588: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4D58C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4D590: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4D594: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4D598: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4D59C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D5A0 size=148
    let mut pc: u32 = 0x82C4D5A0;
    'dispatch: loop {
        match pc {
            0x82C4D5A0 => {
    //   block [0x82C4D5A0..0x82C4D634)
	// 82C4D5A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D5A4: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D5A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C4D5AC: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D5B0: 409A0324  bne cr6, 0x82c4d8d4
	if !ctx.cr[6].eq {
		sub_82C4D8D4(ctx, base);
		return;
	}
	// 82C4D5B4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C4D5B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82C4D5BC: 7F062040  cmplw cr6, r6, r4
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C4D5C0: 419A030C  beq cr6, 0x82c4d8cc
	if ctx.cr[6].eq {
		sub_82C4D8B0(ctx, base);
		return;
	}
	// 82C4D5C4: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D5C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D5CC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4D5D0: 409A0178  bne cr6, 0x82c4d748
	if !ctx.cr[6].eq {
		sub_82C4D748(ctx, base);
		return;
	}
	// 82C4D5D4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D5D8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D5DC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C4D5E0: 419A0068  beq cr6, 0x82c4d648
	if ctx.cr[6].eq {
		sub_82C4D634(ctx, base);
		return;
	}
	// 82C4D5E4: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D5E8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D5EC: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D5F0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D5F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D5F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D5FC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C4D600: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D604: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D608: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D60C: 419A0008  beq cr6, 0x82c4d614
	if ctx.cr[6].eq {
	pc = 0x82C4D614; continue 'dispatch;
	}
	// 82C4D610: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D614: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D618: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C4D61C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D620: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D624: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D628: 409A000C  bne cr6, 0x82c4d634
	if !ctx.cr[6].eq {
		sub_82C4D634(ctx, base);
		return;
	}
	// 82C4D62C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D630: 48000008  b 0x82c4d638
	sub_82C4D634(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D634(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D634 size=64
    let mut pc: u32 = 0x82C4D634;
    'dispatch: loop {
        match pc {
            0x82C4D634 => {
    //   block [0x82C4D634..0x82C4D674)
	// 82C4D634: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D638: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4D63C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4D640: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D644: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D648: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D64C: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D650: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C4D654: 409A0088  bne cr6, 0x82c4d6dc
	if !ctx.cr[6].eq {
		sub_82C4D6C8(ctx, base);
		return;
	}
	// 82C4D658: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D65C: 80A5000C  lwz r5, 0xc(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D660: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C4D664: 409A0010  bne cr6, 0x82c4d674
	if !ctx.cr[6].eq {
		sub_82C4D674(ctx, base);
		return;
	}
	// 82C4D668: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D66C: 80840008  lwz r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D670: 48000250  b 0x82c4d8c0
	sub_82C4D8B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D674(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D674 size=84
    let mut pc: u32 = 0x82C4D674;
    'dispatch: loop {
        match pc {
            0x82C4D674 => {
    //   block [0x82C4D674..0x82C4D6C8)
	// 82C4D674: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C4D678: 409A0064  bne cr6, 0x82c4d6dc
	if !ctx.cr[6].eq {
		sub_82C4D6C8(ctx, base);
		return;
	}
	// 82C4D67C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D680: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D684: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D688: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D68C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D690: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4D694: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D698: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D69C: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4D6A0: 419A0008  beq cr6, 0x82c4d6a8
	if ctx.cr[6].eq {
	pc = 0x82C4D6A8; continue 'dispatch;
	}
	// 82C4D6A4: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D6A8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D6AC: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C4D6B0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D6B4: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D6B8: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D6BC: 409A000C  bne cr6, 0x82c4d6c8
	if !ctx.cr[6].eq {
		sub_82C4D6C8(ctx, base);
		return;
	}
	// 82C4D6C0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D6C4: 48000008  b 0x82c4d6cc
	sub_82C4D6C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D6C8 size=116
    let mut pc: u32 = 0x82C4D6C8;
    'dispatch: loop {
        match pc {
            0x82C4D6C8 => {
    //   block [0x82C4D6C8..0x82C4D73C)
	// 82C4D6C8: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D6CC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4D6D0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4D6D4: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D6D8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D6DC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D6E0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C4D6E4: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D6E8: 9109000C  stw r8, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D6EC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D6F0: 9105000C  stw r8, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D6F4: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D6F8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D6FC: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D700: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82C4D704: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D708: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D70C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D710: 419A0008  beq cr6, 0x82c4d718
	if ctx.cr[6].eq {
	pc = 0x82C4D718; continue 'dispatch;
	}
	// 82C4D714: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D718: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D71C: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C4D720: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D724: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D728: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D72C: 409A0010  bne cr6, 0x82c4d73c
	if !ctx.cr[6].eq {
		sub_82C4D73C(ctx, base);
		return;
	}
	// 82C4D730: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D734: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4D738: 48000180  b 0x82c4d8b8
	sub_82C4D8B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D73C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D73C size=12
    let mut pc: u32 = 0x82C4D73C;
    'dispatch: loop {
        match pc {
            0x82C4D73C => {
    //   block [0x82C4D73C..0x82C4D748)
	// 82C4D73C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D740: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4D744: 48000174  b 0x82c4d8b8
	sub_82C4D8B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D748 size=96
    let mut pc: u32 = 0x82C4D748;
    'dispatch: loop {
        match pc {
            0x82C4D748 => {
    //   block [0x82C4D748..0x82C4D7A8)
	// 82C4D748: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D74C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D750: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C4D754: 419A0068  beq cr6, 0x82c4d7bc
	if ctx.cr[6].eq {
		sub_82C4D7A8(ctx, base);
		return;
	}
	// 82C4D758: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D75C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D760: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D764: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D768: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D76C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D770: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4D774: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D778: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D77C: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4D780: 419A0008  beq cr6, 0x82c4d788
	if ctx.cr[6].eq {
	pc = 0x82C4D788; continue 'dispatch;
	}
	// 82C4D784: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D788: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D78C: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C4D790: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D794: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D798: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D79C: 409A000C  bne cr6, 0x82c4d7a8
	if !ctx.cr[6].eq {
		sub_82C4D7A8(ctx, base);
		return;
	}
	// 82C4D7A0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D7A4: 48000008  b 0x82c4d7ac
	sub_82C4D7A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D7A8 size=64
    let mut pc: u32 = 0x82C4D7A8;
    'dispatch: loop {
        match pc {
            0x82C4D7A8 => {
    //   block [0x82C4D7A8..0x82C4D7E8)
	// 82C4D7A8: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D7AC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4D7B0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4D7B4: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D7B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D7BC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D7C0: 80A9000C  lwz r5, 0xc(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D7C4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C4D7C8: 409A0020  bne cr6, 0x82c4d7e8
	if !ctx.cr[6].eq {
		sub_82C4D7E8(ctx, base);
		return;
	}
	// 82C4D7CC: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D7D0: 80A5000C  lwz r5, 0xc(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D7D4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C4D7D8: 409A0010  bne cr6, 0x82c4d7e8
	if !ctx.cr[6].eq {
		sub_82C4D7E8(ctx, base);
		return;
	}
	// 82C4D7DC: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D7E0: 80840008  lwz r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D7E4: 480000DC  b 0x82c4d8c0
	sub_82C4D8B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D7E8 size=88
    let mut pc: u32 = 0x82C4D7E8;
    'dispatch: loop {
        match pc {
            0x82C4D7E8 => {
    //   block [0x82C4D7E8..0x82C4D840)
	// 82C4D7E8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D7EC: 80A5000C  lwz r5, 0xc(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D7F0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C4D7F4: 409A0060  bne cr6, 0x82c4d854
	if !ctx.cr[6].eq {
		sub_82C4D840(ctx, base);
		return;
	}
	// 82C4D7F8: 9109000C  stw r8, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D7FC: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4D800: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D804: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D808: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C4D80C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D810: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D814: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D818: 419A0008  beq cr6, 0x82c4d820
	if ctx.cr[6].eq {
	pc = 0x82C4D820; continue 'dispatch;
	}
	// 82C4D81C: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D820: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D824: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C4D828: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D82C: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D830: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D834: 409A000C  bne cr6, 0x82c4d840
	if !ctx.cr[6].eq {
		sub_82C4D840(ctx, base);
		return;
	}
	// 82C4D838: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D83C: 48000008  b 0x82c4d844
	sub_82C4D840(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D840 size=112
    let mut pc: u32 = 0x82C4D840;
    'dispatch: loop {
        match pc {
            0x82C4D840 => {
    //   block [0x82C4D840..0x82C4D8B0)
	// 82C4D840: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D844: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4D848: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4D84C: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D850: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D854: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D858: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C4D85C: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D860: 9109000C  stw r8, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D864: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D868: 9105000C  stw r8, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D86C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D870: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D874: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D878: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C4D87C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D880: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D884: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4D888: 419A0008  beq cr6, 0x82c4d890
	if ctx.cr[6].eq {
	pc = 0x82C4D890; continue 'dispatch;
	}
	// 82C4D88C: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D890: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D894: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C4D898: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D89C: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D8A0: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D8A4: 409A000C  bne cr6, 0x82c4d8b0
	if !ctx.cr[6].eq {
		sub_82C4D8B0(ctx, base);
		return;
	}
	// 82C4D8A8: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C4D8AC: 48000008  b 0x82c4d8b4
	sub_82C4D8B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D8B0 size=36
    let mut pc: u32 = 0x82C4D8B0;
    'dispatch: loop {
        match pc {
            0x82C4D8B0 => {
    //   block [0x82C4D8B0..0x82C4D8D4)
	// 82C4D8B0: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D8B4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4D8B8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4D8BC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82C4D8C0: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D8C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4D8C8: 419AFCF4  beq cr6, 0x82c4d5bc
	if ctx.cr[6].eq {
		sub_82C4D5A0(ctx, base);
		return;
	}
	// 82C4D8CC: 9104000C  stw r8, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4D8D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D8D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4D8D4 size=12
    let mut pc: u32 = 0x82C4D8D4;
    'dispatch: loop {
        match pc {
            0x82C4D8D4 => {
    //   block [0x82C4D8D4..0x82C4D8E0)
	// 82C4D8D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4D8D8: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4D8DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4D8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4D8E0 size=344
    let mut pc: u32 = 0x82C4D8E0;
    'dispatch: loop {
        match pc {
            0x82C4D8E0 => {
    //   block [0x82C4D8E0..0x82C4DA38)
	// 82C4D8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4D8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4D8E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4D8EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4D8F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4D8F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C4D8F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4D8FC: 80E60004  lwz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D900: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D904: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C4D908: 419A001C  beq cr6, 0x82c4d924
	if ctx.cr[6].eq {
	pc = 0x82C4D924; continue 'dispatch;
	}
	// 82C4D90C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D910: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C4D914: 419A0010  beq cr6, 0x82c4d924
	if ctx.cr[6].eq {
	pc = 0x82C4D924; continue 'dispatch;
	}
	// 82C4D918: 4BFFF851  bl 0x82c4d168
	ctx.lr = 0x82C4D91C;
	sub_82C4D168(ctx, base);
	// 82C4D91C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4D920: 48000008  b 0x82c4d928
	pc = 0x82C4D928; continue 'dispatch;
	// 82C4D924: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82C4D928: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D92C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C4D930: 409A000C  bne cr6, 0x82c4d93c
	if !ctx.cr[6].eq {
	pc = 0x82C4D93C; continue 'dispatch;
	}
	// 82C4D934: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D938: 48000008  b 0x82c4d940
	pc = 0x82C4D940; continue 'dispatch;
	// 82C4D93C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C4D940: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D944: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4D948: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D94C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4D950: 409A000C  bne cr6, 0x82c4d95c
	if !ctx.cr[6].eq {
	pc = 0x82C4D95C; continue 'dispatch;
	}
	// 82C4D954: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C4D958: 48000020  b 0x82c4d978
	pc = 0x82C4D978; continue 'dispatch;
	// 82C4D95C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D960: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D964: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4D968: 409A000C  bne cr6, 0x82c4d974
	if !ctx.cr[6].eq {
	pc = 0x82C4D974; continue 'dispatch;
	}
	// 82C4D96C: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C4D970: 48000008  b 0x82c4d978
	pc = 0x82C4D978; continue 'dispatch;
	// 82C4D974: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82C4D978: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C4D97C: 419A007C  beq cr6, 0x82c4d9f8
	if ctx.cr[6].eq {
	pc = 0x82C4D9F8; continue 'dispatch;
	}
	// 82C4D980: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D984: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4D988: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D98C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4D990: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D994: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C4D998: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4D99C: 93E80008  stw r31, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C4D9A0: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D9A4: 93E70008  stw r31, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C4D9A8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4D9AC: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4D9B0: 7F1E2840  cmplw cr6, r30, r5
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4D9B4: 409A000C  bne cr6, 0x82c4d9c0
	if !ctx.cr[6].eq {
	pc = 0x82C4D9C0; continue 'dispatch;
	}
	// 82C4D9B8: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C4D9BC: 48000008  b 0x82c4d9c4
	pc = 0x82C4D9C4; continue 'dispatch;
	// 82C4D9C0: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C4D9C4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D9C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4D9CC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D9D0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4D9D4: 409A000C  bne cr6, 0x82c4d9e0
	if !ctx.cr[6].eq {
	pc = 0x82C4D9E0; continue 'dispatch;
	}
	// 82C4D9D8: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82C4D9DC: 4BFFFBC5  bl 0x82c4d5a0
	ctx.lr = 0x82C4D9E0;
	sub_82C4D5A0(ctx, base);
	// 82C4D9E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4D9E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4D9E8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4D9EC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4D9F0: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C4D9F4: 4800002C  b 0x82c4da20
	pc = 0x82C4DA20; continue 'dispatch;
	// 82C4D9F8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4D9FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4DA00: 409A000C  bne cr6, 0x82c4da0c
	if !ctx.cr[6].eq {
	pc = 0x82C4DA0C; continue 'dispatch;
	}
	// 82C4DA04: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82C4DA08: 4BFFFB99  bl 0x82c4d5a0
	ctx.lr = 0x82C4DA0C;
	sub_82C4D5A0(ctx, base);
	// 82C4DA0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4DA10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4DA14: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4DA18: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4DA1C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C4DA20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4DA24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4DA28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4DA2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4DA30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4DA34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4DA38 size=84
    let mut pc: u32 = 0x82C4DA38;
    'dispatch: loop {
        match pc {
            0x82C4DA38 => {
    //   block [0x82C4DA38..0x82C4DA8C)
	// 82C4DA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4DA3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4DA40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4DA44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4DA48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4DA4C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DA50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4DA54: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C4DA58: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C4DA5C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4DA60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4DA64: 4E800421  bctrl
	ctx.lr = 0x82C4DA68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4DA68: 7C83F214  add r4, r3, r30
	ctx.r[4].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 82C4DA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4DA70: 4BFFFE71  bl 0x82c4d8e0
	ctx.lr = 0x82C4DA74;
	sub_82C4D8E0(ctx, base);
	// 82C4DA74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4DA78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4DA7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4DA80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4DA84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4DA88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4DA90 size=24
    let mut pc: u32 = 0x82C4DA90;
    'dispatch: loop {
        match pc {
            0x82C4DA90 => {
    //   block [0x82C4DA90..0x82C4DAA8)
	// 82C4DA90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4DA94: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4DA98: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4DA9C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4DAA0: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C4DAA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4DAA8 size=244
    let mut pc: u32 = 0x82C4DAA8;
    'dispatch: loop {
        match pc {
            0x82C4DAA8 => {
    //   block [0x82C4DAA8..0x82C4DB9C)
	// 82C4DAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4DAAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4DAB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4DAB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4DAB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4DABC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4DAC0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82C4DAC4: 4B5D1795  bl 0x8221f258
	ctx.lr = 0x82C4DAC8;
	sub_8221F258(ctx, base);
	// 82C4DAC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4DACC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C4DAD0: 419A001C  beq cr6, 0x82c4daec
	if ctx.cr[6].eq {
	pc = 0x82C4DAEC; continue 'dispatch;
	}
	// 82C4DAD4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C4DAD8: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C4DADC: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C4DAE0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C4DAE4: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82C4DAE8: 48000008  b 0x82c4daf0
	pc = 0x82C4DAF0; continue 'dispatch;
	// 82C4DAEC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C4DAF0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4DAF4: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82C4DAF8: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4DAFC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DB00: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DB04: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4DB08: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DB0C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DB10: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C4DB14: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DB18: 93E7000C  stw r31, 0xc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C4DB1C: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DB20: 93E60010  stw r31, 0x10(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82C4DB24: 4B5D1735  bl 0x8221f258
	ctx.lr = 0x82C4DB28;
	sub_8221F258(ctx, base);
	// 82C4DB28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4DB2C: 419A001C  beq cr6, 0x82c4db48
	if ctx.cr[6].eq {
	pc = 0x82C4DB48; continue 'dispatch;
	}
	// 82C4DB30: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C4DB34: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C4DB38: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C4DB3C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C4DB40: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82C4DB44: 48000008  b 0x82c4db4c
	pc = 0x82C4DB4C; continue 'dispatch;
	// 82C4DB48: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C4DB4C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DB50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4DB54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4DB58: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4DB5C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DB60: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DB64: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C4DB68: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DB6C: 80C70000  lwz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DB70: 90C70008  stw r6, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82C4DB74: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DB78: 93E5000C  stw r31, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C4DB7C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DB80: 93E40010  stw r31, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82C4DB84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4DB88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4DB8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4DB90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4DB94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4DB98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4DBA0 size=72
    let mut pc: u32 = 0x82C4DBA0;
    'dispatch: loop {
        match pc {
            0x82C4DBA0 => {
    //   block [0x82C4DBA0..0x82C4DBE8)
	// 82C4DBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4DBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4DBA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4DBAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4DBB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4DBB4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DBB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4DBBC: 419A0008  beq cr6, 0x82c4dbc4
	if ctx.cr[6].eq {
	pc = 0x82C4DBC4; continue 'dispatch;
	}
	// 82C4DBC0: 4BBF7BF1  bl 0x828457b0
	ctx.lr = 0x82C4DBC4;
	sub_828457B0(ctx, base);
	// 82C4DBC4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DBC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4DBCC: 419A0008  beq cr6, 0x82c4dbd4
	if ctx.cr[6].eq {
	pc = 0x82C4DBD4; continue 'dispatch;
	}
	// 82C4DBD0: 4BBF7BE1  bl 0x828457b0
	ctx.lr = 0x82C4DBD4;
	sub_828457B0(ctx, base);
	// 82C4DBD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4DBD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4DBDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4DBE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4DBE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4DBE8 size=16
    let mut pc: u32 = 0x82C4DBE8;
    'dispatch: loop {
        match pc {
            0x82C4DBE8 => {
    //   block [0x82C4DBE8..0x82C4DBF8)
	// 82C4DBE8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DBEC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DBF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4DBF4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4DBF8 size=16
    let mut pc: u32 = 0x82C4DBF8;
    'dispatch: loop {
        match pc {
            0x82C4DBF8 => {
    //   block [0x82C4DBF8..0x82C4DC08)
	// 82C4DBF8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DBFC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DC00: 2B0A003C  cmplwi cr6, r10, 0x3c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 60 as u32, &mut ctx.xer);
	// 82C4DC04: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DC08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4DC08 size=12
    let mut pc: u32 = 0x82C4DC08;
    'dispatch: loop {
        match pc {
            0x82C4DC08 => {
    //   block [0x82C4DC08..0x82C4DC14)
	// 82C4DC08: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82C4DC0C: 2B0A0021  cmplwi cr6, r10, 0x21
	ctx.cr[6].compare_u32(ctx.r[10].u32, 33 as u32, &mut ctx.xer);
	// 82C4DC10: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DC14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4DC14 size=12
    let mut pc: u32 = 0x82C4DC14;
    'dispatch: loop {
        match pc {
            0x82C4DC14 => {
    //   block [0x82C4DC14..0x82C4DC20)
	// 82C4DC14: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82C4DC18: 2B0A002D  cmplwi cr6, r10, 0x2d
	ctx.cr[6].compare_u32(ctx.r[10].u32, 45 as u32, &mut ctx.xer);
	// 82C4DC1C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4DC20 size=12
    let mut pc: u32 = 0x82C4DC20;
    'dispatch: loop {
        match pc {
            0x82C4DC20 => {
    //   block [0x82C4DC20..0x82C4DC2C)
	// 82C4DC20: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82C4DC24: 2B0A002D  cmplwi cr6, r10, 0x2d
	ctx.cr[6].compare_u32(ctx.r[10].u32, 45 as u32, &mut ctx.xer);
	// 82C4DC28: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DC2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4DC2C size=96
    let mut pc: u32 = 0x82C4DC2C;
    'dispatch: loop {
        match pc {
            0x82C4DC2C => {
    //   block [0x82C4DC2C..0x82C4DC8C)
	// 82C4DC2C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82C4DC30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4DC34: 896B0004  lbz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DC38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4DC3C: 419A0044  beq cr6, 0x82c4dc80
	if ctx.cr[6].eq {
	pc = 0x82C4DC80; continue 'dispatch;
	}
	// 82C4DC40: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DC44: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DC48: 2B0A002D  cmplwi cr6, r10, 0x2d
	ctx.cr[6].compare_u32(ctx.r[10].u32, 45 as u32, &mut ctx.xer);
	// 82C4DC4C: 409A001C  bne cr6, 0x82c4dc68
	if !ctx.cr[6].eq {
	pc = 0x82C4DC68; continue 'dispatch;
	}
	// 82C4DC50: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82C4DC54: 2B0A002D  cmplwi cr6, r10, 0x2d
	ctx.cr[6].compare_u32(ctx.r[10].u32, 45 as u32, &mut ctx.xer);
	// 82C4DC58: 409A0010  bne cr6, 0x82c4dc68
	if !ctx.cr[6].eq {
	pc = 0x82C4DC68; continue 'dispatch;
	}
	// 82C4DC5C: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82C4DC60: 2B0A003E  cmplwi cr6, r10, 0x3e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 62 as u32, &mut ctx.xer);
	// 82C4DC64: 419A0028  beq cr6, 0x82c4dc8c
	if ctx.cr[6].eq {
		sub_82C4DC8C(ctx, base);
		return;
	}
	// 82C4DC68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4DC6C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4DC70: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4DC74: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DC78: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4DC7C: 409AFFC4  bne cr6, 0x82c4dc40
	if !ctx.cr[6].eq {
	pc = 0x82C4DC40; continue 'dispatch;
	}
	// 82C4DC80: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DC84: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4DC88: 48000010  b 0x82c4dc98
	sub_82C4DC8C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DC8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4DC8C size=32
    let mut pc: u32 = 0x82C4DC8C;
    'dispatch: loop {
        match pc {
            0x82C4DC8C => {
    //   block [0x82C4DC8C..0x82C4DCAC)
	// 82C4DC8C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DC90: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 82C4DC94: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4DC98: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DC9C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DCA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4DCA4: 409AFF54  bne cr6, 0x82c4dbf8
	if !ctx.cr[6].eq {
		sub_82C4DBF8(ctx, base);
		return;
	}
	// 82C4DCA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4DCB0 size=24
    let mut pc: u32 = 0x82C4DCB0;
    'dispatch: loop {
        match pc {
            0x82C4DCB0 => {
    //   block [0x82C4DCB0..0x82C4DCC8)
	// 82C4DCB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4DCB4: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C4DCB8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4DCBC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4DCC0: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4DCC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4DCC8 size=264
    let mut pc: u32 = 0x82C4DCC8;
    'dispatch: loop {
        match pc {
            0x82C4DCC8 => {
    //   block [0x82C4DCC8..0x82C4DDD0)
	// 82C4DCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4DCCC: 4805B739  bl 0x82ca9404
	ctx.lr = 0x82C4DCD0;
	sub_82CA93D0(ctx, base);
	// 82C4DCD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4DCD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4DCD8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C4DCDC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DCE0: 8BCB0000  lbz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DCE4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C4DCE8: 409A0050  bne cr6, 0x82c4dd38
	if !ctx.cr[6].eq {
	pc = 0x82C4DD38; continue 'dispatch;
	}
	// 82C4DCEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4DCF0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4DCF4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82C4DCF8: 4BFB7A91  bl 0x82c05788
	ctx.lr = 0x82C4DCFC;
	sub_82C05788(ctx, base);
	// 82C4DCFC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4DD00: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C4DD04: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4DD08: 388ACA74  addi r4, r10, -0x358c
	ctx.r[4].s64 = ctx.r[10].s64 + -13708;
	// 82C4DD0C: 3BC9CA68  addi r30, r9, -0x3598
	ctx.r[30].s64 = ctx.r[9].s64 + -13720;
	// 82C4DD10: 4BFB7AE9  bl 0x82c057f8
	ctx.lr = 0x82C4DD14;
	sub_82C057F8(ctx, base);
	// 82C4DD14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4DD18: 4BFB7B19  bl 0x82c05830
	ctx.lr = 0x82C4DD1C;
	sub_82C05830(ctx, base);
	// 82C4DD1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4DD20: 4BFB7AD9  bl 0x82c057f8
	ctx.lr = 0x82C4DD24;
	sub_82C057F8(ctx, base);
	// 82C4DD24: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DD28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4DD2C: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4DD30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4DD34: 4805B720  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4DD38: 7FDC0774  extsb r28, r30
	ctx.r[28].s64 = ctx.r[30].s8 as i64;
	// 82C4DD3C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C4DD40: 419A0014  beq cr6, 0x82c4dd54
	if ctx.cr[6].eq {
	pc = 0x82C4DD54; continue 'dispatch;
	}
	// 82C4DD44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4DD48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4DD4C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4DD50: 4BFFFE99  bl 0x82c4dbe8
	ctx.lr = 0x82C4DD54;
	sub_82C4DBE8(ctx, base);
	// 82C4DD54: 7FAB0774  extsb r11, r29
	ctx.r[11].s64 = ctx.r[29].s8 as i64;
	// 82C4DD58: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C4DD5C: 419A0068  beq cr6, 0x82c4ddc4
	if ctx.cr[6].eq {
	pc = 0x82C4DDC4; continue 'dispatch;
	}
	// 82C4DD60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4DD64: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4DD68: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82C4DD6C: 4BFB7A1D  bl 0x82c05788
	ctx.lr = 0x82C4DD70;
	sub_82C05788(ctx, base);
	// 82C4DD70: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4DD74: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82C4DD78: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4DD7C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C4DD80: 388ACA74  addi r4, r10, -0x358c
	ctx.r[4].s64 = ctx.r[10].s64 + -13708;
	// 82C4DD84: 3B89934C  addi r28, r9, -0x6cb4
	ctx.r[28].s64 = ctx.r[9].s64 + -27828;
	// 82C4DD88: 3B68A6A8  addi r27, r8, -0x5958
	ctx.r[27].s64 = ctx.r[8].s64 + -22872;
	// 82C4DD8C: 4BFB7A6D  bl 0x82c057f8
	ctx.lr = 0x82C4DD90;
	sub_82C057F8(ctx, base);
	// 82C4DD90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4DD94: 4BFB7A9D  bl 0x82c05830
	ctx.lr = 0x82C4DD98;
	sub_82C05830(ctx, base);
	// 82C4DD98: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C4DD9C: 4BFB7A5D  bl 0x82c057f8
	ctx.lr = 0x82C4DDA0;
	sub_82C057F8(ctx, base);
	// 82C4DDA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4DDA4: 4BFB7A8D  bl 0x82c05830
	ctx.lr = 0x82C4DDA8;
	sub_82C05830(ctx, base);
	// 82C4DDA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4DDAC: 4BFB7A4D  bl 0x82c057f8
	ctx.lr = 0x82C4DDB0;
	sub_82C057F8(ctx, base);
	// 82C4DDB0: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DDB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4DDB8: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4DDBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4DDC0: 4805B694  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4DDC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4DDC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4DDCC: 4805B688  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4DDD0 size=256
    let mut pc: u32 = 0x82C4DDD0;
    'dispatch: loop {
        match pc {
            0x82C4DDD0 => {
    //   block [0x82C4DDD0..0x82C4DED0)
	// 82C4DDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4DDD4: 4805B639  bl 0x82ca940c
	ctx.lr = 0x82C4DDD8;
	sub_82CA93D0(ctx, base);
	// 82C4DDD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4DDDC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C4DDE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4DDE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4DDE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4DDEC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82C4DDF0: 4B627649  bl 0x82275438
	ctx.lr = 0x82C4DDF4;
	sub_82275438(ctx, base);
	// 82C4DDF4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DDF8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DDFC: 7D5F0774  extsb r31, r10
	ctx.r[31].s64 = ctx.r[10].s8 as i64;
	// 82C4DE00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4DE04: 4805F4DD  bl 0x82cad2e0
	ctx.lr = 0x82C4DE08;
	sub_82CAD2E0(ctx, base);
	// 82C4DE08: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4DE0C: 409A0018  bne cr6, 0x82c4de24
	if !ctx.cr[6].eq {
	pc = 0x82C4DE24; continue 'dispatch;
	}
	// 82C4DE10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4DE14: 4805F52D  bl 0x82cad340
	ctx.lr = 0x82C4DE18;
	sub_82CAD340(ctx, base);
	// 82C4DE18: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4DE1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4DE20: 419A0008  beq cr6, 0x82c4de28
	if ctx.cr[6].eq {
	pc = 0x82C4DE28; continue 'dispatch;
	}
	// 82C4DE24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4DE28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4DE2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4DE30: 409A0018  bne cr6, 0x82c4de48
	if !ctx.cr[6].eq {
	pc = 0x82C4DE48; continue 'dispatch;
	}
	// 82C4DE34: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DE38: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DE3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4DE40: 2B0A005F  cmplwi cr6, r10, 0x5f
	ctx.cr[6].compare_u32(ctx.r[10].u32, 95 as u32, &mut ctx.xer);
	// 82C4DE44: 409A0008  bne cr6, 0x82c4de4c
	if !ctx.cr[6].eq {
	pc = 0x82C4DE4C; continue 'dispatch;
	}
	// 82C4DE48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4DE4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4DE50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4DE54: 419A0034  beq cr6, 0x82c4de88
	if ctx.cr[6].eq {
	pc = 0x82C4DE88; continue 'dispatch;
	}
	// 82C4DE58: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DE5C: 8BEB0000  lbz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DE60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C4DE64: 419A0014  beq cr6, 0x82c4de78
	if ctx.cr[6].eq {
	pc = 0x82C4DE78; continue 'dispatch;
	}
	// 82C4DE68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4DE6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4DE70: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4DE74: 4BFFFD75  bl 0x82c4dbe8
	ctx.lr = 0x82C4DE78;
	sub_82C4DBE8(ctx, base);
	// 82C4DE78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4DE7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4DE80: 4B5493F1  bl 0x82197270
	ctx.lr = 0x82C4DE84;
	sub_82197270(ctx, base);
	// 82C4DE84: 4BFFFF70  b 0x82c4ddf4
	pc = 0x82C4DDF4; continue 'dispatch;
	// 82C4DE88: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DE8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4DE90: 419A0010  beq cr6, 0x82c4dea0
	if ctx.cr[6].eq {
	pc = 0x82C4DEA0; continue 'dispatch;
	}
	// 82C4DE94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4DE98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4DE9C: 409A0028  bne cr6, 0x82c4dec4
	if !ctx.cr[6].eq {
	pc = 0x82C4DEC4; continue 'dispatch;
	}
	// 82C4DEA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4DEA4: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4DEA8: 388BCA80  addi r4, r11, -0x3580
	ctx.r[4].s64 = ctx.r[11].s64 + -13696;
	// 82C4DEAC: 4BFB78DD  bl 0x82c05788
	ctx.lr = 0x82C4DEB0;
	sub_82C05788(ctx, base);
	// 82C4DEB0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DEB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4DEB8: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C4DEBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4DEC0: 4805B59C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82C4DEC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4DEC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4DECC: 4805B590  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4DED0 size=108
    let mut pc: u32 = 0x82C4DED0;
    'dispatch: loop {
        match pc {
            0x82C4DED0 => {
    //   block [0x82C4DED0..0x82C4DF3C)
	// 82C4DED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4DED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4DED8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4DEDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4DEE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4DEE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DEE8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DEEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4DEF0: 409A0034  bne cr6, 0x82c4df24
	if !ctx.cr[6].eq {
	pc = 0x82C4DF24; continue 'dispatch;
	}
	// 82C4DEF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4DEF8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4DEFC: 388BCAA8  addi r4, r11, -0x3558
	ctx.r[4].s64 = ctx.r[11].s64 + -13656;
	// 82C4DF00: 4BFB7889  bl 0x82c05788
	ctx.lr = 0x82C4DF04;
	sub_82C05788(ctx, base);
	// 82C4DF04: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DF08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4DF0C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C4DF10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4DF14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4DF18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4DF1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4DF20: 4E800020  blr
	return;
	// 82C4DF24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4DF28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4DF2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4DF30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4DF34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4DF38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4DF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4DF40 size=212
    let mut pc: u32 = 0x82C4DF40;
    'dispatch: loop {
        match pc {
            0x82C4DF40 => {
    //   block [0x82C4DF40..0x82C4E014)
	// 82C4DF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4DF44: 4805B4C1  bl 0x82ca9404
	ctx.lr = 0x82C4DF48;
	sub_82CA93D0(ctx, base);
	// 82C4DF48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4DF4C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C4DF50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4DF54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4DF58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4DF5C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82C4DF60: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C4DF64: 4B6274D5  bl 0x82275438
	ctx.lr = 0x82C4DF68;
	sub_82275438(ctx, base);
	// 82C4DF68: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C4DF6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4DF70: 4BFFFD59  bl 0x82c4dcc8
	ctx.lr = 0x82C4DF74;
	sub_82C4DCC8(ctx, base);
	// 82C4DF74: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4DF78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4DF7C: 409A0010  bne cr6, 0x82c4df8c
	if !ctx.cr[6].eq {
	pc = 0x82C4DF8C; continue 'dispatch;
	}
	// 82C4DF80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4DF84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4DF88: 4805B4CC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4DF8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DF90: 7F7D0774  extsb r29, r27
	ctx.r[29].s64 = ctx.r[27].s8 as i64;
	// 82C4DF94: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DF98: 7D490774  extsb r9, r10
	ctx.r[9].s64 = ctx.r[10].s8 as i64;
	// 82C4DF9C: 7F09E800  cmpw cr6, r9, r29
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82C4DFA0: 419A0050  beq cr6, 0x82c4dff0
	if ctx.cr[6].eq {
	pc = 0x82C4DFF0; continue 'dispatch;
	}
	// 82C4DFA4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DFA8: 8BCB0000  lbz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DFAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C4DFB0: 419A0040  beq cr6, 0x82c4dff0
	if ctx.cr[6].eq {
	pc = 0x82C4DFF0; continue 'dispatch;
	}
	// 82C4DFB4: 7FCA0774  extsb r10, r30
	ctx.r[10].s64 = ctx.r[30].s8 as i64;
	// 82C4DFB8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C4DFBC: 419A0014  beq cr6, 0x82c4dfd0
	if ctx.cr[6].eq {
	pc = 0x82C4DFD0; continue 'dispatch;
	}
	// 82C4DFC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4DFC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4DFC8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4DFCC: 4BFFFC1D  bl 0x82c4dbe8
	ctx.lr = 0x82C4DFD0;
	sub_82C4DBE8(ctx, base);
	// 82C4DFD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4DFD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4DFD8: 4B549299  bl 0x82197270
	ctx.lr = 0x82C4DFDC;
	sub_82197270(ctx, base);
	// 82C4DFDC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4DFE0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4DFE4: 7D490774  extsb r9, r10
	ctx.r[9].s64 = ctx.r[10].s8 as i64;
	// 82C4DFE8: 7F09E800  cmpw cr6, r9, r29
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82C4DFEC: 409AFFB8  bne cr6, 0x82c4dfa4
	if !ctx.cr[6].eq {
	pc = 0x82C4DFA4; continue 'dispatch;
	}
	// 82C4DFF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C4DFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4DFF8: 4BFFFCD1  bl 0x82c4dcc8
	ctx.lr = 0x82C4DFFC;
	sub_82C4DCC8(ctx, base);
	// 82C4DFFC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E000: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C4E004: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C4E008: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 82C4E00C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4E010: 4805B444  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4E018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4E018 size=160
    let mut pc: u32 = 0x82C4E018;
    'dispatch: loop {
        match pc {
            0x82C4E018 => {
    //   block [0x82C4E018..0x82C4E0B8)
	// 82C4E018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4E01C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4E020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4E024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4E028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4E02C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4E030: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4E034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E038: 409A0068  bne cr6, 0x82c4e0a0
	if !ctx.cr[6].eq {
	pc = 0x82C4E0A0; continue 'dispatch;
	}
	// 82C4E03C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E040: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E044: 7D5F0774  extsb r31, r10
	ctx.r[31].s64 = ctx.r[10].s8 as i64;
	// 82C4E048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E04C: 4805F335  bl 0x82cad380
	ctx.lr = 0x82C4E050;
	sub_82CAD380(ctx, base);
	// 82C4E050: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4E054: 409A0018  bne cr6, 0x82c4e06c
	if !ctx.cr[6].eq {
	pc = 0x82C4E06C; continue 'dispatch;
	}
	// 82C4E058: 2F1F000A  cmpwi cr6, r31, 0xa
	ctx.cr[6].compare_i32(ctx.r[31].s32, 10, &mut ctx.xer);
	// 82C4E05C: 419A0010  beq cr6, 0x82c4e06c
	if ctx.cr[6].eq {
	pc = 0x82C4E06C; continue 'dispatch;
	}
	// 82C4E060: 2F1F000D  cmpwi cr6, r31, 0xd
	ctx.cr[6].compare_i32(ctx.r[31].s32, 13, &mut ctx.xer);
	// 82C4E064: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4E068: 409A0008  bne cr6, 0x82c4e070
	if !ctx.cr[6].eq {
	pc = 0x82C4E070; continue 'dispatch;
	}
	// 82C4E06C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4E070: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4E074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E078: 419A0028  beq cr6, 0x82c4e0a0
	if ctx.cr[6].eq {
	pc = 0x82C4E0A0; continue 'dispatch;
	}
	// 82C4E07C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E080: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E084: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E088: 419AFFB4  beq cr6, 0x82c4e03c
	if ctx.cr[6].eq {
	pc = 0x82C4E03C; continue 'dispatch;
	}
	// 82C4E08C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4E094: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4E098: 4BFFFB51  bl 0x82c4dbe8
	ctx.lr = 0x82C4E09C;
	sub_82C4DBE8(ctx, base);
	// 82C4E09C: 4BFFFFA0  b 0x82c4e03c
	pc = 0x82C4E03C; continue 'dispatch;
	// 82C4E0A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4E0A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4E0A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4E0AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4E0B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4E0B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4E0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4E0B8 size=204
    let mut pc: u32 = 0x82C4E0B8;
    'dispatch: loop {
        match pc {
            0x82C4E0B8 => {
    //   block [0x82C4E0B8..0x82C4E184)
	// 82C4E0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4E0BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4E0C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4E0C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4E0C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4E0CC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E0D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E0D4: 419A009C  beq cr6, 0x82c4e170
	if ctx.cr[6].eq {
	pc = 0x82C4E170; continue 'dispatch;
	}
	// 82C4E0D8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C4E0DC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E0E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E0E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4E0E8: 409AFFF4  bne cr6, 0x82c4e0dc
	if !ctx.cr[6].eq {
	pc = 0x82C4E0DC; continue 'dispatch;
	}
	// 82C4E0EC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C4E0F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82C4E0F4: 5569003E  slwi r9, r11, 0
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C4E0F8: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82C4E0FC: 41980074  blt cr6, 0x82c4e170
	if ctx.cr[6].lt {
	pc = 0x82C4E170; continue 'dispatch;
	}
	// 82C4E100: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E104: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 82C4E108: 419A0010  beq cr6, 0x82c4e118
	if ctx.cr[6].eq {
	pc = 0x82C4E118; continue 'dispatch;
	}
	// 82C4E10C: 896A0001  lbz r11, 1(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 82C4E110: 2B0B003F  cmplwi cr6, r11, 0x3f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 63 as u32, &mut ctx.xer);
	// 82C4E114: 409A005C  bne cr6, 0x82c4e170
	if !ctx.cr[6].eq {
	pc = 0x82C4E170; continue 'dispatch;
	}
	// 82C4E118: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82C4E11C: 388A0002  addi r4, r10, 2
	ctx.r[4].s64 = ctx.r[10].s64 + 2;
	// 82C4E120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E124: 4B5DEDAD  bl 0x8222ced0
	ctx.lr = 0x82C4E128;
	sub_8222CED0(ctx, base);
	// 82C4E128: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4E12C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E130: 388BCAB8  addi r4, r11, -0x3548
	ctx.r[4].s64 = ctx.r[11].s64 + -13640;
	// 82C4E134: 4B598615  bl 0x821e6748
	ctx.lr = 0x82C4E138;
	sub_821E6748(ctx, base);
	// 82C4E138: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C4E13C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4E140: 40980010  bge cr6, 0x82c4e150
	if !ctx.cr[6].lt {
	pc = 0x82C4E150; continue 'dispatch;
	}
	// 82C4E144: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E148: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4E14C: 4800001C  b 0x82c4e168
	pc = 0x82C4E168; continue 'dispatch;
	// 82C4E150: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E158: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C4E15C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C4E160: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4E164: 4BFFFEB5  bl 0x82c4e018
	ctx.lr = 0x82C4E168;
	sub_82C4E018(ctx, base);
	// 82C4E168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E16C: 4B5C6C6D  bl 0x82214dd8
	ctx.lr = 0x82C4E170;
	sub_82214DD8(ctx, base);
	// 82C4E170: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4E174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4E178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4E17C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4E180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4E188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4E188 size=1468
    let mut pc: u32 = 0x82C4E188;
    'dispatch: loop {
        match pc {
            0x82C4E188 => {
    //   block [0x82C4E188..0x82C4E744)
	// 82C4E188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4E18C: 4805B279  bl 0x82ca9404
	ctx.lr = 0x82C4E190;
	sub_82CA93D0(ctx, base);
	// 82C4E190: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4E194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4E198: 4BFFFE81  bl 0x82c4e018
	ctx.lr = 0x82C4E19C;
	sub_82C4E018(ctx, base);
	// 82C4E19C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E1A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E1A4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4E1A8: 7FCA5850  subf r30, r10, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C4E1AC: 4B5A9655  bl 0x821f7800
	ctx.lr = 0x82C4E1B0;
	sub_821F7800(ctx, base);
	// 82C4E1B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C4E1B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E1B8: 4BFFFC19  bl 0x82c4ddd0
	ctx.lr = 0x82C4E1BC;
	sub_82C4DDD0(ctx, base);
	// 82C4E1BC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E1C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E1C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4E1C8: 419A0570  beq cr6, 0x82c4e738
	if ctx.cr[6].eq {
	pc = 0x82C4E738; continue 'dispatch;
	}
	// 82C4E1CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E1D0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E1D4: 4B5D9B95  bl 0x82227d68
	ctx.lr = 0x82C4E1D8;
	sub_82227D68(ctx, base);
	// 82C4E1D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C4E1DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E1E0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E1E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C4E1E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4E1EC: 4E800421  bctrl
	ctx.lr = 0x82C4E1F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4E1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E1F4: 4BFFFE25  bl 0x82c4e018
	ctx.lr = 0x82C4E1F8;
	sub_82C4E018(ctx, base);
	// 82C4E1F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4E1FC: 3B8BCAA8  addi r28, r11, -0x3558
	ctx.r[28].s64 = ctx.r[11].s64 + -13656;
	// 82C4E200: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E204: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E208: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E20C: 409A0020  bne cr6, 0x82c4e22c
	if !ctx.cr[6].eq {
	pc = 0x82C4E22C; continue 'dispatch;
	}
	// 82C4E210: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4E214: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4E218: 4BFB7571  bl 0x82c05788
	ctx.lr = 0x82C4E21C;
	sub_82C05788(ctx, base);
	// 82C4E21C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E220: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C4E224: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4E228: 48000008  b 0x82c4e230
	pc = 0x82C4E230; continue 'dispatch;
	// 82C4E22C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C4E230: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82C4E234: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E238: 419A04FC  beq cr6, 0x82c4e734
	if ctx.cr[6].eq {
	pc = 0x82C4E734; continue 'dispatch;
	}
	// 82C4E23C: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E240: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82C4E244: 2F0B002F  cmpwi cr6, r11, 0x2f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 47, &mut ctx.xer);
	// 82C4E248: 419A0144  beq cr6, 0x82c4e38c
	if ctx.cr[6].eq {
	pc = 0x82C4E38C; continue 'dispatch;
	}
	// 82C4E24C: 2F0B003E  cmpwi cr6, r11, 0x3e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 62, &mut ctx.xer);
	// 82C4E250: 419A01D4  beq cr6, 0x82c4e424
	if ctx.cr[6].eq {
	pc = 0x82C4E424; continue 'dispatch;
	}
	// 82C4E254: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4E258: 4B5A95A9  bl 0x821f7800
	ctx.lr = 0x82C4E25C;
	sub_821F7800(ctx, base);
	// 82C4E25C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E260: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4E264: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C4E268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E26C: 7FAA5850  subf r29, r10, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C4E270: 4BFFFB61  bl 0x82c4ddd0
	ctx.lr = 0x82C4E274;
	sub_82C4DDD0(ctx, base);
	// 82C4E274: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E278: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4E27C: 419A04B0  beq cr6, 0x82c4e72c
	if ctx.cr[6].eq {
	pc = 0x82C4E72C; continue 'dispatch;
	}
	// 82C4E280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E284: 4BFFFD95  bl 0x82c4e018
	ctx.lr = 0x82C4E288;
	sub_82C4E018(ctx, base);
	// 82C4E288: 3880003D  li r4, 0x3d
	ctx.r[4].s64 = 61;
	// 82C4E28C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E290: 4BFFFA39  bl 0x82c4dcc8
	ctx.lr = 0x82C4E294;
	sub_82C4DCC8(ctx, base);
	// 82C4E294: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E29C: 419A0490  beq cr6, 0x82c4e72c
	if ctx.cr[6].eq {
	pc = 0x82C4E72C; continue 'dispatch;
	}
	// 82C4E2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E2A4: 4BFFFD75  bl 0x82c4e018
	ctx.lr = 0x82C4E2A8;
	sub_82C4E018(ctx, base);
	// 82C4E2A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E2AC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E2B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E2B4: 409A0020  bne cr6, 0x82c4e2d4
	if !ctx.cr[6].eq {
	pc = 0x82C4E2D4; continue 'dispatch;
	}
	// 82C4E2B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4E2BC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4E2C0: 4BFB74C9  bl 0x82c05788
	ctx.lr = 0x82C4E2C4;
	sub_82C05788(ctx, base);
	// 82C4E2C4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E2C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4E2CC: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C4E2D0: 48000008  b 0x82c4e2d8
	pc = 0x82C4E2D8; continue 'dispatch;
	// 82C4E2D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4E2D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4E2DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E2E0: 419A044C  beq cr6, 0x82c4e72c
	if ctx.cr[6].eq {
	pc = 0x82C4E72C; continue 'dispatch;
	}
	// 82C4E2E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4E2E8: 4B5A9519  bl 0x821f7800
	ctx.lr = 0x82C4E2EC;
	sub_821F7800(ctx, base);
	// 82C4E2EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E2F0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C4E2F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E2F8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E2FC: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 82C4E300: 2F0B0027  cmpwi cr6, r11, 0x27
	ctx.cr[6].compare_i32(ctx.r[11].s32, 39, &mut ctx.xer);
	// 82C4E304: 409A0010  bne cr6, 0x82c4e314
	if !ctx.cr[6].eq {
	pc = 0x82C4E314; continue 'dispatch;
	}
	// 82C4E308: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82C4E30C: 4BFFFC35  bl 0x82c4df40
	ctx.lr = 0x82C4E310;
	sub_82C4DF40(ctx, base);
	// 82C4E310: 4800001C  b 0x82c4e32c
	pc = 0x82C4E32C; continue 'dispatch;
	// 82C4E314: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 82C4E318: 409A0010  bne cr6, 0x82c4e328
	if !ctx.cr[6].eq {
	pc = 0x82C4E328; continue 'dispatch;
	}
	// 82C4E31C: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 82C4E320: 4BFFFC21  bl 0x82c4df40
	ctx.lr = 0x82C4E324;
	sub_82C4DF40(ctx, base);
	// 82C4E324: 48000008  b 0x82c4e32c
	pc = 0x82C4E32C; continue 'dispatch;
	// 82C4E328: 4BFFFAA9  bl 0x82c4ddd0
	ctx.lr = 0x82C4E32C;
	sub_82C4DDD0(ctx, base);
	// 82C4E32C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4E334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E338: 419A03F0  beq cr6, 0x82c4e728
	if ctx.cr[6].eq {
	pc = 0x82C4E728; continue 'dispatch;
	}
	// 82C4E33C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E340: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E344: 4B5D9A25  bl 0x82227d68
	ctx.lr = 0x82C4E348;
	sub_82227D68(ctx, base);
	// 82C4E348: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C4E34C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4E350: 4B5D9A19  bl 0x82227d68
	ctx.lr = 0x82C4E354;
	sub_82227D68(ctx, base);
	// 82C4E354: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C4E358: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E35C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C4E360: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4E364: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82C4E368: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4E36C: 4E800421  bctrl
	ctx.lr = 0x82C4E370;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4E370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E374: 4BFFFCA5  bl 0x82c4e018
	ctx.lr = 0x82C4E378;
	sub_82C4E018(ctx, base);
	// 82C4E378: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4E37C: 4B5C6A5D  bl 0x82214dd8
	ctx.lr = 0x82C4E380;
	sub_82214DD8(ctx, base);
	// 82C4E380: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4E384: 4B5C6A55  bl 0x82214dd8
	ctx.lr = 0x82C4E388;
	sub_82214DD8(ctx, base);
	// 82C4E388: 4BFFFE78  b 0x82c4e200
	pc = 0x82C4E200; continue 'dispatch;
	// 82C4E38C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E390: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E398: 419A0014  beq cr6, 0x82c4e3ac
	if ctx.cr[6].eq {
	pc = 0x82C4E3AC; continue 'dispatch;
	}
	// 82C4E39C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E3A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E3A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4E3A8: 4BFFF841  bl 0x82c4dbe8
	ctx.lr = 0x82C4E3AC;
	sub_82C4DBE8(ctx, base);
	// 82C4E3AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E3B0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E3B4: 7D5E0774  extsb r30, r10
	ctx.r[30].s64 = ctx.r[10].s8 as i64;
	// 82C4E3B8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C4E3BC: 419A0014  beq cr6, 0x82c4e3d0
	if ctx.cr[6].eq {
	pc = 0x82C4E3D0; continue 'dispatch;
	}
	// 82C4E3C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E3C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E3C8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4E3CC: 4BFFF81D  bl 0x82c4dbe8
	ctx.lr = 0x82C4E3D0;
	sub_82C4DBE8(ctx, base);
	// 82C4E3D0: 2F1E003E  cmpwi cr6, r30, 0x3e
	ctx.cr[6].compare_i32(ctx.r[30].s32, 62, &mut ctx.xer);
	// 82C4E3D4: 419A002C  beq cr6, 0x82c4e400
	if ctx.cr[6].eq {
	pc = 0x82C4E400; continue 'dispatch;
	}
	// 82C4E3D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4E3DC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4E3E0: 388BCAF4  addi r4, r11, -0x350c
	ctx.r[4].s64 = ctx.r[11].s64 + -13580;
	// 82C4E3E4: 4BFB7415  bl 0x82c057f8
	ctx.lr = 0x82C4E3E8;
	sub_82C057F8(ctx, base);
	// 82C4E3E8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E3EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E3F0: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C4E3F4: 4B5C69E5  bl 0x82214dd8
	ctx.lr = 0x82C4E3F8;
	sub_82214DD8(ctx, base);
	// 82C4E3F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4E3FC: 4805B058  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4E400: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E404: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E408: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E40C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4E410: 4E800421  bctrl
	ctx.lr = 0x82C4E414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4E414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E418: 4B5C69C1  bl 0x82214dd8
	ctx.lr = 0x82C4E41C;
	sub_82214DD8(ctx, base);
	// 82C4E41C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4E420: 4805B034  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4E424: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E428: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E42C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E430: 419A0014  beq cr6, 0x82c4e444
	if ctx.cr[6].eq {
	pc = 0x82C4E444; continue 'dispatch;
	}
	// 82C4E434: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E438: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E43C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4E440: 4BFFF7A9  bl 0x82c4dbe8
	ctx.lr = 0x82C4E444;
	sub_82C4DBE8(ctx, base);
	// 82C4E444: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4E448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E44C: 409A02E8  bne cr6, 0x82c4e734
	if !ctx.cr[6].eq {
	pc = 0x82C4E734; continue 'dispatch;
	}
	// 82C4E450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E454: 4BFFFBC5  bl 0x82c4e018
	ctx.lr = 0x82C4E458;
	sub_82C4E018(ctx, base);
	// 82C4E458: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E45C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E460: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E464: 409A0020  bne cr6, 0x82c4e484
	if !ctx.cr[6].eq {
	pc = 0x82C4E484; continue 'dispatch;
	}
	// 82C4E468: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4E46C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4E470: 4BFB7319  bl 0x82c05788
	ctx.lr = 0x82C4E474;
	sub_82C05788(ctx, base);
	// 82C4E474: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E478: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C4E47C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4E480: 48000008  b 0x82c4e488
	pc = 0x82C4E488; continue 'dispatch;
	// 82C4E484: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C4E488: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82C4E48C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E490: 419A02A4  beq cr6, 0x82c4e734
	if ctx.cr[6].eq {
	pc = 0x82C4E734; continue 'dispatch;
	}
	// 82C4E494: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E498: 2B0A003C  cmplwi cr6, r10, 0x3c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 60 as u32, &mut ctx.xer);
	// 82C4E49C: 409A0030  bne cr6, 0x82c4e4cc
	if !ctx.cr[6].eq {
	pc = 0x82C4E4CC; continue 'dispatch;
	}
	// 82C4E4A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E4A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E4A8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4E4AC: 4BFFF73D  bl 0x82c4dbe8
	ctx.lr = 0x82C4E4B0;
	sub_82C4DBE8(ctx, base);
	// 82C4E4B0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E4B4: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E4B8: 2B09002F  cmplwi cr6, r9, 0x2f
	ctx.cr[6].compare_u32(ctx.r[9].u32, 47 as u32, &mut ctx.xer);
	// 82C4E4BC: 419A00D4  beq cr6, 0x82c4e590
	if ctx.cr[6].eq {
	pc = 0x82C4E590; continue 'dispatch;
	}
	// 82C4E4C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E4C4: 4BFFFCC5  bl 0x82c4e188
	ctx.lr = 0x82C4E4C8;
	sub_82C4E188(ctx, base);
	// 82C4E4C8: 480000AC  b 0x82c4e574
	pc = 0x82C4E574; continue 'dispatch;
	// 82C4E4CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4E4D0: 4B5A9331  bl 0x821f7800
	ctx.lr = 0x82C4E4D4;
	sub_821F7800(ctx, base);
	// 82C4E4D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E4D8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E4DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E4E0: 419A004C  beq cr6, 0x82c4e52c
	if ctx.cr[6].eq {
	pc = 0x82C4E52C; continue 'dispatch;
	}
	// 82C4E4E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E4E8: 8BCB0000  lbz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E4EC: 2B1E003C  cmplwi cr6, r30, 0x3c
	ctx.cr[6].compare_u32(ctx.r[30].u32, 60 as u32, &mut ctx.xer);
	// 82C4E4F0: 419A003C  beq cr6, 0x82c4e52c
	if ctx.cr[6].eq {
	pc = 0x82C4E52C; continue 'dispatch;
	}
	// 82C4E4F4: 7FCA0774  extsb r10, r30
	ctx.r[10].s64 = ctx.r[30].s8 as i64;
	// 82C4E4F8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C4E4FC: 419A0014  beq cr6, 0x82c4e510
	if ctx.cr[6].eq {
	pc = 0x82C4E510; continue 'dispatch;
	}
	// 82C4E500: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E508: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4E50C: 4BFFF6DD  bl 0x82c4dbe8
	ctx.lr = 0x82C4E510;
	sub_82C4DBE8(ctx, base);
	// 82C4E510: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4E514: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4E518: 4B548D59  bl 0x82197270
	ctx.lr = 0x82C4E51C;
	sub_82197270(ctx, base);
	// 82C4E51C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E520: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E528: 409AFFBC  bne cr6, 0x82c4e4e4
	if !ctx.cr[6].eq {
	pc = 0x82C4E4E4; continue 'dispatch;
	}
	// 82C4E52C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E530: 4BFFF9A1  bl 0x82c4ded0
	ctx.lr = 0x82C4E534;
	sub_82C4DED0(ctx, base);
	// 82C4E534: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E538: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4E53C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E540: 419A01F0  beq cr6, 0x82c4e730
	if ctx.cr[6].eq {
	pc = 0x82C4E730; continue 'dispatch;
	}
	// 82C4E544: 4BEEFD0D  bl 0x82b3e250
	ctx.lr = 0x82C4E548;
	sub_82B3E250(ctx, base);
	// 82C4E548: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E54C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4E550: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E554: 4B5D9815  bl 0x82227d68
	ctx.lr = 0x82C4E558;
	sub_82227D68(ctx, base);
	// 82C4E558: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C4E55C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E560: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4E564: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4E568: 4E800421  bctrl
	ctx.lr = 0x82C4E56C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4E56C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4E570: 4B5C6869  bl 0x82214dd8
	ctx.lr = 0x82C4E574;
	sub_82214DD8(ctx, base);
	// 82C4E574: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4E578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E57C: 419AFED4  beq cr6, 0x82c4e450
	if ctx.cr[6].eq {
	pc = 0x82C4E450; continue 'dispatch;
	}
	// 82C4E580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E584: 4B5C6855  bl 0x82214dd8
	ctx.lr = 0x82C4E588;
	sub_82214DD8(ctx, base);
	// 82C4E588: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4E58C: 4805AEC8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4E590: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E594: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E59C: 419A0014  beq cr6, 0x82c4e5b0
	if ctx.cr[6].eq {
	pc = 0x82C4E5B0; continue 'dispatch;
	}
	// 82C4E5A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E5A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E5A8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4E5AC: 4BFFF63D  bl 0x82c4dbe8
	ctx.lr = 0x82C4E5B0;
	sub_82C4DBE8(ctx, base);
	// 82C4E5B0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82C4E5B4: 4B5A924D  bl 0x821f7800
	ctx.lr = 0x82C4E5B8;
	sub_821F7800(ctx, base);
	// 82C4E5B8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82C4E5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E5C0: 4BFFF811  bl 0x82c4ddd0
	ctx.lr = 0x82C4E5C4;
	sub_82C4DDD0(ctx, base);
	// 82C4E5C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E5CC: 409A0060  bne cr6, 0x82c4e62c
	if !ctx.cr[6].eq {
	pc = 0x82C4E62C; continue 'dispatch;
	}
	// 82C4E5D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4E5D4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4E5D8: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82C4E5DC: 4BFB71AD  bl 0x82c05788
	ctx.lr = 0x82C4E5E0;
	sub_82C05788(ctx, base);
	// 82C4E5E0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4E5E4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82C4E5E8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4E5EC: 388ACADC  addi r4, r10, -0x3524
	ctx.r[4].s64 = ctx.r[10].s64 + -13604;
	// 82C4E5F0: 3BC94A08  addi r30, r9, 0x4a08
	ctx.r[30].s64 = ctx.r[9].s64 + 18952;
	// 82C4E5F4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82C4E5F8: 4BFB7201  bl 0x82c057f8
	ctx.lr = 0x82C4E5FC;
	sub_82C057F8(ctx, base);
	// 82C4E5FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4E600: 4BFB71C1  bl 0x82c057c0
	ctx.lr = 0x82C4E604;
	sub_82C057C0(ctx, base);
	// 82C4E604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4E608: 4BFB71F1  bl 0x82c057f8
	ctx.lr = 0x82C4E60C;
	sub_82C057F8(ctx, base);
	// 82C4E60C: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E610: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82C4E614: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C4E618: 4B5C67C1  bl 0x82214dd8
	ctx.lr = 0x82C4E61C;
	sub_82214DD8(ctx, base);
	// 82C4E61C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E620: 4B5C67B9  bl 0x82214dd8
	ctx.lr = 0x82C4E624;
	sub_82214DD8(ctx, base);
	// 82C4E624: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4E628: 4805AE2C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4E62C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82C4E630: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C4E634: 386BFFDF  addi r3, r11, -0x21
	ctx.r[3].s64 = ctx.r[11].s64 + -33;
	// 82C4E638: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E63C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C4E640: 419A0008  beq cr6, 0x82c4e648
	if ctx.cr[6].eq {
	pc = 0x82C4E648; continue 'dispatch;
	}
	// 82C4E644: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E648: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4E64C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E650: 419A0008  beq cr6, 0x82c4e658
	if ctx.cr[6].eq {
	pc = 0x82C4E658; continue 'dispatch;
	}
	// 82C4E654: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E658: 4805E4F9  bl 0x82cacb50
	ctx.lr = 0x82C4E65C;
	sub_82CACB50(ctx, base);
	// 82C4E65C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4E660: 419A007C  beq cr6, 0x82c4e6dc
	if ctx.cr[6].eq {
	pc = 0x82C4E6DC; continue 'dispatch;
	}
	// 82C4E664: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4E668: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4E66C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82C4E670: 4BFB7119  bl 0x82c05788
	ctx.lr = 0x82C4E674;
	sub_82C05788(ctx, base);
	// 82C4E674: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4E678: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82C4E67C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4E680: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82C4E684: 388ACABC  addi r4, r10, -0x3544
	ctx.r[4].s64 = ctx.r[10].s64 + -13636;
	// 82C4E688: 3BC94A08  addi r30, r9, 0x4a08
	ctx.r[30].s64 = ctx.r[9].s64 + 18952;
	// 82C4E68C: 3BA82BAC  addi r29, r8, 0x2bac
	ctx.r[29].s64 = ctx.r[8].s64 + 11180;
	// 82C4E690: 3B81005C  addi r28, r1, 0x5c
	ctx.r[28].s64 = ctx.r[1].s64 + 92;
	// 82C4E694: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82C4E698: 4BFB7161  bl 0x82c057f8
	ctx.lr = 0x82C4E69C;
	sub_82C057F8(ctx, base);
	// 82C4E69C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C4E6A0: 4BFB7121  bl 0x82c057c0
	ctx.lr = 0x82C4E6A4;
	sub_82C057C0(ctx, base);
	// 82C4E6A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4E6A8: 4BFB7151  bl 0x82c057f8
	ctx.lr = 0x82C4E6AC;
	sub_82C057F8(ctx, base);
	// 82C4E6AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4E6B0: 4BFB7111  bl 0x82c057c0
	ctx.lr = 0x82C4E6B4;
	sub_82C057C0(ctx, base);
	// 82C4E6B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4E6B8: 4BFB7141  bl 0x82c057f8
	ctx.lr = 0x82C4E6BC;
	sub_82C057F8(ctx, base);
	// 82C4E6BC: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E6C0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82C4E6C4: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C4E6C8: 4B5C6711  bl 0x82214dd8
	ctx.lr = 0x82C4E6CC;
	sub_82214DD8(ctx, base);
	// 82C4E6CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E6D0: 4B5C6709  bl 0x82214dd8
	ctx.lr = 0x82C4E6D4;
	sub_82214DD8(ctx, base);
	// 82C4E6D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4E6D8: 4805AD7C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4E6DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E6E0: 4BFFF939  bl 0x82c4e018
	ctx.lr = 0x82C4E6E4;
	sub_82C4E018(ctx, base);
	// 82C4E6E4: 3880003E  li r4, 0x3e
	ctx.r[4].s64 = 62;
	// 82C4E6E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E6EC: 4BFFF5DD  bl 0x82c4dcc8
	ctx.lr = 0x82C4E6F0;
	sub_82C4DCC8(ctx, base);
	// 82C4E6F0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E6F8: 419A0018  beq cr6, 0x82c4e710
	if ctx.cr[6].eq {
	pc = 0x82C4E710; continue 'dispatch;
	}
	// 82C4E6FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E700: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E704: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E708: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4E70C: 4E800421  bctrl
	ctx.lr = 0x82C4E710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4E710: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82C4E714: 4B5C66C5  bl 0x82214dd8
	ctx.lr = 0x82C4E718;
	sub_82214DD8(ctx, base);
	// 82C4E718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E71C: 4B5C66BD  bl 0x82214dd8
	ctx.lr = 0x82C4E720;
	sub_82214DD8(ctx, base);
	// 82C4E720: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4E724: 4805AD30  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82C4E728: 4B5C66B1  bl 0x82214dd8
	ctx.lr = 0x82C4E72C;
	sub_82214DD8(ctx, base);
	// 82C4E72C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C4E730: 4B5C66A9  bl 0x82214dd8
	ctx.lr = 0x82C4E734;
	sub_82214DD8(ctx, base);
	// 82C4E734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E738: 4B5C66A1  bl 0x82214dd8
	ctx.lr = 0x82C4E73C;
	sub_82214DD8(ctx, base);
	// 82C4E73C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4E740: 4805AD14  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4E748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4E748 size=144
    let mut pc: u32 = 0x82C4E748;
    'dispatch: loop {
        match pc {
            0x82C4E748 => {
    //   block [0x82C4E748..0x82C4E7D8)
	// 82C4E748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4E74C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4E750: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4E754: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4E758: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4E75C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4E760: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C4E764: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82C4E768: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82C4E76C: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82C4E770: 388A0CA0  addi r4, r10, 0xca0
	ctx.r[4].s64 = ctx.r[10].s64 + 3232;
	// 82C4E774: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82C4E778: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82C4E77C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4E780: 4BFB7009  bl 0x82c05788
	ctx.lr = 0x82C4E784;
	sub_82C05788(ctx, base);
	// 82C4E784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E788: 4BFFF931  bl 0x82c4e0b8
	ctx.lr = 0x82C4E78C;
	sub_82C4E0B8(ctx, base);
	// 82C4E78C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4E790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E794: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4E798: 409A002C  bne cr6, 0x82c4e7c4
	if !ctx.cr[6].eq {
	pc = 0x82C4E7C4; continue 'dispatch;
	}
	// 82C4E79C: 4BFFF87D  bl 0x82c4e018
	ctx.lr = 0x82C4E7A0;
	sub_82C4E018(ctx, base);
	// 82C4E7A0: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 82C4E7A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E7A8: 4BFFF521  bl 0x82c4dcc8
	ctx.lr = 0x82C4E7AC;
	sub_82C4DCC8(ctx, base);
	// 82C4E7AC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E7B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E7B8: 419A000C  beq cr6, 0x82c4e7c4
	if ctx.cr[6].eq {
	pc = 0x82C4E7C4; continue 'dispatch;
	}
	// 82C4E7BC: 4BFFF9CD  bl 0x82c4e188
	ctx.lr = 0x82C4E7C0;
	sub_82C4E188(ctx, base);
	// 82C4E7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4E7C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4E7C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4E7CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4E7D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4E7D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4E7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4E7D8 size=268
    let mut pc: u32 = 0x82C4E7D8;
    'dispatch: loop {
        match pc {
            0x82C4E7D8 => {
    //   block [0x82C4E7D8..0x82C4E8E4)
	// 82C4E7D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4E7DC: 4805AC2D  bl 0x82ca9408
	ctx.lr = 0x82C4E7E0;
	sub_82CA93D0(ctx, base);
	// 82C4E7E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4E7E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C4E7E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4E7EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4E7F0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C4E7F4: 4BFB6F3D  bl 0x82c05730
	ctx.lr = 0x82C4E7F8;
	sub_82C05730(ctx, base);
	// 82C4E7F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4E7FC: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82C4E800: 4B5D9569  bl 0x82227d68
	ctx.lr = 0x82C4E804;
	sub_82227D68(ctx, base);
	// 82C4E804: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C4E808: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C4E80C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C4E810: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C4E814: 4BFFFF35  bl 0x82c4e748
	ctx.lr = 0x82C4E818;
	sub_82C4E748(ctx, base);
	// 82C4E818: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4E81C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4E820: 409A0018  bne cr6, 0x82c4e838
	if !ctx.cr[6].eq {
	pc = 0x82C4E838; continue 'dispatch;
	}
	// 82C4E824: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4E828: 4BFB6F49  bl 0x82c05770
	ctx.lr = 0x82C4E82C;
	sub_82C05770(ctx, base);
	// 82C4E82C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4E830: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C4E834: 4805AC24  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82C4E838: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C4E83C: 419A0094  beq cr6, 0x82c4e8d0
	if ctx.cr[6].eq {
	pc = 0x82C4E8D0; continue 'dispatch;
	}
	// 82C4E840: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4E844: 4BBFDA3D  bl 0x8284c280
	ctx.lr = 0x82C4E848;
	sub_8284C280(ctx, base);
	// 82C4E848: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C4E84C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E850: 4B5A19F1  bl 0x821f0240
	ctx.lr = 0x82C4E854;
	sub_821F0240(ctx, base);
	// 82C4E854: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C4E858: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E85C: 4B616945  bl 0x822651a0
	ctx.lr = 0x82C4E860;
	sub_822651A0(ctx, base);
	// 82C4E860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4E864: 4B5C6575  bl 0x82214dd8
	ctx.lr = 0x82C4E868;
	sub_82214DD8(ctx, base);
	// 82C4E868: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4E86C: 4B5D94FD  bl 0x82227d68
	ctx.lr = 0x82C4E870;
	sub_82227D68(ctx, base);
	// 82C4E870: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C4E874: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82C4E878: 7FC35850  subf r30, r3, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C4E87C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82C4E880: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4E884: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C4E888: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82C4E88C: 4B5D94DD  bl 0x82227d68
	ctx.lr = 0x82C4E890;
	sub_82227D68(ctx, base);
	// 82C4E890: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C4E894: 419A003C  beq cr6, 0x82c4e8d0
	if ctx.cr[6].eq {
	pc = 0x82C4E8D0; continue 'dispatch;
	}
	// 82C4E898: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4E89C: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 82C4E8A0: 409A0018  bne cr6, 0x82c4e8b8
	if !ctx.cr[6].eq {
	pc = 0x82C4E8B8; continue 'dispatch;
	}
	// 82C4E8A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4E8A8: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82C4E8AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E8B0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4E8B4: 48000010  b 0x82c4e8c4
	pc = 0x82C4E8C4; continue 'dispatch;
	// 82C4E8B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4E8BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E8C0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4E8C4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C4E8C8: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82C4E8CC: 4082FFCC  bne 0x82c4e898
	if !ctx.cr[0].eq {
	pc = 0x82C4E898; continue 'dispatch;
	}
	// 82C4E8D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4E8D4: 4BFB6E9D  bl 0x82c05770
	ctx.lr = 0x82C4E8D8;
	sub_82C05770(ctx, base);
	// 82C4E8D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4E8DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C4E8E0: 4805AB78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4E8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4E8E8 size=64
    let mut pc: u32 = 0x82C4E8E8;
    'dispatch: loop {
        match pc {
            0x82C4E8E8 => {
    //   block [0x82C4E8E8..0x82C4E928)
	// 82C4E8E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C4E8EC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C4E8F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4E8F4: 3909A94C  addi r8, r9, -0x56b4
	ctx.r[8].s64 = ctx.r[9].s64 + -22196;
	// 82C4E8F8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C4E8FC: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4E900: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C4E904: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C4E908: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C4E90C: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C4E910: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C4E914: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82C4E918: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82C4E91C: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82C4E920: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82C4E924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4E928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4E928 size=64
    let mut pc: u32 = 0x82C4E928;
    'dispatch: loop {
        match pc {
            0x82C4E928 => {
    //   block [0x82C4E928..0x82C4E968)
	// 82C4E928: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4E92C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4E930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4E934: 4099002C  ble cr6, 0x82c4e960
	if !ctx.cr[6].gt {
	pc = 0x82C4E960; continue 'dispatch;
	}
	// 82C4E938: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C4E93C: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4E940: 7D0B2214  add r8, r11, r4
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82C4E944: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4E948: 7CEA482E  lwzx r7, r10, r9
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82C4E94C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C4E950: 91070004  stw r8, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82C4E954: 80C30018  lwz r6, 0x18(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4E958: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C4E95C: 4198FFE0  blt cr6, 0x82c4e93c
	if ctx.cr[6].lt {
	pc = 0x82C4E93C; continue 'dispatch;
	}
	// 82C4E960: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4E964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4E968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4E968 size=436
    let mut pc: u32 = 0x82C4E968;
    'dispatch: loop {
        match pc {
            0x82C4E968 => {
    //   block [0x82C4E968..0x82C4EB1C)
	// 82C4E968: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82C4E96C: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82C4E970: C001001C  lfs f0, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4E974: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4E978: C1610018  lfs f11, 0x18(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4E97C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C4E980: 80C70020  lwz r6, 0x20(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4E984: 3946FFFF  addi r10, r6, -1
	ctx.r[10].s64 = ctx.r[6].s64 + -1;
	// 82C4E988: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 82C4E98C: 41980188  blt cr6, 0x82c4eb14
	if ctx.cr[6].lt {
	pc = 0x82C4EB14; continue 'dispatch;
	}
	// 82C4E990: 38A6FFFD  addi r5, r6, -3
	ctx.r[5].s64 = ctx.r[6].s64 + -3;
	// 82C4E994: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C4E998: 39670030  addi r11, r7, 0x30
	ctx.r[11].s64 = ctx.r[7].s64 + 48;
	// 82C4E99C: 2087FFE8  subfic r4, r7, -0x18
	ctx.xer.ca = ctx.r[7].u32 <= -24 as u32;
	ctx.r[4].s64 = (-24 as i64) - ctx.r[7].s64;
	// 82C4E9A0: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4E9A4: 7D483A14  add r10, r8, r7
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82C4E9A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4E9AC: 40980010  bge cr6, 0x82c4e9bc
	if !ctx.cr[6].lt {
	pc = 0x82C4E9BC; continue 'dispatch;
	}
	// 82C4E9B0: C18A0028  lfs f12, 0x28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4E9B4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4E9B8: 40980018  bge cr6, 0x82c4e9d0
	if !ctx.cr[6].lt {
	pc = 0x82C4E9D0; continue 'dispatch;
	}
	// 82C4E9BC: C18A0028  lfs f12, 0x28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4E9C0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4E9C4: 4098003C  bge cr6, 0x82c4ea00
	if !ctx.cr[6].lt {
	pc = 0x82C4EA00; continue 'dispatch;
	}
	// 82C4E9C8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4E9CC: 41980034  blt cr6, 0x82c4ea00
	if ctx.cr[6].lt {
	pc = 0x82C4EA00; continue 'dispatch;
	}
	// 82C4E9D0: ED406828  fsubs f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C4E9D4: C12BFFF4  lfs f9, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C4E9D8: ED0C6828  fsubs f8, f12, f13
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C4E9DC: C0EA0024  lfs f7, 0x24(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C4E9E0: ECC74828  fsubs f6, f7, f9
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C4E9E4: ECAA4024  fdivs f5, f10, f8
	ctx.f[5].f64 = ((ctx.f[10].f64 / ctx.f[8].f64) as f32) as f64;
	// 82C4E9E8: EC8549BA  fmadds f4, f5, f6, f9
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[6].f64 + ctx.f[9].f64) as f32) as f64);
	// 82C4E9EC: FF045800  fcmpu cr6, f4, f11
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[11].f64);
	// 82C4E9F0: 40980010  bge cr6, 0x82c4ea00
	if !ctx.cr[6].lt {
	pc = 0x82C4EA00; continue 'dispatch;
	}
	// 82C4E9F4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4E9F8: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82C4E9FC: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C4EA00: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4EA04: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EA08: 4098000C  bge cr6, 0x82c4ea14
	if !ctx.cr[6].lt {
	pc = 0x82C4EA14; continue 'dispatch;
	}
	// 82C4EA0C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EA10: 40980014  bge cr6, 0x82c4ea24
	if !ctx.cr[6].lt {
	pc = 0x82C4EA24; continue 'dispatch;
	}
	// 82C4EA14: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EA18: 4098003C  bge cr6, 0x82c4ea54
	if !ctx.cr[6].lt {
	pc = 0x82C4EA54; continue 'dispatch;
	}
	// 82C4EA1C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EA20: 41980034  blt cr6, 0x82c4ea54
	if ctx.cr[6].lt {
	pc = 0x82C4EA54; continue 'dispatch;
	}
	// 82C4EA24: ED406028  fsubs f10, f0, f12
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C4EA28: C12BFFFC  lfs f9, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C4EA2C: ED0D6028  fsubs f8, f13, f12
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C4EA30: C0EBFFF4  lfs f7, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C4EA34: ECC74828  fsubs f6, f7, f9
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C4EA38: ECAA4024  fdivs f5, f10, f8
	ctx.f[5].f64 = ((ctx.f[10].f64 / ctx.f[8].f64) as f32) as f64;
	// 82C4EA3C: EC8549BA  fmadds f4, f5, f6, f9
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[6].f64 + ctx.f[9].f64) as f32) as f64);
	// 82C4EA40: FF045800  fcmpu cr6, f4, f11
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[11].f64);
	// 82C4EA44: 40980010  bge cr6, 0x82c4ea54
	if !ctx.cr[6].lt {
	pc = 0x82C4EA54; continue 'dispatch;
	}
	// 82C4EA48: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4EA4C: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82C4EA50: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C4EA54: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4EA58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EA5C: 4098000C  bge cr6, 0x82c4ea68
	if !ctx.cr[6].lt {
	pc = 0x82C4EA68; continue 'dispatch;
	}
	// 82C4EA60: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EA64: 40980014  bge cr6, 0x82c4ea78
	if !ctx.cr[6].lt {
	pc = 0x82C4EA78; continue 'dispatch;
	}
	// 82C4EA68: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EA6C: 4098003C  bge cr6, 0x82c4eaa8
	if !ctx.cr[6].lt {
	pc = 0x82C4EAA8; continue 'dispatch;
	}
	// 82C4EA70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EA74: 41980034  blt cr6, 0x82c4eaa8
	if ctx.cr[6].lt {
	pc = 0x82C4EAA8; continue 'dispatch;
	}
	// 82C4EA78: ED406828  fsubs f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C4EA7C: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C4EA80: ED0C6828  fsubs f8, f12, f13
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C4EA84: C0EBFFFC  lfs f7, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C4EA88: ECC74828  fsubs f6, f7, f9
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C4EA8C: ECAA4024  fdivs f5, f10, f8
	ctx.f[5].f64 = ((ctx.f[10].f64 / ctx.f[8].f64) as f32) as f64;
	// 82C4EA90: EC8549BA  fmadds f4, f5, f6, f9
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[6].f64 + ctx.f[9].f64) as f32) as f64);
	// 82C4EA94: FF045800  fcmpu cr6, f4, f11
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[11].f64);
	// 82C4EA98: 40980010  bge cr6, 0x82c4eaa8
	if !ctx.cr[6].lt {
	pc = 0x82C4EAA8; continue 'dispatch;
	}
	// 82C4EA9C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4EAA0: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82C4EAA4: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C4EAA8: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4EAAC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EAB0: 4098000C  bge cr6, 0x82c4eabc
	if !ctx.cr[6].lt {
	pc = 0x82C4EABC; continue 'dispatch;
	}
	// 82C4EAB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EAB8: 40980014  bge cr6, 0x82c4eacc
	if !ctx.cr[6].lt {
	pc = 0x82C4EACC; continue 'dispatch;
	}
	// 82C4EABC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EAC0: 4098003C  bge cr6, 0x82c4eafc
	if !ctx.cr[6].lt {
	pc = 0x82C4EAFC; continue 'dispatch;
	}
	// 82C4EAC4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EAC8: 41980034  blt cr6, 0x82c4eafc
	if ctx.cr[6].lt {
	pc = 0x82C4EAFC; continue 'dispatch;
	}
	// 82C4EACC: ED406028  fsubs f10, f0, f12
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C4EAD0: C12B000C  lfs f9, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C4EAD4: ED0D6028  fsubs f8, f13, f12
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C4EAD8: C0EB0004  lfs f7, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C4EADC: ECC74828  fsubs f6, f7, f9
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C4EAE0: ECAA4024  fdivs f5, f10, f8
	ctx.f[5].f64 = ((ctx.f[10].f64 / ctx.f[8].f64) as f32) as f64;
	// 82C4EAE4: EC8549BA  fmadds f4, f5, f6, f9
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[6].f64 + ctx.f[9].f64) as f32) as f64);
	// 82C4EAE8: FF045800  fcmpu cr6, f4, f11
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[11].f64);
	// 82C4EAEC: 40980010  bge cr6, 0x82c4eafc
	if !ctx.cr[6].lt {
	pc = 0x82C4EAFC; continue 'dispatch;
	}
	// 82C4EAF0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4EAF4: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82C4EAF8: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C4EAFC: 39490003  addi r10, r9, 3
	ctx.r[10].s64 = ctx.r[9].s64 + 3;
	// 82C4EB00: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C4EB04: 7D045A14  add r8, r4, r11
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C4EB08: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82C4EB0C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C4EB10: 4198FE90  blt cr6, 0x82c4e9a0
	if ctx.cr[6].lt {
	pc = 0x82C4E9A0; continue 'dispatch;
	}
	// 82C4EB14: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C4EB18: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4EB1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4EB1C size=144
    let mut pc: u32 = 0x82C4EB1C;
    'dispatch: loop {
        match pc {
            0x82C4EB1C => {
    //   block [0x82C4EB1C..0x82C4EBAC)
	// 82C4EB1C: 39690005  addi r11, r9, 5
	ctx.r[11].s64 = ctx.r[9].s64 + 5;
	// 82C4EB20: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4EB24: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4EB28: 2107FFD8  subfic r8, r7, -0x28
	ctx.xer.ca = ctx.r[7].u32 <= -40 as u32;
	ctx.r[8].s64 = (-40 as i64) - ctx.r[7].s64;
	// 82C4EB2C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82C4EB30: 7D293050  subf r9, r9, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 82C4EB34: C18B0000  lfs f12, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4EB38: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82C4EB3C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EB40: 40980010  bge cr6, 0x82c4eb50
	if !ctx.cr[6].lt {
	pc = 0x82C4EB50; continue 'dispatch;
	}
	// 82C4EB44: C1AA0028  lfs f13, 0x28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4EB48: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EB4C: 40980018  bge cr6, 0x82c4eb64
	if !ctx.cr[6].lt {
	pc = 0x82C4EB64; continue 'dispatch;
	}
	// 82C4EB50: C1AA0028  lfs f13, 0x28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4EB54: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EB58: 40980040  bge cr6, 0x82c4eb98
	if !ctx.cr[6].lt {
	pc = 0x82C4EB98; continue 'dispatch;
	}
	// 82C4EB5C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EB60: 41980038  blt cr6, 0x82c4eb98
	if ctx.cr[6].lt {
	pc = 0x82C4EB98; continue 'dispatch;
	}
	// 82C4EB64: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4EB68: ED406028  fsubs f10, f0, f12
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C4EB6C: C12BFFFC  lfs f9, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C4EB70: ED0D6028  fsubs f8, f13, f12
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C4EB74: C0EA0024  lfs f7, 0x24(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C4EB78: ECC74828  fsubs f6, f7, f9
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C4EB7C: ECAA4024  fdivs f5, f10, f8
	ctx.f[5].f64 = ((ctx.f[10].f64 / ctx.f[8].f64) as f32) as f64;
	// 82C4EB80: EC8549BA  fmadds f4, f5, f6, f9
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[6].f64 + ctx.f[9].f64) as f32) as f64);
	// 82C4EB84: FF045800  fcmpu cr6, f4, f11
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[11].f64);
	// 82C4EB88: 40980010  bge cr6, 0x82c4eb98
	if !ctx.cr[6].lt {
	pc = 0x82C4EB98; continue 'dispatch;
	}
	// 82C4EB8C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4EB90: 7D460034  cntlzw r6, r10
	ctx.r[6].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82C4EB94: 54C3DFFE  rlwinm r3, r6, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 82C4EB98: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82C4EB9C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C4EBA0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82C4EBA4: 4082FF90  bne 0x82c4eb34
	if !ctx.cr[0].eq {
	pc = 0x82C4EB34; continue 'dispatch;
	}
	// 82C4EBA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4EBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4EBB0 size=100
    let mut pc: u32 = 0x82C4EBB0;
    'dispatch: loop {
        match pc {
            0x82C4EBB0 => {
    //   block [0x82C4EBB0..0x82C4EC14)
	// 82C4EBB0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EBB4: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82C4EBB8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4EBBC: 409A0058  bne cr6, 0x82c4ec14
	if !ctx.cr[6].eq {
		sub_82C4EC14(ctx, base);
		return;
	}
	// 82C4EBC0: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 82C4EBC4: C0010020  lfs f0, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4EBC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C4EBCC: C1810024  lfs f12, 0x24(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4EBD0: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82C4EBD4: C161FFF4  lfs f11, -0xc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4EBD8: C141FFF0  lfs f10, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C4EBDC: EDA05028  fsubs f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82C4EBE0: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4EBE4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82C4EBE8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EBEC: 41980028  blt cr6, 0x82c4ec14
	if ctx.cr[6].lt {
		sub_82C4EC14(ctx, base);
		return;
	}
	// 82C4EBF0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EBF4: 41980020  blt cr6, 0x82c4ec14
	if ctx.cr[6].lt {
		sub_82C4EC14(ctx, base);
		return;
	}
	// 82C4EBF8: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4EBFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C4EC00: 41990014  bgt cr6, 0x82c4ec14
	if ctx.cr[6].gt {
		sub_82C4EC14(ctx, base);
		return;
	}
	// 82C4EC04: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4EC08: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4EC0C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C4EC10: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4EC14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4EC14 size=8
    let mut pc: u32 = 0x82C4EC14;
    'dispatch: loop {
        match pc {
            0x82C4EC14 => {
    //   block [0x82C4EC14..0x82C4EC1C)
	// 82C4EC14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4EC18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4EC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4EC20 size=104
    let mut pc: u32 = 0x82C4EC20;
    'dispatch: loop {
        match pc {
            0x82C4EC20 => {
    //   block [0x82C4EC20..0x82C4EC88)
	// 82C4EC20: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82C4EC24: C0E1001C  lfs f7, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C4EC28: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82C4EC2C: C1410024  lfs f10, 0x24(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C4EC30: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82C4EC34: C0010028  lfs f0, 0x28(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4EC38: C1A1002C  lfs f13, 0x2c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4EC3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4EC40: C1610020  lfs f11, 0x20(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4EC44: C1810018  lfs f12, 0x18(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4EC48: ED0C5828  fsubs f8, f12, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82C4EC4C: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82C4EC50: C12B0C18  lfs f9, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C4EC54: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82C4EC58: ECC75028  fsubs f6, f7, f10
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[10].f64) as f32) as f64);
	// 82C4EC5C: ECA00032  fmuls f5, f0, f0
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C4EC60: EC880032  fmuls f4, f8, f0
	ctx.f[4].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C4EC64: EC6D2B7A  fmadds f3, f13, f13, f5
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 82C4EC68: EC46237A  fmadds f2, f6, f13, f4
	ctx.f[2].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[4].f64) as f32) as f64);
	// 82C4EC6C: EC20182C  fsqrts f1, f3
	ctx.f[1].f64 = ((ctx.f[3].f64).sqrt() as f32) as f64;
	// 82C4EC70: ED810072  fmuls f12, f1, f1
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82C4EC74: ED826024  fdivs f12, f2, f12
	ctx.f[12].f64 = ((ctx.f[2].f64 / ctx.f[12].f64) as f32) as f64;
	// 82C4EC78: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 82C4EC7C: 4098000C  bge cr6, 0x82c4ec88
	if !ctx.cr[6].lt {
		sub_82C4EC88(ctx, base);
		return;
	}
	// 82C4EC80: F8A30000  std r5, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82C4EC84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4EC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4EC88 size=24
    let mut pc: u32 = 0x82C4EC88;
    'dispatch: loop {
        match pc {
            0x82C4EC88 => {
    //   block [0x82C4EC88..0x82C4ECA0)
	// 82C4EC88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4EC8C: C12B0C14  lfs f9, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C4EC90: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 82C4EC94: 4099000C  ble cr6, 0x82c4eca0
	if !ctx.cr[6].gt {
		sub_82C4ECA0(ctx, base);
		return;
	}
	// 82C4EC98: F8C30000  std r6, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82C4EC9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4ECA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4ECA0 size=36
    let mut pc: u32 = 0x82C4ECA0;
    'dispatch: loop {
        match pc {
            0x82C4ECA0 => {
    //   block [0x82C4ECA0..0x82C4ECC4)
	// 82C4ECA0: EC000332  fmuls f0, f0, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C4ECA4: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C4ECA8: ED80582A  fadds f12, f0, f11
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82C4ECAC: D181FFF0  stfs f12, -0x10(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82C4ECB0: ED6D502A  fadds f11, f13, f10
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82C4ECB4: D161FFF4  stfs f11, -0xc(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82C4ECB8: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4ECBC: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C4ECC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4ECC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4ECC8 size=104
    let mut pc: u32 = 0x82C4ECC8;
    'dispatch: loop {
        match pc {
            0x82C4ECC8 => {
    //   block [0x82C4ECC8..0x82C4ED30)
	// 82C4ECC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4ECCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4ECD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4ECD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4ECD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4ECDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4ECE0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4ECE4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C4ECE8: 392BA94C  addi r9, r11, -0x56b4
	ctx.r[9].s64 = ctx.r[11].s64 + -22196;
	// 82C4ECEC: 895F0024  lbz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C4ECF0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4ECF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4ECF8: 419A0018  beq cr6, 0x82c4ed10
	if ctx.cr[6].eq {
	pc = 0x82C4ED10; continue 'dispatch;
	}
	// 82C4ECFC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4ED00: 4BBF6AB1  bl 0x828457b0
	ctx.lr = 0x82C4ED04;
	sub_828457B0(ctx, base);
	// 82C4ED04: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4ED08: 4BBF6AA9  bl 0x828457b0
	ctx.lr = 0x82C4ED0C;
	sub_828457B0(ctx, base);
	// 82C4ED0C: 9BDF0024  stb r30, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 82C4ED10: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82C4ED14: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82C4ED18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4ED1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4ED20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4ED24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4ED28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4ED2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4ED30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4ED30 size=748
    let mut pc: u32 = 0x82C4ED30;
    'dispatch: loop {
        match pc {
            0x82C4ED30 => {
    //   block [0x82C4ED30..0x82C4F01C)
	// 82C4ED30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4ED34: 4805A6D5  bl 0x82ca9408
	ctx.lr = 0x82C4ED38;
	sub_82CA93D0(ctx, base);
	// 82C4ED38: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4ED3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4ED40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4ED44: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C4ED48: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C4ED4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4ED50: 419A0018  beq cr6, 0x82c4ed68
	if ctx.cr[6].eq {
	pc = 0x82C4ED68; continue 'dispatch;
	}
	// 82C4ED54: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4ED58: 4BBF6A59  bl 0x828457b0
	ctx.lr = 0x82C4ED5C;
	sub_828457B0(ctx, base);
	// 82C4ED5C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4ED60: 4BBF6A51  bl 0x828457b0
	ctx.lr = 0x82C4ED64;
	sub_828457B0(ctx, base);
	// 82C4ED64: 9BBF0024  stb r29, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 82C4ED68: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82C4ED6C: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82C4ED70: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82C4ED74: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4ED78: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4ED7C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C4ED80: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82C4ED84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4ED88: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82C4ED8C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82C4ED90: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4ED94: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4ED98: 4E800421  bctrl
	ctx.lr = 0x82C4ED9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4ED9C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EDA0: 41980270  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EDA4: 3D604144  lis r11, 0x4144
	ctx.r[11].s64 = 1094975488;
	// 82C4EDA8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4EDAC: 61694D50  ori r9, r11, 0x4d50
	ctx.r[9].u64 = ctx.r[11].u64 | 19792;
	// 82C4EDB0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4EDB4: 409A025C  bne cr6, 0x82c4f010
	if !ctx.cr[6].eq {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EDB8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EDBC: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82C4EDC0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82C4EDC4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4EDC8: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82C4EDCC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82C4EDD0: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82C4EDD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4EDD8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EDDC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4EDE0: 4E800421  bctrl
	ctx.lr = 0x82C4EDE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4EDE4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EDE8: 41980228  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EDEC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C4EDF0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82C4EDF4: 409A021C  bne cr6, 0x82c4f010
	if !ctx.cr[6].eq {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EDF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EDFC: 3941005C  addi r10, r1, 0x5c
	ctx.r[10].s64 = ctx.r[1].s64 + 92;
	// 82C4EE00: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82C4EE04: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4EE08: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82C4EE0C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C4EE10: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82C4EE14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4EE18: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EE1C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4EE20: 4E800421  bctrl
	ctx.lr = 0x82C4EE24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4EE24: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EE28: 419801E8  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EE2C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EE30: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82C4EE34: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4EE38: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 82C4EE3C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82C4EE40: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82C4EE44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4EE48: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EE4C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4EE50: 4E800421  bctrl
	ctx.lr = 0x82C4EE54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4EE54: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EE58: 419801B8  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EE5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EE60: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	// 82C4EE64: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4EE68: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82C4EE6C: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82C4EE70: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C4EE74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4EE78: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EE7C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4EE80: 4E800421  bctrl
	ctx.lr = 0x82C4EE84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4EE84: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EE88: 41980188  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EE8C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EE90: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82C4EE94: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82C4EE98: 93A1008C  stw r29, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 82C4EE9C: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82C4EEA0: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82C4EEA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4EEA8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EEAC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4EEB0: 4E800421  bctrl
	ctx.lr = 0x82C4EEB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4EEB4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EEB8: 41980158  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EEBC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EEC0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82C4EEC4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4EEC8: 93A10094  stw r29, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 82C4EECC: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82C4EED0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82C4EED4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4EED8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EEDC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4EEE0: 4E800421  bctrl
	ctx.lr = 0x82C4EEE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4EEE4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EEE8: 41980128  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EEEC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EEF0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C4EEF4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82C4EEF8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4EEFC: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82C4EF00: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82C4EF04: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 82C4EF08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4EF0C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EF10: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4EF14: 4E800421  bctrl
	ctx.lr = 0x82C4EF18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4EF18: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EF1C: 419800F4  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EF20: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4EF24: 4B5D0335  bl 0x8221f258
	ctx.lr = 0x82C4EF28;
	sub_8221F258(ctx, base);
	// 82C4EF28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4EF2C: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82C4EF30: 3B9F0018  addi r28, r31, 0x18
	ctx.r[28].s64 = ctx.r[31].s64 + 24;
	// 82C4EF34: 93A100A4  stw r29, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[29].u32 ) };
	// 82C4EF38: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82C4EF3C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82C4EF40: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EF44: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82C4EF48: 938100A0  stw r28, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[28].u32 ) };
	// 82C4EF4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4EF50: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EF54: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4EF58: 4E800421  bctrl
	ctx.lr = 0x82C4EF5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4EF5C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EF60: 419800B0  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EF64: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82C4EF68: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EF6C: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 82C4EF70: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C4EF74: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4EF78: 40990008  ble cr6, 0x82c4ef80
	if !ctx.cr[6].gt {
	pc = 0x82C4EF80; continue 'dispatch;
	}
	// 82C4EF7C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82C4EF80: 4B5D02D9  bl 0x8221f258
	ctx.lr = 0x82C4EF84;
	sub_8221F258(ctx, base);
	// 82C4EF84: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82C4EF88: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4EF8C: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 82C4EF90: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4EF94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4EF98: 93A100AC  stw r29, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[29].u32 ) };
	// 82C4EF9C: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82C4EFA0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EFA4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4EFA8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4EFAC: 4E800421  bctrl
	ctx.lr = 0x82C4EFB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4EFB0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4EFB4: 4198005C  blt cr6, 0x82c4f010
	if ctx.cr[6].lt {
	pc = 0x82C4F010; continue 'dispatch;
	}
	// 82C4EFB8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EFBC: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82C4EFC0: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4EFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4EFC8: 4099003C  ble cr6, 0x82c4f004
	if !ctx.cr[6].gt {
	pc = 0x82C4F004; continue 'dispatch;
	}
	// 82C4EFCC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4EFD0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82C4EFD4: 7D0B512E  stwx r8, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 82C4EFD8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82C4EFDC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4EFE0: 80FC0000  lwz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4EFE4: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C4EFE8: 7CCB502E  lwzx r6, r11, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82C4EFEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C4EFF0: 80A60020  lwz r5, 0x20(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4EFF4: 54A71838  slwi r7, r5, 3
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C4EFF8: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82C4EFFC: 39080024  addi r8, r8, 0x24
	ctx.r[8].s64 = ctx.r[8].s64 + 36;
	// 82C4F000: 4198FFD4  blt cr6, 0x82c4efd4
	if ctx.cr[6].lt {
	pc = 0x82C4EFD4; continue 'dispatch;
	}
	// 82C4F004: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4F008: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C4F00C: 4805A44C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82C4F010: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4F014: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C4F018: 4805A440  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C4F020 size=204
    let mut pc: u32 = 0x82C4F020;
    'dispatch: loop {
        match pc {
            0x82C4F020 => {
    //   block [0x82C4F020..0x82C4F0EC)
	// 82C4F020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F024: 4805A3E5  bl 0x82ca9408
	ctx.lr = 0x82C4F028;
	sub_82CA93D0(ctx, base);
	// 82C4F028: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 82C4F02C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82C4F030: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82C4F034: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F038: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82C4F03C: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4F040: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4F044: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82C4F048: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C4F04C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C4F050: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C4F054: 81070020  lwz r8, 0x20(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4F058: C3EB0BEC  lfs f31, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C4F05C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C4F060: 419A006C  beq cr6, 0x82c4f0cc
	if ctx.cr[6].eq {
	pc = 0x82C4F0CC; continue 'dispatch;
	}
	// 82C4F064: C3C100BC  lfs f30, 0xbc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C4F068: 3BE8FFFF  addi r31, r8, -1
	ctx.r[31].s64 = ctx.r[8].s64 + -1;
	// 82C4F06C: C3A100B8  lfs f29, 0xb8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82C4F070: 3947002C  addi r10, r7, 0x2c
	ctx.r[10].s64 = ctx.r[7].s64 + 44;
	// 82C4F074: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C4F078: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C4F07C: 41980008  blt cr6, 0x82c4f084
	if ctx.cr[6].lt {
	pc = 0x82C4F084; continue 'dispatch;
	}
	// 82C4F080: 39670024  addi r11, r7, 0x24
	ctx.r[11].s64 = ctx.r[7].s64 + 36;
	// 82C4F084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4F088: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82C4F08C: E8AAFFF8  ld r5, -8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	// 82C4F090: 4BFFFB91  bl 0x82c4ec20
	ctx.lr = 0x82C4F094;
	sub_82C4EC20(ctx, base);
	// 82C4F094: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4F098: EDA0F028  fsubs f13, f0, f30
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82C4F09C: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4F0A0: ED6CE828  fsubs f11, f12, f29
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[29].f64) as f32) as f64);
	// 82C4F0A4: ED4D0372  fmuls f10, f13, f13
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C4F0A8: EC0B52FA  fmadds f0, f11, f11, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 82C4F0AC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82C4F0B0: 4098000C  bge cr6, 0x82c4f0bc
	if !ctx.cr[6].lt {
	pc = 0x82C4F0BC; continue 'dispatch;
	}
	// 82C4F0B4: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4F0B8: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82C4F0BC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82C4F0C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82C4F0C4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C4F0C8: 4198FFAC  blt cr6, 0x82c4f074
	if ctx.cr[6].lt {
	pc = 0x82C4F074; continue 'dispatch;
	}
	// 82C4F0CC: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 82C4F0D0: EC00F82C  fsqrts f0, f31
	ctx.f[0].f64 = ((ctx.f[31].f64).sqrt() as f32) as f64;
	// 82C4F0D4: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C4F0D8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C4F0DC: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82C4F0E0: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82C4F0E4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82C4F0E8: 4805A370  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C4F0F0 size=252
    let mut pc: u32 = 0x82C4F0F0;
    'dispatch: loop {
        match pc {
            0x82C4F0F0 => {
    //   block [0x82C4F0F0..0x82C4F1EC)
	// 82C4F0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F0F4: 4805A30D  bl 0x82ca9400
	ctx.lr = 0x82C4F0F8;
	sub_82CA93D0(ctx, base);
	// 82C4F0F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F0FC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4F100: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82C4F104: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82C4F108: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4F10C: 409A00A8  bne cr6, 0x82c4f1b4
	if !ctx.cr[6].eq {
	pc = 0x82C4F1B4; continue 'dispatch;
	}
	// 82C4F110: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 82C4F114: C00100B0  lfs f0, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4F118: 83830018  lwz r28, 0x18(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4F11C: C1A100B4  lfs f13, 0xb4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4F120: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C4F124: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C4F128: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C4F12C: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4F130: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4F134: EC606028  fsubs f3, f0, f12
	ctx.f[3].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C4F138: EC4D5828  fsubs f2, f13, f11
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82C4F13C: D0610050  stfs f3, 0x50(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C4F140: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C4F144: 419A0070  beq cr6, 0x82c4f1b4
	if ctx.cr[6].eq {
	pc = 0x82C4F1B4; continue 'dispatch;
	}
	// 82C4F148: 83C3001C  lwz r30, 0x1c(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4F14C: EB610050  ld r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4F150: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F154: E97F0014  ld r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	// 82C4F158: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4F15C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C4F160: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4F164: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4F168: ED6C1828  fsubs f11, f12, f3
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[3].f64) as f32) as f64);
	// 82C4F16C: ED4D1028  fsubs f10, f13, f2
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 82C4F170: ED2B02F2  fmuls f9, f11, f11
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82C4F174: ED0A4ABA  fmadds f8, f10, f10, f9
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[9].f64) as f32) as f64);
	// 82C4F178: ECE0402C  fsqrts f7, f8
	ctx.f[7].f64 = ((ctx.f[8].f64).sqrt() as f32) as f64;
	// 82C4F17C: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 82C4F180: 4099000C  ble cr6, 0x82c4f18c
	if !ctx.cr[6].gt {
	pc = 0x82C4F18C; continue 'dispatch;
	}
	// 82C4F184: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4F188: 48000010  b 0x82c4f198
	pc = 0x82C4F198; continue 'dispatch;
	// 82C4F18C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C4F190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4F194: 4BFFF7D5  bl 0x82c4e968
	ctx.lr = 0x82C4F198;
	sub_82C4E968(ctx, base);
	// 82C4F198: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4F19C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F1A0: 409A0020  bne cr6, 0x82c4f1c0
	if !ctx.cr[6].eq {
	pc = 0x82C4F1C0; continue 'dispatch;
	}
	// 82C4F1A4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C4F1A8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C4F1AC: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C4F1B0: 4198FFA0  blt cr6, 0x82c4f150
	if ctx.cr[6].lt {
	pc = 0x82C4F150; continue 'dispatch;
	}
	// 82C4F1B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4F1B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4F1BC: 4805A294  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 82C4F1C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F1C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4F1C8: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4F1CC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F1D0: 915A0004  stw r10, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4F1D4: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4F1D8: D01A0008  stfs f0, 8(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C4F1DC: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4F1E0: D1BA000C  stfs f13, 0xc(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C4F1E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4F1E8: 4805A268  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F1F0 size=160
    let mut pc: u32 = 0x82C4F1F0;
    'dispatch: loop {
        match pc {
            0x82C4F1F0 => {
    //   block [0x82C4F1F0..0x82C4F290)
	// 82C4F1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4F1F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4F1FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4F200: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4F208: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 82C4F20C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4F210: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 82C4F214: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4F218: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C4F21C: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C4F220: 4098004C  bge cr6, 0x82c4f26c
	if !ctx.cr[6].lt {
	pc = 0x82C4F26C; continue 'dispatch;
	}
	// 82C4F224: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C4F228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4F22C: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82C4F230: 4B6A2D11  bl 0x822f1f40
	ctx.lr = 0x82C4F234;
	sub_822F1F40(ctx, base);
	// 82C4F234: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C4F238: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C4F23C: 4B6A2B35  bl 0x822f1d70
	ctx.lr = 0x82C4F240;
	sub_822F1D70(ctx, base);
	// 82C4F240: 4B6A2BE1  bl 0x822f1e20
	ctx.lr = 0x82C4F244;
	sub_822F1E20(ctx, base);
	// 82C4F244: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C4F248: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C4F24C: 392A1720  addi r9, r10, 0x1720
	ctx.r[9].s64 = ctx.r[10].s64 + 5920;
	// 82C4F250: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82C4F254: 4BA2C58D  bl 0x8267b7e0
	ctx.lr = 0x82C4F258;
	sub_8267B7E0(ctx, base);
	// 82C4F258: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C4F25C: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82C4F260: 4198000C  blt cr6, 0x82c4f26c
	if ctx.cr[6].lt {
	pc = 0x82C4F26C; continue 'dispatch;
	}
	// 82C4F264: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4F268: 4BBF6549  bl 0x828457b0
	ctx.lr = 0x82C4F26C;
	sub_828457B0(ctx, base);
	// 82C4F26C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4F270: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C4F274: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4F278: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C4F27C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F280: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F284: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4F288: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4F28C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F290 size=144
    let mut pc: u32 = 0x82C4F290;
    'dispatch: loop {
        match pc {
            0x82C4F290 => {
    //   block [0x82C4F290..0x82C4F320)
	// 82C4F290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F294: 4805A16D  bl 0x82ca9400
	ctx.lr = 0x82C4F298;
	sub_82CA93D0(ctx, base);
	// 82C4F298: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F29C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82C4F2A0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82C4F2A4: 836100AC  lwz r27, 0xac(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82C4F2A8: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82C4F2AC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C4F2B0: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F2B4: 4B5CFFA5  bl 0x8221f258
	ctx.lr = 0x82C4F2B8;
	sub_8221F258(ctx, base);
	// 82C4F2B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4F2BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C4F2C0: 419A0008  beq cr6, 0x82c4f2c8
	if ctx.cr[6].eq {
	pc = 0x82C4F2C8; continue 'dispatch;
	}
	// 82C4F2C4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82C4F2C8: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 82C4F2CC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C4F2D0: 419A0008  beq cr6, 0x82c4f2d8
	if ctx.cr[6].eq {
	pc = 0x82C4F2D8; continue 'dispatch;
	}
	// 82C4F2D4: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C4F2D8: 355F0008  addic. r10, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C4F2DC: 41820024  beq 0x82c4f300
	if ctx.cr[0].eq {
	pc = 0x82C4F300; continue 'dispatch;
	}
	// 82C4F2E0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82C4F2E4: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82C4F2E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4F2EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F2F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C4F2F4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4F2F8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C4F2FC: 4200FFF0  bdnz 0x82c4f2ec
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82C4F2EC; continue 'dispatch;
	}
	// 82C4F300: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C4F304: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C4F308: 4BFFFEE9  bl 0x82c4f1f0
	ctx.lr = 0x82C4F30C;
	sub_82C4F1F0(ctx, base);
	// 82C4F30C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C4F310: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F314: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C4F318: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4F31C: 4805A134  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C4F320 size=540
    let mut pc: u32 = 0x82C4F320;
    'dispatch: loop {
        match pc {
            0x82C4F320 => {
    //   block [0x82C4F320..0x82C4F53C)
	// 82C4F320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F324: 4805A0C5  bl 0x82ca93e8
	ctx.lr = 0x82C4F328;
	sub_82CA93D0(ctx, base);
	// 82C4F328: DBA1FF80  stfd f29, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[29].u64 ) };
	// 82C4F32C: DBC1FF88  stfd f30, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 82C4F330: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82C4F334: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F338: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4F33C: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82C4F340: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82C4F344: FAC10120  std r22, 0x120(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[22].u64 ) };
	// 82C4F348: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4F34C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4F350: 409A01D8  bne cr6, 0x82c4f528
	if !ctx.cr[6].eq {
	pc = 0x82C4F528; continue 'dispatch;
	}
	// 82C4F354: E97C0010  ld r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	// 82C4F358: C0010120  lfs f0, 0x120(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4F35C: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4F360: C1A10124  lfs f13, 0x124(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4F364: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 82C4F368: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 82C4F36C: 7E97A378  mr r23, r20
	ctx.r[23].u64 = ctx.r[20].u64;
	// 82C4F370: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C4F374: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4F378: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4F37C: EFC06028  fsubs f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C4F380: EFAD5828  fsubs f29, f13, f11
	ctx.f[29].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82C4F384: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C4F388: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C4F38C: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 82C4F390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4F394: 40990194  ble cr6, 0x82c4f528
	if !ctx.cr[6].gt {
	pc = 0x82C4F528; continue 'dispatch;
	}
	// 82C4F398: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C4F39C: EB210050  ld r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4F3A0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82C4F3A4: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82C4F3A8: 9281007C  stw r20, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[20].u32 ) };
	// 82C4F3AC: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	// 82C4F3B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82C4F3B4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82C4F3B8: C3EA0C18  lfs f31, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C4F3BC: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82C4F3C0: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82C4F3C4: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82C4F3C8: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82C4F3CC: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82C4F3D0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F3D4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C4F3D8: 815C001C  lwz r10, 0x1c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4F3DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C4F3E0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C4F3E4: 7FBA502E  lwzx r29, r26, r10
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82C4F3E8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C4F3EC: 4BFFFEA5  bl 0x82c4f290
	ctx.lr = 0x82C4F3F0;
	sub_82C4F290(ctx, base);
	// 82C4F3F0: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F3F4: 552A003E  slwi r10, r9, 0
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4F3F8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F3FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4F400: 409A000C  bne cr6, 0x82c4f40c
	if !ctx.cr[6].eq {
	pc = 0x82C4F40C; continue 'dispatch;
	}
	// 82C4F404: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4F408: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4F40C: E95D0014  ld r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	// 82C4F410: C01D001C  lfs f0, 0x1c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4F414: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82C4F418: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82C4F41C: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4F420: ED8DF028  fsubs f12, f13, f30
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 82C4F424: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4F428: ED4C0332  fmuls f10, f12, f12
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C4F42C: ED2BE828  fsubs f9, f11, f29
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[29].f64) as f32) as f64);
	// 82C4F430: ED09527A  fmadds f8, f9, f9, f10
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64);
	// 82C4F434: ECE0402C  fsqrts f7, f8
	ctx.f[7].f64 = ((ctx.f[8].f64).sqrt() as f32) as f64;
	// 82C4F438: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 82C4F43C: 4099000C  ble cr6, 0x82c4f448
	if !ctx.cr[6].gt {
	pc = 0x82C4F448; continue 'dispatch;
	}
	// 82C4F440: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82C4F444: 48000010  b 0x82c4f454
	pc = 0x82C4F454; continue 'dispatch;
	// 82C4F448: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82C4F44C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4F450: 4BFFF519  bl 0x82c4e968
	ctx.lr = 0x82C4F454;
	sub_82C4E968(ctx, base);
	// 82C4F454: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4F458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F45C: 419A0010  beq cr6, 0x82c4f46c
	if ctx.cr[6].eq {
	pc = 0x82C4F46C; continue 'dispatch;
	}
	// 82C4F460: 92BF001C  stw r21, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[21].u32 ) };
	// 82C4F464: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 82C4F468: 48000008  b 0x82c4f470
	pc = 0x82C4F470; continue 'dispatch;
	// 82C4F46C: 929F001C  stw r20, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[20].u32 ) };
	// 82C4F470: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4F474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F478: 409A0044  bne cr6, 0x82c4f4bc
	if !ctx.cr[6].eq {
	pc = 0x82C4F4BC; continue 'dispatch;
	}
	// 82C4F47C: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 82C4F480: 38DF0018  addi r6, r31, 0x18
	ctx.r[6].s64 = ctx.r[31].s64 + 24;
	// 82C4F484: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82C4F488: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4F48C: 4BFFFB95  bl 0x82c4f020
	ctx.lr = 0x82C4F490;
	sub_82C4F020(ctx, base);
	// 82C4F490: E97C0010  ld r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	// 82C4F494: C01F0010  lfs f0, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4F498: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4F49C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C4F4A0: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4F4A4: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4F4A8: ED20602A  fadds f9, f0, f12
	ctx.f[9].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82C4F4AC: ED4B682A  fadds f10, f11, f13
	ctx.f[10].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C4F4B0: D13F0010  stfs f9, 0x10(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C4F4B4: D15F0014  stfs f10, 0x14(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C4F4B8: 4800002C  b 0x82c4f4e4
	pc = 0x82C4F4E4; continue 'dispatch;
	// 82C4F4BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C4F4C0: 409A000C  bne cr6, 0x82c4f4cc
	if !ctx.cr[6].eq {
	pc = 0x82C4F4CC; continue 'dispatch;
	}
	// 82C4F4C4: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C4F4C8: 48000018  b 0x82c4f4e0
	pc = 0x82C4F4E0; continue 'dispatch;
	// 82C4F4CC: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 82C4F4D0: 38DF0018  addi r6, r31, 0x18
	ctx.r[6].s64 = ctx.r[31].s64 + 24;
	// 82C4F4D4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82C4F4D8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C4F4DC: 4BFFFB45  bl 0x82c4f020
	ctx.lr = 0x82C4F4E0;
	sub_82C4F020(ctx, base);
	// 82C4F4E0: FADF0010  std r22, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[22].u64 ) };
	// 82C4F4E4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4F4E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F4EC: 40990008  ble cr6, 0x82c4f4f4
	if !ctx.cr[6].gt {
	pc = 0x82C4F4F4; continue 'dispatch;
	}
	// 82C4F4F0: 7FB7EB78  mr r23, r29
	ctx.r[23].u64 = ctx.r[29].u64;
	// 82C4F4F4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F4F8: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82C4F4FC: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82C4F500: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4F504: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F508: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C4F50C: C01D0008  lfs f0, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4F510: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C4F514: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4F518: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C4F51C: 813C0018  lwz r9, 0x18(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4F520: 7F184840  cmplw cr6, r24, r9
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4F524: 4198FEAC  blt cr6, 0x82c4f3d0
	if ctx.cr[6].lt {
	pc = 0x82C4F3D0; continue 'dispatch;
	}
	// 82C4F528: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82C4F52C: CBA1FF80  lfd f29, -0x80(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82C4F530: CBC1FF88  lfd f30, -0x78(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82C4F534: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82C4F538: 48059F00  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F540 size=100
    let mut pc: u32 = 0x82C4F540;
    'dispatch: loop {
        match pc {
            0x82C4F540 => {
    //   block [0x82C4F540..0x82C4F5A4)
	// 82C4F540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4F548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4F54C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4F554: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C4F558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F55C: 419A001C  beq cr6, 0x82c4f578
	if ctx.cr[6].eq {
	pc = 0x82C4F578; continue 'dispatch;
	}
	// 82C4F560: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4F564: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4F568: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F56C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F570: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4F574: 4E800020  blr
	return;
	// 82C4F578: 909F0064  stw r4, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 82C4F57C: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82C4F580: 4BFBF001  bl 0x82c0e580
	ctx.lr = 0x82C4F584;
	sub_82C0E580(ctx, base);
	// 82C4F584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4F588: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4F58C: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82C4F590: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4F594: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F598: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F59C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4F5A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F5A8 size=164
    let mut pc: u32 = 0x82C4F5A8;
    'dispatch: loop {
        match pc {
            0x82C4F5A8 => {
    //   block [0x82C4F5A8..0x82C4F64C)
	// 82C4F5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F5AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4F5B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4F5B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F5B8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4F5BC: 3BEB5010  addi r31, r11, 0x5010
	ctx.r[31].s64 = ctx.r[11].s64 + 20496;
	// 82C4F5C0: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C4F5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F5C8: 419A000C  beq cr6, 0x82c4f5d4
	if ctx.cr[6].eq {
	pc = 0x82C4F5D4; continue 'dispatch;
	}
	// 82C4F5CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C4F5D0: 48000024  b 0x82c4f5f4
	pc = 0x82C4F5F4; continue 'dispatch;
	// 82C4F5D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4F5D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C4F5DC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82C4F5E0: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82C4F5E4: 4BFBEF9D  bl 0x82c0e580
	ctx.lr = 0x82C4F5E8;
	sub_82C0E580(ctx, base);
	// 82C4F5E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4F5EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C4F5F0: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82C4F5F4: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82C4F5F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F5FC: 409A001C  bne cr6, 0x82c4f618
	if !ctx.cr[6].eq {
	pc = 0x82C4F618; continue 'dispatch;
	}
	// 82C4F600: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4F604: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4F608: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F60C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F610: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4F614: 4E800020  blr
	return;
	// 82C4F618: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4F61C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82C4F620: 386B5088  addi r3, r11, 0x5088
	ctx.r[3].s64 = ctx.r[11].s64 + 20616;
	// 82C4F624: 4BFFFF1D  bl 0x82c4f540
	ctx.lr = 0x82C4F628;
	sub_82C4F540(ctx, base);
	// 82C4F628: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4F62C: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82C4F630: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82C4F634: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 82C4F638: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4F63C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4F648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F650 size=300
    let mut pc: u32 = 0x82C4F650;
    'dispatch: loop {
        match pc {
            0x82C4F650 => {
    //   block [0x82C4F650..0x82C4F77C)
	// 82C4F650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4F658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4F65C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4F660: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F664: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4F668: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C4F66C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82C4F670: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82C4F674: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4F67C: 409A0034  bne cr6, 0x82c4f6b0
	if !ctx.cr[6].eq {
	pc = 0x82C4F6B0; continue 'dispatch;
	}
	// 82C4F680: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4F684: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C4F688: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4F68C: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4F690: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C4F694: 4B66AF45  bl 0x822ba5d8
	ctx.lr = 0x82C4F698;
	sub_822BA5D8(ctx, base);
	// 82C4F698: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4F69C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4F6A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4F6A4: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82C4F6A8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C4F6AC: 480000B4  b 0x82c4f760
	pc = 0x82C4F760; continue 'dispatch;
	// 82C4F6B0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F6B4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82C4F6B8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4F6BC: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82C4F6C0: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4F6C4: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4F6C8: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C4F6CC: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4F6D0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F6D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C4F6D8: 4E800421  bctrl
	ctx.lr = 0x82C4F6DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4F6DC: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4F6E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4F6E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4F6E8: 419A0034  beq cr6, 0x82c4f71c
	if ctx.cr[6].eq {
	pc = 0x82C4F71C; continue 'dispatch;
	}
	// 82C4F6EC: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4F6F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4F6F4: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4F6F8: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82C4F6FC: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4F700: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4F704: 7CC85A14  add r6, r8, r11
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82C4F708: 90FF0018  stw r7, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 82C4F70C: 7CAA4A14  add r5, r10, r9
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82C4F710: 90DF001C  stw r6, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[6].u32 ) };
	// 82C4F714: 90BF0020  stw r5, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[5].u32 ) };
	// 82C4F718: 4800004C  b 0x82c4f764
	pc = 0x82C4F764; continue 'dispatch;
	// 82C4F71C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4F720: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4F724: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4F728: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4F72C: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82C4F730: 80FF0018  lwz r7, 0x18(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4F734: 7CC85A14  add r6, r8, r11
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82C4F738: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4F73C: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82C4F740: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4F744: 7C8B3850  subf r4, r11, r7
	ctx.r[4].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82C4F748: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82C4F74C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82C4F750: 90BF000C  stw r5, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82C4F754: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82C4F758: 909F0018  stw r4, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 82C4F75C: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82C4F760: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82C4F764: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4F768: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F76C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F770: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4F774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4F778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F780 size=112
    let mut pc: u32 = 0x82C4F780;
    'dispatch: loop {
        match pc {
            0x82C4F780 => {
    //   block [0x82C4F780..0x82C4F7F0)
	// 82C4F780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4F788: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F78C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F794: 419A0048  beq cr6, 0x82c4f7dc
	if ctx.cr[6].eq {
	pc = 0x82C4F7DC; continue 'dispatch;
	}
	// 82C4F798: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4F79C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F7A0: 419A003C  beq cr6, 0x82c4f7dc
	if ctx.cr[6].eq {
	pc = 0x82C4F7DC; continue 'dispatch;
	}
	// 82C4F7A4: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4F7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F7AC: 419A0030  beq cr6, 0x82c4f7dc
	if ctx.cr[6].eq {
	pc = 0x82C4F7DC; continue 'dispatch;
	}
	// 82C4F7B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4F7B4: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82C4F7B8: 9164001C  stw r11, 0x1c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82C4F7BC: 91640020  stw r11, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82C4F7C0: 99640024  stb r11, 0x24(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82C4F7C4: 4BEF9865  bl 0x82b49028
	ctx.lr = 0x82C4F7C8;
	sub_82B49028(ctx, base);
	// 82C4F7C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4F7CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4F7D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F7D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F7D8: 4E800020  blr
	return;
	// 82C4F7DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4F7E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4F7E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F7E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F7EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F7F0 size=116
    let mut pc: u32 = 0x82C4F7F0;
    'dispatch: loop {
        match pc {
            0x82C4F7F0 => {
    //   block [0x82C4F7F0..0x82C4F864)
	// 82C4F7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F7F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4F7F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4F7FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F800: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4F804: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F808: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4F80C: 419A0034  beq cr6, 0x82c4f840
	if ctx.cr[6].eq {
	pc = 0x82C4F840; continue 'dispatch;
	}
	// 82C4F810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F814: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4F818: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4F81C: 4E800421  bctrl
	ctx.lr = 0x82C4F820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4F820: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C4F824: 4198001C  blt cr6, 0x82c4f840
	if ctx.cr[6].lt {
	pc = 0x82C4F840; continue 'dispatch;
	}
	// 82C4F828: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82C4F82C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4F830: 40980014  bge cr6, 0x82c4f844
	if !ctx.cr[6].lt {
	pc = 0x82C4F844; continue 'dispatch;
	}
	// 82C4F834: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4F838: 386B5088  addi r3, r11, 0x5088
	ctx.r[3].s64 = ctx.r[11].s64 + 20616;
	// 82C4F83C: 48000010  b 0x82c4f84c
	pc = 0x82C4F84C; continue 'dispatch;
	// 82C4F840: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4F844: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4F848: 386B5010  addi r3, r11, 0x5010
	ctx.r[3].s64 = ctx.r[11].s64 + 20496;
	// 82C4F84C: 4BFFFF35  bl 0x82c4f780
	ctx.lr = 0x82C4F850;
	sub_82C4F780(ctx, base);
	// 82C4F850: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4F854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F85C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4F860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F868 size=68
    let mut pc: u32 = 0x82C4F868;
    'dispatch: loop {
        match pc {
            0x82C4F868 => {
    //   block [0x82C4F868..0x82C4F8AC)
	// 82C4F868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4F870: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F874: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4F878: 396B5088  addi r11, r11, 0x5088
	ctx.r[11].s64 = ctx.r[11].s64 + 20616;
	// 82C4F87C: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82C4F880: 4BEF99A1  bl 0x82b49220
	ctx.lr = 0x82C4F884;
	sub_82B49220(ctx, base);
	// 82C4F884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4F888: 409A0014  bne cr6, 0x82c4f89c
	if !ctx.cr[6].eq {
	pc = 0x82C4F89C; continue 'dispatch;
	}
	// 82C4F88C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C4F890: 396B5010  addi r11, r11, 0x5010
	ctx.r[11].s64 = ctx.r[11].s64 + 20496;
	// 82C4F894: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82C4F898: 4BEF9989  bl 0x82b49220
	ctx.lr = 0x82C4F89C;
	sub_82B49220(ctx, base);
	// 82C4F89C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4F8A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F8A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F8A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F8B0 size=160
    let mut pc: u32 = 0x82C4F8B0;
    'dispatch: loop {
        match pc {
            0x82C4F8B0 => {
    //   block [0x82C4F8B0..0x82C4F950)
	// 82C4F8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4F8B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4F8BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4F8C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F8C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4F8C8: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82C4F8CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4F8D0: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 82C4F8D4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4F8D8: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C4F8DC: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C4F8E0: 4098004C  bge cr6, 0x82c4f92c
	if !ctx.cr[6].lt {
	pc = 0x82C4F92C; continue 'dispatch;
	}
	// 82C4F8E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C4F8E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4F8EC: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82C4F8F0: 4B6A2651  bl 0x822f1f40
	ctx.lr = 0x82C4F8F4;
	sub_822F1F40(ctx, base);
	// 82C4F8F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C4F8F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C4F8FC: 4B6A2475  bl 0x822f1d70
	ctx.lr = 0x82C4F900;
	sub_822F1D70(ctx, base);
	// 82C4F900: 4B6A2521  bl 0x822f1e20
	ctx.lr = 0x82C4F904;
	sub_822F1E20(ctx, base);
	// 82C4F904: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C4F908: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C4F90C: 392A1720  addi r9, r10, 0x1720
	ctx.r[9].s64 = ctx.r[10].s64 + 5920;
	// 82C4F910: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82C4F914: 4BA2BECD  bl 0x8267b7e0
	ctx.lr = 0x82C4F918;
	sub_8267B7E0(ctx, base);
	// 82C4F918: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C4F91C: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82C4F920: 4198000C  blt cr6, 0x82c4f92c
	if ctx.cr[6].lt {
	pc = 0x82C4F92C; continue 'dispatch;
	}
	// 82C4F924: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4F928: 4BBF5E89  bl 0x828457b0
	ctx.lr = 0x82C4F92C;
	sub_828457B0(ctx, base);
	// 82C4F92C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4F930: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C4F934: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4F938: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C4F93C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4F940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4F944: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4F948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4F94C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4F950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4F950 size=440
    let mut pc: u32 = 0x82C4F950;
    'dispatch: loop {
        match pc {
            0x82C4F950 => {
    //   block [0x82C4F950..0x82C4FB08)
	// 82C4F950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4F954: 48059AA9  bl 0x82ca93fc
	ctx.lr = 0x82C4F958;
	sub_82CA93D0(ctx, base);
	// 82C4F958: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4F95C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4F960: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C4F964: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82C4F968: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82C4F96C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F970: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4F974: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82C4F978: EBA10050  ld r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4F97C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F980: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C4F984: 419A000C  beq cr6, 0x82c4f990
	if ctx.cr[6].eq {
	pc = 0x82C4F990; continue 'dispatch;
	}
	// 82C4F988: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C4F98C: 419A0008  beq cr6, 0x82c4f994
	if ctx.cr[6].eq {
	pc = 0x82C4F994; continue 'dispatch;
	}
	// 82C4F990: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4F994: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4F998: 419A00C0  beq cr6, 0x82c4fa58
	if ctx.cr[6].eq {
	pc = 0x82C4FA58; continue 'dispatch;
	}
	// 82C4F99C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C4F9A0: 409A0008  bne cr6, 0x82c4f9a8
	if !ctx.cr[6].eq {
	pc = 0x82C4F9A8; continue 'dispatch;
	}
	// 82C4F9A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4F9A8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4F9AC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4F9B0: 409A0008  bne cr6, 0x82c4f9b8
	if !ctx.cr[6].eq {
	pc = 0x82C4F9B8; continue 'dispatch;
	}
	// 82C4F9B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4F9B8: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4F9BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4F9C0: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C4F9C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4F9C8: 419A0030  beq cr6, 0x82c4f9f8
	if ctx.cr[6].eq {
	pc = 0x82C4F9F8; continue 'dispatch;
	}
	// 82C4F9CC: 387E0038  addi r3, r30, 0x38
	ctx.r[3].s64 = ctx.r[30].s64 + 56;
	// 82C4F9D0: 4BEF9659  bl 0x82b49028
	ctx.lr = 0x82C4F9D4;
	sub_82B49028(ctx, base);
	// 82C4F9D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C4F9D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4F9DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4F9E0: 4BFFB789  bl 0x82c4b168
	ctx.lr = 0x82C4F9E4;
	sub_82C4B168(ctx, base);
	// 82C4F9E4: EBA30000  ld r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82C4F9E8: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82C4F9EC: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4F9F0: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4F9F4: 4BFFFF88  b 0x82c4f97c
	pc = 0x82C4F97C; continue 'dispatch;
	// 82C4F9F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4F9FC: 4BFFFC55  bl 0x82c4f650
	ctx.lr = 0x82C4FA00;
	sub_82C4F650(ctx, base);
	// 82C4FA00: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4FA04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4FA08: 419A0038  beq cr6, 0x82c4fa40
	if ctx.cr[6].eq {
	pc = 0x82C4FA40; continue 'dispatch;
	}
	// 82C4FA0C: 9B5F0024  stb r26, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[26].u8 ) };
	// 82C4FA10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4FA14: 387E0038  addi r3, r30, 0x38
	ctx.r[3].s64 = ctx.r[30].s64 + 56;
	// 82C4FA18: 4BEF9611  bl 0x82b49028
	ctx.lr = 0x82C4FA1C;
	sub_82B49028(ctx, base);
	// 82C4FA1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C4FA20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4FA24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C4FA28: 4BFFB741  bl 0x82c4b168
	ctx.lr = 0x82C4FA2C;
	sub_82C4B168(ctx, base);
	// 82C4FA2C: EBA30000  ld r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82C4FA30: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82C4FA34: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4FA38: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4FA3C: 4BFFFF40  b 0x82c4f97c
	pc = 0x82C4F97C; continue 'dispatch;
	// 82C4FA40: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4FA44: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4FA48: 409A0008  bne cr6, 0x82c4fa50
	if !ctx.cr[6].eq {
	pc = 0x82C4FA50; continue 'dispatch;
	}
	// 82C4FA4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C4FA50: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4FA54: 4BFFFF20  b 0x82c4f974
	pc = 0x82C4F974; continue 'dispatch;
	// 82C4FA58: 3B3E0010  addi r25, r30, 0x10
	ctx.r[25].s64 = ctx.r[30].s64 + 16;
	// 82C4FA5C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C4FA60: 4BEF97C1  bl 0x82b49220
	ctx.lr = 0x82C4FA64;
	sub_82B49220(ctx, base);
	// 82C4FA64: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82C4FA68: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82C4FA6C: 419A0094  beq cr6, 0x82c4fb00
	if ctx.cr[6].eq {
	pc = 0x82C4FB00; continue 'dispatch;
	}
	// 82C4FA70: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C4FA74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4FA78: 4BFFFBD9  bl 0x82c4f650
	ctx.lr = 0x82C4FA7C;
	sub_82C4F650(ctx, base);
	// 82C4FA7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4FA80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4FA84: 419A0014  beq cr6, 0x82c4fa98
	if ctx.cr[6].eq {
	pc = 0x82C4FA98; continue 'dispatch;
	}
	// 82C4FA88: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C4FA8C: 387E0038  addi r3, r30, 0x38
	ctx.r[3].s64 = ctx.r[30].s64 + 56;
	// 82C4FA90: 4BEF9599  bl 0x82b49028
	ctx.lr = 0x82C4FA94;
	sub_82B49028(ctx, base);
	// 82C4FA94: 48000058  b 0x82c4faec
	pc = 0x82C4FAEC; continue 'dispatch;
	// 82C4FA98: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4FA9C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82C4FAA0: 837C0004  lwz r27, 4(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4FAA4: 4B5CF7B5  bl 0x8221f258
	ctx.lr = 0x82C4FAA8;
	sub_8221F258(ctx, base);
	// 82C4FAA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4FAAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C4FAB0: 419A0008  beq cr6, 0x82c4fab8
	if ctx.cr[6].eq {
	pc = 0x82C4FAB8; continue 'dispatch;
	}
	// 82C4FAB4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82C4FAB8: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82C4FABC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C4FAC0: 419A0008  beq cr6, 0x82c4fac8
	if ctx.cr[6].eq {
	pc = 0x82C4FAC8; continue 'dispatch;
	}
	// 82C4FAC4: 937D0000  stw r27, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82C4FAC8: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4FACC: 41820008  beq 0x82c4fad4
	if ctx.cr[0].eq {
	pc = 0x82C4FAD4; continue 'dispatch;
	}
	// 82C4FAD0: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C4FAD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C4FAD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4FADC: 4BFFFDD5  bl 0x82c4f8b0
	ctx.lr = 0x82C4FAE0;
	sub_82C4F8B0(ctx, base);
	// 82C4FAE0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C4FAE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4FAE8: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C4FAEC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C4FAF0: 4BEF9731  bl 0x82b49220
	ctx.lr = 0x82C4FAF4;
	sub_82B49220(ctx, base);
	// 82C4FAF4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82C4FAF8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82C4FAFC: 409AFF74  bne cr6, 0x82c4fa70
	if !ctx.cr[6].eq {
	pc = 0x82C4FA70; continue 'dispatch;
	}
	// 82C4FB00: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C4FB04: 48059948  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4FB08 size=292
    let mut pc: u32 = 0x82C4FB08;
    'dispatch: loop {
        match pc {
            0x82C4FB08 => {
    //   block [0x82C4FB08..0x82C4FC2C)
	// 82C4FB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4FB0C: 480598FD  bl 0x82ca9408
	ctx.lr = 0x82C4FB10;
	sub_82CA93D0(ctx, base);
	// 82C4FB10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4FB14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4FB18: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82C4FB1C: 4B5CF73D  bl 0x8221f258
	ctx.lr = 0x82C4FB20;
	sub_8221F258(ctx, base);
	// 82C4FB20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4FB24: 419A0008  beq cr6, 0x82c4fb2c
	if ctx.cr[6].eq {
	pc = 0x82C4FB2C; continue 'dispatch;
	}
	// 82C4FB28: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C4FB2C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C4FB30: 41820008  beq 0x82c4fb38
	if ctx.cr[0].eq {
	pc = 0x82C4FB38; continue 'dispatch;
	}
	// 82C4FB34: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C4FB38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C4FB3C: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82C4FB40: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C4FB44: 4BF051B5  bl 0x82b54cf8
	ctx.lr = 0x82C4FB48;
	sub_82B54CF8(ctx, base);
	// 82C4FB48: FBFE0010  std r31, 0x10(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 82C4FB4C: FBFE0018  std r31, 0x18(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 82C4FB50: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 82C4FB54: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4FB58: 387D0014  addi r3, r29, 0x14
	ctx.r[3].s64 = ctx.r[29].s64 + 20;
	// 82C4FB5C: 483B1595  bl 0x830010f0
	ctx.lr = 0x82C4FB60;
	sub_830010F0(ctx, base);
	// 82C4FB60: 939E0030  stw r28, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[28].u32 ) };
	// 82C4FB64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C4FB68: 4B5CF6F1  bl 0x8221f258
	ctx.lr = 0x82C4FB6C;
	sub_8221F258(ctx, base);
	// 82C4FB6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C4FB70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4FB74: 419A000C  beq cr6, 0x82c4fb80
	if ctx.cr[6].eq {
	pc = 0x82C4FB80; continue 'dispatch;
	}
	// 82C4FB78: FBEB0008  std r31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 82C4FB7C: 48000008  b 0x82c4fb84
	pc = 0x82C4FB84; continue 'dispatch;
	// 82C4FB80: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C4FB84: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C4FB88: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C4FB8C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4FB90: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4FB94: 93FD0010  stw r31, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82C4FB98: 4BF05161  bl 0x82b54cf8
	ctx.lr = 0x82C4FB9C;
	sub_82B54CF8(ctx, base);
	// 82C4FB9C: FBFE0038  std r31, 0x38(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[31].u64 ) };
	// 82C4FBA0: FBFE0040  std r31, 0x40(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[31].u64 ) };
	// 82C4FBA4: 3BBE0038  addi r29, r30, 0x38
	ctx.r[29].s64 = ctx.r[30].s64 + 56;
	// 82C4FBA8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C4FBAC: 387D0014  addi r3, r29, 0x14
	ctx.r[3].s64 = ctx.r[29].s64 + 20;
	// 82C4FBB0: 483B1541  bl 0x830010f0
	ctx.lr = 0x82C4FBB4;
	sub_830010F0(ctx, base);
	// 82C4FBB4: 939E0058  stw r28, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82C4FBB8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C4FBBC: 4B5CF69D  bl 0x8221f258
	ctx.lr = 0x82C4FBC0;
	sub_8221F258(ctx, base);
	// 82C4FBC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C4FBC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4FBC8: 419A000C  beq cr6, 0x82c4fbd4
	if ctx.cr[6].eq {
	pc = 0x82C4FBD4; continue 'dispatch;
	}
	// 82C4FBCC: FBEB0008  std r31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 82C4FBD0: 48000008  b 0x82c4fbd8
	pc = 0x82C4FBD8; continue 'dispatch;
	// 82C4FBD4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C4FBD8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4FBDC: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C4FBE0: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C4FBE4: 3D2082C5  lis r9, -0x7d3b
	ctx.r[9].s64 = -2101018624;
	// 82C4FBE8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4FBEC: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 82C4FBF0: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4FBF4: 38EACB04  addi r7, r10, -0x34fc
	ctx.r[7].s64 = ctx.r[10].s64 + -13564;
	// 82C4FBF8: 93FD0010  stw r31, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82C4FBFC: 38C9F950  addi r6, r9, -0x6b0
	ctx.r[6].s64 = ctx.r[9].s64 + -1712;
	// 82C4FC00: 9BFE0060  stb r31, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[31].u8 ) };
	// 82C4FC04: 397E0068  addi r11, r30, 0x68
	ctx.r[11].s64 = ctx.r[30].s64 + 104;
	// 82C4FC08: 911E0064  stw r8, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82C4FC0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4FC10: 90FE0068  stw r7, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 82C4FC14: 93FE006C  stw r31, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82C4FC18: 93FE0070  stw r31, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82C4FC1C: 93DE006C  stw r30, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82C4FC20: 90DE0070  stw r6, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[6].u32 ) };
	// 82C4FC24: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4FC28: 48059830  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4FC30 size=8
    let mut pc: u32 = 0x82C4FC30;
    'dispatch: loop {
        match pc {
            0x82C4FC30 => {
    //   block [0x82C4FC30..0x82C4FC38)
	// 82C4FC30: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C4FC34: 4BFB60CC  b 0x82c05d00
	sub_82C05D00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4FC38 size=12
    let mut pc: u32 = 0x82C4FC38;
    'dispatch: loop {
        match pc {
            0x82C4FC38 => {
    //   block [0x82C4FC38..0x82C4FC44)
	// 82C4FC38: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C4FC3C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C4FC40: 4BFB6108  b 0x82c05d48
	sub_82C05D48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4FC48 size=160
    let mut pc: u32 = 0x82C4FC48;
    'dispatch: loop {
        match pc {
            0x82C4FC48 => {
    //   block [0x82C4FC48..0x82C4FCE8)
	// 82C4FC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4FC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4FC50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4FC54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4FC58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4FC5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4FC60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4FC64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4FC68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C4FC6C: 388BB25C  addi r4, r11, -0x4da4
	ctx.r[4].s64 = ctx.r[11].s64 + -19876;
	// 82C4FC70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4FC74: 4BFB7535  bl 0x82c071a8
	ctx.lr = 0x82C4FC78;
	sub_82C071A8(ctx, base);
	// 82C4FC78: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4FC7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4FC80: 419A0048  beq cr6, 0x82c4fcc8
	if ctx.cr[6].eq {
	pc = 0x82C4FCC8; continue 'dispatch;
	}
	// 82C4FC84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4FC88: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C4FC8C: 388BCB78  addi r4, r11, -0x3488
	ctx.r[4].s64 = ctx.r[11].s64 + -13448;
	// 82C4FC90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4FC94: 4BFCB91D  bl 0x82c1b5b0
	ctx.lr = 0x82C4FC98;
	sub_82C1B5B0(ctx, base);
	// 82C4FC98: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4FC9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4FCA0: 419A0028  beq cr6, 0x82c4fcc8
	if ctx.cr[6].eq {
	pc = 0x82C4FCC8; continue 'dispatch;
	}
	// 82C4FCA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4FCA8: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82C4FCAC: 388BCB6C  addi r4, r11, -0x3494
	ctx.r[4].s64 = ctx.r[11].s64 + -13460;
	// 82C4FCB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4FCB4: 4BFB74F5  bl 0x82c071a8
	ctx.lr = 0x82C4FCB8;
	sub_82C071A8(ctx, base);
	// 82C4FCB8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4FCBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4FCC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4FCC4: 409A0008  bne cr6, 0x82c4fccc
	if !ctx.cr[6].eq {
	pc = 0x82C4FCCC; continue 'dispatch;
	}
	// 82C4FCC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4FCCC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4FCD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4FCD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4FCD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4FCDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4FCE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4FCE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C4FCE8 size=160
    let mut pc: u32 = 0x82C4FCE8;
    'dispatch: loop {
        match pc {
            0x82C4FCE8 => {
    //   block [0x82C4FCE8..0x82C4FD88)
	// 82C4FCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4FCEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C4FCF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4FCF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4FCF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4FCFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4FD00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4FD04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4FD08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C4FD0C: 388BCB88  addi r4, r11, -0x3478
	ctx.r[4].s64 = ctx.r[11].s64 + -13432;
	// 82C4FD10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4FD14: 4BFB7495  bl 0x82c071a8
	ctx.lr = 0x82C4FD18;
	sub_82C071A8(ctx, base);
	// 82C4FD18: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4FD1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4FD20: 419A0048  beq cr6, 0x82c4fd68
	if ctx.cr[6].eq {
	pc = 0x82C4FD68; continue 'dispatch;
	}
	// 82C4FD24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4FD28: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C4FD2C: 388BCB80  addi r4, r11, -0x3480
	ctx.r[4].s64 = ctx.r[11].s64 + -13440;
	// 82C4FD30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4FD34: 4BFB7475  bl 0x82c071a8
	ctx.lr = 0x82C4FD38;
	sub_82C071A8(ctx, base);
	// 82C4FD38: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4FD3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4FD40: 419A0028  beq cr6, 0x82c4fd68
	if ctx.cr[6].eq {
	pc = 0x82C4FD68; continue 'dispatch;
	}
	// 82C4FD44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82C4FD48: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82C4FD4C: 388BD838  addi r4, r11, -0x27c8
	ctx.r[4].s64 = ctx.r[11].s64 + -10184;
	// 82C4FD50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4FD54: 4BFCB85D  bl 0x82c1b5b0
	ctx.lr = 0x82C4FD58;
	sub_82C1B5B0(ctx, base);
	// 82C4FD58: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4FD5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4FD60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4FD64: 409A0008  bne cr6, 0x82c4fd6c
	if !ctx.cr[6].eq {
	pc = 0x82C4FD6C; continue 'dispatch;
	}
	// 82C4FD68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4FD6C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4FD70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4FD74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4FD78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4FD7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4FD80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4FD84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4FD88 size=20
    let mut pc: u32 = 0x82C4FD88;
    'dispatch: loop {
        match pc {
            0x82C4FD88 => {
    //   block [0x82C4FD88..0x82C4FD9C)
	// 82C4FD88: 2F050019  cmpwi cr6, r5, 0x19
	ctx.cr[6].compare_i32(ctx.r[5].s32, 25, &mut ctx.xer);
	// 82C4FD8C: 41980010  blt cr6, 0x82c4fd9c
	if ctx.cr[6].lt {
		sub_82C4FD9C(ctx, base);
		return;
	}
	// 82C4FD90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4FD94: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C4FD98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FD9C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4FD9C size=44
    let mut pc: u32 = 0x82C4FD9C;
    'dispatch: loop {
        match pc {
            0x82C4FD9C => {
    //   block [0x82C4FD9C..0x82C4FDC8)
	// 82C4FD9C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4FDA0: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4FDA4: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C4FDA8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4FDAC: 38EACB08  addi r7, r10, -0x34f8
	ctx.r[7].s64 = ctx.r[10].s64 + -13560;
	// 82C4FDB0: 7D492050  subf r10, r9, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82C4FDB4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4FDB8: 7D28382E  lwzx r9, r8, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82C4FDBC: 4198000C  blt cr6, 0x82c4fdc8
	if ctx.cr[6].lt {
		sub_82C4FDC8(ctx, base);
		return;
	}
	// 82C4FDC0: C1830018  lfs f12, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4FDC4: 48000040  b 0x82c4fe04
	sub_82C4FDC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4FDC8 size=192
    let mut pc: u32 = 0x82C4FDC8;
    'dispatch: loop {
        match pc {
            0x82C4FDC8 => {
    //   block [0x82C4FDC8..0x82C4FE88)
	// 82C4FDC8: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82C4FDCC: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4FDD0: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82C4FDD4: C1A30018  lfs f13, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4FDD8: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82C4FDDC: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4FDE0: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82C4FDE4: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4FDE8: FD20669C  fcfid f9, f12
	ctx.f[9].f64 = (ctx.f[12].s64 as f64);
	// 82C4FDEC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82C4FDF0: FCC04818  frsp f6, f9
	ctx.f[6].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82C4FDF4: ECED0028  fsubs f7, f13, f0
	ctx.f[7].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C4FDF8: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82C4FDFC: ECA83024  fdivs f5, f8, f6
	ctx.f[5].f64 = ((ctx.f[8].f64 / ctx.f[6].f64) as f32) as f64;
	// 82C4FE00: ED8501FA  fmadds f12, f5, f7, f0
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C4FE04: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4FE08: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C4FE0C: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4FE10: C1AB0028  lfs f13, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4FE14: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4FE18: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82C4FE1C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4FE20: 4098003C  bge cr6, 0x82c4fe5c
	if !ctx.cr[6].lt {
	pc = 0x82C4FE5C; continue 'dispatch;
	}
	// 82C4FE24: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 82C4FE28: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4FE2C: 79480020  clrldi r8, r10, 0x20
	ctx.r[8].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82C4FE30: ECCD0028  fsubs f6, f13, f0
	ctx.f[6].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C4FE34: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82C4FE38: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4FE3C: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 82C4FE40: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4FE44: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 82C4FE48: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82C4FE4C: FCA04018  frsp f5, f8
	ctx.f[5].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82C4FE50: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82C4FE54: EC853824  fdivs f4, f5, f7
	ctx.f[4].f64 = ((ctx.f[5].f64 / ctx.f[7].f64) as f32) as f64;
	// 82C4FE58: EDA401BA  fmadds f13, f4, f6, f0
	ctx.f[13].f64 = (((ctx.f[4].f64 * ctx.f[6].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C4FE5C: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4FE60: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C4FE64: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C4FE68: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4FE6C: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82C4FE70: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4FE74: 41980014  blt cr6, 0x82c4fe88
	if ctx.cr[6].lt {
		sub_82C4FE88(ctx, base);
		return;
	}
	// 82C4FE78: C00B0058  lfs f0, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4FE7C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C4FE80: EC200332  fmuls f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C4FE84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4FE88 size=72
    let mut pc: u32 = 0x82C4FE88;
    'dispatch: loop {
        match pc {
            0x82C4FE88 => {
    //   block [0x82C4FE88..0x82C4FED0)
	// 82C4FE88: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82C4FE8C: C00B0054  lfs f0, 0x54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4FE90: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 82C4FE94: C16B0058  lfs f11, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4FE98: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82C4FE9C: ECAB0028  fsubs f5, f11, f0
	ctx.f[5].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C4FEA0: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4FEA4: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82C4FEA8: FCE0569C  fcfid f7, f10
	ctx.f[7].f64 = (ctx.f[10].s64 as f64);
	// 82C4FEAC: FC803818  frsp f4, f7
	ctx.f[4].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82C4FEB0: C921FFF0  lfd f9, -0x10(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4FEB4: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82C4FEB8: FCC04018  frsp f6, f8
	ctx.f[6].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82C4FEBC: EC662024  fdivs f3, f6, f4
	ctx.f[3].f64 = ((ctx.f[6].f64 / ctx.f[4].f64) as f32) as f64;
	// 82C4FEC0: EC03017A  fmadds f0, f3, f5, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C4FEC4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C4FEC8: EC200332  fmuls f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C4FECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4FED0 size=28
    let mut pc: u32 = 0x82C4FED0;
    'dispatch: loop {
        match pc {
            0x82C4FED0 => {
    //   block [0x82C4FED0..0x82C4FEEC)
	// 82C4FED0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C4FED4: 99250000  stb r9, 0(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82C4FED8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4FEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4FEE0: 409A000C  bne cr6, 0x82c4feec
	if !ctx.cr[6].eq {
		sub_82C4FEEC(ctx, base);
		return;
	}
	// 82C4FEE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4FEE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FEEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4FEEC size=112
    let mut pc: u32 = 0x82C4FEEC;
    'dispatch: loop {
        match pc {
            0x82C4FEEC => {
    //   block [0x82C4FEEC..0x82C4FF5C)
	// 82C4FEEC: 350BFFFF  addic. r8, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C4FEF0: 4180003C  blt 0x82c4ff2c
	if ctx.cr[0].lt {
	pc = 0x82C4FF2C; continue 'dispatch;
	}
	// 82C4FEF4: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4FEF8: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4FEFC: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82C4FF00: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82C4FF04: 7D6A0194  addze r11, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82C4FF08: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4FF0C: 7D4A302E  lwzx r10, r10, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82C4FF10: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4FF14: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C4FF18: 41990044  bgt cr6, 0x82c4ff5c
	if ctx.cr[6].gt {
		sub_82C4FF5C(ctx, base);
		return;
	}
	// 82C4FF1C: 40980048  bge cr6, 0x82c4ff64
	if !ctx.cr[6].lt {
		sub_82C4FF64(ctx, base);
		return;
	}
	// 82C4FF20: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82C4FF24: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82C4FF28: 4099FFD4  ble cr6, 0x82c4fefc
	if !ctx.cr[6].gt {
	pc = 0x82C4FEFC; continue 'dispatch;
	}
	// 82C4FF2C: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82C4FF30: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4FF34: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4FF38: 7D680E70  srawi r8, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82C4FF3C: 7C680194  addze r3, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[3].s64 = tmp.s64;
	// 82C4FF40: 5467103A  slwi r7, r3, 2
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C4FF44: 7D67502E  lwzx r11, r7, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82C4FF48: 80CB0020  lwz r6, 0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4FF4C: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C4FF50: 41980008  blt cr6, 0x82c4ff58
	if ctx.cr[6].lt {
	pc = 0x82C4FF58; continue 'dispatch;
	}
	// 82C4FF54: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82C4FF58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FF5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4FF5C size=8
    let mut pc: u32 = 0x82C4FF5C;
    'dispatch: loop {
        match pc {
            0x82C4FF5C => {
    //   block [0x82C4FF5C..0x82C4FF64)
	// 82C4FF5C: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82C4FF60: 4BFFFFC4  b 0x82c4ff24
	sub_82C4FEEC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FF64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C4FF64 size=16
    let mut pc: u32 = 0x82C4FF64;
    'dispatch: loop {
        match pc {
            0x82C4FF64 => {
    //   block [0x82C4FF64..0x82C4FF74)
	// 82C4FF64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C4FF68: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C4FF6C: 99450000  stb r10, 0(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82C4FF70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C4FF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C4FF78 size=216
    let mut pc: u32 = 0x82C4FF78;
    'dispatch: loop {
        match pc {
            0x82C4FF78 => {
    //   block [0x82C4FF78..0x82C50050)
	// 82C4FF78: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82C4FF7C: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82C4FF80: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82C4FF84: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4FF88: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82C4FF8C: 40980050  bge cr6, 0x82c4ffdc
	if !ctx.cr[6].lt {
	pc = 0x82C4FFDC; continue 'dispatch;
	}
	// 82C4FF90: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C4FF94: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 82C4FF98: 8109FFFC  lwz r8, -4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C4FF9C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4FFA0: 81080020  lwz r8, 0x20(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4FFA4: 80890020  lwz r4, 0x20(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C4FFA8: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C4FFAC: 40980008  bge cr6, 0x82c4ffb4
	if !ctx.cr[6].lt {
	pc = 0x82C4FFB4; continue 'dispatch;
	}
	// 82C4FFB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82C4FFB4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C4FFB8: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C4FFBC: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82C4FFC0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C4FFC4: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4FFC8: 7D29182E  lwzx r9, r9, r3
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82C4FFCC: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82C4FFD0: 7D28192E  stwx r9, r8, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32), ctx.r[9].u32) };
	// 82C4FFD4: 4198FFBC  blt cr6, 0x82c4ff90
	if ctx.cr[6].lt {
	pc = 0x82C4FF90; continue 'dispatch;
	}
	// 82C4FFD8: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82C4FFDC: 409A001C  bne cr6, 0x82c4fff8
	if !ctx.cr[6].eq {
	pc = 0x82C4FFF8; continue 'dispatch;
	}
	// 82C4FFE0: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4FFE4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C4FFE8: 7D0B1A14  add r8, r11, r3
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C4FFEC: 3945FFFF  addi r10, r5, -1
	ctx.r[10].s64 = ctx.r[5].s64 + -1;
	// 82C4FFF0: 80A8FFFC  lwz r5, -4(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C4FFF4: 7CA9192E  stwx r5, r9, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), ctx.r[5].u32) };
	// 82C4FFF8: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 82C4FFFC: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C50000: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82C50004: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82C50008: 4098003C  bge cr6, 0x82c50044
	if !ctx.cr[6].lt {
	pc = 0x82C50044; continue 'dispatch;
	}
	// 82C5000C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C50010: 81060020  lwz r8, 0x20(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50014: 7D29182E  lwzx r9, r9, r3
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82C50018: 80A90020  lwz r5, 0x20(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C5001C: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C50020: 40980024  bge cr6, 0x82c50044
	if !ctx.cr[6].lt {
	pc = 0x82C50044; continue 'dispatch;
	}
	// 82C50024: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C50028: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82C5002C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C50030: 7CA40E70  srawi r4, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82C50034: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C50038: 7D28192E  stwx r9, r8, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32), ctx.r[9].u32) };
	// 82C5003C: 7D640194  addze r11, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82C50040: 4198FFCC  blt cr6, 0x82c5000c
	if ctx.cr[6].lt {
	pc = 0x82C5000C; continue 'dispatch;
	}
	// 82C50044: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C50048: 7CCB192E  stwx r6, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[6].u32) };
	// 82C5004C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C50050 size=44
    let mut pc: u32 = 0x82C50050;
    'dispatch: loop {
        match pc {
            0x82C50050 => {
    //   block [0x82C50050..0x82C5007C)
	// 82C50050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C50058: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5005C: D0210084  stfs f1, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82C50060: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 82C50064: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 82C50068: 4BFC3129  bl 0x82c13190
	ctx.lr = 0x82C5006C;
	sub_82C13190(ctx, base);
	// 82C5006C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C50070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C50074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C50078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C50080 size=64
    let mut pc: u32 = 0x82C50080;
    'dispatch: loop {
        match pc {
            0x82C50080 => {
    //   block [0x82C50080..0x82C500C0)
	// 82C50080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C50088: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5008C: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82C50090: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82C50094: 4098001C  bge cr6, 0x82c500b0
	if !ctx.cr[6].lt {
	pc = 0x82C500B0; continue 'dispatch;
	}
	// 82C50098: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C5009C: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 82C500A0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C500A4: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 82C500A8: 386B001C  addi r3, r11, 0x1c
	ctx.r[3].s64 = ctx.r[11].s64 + 28;
	// 82C500AC: 4BFC30E5  bl 0x82c13190
	ctx.lr = 0x82C500B0;
	sub_82C13190(ctx, base);
	// 82C500B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C500B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C500B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C500BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C500C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C500C0 size=40
    let mut pc: u32 = 0x82C500C0;
    'dispatch: loop {
        match pc {
            0x82C500C0 => {
    //   block [0x82C500C0..0x82C500E8)
	// 82C500C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C500C4: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82C500C8: 7D4B2050  subf r10, r11, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82C500CC: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C500D0: 7D4A4BD6  divw r10, r10, r9
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 82C500D4: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C500D8: 7D0A4A14  add r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82C500DC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C500E0: 7C6A2A14  add r3, r10, r5
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 82C500E4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C500E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C500E8 size=48
    let mut pc: u32 = 0x82C500E8;
    'dispatch: loop {
        match pc {
            0x82C500E8 => {
    //   block [0x82C500E8..0x82C50118)
	// 82C500E8: 7D4B2850  subf r10, r11, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82C500EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C500F0: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C500F4: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82C500F8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C500FC: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82C50100: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C50104: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C50108: 90C80008  stw r6, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82C5010C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C50110: 409AFFDC  bne cr6, 0x82c500ec
	if !ctx.cr[6].eq {
	pc = 0x82C500EC; continue 'dispatch;
	}
	// 82C50114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C50118 size=548
    let mut pc: u32 = 0x82C50118;
    'dispatch: loop {
        match pc {
            0x82C50118 => {
    //   block [0x82C50118..0x82C5033C)
	// 82C50118: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82C5011C: 7D632850  subf r11, r3, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	// 82C50120: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82C50124: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 82C50128: 409901AC  ble cr6, 0x82c502d4
	if !ctx.cr[6].gt {
	pc = 0x82C502D4; continue 'dispatch;
	}
	// 82C5012C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C50130: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50134: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82C50138: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82C5013C: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50140: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C50144: 55471838  slwi r7, r10, 3
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C50148: 7D4B182E  lwzx r10, r11, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82C5014C: 80CA0020  lwz r6, 0x20(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50150: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C50154: 4098000C  bge cr6, 0x82c50160
	if !ctx.cr[6].lt {
	pc = 0x82C50160; continue 'dispatch;
	}
	// 82C50158: 7D2B192E  stwx r9, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[9].u32) };
	// 82C5015C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50160: 7D2B182E  lwzx r9, r11, r3
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82C50164: 7D47182E  lwzx r10, r7, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82C50168: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C5016C: 80CA0020  lwz r6, 0x20(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50170: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C50174: 4098000C  bge cr6, 0x82c50180
	if !ctx.cr[6].lt {
	pc = 0x82C50180; continue 'dispatch;
	}
	// 82C50178: 7D27192E  stwx r9, r7, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[3].u32), ctx.r[9].u32) };
	// 82C5017C: 7D4B192E  stwx r10, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 82C50180: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50184: 7D4B182E  lwzx r10, r11, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82C50188: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C5018C: 80CA0020  lwz r6, 0x20(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50190: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C50194: 4098000C  bge cr6, 0x82c501a0
	if !ctx.cr[6].lt {
	pc = 0x82C501A0; continue 'dispatch;
	}
	// 82C50198: 7D2B192E  stwx r9, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[9].u32) };
	// 82C5019C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C501A0: 7D0B2050  subf r8, r11, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82C501A4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C501A8: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C501AC: 80CA0020  lwz r6, 0x20(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C501B0: 83E90020  lwz r31, 0x20(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C501B4: 7F06F840  cmplw cr6, r6, r31
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C501B8: 4098000C  bge cr6, 0x82c501c4
	if !ctx.cr[6].lt {
	pc = 0x82C501C4; continue 'dispatch;
	}
	// 82C501BC: 91240000  stw r9, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C501C0: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C501C4: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C501C8: 7D4B202E  lwzx r10, r11, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82C501CC: 80C90020  lwz r6, 0x20(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C501D0: 83EA0020  lwz r31, 0x20(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C501D4: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C501D8: 4098000C  bge cr6, 0x82c501e4
	if !ctx.cr[6].lt {
	pc = 0x82C501E4; continue 'dispatch;
	}
	// 82C501DC: 7D2B212E  stwx r9, r11, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[9].u32) };
	// 82C501E0: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C501E4: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C501E8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C501EC: 80C90020  lwz r6, 0x20(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C501F0: 83EA0020  lwz r31, 0x20(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C501F4: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C501F8: 4098000C  bge cr6, 0x82c50204
	if !ctx.cr[6].lt {
	pc = 0x82C50204; continue 'dispatch;
	}
	// 82C501FC: 91240000  stw r9, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C50200: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50204: 7D4B2850  subf r10, r11, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82C50208: 7CE72850  subf r7, r7, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 82C5020C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50210: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50214: 80C90020  lwz r6, 0x20(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50218: 83E80020  lwz r31, 0x20(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C5021C: 7F06F840  cmplw cr6, r6, r31
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C50220: 4098000C  bge cr6, 0x82c5022c
	if !ctx.cr[6].lt {
	pc = 0x82C5022C; continue 'dispatch;
	}
	// 82C50224: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C50228: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5022C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50230: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50234: 80C80020  lwz r6, 0x20(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50238: 83E90020  lwz r31, 0x20(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C5023C: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C50240: 4098000C  bge cr6, 0x82c5024c
	if !ctx.cr[6].lt {
	pc = 0x82C5024C; continue 'dispatch;
	}
	// 82C50244: 91050000  stw r8, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C50248: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5024C: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50250: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50254: 80C80020  lwz r6, 0x20(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50258: 80A90020  lwz r5, 0x20(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C5025C: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C50260: 4098000C  bge cr6, 0x82c5026c
	if !ctx.cr[6].lt {
	pc = 0x82C5026C; continue 'dispatch;
	}
	// 82C50264: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C50268: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5026C: 7D0B182E  lwzx r8, r11, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82C50270: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50274: 80E80020  lwz r7, 0x20(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50278: 80C90020  lwz r6, 0x20(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C5027C: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C50280: 4098000C  bge cr6, 0x82c5028c
	if !ctx.cr[6].lt {
	pc = 0x82C5028C; continue 'dispatch;
	}
	// 82C50284: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C50288: 7D2B192E  stwx r9, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[9].u32) };
	// 82C5028C: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50290: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50294: 80E80020  lwz r7, 0x20(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50298: 80C90020  lwz r6, 0x20(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C5029C: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C502A0: 4098000C  bge cr6, 0x82c502ac
	if !ctx.cr[6].lt {
	pc = 0x82C502AC; continue 'dispatch;
	}
	// 82C502A4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C502A8: 91240000  stw r9, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C502AC: 7D2B182E  lwzx r9, r11, r3
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82C502B0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C502B4: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C502B8: 80EA0020  lwz r7, 0x20(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C502BC: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C502C0: 40980074  bge cr6, 0x82c50334
	if !ctx.cr[6].lt {
	pc = 0x82C50334; continue 'dispatch;
	}
	// 82C502C4: 91240000  stw r9, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C502C8: 7D4B192E  stwx r10, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 82C502CC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82C502D0: 4E800020  blr
	return;
	// 82C502D4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C502D8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C502DC: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C502E0: 810B0020  lwz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C502E4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C502E8: 4098000C  bge cr6, 0x82c502f4
	if !ctx.cr[6].lt {
	pc = 0x82C502F4; continue 'dispatch;
	}
	// 82C502EC: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C502F0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C502F4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C502F8: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C502FC: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50300: 810B0020  lwz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50304: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C50308: 4098000C  bge cr6, 0x82c50314
	if !ctx.cr[6].lt {
	pc = 0x82C50314; continue 'dispatch;
	}
	// 82C5030C: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50310: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C50314: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50318: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5031C: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50320: 810B0020  lwz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50324: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C50328: 4098000C  bge cr6, 0x82c50334
	if !ctx.cr[6].lt {
	pc = 0x82C50334; continue 'dispatch;
	}
	// 82C5032C: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50330: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C50334: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82C50338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C50340 size=96
    let mut pc: u32 = 0x82C50340;
    'dispatch: loop {
        match pc {
            0x82C50340 => {
    //   block [0x82C50340..0x82C503A0)
	// 82C50340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50344: 480590C1  bl 0x82ca9404
	ctx.lr = 0x82C50348;
	sub_82CA93D0(ctx, base);
	// 82C50348: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5034C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C50350: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C50354: 7D7D2050  subf r11, r29, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[29].s64;
	// 82C50358: 7D7C1670  srawi r28, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82C5035C: 7F8A0E70  srawi r10, r28, 1
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[28].s32 >> 1) as i64;
	// 82C50360: 7FEA0195  addze. r31, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82C50364: 40810034  ble 0x82c50398
	if !ctx.cr[0].gt {
	pc = 0x82C50398; continue 'dispatch;
	}
	// 82C50368: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C5036C: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82C50370: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 82C50374: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82C50378: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C5037C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C50380: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C50384: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50388: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5038C: 4BFFFBED  bl 0x82c4ff78
	ctx.lr = 0x82C50390;
	sub_82C4FF78(ctx, base);
	// 82C50390: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82C50394: 4199FFDC  bgt cr6, 0x82c50370
	if ctx.cr[6].gt {
	pc = 0x82C50370; continue 'dispatch;
	}
	// 82C50398: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5039C: 480590B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C503A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C503A0 size=196
    let mut pc: u32 = 0x82C503A0;
    'dispatch: loop {
        match pc {
            0x82C503A0 => {
    //   block [0x82C503A0..0x82C50464)
	// 82C503A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C503A4: 3943001C  addi r10, r3, 0x1c
	ctx.r[10].s64 = ctx.r[3].s64 + 28;
	// 82C503A8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C503AC: 3923004C  addi r9, r3, 0x4c
	ctx.r[9].s64 = ctx.r[3].s64 + 76;
	// 82C503B0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C503B4: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 82C503B8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C503BC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C503C0: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C503C4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82C503C8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82C503CC: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82C503D0: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82C503D4: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82C503D8: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82C503DC: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C503E0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C503E4: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C503E8: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 82C503EC: 4080FFF0  bge 0x82c503dc
	if !ctx.cr[0].lt {
	pc = 0x82C503DC; continue 'dispatch;
	}
	// 82C503F0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C503F4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C503F8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C503FC: 39200019  li r9, 0x19
	ctx.r[9].s64 = 25;
	// 82C50400: C0080C14  lfs f0, 0xc14(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C50404: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C50408: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C5040C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C50410: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C50414: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C50418: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C5041C: 3943003C  addi r10, r3, 0x3c
	ctx.r[10].s64 = ctx.r[3].s64 + 60;
	// 82C50420: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82C50424: 39430058  addi r10, r3, 0x58
	ctx.r[10].s64 = ctx.r[3].s64 + 88;
	// 82C50428: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82C5042C: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82C50430: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82C50434: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82C50438: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82C5043C: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82C50440: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82C50444: D00AFFFC  stfs f0, -4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82C50448: 916AFFF4  stw r11, -0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82C5044C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C50450: 916AFFF8  stw r11, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 82C50454: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C50458: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82C5045C: 4082FFE8  bne 0x82c50444
	if !ctx.cr[0].eq {
	pc = 0x82C50444; continue 'dispatch;
	}
	// 82C50460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C50468 size=588
    let mut pc: u32 = 0x82C50468;
    'dispatch: loop {
        match pc {
            0x82C50468 => {
    //   block [0x82C50468..0x82C506B4)
	// 82C50468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5046C: 48058F9D  bl 0x82ca9408
	ctx.lr = 0x82C50470;
	sub_82CA93D0(ctx, base);
	// 82C50470: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C50478: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C5047C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C50480: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82C50484: 38BDFFFC  addi r5, r29, -4
	ctx.r[5].s64 = ctx.r[29].s64 + -4;
	// 82C50488: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82C5048C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C50490: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82C50494: 7D090194  addze r8, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[8].s64 = tmp.s64;
	// 82C50498: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C5049C: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C504A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C504A4: 4BFFFC75  bl 0x82c50118
	ctx.lr = 0x82C504A8;
	sub_82C50118(ctx, base);
	// 82C504A8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82C504AC: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C504B0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C504B4: 40980044  bge cr6, 0x82c504f8
	if !ctx.cr[6].lt {
	pc = 0x82C504F8; continue 'dispatch;
	}
	// 82C504B8: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C504BC: 3928FFFC  addi r9, r8, -4
	ctx.r[9].s64 = ctx.r[8].s64 + -4;
	// 82C504C0: 8148FFFC  lwz r10, -4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C504C4: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82C504C8: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82C504CC: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C504D0: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C504D4: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C504D8: 41980020  blt cr6, 0x82c504f8
	if ctx.cr[6].lt {
	pc = 0x82C504F8; continue 'dispatch;
	}
	// 82C504DC: 54EB003E  slwi r11, r7, 0
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C504E0: 54CA003E  slwi r10, r6, 0
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C504E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C504E8: 41980010  blt cr6, 0x82c504f8
	if ctx.cr[6].lt {
	pc = 0x82C504F8; continue 'dispatch;
	}
	// 82C504EC: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82C504F0: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C504F4: 4198FFC4  blt cr6, 0x82c504b8
	if ctx.cr[6].lt {
	pc = 0x82C504B8; continue 'dispatch;
	}
	// 82C504F8: 7F05E840  cmplw cr6, r5, r29
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C504FC: 40980040  bge cr6, 0x82c5053c
	if !ctx.cr[6].lt {
	pc = 0x82C5053C; continue 'dispatch;
	}
	// 82C50500: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50504: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 82C50508: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5050C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50510: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82C50514: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50518: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C5051C: 41980020  blt cr6, 0x82c5053c
	if ctx.cr[6].lt {
	pc = 0x82C5053C; continue 'dispatch;
	}
	// 82C50520: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C50524: 54E7003E  slwi r7, r7, 0
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C50528: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C5052C: 41980010  blt cr6, 0x82c5053c
	if ctx.cr[6].lt {
	pc = 0x82C5053C; continue 'dispatch;
	}
	// 82C50530: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82C50534: 7F05E840  cmplw cr6, r5, r29
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C50538: 4198FFD0  blt cr6, 0x82c50508
	if ctx.cr[6].lt {
	pc = 0x82C50508; continue 'dispatch;
	}
	// 82C5053C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82C50540: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 82C50544: 7F07E840  cmplw cr6, r7, r29
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C50548: 40980054  bge cr6, 0x82c5059c
	if !ctx.cr[6].lt {
	pc = 0x82C5059C; continue 'dispatch;
	}
	// 82C5054C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50550: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50554: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82C50558: 39690020  addi r11, r9, 0x20
	ctx.r[11].s64 = ctx.r[9].s64 + 32;
	// 82C5055C: 80890020  lwz r4, 0x20(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50560: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50564: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C50568: 41980028  blt cr6, 0x82c50590
	if ctx.cr[6].lt {
	pc = 0x82C50590; continue 'dispatch;
	}
	// 82C5056C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50570: 546A003E  slwi r10, r3, 0
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C50574: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C50578: 41980024  blt cr6, 0x82c5059c
	if ctx.cr[6].lt {
	pc = 0x82C5059C; continue 'dispatch;
	}
	// 82C5057C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82C50580: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82C50584: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50588: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5058C: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50590: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82C50594: 7F07E840  cmplw cr6, r7, r29
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C50598: 4198FFB4  blt cr6, 0x82c5054c
	if ctx.cr[6].lt {
	pc = 0x82C5054C; continue 'dispatch;
	}
	// 82C5059C: 7F06F040  cmplw cr6, r6, r30
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C505A0: 4099005C  ble cr6, 0x82c505fc
	if !ctx.cr[6].gt {
	pc = 0x82C505FC; continue 'dispatch;
	}
	// 82C505A4: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C505A8: 3926FFFC  addi r9, r6, -4
	ctx.r[9].s64 = ctx.r[6].s64 + -4;
	// 82C505AC: 8146FFFC  lwz r10, -4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C505B0: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82C505B4: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82C505B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C505BC: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C505C0: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C505C4: 41980028  blt cr6, 0x82c505ec
	if ctx.cr[6].lt {
	pc = 0x82C505EC; continue 'dispatch;
	}
	// 82C505C8: 548B003E  slwi r11, r4, 0
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C505CC: 546A003E  slwi r10, r3, 0
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C505D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C505D4: 41980024  blt cr6, 0x82c505f8
	if ctx.cr[6].lt {
	pc = 0x82C505F8; continue 'dispatch;
	}
	// 82C505D8: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 82C505DC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C505E0: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C505E4: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C505E8: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C505EC: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 82C505F0: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C505F4: 4198FFB0  blt cr6, 0x82c505a4
	if ctx.cr[6].lt {
	pc = 0x82C505A4; continue 'dispatch;
	}
	// 82C505F8: 7F06F040  cmplw cr6, r6, r30
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C505FC: 409A004C  bne cr6, 0x82c50648
	if !ctx.cr[6].eq {
	pc = 0x82C50648; continue 'dispatch;
	}
	// 82C50600: 7F07E840  cmplw cr6, r7, r29
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C50604: 419A009C  beq cr6, 0x82c506a0
	if ctx.cr[6].eq {
	pc = 0x82C506A0; continue 'dispatch;
	}
	// 82C50608: 7F053840  cmplw cr6, r5, r7
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C5060C: 419A0014  beq cr6, 0x82c50620
	if ctx.cr[6].eq {
	pc = 0x82C50620; continue 'dispatch;
	}
	// 82C50610: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50614: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50618: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C5061C: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50620: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82C50624: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82C50628: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82C5062C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82C50630: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82C50634: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50638: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5063C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C50640: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C50644: 4BFFFF00  b 0x82c50544
	pc = 0x82C50544; continue 'dispatch;
	// 82C50648: 7F07E840  cmplw cr6, r7, r29
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C5064C: 38C6FFFC  addi r6, r6, -4
	ctx.r[6].s64 = ctx.r[6].s64 + -4;
	// 82C50650: 409A0038  bne cr6, 0x82c50688
	if !ctx.cr[6].eq {
	pc = 0x82C50688; continue 'dispatch;
	}
	// 82C50654: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 82C50658: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C5065C: 419A0014  beq cr6, 0x82c50670
	if ctx.cr[6].eq {
	pc = 0x82C50670; continue 'dispatch;
	}
	// 82C50660: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50664: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50668: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C5066C: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50670: 38A5FFFC  addi r5, r5, -4
	ctx.r[5].s64 = ctx.r[5].s64 + -4;
	// 82C50674: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50678: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5067C: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50680: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C50684: 4BFFFEC0  b 0x82c50544
	pc = 0x82C50544; continue 'dispatch;
	// 82C50688: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5068C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50690: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50694: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82C50698: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C5069C: 4BFFFEA8  b 0x82c50544
	pc = 0x82C50544; continue 'dispatch;
	// 82C506A0: 911C0000  stw r8, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C506A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C506A8: 90BC0004  stw r5, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82C506AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C506B0: 48058DA8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C506B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C506B8 size=196
    let mut pc: u32 = 0x82C506B8;
    'dispatch: loop {
        match pc {
            0x82C506B8 => {
    //   block [0x82C506B8..0x82C5077C)
	// 82C506B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C506BC: 48058D4D  bl 0x82ca9408
	ctx.lr = 0x82C506C0;
	sub_82CA93D0(ctx, base);
	// 82C506C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C506C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C506C8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C506CC: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C506D0: 419A00A4  beq cr6, 0x82c50774
	if ctx.cr[6].eq {
	pc = 0x82C50774; continue 'dispatch;
	}
	// 82C506D4: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 82C506D8: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C506DC: 419A0098  beq cr6, 0x82c50774
	if ctx.cr[6].eq {
	pc = 0x82C50774; continue 'dispatch;
	}
	// 82C506E0: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82C506E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C506E8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C506EC: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82C506F0: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C506F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C506F8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C506FC: 4098001C  bge cr6, 0x82c50718
	if !ctx.cr[6].lt {
	pc = 0x82C50718; continue 'dispatch;
	}
	// 82C50700: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C50704: 419A0060  beq cr6, 0x82c50764
	if ctx.cr[6].eq {
	pc = 0x82C50764; continue 'dispatch;
	}
	// 82C50708: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C5070C: 419A0058  beq cr6, 0x82c50764
	if ctx.cr[6].eq {
	pc = 0x82C50764; continue 'dispatch;
	}
	// 82C50710: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50714: 4800003C  b 0x82c50750
	pc = 0x82C50750; continue 'dispatch;
	// 82C50718: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5071C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C50720: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C50724: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82C50728: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5072C: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C50730: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C50734: 4098000C  bge cr6, 0x82c50740
	if !ctx.cr[6].lt {
	pc = 0x82C50740; continue 'dispatch;
	}
	// 82C50738: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C5073C: 4BFFFFE8  b 0x82c50724
	pc = 0x82C50724; continue 'dispatch;
	// 82C50740: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C50744: 419A0020  beq cr6, 0x82c50764
	if ctx.cr[6].eq {
	pc = 0x82C50764; continue 'dispatch;
	}
	// 82C50748: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C5074C: 419A0018  beq cr6, 0x82c50764
	if ctx.cr[6].eq {
	pc = 0x82C50764; continue 'dispatch;
	}
	// 82C50750: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82C50754: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C50758: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C5075C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C50760: 4BFE8609  bl 0x82c38d68
	ctx.lr = 0x82C50764;
	sub_82C38D68(ctx, base);
	// 82C50764: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C50768: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C5076C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C50770: 409AFF74  bne cr6, 0x82c506e4
	if !ctx.cr[6].eq {
	pc = 0x82C506E4; continue 'dispatch;
	}
	// 82C50774: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C50778: 48058CE0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C50780 size=388
    let mut pc: u32 = 0x82C50780;
    'dispatch: loop {
        match pc {
            0x82C50780 => {
    //   block [0x82C50780..0x82C50904)
	// 82C50780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C50788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5078C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C50790: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50794: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50798: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5079C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C507A0: 40990008  ble cr6, 0x82c507a8
	if !ctx.cr[6].gt {
	pc = 0x82C507A8; continue 'dispatch;
	}
	// 82C507A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C507A8: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82C507AC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C507B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C507B4: 40990008  ble cr6, 0x82c507bc
	if !ctx.cr[6].gt {
	pc = 0x82C507BC; continue 'dispatch;
	}
	// 82C507B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C507BC: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C507C0: 419A00B8  beq cr6, 0x82c50878
	if ctx.cr[6].eq {
	pc = 0x82C50878; continue 'dispatch;
	}
	// 82C507C4: 41980008  blt cr6, 0x82c507cc
	if ctx.cr[6].lt {
	pc = 0x82C507CC; continue 'dispatch;
	}
	// 82C507C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C507CC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C507D0: C1A80004  lfs f13, 4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C507D4: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C507D8: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 82C507DC: 40980084  bge cr6, 0x82c50860
	if !ctx.cr[6].lt {
	pc = 0x82C50860; continue 'dispatch;
	}
	// 82C507E0: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C507E4: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82C507E8: 396B004C  addi r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 + 76;
	// 82C507EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C507F0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C507F4: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82C507F8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C507FC: 4198000C  blt cr6, 0x82c50808
	if ctx.cr[6].lt {
	pc = 0x82C50808; continue 'dispatch;
	}
	// 82C50800: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C50804: 48000040  b 0x82c50844
	pc = 0x82C50844; continue 'dispatch;
	// 82C50808: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 82C5080C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C50810: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82C50814: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C50818: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82C5081C: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C50820: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82C50824: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C50828: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 82C5082C: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82C50830: FCA04018  frsp f5, f8
	ctx.f[5].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82C50834: ECCC0028  fsubs f6, f12, f0
	ctx.f[6].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C50838: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82C5083C: EC872824  fdivs f4, f7, f5
	ctx.f[4].f64 = ((ctx.f[7].f64 / ctx.f[5].f64) as f32) as f64;
	// 82C50840: EC0401BA  fmadds f0, f4, f6, f0
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[6].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C50844: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C50848: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82C5084C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C50850: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C50854: 409A0008  bne cr6, 0x82c5085c
	if !ctx.cr[6].eq {
	pc = 0x82C5085C; continue 'dispatch;
	}
	// 82C50858: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C5085C: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C50860: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C50864: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C50868: 41980008  blt cr6, 0x82c50870
	if ctx.cr[6].lt {
	pc = 0x82C50870; continue 'dispatch;
	}
	// 82C5086C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C50870: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 82C50874: 4BFFFF38  b 0x82c507ac
	pc = 0x82C507AC; continue 'dispatch;
	// 82C50878: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5087C: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82C50880: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C50884: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C50888: 40990008  ble cr6, 0x82c50890
	if !ctx.cr[6].gt {
	pc = 0x82C50890; continue 'dispatch;
	}
	// 82C5088C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C50890: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C50894: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50898: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5089C: 40990008  ble cr6, 0x82c508a4
	if !ctx.cr[6].gt {
	pc = 0x82C508A4; continue 'dispatch;
	}
	// 82C508A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C508A4: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C508A8: 419A0008  beq cr6, 0x82c508b0
	if ctx.cr[6].eq {
	pc = 0x82C508B0; continue 'dispatch;
	}
	// 82C508AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C508B0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C508B4: 419A0038  beq cr6, 0x82c508ec
	if ctx.cr[6].eq {
	pc = 0x82C508EC; continue 'dispatch;
	}
	// 82C508B8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C508BC: 41980008  blt cr6, 0x82c508c4
	if ctx.cr[6].lt {
	pc = 0x82C508C4; continue 'dispatch;
	}
	// 82C508C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C508C4: C03F0008  lfs f1, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C508C8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C508CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C508D0: 4BFB5479  bl 0x82c05d48
	ctx.lr = 0x82C508D4;
	sub_82C05D48(ctx, base);
	// 82C508D4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C508D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C508DC: 41980008  blt cr6, 0x82c508e4
	if ctx.cr[6].lt {
	pc = 0x82C508E4; continue 'dispatch;
	}
	// 82C508E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C508E4: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C508E8: 4BFFFFA8  b 0x82c50890
	pc = 0x82C50890; continue 'dispatch;
	// 82C508EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C508F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C508F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C508F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C508FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C50900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C50908 size=756
    let mut pc: u32 = 0x82C50908;
    'dispatch: loop {
        match pc {
            0x82C50908 => {
    //   block [0x82C50908..0x82C50BFC)
	// 82C50908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5090C: 48058AF1  bl 0x82ca93fc
	ctx.lr = 0x82C50910;
	sub_82CA93D0(ctx, base);
	// 82C50910: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C50918: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5091C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C50920: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 82C50924: 388BCBB8  addi r4, r11, -0x3448
	ctx.r[4].s64 = ctx.r[11].s64 + -13384;
	// 82C50928: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5092C: 4BFB687D  bl 0x82c071a8
	ctx.lr = 0x82C50930;
	sub_82C071A8(ctx, base);
	// 82C50930: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50934: 3B80000C  li r28, 0xc
	ctx.r[28].s64 = 12;
	// 82C50938: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82C5093C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C50940: 409A000C  bne cr6, 0x82c5094c
	if !ctx.cr[6].eq {
	pc = 0x82C5094C; continue 'dispatch;
	}
	// 82C50944: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82C50948: 48000014  b 0x82c5095c
	pc = 0x82C5095C; continue 'dispatch;
	// 82C5094C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C50950: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C50954: 7D09E3D6  divw r8, r9, r28
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	// 82C50958: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C5095C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C50960: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C50964: 388BCBA4  addi r4, r11, -0x345c
	ctx.r[4].s64 = ctx.r[11].s64 + -13404;
	// 82C50968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5096C: 4BFB683D  bl 0x82c071a8
	ctx.lr = 0x82C50970;
	sub_82C071A8(ctx, base);
	// 82C50970: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C50974: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50978: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5097C: 40990008  ble cr6, 0x82c50984
	if !ctx.cr[6].gt {
	pc = 0x82C50984; continue 'dispatch;
	}
	// 82C50980: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C50984: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50988: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5098C: 40990008  ble cr6, 0x82c50994
	if !ctx.cr[6].gt {
	pc = 0x82C50994; continue 'dispatch;
	}
	// 82C50990: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C50994: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C50998: 419A0030  beq cr6, 0x82c509c8
	if ctx.cr[6].eq {
	pc = 0x82C509C8; continue 'dispatch;
	}
	// 82C5099C: 41980008  blt cr6, 0x82c509a4
	if ctx.cr[6].lt {
	pc = 0x82C509A4; continue 'dispatch;
	}
	// 82C509A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C509A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C509A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C509AC: 4BFFF29D  bl 0x82c4fc48
	ctx.lr = 0x82C509B0;
	sub_82C4FC48(ctx, base);
	// 82C509B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C509B4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C509B8: 41980008  blt cr6, 0x82c509c0
	if ctx.cr[6].lt {
	pc = 0x82C509C0; continue 'dispatch;
	}
	// 82C509BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C509C0: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82C509C4: 4BFFFFC0  b 0x82c50984
	pc = 0x82C50984; continue 'dispatch;
	// 82C509C8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C509CC: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82C509D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C509D4: 409A000C  bne cr6, 0x82c509e0
	if !ctx.cr[6].eq {
	pc = 0x82C509E0; continue 'dispatch;
	}
	// 82C509D8: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82C509DC: 48000014  b 0x82c509f0
	pc = 0x82C509F0; continue 'dispatch;
	// 82C509E0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C509E4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C509E8: 7D09E3D6  divw r8, r9, r28
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	// 82C509EC: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82C509F0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C509F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C509F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C509FC: 388ACB94  addi r4, r10, -0x346c
	ctx.r[4].s64 = ctx.r[10].s64 + -13420;
	// 82C50A00: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C50A04: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C50A08: 4E800421  bctrl
	ctx.lr = 0x82C50A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C50A0C: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50A10: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C50A14: 419A0030  beq cr6, 0x82c50a44
	if ctx.cr[6].eq {
	pc = 0x82C50A44; continue 'dispatch;
	}
	// 82C50A18: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C50A1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50A20: 4BFCB3A9  bl 0x82c1bdc8
	ctx.lr = 0x82C50A24;
	sub_82C1BDC8(ctx, base);
	// 82C50A24: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C50A2C: 419A0018  beq cr6, 0x82c50a44
	if ctx.cr[6].eq {
	pc = 0x82C50A44; continue 'dispatch;
	}
	// 82C50A30: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50A34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50A38: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C50A3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C50A40: 4E800421  bctrl
	ctx.lr = 0x82C50A44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C50A44: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50A48: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C50A4C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C50A50: 40990008  ble cr6, 0x82c50a58
	if !ctx.cr[6].gt {
	pc = 0x82C50A58; continue 'dispatch;
	}
	// 82C50A54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C50A58: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C50A5C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82C50A60: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C50A64: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C50A68: 3B8BD838  addi r28, r11, -0x27c8
	ctx.r[28].s64 = ctx.r[11].s64 + -10184;
	// 82C50A6C: 3B6ACB80  addi r27, r10, -0x3480
	ctx.r[27].s64 = ctx.r[10].s64 + -13440;
	// 82C50A70: 3B49CB88  addi r26, r9, -0x3478
	ctx.r[26].s64 = ctx.r[9].s64 + -13432;
	// 82C50A74: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C50A78: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50A7C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C50A80: 40990008  ble cr6, 0x82c50a88
	if !ctx.cr[6].gt {
	pc = 0x82C50A88; continue 'dispatch;
	}
	// 82C50A84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C50A88: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C50A8C: 419A0008  beq cr6, 0x82c50a94
	if ctx.cr[6].eq {
	pc = 0x82C50A94; continue 'dispatch;
	}
	// 82C50A90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C50A94: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C50A98: 419A0158  beq cr6, 0x82c50bf0
	if ctx.cr[6].eq {
	pc = 0x82C50BF0; continue 'dispatch;
	}
	// 82C50A9C: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C50AA0: 41980008  blt cr6, 0x82c50aa8
	if ctx.cr[6].lt {
	pc = 0x82C50AA8; continue 'dispatch;
	}
	// 82C50AA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C50AA8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50AAC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C50AB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50AB4: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C50AB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C50ABC: 4E800421  bctrl
	ctx.lr = 0x82C50AC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C50AC0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50AC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C50AC8: 419A0040  beq cr6, 0x82c50b08
	if ctx.cr[6].eq {
	pc = 0x82C50B08; continue 'dispatch;
	}
	// 82C50ACC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C50AD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50AD4: 4BFCB2F5  bl 0x82c1bdc8
	ctx.lr = 0x82C50AD8;
	sub_82C1BDC8(ctx, base);
	// 82C50AD8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50ADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C50AE0: 419A0028  beq cr6, 0x82c50b08
	if ctx.cr[6].eq {
	pc = 0x82C50B08; continue 'dispatch;
	}
	// 82C50AE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50AE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50AEC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C50AF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C50AF4: 4E800421  bctrl
	ctx.lr = 0x82C50AF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C50AF8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50AFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C50B00: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C50B04: 409A0008  bne cr6, 0x82c50b0c
	if !ctx.cr[6].eq {
	pc = 0x82C50B0C; continue 'dispatch;
	}
	// 82C50B08: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C50B0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C50B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C50B14: 419A00C4  beq cr6, 0x82c50bd8
	if ctx.cr[6].eq {
	pc = 0x82C50BD8; continue 'dispatch;
	}
	// 82C50B18: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50B1C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C50B20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50B24: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C50B28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C50B2C: 4E800421  bctrl
	ctx.lr = 0x82C50B30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C50B30: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50B34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C50B38: 419A0040  beq cr6, 0x82c50b78
	if ctx.cr[6].eq {
	pc = 0x82C50B78; continue 'dispatch;
	}
	// 82C50B3C: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82C50B40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50B44: 4BFCB285  bl 0x82c1bdc8
	ctx.lr = 0x82C50B48;
	sub_82C1BDC8(ctx, base);
	// 82C50B48: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C50B50: 419A0028  beq cr6, 0x82c50b78
	if ctx.cr[6].eq {
	pc = 0x82C50B78; continue 'dispatch;
	}
	// 82C50B54: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50B58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50B5C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C50B60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C50B64: 4E800421  bctrl
	ctx.lr = 0x82C50B68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C50B68: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50B6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C50B70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C50B74: 409A0008  bne cr6, 0x82c50b7c
	if !ctx.cr[6].eq {
	pc = 0x82C50B7C; continue 'dispatch;
	}
	// 82C50B78: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C50B7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C50B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C50B84: 419A0054  beq cr6, 0x82c50bd8
	if ctx.cr[6].eq {
	pc = 0x82C50BD8; continue 'dispatch;
	}
	// 82C50B88: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50B8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C50B90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50B94: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C50B98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C50B9C: 4E800421  bctrl
	ctx.lr = 0x82C50BA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C50BA0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50BA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C50BA8: 419A0030  beq cr6, 0x82c50bd8
	if ctx.cr[6].eq {
	pc = 0x82C50BD8; continue 'dispatch;
	}
	// 82C50BAC: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 82C50BB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50BB4: 4BFB6565  bl 0x82c07118
	ctx.lr = 0x82C50BB8;
	sub_82C07118(ctx, base);
	// 82C50BB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C50BBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C50BC0: 419A0018  beq cr6, 0x82c50bd8
	if ctx.cr[6].eq {
	pc = 0x82C50BD8; continue 'dispatch;
	}
	// 82C50BC4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50BC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C50BCC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C50BD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C50BD4: 4E800421  bctrl
	ctx.lr = 0x82C50BD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C50BD8: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C50BDC: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C50BE0: 41980008  blt cr6, 0x82c50be8
	if ctx.cr[6].lt {
	pc = 0x82C50BE8; continue 'dispatch;
	}
	// 82C50BE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C50BE8: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C50BEC: 4BFFFE88  b 0x82c50a74
	pc = 0x82C50A74; continue 'dispatch;
	// 82C50BF0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C50BF4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C50BF8: 48058854  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C50C00 size=124
    let mut pc: u32 = 0x82C50C00;
    'dispatch: loop {
        match pc {
            0x82C50C00 => {
    //   block [0x82C50C00..0x82C50C7C)
	// 82C50C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C50C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C50C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C50C10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50C14: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82C50C18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C50C1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C50C20: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82C50C24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C50C28: 4BFFF2A9  bl 0x82c4fed0
	ctx.lr = 0x82C50C2C;
	sub_82C4FED0(ctx, base);
	// 82C50C2C: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C50C30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C50C34: 419A0018  beq cr6, 0x82c50c4c
	if ctx.cr[6].eq {
	pc = 0x82C50C4C; continue 'dispatch;
	}
	// 82C50C38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50C3C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C50C40: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C50C44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C50C48: 409A000C  bne cr6, 0x82c50c54
	if !ctx.cr[6].eq {
	pc = 0x82C50C54; continue 'dispatch;
	}
	// 82C50C4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C50C50: 48000014  b 0x82c50c64
	pc = 0x82C50C64; continue 'dispatch;
	// 82C50C54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C50C58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C50C5C: 4BFFFB25  bl 0x82c50780
	ctx.lr = 0x82C50C60;
	sub_82C50780(ctx, base);
	// 82C50C60: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C50C64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C50C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C50C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C50C70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C50C74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C50C78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C50C80 size=100
    let mut pc: u32 = 0x82C50C80;
    'dispatch: loop {
        match pc {
            0x82C50C80 => {
    //   block [0x82C50C80..0x82C50CE4)
	// 82C50C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C50C88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C50C8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50C90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C50C94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C50C98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C50C9C: 392BB820  addi r9, r11, -0x47e0
	ctx.r[9].s64 = ctx.r[11].s64 + -18400;
	// 82C50CA0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C50CA4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C50CA8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C50CAC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C50CB0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C50CB4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C50CB8: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C50CBC: 4BFE361D  bl 0x82c342d8
	ctx.lr = 0x82C50CC0;
	sub_82C342D8(ctx, base);
	// 82C50CC0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C50CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C50CC8: 38E8CBC4  addi r7, r8, -0x343c
	ctx.r[7].s64 = ctx.r[8].s64 + -13372;
	// 82C50CCC: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82C50CD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C50CD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C50CD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C50CDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C50CE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C50CE8 size=100
    let mut pc: u32 = 0x82C50CE8;
    'dispatch: loop {
        match pc {
            0x82C50CE8 => {
    //   block [0x82C50CE8..0x82C50D4C)
	// 82C50CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50CEC: 4805871D  bl 0x82ca9408
	ctx.lr = 0x82C50CF0;
	sub_82CA93D0(ctx, base);
	// 82C50CF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50CF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C50CF8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C50CFC: 7FFE2050  subf r31, r30, r4
	ctx.r[31].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82C50D00: 7FEB1670  srawi r11, r31, 2
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 2) as i64;
	// 82C50D04: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C50D08: 4099003C  ble cr6, 0x82c50d44
	if !ctx.cr[6].gt {
	pc = 0x82C50D44; continue 'dispatch;
	}
	// 82C50D0C: 3BBEFFFC  addi r29, r30, -4
	ctx.r[29].s64 = ctx.r[30].s64 + -4;
	// 82C50D10: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C50D14: 395FFFFC  addi r10, r31, -4
	ctx.r[10].s64 = ctx.r[31].s64 + -4;
	// 82C50D18: 7CDDF82E  lwzx r6, r29, r31
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82C50D1C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82C50D20: 7D451670  srawi r5, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82C50D24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C50D28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C50D2C: 7D7DF92E  stwx r11, r29, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 82C50D30: 4BFFF249  bl 0x82c4ff78
	ctx.lr = 0x82C50D34;
	sub_82C4FF78(ctx, base);
	// 82C50D34: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82C50D38: 7FEB1670  srawi r11, r31, 2
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 2) as i64;
	// 82C50D3C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C50D40: 4199FFD0  bgt cr6, 0x82c50d10
	if ctx.cr[6].gt {
	pc = 0x82C50D10; continue 'dispatch;
	}
	// 82C50D44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C50D48: 48058710  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C50D50 size=288
    let mut pc: u32 = 0x82C50D50;
    'dispatch: loop {
        match pc {
            0x82C50D50 => {
    //   block [0x82C50D50..0x82C50E70)
	// 82C50D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50D54: 480586AD  bl 0x82ca9400
	ctx.lr = 0x82C50D58;
	sub_82CA93D0(ctx, base);
	// 82C50D58: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50D5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C50D60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C50D64: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C50D68: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 82C50D6C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C50D70: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82C50D74: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82C50D78: 40990090  ble cr6, 0x82c50e08
	if !ctx.cr[6].gt {
	pc = 0x82C50E08; continue 'dispatch;
	}
	// 82C50D7C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C50D80: 409900A8  ble cr6, 0x82c50e28
	if !ctx.cr[6].gt {
	pc = 0x82C50E28; continue 'dispatch;
	}
	// 82C50D84: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C50D88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C50D8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C50D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C50D94: 4BFFF6D5  bl 0x82c50468
	ctx.lr = 0x82C50D98;
	sub_82C50468(ctx, base);
	// 82C50D98: 7FAB0E70  srawi r11, r29, 1
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[29].s32 >> 1) as i64;
	// 82C50D9C: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82C50DA0: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82C50DA4: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82C50DA8: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C50DAC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C50DB0: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C50DB4: 83410050  lwz r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C50DB8: 7D3BF850  subf r9, r27, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82C50DBC: 7D1ED050  subf r8, r30, r26
	ctx.r[8].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 82C50DC0: 5527003A  rlwinm r7, r9, 0, 0, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82C50DC4: 5506003A  rlwinm r6, r8, 0, 0, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82C50DC8: 7F063800  cmpw cr6, r6, r7
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82C50DCC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C50DD0: 40980018  bge cr6, 0x82c50de8
	if !ctx.cr[6].lt {
	pc = 0x82C50DE8; continue 'dispatch;
	}
	// 82C50DD4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C50DD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C50DDC: 4BFFFF75  bl 0x82c50d50
	ctx.lr = 0x82C50DE0;
	sub_82C50D50(ctx, base);
	// 82C50DE0: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82C50DE4: 48000014  b 0x82c50df8
	pc = 0x82C50DF8; continue 'dispatch;
	// 82C50DE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C50DEC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C50DF0: 4BFFFF61  bl 0x82c50d50
	ctx.lr = 0x82C50DF4;
	sub_82C50D50(ctx, base);
	// 82C50DF4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82C50DF8: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 82C50DFC: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82C50E00: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82C50E04: 4199FF78  bgt cr6, 0x82c50d7c
	if ctx.cr[6].gt {
	pc = 0x82C50D7C; continue 'dispatch;
	}
	// 82C50E08: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C50E0C: 40990014  ble cr6, 0x82c50e20
	if !ctx.cr[6].gt {
	pc = 0x82C50E20; continue 'dispatch;
	}
	// 82C50E10: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C50E14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C50E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C50E1C: 4BFFF89D  bl 0x82c506b8
	ctx.lr = 0x82C50E20;
	sub_82C506B8(ctx, base);
	// 82C50E20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C50E24: 4805862C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 82C50E28: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82C50E2C: 4099FFDC  ble cr6, 0x82c50e08
	if !ctx.cr[6].gt {
	pc = 0x82C50E08; continue 'dispatch;
	}
	// 82C50E30: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 82C50E34: 556A003A  rlwinm r10, r11, 0, 0, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C50E38: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 82C50E3C: 4099001C  ble cr6, 0x82c50e58
	if !ctx.cr[6].gt {
	pc = 0x82C50E58; continue 'dispatch;
	}
	// 82C50E40: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82C50E44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C50E48: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C50E4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C50E50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C50E54: 4BFFF4ED  bl 0x82c50340
	ctx.lr = 0x82C50E58;
	sub_82C50340(ctx, base);
	// 82C50E58: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C50E5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C50E60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C50E64: 4BFFFE85  bl 0x82c50ce8
	ctx.lr = 0x82C50E68;
	sub_82C50CE8(ctx, base);
	// 82C50E68: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C50E6C: 480585E4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C50E70 size=204
    let mut pc: u32 = 0x82C50E70;
    'dispatch: loop {
        match pc {
            0x82C50E70 => {
    //   block [0x82C50E70..0x82C50F3C)
	// 82C50E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50E74: 4805858D  bl 0x82ca9400
	ctx.lr = 0x82C50E78;
	sub_82CA93D0(ctx, base);
	// 82C50E78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50E7C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C50E80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C50E84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C50E88: 392BCBC4  addi r9, r11, -0x343c
	ctx.r[9].s64 = ctx.r[11].s64 + -13372;
	// 82C50E8C: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82C50E90: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C50E94: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C50E98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C50E9C: 40990070  ble cr6, 0x82c50f0c
	if !ctx.cr[6].gt {
	pc = 0x82C50F0C; continue 'dispatch;
	}
	// 82C50EA0: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82C50EA4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50EA8: 7FEBD82E  lwzx r31, r11, r27
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82C50EAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C50EB0: 419A0048  beq cr6, 0x82c50ef8
	if ctx.cr[6].eq {
	pc = 0x82C50EF8; continue 'dispatch;
	}
	// 82C50EB4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C50EB8: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82C50EBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C50EC0: 419A0008  beq cr6, 0x82c50ec8
	if ctx.cr[6].eq {
	pc = 0x82C50EC8; continue 'dispatch;
	}
	// 82C50EC4: 4BBF48ED  bl 0x828457b0
	ctx.lr = 0x82C50EC8;
	sub_828457B0(ctx, base);
	// 82C50EC8: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C50ECC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C50ED0: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C50ED4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50ED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C50EDC: 419A0008  beq cr6, 0x82c50ee4
	if ctx.cr[6].eq {
	pc = 0x82C50EE4; continue 'dispatch;
	}
	// 82C50EE0: 4BBF48D1  bl 0x828457b0
	ctx.lr = 0x82C50EE4;
	sub_828457B0(ctx, base);
	// 82C50EE4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C50EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C50EEC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C50EF0: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C50EF4: 4BBF48BD  bl 0x828457b0
	ctx.lr = 0x82C50EF8;
	sub_828457B0(ctx, base);
	// 82C50EF8: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C50EFC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82C50F00: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82C50F04: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C50F08: 4198FF9C  blt cr6, 0x82c50ea4
	if ctx.cr[6].lt {
	pc = 0x82C50EA4; continue 'dispatch;
	}
	// 82C50F0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C50F10: 93BC000C  stw r29, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C50F14: 394BB820  addi r10, r11, -0x47e0
	ctx.r[10].s64 = ctx.r[11].s64 + -18400;
	// 82C50F18: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50F1C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50F20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C50F24: 419A0010  beq cr6, 0x82c50f34
	if ctx.cr[6].eq {
	pc = 0x82C50F34; continue 'dispatch;
	}
	// 82C50F28: 4BBF4889  bl 0x828457b0
	ctx.lr = 0x82C50F2C;
	sub_828457B0(ctx, base);
	// 82C50F2C: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C50F30: 93BC000C  stw r29, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C50F34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C50F38: 48058518  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C50F40 size=80
    let mut pc: u32 = 0x82C50F40;
    'dispatch: loop {
        match pc {
            0x82C50F40 => {
    //   block [0x82C50F40..0x82C50F90)
	// 82C50F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C50F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C50F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C50F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50F54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C50F58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C50F5C: 4BFFFF15  bl 0x82c50e70
	ctx.lr = 0x82C50F60;
	sub_82C50E70(ctx, base);
	// 82C50F60: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C50F64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C50F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C50F6C: 419A000C  beq cr6, 0x82c50f78
	if ctx.cr[6].eq {
	pc = 0x82C50F78; continue 'dispatch;
	}
	// 82C50F70: 4BBF4841  bl 0x828457b0
	ctx.lr = 0x82C50F74;
	sub_828457B0(ctx, base);
	// 82C50F74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C50F78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C50F7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C50F80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C50F84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C50F88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C50F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C50F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C50F90 size=208
    let mut pc: u32 = 0x82C50F90;
    'dispatch: loop {
        match pc {
            0x82C50F90 => {
    //   block [0x82C50F90..0x82C51060)
	// 82C50F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C50F94: 4805846D  bl 0x82ca9400
	ctx.lr = 0x82C50F98;
	sub_82CA93D0(ctx, base);
	// 82C50F98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C50F9C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C50FA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C50FA4: 394BCB90  addi r10, r11, -0x3470
	ctx.r[10].s64 = ctx.r[11].s64 + -13424;
	// 82C50FA8: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C50FAC: 4BFD9E5D  bl 0x82c2ae08
	ctx.lr = 0x82C50FB0;
	sub_82C2AE08(ctx, base);
	// 82C50FB0: 813C000C  lwz r9, 0xc(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C50FB4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C50FB8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C50FBC: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82C50FC0: 40990070  ble cr6, 0x82c51030
	if !ctx.cr[6].gt {
	pc = 0x82C51030; continue 'dispatch;
	}
	// 82C50FC4: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82C50FC8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50FCC: 7FEBD82E  lwzx r31, r11, r27
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82C50FD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C50FD4: 419A0048  beq cr6, 0x82c5101c
	if ctx.cr[6].eq {
	pc = 0x82C5101C; continue 'dispatch;
	}
	// 82C50FD8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C50FDC: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82C50FE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C50FE4: 419A0008  beq cr6, 0x82c50fec
	if ctx.cr[6].eq {
	pc = 0x82C50FEC; continue 'dispatch;
	}
	// 82C50FE8: 4BBF47C9  bl 0x828457b0
	ctx.lr = 0x82C50FEC;
	sub_828457B0(ctx, base);
	// 82C50FEC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C50FF0: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C50FF4: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C50FF8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C50FFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C51000: 419A0008  beq cr6, 0x82c51008
	if ctx.cr[6].eq {
	pc = 0x82C51008; continue 'dispatch;
	}
	// 82C51004: 4BBF47AD  bl 0x828457b0
	ctx.lr = 0x82C51008;
	sub_828457B0(ctx, base);
	// 82C51008: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C5100C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51010: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C51014: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C51018: 4BBF4799  bl 0x828457b0
	ctx.lr = 0x82C5101C;
	sub_828457B0(ctx, base);
	// 82C5101C: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C51020: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82C51024: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82C51028: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5102C: 4198FF9C  blt cr6, 0x82c50fc8
	if ctx.cr[6].lt {
	pc = 0x82C50FC8; continue 'dispatch;
	}
	// 82C51030: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C51034: 93BC000C  stw r29, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C51038: 394BB008  addi r10, r11, -0x4ff8
	ctx.r[10].s64 = ctx.r[11].s64 + -20472;
	// 82C5103C: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C51040: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C51044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C51048: 419A0010  beq cr6, 0x82c51058
	if ctx.cr[6].eq {
	pc = 0x82C51058; continue 'dispatch;
	}
	// 82C5104C: 4BBF4765  bl 0x828457b0
	ctx.lr = 0x82C51050;
	sub_828457B0(ctx, base);
	// 82C51050: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C51054: 93BC000C  stw r29, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C51058: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C5105C: 480583F4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C51060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C51060 size=80
    let mut pc: u32 = 0x82C51060;
    'dispatch: loop {
        match pc {
            0x82C51060 => {
    //   block [0x82C51060..0x82C510B0)
	// 82C51060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C51064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C51068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5106C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C51070: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51078: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C5107C: 4BFFFF15  bl 0x82c50f90
	ctx.lr = 0x82C51080;
	sub_82C50F90(ctx, base);
	// 82C51080: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C51084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C5108C: 419A000C  beq cr6, 0x82c51098
	if ctx.cr[6].eq {
	pc = 0x82C51098; continue 'dispatch;
	}
	// 82C51090: 4BBF4721  bl 0x828457b0
	ctx.lr = 0x82C51094;
	sub_828457B0(ctx, base);
	// 82C51094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51098: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5109C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C510A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C510A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C510A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C510AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C510B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C510B0 size=292
    let mut pc: u32 = 0x82C510B0;
    'dispatch: loop {
        match pc {
            0x82C510B0 => {
    //   block [0x82C510B0..0x82C511D4)
	// 82C510B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C510B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C510B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C510BC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C510C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C510C4: F8A100A0  std r5, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u64 ) };
	// 82C510C8: F8C100A8  std r6, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[6].u64 ) };
	// 82C510CC: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82C510D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C510D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C510D8: 409A000C  bne cr6, 0x82c510e4
	if !ctx.cr[6].eq {
	pc = 0x82C510E4; continue 'dispatch;
	}
	// 82C510DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C510E0: 48000010  b 0x82c510f0
	pc = 0x82C510F0; continue 'dispatch;
	// 82C510E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C510E8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C510EC: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82C510F0: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C510F4: 40980060  bge cr6, 0x82c51154
	if !ctx.cr[6].lt {
	pc = 0x82C51154; continue 'dispatch;
	}
	// 82C510F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C510FC: 409A000C  bne cr6, 0x82c51108
	if !ctx.cr[6].eq {
	pc = 0x82C51108; continue 'dispatch;
	}
	// 82C51100: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C51104: 48000010  b 0x82c51114
	pc = 0x82C51114; continue 'dispatch;
	// 82C51108: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5110C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C51110: 7D284BD6  divw r9, r8, r9
	ctx.r[9].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82C51114: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51118: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C5111C: 40990008  ble cr6, 0x82c51124
	if !ctx.cr[6].gt {
	pc = 0x82C51124; continue 'dispatch;
	}
	// 82C51120: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C51124: 7CA92050  subf r5, r9, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82C51128: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C5112C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82C51130: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C51134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51138: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C5113C: 48019F4D  bl 0x82c6b088
	ctx.lr = 0x82C51140;
	sub_82C6B088(ctx, base);
	// 82C51140: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C51144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C51148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5114C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C51150: 4E800020  blr
	return;
	// 82C51154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51158: 419A0068  beq cr6, 0x82c511c0
	if ctx.cr[6].eq {
	pc = 0x82C511C0; continue 'dispatch;
	}
	// 82C5115C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51160: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C51164: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82C51168: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C5116C: 40980054  bge cr6, 0x82c511c0
	if !ctx.cr[6].lt {
	pc = 0x82C511C0; continue 'dispatch;
	}
	// 82C51170: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C51174: 40990008  ble cr6, 0x82c5117c
	if !ctx.cr[6].gt {
	pc = 0x82C5117C; continue 'dispatch;
	}
	// 82C51178: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C5117C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C51180: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C51184: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82C51188: 40990008  ble cr6, 0x82c51190
	if !ctx.cr[6].gt {
	pc = 0x82C51190; continue 'dispatch;
	}
	// 82C5118C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C51190: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C51194: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82C51198: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C5119C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C511A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C511A4: 4BFF145D  bl 0x82c42600
	ctx.lr = 0x82C511A8;
	sub_82C42600(ctx, base);
	// 82C511A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C511AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C511B0: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C511B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C511B8: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82C511BC: 4BEF5B95  bl 0x82b46d50
	ctx.lr = 0x82C511C0;
	sub_82B46D50(ctx, base);
	// 82C511C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C511C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C511C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C511CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C511D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C511D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C511D8 size=108
    let mut pc: u32 = 0x82C511D8;
    'dispatch: loop {
        match pc {
            0x82C511D8 => {
    //   block [0x82C511D8..0x82C51244)
	// 82C511D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C511DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C511E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C511E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C511E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C511EC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C511F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C511F4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C511F8: 4BFE30E1  bl 0x82c342d8
	ctx.lr = 0x82C511FC;
	sub_82C342D8(ctx, base);
	// 82C511FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51204: 419A002C  beq cr6, 0x82c51230
	if ctx.cr[6].eq {
	pc = 0x82C51230; continue 'dispatch;
	}
	// 82C51208: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C5120C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51210: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C51214: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C51218: 7C8B1A14  add r4, r11, r3
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C5121C: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82C51220: 7D032050  subf r8, r3, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C51224: 7D051670  srawi r5, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82C51228: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C5122C: 4BFFFB25  bl 0x82c50d50
	ctx.lr = 0x82C51230;
	sub_82C50D50(ctx, base);
	// 82C51230: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C51234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C51238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5123C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C51240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C51248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C51248 size=496
    let mut pc: u32 = 0x82C51248;
    'dispatch: loop {
        match pc {
            0x82C51248 => {
    //   block [0x82C51248..0x82C51438)
	// 82C51248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5124C: 480581B5  bl 0x82ca9400
	ctx.lr = 0x82C51250;
	sub_82CA93D0(ctx, base);
	// 82C51250: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51254: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C51258: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C5125C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C51260: 3BFC0020  addi r31, r28, 0x20
	ctx.r[31].s64 = ctx.r[28].s64 + 32;
	// 82C51264: 388BCBB8  addi r4, r11, -0x3448
	ctx.r[4].s64 = ctx.r[11].s64 + -13384;
	// 82C51268: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C5126C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51270: 4BFB5F39  bl 0x82c071a8
	ctx.lr = 0x82C51274;
	sub_82C071A8(ctx, base);
	// 82C51274: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51278: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5127C: 409A0050  bne cr6, 0x82c512cc
	if !ctx.cr[6].eq {
	pc = 0x82C512CC; continue 'dispatch;
	}
	// 82C51280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C51284: 4B5A657D  bl 0x821f7800
	ctx.lr = 0x82C51288;
	sub_821F7800(ctx, base);
	// 82C51288: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5128C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C51290: 388BCBC8  addi r4, r11, -0x3438
	ctx.r[4].s64 = ctx.r[11].s64 + -13368;
	// 82C51294: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51298: 4BFCA021  bl 0x82c1b2b8
	ctx.lr = 0x82C5129C;
	sub_82C1B2B8(ctx, base);
	// 82C5129C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C512A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C512A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C512A8: 409A0014  bne cr6, 0x82c512bc
	if !ctx.cr[6].eq {
	pc = 0x82C512BC; continue 'dispatch;
	}
	// 82C512AC: 4B5C3B2D  bl 0x82214dd8
	ctx.lr = 0x82C512B0;
	sub_82214DD8(ctx, base);
	// 82C512B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C512B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C512B8: 48058198  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 82C512BC: 4B63971D  bl 0x8228a9d8
	ctx.lr = 0x82C512C0;
	sub_8228A9D8(ctx, base);
	// 82C512C0: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C512C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C512C8: 4B5C3B11  bl 0x82214dd8
	ctx.lr = 0x82C512CC;
	sub_82214DD8(ctx, base);
	// 82C512CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C512D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C512D4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C512D8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82C512DC: 388BCBA4  addi r4, r11, -0x345c
	ctx.r[4].s64 = ctx.r[11].s64 + -13404;
	// 82C512E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C512E4: 4BFB5EC5  bl 0x82c071a8
	ctx.lr = 0x82C512E8;
	sub_82C071A8(ctx, base);
	// 82C512E8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C512EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C512F0: 419AFFC0  beq cr6, 0x82c512b0
	if ctx.cr[6].eq {
	pc = 0x82C512B0; continue 'dispatch;
	}
	// 82C512F4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82C512F8: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C512FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C51300: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82C51304: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C51308: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C5130C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C51310: 794607E6  rldicr r6, r10, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82C51314: 4BFFFD9D  bl 0x82c510b0
	ctx.lr = 0x82C51318;
	sub_82C510B0(ctx, base);
	// 82C51318: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5131C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82C51320: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 82C51324: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C51328: 419A0058  beq cr6, 0x82c51380
	if ctx.cr[6].eq {
	pc = 0x82C51380; continue 'dispatch;
	}
	// 82C5132C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C51330: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C51334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51338: 419A0018  beq cr6, 0x82c51350
	if ctx.cr[6].eq {
	pc = 0x82C51350; continue 'dispatch;
	}
	// 82C5133C: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51340: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C51344: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 82C51348: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C5134C: 41980008  blt cr6, 0x82c51354
	if ctx.cr[6].lt {
	pc = 0x82C51354; continue 'dispatch;
	}
	// 82C51350: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C51354: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82C51358: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C5135C: 4BFFE8ED  bl 0x82c4fc48
	ctx.lr = 0x82C51360;
	sub_82C4FC48(ctx, base);
	// 82C51360: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51368: 419AFF48  beq cr6, 0x82c512b0
	if ctx.cr[6].eq {
	pc = 0x82C512B0; continue 'dispatch;
	}
	// 82C5136C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C51370: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C51374: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82C51378: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5137C: 4198FFB4  blt cr6, 0x82c51330
	if ctx.cr[6].lt {
	pc = 0x82C51330; continue 'dispatch;
	}
	// 82C51380: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C51384: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C51388: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82C5138C: 388BCB94  addi r4, r11, -0x346c
	ctx.r[4].s64 = ctx.r[11].s64 + -13420;
	// 82C51390: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51394: 4BFB5E15  bl 0x82c071a8
	ctx.lr = 0x82C51398;
	sub_82C071A8(ctx, base);
	// 82C51398: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C5139C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C513A0: 419AFF10  beq cr6, 0x82c512b0
	if ctx.cr[6].eq {
	pc = 0x82C512B0; continue 'dispatch;
	}
	// 82C513A4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82C513A8: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C513AC: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	// 82C513B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C513B4: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 82C513B8: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C513BC: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C513C0: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C513C4: 794607E6  rldicr r6, r10, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82C513C8: 4BFFFCE9  bl 0x82c510b0
	ctx.lr = 0x82C513CC;
	sub_82C510B0(ctx, base);
	// 82C513CC: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C513D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C513D4: 419A0058  beq cr6, 0x82c5142c
	if ctx.cr[6].eq {
	pc = 0x82C5142C; continue 'dispatch;
	}
	// 82C513D8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82C513DC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C513E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C513E4: 419A0018  beq cr6, 0x82c513fc
	if ctx.cr[6].eq {
	pc = 0x82C513FC; continue 'dispatch;
	}
	// 82C513E8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C513EC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C513F0: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 82C513F4: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C513F8: 41980008  blt cr6, 0x82c51400
	if ctx.cr[6].lt {
	pc = 0x82C51400; continue 'dispatch;
	}
	// 82C513FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82C51400: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C51404: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C51408: 4BFFE8E1  bl 0x82c4fce8
	ctx.lr = 0x82C5140C;
	sub_82C4FCE8(ctx, base);
	// 82C5140C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51414: 419AFE9C  beq cr6, 0x82c512b0
	if ctx.cr[6].eq {
	pc = 0x82C512B0; continue 'dispatch;
	}
	// 82C51418: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5141C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82C51420: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82C51424: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C51428: 4198FFB4  blt cr6, 0x82c513dc
	if ctx.cr[6].lt {
	pc = 0x82C513DC; continue 'dispatch;
	}
	// 82C5142C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C51430: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C51434: 4805801C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C51438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C51438 size=516
    let mut pc: u32 = 0x82C51438;
    'dispatch: loop {
        match pc {
            0x82C51438 => {
    //   block [0x82C51438..0x82C5163C)
	// 82C51438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5143C: 48057FC1  bl 0x82ca93fc
	ctx.lr = 0x82C51440;
	sub_82CA93D0(ctx, base);
	// 82C51440: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51444: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82C51448: 3B840004  addi r28, r4, 4
	ctx.r[28].s64 = ctx.r[4].s64 + 4;
	// 82C5144C: 3BB90004  addi r29, r25, 4
	ctx.r[29].s64 = ctx.r[25].s64 + 4;
	// 82C51450: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C51454: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C51458: 4BFE2E81  bl 0x82c342d8
	ctx.lr = 0x82C5145C;
	sub_82C342D8(ctx, base);
	// 82C5145C: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C51460: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C51464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51468: 419A0028  beq cr6, 0x82c51490
	if ctx.cr[6].eq {
	pc = 0x82C51490; continue 'dispatch;
	}
	// 82C5146C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C51470: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51474: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C51478: 7C8B1A14  add r4, r11, r3
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C5147C: 9B4A0000  stb r26, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C51480: 7D232050  subf r9, r3, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C51484: 7D251670  srawi r5, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82C51488: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C5148C: 4BFFF8C5  bl 0x82c50d50
	ctx.lr = 0x82C51490;
	sub_82C50D50(ctx, base);
	// 82C51490: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C51494: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82C51498: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C5149C: 4099009C  ble cr6, 0x82c51538
	if !ctx.cr[6].gt {
	pc = 0x82C51538; continue 'dispatch;
	}
	// 82C514A0: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82C514A4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C514A8: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C514AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C514B0: 83EBFFFC  lwz r31, -4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C514B4: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C514B8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C514BC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C514C0: 41990064  bgt cr6, 0x82c51524
	if ctx.cr[6].gt {
	pc = 0x82C51524; continue 'dispatch;
	}
	// 82C514C4: 41980060  blt cr6, 0x82c51524
	if ctx.cr[6].lt {
	pc = 0x82C51524; continue 'dispatch;
	}
	// 82C514C8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C514CC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C514D0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C514D4: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C514D8: 40980024  bge cr6, 0x82c514fc
	if !ctx.cr[6].lt {
	pc = 0x82C514FC; continue 'dispatch;
	}
	// 82C514DC: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C514E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C514E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C514E8: 40980008  bge cr6, 0x82c514f0
	if !ctx.cr[6].lt {
	pc = 0x82C514F0; continue 'dispatch;
	}
	// 82C514EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C514F0: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C514F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C514F8: 4BFD4DA9  bl 0x82c262a0
	ctx.lr = 0x82C514FC;
	sub_82C262A0(ctx, base);
	// 82C514FC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51500: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51504: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C51508: 7FE9512E  stwx r31, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 82C5150C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51510: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82C51514: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C51518: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5151C: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C51520: 9347FFFC  stw r26, -4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-4 as u32), ctx.r[26].u32 ) };
	// 82C51524: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C51528: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82C5152C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C51530: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C51534: 4198FF70  blt cr6, 0x82c514a4
	if ctx.cr[6].lt {
	pc = 0x82C514A4; continue 'dispatch;
	}
	// 82C51538: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5153C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82C51540: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82C51544: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C51548: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82C5154C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51550: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82C51554: 4099003C  ble cr6, 0x82c51590
	if !ctx.cr[6].gt {
	pc = 0x82C51590; continue 'dispatch;
	}
	// 82C51558: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82C5155C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82C51560: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51564: 7D49582E  lwzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C51568: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5156C: 419A0010  beq cr6, 0x82c5157c
	if ctx.cr[6].eq {
	pc = 0x82C5157C; continue 'dispatch;
	}
	// 82C51570: 7D48592E  stwx r10, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82C51574: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82C51578: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82C5157C: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C51580: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82C51584: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C51588: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5158C: 4198FFD4  blt cr6, 0x82c51560
	if ctx.cr[6].lt {
	pc = 0x82C51560; continue 'dispatch;
	}
	// 82C51590: 90F9000C  stw r7, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C51594: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C51598: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C5159C: 4BFE2D3D  bl 0x82c342d8
	ctx.lr = 0x82C515A0;
	sub_82C342D8(ctx, base);
	// 82C515A0: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C515A4: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C515A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C515AC: 419A0028  beq cr6, 0x82c515d4
	if ctx.cr[6].eq {
	pc = 0x82C515D4; continue 'dispatch;
	}
	// 82C515B0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C515B4: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C515B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C515BC: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82C515C0: 9B4A0000  stb r26, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C515C4: 7D3F2050  subf r9, r31, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 82C515C8: 7D251670  srawi r5, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82C515CC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C515D0: 4BFFF781  bl 0x82c50d50
	ctx.lr = 0x82C515D4;
	sub_82C50D50(ctx, base);
	// 82C515D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C515D8: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 82C515DC: 40990030  ble cr6, 0x82c5160c
	if !ctx.cr[6].gt {
	pc = 0x82C5160C; continue 'dispatch;
	}
	// 82C515E0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C515E4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C515E8: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C515EC: 81080020  lwz r8, 0x20(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C515F0: 80E90020  lwz r7, 0x20(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C515F4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C515F8: 40980014  bge cr6, 0x82c5160c
	if !ctx.cr[6].lt {
	pc = 0x82C5160C; continue 'dispatch;
	}
	// 82C515FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C51600: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C51604: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C51608: 4198FFDC  blt cr6, 0x82c515e4
	if ctx.cr[6].lt {
	pc = 0x82C515E4; continue 'dispatch;
	}
	// 82C5160C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C51610: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C51614: 4BFE2CC5  bl 0x82c342d8
	ctx.lr = 0x82C51618;
	sub_82C342D8(ctx, base);
	// 82C51618: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C5161C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C51620: 4BFE2CB9  bl 0x82c342d8
	ctx.lr = 0x82C51624;
	sub_82C342D8(ctx, base);
	// 82C51624: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C51628: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5162C: 419A0008  beq cr6, 0x82c51634
	if ctx.cr[6].eq {
	pc = 0x82C51634; continue 'dispatch;
	}
	// 82C51630: 4BBF4181  bl 0x828457b0
	ctx.lr = 0x82C51634;
	sub_828457B0(ctx, base);
	// 82C51634: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C51638: 48057E14  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C51640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C51640 size=184
    let mut pc: u32 = 0x82C51640;
    'dispatch: loop {
        match pc {
            0x82C51640 => {
    //   block [0x82C51640..0x82C516F8)
	// 82C51640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C51644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C51648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5164C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C51650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51658: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C5165C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51660: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C51664: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51668: 4E800421  bctrl
	ctx.lr = 0x82C5166C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5166C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51670: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C51674: 419A0064  beq cr6, 0x82c516d8
	if ctx.cr[6].eq {
	pc = 0x82C516D8; continue 'dispatch;
	}
	// 82C51678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5167C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51680: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C51684: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51688: 4E800421  bctrl
	ctx.lr = 0x82C5168C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5168C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C51690: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C51694: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C51698: 409A000C  bne cr6, 0x82c516a4
	if !ctx.cr[6].eq {
	pc = 0x82C516A4; continue 'dispatch;
	}
	// 82C5169C: 4BFFFBAD  bl 0x82c51248
	ctx.lr = 0x82C516A0;
	sub_82C51248(ctx, base);
	// 82C516A0: 48000008  b 0x82c516a8
	pc = 0x82C516A8; continue 'dispatch;
	// 82C516A4: 4BFFF265  bl 0x82c50908
	ctx.lr = 0x82C516A8;
	sub_82C50908(ctx, base);
	// 82C516A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C516AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C516B0: 419A0028  beq cr6, 0x82c516d8
	if ctx.cr[6].eq {
	pc = 0x82C516D8; continue 'dispatch;
	}
	// 82C516B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C516B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C516BC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C516C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C516C4: 4E800421  bctrl
	ctx.lr = 0x82C516C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C516C8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C516CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C516D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C516D4: 409A0008  bne cr6, 0x82c516dc
	if !ctx.cr[6].eq {
	pc = 0x82C516DC; continue 'dispatch;
	}
	// 82C516D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C516DC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C516E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C516E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C516E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C516EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C516F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C516F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C516F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C516F8 size=892
    let mut pc: u32 = 0x82C516F8;
    'dispatch: loop {
        match pc {
            0x82C516F8 => {
    //   block [0x82C516F8..0x82C51A74)
	// 82C516F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C516FC: 48057D01  bl 0x82ca93fc
	ctx.lr = 0x82C51700;
	sub_82CA93D0(ctx, base);
	// 82C51700: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51704: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C51708: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82C5170C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51710: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51714: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51718: 4E800421  bctrl
	ctx.lr = 0x82C5171C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5171C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C51720: 41980140  blt cr6, 0x82c51860
	if ctx.cr[6].lt {
	pc = 0x82C51860; continue 'dispatch;
	}
	// 82C51724: 409A029C  bne cr6, 0x82c519c0
	if !ctx.cr[6].eq {
	pc = 0x82C519C0; continue 'dispatch;
	}
	// 82C51728: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5172C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51730: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C51734: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51738: 4E800421  bctrl
	ctx.lr = 0x82C5173C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5173C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C51740: 41980064  blt cr6, 0x82c517a4
	if ctx.cr[6].lt {
	pc = 0x82C517A4; continue 'dispatch;
	}
	// 82C51744: 409A027C  bne cr6, 0x82c519c0
	if !ctx.cr[6].eq {
	pc = 0x82C519C0; continue 'dispatch;
	}
	// 82C51748: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5174C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C51750: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82C51754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51758: 40990310  ble cr6, 0x82c51a68
	if !ctx.cr[6].gt {
	pc = 0x82C51A68; continue 'dispatch;
	}
	// 82C5175C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C51760: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
	// 82C51764: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51768: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C5176C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51770: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C51774: 4BFFFECD  bl 0x82c51640
	ctx.lr = 0x82C51778;
	sub_82C51640(ctx, base);
	// 82C51778: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C5177C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C51780: 419A0240  beq cr6, 0x82c519c0
	if ctx.cr[6].eq {
	pc = 0x82C519C0; continue 'dispatch;
	}
	// 82C51784: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51788: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C5178C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C51790: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C51794: 4198FFD0  blt cr6, 0x82c51764
	if ctx.cr[6].lt {
	pc = 0x82C51764; continue 'dispatch;
	}
	// 82C51798: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5179C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C517A0: 48057CAC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 82C517A4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C517A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C517AC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C517B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C517B4: 4E800421  bctrl
	ctx.lr = 0x82C517B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C517B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C517BC: 3B4B5D98  addi r26, r11, 0x5d98
	ctx.r[26].s64 = ctx.r[11].s64 + 23960;
	// 82C517C0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C517C4: 4BFB73F5  bl 0x82c08bb8
	ctx.lr = 0x82C517C8;
	sub_82C08BB8(ctx, base);
	// 82C517C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C517CC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C517D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C517D4: 4BFD4ACD  bl 0x82c262a0
	ctx.lr = 0x82C517D8;
	sub_82C262A0(ctx, base);
	// 82C517D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C517DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C517E0: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C517E4: 419A0284  beq cr6, 0x82c51a68
	if ctx.cr[6].eq {
	pc = 0x82C51A68; continue 'dispatch;
	}
	// 82C517E8: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82C517EC: 4B5CDA6D  bl 0x8221f258
	ctx.lr = 0x82C517F0;
	sub_8221F258(ctx, base);
	// 82C517F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C517F4: 419A0028  beq cr6, 0x82c5181c
	if ctx.cr[6].eq {
	pc = 0x82C5181C; continue 'dispatch;
	}
	// 82C517F8: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C517FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C51800: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C51804: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C51808: 93E30014  stw r31, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82C5180C: 93E30018  stw r31, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82C51810: 93E3001C  stw r31, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82C51814: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82C51818: 48000008  b 0x82c51820
	pc = 0x82C51820; continue 'dispatch;
	// 82C5181C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82C51820: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C51824: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C51828: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C5182C: 4BFFFE15  bl 0x82c51640
	ctx.lr = 0x82C51830;
	sub_82C51640(ctx, base);
	// 82C51830: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51838: 419A0188  beq cr6, 0x82c519c0
	if ctx.cr[6].eq {
	pc = 0x82C519C0; continue 'dispatch;
	}
	// 82C5183C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C51840: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C51844: 4BFD4EA5  bl 0x82c266e8
	ctx.lr = 0x82C51848;
	sub_82C266E8(ctx, base);
	// 82C51848: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C5184C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C51850: 4198FF98  blt cr6, 0x82c517e8
	if ctx.cr[6].lt {
	pc = 0x82C517E8; continue 'dispatch;
	}
	// 82C51854: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C51858: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C5185C: 48057BF0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 82C51860: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51864: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51868: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5186C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51870: 4E800421  bctrl
	ctx.lr = 0x82C51874;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51874: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C51878: 419800A4  blt cr6, 0x82c5191c
	if ctx.cr[6].lt {
	pc = 0x82C5191C; continue 'dispatch;
	}
	// 82C5187C: 409A0144  bne cr6, 0x82c519c0
	if !ctx.cr[6].eq {
	pc = 0x82C519C0; continue 'dispatch;
	}
	// 82C51880: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51884: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51888: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5188C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51890: 4E800421  bctrl
	ctx.lr = 0x82C51894;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51894: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51898: 81190008  lwz r8, 8(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5189C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C518A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C518A4: 80E90020  lwz r7, 0x20(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C518A8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C518AC: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C518B0: 4E800421  bctrl
	ctx.lr = 0x82C518B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C518B4: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C518B8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C518BC: 419A0104  beq cr6, 0x82c519c0
	if ctx.cr[6].eq {
	pc = 0x82C519C0; continue 'dispatch;
	}
	// 82C518C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C518C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C518C8: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C518CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C518D0: 419A0198  beq cr6, 0x82c51a68
	if ctx.cr[6].eq {
	pc = 0x82C51A68; continue 'dispatch;
	}
	// 82C518D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C518D8: 3BCB5D98  addi r30, r11, 0x5d98
	ctx.r[30].s64 = ctx.r[11].s64 + 23960;
	// 82C518DC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C518E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C518E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C518E8: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C518EC: 4BFFFD55  bl 0x82c51640
	ctx.lr = 0x82C518F0;
	sub_82C51640(ctx, base);
	// 82C518F0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C518F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C518F8: 419A00C8  beq cr6, 0x82c519c0
	if ctx.cr[6].eq {
	pc = 0x82C519C0; continue 'dispatch;
	}
	// 82C518FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51900: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C51904: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C51908: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C5190C: 4198FFD0  blt cr6, 0x82c518dc
	if ctx.cr[6].lt {
	pc = 0x82C518DC; continue 'dispatch;
	}
	// 82C51910: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C51914: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C51918: 48057B34  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 82C5191C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51920: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51924: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C51928: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5192C: 4E800421  bctrl
	ctx.lr = 0x82C51930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51930: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51938: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C5193C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51940: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C51944: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C51948: 4E800421  bctrl
	ctx.lr = 0x82C5194C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5194C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51950: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C51954: 419A006C  beq cr6, 0x82c519c0
	if ctx.cr[6].eq {
	pc = 0x82C519C0; continue 'dispatch;
	}
	// 82C51958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5195C: 4BFB63C5  bl 0x82c07d20
	ctx.lr = 0x82C51960;
	sub_82C07D20(ctx, base);
	// 82C51960: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51964: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82C51968: 40990064  ble cr6, 0x82c519cc
	if !ctx.cr[6].gt {
	pc = 0x82C519CC; continue 'dispatch;
	}
	// 82C5196C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51970: 4BFB63B1  bl 0x82c07d20
	ctx.lr = 0x82C51974;
	sub_82C07D20(ctx, base);
	// 82C51974: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51978: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5197C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51980: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C51984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C51988: 3BAAB0E8  addi r29, r10, -0x4f18
	ctx.r[29].s64 = ctx.r[10].s64 + -20248;
	// 82C5198C: 810B0040  lwz r8, 0x40(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C51990: 3B89B0C8  addi r28, r9, -0x4f38
	ctx.r[28].s64 = ctx.r[9].s64 + -20280;
	// 82C51994: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51998: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C5199C: 4E800421  bctrl
	ctx.lr = 0x82C519A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C519A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C519A4: 4BFB3E55  bl 0x82c057f8
	ctx.lr = 0x82C519A8;
	sub_82C057F8(ctx, base);
	// 82C519A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C519AC: 4BFB3EBD  bl 0x82c05868
	ctx.lr = 0x82C519B0;
	sub_82C05868(ctx, base);
	// 82C519B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C519B4: 4BFB3E45  bl 0x82c057f8
	ctx.lr = 0x82C519B8;
	sub_82C057F8(ctx, base);
	// 82C519B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C519BC: 4BFB3EAD  bl 0x82c05868
	ctx.lr = 0x82C519C0;
	sub_82C05868(ctx, base);
	// 82C519C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C519C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C519C8: 48057A84  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 82C519CC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C519D0: 4BFD48D1  bl 0x82c262a0
	ctx.lr = 0x82C519D4;
	sub_82C262A0(ctx, base);
	// 82C519D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C519D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C519DC: 419A008C  beq cr6, 0x82c51a68
	if ctx.cr[6].eq {
	pc = 0x82C51A68; continue 'dispatch;
	}
	// 82C519E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C519E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C519E8: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C519EC: 419A007C  beq cr6, 0x82c51a68
	if ctx.cr[6].eq {
	pc = 0x82C51A68; continue 'dispatch;
	}
	// 82C519F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C519F4: 3B8B5D98  addi r28, r11, 0x5d98
	ctx.r[28].s64 = ctx.r[11].s64 + 23960;
	// 82C519F8: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82C519FC: 4B5CD85D  bl 0x8221f258
	ctx.lr = 0x82C51A00;
	sub_8221F258(ctx, base);
	// 82C51A00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C51A04: 419A0028  beq cr6, 0x82c51a2c
	if ctx.cr[6].eq {
	pc = 0x82C51A2C; continue 'dispatch;
	}
	// 82C51A08: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C51A0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C51A10: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C51A14: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C51A18: 93E30014  stw r31, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82C51A1C: 93E30018  stw r31, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82C51A20: 93E3001C  stw r31, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82C51A24: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82C51A28: 48000008  b 0x82c51a30
	pc = 0x82C51A30; continue 'dispatch;
	// 82C51A2C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82C51A30: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C51A34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C51A38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C51A3C: 4BFFFC05  bl 0x82c51640
	ctx.lr = 0x82C51A40;
	sub_82C51640(ctx, base);
	// 82C51A40: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51A48: 419AFF78  beq cr6, 0x82c519c0
	if ctx.cr[6].eq {
	pc = 0x82C519C0; continue 'dispatch;
	}
	// 82C51A4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C51A50: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C51A54: 4BFD4C95  bl 0x82c266e8
	ctx.lr = 0x82C51A58;
	sub_82C266E8(ctx, base);
	// 82C51A58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51A5C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C51A60: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C51A64: 4198FF94  blt cr6, 0x82c519f8
	if ctx.cr[6].lt {
	pc = 0x82C519F8; continue 'dispatch;
	}
	// 82C51A68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C51A6C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C51A70: 480579DC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C51A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C51A78 size=396
    let mut pc: u32 = 0x82C51A78;
    'dispatch: loop {
        match pc {
            0x82C51A78 => {
    //   block [0x82C51A78..0x82C51C04)
	// 82C51A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C51A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C51A80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C51A84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C51A88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51A90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C51A94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51A98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51A9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51AA0: 4E800421  bctrl
	ctx.lr = 0x82C51AA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51AA4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C51AA8: 41980038  blt cr6, 0x82c51ae0
	if ctx.cr[6].lt {
	pc = 0x82C51AE0; continue 'dispatch;
	}
	// 82C51AAC: 409A0118  bne cr6, 0x82c51bc4
	if !ctx.cr[6].eq {
	pc = 0x82C51BC4; continue 'dispatch;
	}
	// 82C51AB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51AB8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C51ABC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51AC0: 4E800421  bctrl
	ctx.lr = 0x82C51AC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51AC4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C51AC8: 41980070  blt cr6, 0x82c51b38
	if ctx.cr[6].lt {
	pc = 0x82C51B38; continue 'dispatch;
	}
	// 82C51ACC: 409A00F8  bne cr6, 0x82c51bc4
	if !ctx.cr[6].eq {
	pc = 0x82C51BC4; continue 'dispatch;
	}
	// 82C51AD0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51AD8: 419A0110  beq cr6, 0x82c51be8
	if ctx.cr[6].eq {
	pc = 0x82C51BE8; continue 'dispatch;
	}
	// 82C51ADC: 48000024  b 0x82c51b00
	pc = 0x82C51B00; continue 'dispatch;
	// 82C51AE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51AE8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C51AEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51AF0: 4E800421  bctrl
	ctx.lr = 0x82C51AF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51AF4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C51AF8: 41980040  blt cr6, 0x82c51b38
	if ctx.cr[6].lt {
	pc = 0x82C51B38; continue 'dispatch;
	}
	// 82C51AFC: 409A00C8  bne cr6, 0x82c51bc4
	if !ctx.cr[6].eq {
	pc = 0x82C51BC4; continue 'dispatch;
	}
	// 82C51B00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C51B04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51B08: 4BFCFD51  bl 0x82c21858
	ctx.lr = 0x82C51B0C;
	sub_82C21858(ctx, base);
	// 82C51B0C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C51B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51B14: 4BFFFBE5  bl 0x82c516f8
	ctx.lr = 0x82C51B18;
	sub_82C516F8(ctx, base);
	// 82C51B18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51B1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C51B20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C51B24: 4BFFF6B5  bl 0x82c511d8
	ctx.lr = 0x82C51B28;
	sub_82C511D8(ctx, base);
	// 82C51B28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51B2C: 4BFD8EC5  bl 0x82c2a9f0
	ctx.lr = 0x82C51B30;
	sub_82C2A9F0(ctx, base);
	// 82C51B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51B34: 480000B8  b 0x82c51bec
	pc = 0x82C51BEC; continue 'dispatch;
	// 82C51B38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C51B3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51B40: 4BFFF141  bl 0x82c50c80
	ctx.lr = 0x82C51B44;
	sub_82C50C80(ctx, base);
	// 82C51B44: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C51B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51B4C: 4BFFFBAD  bl 0x82c516f8
	ctx.lr = 0x82C51B50;
	sub_82C516F8(ctx, base);
	// 82C51B50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51B54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51B58: 419A0064  beq cr6, 0x82c51bbc
	if ctx.cr[6].eq {
	pc = 0x82C51BBC; continue 'dispatch;
	}
	// 82C51B5C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C51B60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C51B64: 392ACB90  addi r9, r10, -0x3470
	ctx.r[9].s64 = ctx.r[10].s64 + -13424;
	// 82C51B68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C51B6C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C51B70: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C51B74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C51B78: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C51B7C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C51B80: 4BFFF8B9  bl 0x82c51438
	ctx.lr = 0x82C51B84;
	sub_82C51438(ctx, base);
	// 82C51B84: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C51B88: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C51B8C: 419A0040  beq cr6, 0x82c51bcc
	if ctx.cr[6].eq {
	pc = 0x82C51BCC; continue 'dispatch;
	}
	// 82C51B90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51B94: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C51B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51B9C: 3BEAB124  addi r31, r10, -0x4edc
	ctx.r[31].s64 = ctx.r[10].s64 + -20188;
	// 82C51BA0: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C51BA4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C51BA8: 4E800421  bctrl
	ctx.lr = 0x82C51BAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51BAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C51BB0: 4BFB3C49  bl 0x82c057f8
	ctx.lr = 0x82C51BB4;
	sub_82C057F8(ctx, base);
	// 82C51BB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C51BB8: 4BFFF3D9  bl 0x82c50f90
	ctx.lr = 0x82C51BBC;
	sub_82C50F90(ctx, base);
	// 82C51BBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51BC0: 4BFFF2B1  bl 0x82c50e70
	ctx.lr = 0x82C51BC4;
	sub_82C50E70(ctx, base);
	// 82C51BC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C51BC8: 48000024  b 0x82c51bec
	pc = 0x82C51BEC; continue 'dispatch;
	// 82C51BCC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C51BD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C51BD4: 4BFFF605  bl 0x82c511d8
	ctx.lr = 0x82C51BD8;
	sub_82C511D8(ctx, base);
	// 82C51BD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C51BDC: 4BFFF3B5  bl 0x82c50f90
	ctx.lr = 0x82C51BE0;
	sub_82C50F90(ctx, base);
	// 82C51BE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51BE4: 4BFFF28D  bl 0x82c50e70
	ctx.lr = 0x82C51BE8;
	sub_82C50E70(ctx, base);
	// 82C51BE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C51BEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C51BF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C51BF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C51BF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C51BFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C51C00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C51C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C51C08 size=148
    let mut pc: u32 = 0x82C51C08;
    'dispatch: loop {
        match pc {
            0x82C51C08 => {
    //   block [0x82C51C08..0x82C51C9C)
	// 82C51C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C51C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C51C10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C51C14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C51C18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51C1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51C20: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C51C24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51C28: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C51C2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51C30: 4E800421  bctrl
	ctx.lr = 0x82C51C34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51C34: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51C38: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C51C3C: 419A0040  beq cr6, 0x82c51c7c
	if ctx.cr[6].eq {
	pc = 0x82C51C7C; continue 'dispatch;
	}
	// 82C51C40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C51C44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51C48: 4BFFFE31  bl 0x82c51a78
	ctx.lr = 0x82C51C4C;
	sub_82C51A78(ctx, base);
	// 82C51C4C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51C54: 419A0028  beq cr6, 0x82c51c7c
	if ctx.cr[6].eq {
	pc = 0x82C51C7C; continue 'dispatch;
	}
	// 82C51C58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51C60: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C51C64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51C68: 4E800421  bctrl
	ctx.lr = 0x82C51C6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51C6C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51C70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C51C74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C51C78: 409A0008  bne cr6, 0x82c51c80
	if !ctx.cr[6].eq {
	pc = 0x82C51C80; continue 'dispatch;
	}
	// 82C51C7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C51C80: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C51C84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C51C88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C51C8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C51C90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C51C94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C51C98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C51CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C51CA0 size=540
    let mut pc: u32 = 0x82C51CA0;
    'dispatch: loop {
        match pc {
            0x82C51CA0 => {
    //   block [0x82C51CA0..0x82C51EBC)
	// 82C51CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C51CA4: 48057765  bl 0x82ca9408
	ctx.lr = 0x82C51CA8;
	sub_82CA93D0(ctx, base);
	// 82C51CA8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51CAC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C51CB0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C51CB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C51CB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C51CBC: 419A001C  beq cr6, 0x82c51cd8
	if ctx.cr[6].eq {
	pc = 0x82C51CD8; continue 'dispatch;
	}
	// 82C51CC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C51CC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C51CC8: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C51CCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C51CD0: 388A0CA0  addi r4, r10, 0xca0
	ctx.r[4].s64 = ctx.r[10].s64 + 3232;
	// 82C51CD4: 4BFB3AB5  bl 0x82c05788
	ctx.lr = 0x82C51CD8;
	sub_82C05788(ctx, base);
	// 82C51CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C51CDC: 4BFB730D  bl 0x82c08fe8
	ctx.lr = 0x82C51CE0;
	sub_82C08FE8(ctx, base);
	// 82C51CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51CE4: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 82C51CE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C51CEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C51CF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C51CF4: 4BEFC6FD  bl 0x82b4e3f0
	ctx.lr = 0x82C51CF8;
	sub_82B4E3F0(ctx, base);
	// 82C51CF8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51CFC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C51D00: 419A00DC  beq cr6, 0x82c51ddc
	if ctx.cr[6].eq {
	pc = 0x82C51DDC; continue 'dispatch;
	}
	// 82C51D04: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 82C51D08: 41980160  blt cr6, 0x82c51e68
	if ctx.cr[6].lt {
	pc = 0x82C51E68; continue 'dispatch;
	}
	// 82C51D0C: 419A012C  beq cr6, 0x82c51e38
	if ctx.cr[6].eq {
	pc = 0x82C51E38; continue 'dispatch;
	}
	// 82C51D10: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 82C51D14: 41980024  blt cr6, 0x82c51d38
	if ctx.cr[6].lt {
	pc = 0x82C51D38; continue 'dispatch;
	}
	// 82C51D18: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51D1C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C51D20: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51D24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51D28: 4E800421  bctrl
	ctx.lr = 0x82C51D2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51D2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C51D30: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C51D34: 48057724  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82C51D38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C51D40: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C51D44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51D48: 4E800421  bctrl
	ctx.lr = 0x82C51D4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51D4C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C51D50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C51D54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C51D58: 4BEF91C9  bl 0x82b4af20
	ctx.lr = 0x82C51D5C;
	sub_82B4AF20(ctx, base);
	// 82C51D5C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C51D60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C51D64: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51D68: 48018A99  bl 0x82c6a800
	ctx.lr = 0x82C51D6C;
	sub_82C6A800(ctx, base);
	// 82C51D6C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C51D70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C51D74: 419A0014  beq cr6, 0x82c51d88
	if ctx.cr[6].eq {
	pc = 0x82C51D88; continue 'dispatch;
	}
	// 82C51D78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51D7C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51D80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51D84: 4E800421  bctrl
	ctx.lr = 0x82C51D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51D88: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C51D8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C51D90: 419A0030  beq cr6, 0x82c51dc0
	if ctx.cr[6].eq {
	pc = 0x82C51DC0; continue 'dispatch;
	}
	// 82C51D94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C51D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C51D9C: 4BFB765D  bl 0x82c093f8
	ctx.lr = 0x82C51DA0;
	sub_82C093F8(ctx, base);
	// 82C51DA0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C51DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51DA8: 409A0040  bne cr6, 0x82c51de8
	if !ctx.cr[6].eq {
	pc = 0x82C51DE8; continue 'dispatch;
	}
	// 82C51DAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51DB4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51DB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51DBC: 4E800421  bctrl
	ctx.lr = 0x82C51DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51DC0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51DC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C51DC8: 419A0014  beq cr6, 0x82c51ddc
	if ctx.cr[6].eq {
	pc = 0x82C51DDC; continue 'dispatch;
	}
	// 82C51DCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51DD0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51DD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51DD8: 4E800421  bctrl
	ctx.lr = 0x82C51DDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51DDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C51DE0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C51DE4: 48057674  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82C51DE8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C51DEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C51DF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C51DF4: 4BFFFEAD  bl 0x82c51ca0
	ctx.lr = 0x82C51DF8;
	sub_82C51CA0(ctx, base);
	// 82C51DF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51DFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C51E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51E04: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51E08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51E0C: 4E800421  bctrl
	ctx.lr = 0x82C51E10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51E10: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51E14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C51E18: 419A0014  beq cr6, 0x82c51e2c
	if ctx.cr[6].eq {
	pc = 0x82C51E2C; continue 'dispatch;
	}
	// 82C51E1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51E20: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51E24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51E28: 4E800421  bctrl
	ctx.lr = 0x82C51E2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51E2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C51E30: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C51E34: 48057624  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82C51E38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C51E3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51E40: 4BFB7069  bl 0x82c08ea8
	ctx.lr = 0x82C51E44;
	sub_82C08EA8(ctx, base);
	// 82C51E44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C51E48: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C51E4C: 388BA0B8  addi r4, r11, -0x5f48
	ctx.r[4].s64 = ctx.r[11].s64 + -24392;
	// 82C51E50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51E54: 4BFFFDB5  bl 0x82c51c08
	ctx.lr = 0x82C51E58;
	sub_82C51C08(ctx, base);
	// 82C51E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51E5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51E60: 4BFB7129  bl 0x82c08f88
	ctx.lr = 0x82C51E64;
	sub_82C08F88(ctx, base);
	// 82C51E64: 48000030  b 0x82c51e94
	pc = 0x82C51E94; continue 'dispatch;
	// 82C51E68: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C51E6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51E70: 4BFB6A29  bl 0x82c08898
	ctx.lr = 0x82C51E74;
	sub_82C08898(ctx, base);
	// 82C51E74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C51E78: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C51E7C: 388BA0B8  addi r4, r11, -0x5f48
	ctx.r[4].s64 = ctx.r[11].s64 + -24392;
	// 82C51E80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51E84: 4BFFFD85  bl 0x82c51c08
	ctx.lr = 0x82C51E88;
	sub_82C51C08(ctx, base);
	// 82C51E88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51E8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51E90: 4BFB6CB1  bl 0x82c08b40
	ctx.lr = 0x82C51E94;
	sub_82C08B40(ctx, base);
	// 82C51E94: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51E98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C51E9C: 419A0014  beq cr6, 0x82c51eb0
	if ctx.cr[6].eq {
	pc = 0x82C51EB0; continue 'dispatch;
	}
	// 82C51EA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51EA4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51EA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51EAC: 4E800421  bctrl
	ctx.lr = 0x82C51EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51EB4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C51EB8: 480575A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C51EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C51EC0 size=284
    let mut pc: u32 = 0x82C51EC0;
    'dispatch: loop {
        match pc {
            0x82C51EC0 => {
    //   block [0x82C51EC0..0x82C51FDC)
	// 82C51EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C51EC4: 48057549  bl 0x82ca940c
	ctx.lr = 0x82C51EC8;
	sub_82CA93D0(ctx, base);
	// 82C51EC8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51ECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C51ED0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C51ED4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C51ED8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51EE0: 419A0038  beq cr6, 0x82c51f18
	if ctx.cr[6].eq {
	pc = 0x82C51F18; continue 'dispatch;
	}
	// 82C51EE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C51EE8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82C51EEC: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82C51EF0: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C51EF4: 394BB008  addi r10, r11, -0x4ff8
	ctx.r[10].s64 = ctx.r[11].s64 + -20472;
	// 82C51EF8: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82C51EFC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82C51F00: 4BFE23D9  bl 0x82c342d8
	ctx.lr = 0x82C51F04;
	sub_82C342D8(ctx, base);
	// 82C51F04: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C51F08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C51F0C: 3909CB90  addi r8, r9, -0x3470
	ctx.r[8].s64 = ctx.r[9].s64 + -13424;
	// 82C51F10: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82C51F14: 4BFFF07D  bl 0x82c50f90
	ctx.lr = 0x82C51F18;
	sub_82C50F90(ctx, base);
	// 82C51F18: 4BFB0D19  bl 0x82c02c30
	ctx.lr = 0x82C51F1C;
	sub_82C02C30(ctx, base);
	// 82C51F1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51F28: 409A0010  bne cr6, 0x82c51f38
	if !ctx.cr[6].eq {
	pc = 0x82C51F38; continue 'dispatch;
	}
	// 82C51F2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82C51F30: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82C51F34: 48000008  b 0x82c51f3c
	pc = 0x82C51F3C; continue 'dispatch;
	// 82C51F38: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51F3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C51F40: 4B529169  bl 0x8217b0a8
	ctx.lr = 0x82C51F44;
	sub_8217B0A8(ctx, base);
	// 82C51F44: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51F48: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C51F4C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82C51F50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C51F54: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51F58: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C51F5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C51F60: 4E800421  bctrl
	ctx.lr = 0x82C51F64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51F64: 81210088  lwz r9, 0x88(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C51F68: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 82C51F6C: 4198000C  blt cr6, 0x82c51f78
	if ctx.cr[6].lt {
	pc = 0x82C51F78; continue 'dispatch;
	}
	// 82C51F70: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82C51F74: 4BBF383D  bl 0x828457b0
	ctx.lr = 0x82C51F78;
	sub_828457B0(ctx, base);
	// 82C51F78: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51F7C: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82C51F80: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82C51F84: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82C51F88: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C51F8C: B3A10074  sth r29, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u16 ) };
	// 82C51F90: 409A0010  bne cr6, 0x82c51fa0
	if !ctx.cr[6].eq {
	pc = 0x82C51FA0; continue 'dispatch;
	}
	// 82C51F94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C51F98: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C51F9C: 480574C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82C51FA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C51FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C51FA8: 4BFFFCF9  bl 0x82c51ca0
	ctx.lr = 0x82C51FAC;
	sub_82C51CA0(ctx, base);
	// 82C51FAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C51FB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C51FB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C51FB8: 419A0018  beq cr6, 0x82c51fd0
	if ctx.cr[6].eq {
	pc = 0x82C51FD0; continue 'dispatch;
	}
	// 82C51FBC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C51FC0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C51FC4: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C51FC8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C51FCC: 4E800421  bctrl
	ctx.lr = 0x82C51FD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C51FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C51FD4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C51FD8: 48057484  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C51FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C51FE0 size=136
    let mut pc: u32 = 0x82C51FE0;
    'dispatch: loop {
        match pc {
            0x82C51FE0 => {
    //   block [0x82C51FE0..0x82C52068)
	// 82C51FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C51FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C51FE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C51FEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C51FF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C51FF4: 3FE08333  lis r31, -0x7ccd
	ctx.r[31].s64 = -2093809664;
	// 82C51FF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C51FFC: 897F5100  lbz r11, 0x5100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20736 as u32) ) } as u64;
	// 82C52000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C52004: 419A000C  beq cr6, 0x82c52010
	if ctx.cr[6].eq {
	pc = 0x82C52010; continue 'dispatch;
	}
	// 82C52008: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C5200C: 48000044  b 0x82c52050
	pc = 0x82C52050; continue 'dispatch;
	// 82C52010: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52014: 38A01000  li r5, 0x1000
	ctx.r[5].s64 = 4096;
	// 82C52018: 386B5108  addi r3, r11, 0x5108
	ctx.r[3].s64 = ctx.r[11].s64 + 20744;
	// 82C5201C: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 82C52020: 4BFB7DB1  bl 0x82c09dd0
	ctx.lr = 0x82C52024;
	sub_82C09DD0(ctx, base);
	// 82C52024: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C52028: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C5202C: 419AFFDC  beq cr6, 0x82c52008
	if ctx.cr[6].eq {
	pc = 0x82C52008; continue 'dispatch;
	}
	// 82C52030: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C52034: 48008CF5  bl 0x82c5ad28
	ctx.lr = 0x82C52038;
	sub_82C5AD28(ctx, base);
	// 82C52038: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C5203C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C52040: 419AFFC8  beq cr6, 0x82c52008
	if ctx.cr[6].eq {
	pc = 0x82C52008; continue 'dispatch;
	}
	// 82C52044: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C52048: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5204C: 997F5100  stb r11, 0x5100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20736 as u32), ctx.r[11].u8 ) };
	// 82C52050: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C52054: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52058: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5205C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C52060: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52064: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52068 size=24
    let mut pc: u32 = 0x82C52068;
    'dispatch: loop {
        match pc {
            0x82C52068 => {
    //   block [0x82C52068..0x82C52080)
	// 82C52068: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C5206C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82C52070: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 82C52074: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82C52078: 916A5160  stw r11, 0x5160(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20832 as u32), ctx.r[11].u32 ) };
	// 82C5207C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52080 size=164
    let mut pc: u32 = 0x82C52080;
    'dispatch: loop {
        match pc {
            0x82C52080 => {
    //   block [0x82C52080..0x82C52124)
	// 82C52080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52084: 48057389  bl 0x82ca940c
	ctx.lr = 0x82C52088;
	sub_82CA93D0(ctx, base);
	// 82C52088: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5208C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52090: 894B5100  lbz r10, 0x5100(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20736 as u32) ) } as u64;
	// 82C52094: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C52098: 419A0084  beq cr6, 0x82c5211c
	if ctx.cr[6].eq {
	pc = 0x82C5211C; continue 'dispatch;
	}
	// 82C5209C: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C520A0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C520A4: 3BAA515C  addi r29, r10, 0x515c
	ctx.r[29].s64 = ctx.r[10].s64 + 20828;
	// 82C520A8: 3BCB5108  addi r30, r11, 0x5108
	ctx.r[30].s64 = ctx.r[11].s64 + 20744;
	// 82C520AC: 816A515C  lwz r11, 0x515c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20828 as u32) ) } as u64;
	// 82C520B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C520B4: 41990018  bgt cr6, 0x82c520cc
	if ctx.cr[6].gt {
	pc = 0x82C520CC; continue 'dispatch;
	}
	// 82C520B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C520BC: 4BFB7BB5  bl 0x82c09c70
	ctx.lr = 0x82C520C0;
	sub_82C09C70(ctx, base);
	// 82C520C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C520C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C520C8: 419A0054  beq cr6, 0x82c5211c
	if ctx.cr[6].eq {
	pc = 0x82C5211C; continue 'dispatch;
	}
	// 82C520CC: 3FE08333  lis r31, -0x7ccd
	ctx.r[31].s64 = -2093809664;
	// 82C520D0: 817F5160  lwz r11, 0x5160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20832 as u32) ) } as u64;
	// 82C520D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C520D8: 409A0018  bne cr6, 0x82c520f0
	if !ctx.cr[6].eq {
	pc = 0x82C520F0; continue 'dispatch;
	}
	// 82C520DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C520E0: 4BFB7D81  bl 0x82c09e60
	ctx.lr = 0x82C520E4;
	sub_82C09E60(ctx, base);
	// 82C520E4: 817F5160  lwz r11, 0x5160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20832 as u32) ) } as u64;
	// 82C520E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C520EC: 419AFFF0  beq cr6, 0x82c520dc
	if ctx.cr[6].eq {
	pc = 0x82C520DC; continue 'dispatch;
	}
	// 82C520F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C520F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C520F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C520FC: 917F5160  stw r11, 0x5160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20832 as u32), ctx.r[11].u32 ) };
	// 82C52100: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82C52104: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82C52108: 7D40E828  lwarx r10, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82C5210C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82C52110: 7D40E92D  stwcx. r10, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82C52114: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82C52118: 4082FFE8  bne 0x82c52100
	if !ctx.cr[0].eq {
	pc = 0x82C52100; continue 'dispatch;
	}
	// 82C5211C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C52120: 4805733C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52128 size=24
    let mut pc: u32 = 0x82C52128;
    'dispatch: loop {
        match pc {
            0x82C52128 => {
    //   block [0x82C52128..0x82C52140)
	// 82C52128: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5212C: 894B5100  lbz r10, 0x5100(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20736 as u32) ) } as u64;
	// 82C52130: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C52134: 409A000C  bne cr6, 0x82c52140
	if !ctx.cr[6].eq {
		sub_82C52140(ctx, base);
		return;
	}
	// 82C52138: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C5213C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52140 size=12
    let mut pc: u32 = 0x82C52140;
    'dispatch: loop {
        match pc {
            0x82C52140 => {
    //   block [0x82C52140..0x82C5214C)
	// 82C52140: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52144: 386B5108  addi r3, r11, 0x5108
	ctx.r[3].s64 = ctx.r[11].s64 + 20744;
	// 82C52148: 4BFB7B00  b 0x82c09c48
	sub_82C09C48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52150 size=48
    let mut pc: u32 = 0x82C52150;
    'dispatch: loop {
        match pc {
            0x82C52150 => {
    //   block [0x82C52150..0x82C52180)
	// 82C52150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52158: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5215C: 48005BF5  bl 0x82c57d50
	ctx.lr = 0x82C52160;
	sub_82C57D50(ctx, base);
	// 82C52160: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52164: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52168: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C5216C: 4E800421  bctrl
	ctx.lr = 0x82C52170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52170: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C52174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C5217C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52180 size=84
    let mut pc: u32 = 0x82C52180;
    'dispatch: loop {
        match pc {
            0x82C52180 => {
    //   block [0x82C52180..0x82C521D4)
	// 82C52180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52188: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5218C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52190: 894B5100  lbz r10, 0x5100(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20736 as u32) ) } as u64;
	// 82C52194: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C52198: 409A0018  bne cr6, 0x82c521b0
	if !ctx.cr[6].eq {
	pc = 0x82C521B0; continue 'dispatch;
	}
	// 82C5219C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C521A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C521A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C521A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C521AC: 4E800020  blr
	return;
	// 82C521B0: 48005BA1  bl 0x82c57d50
	ctx.lr = 0x82C521B4;
	sub_82C57D50(ctx, base);
	// 82C521B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C521B8: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C521BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C521C0: 4E800421  bctrl
	ctx.lr = 0x82C521C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C521C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C521C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C521CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C521D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C521D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C521D8 size=84
    let mut pc: u32 = 0x82C521D8;
    'dispatch: loop {
        match pc {
            0x82C521D8 => {
    //   block [0x82C521D8..0x82C5222C)
	// 82C521D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C521DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C521E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C521E4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C521E8: 894B5100  lbz r10, 0x5100(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20736 as u32) ) } as u64;
	// 82C521EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C521F0: 409A0018  bne cr6, 0x82c52208
	if !ctx.cr[6].eq {
	pc = 0x82C52208; continue 'dispatch;
	}
	// 82C521F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C521F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C521FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52204: 4E800020  blr
	return;
	// 82C52208: 48005B49  bl 0x82c57d50
	ctx.lr = 0x82C5220C;
	sub_82C57D50(ctx, base);
	// 82C5220C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52210: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C52214: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C52218: 4E800421  bctrl
	ctx.lr = 0x82C5221C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5221C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C52220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52230 size=64
    let mut pc: u32 = 0x82C52230;
    'dispatch: loop {
        match pc {
            0x82C52230 => {
    //   block [0x82C52230..0x82C52270)
	// 82C52230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5223C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C52244: 48005B0D  bl 0x82c57d50
	ctx.lr = 0x82C52248;
	sub_82C57D50(ctx, base);
	// 82C52248: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5224C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52250: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C52254: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C52258: 4E800421  bctrl
	ctx.lr = 0x82C5225C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5225C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C52260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52268: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5226C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52270 size=64
    let mut pc: u32 = 0x82C52270;
    'dispatch: loop {
        match pc {
            0x82C52270 => {
    //   block [0x82C52270..0x82C522B0)
	// 82C52270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52278: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5227C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C52284: 48005ACD  bl 0x82c57d50
	ctx.lr = 0x82C52288;
	sub_82C57D50(ctx, base);
	// 82C52288: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5228C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52290: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C52294: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C52298: 4E800421  bctrl
	ctx.lr = 0x82C5229C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C5229C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C522A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C522A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C522A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C522AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C522B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C522B0 size=64
    let mut pc: u32 = 0x82C522B0;
    'dispatch: loop {
        match pc {
            0x82C522B0 => {
    //   block [0x82C522B0..0x82C522F0)
	// 82C522B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C522B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C522B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C522BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C522C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C522C4: 48005A8D  bl 0x82c57d50
	ctx.lr = 0x82C522C8;
	sub_82C57D50(ctx, base);
	// 82C522C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C522CC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C522D0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C522D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C522D8: 4E800421  bctrl
	ctx.lr = 0x82C522DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C522DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C522E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C522E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C522E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C522EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C522F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C522F0 size=76
    let mut pc: u32 = 0x82C522F0;
    'dispatch: loop {
        match pc {
            0x82C522F0 => {
    //   block [0x82C522F0..0x82C5233C)
	// 82C522F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C522F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C522F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C522FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C52304: 48005A4D  bl 0x82c57d50
	ctx.lr = 0x82C52308;
	sub_82C57D50(ctx, base);
	// 82C52308: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5230C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52310: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52314: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C52318: 808A0010  lwz r4, 0x10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5231C: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C52320: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C52324: 4E800421  bctrl
	ctx.lr = 0x82C52328;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52328: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5232C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52340 size=76
    let mut pc: u32 = 0x82C52340;
    'dispatch: loop {
        match pc {
            0x82C52340 => {
    //   block [0x82C52340..0x82C5238C)
	// 82C52340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5234C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C52354: 480059FD  bl 0x82c57d50
	ctx.lr = 0x82C52358;
	sub_82C57D50(ctx, base);
	// 82C52358: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5235C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52360: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52364: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C52368: 808A0010  lwz r4, 0x10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5236C: 8109003C  lwz r8, 0x3c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 82C52370: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C52374: 4E800421  bctrl
	ctx.lr = 0x82C52378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52378: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5237C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52380: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52390 size=32
    let mut pc: u32 = 0x82C52390;
    'dispatch: loop {
        match pc {
            0x82C52390 => {
    //   block [0x82C52390..0x82C523B0)
	// 82C52390: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52394: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C52398: 88830008  lbz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5239C: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C523A0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C523A4: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C523A8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C523AC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C523B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C523B0 size=32
    let mut pc: u32 = 0x82C523B0;
    'dispatch: loop {
        match pc {
            0x82C523B0 => {
    //   block [0x82C523B0..0x82C523D0)
	// 82C523B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C523B4: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C523B8: 88830008  lbz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C523BC: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C523C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C523C4: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C523C8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C523CC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C523D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C523D0 size=24
    let mut pc: u32 = 0x82C523D0;
    'dispatch: loop {
        match pc {
            0x82C523D0 => {
    //   block [0x82C523D0..0x82C523E8)
	// 82C523D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C523D4: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C523D8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C523DC: 812A002C  lwz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C523E0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C523E4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C523E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C523E8 size=32
    let mut pc: u32 = 0x82C523E8;
    'dispatch: loop {
        match pc {
            0x82C523E8 => {
    //   block [0x82C523E8..0x82C52408)
	// 82C523E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C523EC: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C523F0: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C523F4: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C523F8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C523FC: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C52400: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C52404: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52408 size=28
    let mut pc: u32 = 0x82C52408;
    'dispatch: loop {
        match pc {
            0x82C52408 => {
    //   block [0x82C52408..0x82C52424)
	// 82C52408: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5240C: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C52410: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C52414: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52418: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5241C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C52420: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52428 size=28
    let mut pc: u32 = 0x82C52428;
    'dispatch: loop {
        match pc {
            0x82C52428 => {
    //   block [0x82C52428..0x82C52444)
	// 82C52428: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5242C: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C52430: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C52434: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52438: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C5243C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C52440: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52448 size=84
    let mut pc: u32 = 0x82C52448;
    'dispatch: loop {
        match pc {
            0x82C52448 => {
    //   block [0x82C52448..0x82C5249C)
	// 82C52448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5244C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52450: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52454: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52458: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5245C: 480058F5  bl 0x82c57d50
	ctx.lr = 0x82C52460;
	sub_82C57D50(ctx, base);
	// 82C52460: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52464: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C52468: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C5246C: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C52470: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C52474: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C52478: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C5247C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C52480: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C52484: 4E800421  bctrl
	ctx.lr = 0x82C52488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52488: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5248C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C524A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C524A0 size=48
    let mut pc: u32 = 0x82C524A0;
    'dispatch: loop {
        match pc {
            0x82C524A0 => {
    //   block [0x82C524A0..0x82C524D0)
	// 82C524A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C524A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C524A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C524AC: 480058A5  bl 0x82c57d50
	ctx.lr = 0x82C524B0;
	sub_82C57D50(ctx, base);
	// 82C524B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C524B4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C524B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C524BC: 4E800421  bctrl
	ctx.lr = 0x82C524C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C524C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C524C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C524C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C524CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C524D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C524D0 size=64
    let mut pc: u32 = 0x82C524D0;
    'dispatch: loop {
        match pc {
            0x82C524D0 => {
    //   block [0x82C524D0..0x82C52510)
	// 82C524D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C524D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C524D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C524DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C524E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C524E4: 4800586D  bl 0x82c57d50
	ctx.lr = 0x82C524E8;
	sub_82C57D50(ctx, base);
	// 82C524E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C524EC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C524F0: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C524F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C524F8: 4E800421  bctrl
	ctx.lr = 0x82C524FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C524FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C52500: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52504: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52508: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C5250C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52510 size=76
    let mut pc: u32 = 0x82C52510;
    'dispatch: loop {
        match pc {
            0x82C52510 => {
    //   block [0x82C52510..0x82C5255C)
	// 82C52510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52518: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5251C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C52524: 4800582D  bl 0x82c57d50
	ctx.lr = 0x82C52528;
	sub_82C57D50(ctx, base);
	// 82C52528: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5252C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52530: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52534: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C52538: 808A0034  lwz r4, 0x34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C5253C: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C52540: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C52544: 4E800421  bctrl
	ctx.lr = 0x82C52548;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52548: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5254C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52554: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52560 size=76
    let mut pc: u32 = 0x82C52560;
    'dispatch: loop {
        match pc {
            0x82C52560 => {
    //   block [0x82C52560..0x82C525AC)
	// 82C52560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5256C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C52574: 480057DD  bl 0x82c57d50
	ctx.lr = 0x82C52578;
	sub_82C57D50(ctx, base);
	// 82C52578: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5257C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52580: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52584: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C52588: 808A0034  lwz r4, 0x34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C5258C: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C52590: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C52594: 4E800421  bctrl
	ctx.lr = 0x82C52598;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52598: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5259C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C525A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C525A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C525A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C525B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C525B0 size=76
    let mut pc: u32 = 0x82C525B0;
    'dispatch: loop {
        match pc {
            0x82C525B0 => {
    //   block [0x82C525B0..0x82C525FC)
	// 82C525B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C525B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C525B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C525BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C525C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C525C4: 4800578D  bl 0x82c57d50
	ctx.lr = 0x82C525C8;
	sub_82C57D50(ctx, base);
	// 82C525C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C525CC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C525D0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C525D4: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C525D8: 808A0034  lwz r4, 0x34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C525DC: 81090018  lwz r8, 0x18(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C525E0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C525E4: 4E800421  bctrl
	ctx.lr = 0x82C525E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C525E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C525EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C525F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C525F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C525F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52600 size=76
    let mut pc: u32 = 0x82C52600;
    'dispatch: loop {
        match pc {
            0x82C52600 => {
    //   block [0x82C52600..0x82C5264C)
	// 82C52600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52608: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5260C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52610: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C52614: 4800573D  bl 0x82c57d50
	ctx.lr = 0x82C52618;
	sub_82C57D50(ctx, base);
	// 82C52618: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5261C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52620: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52624: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C52628: 808A0034  lwz r4, 0x34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C5262C: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C52630: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C52634: 4E800421  bctrl
	ctx.lr = 0x82C52638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52638: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5263C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52650 size=28
    let mut pc: u32 = 0x82C52650;
    'dispatch: loop {
        match pc {
            0x82C52650 => {
    //   block [0x82C52650..0x82C5266C)
	// 82C52650: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52654: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C52658: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C5265C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52660: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C52664: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C52668: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C52670 size=32
    let mut pc: u32 = 0x82C52670;
    'dispatch: loop {
        match pc {
            0x82C52670 => {
    //   block [0x82C52670..0x82C52690)
	// 82C52670: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52674: C0230008  lfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C52678: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5267C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C52680: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52684: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52688: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C5268C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C52690 size=32
    let mut pc: u32 = 0x82C52690;
    'dispatch: loop {
        match pc {
            0x82C52690 => {
    //   block [0x82C52690..0x82C526B0)
	// 82C52690: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52694: C0230008  lfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C52698: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C5269C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C526A0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C526A4: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C526A8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C526AC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C526B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C526B0 size=32
    let mut pc: u32 = 0x82C526B0;
    'dispatch: loop {
        match pc {
            0x82C526B0 => {
    //   block [0x82C526B0..0x82C526D0)
	// 82C526B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C526B4: C0230008  lfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C526B8: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C526BC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C526C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C526C4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C526C8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C526CC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C526D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C526D0 size=36
    let mut pc: u32 = 0x82C526D0;
    'dispatch: loop {
        match pc {
            0x82C526D0 => {
    //   block [0x82C526D0..0x82C526F4)
	// 82C526D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C526D4: C043000C  lfs f2, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C526D8: C0230008  lfs f1, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C526DC: 80830010  lwz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C526E0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C526E4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C526E8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C526EC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C526F0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C526F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C526F8 size=32
    let mut pc: u32 = 0x82C526F8;
    'dispatch: loop {
        match pc {
            0x82C526F8 => {
    //   block [0x82C526F8..0x82C52718)
	// 82C526F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C526FC: C0230008  lfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C52700: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C52704: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C52708: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C5270C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52710: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C52714: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52718 size=64
    let mut pc: u32 = 0x82C52718;
    'dispatch: loop {
        match pc {
            0x82C52718 => {
    //   block [0x82C52718..0x82C52758)
	// 82C52718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5271C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52720: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52724: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52728: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5272C: 48005625  bl 0x82c57d50
	ctx.lr = 0x82C52730;
	sub_82C57D50(ctx, base);
	// 82C52730: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52734: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52738: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5273C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C52740: 4E800421  bctrl
	ctx.lr = 0x82C52744;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52744: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C52748: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5274C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52750: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C52758 size=68
    let mut pc: u32 = 0x82C52758;
    'dispatch: loop {
        match pc {
            0x82C52758 => {
    //   block [0x82C52758..0x82C5279C)
	// 82C52758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5275C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52760: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52764: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5276C: 480055E5  bl 0x82c57d50
	ctx.lr = 0x82C52770;
	sub_82C57D50(ctx, base);
	// 82C52770: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52774: C03F0004  lfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C52778: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C5277C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C52780: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C52784: 4E800421  bctrl
	ctx.lr = 0x82C52788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52788: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5278C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52794: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C527A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C527A0 size=72
    let mut pc: u32 = 0x82C527A0;
    'dispatch: loop {
        match pc {
            0x82C527A0 => {
    //   block [0x82C527A0..0x82C527E8)
	// 82C527A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C527A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C527A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C527AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C527B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C527B4: 4800559D  bl 0x82c57d50
	ctx.lr = 0x82C527B8;
	sub_82C57D50(ctx, base);
	// 82C527B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C527BC: C03F000C  lfs f1, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C527C0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C527C4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C527C8: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C527CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C527D0: 4E800421  bctrl
	ctx.lr = 0x82C527D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C527D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C527D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C527DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C527E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C527E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C527E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C527E8 size=64
    let mut pc: u32 = 0x82C527E8;
    'dispatch: loop {
        match pc {
            0x82C527E8 => {
    //   block [0x82C527E8..0x82C52828)
	// 82C527E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C527EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C527F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C527F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C527F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C527FC: 48005555  bl 0x82c57d50
	ctx.lr = 0x82C52800;
	sub_82C57D50(ctx, base);
	// 82C52800: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52804: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52808: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C5280C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C52810: 4E800421  bctrl
	ctx.lr = 0x82C52814;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52814: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C52818: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5281C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52820: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52824: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52828 size=64
    let mut pc: u32 = 0x82C52828;
    'dispatch: loop {
        match pc {
            0x82C52828 => {
    //   block [0x82C52828..0x82C52868)
	// 82C52828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5282C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52834: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52838: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5283C: 48005515  bl 0x82c57d50
	ctx.lr = 0x82C52840;
	sub_82C57D50(ctx, base);
	// 82C52840: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52844: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52848: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C5284C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C52850: 4E800421  bctrl
	ctx.lr = 0x82C52854;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52854: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C52858: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5285C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52860: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52868 size=64
    let mut pc: u32 = 0x82C52868;
    'dispatch: loop {
        match pc {
            0x82C52868 => {
    //   block [0x82C52868..0x82C528A8)
	// 82C52868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5286C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52874: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52878: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C5287C: 480054D5  bl 0x82c57d50
	ctx.lr = 0x82C52880;
	sub_82C57D50(ctx, base);
	// 82C52880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52884: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52888: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C5288C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C52890: 4E800421  bctrl
	ctx.lr = 0x82C52894;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C52894: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C52898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5289C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C528A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C528A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C528A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C528A8 size=212
    let mut pc: u32 = 0x82C528A8;
    'dispatch: loop {
        match pc {
            0x82C528A8 => {
    //   block [0x82C528A8..0x82C5297C)
	// 82C528A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C528AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C528B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C528B4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C528B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C528BC: 48005495  bl 0x82c57d50
	ctx.lr = 0x82C528C0;
	sub_82C57D50(ctx, base);
	// 82C528C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C528C4: C03F0028  lfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C528C8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C528CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C528D0: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 82C528D4: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82C528D8: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C528DC: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82C528E0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82C528E4: 393F0004  addi r9, r31, 4
	ctx.r[9].s64 = ctx.r[31].s64 + 4;
	// 82C528E8: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C528EC: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 82C528F0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82C528F4: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82C528F8: 12802407  vcmpneb. (lvlx128) v20, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[52] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C528FC: 13A05C07  vcmpneb. (lvlx128) v29, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C52900: 13805407  vcmpneb. (lvlx128) v28, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C52904: 134B3C07  vcmpneb. (lvlx128) v26, v11, v7
	tmp.u32 = ctx.r[11].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[58] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C52908: 132A3C07  vcmpneb. (lvlx128) v25, v10, v7
	tmp.u32 = ctx.r[10].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[57] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C52980 size=124
    let mut pc: u32 = 0x82C52980;
    'dispatch: loop {
        match pc {
            0x82C52980 => {
    //   block [0x82C52980..0x82C529FC)
	// 82C52980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C5298C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C52994: 480053BD  bl 0x82c57d50
	ctx.lr = 0x82C52998;
	sub_82C57D50(ctx, base);
	// 82C52998: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82C5299C: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C529A0: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82C529A4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C529A8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C529AC: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 82C529B0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C529B4: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C529B8: 80A60020  lwz r5, 0x20(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C529BC: 13CB5407  vcmpneb. (lvlx128) v30, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C52A00 size=112
    let mut pc: u32 = 0x82C52A00;
    'dispatch: loop {
        match pc {
            0x82C52A00 => {
    //   block [0x82C52A00..0x82C52A70)
	// 82C52A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52A08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52A0C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52A10: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 82C52A14: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82C52A18: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C52A1C: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 82C52A20: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82C52A24: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C52A28: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C52A2C: 13CB5407  vcmpneb. (lvlx128) v30, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C52A70 size=120
    let mut pc: u32 = 0x82C52A70;
    'dispatch: loop {
        match pc {
            0x82C52A70 => {
    //   block [0x82C52A70..0x82C52AE8)
	// 82C52A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52A78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52A7C: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 82C52A80: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52A84: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82C52A88: 80A30014  lwz r5, 0x14(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C52A8C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C52A90: 88830018  lbz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C52A94: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 82C52A98: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82C52A9C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C52AA0: 80690034  lwz r3, 0x34(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C52AA4: 13CB5407  vcmpneb. (lvlx128) v30, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52AE8 size=56
    let mut pc: u32 = 0x82C52AE8;
    'dispatch: loop {
        match pc {
            0x82C52AE8 => {
    //   block [0x82C52AE8..0x82C52B20)
	// 82C52AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52AEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52AF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52AF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52AF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C52AFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C52B00: 4BBF2CB1  bl 0x828457b0
	ctx.lr = 0x82C52B04;
	sub_828457B0(ctx, base);
	// 82C52B04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C52B08: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C52B0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C52B10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52B14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52B18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52B1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52B20 size=308
    let mut pc: u32 = 0x82C52B20;
    'dispatch: loop {
        match pc {
            0x82C52B20 => {
    //   block [0x82C52B20..0x82C52C54)
	// 82C52B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52B28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52B2C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C52B30: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52C58 size=172
    let mut pc: u32 = 0x82C52C58;
    'dispatch: loop {
        match pc {
            0x82C52C58 => {
    //   block [0x82C52C58..0x82C52D04)
	// 82C52C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52C5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52C60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C52C64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52C68: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52D08 size=100
    let mut pc: u32 = 0x82C52D08;
    'dispatch: loop {
        match pc {
            0x82C52D08 => {
    //   block [0x82C52D08..0x82C52D6C)
	// 82C52D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52D10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C52D14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52D18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52D1C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52D20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C52D24: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C52D28: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C52D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52D30: 4B5EBC41  bl 0x8223e970
	ctx.lr = 0x82C52D34;
	sub_8223E970(ctx, base);
	// 82C52D34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C52D38: 419A0010  beq cr6, 0x82c52d48
	if ctx.cr[6].eq {
	pc = 0x82C52D48; continue 'dispatch;
	}
	// 82C52D3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C52D40: 394BCBEC  addi r10, r11, -0x3414
	ctx.r[10].s64 = ctx.r[11].s64 + -13332;
	// 82C52D44: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C52D48: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C52D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52D50: 4B5EBAE9  bl 0x8223e838
	ctx.lr = 0x82C52D54;
	sub_8223E838(ctx, base);
	// 82C52D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C52D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52D60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C52D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C52D70 size=172
    let mut pc: u32 = 0x82C52D70;
    'dispatch: loop {
        match pc {
            0x82C52D70 => {
    //   block [0x82C52D70..0x82C52E1C)
	// 82C52D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52D78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C52D7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52D80: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52E20 size=100
    let mut pc: u32 = 0x82C52E20;
    'dispatch: loop {
        match pc {
            0x82C52E20 => {
    //   block [0x82C52E20..0x82C52E84)
	// 82C52E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52E28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C52E2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52E30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52E34: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52E38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C52E3C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C52E40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C52E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52E48: 4B5EBB29  bl 0x8223e970
	ctx.lr = 0x82C52E4C;
	sub_8223E970(ctx, base);
	// 82C52E4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C52E50: 419A0010  beq cr6, 0x82c52e60
	if ctx.cr[6].eq {
	pc = 0x82C52E60; continue 'dispatch;
	}
	// 82C52E54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C52E58: 394BCC04  addi r10, r11, -0x33fc
	ctx.r[10].s64 = ctx.r[11].s64 + -13308;
	// 82C52E5C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C52E60: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C52E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52E68: 4B5EB9D1  bl 0x8223e838
	ctx.lr = 0x82C52E6C;
	sub_8223E838(ctx, base);
	// 82C52E6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C52E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52E78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C52E7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52E80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52E88 size=100
    let mut pc: u32 = 0x82C52E88;
    'dispatch: loop {
        match pc {
            0x82C52E88 => {
    //   block [0x82C52E88..0x82C52EEC)
	// 82C52E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C52E90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C52E94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C52E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52E9C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52EA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C52EA4: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C52EA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C52EAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52EB0: 4B5EBAC1  bl 0x8223e970
	ctx.lr = 0x82C52EB4;
	sub_8223E970(ctx, base);
	// 82C52EB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C52EB8: 419A0010  beq cr6, 0x82c52ec8
	if ctx.cr[6].eq {
	pc = 0x82C52EC8; continue 'dispatch;
	}
	// 82C52EBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C52EC0: 394BCC10  addi r10, r11, -0x33f0
	ctx.r[10].s64 = ctx.r[11].s64 + -13296;
	// 82C52EC4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C52EC8: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C52ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52ED0: 4B5EB969  bl 0x8223e838
	ctx.lr = 0x82C52ED4;
	sub_8223E838(ctx, base);
	// 82C52ED4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C52ED8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C52EDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C52EE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C52EE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C52EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52EF0 size=88
    let mut pc: u32 = 0x82C52EF0;
    'dispatch: loop {
        match pc {
            0x82C52EF0 => {
    //   block [0x82C52EF0..0x82C52F48)
	// 82C52EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52EF4: 48056519  bl 0x82ca940c
	ctx.lr = 0x82C52EF8;
	sub_82CA93D0(ctx, base);
	// 82C52EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52EFC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52F00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C52F04: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C52F08: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C52F0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C52F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52F14: 4B5EBA5D  bl 0x8223e970
	ctx.lr = 0x82C52F18;
	sub_8223E970(ctx, base);
	// 82C52F18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C52F1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C52F20: 419A0010  beq cr6, 0x82c52f30
	if ctx.cr[6].eq {
	pc = 0x82C52F30; continue 'dispatch;
	}
	// 82C52F24: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C52F28: 392ACC1C  addi r9, r10, -0x33e4
	ctx.r[9].s64 = ctx.r[10].s64 + -13284;
	// 82C52F2C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C52F30: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C52F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52F38: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C52F3C: 4B5EB8FD  bl 0x8223e838
	ctx.lr = 0x82C52F40;
	sub_8223E838(ctx, base);
	// 82C52F40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C52F44: 48056518  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52F48 size=88
    let mut pc: u32 = 0x82C52F48;
    'dispatch: loop {
        match pc {
            0x82C52F48 => {
    //   block [0x82C52F48..0x82C52FA0)
	// 82C52F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52F4C: 480564C1  bl 0x82ca940c
	ctx.lr = 0x82C52F50;
	sub_82CA93D0(ctx, base);
	// 82C52F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52F54: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52F58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C52F5C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C52F60: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C52F64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C52F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52F6C: 4B5EBA05  bl 0x8223e970
	ctx.lr = 0x82C52F70;
	sub_8223E970(ctx, base);
	// 82C52F70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C52F74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C52F78: 419A0010  beq cr6, 0x82c52f88
	if ctx.cr[6].eq {
	pc = 0x82C52F88; continue 'dispatch;
	}
	// 82C52F7C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C52F80: 392ACC28  addi r9, r10, -0x33d8
	ctx.r[9].s64 = ctx.r[10].s64 + -13272;
	// 82C52F84: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C52F88: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C52F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52F90: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C52F94: 4B5EB8A5  bl 0x8223e838
	ctx.lr = 0x82C52F98;
	sub_8223E838(ctx, base);
	// 82C52F98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C52F9C: 480564C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C52FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C52FA0 size=96
    let mut pc: u32 = 0x82C52FA0;
    'dispatch: loop {
        match pc {
            0x82C52FA0 => {
    //   block [0x82C52FA0..0x82C53000)
	// 82C52FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C52FA4: 48056465  bl 0x82ca9408
	ctx.lr = 0x82C52FA8;
	sub_82CA93D0(ctx, base);
	// 82C52FA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C52FAC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C52FB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C52FB4: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C52FB8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C52FBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C52FC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52FC4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C52FC8: 4B5EB9A9  bl 0x8223e970
	ctx.lr = 0x82C52FCC;
	sub_8223E970(ctx, base);
	// 82C52FCC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C52FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C52FD4: 419A0010  beq cr6, 0x82c52fe4
	if ctx.cr[6].eq {
	pc = 0x82C52FE4; continue 'dispatch;
	}
	// 82C52FD8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C52FDC: 392ACC34  addi r9, r10, -0x33cc
	ctx.r[9].s64 = ctx.r[10].s64 + -13260;
	// 82C52FE0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C52FE4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C52FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C52FEC: 9BAB0008  stb r29, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u8 ) };
	// 82C52FF0: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82C52FF4: 4B5EB845  bl 0x8223e838
	ctx.lr = 0x82C52FF8;
	sub_8223E838(ctx, base);
	// 82C52FF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C52FFC: 4805645C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53000 size=96
    let mut pc: u32 = 0x82C53000;
    'dispatch: loop {
        match pc {
            0x82C53000 => {
    //   block [0x82C53000..0x82C53060)
	// 82C53000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53004: 48056405  bl 0x82ca9408
	ctx.lr = 0x82C53008;
	sub_82CA93D0(ctx, base);
	// 82C53008: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5300C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53010: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C53014: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53018: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5301C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53024: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C53028: 4B5EB949  bl 0x8223e970
	ctx.lr = 0x82C5302C;
	sub_8223E970(ctx, base);
	// 82C5302C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C53030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C53034: 419A0010  beq cr6, 0x82c53044
	if ctx.cr[6].eq {
	pc = 0x82C53044; continue 'dispatch;
	}
	// 82C53038: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C5303C: 392ACC40  addi r9, r10, -0x33c0
	ctx.r[9].s64 = ctx.r[10].s64 + -13248;
	// 82C53040: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C53044: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C53048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5304C: 9BAB0008  stb r29, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u8 ) };
	// 82C53050: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82C53054: 4B5EB7E5  bl 0x8223e838
	ctx.lr = 0x82C53058;
	sub_8223E838(ctx, base);
	// 82C53058: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5305C: 480563FC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53060 size=100
    let mut pc: u32 = 0x82C53060;
    'dispatch: loop {
        match pc {
            0x82C53060 => {
    //   block [0x82C53060..0x82C530C4)
	// 82C53060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C53068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5306C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C53070: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53074: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53078: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5307C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53080: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53088: 4B5EB8E9  bl 0x8223e970
	ctx.lr = 0x82C5308C;
	sub_8223E970(ctx, base);
	// 82C5308C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53090: 419A0010  beq cr6, 0x82c530a0
	if ctx.cr[6].eq {
	pc = 0x82C530A0; continue 'dispatch;
	}
	// 82C53094: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53098: 394BCC4C  addi r10, r11, -0x33b4
	ctx.r[10].s64 = ctx.r[11].s64 + -13236;
	// 82C5309C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C530A0: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C530A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C530A8: 4B5EB791  bl 0x8223e838
	ctx.lr = 0x82C530AC;
	sub_8223E838(ctx, base);
	// 82C530AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C530B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C530B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C530B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C530BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C530C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C530C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C530C8 size=96
    let mut pc: u32 = 0x82C530C8;
    'dispatch: loop {
        match pc {
            0x82C530C8 => {
    //   block [0x82C530C8..0x82C53128)
	// 82C530C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C530CC: 4805633D  bl 0x82ca9408
	ctx.lr = 0x82C530D0;
	sub_82CA93D0(ctx, base);
	// 82C530D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C530D4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C530D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C530DC: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C530E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C530E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C530E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C530EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C530F0: 4B5EB881  bl 0x8223e970
	ctx.lr = 0x82C530F4;
	sub_8223E970(ctx, base);
	// 82C530F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C530F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C530FC: 419A0010  beq cr6, 0x82c5310c
	if ctx.cr[6].eq {
	pc = 0x82C5310C; continue 'dispatch;
	}
	// 82C53100: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C53104: 392ACC58  addi r9, r10, -0x33a8
	ctx.r[9].s64 = ctx.r[10].s64 + -13224;
	// 82C53108: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C5310C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C53110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53114: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C53118: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82C5311C: 4B5EB71D  bl 0x8223e838
	ctx.lr = 0x82C53120;
	sub_8223E838(ctx, base);
	// 82C53120: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C53124: 48056334  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53128 size=88
    let mut pc: u32 = 0x82C53128;
    'dispatch: loop {
        match pc {
            0x82C53128 => {
    //   block [0x82C53128..0x82C53180)
	// 82C53128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5312C: 480562E1  bl 0x82ca940c
	ctx.lr = 0x82C53130;
	sub_82CA93D0(ctx, base);
	// 82C53130: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53134: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53138: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5313C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53140: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C53144: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5314C: 4B5EB825  bl 0x8223e970
	ctx.lr = 0x82C53150;
	sub_8223E970(ctx, base);
	// 82C53150: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C53154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C53158: 419A0010  beq cr6, 0x82c53168
	if ctx.cr[6].eq {
	pc = 0x82C53168; continue 'dispatch;
	}
	// 82C5315C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C53160: 392ACC64  addi r9, r10, -0x339c
	ctx.r[9].s64 = ctx.r[10].s64 + -13212;
	// 82C53164: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C53168: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C5316C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53170: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C53174: 4B5EB6C5  bl 0x8223e838
	ctx.lr = 0x82C53178;
	sub_8223E838(ctx, base);
	// 82C53178: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5317C: 480562E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53180 size=88
    let mut pc: u32 = 0x82C53180;
    'dispatch: loop {
        match pc {
            0x82C53180 => {
    //   block [0x82C53180..0x82C531D8)
	// 82C53180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53184: 48056289  bl 0x82ca940c
	ctx.lr = 0x82C53188;
	sub_82CA93D0(ctx, base);
	// 82C53188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5318C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53190: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C53194: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53198: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5319C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C531A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C531A4: 4B5EB7CD  bl 0x8223e970
	ctx.lr = 0x82C531A8;
	sub_8223E970(ctx, base);
	// 82C531A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C531AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C531B0: 419A0010  beq cr6, 0x82c531c0
	if ctx.cr[6].eq {
	pc = 0x82C531C0; continue 'dispatch;
	}
	// 82C531B4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C531B8: 392ACC70  addi r9, r10, -0x3390
	ctx.r[9].s64 = ctx.r[10].s64 + -13200;
	// 82C531BC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C531C0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C531C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C531C8: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C531CC: 4B5EB66D  bl 0x8223e838
	ctx.lr = 0x82C531D0;
	sub_8223E838(ctx, base);
	// 82C531D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C531D4: 48056288  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C531D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C531D8 size=164
    let mut pc: u32 = 0x82C531D8;
    'dispatch: loop {
        match pc {
            0x82C531D8 => {
    //   block [0x82C531D8..0x82C5327C)
	// 82C531D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C531DC: 4805622D  bl 0x82ca9408
	ctx.lr = 0x82C531E0;
	sub_82CA93D0(ctx, base);
	// 82C531E0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53280 size=120
    let mut pc: u32 = 0x82C53280;
    'dispatch: loop {
        match pc {
            0x82C53280 => {
    //   block [0x82C53280..0x82C532F8)
	// 82C53280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53284: 48056179  bl 0x82ca93fc
	ctx.lr = 0x82C53288;
	sub_82CA93D0(ctx, base);
	// 82C53288: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5328C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53290: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C53294: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53298: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5329C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C532A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C532A4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C532A8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82C532AC: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82C532B0: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 82C532B4: 4B5EB6BD  bl 0x8223e970
	ctx.lr = 0x82C532B8;
	sub_8223E970(ctx, base);
	// 82C532B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C532BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C532C0: 419A0010  beq cr6, 0x82c532d0
	if ctx.cr[6].eq {
	pc = 0x82C532D0; continue 'dispatch;
	}
	// 82C532C4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C532C8: 392ACC88  addi r9, r10, -0x3378
	ctx.r[9].s64 = ctx.r[10].s64 + -13176;
	// 82C532CC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C532D0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C532D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C532D8: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C532DC: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82C532E0: 936B0010  stw r27, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	// 82C532E4: 934B0014  stw r26, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 82C532E8: 932B0018  stw r25, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[25].u32 ) };
	// 82C532EC: 4B5EB54D  bl 0x8223e838
	ctx.lr = 0x82C532F0;
	sub_8223E838(ctx, base);
	// 82C532F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C532F4: 48056158  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C532F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C532F8 size=84
    let mut pc: u32 = 0x82C532F8;
    'dispatch: loop {
        match pc {
            0x82C532F8 => {
    //   block [0x82C532F8..0x82C5334C)
	// 82C532F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C532FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C53300: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C53304: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53308: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5330C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53310: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53318: 4B5EB659  bl 0x8223e970
	ctx.lr = 0x82C5331C;
	sub_8223E970(ctx, base);
	// 82C5331C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53320: 419A0010  beq cr6, 0x82c53330
	if ctx.cr[6].eq {
	pc = 0x82C53330; continue 'dispatch;
	}
	// 82C53324: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53328: 394BCC94  addi r10, r11, -0x336c
	ctx.r[10].s64 = ctx.r[11].s64 + -13164;
	// 82C5332C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53334: 4B5EB505  bl 0x8223e838
	ctx.lr = 0x82C53338;
	sub_8223E838(ctx, base);
	// 82C53338: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C5333C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C53340: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C53344: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C53348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53350 size=100
    let mut pc: u32 = 0x82C53350;
    'dispatch: loop {
        match pc {
            0x82C53350 => {
    //   block [0x82C53350..0x82C533B4)
	// 82C53350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C53358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5335C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C53360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53364: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53368: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5336C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53370: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53378: 4B5EB5F9  bl 0x8223e970
	ctx.lr = 0x82C5337C;
	sub_8223E970(ctx, base);
	// 82C5337C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53380: 419A0010  beq cr6, 0x82c53390
	if ctx.cr[6].eq {
	pc = 0x82C53390; continue 'dispatch;
	}
	// 82C53384: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53388: 394BCCA0  addi r10, r11, -0x3360
	ctx.r[10].s64 = ctx.r[11].s64 + -13152;
	// 82C5338C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53390: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C53394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53398: 4B5EB4A1  bl 0x8223e838
	ctx.lr = 0x82C5339C;
	sub_8223E838(ctx, base);
	// 82C5339C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C533A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C533A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C533A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C533AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C533B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C533B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C533B8 size=88
    let mut pc: u32 = 0x82C533B8;
    'dispatch: loop {
        match pc {
            0x82C533B8 => {
    //   block [0x82C533B8..0x82C53410)
	// 82C533B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C533BC: 48056051  bl 0x82ca940c
	ctx.lr = 0x82C533C0;
	sub_82CA93D0(ctx, base);
	// 82C533C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C533C4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C533C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C533CC: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C533D0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C533D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C533D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C533DC: 4B5EB595  bl 0x8223e970
	ctx.lr = 0x82C533E0;
	sub_8223E970(ctx, base);
	// 82C533E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C533E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C533E8: 419A0010  beq cr6, 0x82c533f8
	if ctx.cr[6].eq {
	pc = 0x82C533F8; continue 'dispatch;
	}
	// 82C533EC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C533F0: 392ACCAC  addi r9, r10, -0x3354
	ctx.r[9].s64 = ctx.r[10].s64 + -13140;
	// 82C533F4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C533F8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C533FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53400: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C53404: 4B5EB435  bl 0x8223e838
	ctx.lr = 0x82C53408;
	sub_8223E838(ctx, base);
	// 82C53408: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5340C: 48056050  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53410 size=88
    let mut pc: u32 = 0x82C53410;
    'dispatch: loop {
        match pc {
            0x82C53410 => {
    //   block [0x82C53410..0x82C53468)
	// 82C53410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53414: 48055FF9  bl 0x82ca940c
	ctx.lr = 0x82C53418;
	sub_82CA93D0(ctx, base);
	// 82C53418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5341C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53420: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C53424: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53428: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5342C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53434: 4B5EB53D  bl 0x8223e970
	ctx.lr = 0x82C53438;
	sub_8223E970(ctx, base);
	// 82C53438: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C5343C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C53440: 419A0010  beq cr6, 0x82c53450
	if ctx.cr[6].eq {
	pc = 0x82C53450; continue 'dispatch;
	}
	// 82C53444: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C53448: 392ACCB8  addi r9, r10, -0x3348
	ctx.r[9].s64 = ctx.r[10].s64 + -13128;
	// 82C5344C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C53450: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C53454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53458: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C5345C: 4B5EB3DD  bl 0x8223e838
	ctx.lr = 0x82C53460;
	sub_8223E838(ctx, base);
	// 82C53460: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C53464: 48055FF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53468 size=88
    let mut pc: u32 = 0x82C53468;
    'dispatch: loop {
        match pc {
            0x82C53468 => {
    //   block [0x82C53468..0x82C534C0)
	// 82C53468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5346C: 48055FA1  bl 0x82ca940c
	ctx.lr = 0x82C53470;
	sub_82CA93D0(ctx, base);
	// 82C53470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53474: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53478: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5347C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53480: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C53484: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5348C: 4B5EB4E5  bl 0x8223e970
	ctx.lr = 0x82C53490;
	sub_8223E970(ctx, base);
	// 82C53490: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C53494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C53498: 419A0010  beq cr6, 0x82c534a8
	if ctx.cr[6].eq {
	pc = 0x82C534A8; continue 'dispatch;
	}
	// 82C5349C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C534A0: 392ACCC4  addi r9, r10, -0x333c
	ctx.r[9].s64 = ctx.r[10].s64 + -13116;
	// 82C534A4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C534A8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C534AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C534B0: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C534B4: 4B5EB385  bl 0x8223e838
	ctx.lr = 0x82C534B8;
	sub_8223E838(ctx, base);
	// 82C534B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C534BC: 48055FA0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C534C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C534C0 size=88
    let mut pc: u32 = 0x82C534C0;
    'dispatch: loop {
        match pc {
            0x82C534C0 => {
    //   block [0x82C534C0..0x82C53518)
	// 82C534C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C534C4: 48055F49  bl 0x82ca940c
	ctx.lr = 0x82C534C8;
	sub_82CA93D0(ctx, base);
	// 82C534C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C534CC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C534D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C534D4: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C534D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C534DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C534E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C534E4: 4B5EB48D  bl 0x8223e970
	ctx.lr = 0x82C534E8;
	sub_8223E970(ctx, base);
	// 82C534E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C534EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C534F0: 419A0010  beq cr6, 0x82c53500
	if ctx.cr[6].eq {
	pc = 0x82C53500; continue 'dispatch;
	}
	// 82C534F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C534F8: 392ACCD0  addi r9, r10, -0x3330
	ctx.r[9].s64 = ctx.r[10].s64 + -13104;
	// 82C534FC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C53500: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C53504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53508: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C5350C: 4B5EB32D  bl 0x8223e838
	ctx.lr = 0x82C53510;
	sub_8223E838(ctx, base);
	// 82C53510: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C53514: 48055F48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53518 size=88
    let mut pc: u32 = 0x82C53518;
    'dispatch: loop {
        match pc {
            0x82C53518 => {
    //   block [0x82C53518..0x82C53570)
	// 82C53518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5351C: 48055EF1  bl 0x82ca940c
	ctx.lr = 0x82C53520;
	sub_82CA93D0(ctx, base);
	// 82C53520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53524: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53528: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5352C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53530: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C53534: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5353C: 4B5EB435  bl 0x8223e970
	ctx.lr = 0x82C53540;
	sub_8223E970(ctx, base);
	// 82C53540: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C53544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C53548: 419A0010  beq cr6, 0x82c53558
	if ctx.cr[6].eq {
	pc = 0x82C53558; continue 'dispatch;
	}
	// 82C5354C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C53550: 392ACCDC  addi r9, r10, -0x3324
	ctx.r[9].s64 = ctx.r[10].s64 + -13092;
	// 82C53554: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C53558: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C5355C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53560: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C53564: 4B5EB2D5  bl 0x8223e838
	ctx.lr = 0x82C53568;
	sub_8223E838(ctx, base);
	// 82C53568: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5356C: 48055EF0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C53570 size=100
    let mut pc: u32 = 0x82C53570;
    'dispatch: loop {
        match pc {
            0x82C53570 => {
    //   block [0x82C53570..0x82C535D4)
	// 82C53570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53574: 48055E99  bl 0x82ca940c
	ctx.lr = 0x82C53578;
	sub_82CA93D0(ctx, base);
	// 82C53578: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C5357C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53580: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53584: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C53588: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5358C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53590: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53598: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C5359C: 4B5EB3D5  bl 0x8223e970
	ctx.lr = 0x82C535A0;
	sub_8223E970(ctx, base);
	// 82C535A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C535A4: 419A0010  beq cr6, 0x82c535b4
	if ctx.cr[6].eq {
	pc = 0x82C535B4; continue 'dispatch;
	}
	// 82C535A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C535AC: 394BCCE8  addi r10, r11, -0x3318
	ctx.r[10].s64 = ctx.r[11].s64 + -13080;
	// 82C535B0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C535B4: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C535B8: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C535BC: 93A3000C  stw r29, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C535C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C535C4: 4B5EB275  bl 0x8223e838
	ctx.lr = 0x82C535C8;
	sub_8223E838(ctx, base);
	// 82C535C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C535CC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C535D0: 48055E8C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C535D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C535D8 size=100
    let mut pc: u32 = 0x82C535D8;
    'dispatch: loop {
        match pc {
            0x82C535D8 => {
    //   block [0x82C535D8..0x82C5363C)
	// 82C535D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C535DC: 48055E31  bl 0x82ca940c
	ctx.lr = 0x82C535E0;
	sub_82CA93D0(ctx, base);
	// 82C535E0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C535E4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C535E8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C535EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C535F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C535F4: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C535F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C535FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53600: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C53604: 4B5EB36D  bl 0x8223e970
	ctx.lr = 0x82C53608;
	sub_8223E970(ctx, base);
	// 82C53608: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C5360C: 419A0010  beq cr6, 0x82c5361c
	if ctx.cr[6].eq {
	pc = 0x82C5361C; continue 'dispatch;
	}
	// 82C53610: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53614: 394BCCF4  addi r10, r11, -0x330c
	ctx.r[10].s64 = ctx.r[11].s64 + -13068;
	// 82C53618: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C5361C: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C53620: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C53624: 93A3000C  stw r29, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C53628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C5362C: 4B5EB20D  bl 0x8223e838
	ctx.lr = 0x82C53630;
	sub_8223E838(ctx, base);
	// 82C53630: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C53634: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C53638: 48055E24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C53640 size=100
    let mut pc: u32 = 0x82C53640;
    'dispatch: loop {
        match pc {
            0x82C53640 => {
    //   block [0x82C53640..0x82C536A4)
	// 82C53640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53644: 48055DC9  bl 0x82ca940c
	ctx.lr = 0x82C53648;
	sub_82CA93D0(ctx, base);
	// 82C53648: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C5364C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53650: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53654: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C53658: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5365C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53660: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53668: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C5366C: 4B5EB305  bl 0x8223e970
	ctx.lr = 0x82C53670;
	sub_8223E970(ctx, base);
	// 82C53670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53674: 419A0010  beq cr6, 0x82c53684
	if ctx.cr[6].eq {
	pc = 0x82C53684; continue 'dispatch;
	}
	// 82C53678: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5367C: 394BCD00  addi r10, r11, -0x3300
	ctx.r[10].s64 = ctx.r[11].s64 + -13056;
	// 82C53680: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53684: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C53688: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C5368C: 93A3000C  stw r29, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C53690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53694: 4B5EB1A5  bl 0x8223e838
	ctx.lr = 0x82C53698;
	sub_8223E838(ctx, base);
	// 82C53698: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5369C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C536A0: 48055DBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C536A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C536A8 size=116
    let mut pc: u32 = 0x82C536A8;
    'dispatch: loop {
        match pc {
            0x82C536A8 => {
    //   block [0x82C536A8..0x82C5371C)
	// 82C536A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C536AC: 48055D61  bl 0x82ca940c
	ctx.lr = 0x82C536B0;
	sub_82CA93D0(ctx, base);
	// 82C536B0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82C536B4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C536B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C536BC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C536C0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C536C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C536C8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82C536CC: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C536D0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C536D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C536D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C536DC: 4B5EB295  bl 0x8223e970
	ctx.lr = 0x82C536E0;
	sub_8223E970(ctx, base);
	// 82C536E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C536E4: 419A0010  beq cr6, 0x82c536f4
	if ctx.cr[6].eq {
	pc = 0x82C536F4; continue 'dispatch;
	}
	// 82C536E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C536EC: 394BCD0C  addi r10, r11, -0x32f4
	ctx.r[10].s64 = ctx.r[11].s64 + -13044;
	// 82C536F0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C536F4: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C536F8: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C536FC: D3C3000C  stfs f30, 0xc(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C53700: 93A30010  stw r29, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82C53704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53708: 4B5EB131  bl 0x8223e838
	ctx.lr = 0x82C5370C;
	sub_8223E838(ctx, base);
	// 82C5370C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C53710: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82C53714: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C53718: 48055D44  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C53720 size=100
    let mut pc: u32 = 0x82C53720;
    'dispatch: loop {
        match pc {
            0x82C53720 => {
    //   block [0x82C53720..0x82C53784)
	// 82C53720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53724: 48055CE9  bl 0x82ca940c
	ctx.lr = 0x82C53728;
	sub_82CA93D0(ctx, base);
	// 82C53728: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C5372C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53730: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53734: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C53738: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C5373C: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53740: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53748: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C5374C: 4B5EB225  bl 0x8223e970
	ctx.lr = 0x82C53750;
	sub_8223E970(ctx, base);
	// 82C53750: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53754: 419A0010  beq cr6, 0x82c53764
	if ctx.cr[6].eq {
	pc = 0x82C53764; continue 'dispatch;
	}
	// 82C53758: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C5375C: 394BCD18  addi r10, r11, -0x32e8
	ctx.r[10].s64 = ctx.r[11].s64 + -13032;
	// 82C53760: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53764: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C53768: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C5376C: 93A3000C  stw r29, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C53770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53774: 4B5EB0C5  bl 0x8223e838
	ctx.lr = 0x82C53778;
	sub_8223E838(ctx, base);
	// 82C53778: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C5377C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C53780: 48055CDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53788 size=116
    let mut pc: u32 = 0x82C53788;
    'dispatch: loop {
        match pc {
            0x82C53788 => {
    //   block [0x82C53788..0x82C537FC)
	// 82C53788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5378C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C53790: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C53794: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C53798: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5379C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C537A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C537A4: 894B5100  lbz r10, 0x5100(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20736 as u32) ) } as u64;
	// 82C537A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C537AC: 419A0038  beq cr6, 0x82c537e4
	if ctx.cr[6].eq {
	pc = 0x82C537E4; continue 'dispatch;
	}
	// 82C537B0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C537B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C537B8: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C537BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C537C0: 4B5EB1B1  bl 0x8223e970
	ctx.lr = 0x82C537C4;
	sub_8223E970(ctx, base);
	// 82C537C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C537C8: 419A0010  beq cr6, 0x82c537d8
	if ctx.cr[6].eq {
	pc = 0x82C537D8; continue 'dispatch;
	}
	// 82C537CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C537D0: 394BCD24  addi r10, r11, -0x32dc
	ctx.r[10].s64 = ctx.r[11].s64 + -13020;
	// 82C537D4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C537D8: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C537DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C537E0: 4B5EB059  bl 0x8223e838
	ctx.lr = 0x82C537E4;
	sub_8223E838(ctx, base);
	// 82C537E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C537E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C537EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C537F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C537F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C537F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C53800 size=116
    let mut pc: u32 = 0x82C53800;
    'dispatch: loop {
        match pc {
            0x82C53800 => {
    //   block [0x82C53800..0x82C53874)
	// 82C53800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C53808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C5380C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C53810: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C53814: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53818: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5381C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C53820: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C53824: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53828: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C5382C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53830: 4B5EB141  bl 0x8223e970
	ctx.lr = 0x82C53834;
	sub_8223E970(ctx, base);
	// 82C53834: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53838: 419A0010  beq cr6, 0x82c53848
	if ctx.cr[6].eq {
	pc = 0x82C53848; continue 'dispatch;
	}
	// 82C5383C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53840: 394BCD30  addi r10, r11, -0x32d0
	ctx.r[10].s64 = ctx.r[11].s64 + -13008;
	// 82C53844: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53848: D3E30004  stfs f31, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C5384C: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82C53850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53854: 4B5EAFE5  bl 0x8223e838
	ctx.lr = 0x82C53858;
	sub_8223E838(ctx, base);
	// 82C53858: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C5385C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C53860: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C53864: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C53868: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5386C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C53870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C53878 size=100
    let mut pc: u32 = 0x82C53878;
    'dispatch: loop {
        match pc {
            0x82C53878 => {
    //   block [0x82C53878..0x82C538DC)
	// 82C53878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5387C: 48055B91  bl 0x82ca940c
	ctx.lr = 0x82C53880;
	sub_82CA93D0(ctx, base);
	// 82C53880: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C53884: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53888: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C5388C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C53890: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C53894: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53898: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C5389C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C538A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C538A4: 4B5EB0CD  bl 0x8223e970
	ctx.lr = 0x82C538A8;
	sub_8223E970(ctx, base);
	// 82C538A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C538AC: 419A0010  beq cr6, 0x82c538bc
	if ctx.cr[6].eq {
	pc = 0x82C538BC; continue 'dispatch;
	}
	// 82C538B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C538B4: 394BCD3C  addi r10, r11, -0x32c4
	ctx.r[10].s64 = ctx.r[11].s64 + -12996;
	// 82C538B8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C538BC: D3E3000C  stfs f31, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C538C0: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C538C4: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C538C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C538CC: 4B5EAF6D  bl 0x8223e838
	ctx.lr = 0x82C538D0;
	sub_8223E838(ctx, base);
	// 82C538D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C538D4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C538D8: 48055B84  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C538E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C538E0 size=100
    let mut pc: u32 = 0x82C538E0;
    'dispatch: loop {
        match pc {
            0x82C538E0 => {
    //   block [0x82C538E0..0x82C53944)
	// 82C538E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C538E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C538E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C538EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C538F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C538F4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C538F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C538FC: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53900: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53908: 4B5EB069  bl 0x8223e970
	ctx.lr = 0x82C5390C;
	sub_8223E970(ctx, base);
	// 82C5390C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53910: 419A0010  beq cr6, 0x82c53920
	if ctx.cr[6].eq {
	pc = 0x82C53920; continue 'dispatch;
	}
	// 82C53914: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53918: 394BCD48  addi r10, r11, -0x32b8
	ctx.r[10].s64 = ctx.r[11].s64 + -12984;
	// 82C5391C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53920: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C53924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53928: 4B5EAF11  bl 0x8223e838
	ctx.lr = 0x82C5392C;
	sub_8223E838(ctx, base);
	// 82C5392C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C53930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C53934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C53938: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C5393C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C53940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53948 size=100
    let mut pc: u32 = 0x82C53948;
    'dispatch: loop {
        match pc {
            0x82C53948 => {
    //   block [0x82C53948..0x82C539AC)
	// 82C53948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C5394C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C53950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C53954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C53958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C5395C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53960: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C53964: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53968: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C5396C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53970: 4B5EB001  bl 0x8223e970
	ctx.lr = 0x82C53974;
	sub_8223E970(ctx, base);
	// 82C53974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53978: 419A0010  beq cr6, 0x82c53988
	if ctx.cr[6].eq {
	pc = 0x82C53988; continue 'dispatch;
	}
	// 82C5397C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53980: 394BCD54  addi r10, r11, -0x32ac
	ctx.r[10].s64 = ctx.r[11].s64 + -12972;
	// 82C53984: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53988: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C5398C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53990: 4B5EAEA9  bl 0x8223e838
	ctx.lr = 0x82C53994;
	sub_8223E838(ctx, base);
	// 82C53994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C53998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C5399C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C539A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C539A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C539A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C539B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C539B0 size=100
    let mut pc: u32 = 0x82C539B0;
    'dispatch: loop {
        match pc {
            0x82C539B0 => {
    //   block [0x82C539B0..0x82C53A14)
	// 82C539B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C539B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C539B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C539BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C539C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C539C4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C539C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C539CC: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C539D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C539D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C539D8: 4B5EAF99  bl 0x8223e970
	ctx.lr = 0x82C539DC;
	sub_8223E970(ctx, base);
	// 82C539DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C539E0: 419A0010  beq cr6, 0x82c539f0
	if ctx.cr[6].eq {
	pc = 0x82C539F0; continue 'dispatch;
	}
	// 82C539E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C539E8: 394BCD60  addi r10, r11, -0x32a0
	ctx.r[10].s64 = ctx.r[11].s64 + -12960;
	// 82C539EC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C539F0: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C539F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C539F8: 4B5EAE41  bl 0x8223e838
	ctx.lr = 0x82C539FC;
	sub_8223E838(ctx, base);
	// 82C539FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C53A00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C53A04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C53A08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C53A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C53A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53A18 size=100
    let mut pc: u32 = 0x82C53A18;
    'dispatch: loop {
        match pc {
            0x82C53A18 => {
    //   block [0x82C53A18..0x82C53A7C)
	// 82C53A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C53A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C53A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C53A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53A2C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53A30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C53A34: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53A38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53A40: 4B5EAF31  bl 0x8223e970
	ctx.lr = 0x82C53A44;
	sub_8223E970(ctx, base);
	// 82C53A44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53A48: 419A0010  beq cr6, 0x82c53a58
	if ctx.cr[6].eq {
	pc = 0x82C53A58; continue 'dispatch;
	}
	// 82C53A4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53A50: 394BCD6C  addi r10, r11, -0x3294
	ctx.r[10].s64 = ctx.r[11].s64 + -12948;
	// 82C53A54: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53A58: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C53A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53A60: 4B5EADD9  bl 0x8223e838
	ctx.lr = 0x82C53A64;
	sub_8223E838(ctx, base);
	// 82C53A64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C53A68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C53A6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C53A70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C53A74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C53A78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53A80 size=72
    let mut pc: u32 = 0x82C53A80;
    'dispatch: loop {
        match pc {
            0x82C53A80 => {
    //   block [0x82C53A80..0x82C53AC8)
	// 82C53A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C53A88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C53A8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53A90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C53A94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53A98: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82C53A9C: 392BA0E8  addi r9, r11, -0x5f18
	ctx.r[9].s64 = ctx.r[11].s64 + -24344;
	// 82C53AA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C53AA4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C53AA8: 419A000C  beq cr6, 0x82c53ab4
	if ctx.cr[6].eq {
	pc = 0x82C53AB4; continue 'dispatch;
	}
	// 82C53AAC: 4BBF1D05  bl 0x828457b0
	ctx.lr = 0x82C53AB0;
	sub_828457B0(ctx, base);
	// 82C53AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53AB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C53AB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C53ABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C53AC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C53AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C53AC8 size=120
    let mut pc: u32 = 0x82C53AC8;
    'dispatch: loop {
        match pc {
            0x82C53AC8 => {
    //   block [0x82C53AC8..0x82C53B40)
	// 82C53AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C53ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C53AD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C53AD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C53AD8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53ADC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C53AE0: 3BEB5108  addi r31, r11, 0x5108
	ctx.r[31].s64 = ctx.r[11].s64 + 20744;
	// 82C53AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53AE8: 4B5EAE89  bl 0x8223e970
	ctx.lr = 0x82C53AEC;
	sub_8223E970(ctx, base);
	// 82C53AEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C53AF0: 419A0010  beq cr6, 0x82c53b00
	if ctx.cr[6].eq {
	pc = 0x82C53B00; continue 'dispatch;
	}
	// 82C53AF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53AF8: 394BCD78  addi r10, r11, -0x3288
	ctx.r[10].s64 = ctx.r[11].s64 + -12936;
	// 82C53AFC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C53B04: 4B5EAD35  bl 0x8223e838
	ctx.lr = 0x82C53B08;
	sub_8223E838(ctx, base);
	// 82C53B08: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C53B0C: 390B515C  addi r8, r11, 0x515c
	ctx.r[8].s64 = ctx.r[11].s64 + 20828;
	// 82C53B10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82C53B14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82C53B18: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82C53B1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C53B20: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82C53B24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82C53B28: 4082FFE8  bne 0x82c53b10
	if !ctx.cr[0].eq {
	pc = 0x82C53B10; continue 'dispatch;
	}
	// 82C53B2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C53B30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C53B34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C53B38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C53B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C53B40 size=16
    let mut pc: u32 = 0x82C53B40;
    'dispatch: loop {
        match pc {
            0x82C53B40 => {
    //   block [0x82C53B40..0x82C53B50)
	// 82C53B40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C53B44: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C53B48: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C53B4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C53B50 size=16
    let mut pc: u32 = 0x82C53B50;
    'dispatch: loop {
        match pc {
            0x82C53B50 => {
    //   block [0x82C53B50..0x82C53B60)
	// 82C53B50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C53B54: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C53B58: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82C53B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C53B60 size=76
    let mut pc: u32 = 0x82C53B60;
    'dispatch: loop {
        match pc {
            0x82C53B60 => {
    //   block [0x82C53B60..0x82C53BAC)
	// 82C53B60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C53B64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C53B68: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C53B6C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C53B70: C00A0C14  lfs f0, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C53B74: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82C53B78: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C53B7C: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82C53B80: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C53B84: 9963001D  stb r11, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[11].u8 ) };
	// 82C53B88: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C53B8C: 9963001E  stb r11, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[11].u8 ) };
	// 82C53B90: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C53B94: 9963001F  stb r11, 0x1f(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(31 as u32), ctx.r[11].u8 ) };
	// 82C53B98: F9630020  std r11, 0x20(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 82C53B9C: F9630028  std r11, 0x28(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	// 82C53BA0: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82C53BA4: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82C53BA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C53BB0 size=36
    let mut pc: u32 = 0x82C53BB0;
    'dispatch: loop {
        match pc {
            0x82C53BB0 => {
    //   block [0x82C53BB0..0x82C53BD4)
	// 82C53BB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C53BB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C53BB8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C53BBC: C00A0C14  lfs f0, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C53BC0: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C53BC4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C53BC8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C53BCC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C53BD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C53BD8 size=28
    let mut pc: u32 = 0x82C53BD8;
    'dispatch: loop {
        match pc {
            0x82C53BD8 => {
    //   block [0x82C53BD8..0x82C53BF4)
	// 82C53BD8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C53BDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C53BE0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C53BE4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C53BE8: C00A0C14  lfs f0, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C53BEC: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C53BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C53BF8 size=140
    let mut pc: u32 = 0x82C53BF8;
    'dispatch: loop {
        match pc {
            0x82C53BF8 => {
    //   block [0x82C53BF8..0x82C53C84)
	// 82C53BF8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C53BFC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C53C00: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C53C04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C53C08: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C53C0C: 38C7CD98  addi r6, r7, -0x3268
	ctx.r[6].s64 = ctx.r[7].s64 + -12904;
	// 82C53C10: C1A90C14  lfs f13, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C53C14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82C53C18: C0080C18  lfs f0, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C53C1C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82C53C20: D1A3001C  stfs f13, 0x1c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C53C24: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C53C28: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82C53C2C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C53C30: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C53C34: D1A3002C  stfs f13, 0x2c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C53C38: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C53C3C: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82C53C40: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C53C44: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C53C48: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C53C4C: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82C53C50: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82C53C54: 91430034  stw r10, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82C53C58: 90A30038  stw r5, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[5].u32 ) };
	// 82C53C5C: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82C53C60: 90830040  stw r4, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[4].u32 ) };
	// 82C53C64: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82C53C68: 99430048  stb r10, 0x48(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[10].u8 ) };
	// 82C53C6C: 99430049  stb r10, 0x49(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(73 as u32), ctx.r[10].u8 ) };
	// 82C53C70: 9963004A  stb r11, 0x4a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(74 as u32), ctx.r[11].u8 ) };
	// 82C53C74: 9963004B  stb r11, 0x4b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(75 as u32), ctx.r[11].u8 ) };
	// 82C53C78: 9963004C  stb r11, 0x4c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u8 ) };
	// 82C53C7C: 9943004D  stb r10, 0x4d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(77 as u32), ctx.r[10].u8 ) };
	// 82C53C80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C53C88 size=16
    let mut pc: u32 = 0x82C53C88;
    'dispatch: loop {
        match pc {
            0x82C53C88 => {
    //   block [0x82C53C88..0x82C53C98)
	// 82C53C88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C53C8C: 394BCD98  addi r10, r11, -0x3268
	ctx.r[10].s64 = ctx.r[11].s64 + -12904;
	// 82C53C90: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C53C94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C53C98 size=12
    let mut pc: u32 = 0x82C53C98;
    'dispatch: loop {
        match pc {
            0x82C53C98 => {
    //   block [0x82C53C98..0x82C53CA4)
	// 82C53C98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C53C9C: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82C53CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C53CA8 size=8
    let mut pc: u32 = 0x82C53CA8;
    'dispatch: loop {
        match pc {
            0x82C53CA8 => {
    //   block [0x82C53CA8..0x82C53CB0)
	// 82C53CA8: 90830080  stw r4, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[4].u32 ) };
	// 82C53CAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C53CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C53CB0 size=12
    let mut pc: u32 = 0x82C53CB0;
    'dispatch: loop {
        match pc {
            0x82C53CB0 => {
    //   block [0x82C53CB0..0x82C53CBC)
	// 82C53CB0: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


