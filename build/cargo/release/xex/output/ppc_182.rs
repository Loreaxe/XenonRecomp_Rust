pub fn sub_82EC0C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC0C98 size=84
    let mut pc: u32 = 0x82EC0C98;
    'dispatch: loop {
        match pc {
            0x82EC0C98 => {
    //   block [0x82EC0C98..0x82EC0CEC)
	// 82EC0C98: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EC0C9C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EC0CA0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC0CA4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EC0CA8: 816AD478  lwz r11, -0x2b88(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11144 as u32) ) } as u64;
	// 82EC0CAC: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC0CB0: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EC0CB4: 3909D46C  addi r8, r9, -0x2b94
	ctx.r[8].s64 = ctx.r[9].s64 + -11156;
	// 82EC0CB8: 40820020  bne 0x82ec0cd8
	if !ctx.cr[0].eq {
	pc = 0x82EC0CD8; continue 'dispatch;
	}
	// 82EC0CBC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EC0CC0: 916AD478  stw r11, -0x2b88(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-11144 as u32), ctx.r[11].u32 ) };
	// 82EC0CC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0CC8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0CCC: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC0CD0: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC0CD4: D0080008  stfs f0, 8(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC0CD8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC0CDC: 394BDAC0  addi r10, r11, -0x2540
	ctx.r[10].s64 = ctx.r[11].s64 + -9536;
	// 82EC0CE0: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC0CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC0CE8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0CEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC0CEC size=40
    let mut pc: u32 = 0x82EC0CEC;
    'dispatch: loop {
        match pc {
            0x82EC0CEC => {
    //   block [0x82EC0CEC..0x82EC0D14)
	// 82EC0CEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0CF0: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0CF4: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC0CF8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EC0CFC: C00B0C4C  lfs f0, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0D00: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0D04: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0D08: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0D0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC0D10: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0D14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0D14 size=4
    let mut pc: u32 = 0x82EC0D14;
    'dispatch: loop {
        match pc {
            0x82EC0D14 => {
    //   block [0x82EC0D14..0x82EC0D18)
	// 82EC0D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0D18 size=12
    let mut pc: u32 = 0x82EC0D18;
    'dispatch: loop {
        match pc {
            0x82EC0D18 => {
    //   block [0x82EC0D18..0x82EC0D24)
	// 82EC0D18: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC0D1C: 386BB38C  addi r3, r11, -0x4c74
	ctx.r[3].s64 = ctx.r[11].s64 + -19572;
	// 82EC0D20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0D28 size=92
    let mut pc: u32 = 0x82EC0D28;
    'dispatch: loop {
        match pc {
            0x82EC0D28 => {
    //   block [0x82EC0D28..0x82EC0D84)
	// 82EC0D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0D2C: 4BDE86E1  bl 0x82ca940c
	ctx.lr = 0x82EC0D30;
	sub_82CA93D0(ctx, base);
	// 82EC0D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0D34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0D38: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC0D3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0D40: 4B755BE9  bl 0x82616928
	ctx.lr = 0x82EC0D44;
	sub_82616928(ctx, base);
	// 82EC0D44: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0D48: 41820030  beq 0x82ec0d78
	if ctx.cr[0].eq {
	pc = 0x82EC0D78; continue 'dispatch;
	}
	// 82EC0D4C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0D50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0D58: 4BFF45D9  bl 0x82eb5330
	ctx.lr = 0x82EC0D5C;
	sub_82EB5330(ctx, base);
	// 82EC0D5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0D60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC0D64: 396BA890  addi r11, r11, -0x5770
	ctx.r[11].s64 = ctx.r[11].s64 + -22384;
	// 82EC0D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0D6C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EC0D70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0D74: 48000008  b 0x82ec0d7c
	pc = 0x82EC0D7C; continue 'dispatch;
	// 82EC0D78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0D80: 4BDE86DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0D88 size=92
    let mut pc: u32 = 0x82EC0D88;
    'dispatch: loop {
        match pc {
            0x82EC0D88 => {
    //   block [0x82EC0D88..0x82EC0DE4)
	// 82EC0D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC0D94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC0D9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0DA0: 396BA890  addi r11, r11, -0x5770
	ctx.r[11].s64 = ctx.r[11].s64 + -22384;
	// 82EC0DA4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0DA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0DAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0DB0: 41820018  beq 0x82ec0dc8
	if ctx.cr[0].eq {
	pc = 0x82EC0DC8; continue 'dispatch;
	}
	// 82EC0DB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0DB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC0DBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0DC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0DC4: 4E800421  bctrl
	ctx.lr = 0x82EC0DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0DCC: 4BFF45FD  bl 0x82eb53c8
	ctx.lr = 0x82EC0DD0;
	sub_82EB53C8(ctx, base);
	// 82EC0DD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC0DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC0DDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC0DE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0DE8 size=316
    let mut pc: u32 = 0x82EC0DE8;
    'dispatch: loop {
        match pc {
            0x82EC0DE8 => {
    //   block [0x82EC0DE8..0x82EC0F24)
	// 82EC0DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0DEC: 4BDE8615  bl 0x82ca9400
	ctx.lr = 0x82EC0DF0;
	sub_82CA93D0(ctx, base);
	// 82EC0DF0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EC0DF4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0DF8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC0DFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC0E00: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0E04: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EC0E08: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0E0C: 834B0048  lwz r26, 0x48(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0E10: 281A0000  cmplwi r26, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E14: 41820100  beq 0x82ec0f14
	if ctx.cr[0].eq {
	pc = 0x82EC0F14; continue 'dispatch;
	}
	// 82EC0E18: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0E1C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E20: 418200F4  beq 0x82ec0f14
	if ctx.cr[0].eq {
	pc = 0x82EC0F14; continue 'dispatch;
	}
	// 82EC0E24: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC0E28: 813C000C  lwz r9, 0xc(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0E2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC0E30: 3BEBB38C  addi r31, r11, -0x4c74
	ctx.r[31].s64 = ctx.r[11].s64 + -19572;
	// 82EC0E34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0E38: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EC0E3C: 4BFC88A5  bl 0x82e896e0
	ctx.lr = 0x82EC0E40;
	sub_82E896E0(ctx, base);
	// 82EC0E40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0E48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EC0E4C: 4BFC8895  bl 0x82e896e0
	ctx.lr = 0x82EC0E50;
	sub_82E896E0(ctx, base);
	// 82EC0E50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC0E54: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E58: 419A0014  beq cr6, 0x82ec0e6c
	if ctx.cr[6].eq {
	pc = 0x82EC0E6C; continue 'dispatch;
	}
	// 82EC0E5C: 897E001C  lbz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC0E60: 38FE0004  addi r7, r30, 4
	ctx.r[7].s64 = ctx.r[30].s64 + 4;
	// 82EC0E64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E68: 40820008  bne 0x82ec0e70
	if !ctx.cr[0].eq {
	pc = 0x82EC0E70; continue 'dispatch;
	}
	// 82EC0E6C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EC0E70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E74: 419A0014  beq cr6, 0x82ec0e88
	if ctx.cr[6].eq {
	pc = 0x82EC0E88; continue 'dispatch;
	}
	// 82EC0E78: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC0E7C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82EC0E80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E84: 40820008  bne 0x82ec0e8c
	if !ctx.cr[0].eq {
	pc = 0x82EC0E8C; continue 'dispatch;
	}
	// 82EC0E88: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82EC0E8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0E90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EC0E94: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EC0E98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E9C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EC0EA0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EC0EA4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC0EA8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC0EAC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EC0EB0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EC0EB4: 409A0044  bne cr6, 0x82ec0ef8
	if !ctx.cr[6].eq {
	pc = 0x82EC0EF8; continue 'dispatch;
	}
	// 82EC0EB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC0EBC: 807A0048  lwz r3, 0x48(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0EC0: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82EC0EC4: 4822D935  bl 0x830ee7f8
	ctx.lr = 0x82EC0EC8;
	sub_830EE7F8(ctx, base);
	// 82EC0EC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC0ECC: 40820028  bne 0x82ec0ef4
	if !ctx.cr[0].eq {
	pc = 0x82EC0EF4; continue 'dispatch;
	}
	// 82EC0ED0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0ED4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC0ED8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC0EDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC0EE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC0EE4: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0EEC: 4E800421  bctrl
	ctx.lr = 0x82EC0EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0EF0: 48000028  b 0x82ec0f18
	pc = 0x82EC0F18; continue 'dispatch;
	// 82EC0EF4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC0EF8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82EC0EFC: 807A0048  lwz r3, 0x48(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0F00: 38BB0004  addi r5, r27, 4
	ctx.r[5].s64 = ctx.r[27].s64 + 4;
	// 82EC0F04: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC0F08: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82EC0F0C: 4822E445  bl 0x830ef350
	ctx.lr = 0x82EC0F10;
	sub_830EF350(ctx, base);
	// 82EC0F10: 48000008  b 0x82ec0f18
	pc = 0x82EC0F18; continue 'dispatch;
	// 82EC0F14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0F18: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC0F1C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EC0F20: 4BDE8530  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0F28 size=40
    let mut pc: u32 = 0x82EC0F28;
    'dispatch: loop {
        match pc {
            0x82EC0F28 => {
    //   block [0x82EC0F28..0x82EC0F50)
	// 82EC0F28: 39670010  addi r11, r7, 0x10
	ctx.r[11].s64 = ctx.r[7].s64 + 16;
	// 82EC0F2C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC0F30: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC0F34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC0F38: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC0F3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC0F40: 4200FFF8  bdnz 0x82ec0f38
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC0F38; continue 'dispatch;
	}
	// 82EC0F44: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82EC0F48: 99270058  stb r9, 0x58(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82EC0F4C: 4BFAEFAC  b 0x82e6fef8
	sub_82E6FEF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0F50 size=548
    let mut pc: u32 = 0x82EC0F50;
    'dispatch: loop {
        match pc {
            0x82EC0F50 => {
    //   block [0x82EC0F50..0x82EC1174)
	// 82EC0F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0F54: 4BDE8495  bl 0x82ca93e8
	ctx.lr = 0x82EC0F58;
	sub_82CA93D0(ctx, base);
	// 82EC0F58: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82EC0F5C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0F60: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EC0F64: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC0F68: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC0F6C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82EC0F70: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 82EC0F74: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0F78: 828B0048  lwz r20, 0x48(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0F7C: 28140000  cmplwi r20, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0F80: 418201B8  beq 0x82ec1138
	if ctx.cr[0].eq {
	pc = 0x82EC1138; continue 'dispatch;
	}
	// 82EC0F84: 81540048  lwz r10, 0x48(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0F88: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0F8C: 418201AC  beq 0x82ec1138
	if ctx.cr[0].eq {
	pc = 0x82EC1138; continue 'dispatch;
	}
	// 82EC0F90: 8139000C  lwz r9, 0xc(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0F94: 3BBA0004  addi r29, r26, 4
	ctx.r[29].s64 = ctx.r[26].s64 + 4;
	// 82EC0F98: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC0F9C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82EC0FA0: 3B6BB38C  addi r27, r11, -0x4c74
	ctx.r[27].s64 = ctx.r[11].s64 + -19572;
	// 82EC0FA4: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0FA8: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EC0FAC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC0FB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC0FB4: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0FB8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC0FBC: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0FC0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC0FC4: 4BFC871D  bl 0x82e896e0
	ctx.lr = 0x82EC0FC8;
	sub_82E896E0(ctx, base);
	// 82EC0FC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC0FCC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC0FD0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC0FD4: 4BFC870D  bl 0x82e896e0
	ctx.lr = 0x82EC0FD8;
	sub_82E896E0(ctx, base);
	// 82EC0FD8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC0FDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC0FE0: 419A0014  beq cr6, 0x82ec0ff4
	if ctx.cr[6].eq {
	pc = 0x82EC0FF4; continue 'dispatch;
	}
	// 82EC0FE4: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC0FE8: 3B1F0004  addi r24, r31, 4
	ctx.r[24].s64 = ctx.r[31].s64 + 4;
	// 82EC0FEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0FF0: 40820008  bne 0x82ec0ff8
	if !ctx.cr[0].eq {
	pc = 0x82EC0FF8; continue 'dispatch;
	}
	// 82EC0FF4: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 82EC0FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC0FFC: 419A0014  beq cr6, 0x82ec1010
	if ctx.cr[6].eq {
	pc = 0x82EC1010; continue 'dispatch;
	}
	// 82EC1000: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC1004: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82EC1008: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC100C: 40820008  bne 0x82ec1014
	if !ctx.cr[0].eq {
	pc = 0x82EC1014; continue 'dispatch;
	}
	// 82EC1010: 7FD7F378  mr r23, r30
	ctx.r[23].u64 = ctx.r[30].u64;
	// 82EC1014: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1018: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82EC101C: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 82EC1020: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82EC1024: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82EC1028: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 82EC102C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82EC1030: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 82EC1034: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82EC1038: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 82EC103C: 409A0048  bne cr6, 0x82ec1084
	if !ctx.cr[6].eq {
	pc = 0x82EC1084; continue 'dispatch;
	}
	// 82EC1040: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82EC1044: 80740048  lwz r3, 0x48(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC1048: 38960004  addi r4, r22, 4
	ctx.r[4].s64 = ctx.r[22].s64 + 4;
	// 82EC104C: 4822D7AD  bl 0x830ee7f8
	ctx.lr = 0x82EC1050;
	sub_830EE7F8(ctx, base);
	// 82EC1050: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1054: 4082002C  bne 0x82ec1080
	if !ctx.cr[0].eq {
	pc = 0x82EC1080; continue 'dispatch;
	}
	// 82EC1058: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC105C: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 82EC1060: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC1064: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EC1068: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EC106C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EC1070: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC1074: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1078: 4E800421  bctrl
	ctx.lr = 0x82EC107C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC107C: 480000EC  b 0x82ec1168
	pc = 0x82EC1168; continue 'dispatch;
	// 82EC1080: 3B010090  addi r24, r1, 0x90
	ctx.r[24].s64 = ctx.r[1].s64 + 144;
	// 82EC1084: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82EC1088: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC108C: 4BFC8655  bl 0x82e896e0
	ctx.lr = 0x82EC1090;
	sub_82E896E0(ctx, base);
	// 82EC1090: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82EC1094: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82EC1098: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 82EC109C: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82EC10A0: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82EC10A4: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82EC10A8: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82EC10AC: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EC10B0: 40820008  bne 0x82ec10b8
	if !ctx.cr[0].eq {
	pc = 0x82EC10B8; continue 'dispatch;
	}
	// 82EC10B4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82EC10B8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EC10BC: 80740048  lwz r3, 0x48(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC10C0: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82EC10C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC10C8: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 82EC10CC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82EC10D0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EC10D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC10D8: 38960004  addi r4, r22, 4
	ctx.r[4].s64 = ctx.r[22].s64 + 4;
	// 82EC10DC: 4822DC75  bl 0x830eed50
	ctx.lr = 0x82EC10E0;
	sub_830EED50(ctx, base);
	// 82EC10E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC10E4: 419A0034  beq cr6, 0x82ec1118
	if ctx.cr[6].eq {
	pc = 0x82EC1118; continue 'dispatch;
	}
	// 82EC10E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC10EC: 997B001C  stb r11, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC10F0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EC10F4: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC10F8: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC10FC: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC1100: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC1104: 917B0014  stw r11, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EC1108: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EC110C: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC1110: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EC1114: 917B0018  stw r11, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC1118: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC111C: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1120: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1124: D0150004  stfs f0, 4(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC1128: D1B50008  stfs f13, 8(r21)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC112C: D195000C  stfs f12, 0xc(r21)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1130: 9BD50058  stb r30, 0x58(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EC1134: 48000034  b 0x82ec1168
	pc = 0x82EC1168; continue 'dispatch;
	// 82EC1138: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC113C: 39750010  addi r11, r21, 0x10
	ctx.r[11].s64 = ctx.r[21].s64 + 16;
	// 82EC1140: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EC1144: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC1148: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC114C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC1150: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC1154: 4200FFF8  bdnz 0x82ec114c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC114C; continue 'dispatch;
	}
	// 82EC1158: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EC115C: 9BD50058  stb r30, 0x58(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EC1160: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82EC1164: 4BFAED95  bl 0x82e6fef8
	ctx.lr = 0x82EC1168;
	sub_82E6FEF8(ctx, base);
	// 82EC1168: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EC116C: CBE1FF90  lfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82EC1170: 4BDE82C8  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1178 size=84
    let mut pc: u32 = 0x82EC1178;
    'dispatch: loop {
        match pc {
            0x82EC1178 => {
    //   block [0x82EC1178..0x82EC11CC)
	// 82EC1178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC117C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1180: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1184: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1188: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC118C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1190: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC1194: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC1198: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC119C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC11A0: 41820014  beq 0x82ec11b4
	if ctx.cr[0].eq {
	pc = 0x82EC11B4; continue 'dispatch;
	}
	// 82EC11A4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC11A8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC11AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC11B0: 4E800421  bctrl
	ctx.lr = 0x82EC11B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC11B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC11B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC11BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC11C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC11C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC11C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC11D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC11D0 size=604
    let mut pc: u32 = 0x82EC11D0;
    'dispatch: loop {
        match pc {
            0x82EC11D0 => {
    //   block [0x82EC11D0..0x82EC142C)
	// 82EC11D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC11D4: 4BDE8229  bl 0x82ca93fc
	ctx.lr = 0x82EC11D8;
	sub_82CA93D0(ctx, base);
	// 82EC11D8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82EC11DC: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC11E0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EC11E4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC11E8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC11EC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EC11F0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EC11F4: 388BB38C  addi r4, r11, -0x4c74
	ctx.r[4].s64 = ctx.r[11].s64 + -19572;
	// 82EC11F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EC11FC: 4BFC84E5  bl 0x82e896e0
	ctx.lr = 0x82EC1200;
	sub_82E896E0(ctx, base);
	// 82EC1200: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EC1204: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1208: 41820014  beq 0x82ec121c
	if ctx.cr[0].eq {
	pc = 0x82EC121C; continue 'dispatch;
	}
	// 82EC120C: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC1210: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 82EC1214: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1218: 40820008  bne 0x82ec1220
	if !ctx.cr[0].eq {
	pc = 0x82EC1220; continue 'dispatch;
	}
	// 82EC121C: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82EC1220: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1224: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1228: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 82EC122C: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82EC1230: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82EC1234: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 82EC1238: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC123C: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82EC1240: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC1244: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1248: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82EC124C: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EC1250: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EC1254: 83AA0048  lwz r29, 0x48(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC1258: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC125C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1260: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82EC1264: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC1268: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82EC126C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1270: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82EC1274: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC1278: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82EC127C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EC1280: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EC1284: 409A0028  bne cr6, 0x82ec12ac
	if !ctx.cr[6].eq {
	pc = 0x82EC12AC; continue 'dispatch;
	}
	// 82EC1288: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82EC128C: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC1290: 38990004  addi r4, r25, 4
	ctx.r[4].s64 = ctx.r[25].s64 + 4;
	// 82EC1294: 4822D565  bl 0x830ee7f8
	ctx.lr = 0x82EC1298;
	sub_830EE7F8(ctx, base);
	// 82EC1298: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC129C: 4082000C  bne 0x82ec12a8
	if !ctx.cr[0].eq {
	pc = 0x82EC12A8; continue 'dispatch;
	}
	// 82EC12A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC12A4: 4800017C  b 0x82ec1420
	pc = 0x82EC1420; continue 'dispatch;
	// 82EC12A8: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 82EC12AC: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82EC12B0: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC12B4: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82EC12B8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC12BC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC12C0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EC12C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC12C8: 38990004  addi r4, r25, 4
	ctx.r[4].s64 = ctx.r[25].s64 + 4;
	// 82EC12CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC12D0: 4822DA81  bl 0x830eed50
	ctx.lr = 0x82EC12D4;
	sub_830EED50(ctx, base);
	// 82EC12D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC12D8: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC12DC: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 82EC12E0: 3BCB9128  addi r30, r11, -0x6ed8
	ctx.r[30].s64 = ctx.r[11].s64 + -28376;
	// 82EC12E4: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EC12E8: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC12EC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82EC12F0: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EC12F4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC12F8: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC12FC: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EC1300: 93C100D0  stw r30, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 82EC1304: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1308: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC130C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC1310: 4200FFF8  bdnz 0x82ec1308
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC1308; continue 'dispatch;
	}
	// 82EC1314: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC1318: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC131C: 9BE10128  stb r31, 0x128(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[31].u8 ) };
	// 82EC1320: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82EC1324: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC1328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC132C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1330: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1334: 409A000C  bne cr6, 0x82ec1340
	if !ctx.cr[6].eq {
	pc = 0x82EC1340; continue 'dispatch;
	}
	// 82EC1338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC133C: 48000028  b 0x82ec1364
	pc = 0x82EC1364; continue 'dispatch;
	// 82EC1340: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC1344: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC1348: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82EC134C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82EC1350: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC1354: C00A0C4C  lfs f0, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1358: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC135C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1360: 4E800421  bctrl
	ctx.lr = 0x82EC1364;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1364: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC1368: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC136C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC1370: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82EC1374: 4082FF2C  bne 0x82ec12a0
	if !ctx.cr[0].eq {
	pc = 0x82EC12A0; continue 'dispatch;
	}
	// 82EC1378: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC137C: 39610140  addi r11, r1, 0x140
	ctx.r[11].s64 = ctx.r[1].s64 + 320;
	// 82EC1380: D0010134  stfs f0, 0x134(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82EC1384: 93C10130  stw r30, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 82EC1388: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC138C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82EC1390: D0010138  stfs f0, 0x138(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82EC1394: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC1398: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC139C: D001013C  stfs f0, 0x13c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82EC13A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC13A4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC13A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC13AC: 4200FFF8  bdnz 0x82ec13a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC13A4; continue 'dispatch;
	}
	// 82EC13B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC13B4: 9BE10188  stb r31, 0x188(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[31].u8 ) };
	// 82EC13B8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EC13BC: 938100B4  stw r28, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	// 82EC13C0: 396BAFB8  addi r11, r11, -0x5048
	ctx.r[11].s64 = ctx.r[11].s64 + -20552;
	// 82EC13C4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82EC13C8: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EC13CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC13D0: 996100CC  stb r11, 0xcc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u8 ) };
	// 82EC13D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EC13D8: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EC13DC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC13E0: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82EC13E4: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC13E8: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EC13EC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EC13F0: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EC13F4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EC13F8: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EC13FC: 4B2ED2AD  bl 0x821ae6a8
	ctx.lr = 0x82EC1400;
	sub_821AE6A8(ctx, base);
	// 82EC1400: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1404: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC1408: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EC140C: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82EC1410: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EC1414: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC141C: 4E800421  bctrl
	ctx.lr = 0x82EC1420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1420: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 82EC1424: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EC1428: 4BDE8024  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1430 size=116
    let mut pc: u32 = 0x82EC1430;
    'dispatch: loop {
        match pc {
            0x82EC1430 => {
    //   block [0x82EC1430..0x82EC14A4)
	// 82EC1430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC143C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1444: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1448: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC144C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1450: 41820030  beq 0x82ec1480
	if ctx.cr[0].eq {
	pc = 0x82EC1480; continue 'dispatch;
	}
	// 82EC1454: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC1458: 48000020  b 0x82ec1478
	pc = 0x82EC1478; continue 'dispatch;
	// 82EC145C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC1464: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1468: 4BDEB6E9  bl 0x82cacb50
	ctx.lr = 0x82EC146C;
	sub_82CACB50(ctx, base);
	// 82EC146C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1470: 4182002C  beq 0x82ec149c
	if ctx.cr[0].eq {
	pc = 0x82EC149C; continue 'dispatch;
	}
	// 82EC1474: 83FF000C  lwz r31, 0xc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC1478: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC147C: 4082FFE0  bne 0x82ec145c
	if !ctx.cr[0].eq {
	pc = 0x82EC145C; continue 'dispatch;
	}
	// 82EC1480: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1484: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC148C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1490: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1498: 4E800020  blr
	return;
	// 82EC149C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC14A0: 4BFFFFE4  b 0x82ec1484
	pc = 0x82EC1484; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC14A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC14A8 size=208
    let mut pc: u32 = 0x82EC14A8;
    'dispatch: loop {
        match pc {
            0x82EC14A8 => {
    //   block [0x82EC14A8..0x82EC1578)
	// 82EC14A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC14AC: 4BDE7F61  bl 0x82ca940c
	ctx.lr = 0x82EC14B0;
	sub_82CA93D0(ctx, base);
	// 82EC14B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC14B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC14B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC14BC: 4BFF3F65  bl 0x82eb5420
	ctx.lr = 0x82EC14C0;
	sub_82EB5420(ctx, base);
	// 82EC14C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC14C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC14C8: 409A000C  bne cr6, 0x82ec14d4
	if !ctx.cr[6].eq {
	pc = 0x82EC14D4; continue 'dispatch;
	}
	// 82EC14CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC14D0: 480000A0  b 0x82ec1570
	pc = 0x82EC1570; continue 'dispatch;
	// 82EC14D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC14D8: 482FAB89  bl 0x831bc060
	ctx.lr = 0x82EC14DC;
	sub_831BC060(ctx, base);
	// 82EC14DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC14E0: 4182008C  beq 0x82ec156c
	if ctx.cr[0].eq {
	pc = 0x82EC156C; continue 'dispatch;
	}
	// 82EC14E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EC14E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC14EC: 3BEB2304  addi r31, r11, 0x2304
	ctx.r[31].s64 = ctx.r[11].s64 + 8964;
	// 82EC14F0: 482FAB71  bl 0x831bc060
	ctx.lr = 0x82EC14F4;
	sub_831BC060(ctx, base);
	// 82EC14F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC14F8: 4BDEB659  bl 0x82cacb50
	ctx.lr = 0x82EC14FC;
	sub_82CACB50(ctx, base);
	// 82EC14FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1500: 4082006C  bne 0x82ec156c
	if !ctx.cr[0].eq {
	pc = 0x82EC156C; continue 'dispatch;
	}
	// 82EC1504: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC1508: 388BBA88  addi r4, r11, -0x4578
	ctx.r[4].s64 = ctx.r[11].s64 + -17784;
	// 82EC150C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1510: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1514: 4B3A670D  bl 0x82267c20
	ctx.lr = 0x82EC1518;
	sub_82267C20(ctx, base);
	// 82EC1518: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC151C: 4182FFB0  beq 0x82ec14cc
	if ctx.cr[0].eq {
	pc = 0x82EC14CC; continue 'dispatch;
	}
	// 82EC1520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC1524: 4BA4C7E5  bl 0x8290dd08
	ctx.lr = 0x82EC1528;
	sub_8290DD08(ctx, base);
	// 82EC1528: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC152C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1530: 4BFFFF01  bl 0x82ec1430
	ctx.lr = 0x82EC1534;
	sub_82EC1430(ctx, base);
	// 82EC1534: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EC1538: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC153C: 4182FF90  beq 0x82ec14cc
	if ctx.cr[0].eq {
	pc = 0x82EC14CC; continue 'dispatch;
	}
	// 82EC1540: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1544: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC1548: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EC154C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EC1550: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC1554: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC1558: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EC155C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC1560: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC1564: 4BFBE60D  bl 0x82e7fb70
	ctx.lr = 0x82EC1568;
	sub_82E7FB70(ctx, base);
	// 82EC1568: 4BFFFF64  b 0x82ec14cc
	pc = 0x82EC14CC; continue 'dispatch;
	// 82EC156C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1570: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC1574: 4BDE7EE8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1578 size=200
    let mut pc: u32 = 0x82EC1578;
    'dispatch: loop {
        match pc {
            0x82EC1578 => {
    //   block [0x82EC1578..0x82EC1640)
	// 82EC1578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC157C: 4BDE7E85  bl 0x82ca9400
	ctx.lr = 0x82EC1580;
	sub_82CA93D0(ctx, base);
	// 82EC1580: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1584: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1588: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EC158C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EC1590: 419A009C  beq cr6, 0x82ec162c
	if ctx.cr[6].eq {
	pc = 0x82EC162C; continue 'dispatch;
	}
	// 82EC1594: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC1598: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC159C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC15A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC15A4: 40990088  ble cr6, 0x82ec162c
	if !ctx.cr[6].gt {
	pc = 0x82EC162C; continue 'dispatch;
	}
	// 82EC15A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EC15AC: 3B6B2304  addi r27, r11, 0x2304
	ctx.r[27].s64 = ctx.r[11].s64 + 8964;
	// 82EC15B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC15B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC15B8: 4BFC2A71  bl 0x82e84028
	ctx.lr = 0x82EC15BC;
	sub_82E84028(ctx, base);
	// 82EC15BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC15C0: 41820030  beq 0x82ec15f0
	if ctx.cr[0].eq {
	pc = 0x82EC15F0; continue 'dispatch;
	}
	// 82EC15C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC15C8: 482FAA99  bl 0x831bc060
	ctx.lr = 0x82EC15CC;
	sub_831BC060(ctx, base);
	// 82EC15CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC15D0: 41820020  beq 0x82ec15f0
	if ctx.cr[0].eq {
	pc = 0x82EC15F0; continue 'dispatch;
	}
	// 82EC15D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC15D8: 482FAA89  bl 0x831bc060
	ctx.lr = 0x82EC15DC;
	sub_831BC060(ctx, base);
	// 82EC15DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC15E0: 4BDEB571  bl 0x82cacb50
	ctx.lr = 0x82EC15E4;
	sub_82CACB50(ctx, base);
	// 82EC15E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC15E8: 40820008  bne 0x82ec15f0
	if !ctx.cr[0].eq {
	pc = 0x82EC15F0; continue 'dispatch;
	}
	// 82EC15EC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EC15F0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC15F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EC15F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC15FC: 4198FFB4  blt cr6, 0x82ec15b0
	if ctx.cr[6].lt {
	pc = 0x82EC15B0; continue 'dispatch;
	}
	// 82EC1600: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EC1604: 419A0028  beq cr6, 0x82ec162c
	if ctx.cr[6].eq {
	pc = 0x82EC162C; continue 'dispatch;
	}
	// 82EC1608: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EC160C: 4B75531D  bl 0x82616928
	ctx.lr = 0x82EC1610;
	sub_82616928(ctx, base);
	// 82EC1610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1614: 41820010  beq 0x82ec1624
	if ctx.cr[0].eq {
	pc = 0x82EC1624; continue 'dispatch;
	}
	// 82EC1618: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC161C: 4BFCBC15  bl 0x82e8d230
	ctx.lr = 0x82EC1620;
	sub_82E8D230(ctx, base);
	// 82EC1620: 48000008  b 0x82ec1628
	pc = 0x82EC1628; continue 'dispatch;
	// 82EC1624: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1628: 907A000C  stw r3, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82EC162C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1630: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC1634: 48002A45  bl 0x82ec4078
	ctx.lr = 0x82EC1638;
	sub_82EC4078(ctx, base);
	// 82EC1638: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC163C: 4BDE7E14  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1640 size=84
    let mut pc: u32 = 0x82EC1640;
    'dispatch: loop {
        match pc {
            0x82EC1640 => {
    //   block [0x82EC1640..0x82EC1694)
	// 82EC1640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1644: 4BDE7DC9  bl 0x82ca940c
	ctx.lr = 0x82EC1648;
	sub_82CA93D0(ctx, base);
	// 82EC1648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC164C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1650: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EC1654: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1658: 4B7552D1  bl 0x82616928
	ctx.lr = 0x82EC165C;
	sub_82616928(ctx, base);
	// 82EC165C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC1660: 41820028  beq 0x82ec1688
	if ctx.cr[0].eq {
	pc = 0x82EC1688; continue 'dispatch;
	}
	// 82EC1664: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC1668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC166C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1670: 4BFF3CC1  bl 0x82eb5330
	ctx.lr = 0x82EC1674;
	sub_82EB5330(ctx, base);
	// 82EC1674: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC167C: 396BA834  addi r11, r11, -0x57cc
	ctx.r[11].s64 = ctx.r[11].s64 + -22476;
	// 82EC1680: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC1684: 48000008  b 0x82ec168c
	pc = 0x82EC168C; continue 'dispatch;
	// 82EC1688: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC168C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1690: 4BDE7DCC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1698 size=332
    let mut pc: u32 = 0x82EC1698;
    'dispatch: loop {
        match pc {
            0x82EC1698 => {
    //   block [0x82EC1698..0x82EC17E4)
	// 82EC1698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC169C: 4BDE7D71  bl 0x82ca940c
	ctx.lr = 0x82EC16A0;
	sub_82CA93D0(ctx, base);
	// 82EC16A0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC16A4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC16A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC16AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC16B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC16B4: 482FA9AD  bl 0x831bc060
	ctx.lr = 0x82EC16B8;
	sub_831BC060(ctx, base);
	// 82EC16B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC16BC: 41820084  beq 0x82ec1740
	if ctx.cr[0].eq {
	pc = 0x82EC1740; continue 'dispatch;
	}
	// 82EC16C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC16C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC16C8: 3BCBAF1C  addi r30, r11, -0x50e4
	ctx.r[30].s64 = ctx.r[11].s64 + -20708;
	// 82EC16CC: 482FA995  bl 0x831bc060
	ctx.lr = 0x82EC16D0;
	sub_831BC060(ctx, base);
	// 82EC16D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC16D4: 4BDEB47D  bl 0x82cacb50
	ctx.lr = 0x82EC16D8;
	sub_82CACB50(ctx, base);
	// 82EC16D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC16DC: 40820064  bne 0x82ec1740
	if !ctx.cr[0].eq {
	pc = 0x82EC1740; continue 'dispatch;
	}
	// 82EC16E0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC16E4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC16E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC16EC: 4182000C  beq 0x82ec16f8
	if ctx.cr[0].eq {
	pc = 0x82EC16F8; continue 'dispatch;
	}
	// 82EC16F0: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC16F4: 4800000C  b 0x82ec1700
	pc = 0x82EC1700; continue 'dispatch;
	// 82EC16F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC16FC: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1704: 4BA4C605  bl 0x8290dd08
	ctx.lr = 0x82EC1708;
	sub_8290DD08(ctx, base);
	// 82EC1708: 4BDEA4A9  bl 0x82cabbb0
	ctx.lr = 0x82EC170C;
	sub_82CABBB0(ctx, base);
	// 82EC170C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1710: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1714: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1718: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC171C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC1720: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC1724: 40990008  ble cr6, 0x82ec172c
	if !ctx.cr[6].gt {
	pc = 0x82EC172C; continue 'dispatch;
	}
	// 82EC1728: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC172C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC1730: 409AFFF0  bne cr6, 0x82ec1720
	if !ctx.cr[6].eq {
	pc = 0x82EC1720; continue 'dispatch;
	}
	// 82EC1734: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1738: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC173C: 4800009C  b 0x82ec17d8
	pc = 0x82EC17D8; continue 'dispatch;
	// 82EC1740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1744: 482FA91D  bl 0x831bc060
	ctx.lr = 0x82EC1748;
	sub_831BC060(ctx, base);
	// 82EC1748: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC174C: 41820080  beq 0x82ec17cc
	if ctx.cr[0].eq {
	pc = 0x82EC17CC; continue 'dispatch;
	}
	// 82EC1750: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1758: 3BCBA628  addi r30, r11, -0x59d8
	ctx.r[30].s64 = ctx.r[11].s64 + -23000;
	// 82EC175C: 482FA905  bl 0x831bc060
	ctx.lr = 0x82EC1760;
	sub_831BC060(ctx, base);
	// 82EC1760: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1764: 4BDEB3ED  bl 0x82cacb50
	ctx.lr = 0x82EC1768;
	sub_82CACB50(ctx, base);
	// 82EC1768: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC176C: 40820060  bne 0x82ec17cc
	if !ctx.cr[0].eq {
	pc = 0x82EC17CC; continue 'dispatch;
	}
	// 82EC1770: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1774: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1778: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC177C: 4182000C  beq 0x82ec1788
	if ctx.cr[0].eq {
	pc = 0x82EC1788; continue 'dispatch;
	}
	// 82EC1780: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1784: 4800000C  b 0x82ec1790
	pc = 0x82EC1790; continue 'dispatch;
	// 82EC1788: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC178C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1794: 4BA4C575  bl 0x8290dd08
	ctx.lr = 0x82EC1798;
	sub_8290DD08(ctx, base);
	// 82EC1798: 4BDEA419  bl 0x82cabbb0
	ctx.lr = 0x82EC179C;
	sub_82CABBB0(ctx, base);
	// 82EC179C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC17A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC17A4: C01D0010  lfs f0, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC17A8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC17AC: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC17B0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC17B4: 40990008  ble cr6, 0x82ec17bc
	if !ctx.cr[6].gt {
	pc = 0x82EC17BC; continue 'dispatch;
	}
	// 82EC17B8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC17BC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC17C0: 409AFFF0  bne cr6, 0x82ec17b0
	if !ctx.cr[6].eq {
	pc = 0x82EC17B0; continue 'dispatch;
	}
	// 82EC17C4: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC17C8: 4BFFFF70  b 0x82ec1738
	pc = 0x82EC1738; continue 'dispatch;
	// 82EC17CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC17D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC17D4: 4BFF3C4D  bl 0x82eb5420
	ctx.lr = 0x82EC17D8;
	sub_82EB5420(ctx, base);
	// 82EC17D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC17DC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC17E0: 4BDE7C7C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC17E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC17E8 size=196
    let mut pc: u32 = 0x82EC17E8;
    'dispatch: loop {
        match pc {
            0x82EC17E8 => {
    //   block [0x82EC17E8..0x82EC18AC)
	// 82EC17E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC17EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC17F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC17F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC17F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC17FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1800: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC1804: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC1808: 388AC178  addi r4, r10, -0x3e88
	ctx.r[4].s64 = ctx.r[10].s64 + -16008;
	// 82EC180C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC1810: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1814: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1818: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC181C: 4B326E5D  bl 0x821e8678
	ctx.lr = 0x82EC1820;
	sub_821E8678(ctx, base);
	// 82EC1820: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC1824: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1828: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC182C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EC1830: C16A0BFC  lfs f11, 0xbfc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC1834: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1838: 41820010  beq 0x82ec1848
	if ctx.cr[0].eq {
	pc = 0x82EC1848; continue 'dispatch;
	}
	// 82EC183C: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1840: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC1844: 48000028  b 0x82ec186c
	pc = 0x82EC186C; continue 'dispatch;
	// 82EC1848: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC184C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1850: 4182000C  beq 0x82ec185c
	if ctx.cr[0].eq {
	pc = 0x82EC185C; continue 'dispatch;
	}
	// 82EC1854: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1858: 48000008  b 0x82ec1860
	pc = 0x82EC1860; continue 'dispatch;
	// 82EC185C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EC1860: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82EC1864: C18B5CC4  lfs f12, 0x5cc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(23748 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1868: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC186C: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC1870: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1874: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1878: 41820008  beq 0x82ec1880
	if ctx.cr[0].eq {
	pc = 0x82EC1880; continue 'dispatch;
	}
	// 82EC187C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1880: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1884: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC1888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC188C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1890: 480027E9  bl 0x82ec4078
	ctx.lr = 0x82EC1894;
	sub_82EC4078(ctx, base);
	// 82EC1894: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC189C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC18A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC18A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC18A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC18B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC18B0 size=80
    let mut pc: u32 = 0x82EC18B0;
    'dispatch: loop {
        match pc {
            0x82EC18B0 => {
    //   block [0x82EC18B0..0x82EC1900)
	// 82EC18B0: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC18B4: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC18B8: C1A5000C  lfs f13, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC18BC: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC18C0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC18C4: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC18C8: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC18CC: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC18D0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC18D4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC18D8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC18DC: 40980024  bge cr6, 0x82ec1900
	if !ctx.cr[6].lt {
		sub_82EC1900(ctx, base);
		return;
	}
	// 82EC18E0: C1A50008  lfs f13, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC18E4: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC18E8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC18EC: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC18F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC18F4: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EC18F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC18FC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC1900 size=8
    let mut pc: u32 = 0x82EC1900;
    'dispatch: loop {
        match pc {
            0x82EC1900 => {
    //   block [0x82EC1900..0x82EC1908)
	// 82EC1900: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1908 size=68
    let mut pc: u32 = 0x82EC1908;
    'dispatch: loop {
        match pc {
            0x82EC1908 => {
    //   block [0x82EC1908..0x82EC194C)
	// 82EC1908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC190C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1910: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1914: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1918: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC191C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1920: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC1924: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC1928: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC192C: 41820008  beq 0x82ec1934
	if ctx.cr[0].eq {
	pc = 0x82EC1934; continue 'dispatch;
	}
	// 82EC1930: 4B983E81  bl 0x828457b0
	ctx.lr = 0x82EC1934;
	sub_828457B0(ctx, base);
	// 82EC1934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1938: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC193C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC1950 size=12
    let mut pc: u32 = 0x82EC1950;
    'dispatch: loop {
        match pc {
            0x82EC1950 => {
    //   block [0x82EC1950..0x82EC195C)
	// 82EC1950: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC1954: 386BD7B8  addi r3, r11, -0x2848
	ctx.r[3].s64 = ctx.r[11].s64 + -10312;
	// 82EC1958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1960 size=84
    let mut pc: u32 = 0x82EC1960;
    'dispatch: loop {
        match pc {
            0x82EC1960 => {
    //   block [0x82EC1960..0x82EC19B4)
	// 82EC1960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1964: 4BDE7AA9  bl 0x82ca940c
	ctx.lr = 0x82EC1968;
	sub_82CA93D0(ctx, base);
	// 82EC1968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC196C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1970: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC1974: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1978: 4B754FB1  bl 0x82616928
	ctx.lr = 0x82EC197C;
	sub_82616928(ctx, base);
	// 82EC197C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC1980: 41820028  beq 0x82ec19a8
	if ctx.cr[0].eq {
	pc = 0x82EC19A8; continue 'dispatch;
	}
	// 82EC1984: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC1988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC198C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1990: 4BFF39A1  bl 0x82eb5330
	ctx.lr = 0x82EC1994;
	sub_82EB5330(ctx, base);
	// 82EC1994: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC199C: 396BB000  addi r11, r11, -0x5000
	ctx.r[11].s64 = ctx.r[11].s64 + -20480;
	// 82EC19A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC19A4: 48000008  b 0x82ec19ac
	pc = 0x82EC19AC; continue 'dispatch;
	// 82EC19A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC19AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC19B0: 4BDE7AAC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC19B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC19B8 size=192
    let mut pc: u32 = 0x82EC19B8;
    'dispatch: loop {
        match pc {
            0x82EC19B8 => {
    //   block [0x82EC19B8..0x82EC1A78)
	// 82EC19B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC19BC: 4BDE7A51  bl 0x82ca940c
	ctx.lr = 0x82EC19C0;
	sub_82CA93D0(ctx, base);
	// 82EC19C0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC19C4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC19C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC19CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC19D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC19D4: 482FA68D  bl 0x831bc060
	ctx.lr = 0x82EC19D8;
	sub_831BC060(ctx, base);
	// 82EC19D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC19DC: 41820084  beq 0x82ec1a60
	if ctx.cr[0].eq {
	pc = 0x82EC1A60; continue 'dispatch;
	}
	// 82EC19E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC19E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC19E8: 3BCBAF1C  addi r30, r11, -0x50e4
	ctx.r[30].s64 = ctx.r[11].s64 + -20708;
	// 82EC19EC: 482FA675  bl 0x831bc060
	ctx.lr = 0x82EC19F0;
	sub_831BC060(ctx, base);
	// 82EC19F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC19F4: 4BDEB15D  bl 0x82cacb50
	ctx.lr = 0x82EC19F8;
	sub_82CACB50(ctx, base);
	// 82EC19F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC19FC: 40820064  bne 0x82ec1a60
	if !ctx.cr[0].eq {
	pc = 0x82EC1A60; continue 'dispatch;
	}
	// 82EC1A00: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1A04: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1A08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1A0C: 4182000C  beq 0x82ec1a18
	if ctx.cr[0].eq {
	pc = 0x82EC1A18; continue 'dispatch;
	}
	// 82EC1A10: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1A14: 4800000C  b 0x82ec1a20
	pc = 0x82EC1A20; continue 'dispatch;
	// 82EC1A18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1A1C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1A24: 4BA4C2E5  bl 0x8290dd08
	ctx.lr = 0x82EC1A28;
	sub_8290DD08(ctx, base);
	// 82EC1A28: 4BDEA189  bl 0x82cabbb0
	ctx.lr = 0x82EC1A2C;
	sub_82CABBB0(ctx, base);
	// 82EC1A2C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1A30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1A34: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1A38: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1A3C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC1A40: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC1A44: 40990008  ble cr6, 0x82ec1a4c
	if !ctx.cr[6].gt {
	pc = 0x82EC1A4C; continue 'dispatch;
	}
	// 82EC1A48: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC1A4C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC1A50: 409AFFF0  bne cr6, 0x82ec1a40
	if !ctx.cr[6].eq {
	pc = 0x82EC1A40; continue 'dispatch;
	}
	// 82EC1A54: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1A58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1A5C: 48000010  b 0x82ec1a6c
	pc = 0x82EC1A6C; continue 'dispatch;
	// 82EC1A60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC1A64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC1A68: 4BFF39B9  bl 0x82eb5420
	ctx.lr = 0x82EC1A6C;
	sub_82EB5420(ctx, base);
	// 82EC1A6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC1A70: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC1A74: 4BDE79E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC1A78 size=24
    let mut pc: u32 = 0x82EC1A78;
    'dispatch: loop {
        match pc {
            0x82EC1A78 => {
    //   block [0x82EC1A78..0x82EC1A90)
	// 82EC1A78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1A7C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1A80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1A84: 4182000C  beq 0x82ec1a90
	if ctx.cr[0].eq {
		sub_82EC1A90(ctx, base);
		return;
	}
	// 82EC1A88: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1A8C: 4800000C  b 0x82ec1a98
	sub_82EC1A90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC1A90 size=28
    let mut pc: u32 = 0x82EC1A90;
    'dispatch: loop {
        match pc {
            0x82EC1A90 => {
    //   block [0x82EC1A90..0x82EC1AAC)
	// 82EC1A90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1A94: C1AB0C14  lfs f13, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1A98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1A9C: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1AA0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1AA4: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1AA8: 480025D0  b 0x82ec4078
	sub_82EC4078(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC1AB0 size=80
    let mut pc: u32 = 0x82EC1AB0;
    'dispatch: loop {
        match pc {
            0x82EC1AB0 => {
    //   block [0x82EC1AB0..0x82EC1B00)
	// 82EC1AB0: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1AB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC1AB8: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1ABC: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1AC0: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1AC4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC1AC8: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1ACC: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1AD0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC1AD4: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC1AD8: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1ADC: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC1AE0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1AE4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1AE8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1AEC: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC1AF0: 41980008  blt cr6, 0x82ec1af8
	if ctx.cr[6].lt {
	pc = 0x82EC1AF8; continue 'dispatch;
	}
	// 82EC1AF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC1AF8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC1AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1B00 size=84
    let mut pc: u32 = 0x82EC1B00;
    'dispatch: loop {
        match pc {
            0x82EC1B00 => {
    //   block [0x82EC1B00..0x82EC1B54)
	// 82EC1B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1B04: 4BDE7909  bl 0x82ca940c
	ctx.lr = 0x82EC1B08;
	sub_82CA93D0(ctx, base);
	// 82EC1B08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1B0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1B10: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EC1B14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1B18: 4B754E11  bl 0x82616928
	ctx.lr = 0x82EC1B1C;
	sub_82616928(ctx, base);
	// 82EC1B1C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC1B20: 41820028  beq 0x82ec1b48
	if ctx.cr[0].eq {
	pc = 0x82EC1B48; continue 'dispatch;
	}
	// 82EC1B24: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC1B28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B30: 4BFF3801  bl 0x82eb5330
	ctx.lr = 0x82EC1B34;
	sub_82EB5330(ctx, base);
	// 82EC1B34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B3C: 396BA84C  addi r11, r11, -0x57b4
	ctx.r[11].s64 = ctx.r[11].s64 + -22452;
	// 82EC1B40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC1B44: 48000008  b 0x82ec1b4c
	pc = 0x82EC1B4C; continue 'dispatch;
	// 82EC1B48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1B4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1B50: 4BDE790C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1B58 size=268
    let mut pc: u32 = 0x82EC1B58;
    'dispatch: loop {
        match pc {
            0x82EC1B58 => {
    //   block [0x82EC1B58..0x82EC1C64)
	// 82EC1B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1B5C: 4BDE78B1  bl 0x82ca940c
	ctx.lr = 0x82EC1B60;
	sub_82CA93D0(ctx, base);
	// 82EC1B60: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC1B64: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1B68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC1B6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC1B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B74: 482FA4ED  bl 0x831bc060
	ctx.lr = 0x82EC1B78;
	sub_831BC060(ctx, base);
	// 82EC1B78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1B7C: 41820040  beq 0x82ec1bbc
	if ctx.cr[0].eq {
	pc = 0x82EC1BBC; continue 'dispatch;
	}
	// 82EC1B80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B88: 3BCBB050  addi r30, r11, -0x4fb0
	ctx.r[30].s64 = ctx.r[11].s64 + -20400;
	// 82EC1B8C: 482FA4D5  bl 0x831bc060
	ctx.lr = 0x82EC1B90;
	sub_831BC060(ctx, base);
	// 82EC1B90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1B94: 4BDEAFBD  bl 0x82cacb50
	ctx.lr = 0x82EC1B98;
	sub_82CACB50(ctx, base);
	// 82EC1B98: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1B9C: 40820020  bne 0x82ec1bbc
	if !ctx.cr[0].eq {
	pc = 0x82EC1BBC; continue 'dispatch;
	}
	// 82EC1BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1BA4: 4BA4C165  bl 0x8290dd08
	ctx.lr = 0x82EC1BA8;
	sub_8290DD08(ctx, base);
	// 82EC1BA8: 4BDE8819  bl 0x82caa3c0
	ctx.lr = 0x82EC1BAC;
	sub_82CAA3C0(ctx, base);
	// 82EC1BAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC1BB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1BB4: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC1BB8: 480000A0  b 0x82ec1c58
	pc = 0x82EC1C58; continue 'dispatch;
	// 82EC1BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1BC0: 482FA4A1  bl 0x831bc060
	ctx.lr = 0x82EC1BC4;
	sub_831BC060(ctx, base);
	// 82EC1BC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1BC8: 41820084  beq 0x82ec1c4c
	if ctx.cr[0].eq {
	pc = 0x82EC1C4C; continue 'dispatch;
	}
	// 82EC1BCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1BD4: 3BCBB040  addi r30, r11, -0x4fc0
	ctx.r[30].s64 = ctx.r[11].s64 + -20416;
	// 82EC1BD8: 482FA489  bl 0x831bc060
	ctx.lr = 0x82EC1BDC;
	sub_831BC060(ctx, base);
	// 82EC1BDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1BE0: 4BDEAF71  bl 0x82cacb50
	ctx.lr = 0x82EC1BE4;
	sub_82CACB50(ctx, base);
	// 82EC1BE4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1BE8: 40820064  bne 0x82ec1c4c
	if !ctx.cr[0].eq {
	pc = 0x82EC1C4C; continue 'dispatch;
	}
	// 82EC1BEC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1BF0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1BF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1BF8: 4182000C  beq 0x82ec1c04
	if ctx.cr[0].eq {
	pc = 0x82EC1C04; continue 'dispatch;
	}
	// 82EC1BFC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1C00: 4800000C  b 0x82ec1c0c
	pc = 0x82EC1C0C; continue 'dispatch;
	// 82EC1C04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1C08: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1C10: 4BA4C0F9  bl 0x8290dd08
	ctx.lr = 0x82EC1C14;
	sub_8290DD08(ctx, base);
	// 82EC1C14: 4BDE9F9D  bl 0x82cabbb0
	ctx.lr = 0x82EC1C18;
	sub_82CABBB0(ctx, base);
	// 82EC1C18: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1C1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1C20: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1C24: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1C28: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC1C2C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC1C30: 41980008  blt cr6, 0x82ec1c38
	if ctx.cr[6].lt {
	pc = 0x82EC1C38; continue 'dispatch;
	}
	// 82EC1C34: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC1C38: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC1C3C: 409AFFF0  bne cr6, 0x82ec1c2c
	if !ctx.cr[6].eq {
	pc = 0x82EC1C2C; continue 'dispatch;
	}
	// 82EC1C40: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1C44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1C48: 48000010  b 0x82ec1c58
	pc = 0x82EC1C58; continue 'dispatch;
	// 82EC1C4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC1C50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC1C54: 4BFF37CD  bl 0x82eb5420
	ctx.lr = 0x82EC1C58;
	sub_82EB5420(ctx, base);
	// 82EC1C58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC1C5C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC1C60: 4BDE77FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1C68 size=140
    let mut pc: u32 = 0x82EC1C68;
    'dispatch: loop {
        match pc {
            0x82EC1C68 => {
    //   block [0x82EC1C68..0x82EC1CF4)
	// 82EC1C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1C70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC1C74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1C78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1C7C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EC1C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1C84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC1C88: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC1C8C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1C90: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1C94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1C98: 4182000C  beq 0x82ec1ca4
	if ctx.cr[0].eq {
	pc = 0x82EC1CA4; continue 'dispatch;
	}
	// 82EC1C9C: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1CA0: 4800000C  b 0x82ec1cac
	pc = 0x82EC1CAC; continue 'dispatch;
	// 82EC1CA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1CA8: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1CAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1CB0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1CB8: C00B0AEC  lfs f0, 0xaec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1CBC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC1CC0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1CC4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1CC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1CCC: 4E800421  bctrl
	ctx.lr = 0x82EC1CD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1CD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1CD8: 480023A1  bl 0x82ec4078
	ctx.lr = 0x82EC1CDC;
	sub_82EC4078(ctx, base);
	// 82EC1CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1CE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC1CF8 size=24
    let mut pc: u32 = 0x82EC1CF8;
    'dispatch: loop {
        match pc {
            0x82EC1CF8 => {
    //   block [0x82EC1CF8..0x82EC1D10)
	// 82EC1CF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1CFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC1D00: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D04: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC1D08: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EC1D0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1D10 size=216
    let mut pc: u32 = 0x82EC1D10;
    'dispatch: loop {
        match pc {
            0x82EC1D10 => {
    //   block [0x82EC1D10..0x82EC1DE8)
	// 82EC1D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1D18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC1D1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1D28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC1D2C: 4B39EC8D  bl 0x822609b8
	ctx.lr = 0x82EC1D30;
	sub_822609B8(ctx, base);
	// 82EC1D30: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D34: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1D38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC1D3C: 419A0018  beq cr6, 0x82ec1d54
	if ctx.cr[6].eq {
	pc = 0x82EC1D54; continue 'dispatch;
	}
	// 82EC1D40: 4B39EC79  bl 0x822609b8
	ctx.lr = 0x82EC1D44;
	sub_822609B8(ctx, base);
	// 82EC1D44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC1D48: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D4C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC1D50: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC1D54: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1D58: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC1D5C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC1D60: 4098006C  bge cr6, 0x82ec1dcc
	if !ctx.cr[6].lt {
	pc = 0x82EC1DCC; continue 'dispatch;
	}
	// 82EC1D64: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1D68: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D6C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1D70: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1D74: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1D78: C15E000C  lfs f10, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC1D7C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1D80: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1D84: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D88: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC1D8C: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC1D90: EDAC4828  fsubs f13, f12, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC1D94: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1D98: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC1D9C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1DA0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1DA4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1DA8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC1DAC: 41990020  bgt cr6, 0x82ec1dcc
	if ctx.cr[6].gt {
	pc = 0x82EC1DCC; continue 'dispatch;
	}
	// 82EC1DB0: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 82EC1DB4: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 82EC1DB8: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC1DBC: 816A0054  lwz r11, 0x54(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC1DC0: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC1DC4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC1DC8: 409A0008  bne cr6, 0x82ec1dd0
	if !ctx.cr[6].eq {
	pc = 0x82EC1DD0; continue 'dispatch;
	}
	// 82EC1DCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1DD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1DDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1DE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1DE8 size=280
    let mut pc: u32 = 0x82EC1DE8;
    'dispatch: loop {
        match pc {
            0x82EC1DE8 => {
    //   block [0x82EC1DE8..0x82EC1F00)
	// 82EC1DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1DEC: 4BDE7615  bl 0x82ca9400
	ctx.lr = 0x82EC1DF0;
	sub_82CA93D0(ctx, base);
	// 82EC1DF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1DF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1DF8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EC1DFC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC1E00: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82EC1E04: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1E08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1E0C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC1E10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1E14: 4E800421  bctrl
	ctx.lr = 0x82EC1E18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1E18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1E1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1E20: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82EC1E24: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC1E28: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC1E2C: 83EB0250  lwz r31, 0x250(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EC1E30: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EC1E34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1E3C: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1E40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1E44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1E48: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1E4C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC1E50: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC1E54: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC1E58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1E5C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1E60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1E64: 4E800421  bctrl
	ctx.lr = 0x82EC1E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1E68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1E6C: 4082000C  bne 0x82ec1e78
	if !ctx.cr[0].eq {
	pc = 0x82EC1E78; continue 'dispatch;
	}
	// 82EC1E70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1E74: 48000084  b 0x82ec1ef8
	pc = 0x82EC1EF8; continue 'dispatch;
	// 82EC1E78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1E7C: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EC1E80: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EC1E84: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EC1E88: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC1E8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1E90: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1E98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1E9C: 4E800421  bctrl
	ctx.lr = 0x82EC1EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1EA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1EA4: 4182FFCC  beq 0x82ec1e70
	if ctx.cr[0].eq {
	pc = 0x82EC1E70; continue 'dispatch;
	}
	// 82EC1EA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1EAC: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82EC1EB0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EC1EB4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EC1EB8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC1EBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1EC0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1EC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1ECC: 4E800421  bctrl
	ctx.lr = 0x82EC1ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1ED0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1ED4: 4182FF9C  beq 0x82ec1e70
	if ctx.cr[0].eq {
	pc = 0x82EC1E70; continue 'dispatch;
	}
	// 82EC1ED8: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1EDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1EE0: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1EE4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC1EE8: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1EEC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC1EF0: 41990008  bgt cr6, 0x82ec1ef8
	if ctx.cr[6].gt {
	pc = 0x82EC1EF8; continue 'dispatch;
	}
	// 82EC1EF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1EF8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EC1EFC: 4BDE7554  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC1F00 size=36
    let mut pc: u32 = 0x82EC1F00;
    'dispatch: loop {
        match pc {
            0x82EC1F00 => {
    //   block [0x82EC1F00..0x82EC1F24)
	// 82EC1F00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1F04: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82EC1F08: 806B0228  lwz r3, 0x228(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EC1F0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1F10: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1F14: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1F18: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1F1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC1F20: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1F28 size=88
    let mut pc: u32 = 0x82EC1F28;
    'dispatch: loop {
        match pc {
            0x82EC1F28 => {
    //   block [0x82EC1F28..0x82EC1F80)
	// 82EC1F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC1F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1F38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1F40: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 82EC1F44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC1F48: 4B7549E1  bl 0x82616928
	ctx.lr = 0x82EC1F4C;
	sub_82616928(ctx, base);
	// 82EC1F4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1F50: 41820014  beq 0x82ec1f64
	if ctx.cr[0].eq {
	pc = 0x82EC1F64; continue 'dispatch;
	}
	// 82EC1F54: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC1F58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC1F5C: 4BFF354D  bl 0x82eb54a8
	ctx.lr = 0x82EC1F60;
	sub_82EB54A8(ctx, base);
	// 82EC1F60: 48000008  b 0x82ec1f68
	pc = 0x82EC1F68; continue 'dispatch;
	// 82EC1F64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1F68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1F74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1F78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1F80 size=164
    let mut pc: u32 = 0x82EC1F80;
    'dispatch: loop {
        match pc {
            0x82EC1F80 => {
    //   block [0x82EC1F80..0x82EC2024)
	// 82EC1F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1F84: 4BDE7489  bl 0x82ca940c
	ctx.lr = 0x82EC1F88;
	sub_82CA93D0(ctx, base);
	// 82EC1F88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1F8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC1F90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC1F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1F98: 482FA0C9  bl 0x831bc060
	ctx.lr = 0x82EC1F9C;
	sub_831BC060(ctx, base);
	// 82EC1F9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1FA0: 41820070  beq 0x82ec2010
	if ctx.cr[0].eq {
	pc = 0x82EC2010; continue 'dispatch;
	}
	// 82EC1FA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1FAC: 3BCBB094  addi r30, r11, -0x4f6c
	ctx.r[30].s64 = ctx.r[11].s64 + -20332;
	// 82EC1FB0: 482FA0B1  bl 0x831bc060
	ctx.lr = 0x82EC1FB4;
	sub_831BC060(ctx, base);
	// 82EC1FB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1FB8: 4BDEAB99  bl 0x82cacb50
	ctx.lr = 0x82EC1FBC;
	sub_82CACB50(ctx, base);
	// 82EC1FBC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1FC0: 40820050  bne 0x82ec2010
	if !ctx.cr[0].eq {
	pc = 0x82EC2010; continue 'dispatch;
	}
	// 82EC1FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1FC8: 4BA4BD41  bl 0x8290dd08
	ctx.lr = 0x82EC1FCC;
	sub_8290DD08(ctx, base);
	// 82EC1FCC: 4BDE9BE5  bl 0x82cabbb0
	ctx.lr = 0x82EC1FD0;
	sub_82CABBB0(ctx, base);
	// 82EC1FD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC1FD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1FD8: C1BD000C  lfs f13, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1FDC: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1FE0: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC1FE4: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1FE8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC1FEC: 41980010  blt cr6, 0x82ec1ffc
	if ctx.cr[6].lt {
	pc = 0x82EC1FFC; continue 'dispatch;
	}
	// 82EC1FF0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC1FF4: 41990008  bgt cr6, 0x82ec1ffc
	if ctx.cr[6].gt {
	pc = 0x82EC1FFC; continue 'dispatch;
	}
	// 82EC1FF8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EC1FFC: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EC2000: 409AFFE8  bne cr6, 0x82ec1fe8
	if !ctx.cr[6].eq {
	pc = 0x82EC1FE8; continue 'dispatch;
	}
	// 82EC2004: D1BD000C  stfs f13, 0xc(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2008: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC200C: 48000010  b 0x82ec201c
	pc = 0x82EC201C; continue 'dispatch;
	// 82EC2010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC2014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2018: 4BFF3409  bl 0x82eb5420
	ctx.lr = 0x82EC201C;
	sub_82EB5420(ctx, base);
	// 82EC201C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2020: 4BDE743C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2028 size=96
    let mut pc: u32 = 0x82EC2028;
    'dispatch: loop {
        match pc {
            0x82EC2028 => {
    //   block [0x82EC2028..0x82EC2088)
	// 82EC2028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC202C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2030: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2034: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2038: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC203C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2040: C00B0B24  lfs f0, 0xb24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2044: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2048: 48002031  bl 0x82ec4078
	ctx.lr = 0x82EC204C;
	sub_82EC4078(ctx, base);
	// 82EC204C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2050: 4082000C  bne 0x82ec205c
	if !ctx.cr[0].eq {
	pc = 0x82EC205C; continue 'dispatch;
	}
	// 82EC2054: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2058: 4800001C  b 0x82ec2074
	pc = 0x82EC2074; continue 'dispatch;
	// 82EC205C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2064: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC2068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC206C: 4E800421  bctrl
	ctx.lr = 0x82EC2070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2070: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2074: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC2078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC207C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC2088 size=72
    let mut pc: u32 = 0x82EC2088;
    'dispatch: loop {
        match pc {
            0x82EC2088 => {
    //   block [0x82EC2088..0x82EC20D0)
	// 82EC2088: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC208C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2090: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2094: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2098: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC209C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC20A0: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC20A4: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC20A8: C1AB0BEC  lfs f13, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC20AC: D1A30028  stfs f13, 0x28(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC20B0: D1A3002C  stfs f13, 0x2c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC20B4: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EC20B8: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC20BC: C0030028  lfs f0, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC20C0: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EC20C4: C003002C  lfs f0, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC20C8: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EC20CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC20D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC20D0 size=24
    let mut pc: u32 = 0x82EC20D0;
    'dispatch: loop {
        match pc {
            0x82EC20D0 => {
    //   block [0x82EC20D0..0x82EC20E8)
	// 82EC20D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC20D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC20D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC20DC: 894A0400  lbz r10, 0x400(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC20E0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC20E4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC20E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC20E8 size=132
    let mut pc: u32 = 0x82EC20E8;
    'dispatch: loop {
        match pc {
            0x82EC20E8 => {
    //   block [0x82EC20E8..0x82EC216C)
	// 82EC20E8: C18B0014  lfs f12, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC20EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC20F0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC20F4: ED600332  fmuls f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC20F8: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC20FC: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EC2100: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2104: 41980028  blt cr6, 0x82ec212c
	if ctx.cr[6].lt {
	pc = 0x82EC212C; continue 'dispatch;
	}
	// 82EC2108: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC210C: ED400332  fmuls f10, f0, f12
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC2110: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EC2114: 41990018  bgt cr6, 0x82ec212c
	if ctx.cr[6].gt {
	pc = 0x82EC212C; continue 'dispatch;
	}
	// 82EC2118: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC211C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2120: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2124: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2128: 40990030  ble cr6, 0x82ec2158
	if !ctx.cr[6].gt {
	pc = 0x82EC2158; continue 'dispatch;
	}
	// 82EC212C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC2130: 814A0718  lwz r10, 0x718(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2134: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2138: 41820008  beq 0x82ec2140
	if ctx.cr[0].eq {
	pc = 0x82EC2140; continue 'dispatch;
	}
	// 82EC213C: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2140: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2144: C00A0A94  lfs f0, 0xa94(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2148: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC214C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EC2150: 40990008  ble cr6, 0x82ec2158
	if !ctx.cr[6].gt {
	pc = 0x82EC2158; continue 'dispatch;
	}
	// 82EC2154: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2158: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC215C: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2160: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2164: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2170 size=468
    let mut pc: u32 = 0x82EC2170;
    'dispatch: loop {
        match pc {
            0x82EC2170 => {
    //   block [0x82EC2170..0x82EC2344)
	// 82EC2170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC217C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2180: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82EC2184: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EC2188: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC218C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2190: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2194: 897E0400  lbz r11, 0x400(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC2198: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC219C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC21A0: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC21A4: 409A00A8  bne cr6, 0x82ec224c
	if !ctx.cr[6].eq {
	pc = 0x82EC224C; continue 'dispatch;
	}
	// 82EC21A8: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21AC: C1BE0404  lfs f13, 0x404(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC21B0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC21B4: 409A0028  bne cr6, 0x82ec21dc
	if !ctx.cr[6].eq {
	pc = 0x82EC21DC; continue 'dispatch;
	}
	// 82EC21B8: C01E0408  lfs f0, 0x408(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21BC: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC21C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC21C4: 409A0018  bne cr6, 0x82ec21dc
	if !ctx.cr[6].eq {
	pc = 0x82EC21DC; continue 'dispatch;
	}
	// 82EC21C8: C01E040C  lfs f0, 0x40c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC21D0: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC21D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC21D8: 419A0008  beq cr6, 0x82ec21e0
	if ctx.cr[6].eq {
	pc = 0x82EC21E0; continue 'dispatch;
	}
	// 82EC21DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC21E0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC21E4: 41820068  beq 0x82ec224c
	if ctx.cr[0].eq {
	pc = 0x82EC224C; continue 'dispatch;
	}
	// 82EC21E8: C01E0404  lfs f0, 0x404(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21EC: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EC21F0: C01E0408  lfs f0, 0x408(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21F4: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC21F8: C01E040C  lfs f0, 0x40c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21FC: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC2200: D3FF0010  stfs f31, 0x10(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2204: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2208: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC220C: C01E0404  lfs f0, 0x404(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2210: C1BE0408  lfs f13, 0x408(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1032 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2214: C19E040C  lfs f12, 0x40c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1036 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2218: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC221C: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2220: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC2224: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2228: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC222C: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2230: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC2234: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2238: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC223C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2240: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2244: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC2248: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC224C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2250: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2254: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EC2258: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC225C: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2260: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC2264: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2268: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC226C: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2270: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2274: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2278: C17F0034  lfs f11, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC227C: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2280: 419A0020  beq cr6, 0x82ec22a0
	if ctx.cr[6].eq {
	pc = 0x82EC22A0; continue 'dispatch;
	}
	// 82EC2284: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC2288: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC228C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC2290: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC2294: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC2298: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EC229C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC22A0: 4B39E719  bl 0x822609b8
	ctx.lr = 0x82EC22A4;
	sub_822609B8(ctx, base);
	// 82EC22A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC22A8: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC22AC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC22B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC22B4: 388AC7F0  addi r4, r10, -0x3810
	ctx.r[4].s64 = ctx.r[10].s64 + -14352;
	// 82EC22B8: C3CB0058  lfs f30, 0x58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC22BC: 4BFBB405  bl 0x82e7d6c0
	ctx.lr = 0x82EC22C0;
	sub_82E7D6C0(ctx, base);
	// 82EC22C0: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC22C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC22C8: 4182001C  beq 0x82ec22e4
	if ctx.cr[0].eq {
	pc = 0x82EC22E4; continue 'dispatch;
	}
	// 82EC22CC: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC22D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC22D4: 4182000C  beq 0x82ec22e0
	if ctx.cr[0].eq {
	pc = 0x82EC22E0; continue 'dispatch;
	}
	// 82EC22D8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC22DC: 48000008  b 0x82ec22e4
	pc = 0x82EC22E4; continue 'dispatch;
	// 82EC22E0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EC22E4: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC22E8: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC22EC: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC22F0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC22F4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC22F8: D1BF0020  stfs f13, 0x20(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC22FC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2300: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2304: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2308: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC230C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2310: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC2314: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2318: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EC231C: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2320: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EC2324: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC2328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC232C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2330: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC2334: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EC2338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC233C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2348 size=84
    let mut pc: u32 = 0x82EC2348;
    'dispatch: loop {
        match pc {
            0x82EC2348 => {
    //   block [0x82EC2348..0x82EC239C)
	// 82EC2348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC234C: 4BDE70C1  bl 0x82ca940c
	ctx.lr = 0x82EC2350;
	sub_82CA93D0(ctx, base);
	// 82EC2350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2354: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2358: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC235C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2360: 4B7545C9  bl 0x82616928
	ctx.lr = 0x82EC2364;
	sub_82616928(ctx, base);
	// 82EC2364: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2368: 41820028  beq 0x82ec2390
	if ctx.cr[0].eq {
	pc = 0x82EC2390; continue 'dispatch;
	}
	// 82EC236C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC2370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2378: 4BFF2FB9  bl 0x82eb5330
	ctx.lr = 0x82EC237C;
	sub_82EB5330(ctx, base);
	// 82EC237C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2384: 396BA800  addi r11, r11, -0x5800
	ctx.r[11].s64 = ctx.r[11].s64 + -22528;
	// 82EC2388: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC238C: 48000008  b 0x82ec2394
	pc = 0x82EC2394; continue 'dispatch;
	// 82EC2390: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2394: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2398: 4BDE70C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC23A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC23A0 size=24
    let mut pc: u32 = 0x82EC23A0;
    'dispatch: loop {
        match pc {
            0x82EC23A0 => {
    //   block [0x82EC23A0..0x82EC23B8)
	// 82EC23A0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC23A4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC23A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC23AC: 4182000C  beq 0x82ec23b8
	if ctx.cr[0].eq {
		sub_82EC23B8(ctx, base);
		return;
	}
	// 82EC23B0: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC23B4: 4800000C  b 0x82ec23c0
	sub_82EC23B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC23B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC23B8 size=16
    let mut pc: u32 = 0x82EC23B8;
    'dispatch: loop {
        match pc {
            0x82EC23B8 => {
    //   block [0x82EC23B8..0x82EC23C8)
	// 82EC23B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC23BC: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC23C0: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC23C4: 48001CB4  b 0x82ec4078
	sub_82EC4078(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC23C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC23C8 size=80
    let mut pc: u32 = 0x82EC23C8;
    'dispatch: loop {
        match pc {
            0x82EC23C8 => {
    //   block [0x82EC23C8..0x82EC2418)
	// 82EC23C8: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC23CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC23D0: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC23D4: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC23D8: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC23DC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC23E0: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC23E4: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC23E8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC23EC: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC23F0: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC23F4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC23F8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC23FC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2400: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2404: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC2408: 41980008  blt cr6, 0x82ec2410
	if ctx.cr[6].lt {
	pc = 0x82EC2410; continue 'dispatch;
	}
	// 82EC240C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC2410: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC2414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC2418 size=12
    let mut pc: u32 = 0x82EC2418;
    'dispatch: loop {
        match pc {
            0x82EC2418 => {
    //   block [0x82EC2418..0x82EC2424)
	// 82EC2418: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC241C: 386BDC08  addi r3, r11, -0x23f8
	ctx.r[3].s64 = ctx.r[11].s64 + -9208;
	// 82EC2420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2428 size=84
    let mut pc: u32 = 0x82EC2428;
    'dispatch: loop {
        match pc {
            0x82EC2428 => {
    //   block [0x82EC2428..0x82EC247C)
	// 82EC2428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC242C: 4BDE6FE1  bl 0x82ca940c
	ctx.lr = 0x82EC2430;
	sub_82CA93D0(ctx, base);
	// 82EC2430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2434: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2438: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EC243C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2440: 4B7544E9  bl 0x82616928
	ctx.lr = 0x82EC2444;
	sub_82616928(ctx, base);
	// 82EC2444: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2448: 41820028  beq 0x82ec2470
	if ctx.cr[0].eq {
	pc = 0x82EC2470; continue 'dispatch;
	}
	// 82EC244C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC2450: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2458: 4BFF2ED9  bl 0x82eb5330
	ctx.lr = 0x82EC245C;
	sub_82EB5330(ctx, base);
	// 82EC245C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2464: 396BB0E8  addi r11, r11, -0x4f18
	ctx.r[11].s64 = ctx.r[11].s64 + -20248;
	// 82EC2468: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC246C: 48000008  b 0x82ec2474
	pc = 0x82EC2474; continue 'dispatch;
	// 82EC2470: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2478: 4BDE6FE4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2480 size=192
    let mut pc: u32 = 0x82EC2480;
    'dispatch: loop {
        match pc {
            0x82EC2480 => {
    //   block [0x82EC2480..0x82EC2540)
	// 82EC2480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2484: 4BDE6F89  bl 0x82ca940c
	ctx.lr = 0x82EC2488;
	sub_82CA93D0(ctx, base);
	// 82EC2488: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC248C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2490: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC2494: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC2498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC249C: 482F9BC5  bl 0x831bc060
	ctx.lr = 0x82EC24A0;
	sub_831BC060(ctx, base);
	// 82EC24A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC24A4: 41820084  beq 0x82ec2528
	if ctx.cr[0].eq {
	pc = 0x82EC2528; continue 'dispatch;
	}
	// 82EC24A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC24AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC24B0: 3BCBAF1C  addi r30, r11, -0x50e4
	ctx.r[30].s64 = ctx.r[11].s64 + -20708;
	// 82EC24B4: 482F9BAD  bl 0x831bc060
	ctx.lr = 0x82EC24B8;
	sub_831BC060(ctx, base);
	// 82EC24B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC24BC: 4BDEA695  bl 0x82cacb50
	ctx.lr = 0x82EC24C0;
	sub_82CACB50(ctx, base);
	// 82EC24C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC24C4: 40820064  bne 0x82ec2528
	if !ctx.cr[0].eq {
	pc = 0x82EC2528; continue 'dispatch;
	}
	// 82EC24C8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC24CC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC24D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC24D4: 4182000C  beq 0x82ec24e0
	if ctx.cr[0].eq {
	pc = 0x82EC24E0; continue 'dispatch;
	}
	// 82EC24D8: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC24DC: 4800000C  b 0x82ec24e8
	pc = 0x82EC24E8; continue 'dispatch;
	// 82EC24E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC24E4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC24E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC24EC: 4BA4B81D  bl 0x8290dd08
	ctx.lr = 0x82EC24F0;
	sub_8290DD08(ctx, base);
	// 82EC24F0: 4BDE96C1  bl 0x82cabbb0
	ctx.lr = 0x82EC24F4;
	sub_82CABBB0(ctx, base);
	// 82EC24F4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC24F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC24FC: C01D0014  lfs f0, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2500: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2504: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC2508: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC250C: 40990008  ble cr6, 0x82ec2514
	if !ctx.cr[6].gt {
	pc = 0x82EC2514; continue 'dispatch;
	}
	// 82EC2510: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC2514: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC2518: 409AFFF0  bne cr6, 0x82ec2508
	if !ctx.cr[6].eq {
	pc = 0x82EC2508; continue 'dispatch;
	}
	// 82EC251C: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2520: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2524: 48000010  b 0x82ec2534
	pc = 0x82EC2534; continue 'dispatch;
	// 82EC2528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC252C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2530: 48000231  bl 0x82ec2760
	ctx.lr = 0x82EC2534;
	sub_82EC2760(ctx, base);
	// 82EC2534: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC2538: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC253C: 4BDE6F20  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2540 size=136
    let mut pc: u32 = 0x82EC2540;
    'dispatch: loop {
        match pc {
            0x82EC2540 => {
    //   block [0x82EC2540..0x82EC25C8)
	// 82EC2540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC254C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2550: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2558: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC255C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2560: 4182000C  beq 0x82ec256c
	if ctx.cr[0].eq {
	pc = 0x82EC256C; continue 'dispatch;
	}
	// 82EC2564: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2568: 4800000C  b 0x82ec2574
	pc = 0x82EC2574; continue 'dispatch;
	// 82EC256C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2570: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2574: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC257C: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2580: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2584: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2588: 48000299  bl 0x82ec2820
	ctx.lr = 0x82EC258C;
	sub_82EC2820(ctx, base);
	// 82EC258C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2590: 4082000C  bne 0x82ec259c
	if !ctx.cr[0].eq {
	pc = 0x82EC259C; continue 'dispatch;
	}
	// 82EC2594: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2598: 4800001C  b 0x82ec25b4
	pc = 0x82EC25B4; continue 'dispatch;
	// 82EC259C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC25A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC25A4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC25A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC25AC: 4E800421  bctrl
	ctx.lr = 0x82EC25B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC25B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC25B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC25B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC25BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC25C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC25C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC25C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC25C8 size=16
    let mut pc: u32 = 0x82EC25C8;
    'dispatch: loop {
        match pc {
            0x82EC25C8 => {
    //   block [0x82EC25C8..0x82EC25D8)
	// 82EC25C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC25CC: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC25D0: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC25D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC25D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC25D8 size=304
    let mut pc: u32 = 0x82EC25D8;
    'dispatch: loop {
        match pc {
            0x82EC25D8 => {
    //   block [0x82EC25D8..0x82EC2708)
	// 82EC25D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC25DC: 4BDE6E31  bl 0x82ca940c
	ctx.lr = 0x82EC25E0;
	sub_82CA93D0(ctx, base);
	// 82EC25E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC25E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC25E8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC25EC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EC25F0: 48000301  bl 0x82ec28f0
	ctx.lr = 0x82EC25F4;
	sub_82EC28F0(ctx, base);
	// 82EC25F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC25F8: 4182000C  beq 0x82ec2604
	if ctx.cr[0].eq {
	pc = 0x82EC2604; continue 'dispatch;
	}
	// 82EC25FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2600: 480000F8  b 0x82ec26f8
	pc = 0x82EC26F8; continue 'dispatch;
	// 82EC2604: 4B39E3B5  bl 0x822609b8
	ctx.lr = 0x82EC2608;
	sub_822609B8(ctx, base);
	// 82EC2608: C1BE0018  lfs f13, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC260C: C003004C  lfs f0, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2610: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC2614: 40990018  ble cr6, 0x82ec262c
	if !ctx.cr[6].gt {
	pc = 0x82EC262C; continue 'dispatch;
	}
	// 82EC2618: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC261C: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2620: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2624: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2628: 480000CC  b 0x82ec26f4
	pc = 0x82EC26F4; continue 'dispatch;
	// 82EC262C: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2630: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2634: C15D0004  lfs f10, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2638: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC263C: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC2640: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2644: C13D0008  lfs f9, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC2648: EDAD4828  fsubs f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC264C: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2650: C15D000C  lfs f10, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2654: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC2658: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC265C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2660: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2664: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC2668: 4098008C  bge cr6, 0x82ec26f4
	if !ctx.cr[6].lt {
	pc = 0x82EC26F4; continue 'dispatch;
	}
	// 82EC266C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2670: 806B023C  lwz r3, 0x23c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EC2674: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2678: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC267C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2680: 4E800421  bctrl
	ctx.lr = 0x82EC2684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2684: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC2688: 396BD244  addi r11, r11, -0x2dbc
	ctx.r[11].s64 = ctx.r[11].s64 + -11708;
	// 82EC268C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC2690: 419A0070  beq cr6, 0x82ec2700
	if ctx.cr[6].eq {
	pc = 0x82EC2700; continue 'dispatch;
	}
	// 82EC2694: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EC2698: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC269C: 4082FFF0  bne 0x82ec268c
	if !ctx.cr[0].eq {
	pc = 0x82EC268C; continue 'dispatch;
	}
	// 82EC26A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC26A4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC26A8: 4182004C  beq 0x82ec26f4
	if ctx.cr[0].eq {
	pc = 0x82EC26F4; continue 'dispatch;
	}
	// 82EC26AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC26B0: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC26B4: C1AB03A8  lfs f13, 0x3a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(936 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC26B8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC26BC: 409A0028  bne cr6, 0x82ec26e4
	if !ctx.cr[6].eq {
	pc = 0x82EC26E4; continue 'dispatch;
	}
	// 82EC26C0: C00B03AC  lfs f0, 0x3ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(940 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC26C4: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC26C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC26CC: 409A0018  bne cr6, 0x82ec26e4
	if !ctx.cr[6].eq {
	pc = 0x82EC26E4; continue 'dispatch;
	}
	// 82EC26D0: C00B03B0  lfs f0, 0x3b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(944 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC26D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC26D8: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC26DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC26E0: 419A0008  beq cr6, 0x82ec26e8
	if ctx.cr[6].eq {
	pc = 0x82EC26E8; continue 'dispatch;
	}
	// 82EC26E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC26E8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC26EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC26F0: 40820008  bne 0x82ec26f8
	if !ctx.cr[0].eq {
	pc = 0x82EC26F8; continue 'dispatch;
	}
	// 82EC26F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC26F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC26FC: 4BDE6D60  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82EC2700: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC2704: 4BFFFFA0  b 0x82ec26a4
	pc = 0x82EC26A4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2708 size=84
    let mut pc: u32 = 0x82EC2708;
    'dispatch: loop {
        match pc {
            0x82EC2708 => {
    //   block [0x82EC2708..0x82EC275C)
	// 82EC2708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC270C: 4BDE6D01  bl 0x82ca940c
	ctx.lr = 0x82EC2710;
	sub_82CA93D0(ctx, base);
	// 82EC2710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2714: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2718: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EC271C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2720: 4B754209  bl 0x82616928
	ctx.lr = 0x82EC2724;
	sub_82616928(ctx, base);
	// 82EC2724: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2728: 41820028  beq 0x82ec2750
	if ctx.cr[0].eq {
	pc = 0x82EC2750; continue 'dispatch;
	}
	// 82EC272C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC2730: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2738: 4BFF2BF9  bl 0x82eb5330
	ctx.lr = 0x82EC273C;
	sub_82EB5330(ctx, base);
	// 82EC273C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2744: 396BA7E8  addi r11, r11, -0x5818
	ctx.r[11].s64 = ctx.r[11].s64 + -22552;
	// 82EC2748: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC274C: 48000008  b 0x82ec2754
	pc = 0x82EC2754; continue 'dispatch;
	// 82EC2750: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2758: 4BDE6D04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2760 size=192
    let mut pc: u32 = 0x82EC2760;
    'dispatch: loop {
        match pc {
            0x82EC2760 => {
    //   block [0x82EC2760..0x82EC2820)
	// 82EC2760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2764: 4BDE6CA9  bl 0x82ca940c
	ctx.lr = 0x82EC2768;
	sub_82CA93D0(ctx, base);
	// 82EC2768: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC276C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2770: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC2774: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC2778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC277C: 482F98E5  bl 0x831bc060
	ctx.lr = 0x82EC2780;
	sub_831BC060(ctx, base);
	// 82EC2780: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2784: 41820084  beq 0x82ec2808
	if ctx.cr[0].eq {
	pc = 0x82EC2808; continue 'dispatch;
	}
	// 82EC2788: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC278C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2790: 3BCBA628  addi r30, r11, -0x59d8
	ctx.r[30].s64 = ctx.r[11].s64 + -23000;
	// 82EC2794: 482F98CD  bl 0x831bc060
	ctx.lr = 0x82EC2798;
	sub_831BC060(ctx, base);
	// 82EC2798: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC279C: 4BDEA3B5  bl 0x82cacb50
	ctx.lr = 0x82EC27A0;
	sub_82CACB50(ctx, base);
	// 82EC27A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC27A4: 40820064  bne 0x82ec2808
	if !ctx.cr[0].eq {
	pc = 0x82EC2808; continue 'dispatch;
	}
	// 82EC27A8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC27AC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC27B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC27B4: 4182000C  beq 0x82ec27c0
	if ctx.cr[0].eq {
	pc = 0x82EC27C0; continue 'dispatch;
	}
	// 82EC27B8: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC27BC: 4800000C  b 0x82ec27c8
	pc = 0x82EC27C8; continue 'dispatch;
	// 82EC27C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC27C4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC27C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC27CC: 4BA4B53D  bl 0x8290dd08
	ctx.lr = 0x82EC27D0;
	sub_8290DD08(ctx, base);
	// 82EC27D0: 4BDE93E1  bl 0x82cabbb0
	ctx.lr = 0x82EC27D4;
	sub_82CABBB0(ctx, base);
	// 82EC27D4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC27D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC27DC: C01D0010  lfs f0, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC27E0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC27E4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC27E8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC27EC: 40990008  ble cr6, 0x82ec27f4
	if !ctx.cr[6].gt {
	pc = 0x82EC27F4; continue 'dispatch;
	}
	// 82EC27F0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC27F4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC27F8: 409AFFF0  bne cr6, 0x82ec27e8
	if !ctx.cr[6].eq {
	pc = 0x82EC27E8; continue 'dispatch;
	}
	// 82EC27FC: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2800: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2804: 48000010  b 0x82ec2814
	pc = 0x82EC2814; continue 'dispatch;
	// 82EC2808: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC280C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2810: 4BFF2C11  bl 0x82eb5420
	ctx.lr = 0x82EC2814;
	sub_82EB5420(ctx, base);
	// 82EC2814: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC2818: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC281C: 4BDE6C40  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2820 size=204
    let mut pc: u32 = 0x82EC2820;
    'dispatch: loop {
        match pc {
            0x82EC2820 => {
    //   block [0x82EC2820..0x82EC28EC)
	// 82EC2820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC282C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2838: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC283C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC2840: 388AC178  addi r4, r10, -0x3e88
	ctx.r[4].s64 = ctx.r[10].s64 + -16008;
	// 82EC2844: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC2848: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC284C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2850: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC2854: 4B325E25  bl 0x821e8678
	ctx.lr = 0x82EC2858;
	sub_821E8678(ctx, base);
	// 82EC2858: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC285C: 41820014  beq 0x82ec2870
	if ctx.cr[0].eq {
	pc = 0x82EC2870; continue 'dispatch;
	}
	// 82EC2860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2864: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2868: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC286C: 4800002C  b 0x82ec2898
	pc = 0x82EC2898; continue 'dispatch;
	// 82EC2870: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2874: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2878: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC287C: 4182000C  beq 0x82ec2888
	if ctx.cr[0].eq {
	pc = 0x82EC2888; continue 'dispatch;
	}
	// 82EC2880: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2884: 4800000C  b 0x82ec2890
	pc = 0x82EC2890; continue 'dispatch;
	// 82EC2888: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC288C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2890: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82EC2894: C00B5CC4  lfs f0, 0x5cc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(23748 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC289C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC28A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC28A4: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC28A8: 480017D1  bl 0x82ec4078
	ctx.lr = 0x82EC28AC;
	sub_82EC4078(ctx, base);
	// 82EC28AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC28B0: 4082000C  bne 0x82ec28bc
	if !ctx.cr[0].eq {
	pc = 0x82EC28BC; continue 'dispatch;
	}
	// 82EC28B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC28B8: 4800001C  b 0x82ec28d4
	pc = 0x82EC28D4; continue 'dispatch;
	// 82EC28BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC28C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC28C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC28C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC28CC: 4E800421  bctrl
	ctx.lr = 0x82EC28D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC28D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC28D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC28D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC28DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC28E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC28E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC28E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC28F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC28F0 size=24
    let mut pc: u32 = 0x82EC28F0;
    'dispatch: loop {
        match pc {
            0x82EC28F0 => {
    //   block [0x82EC28F0..0x82EC2908)
	// 82EC28F0: 8943000C  lbz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC28F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC28F8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC28FC: 4182000C  beq 0x82ec2908
	if ctx.cr[0].eq {
		sub_82EC2908(ctx, base);
		return;
	}
	// 82EC2900: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2904: 48000008  b 0x82ec290c
	sub_82EC2908(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC2908 size=96
    let mut pc: u32 = 0x82EC2908;
    'dispatch: loop {
        match pc {
            0x82EC2908 => {
    //   block [0x82EC2908..0x82EC2968)
	// 82EC2908: C00B0014  lfs f0, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC290C: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2910: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2914: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2918: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC291C: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2920: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2924: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2928: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC292C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2930: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC2934: 40980024  bge cr6, 0x82ec2958
	if !ctx.cr[6].lt {
	pc = 0x82EC2958; continue 'dispatch;
	}
	// 82EC2938: C1A50008  lfs f13, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC293C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC2940: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2944: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2948: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC294C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EC2950: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC2954: 41980008  blt cr6, 0x82ec295c
	if ctx.cr[6].lt {
	pc = 0x82EC295C; continue 'dispatch;
	}
	// 82EC2958: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC295C: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82EC2960: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC2964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC2968 size=12
    let mut pc: u32 = 0x82EC2968;
    'dispatch: loop {
        match pc {
            0x82EC2968 => {
    //   block [0x82EC2968..0x82EC2974)
	// 82EC2968: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC296C: 386BDE30  addi r3, r11, -0x21d0
	ctx.r[3].s64 = ctx.r[11].s64 + -8656;
	// 82EC2970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2978 size=84
    let mut pc: u32 = 0x82EC2978;
    'dispatch: loop {
        match pc {
            0x82EC2978 => {
    //   block [0x82EC2978..0x82EC29CC)
	// 82EC2978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC297C: 4BDE6A91  bl 0x82ca940c
	ctx.lr = 0x82EC2980;
	sub_82CA93D0(ctx, base);
	// 82EC2980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2988: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC298C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2990: 4B753F99  bl 0x82616928
	ctx.lr = 0x82EC2994;
	sub_82616928(ctx, base);
	// 82EC2994: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2998: 41820028  beq 0x82ec29c0
	if ctx.cr[0].eq {
	pc = 0x82EC29C0; continue 'dispatch;
	}
	// 82EC299C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC29A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC29A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC29A8: 4BFF2989  bl 0x82eb5330
	ctx.lr = 0x82EC29AC;
	sub_82EB5330(ctx, base);
	// 82EC29AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC29B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC29B4: 396BB148  addi r11, r11, -0x4eb8
	ctx.r[11].s64 = ctx.r[11].s64 + -20152;
	// 82EC29B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC29BC: 48000008  b 0x82ec29c4
	pc = 0x82EC29C4; continue 'dispatch;
	// 82EC29C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC29C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC29C8: 4BDE6A94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC29D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC29D0 size=84
    let mut pc: u32 = 0x82EC29D0;
    'dispatch: loop {
        match pc {
            0x82EC29D0 => {
    //   block [0x82EC29D0..0x82EC2A24)
	// 82EC29D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC29D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC29D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC29DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC29E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC29E4: 48001695  bl 0x82ec4078
	ctx.lr = 0x82EC29E8;
	sub_82EC4078(ctx, base);
	// 82EC29E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC29EC: 4082000C  bne 0x82ec29f8
	if !ctx.cr[0].eq {
	pc = 0x82EC29F8; continue 'dispatch;
	}
	// 82EC29F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC29F4: 4800001C  b 0x82ec2a10
	pc = 0x82EC2A10; continue 'dispatch;
	// 82EC29F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC29FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2A00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC2A04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2A08: 4E800421  bctrl
	ctx.lr = 0x82EC2A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2A0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2A10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC2A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC2A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2A1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC2A28 size=28
    let mut pc: u32 = 0x82EC2A28;
    'dispatch: loop {
        match pc {
            0x82EC2A28 => {
    //   block [0x82EC2A28..0x82EC2A44)
	// 82EC2A28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC2A2C: 892B000C  lbz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC2A30: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2A34: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2A38: 4182000C  beq 0x82ec2a44
	if ctx.cr[0].eq {
		sub_82EC2A44(ctx, base);
		return;
	}
	// 82EC2A3C: C00A0018  lfs f0, 0x18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2A40: 48000008  b 0x82ec2a48
	sub_82EC2A44(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2A44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC2A44 size=84
    let mut pc: u32 = 0x82EC2A44;
    'dispatch: loop {
        match pc {
            0x82EC2A44 => {
    //   block [0x82EC2A44..0x82EC2A98)
	// 82EC2A44: C00A0014  lfs f0, 0x14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2A48: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2A4C: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2A50: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2A54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC2A58: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2A5C: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2A60: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2A64: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2A68: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2A6C: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2A70: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC2A74: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2A78: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2A7C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2A80: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC2A84: 41980008  blt cr6, 0x82ec2a8c
	if ctx.cr[6].lt {
	pc = 0x82EC2A8C; continue 'dispatch;
	}
	// 82EC2A88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC2A8C: 5543063E  clrlwi r3, r10, 0x18
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EC2A90: 986B000C  stb r3, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[3].u8 ) };
	// 82EC2A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2A98 size=92
    let mut pc: u32 = 0x82EC2A98;
    'dispatch: loop {
        match pc {
            0x82EC2A98 => {
    //   block [0x82EC2A98..0x82EC2AF4)
	// 82EC2A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2AA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2AA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2AA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2AAC: 4BFF2885  bl 0x82eb5330
	ctx.lr = 0x82EC2AB0;
	sub_82EB5330(ctx, base);
	// 82EC2AB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2AB8: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2ABC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2AC0: 396BB184  addi r11, r11, -0x4e7c
	ctx.r[11].s64 = ctx.r[11].s64 + -20092;
	// 82EC2AC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC2AC8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2ACC: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2AD0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2AD4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2AD8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC2ADC: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2AE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC2AE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC2AE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC2AF8 size=12
    let mut pc: u32 = 0x82EC2AF8;
    'dispatch: loop {
        match pc {
            0x82EC2AF8 => {
    //   block [0x82EC2AF8..0x82EC2B04)
	// 82EC2AF8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC2AFC: 386BDF44  addi r3, r11, -0x20bc
	ctx.r[3].s64 = ctx.r[11].s64 + -8380;
	// 82EC2B00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC2B08 size=36
    let mut pc: u32 = 0x82EC2B08;
    'dispatch: loop {
        match pc {
            0x82EC2B08 => {
    //   block [0x82EC2B08..0x82EC2B2C)
	// 82EC2B08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2B0C: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2B10: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2B14: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2B18: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2B1C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2B20: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC2B24: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2B30 size=568
    let mut pc: u32 = 0x82EC2B30;
    'dispatch: loop {
        match pc {
            0x82EC2B30 => {
    //   block [0x82EC2B30..0x82EC2D68)
	// 82EC2B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2B34: 4BDE68D1  bl 0x82ca9404
	ctx.lr = 0x82EC2B38;
	sub_82CA93D0(ctx, base);
	// 82EC2B38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2B3C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC2B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2B44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC2B48: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2B4C: 4BFAD3AD  bl 0x82e6fef8
	ctx.lr = 0x82EC2B50;
	sub_82E6FEF8(ctx, base);
	// 82EC2B50: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC2B54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2B58: 388BB38C  addi r4, r11, -0x4c74
	ctx.r[4].s64 = ctx.r[11].s64 + -19572;
	// 82EC2B5C: 4BFC6B85  bl 0x82e896e0
	ctx.lr = 0x82EC2B60;
	sub_82E896E0(ctx, base);
	// 82EC2B60: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC2B64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B68: 41820038  beq 0x82ec2ba0
	if ctx.cr[0].eq {
	pc = 0x82EC2BA0; continue 'dispatch;
	}
	// 82EC2B6C: 8943001C  lbz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC2B70: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC2B74: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B78: 40820008  bne 0x82ec2b80
	if !ctx.cr[0].eq {
	pc = 0x82EC2B80; continue 'dispatch;
	}
	// 82EC2B7C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC2B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B84: 419A001C  beq cr6, 0x82ec2ba0
	if ctx.cr[6].eq {
	pc = 0x82EC2BA0; continue 'dispatch;
	}
	// 82EC2B88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B8C: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC2B90: 409A0008  bne cr6, 0x82ec2b98
	if !ctx.cr[6].eq {
	pc = 0x82EC2B98; continue 'dispatch;
	}
	// 82EC2B94: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC2B98: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC2B9C: 48000008  b 0x82ec2ba4
	pc = 0x82EC2BA4; continue 'dispatch;
	// 82EC2BA0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC2BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2BA8: 409A0170  bne cr6, 0x82ec2d18
	if !ctx.cr[6].eq {
	pc = 0x82EC2D18; continue 'dispatch;
	}
	// 82EC2BAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2BB0: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2BB4: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2BB8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2BBC: 419A0098  beq cr6, 0x82ec2c54
	if ctx.cr[6].eq {
	pc = 0x82EC2C54; continue 'dispatch;
	}
	// 82EC2BC0: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2BC4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2BC8: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2BCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2BD0: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2BD4: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2BD8: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2BDC: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC2BE0: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2BE4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2BE8: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2BEC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2BF0: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2BF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2BF8: 4182000C  beq 0x82ec2c04
	if ctx.cr[0].eq {
	pc = 0x82EC2C04; continue 'dispatch;
	}
	// 82EC2BFC: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2C00: 48000008  b 0x82ec2c08
	pc = 0x82EC2C08; continue 'dispatch;
	// 82EC2C04: FD405890  fmr f10, f11
	ctx.f[10].f64 = ctx.f[11].f64;
	// 82EC2C08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2C0C: 41820008  beq 0x82ec2c14
	if ctx.cr[0].eq {
	pc = 0x82EC2C14; continue 'dispatch;
	}
	// 82EC2C10: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2C14: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2C18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2C1C: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC2C20: ED8C033A  fmadds f12, f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2C24: C00B0BE8  lfs f0, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C28: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2C2C: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EC2C30: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2C34: 41990020  bgt cr6, 0x82ec2c54
	if ctx.cr[6].gt {
	pc = 0x82EC2C54; continue 'dispatch;
	}
	// 82EC2C38: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C3C: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC2C40: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C44: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC2C48: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C4C: D01C000C  stfs f0, 0xc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2C50: 4800010C  b 0x82ec2d5c
	pc = 0x82EC2D5C; continue 'dispatch;
	// 82EC2C54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2C58: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2C5C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2C60: 41820100  beq 0x82ec2d60
	if ctx.cr[0].eq {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2C64: 816A0048  lwz r11, 0x48(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2C6C: 419A00F4  beq cr6, 0x82ec2d60
	if ctx.cr[6].eq {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2C70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2C74: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82EC2C78: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82EC2C7C: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82EC2C80: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EC2C84: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82EC2C88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC2C8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2C90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC2C94: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC2C98: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EC2C9C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EC2CA0: 806A0048  lwz r3, 0x48(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2CA4: 4822BB55  bl 0x830ee7f8
	ctx.lr = 0x82EC2CA8;
	sub_830EE7F8(ctx, base);
	// 82EC2CA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2CAC: 40820054  bne 0x82ec2d00
	if !ctx.cr[0].eq {
	pc = 0x82EC2D00; continue 'dispatch;
	}
	// 82EC2CB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2CB4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC2CB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC2CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2CC0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC2CC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2CC8: 4E800421  bctrl
	ctx.lr = 0x82EC2CCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2CCC: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CD0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2CD4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CD8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2CDC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CE0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2CE4: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CE8: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2CEC: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CF0: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC2CF4: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CF8: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2CFC: 48000064  b 0x82ec2d60
	pc = 0x82EC2D60; continue 'dispatch;
	// 82EC2D00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC2D04: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EC2D08: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC2D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2D10: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC2D14: 419A004C  beq cr6, 0x82ec2d60
	if ctx.cr[6].eq {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2D18: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2D1C: C1BC0008  lfs f13, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2D20: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2D24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2D28: C17C000C  lfs f11, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2D2C: 41980010  blt cr6, 0x82ec2d3c
	if ctx.cr[6].lt {
	pc = 0x82EC2D3C; continue 'dispatch;
	}
	// 82EC2D30: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2D34: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EC2D38: 40990028  ble cr6, 0x82ec2d60
	if !ctx.cr[6].gt {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2D3C: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2D40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2D44: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2D48: D19C0004  stfs f12, 4(r28)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC2D4C: D17C000C  stfs f11, 0xc(r28)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2D50: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2D54: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2D58: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC2D5C: 9B7C0058  stb r27, 0x58(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(88 as u32), ctx.r[27].u8 ) };
	// 82EC2D60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EC2D64: 4BDE66F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2D68 size=708
    let mut pc: u32 = 0x82EC2D68;
    'dispatch: loop {
        match pc {
            0x82EC2D68 => {
    //   block [0x82EC2D68..0x82EC302C)
	// 82EC2D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2D6C: 4BDE6685  bl 0x82ca93f0
	ctx.lr = 0x82EC2D70;
	sub_82CA93D0(ctx, base);
	// 82EC2D70: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 82EC2D74: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82EC2D78: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82EC2D7C: 9421FB00  stwu r1, -0x500(r1)
	ea = ctx.r[1].u32.wrapping_add(-1280 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2D80: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EC2D84: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EC2D88: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82EC2D8C: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2D90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2D94: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EC2D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2D9C: 4E800421  bctrl
	ctx.lr = 0x82EC2DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2DA0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EC2DA4: 41820274  beq 0x82ec3018
	if ctx.cr[0].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2DAC: 48010AA5  bl 0x82ed3850
	ctx.lr = 0x82EC2DB0;
	sub_82ED3850(ctx, base);
	// 82EC2DB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2DB4: 41820264  beq 0x82ec3018
	if ctx.cr[0].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DB8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2DBC: 82EB0048  lwz r23, 0x48(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2DC0: 28170000  cmplwi r23, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2DC4: 41820254  beq 0x82ec3018
	if ctx.cr[0].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DC8: 81570048  lwz r10, 0x48(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2DCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC2DD0: 419A0248  beq cr6, 0x82ec3018
	if ctx.cr[6].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DD4: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC2DD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2DDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC2DE0: 388AC5C8  addi r4, r10, -0x3a38
	ctx.r[4].s64 = ctx.r[10].s64 + -14904;
	// 82EC2DE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2DE8: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC2DEC: C3CA0C18  lfs f30, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC2DF0: 4B325889  bl 0x821e8678
	ctx.lr = 0x82EC2DF4;
	sub_821E8678(ctx, base);
	// 82EC2DF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2DF8: 41820014  beq 0x82ec2e0c
	if ctx.cr[0].eq {
	pc = 0x82EC2E0C; continue 'dispatch;
	}
	// 82EC2DFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2E00: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2E04: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2E08: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2E0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2E10: 48010851  bl 0x82ed3660
	ctx.lr = 0x82EC2E14;
	sub_82ED3660(ctx, base);
	// 82EC2E14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2E18: C00B0EE0  lfs f0, 0xee0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2E1C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82EC2E20: 409A000C  bne cr6, 0x82ec2e2c
	if !ctx.cr[6].eq {
	pc = 0x82EC2E2C; continue 'dispatch;
	}
	// 82EC2E24: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2E28: C02B0024  lfs f1, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC2E2C: 3BF80004  addi r31, r24, 4
	ctx.r[31].s64 = ctx.r[24].s64 + 4;
	// 82EC2E30: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC2E34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC2E38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC2E3C: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 82EC2E40: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2E44: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 82EC2E48: ED600828  fsubs f11, f0, f1
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC2E4C: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2E50: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EC2E54: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC2E58: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EC2E5C: ED6D0828  fsubs f11, f13, f1
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC2E60: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2E64: EC0D082A  fadds f0, f13, f1
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EC2E68: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EC2E6C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EC2E70: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EC2E74: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EC2E78: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EC2E7C: ED6C0828  fsubs f11, f12, f1
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC2E80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2E84: EC0C082A  fadds f0, f12, f1
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EC2E88: D1610078  stfs f11, 0x78(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EC2E8C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EC2E90: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EC2E94: 480125CD  bl 0x82ed5460
	ctx.lr = 0x82EC2E98;
	sub_82ED5460(ctx, base);
	// 82EC2E98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2E9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2EA0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2EA4: C3AA0BEC  lfs f29, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EC2EA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2EAC: 4182000C  beq 0x82ec2eb8
	if ctx.cr[0].eq {
	pc = 0x82EC2EB8; continue 'dispatch;
	}
	// 82EC2EB0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2EB4: 4800000C  b 0x82ec2ec0
	pc = 0x82EC2EC0; continue 'dispatch;
	// 82EC2EB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2EBC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2EC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2EC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC2EC8: C00B0BF8  lfs f0, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2ECC: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2ED0: 419A0148  beq cr6, 0x82ec3018
	if ctx.cr[6].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2ED4: 3B610090  addi r27, r1, 0x90
	ctx.r[27].s64 = ctx.r[1].s64 + 144;
	// 82EC2ED8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EC2EDC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2EE0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC2EE4: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82EC2EE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC2EEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC2EF0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EC2EF4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EC2EF8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EC2EFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EC2F00: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC2F04: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC2F08: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F0C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC2F10: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82EC2F14: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F18: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC2F1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2F20: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F24: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC2F28: 80770048  lwz r3, 0x48(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2F2C: 4822BE25  bl 0x830eed50
	ctx.lr = 0x82EC2F30;
	sub_830EED50(ctx, base);
	// 82EC2F30: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2F34: C1410060  lfs f10, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2F38: ED6A6828  fsubs f11, f10, f13
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2F3C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F40: C1210064  lfs f9, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC2F44: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC2F48: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2F4C: C1010068  lfs f8, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC2F50: ED886028  fsubs f12, f8, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2F54: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC2F58: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EC2F5C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2F60: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC2F64: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EC2F68: 41990018  bgt cr6, 0x82ec2f80
	if ctx.cr[6].gt {
	pc = 0x82EC2F80; continue 'dispatch;
	}
	// 82EC2F6C: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC2F70: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F74: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC2F78: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F7C: 48000040  b 0x82ec2fbc
	pc = 0x82EC2FBC; continue 'dispatch;
	// 82EC2F80: ECE0F828  fsubs f7, f0, f31
	ctx.f[7].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EC2F84: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2F88: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2F8C: ED4A6828  fsubs f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2F90: ED296028  fsubs f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2F94: ED085828  fsubs f8, f8, f11
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC2F98: EC070024  fdivs f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC2F9C: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2FA0: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2FA4: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2FA8: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EC2FAC: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC2FB0: ED8C482A  fadds f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EC2FB4: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC2FB8: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2FBC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2FC0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC2FC4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EC2FC8: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EC2FCC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EC2FD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC2FD4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EC2FD8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC2FDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2FE0: 4E800421  bctrl
	ctx.lr = 0x82EC2FE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2FE4: FF01E800  fcmpu cr6, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 82EC2FE8: 40980024  bge cr6, 0x82ec300c
	if !ctx.cr[6].lt {
	pc = 0x82EC300C; continue 'dispatch;
	}
	// 82EC2FEC: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2FF0: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82EC2FF4: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2FF8: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2FFC: D0160004  stfs f0, 4(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC3000: D1B60008  stfs f13, 8(r22)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC3004: D196000C  stfs f12, 0xc(r22)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC3008: 9B960058  stb r28, 0x58(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EC300C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82EC3010: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EC3014: 4082FEC8  bne 0x82ec2edc
	if !ctx.cr[0].eq {
	pc = 0x82EC2EDC; continue 'dispatch;
	}
	// 82EC3018: 38210500  addi r1, r1, 0x500
	ctx.r[1].s64 = ctx.r[1].s64 + 1280;
	// 82EC301C: CBA1FF90  lfd f29, -0x70(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82EC3020: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82EC3024: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82EC3028: 4BDE6418  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3030 size=88
    let mut pc: u32 = 0x82EC3030;
    'dispatch: loop {
        match pc {
            0x82EC3030 => {
    //   block [0x82EC3030..0x82EC3088)
	// 82EC3030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC303C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3048: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82EC304C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC3050: 4B7538D9  bl 0x82616928
	ctx.lr = 0x82EC3054;
	sub_82616928(ctx, base);
	// 82EC3054: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3058: 41820014  beq 0x82ec306c
	if ctx.cr[0].eq {
	pc = 0x82EC306C; continue 'dispatch;
	}
	// 82EC305C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC3060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC3064: 4BFFFA35  bl 0x82ec2a98
	ctx.lr = 0x82EC3068;
	sub_82EC2A98(ctx, base);
	// 82EC3068: 48000008  b 0x82ec3070
	pc = 0x82EC3070; continue 'dispatch;
	// 82EC306C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC307C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC3080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3088 size=164
    let mut pc: u32 = 0x82EC3088;
    'dispatch: loop {
        match pc {
            0x82EC3088 => {
    //   block [0x82EC3088..0x82EC312C)
	// 82EC3088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC308C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC3094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC309C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC30A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC30A4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EC30A8: 3BC60004  addi r30, r6, 4
	ctx.r[30].s64 = ctx.r[6].s64 + 4;
	// 82EC30AC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82EC30B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC30B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC30B8: C00A0C4C  lfs f0, 0xc4c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC30BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC30C0: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC30C4: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC30C8: 4B76C449  bl 0x8262f510
	ctx.lr = 0x82EC30CC;
	sub_8262F510(ctx, base);
	// 82EC30CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC30D0: 41820010  beq 0x82ec30e0
	if ctx.cr[0].eq {
	pc = 0x82EC30E0; continue 'dispatch;
	}
	// 82EC30D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC30D8: C02B0BEC  lfs f1, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC30DC: 48000038  b 0x82ec3114
	pc = 0x82EC3114; continue 'dispatch;
	// 82EC30E0: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC30E4: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC30E8: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC30EC: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC30F0: C15E0004  lfs f10, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC30F4: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC30F8: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC30FC: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3100: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3104: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3108: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC310C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3110: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC311C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC3120: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC3124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3128: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3130 size=84
    let mut pc: u32 = 0x82EC3130;
    'dispatch: loop {
        match pc {
            0x82EC3130 => {
    //   block [0x82EC3130..0x82EC3184)
	// 82EC3130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3134: 4BDE62D9  bl 0x82ca940c
	ctx.lr = 0x82EC3138;
	sub_82CA93D0(ctx, base);
	// 82EC3138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC313C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC3140: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EC3144: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC3148: 4B7537E1  bl 0x82616928
	ctx.lr = 0x82EC314C;
	sub_82616928(ctx, base);
	// 82EC314C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC3150: 41820028  beq 0x82ec3178
	if ctx.cr[0].eq {
	pc = 0x82EC3178; continue 'dispatch;
	}
	// 82EC3154: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC3158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC315C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3160: 4BFF21D1  bl 0x82eb5330
	ctx.lr = 0x82EC3164;
	sub_82EB5330(ctx, base);
	// 82EC3164: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC316C: 396BA7D0  addi r11, r11, -0x5830
	ctx.r[11].s64 = ctx.r[11].s64 + -22576;
	// 82EC3170: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC3174: 48000008  b 0x82ec317c
	pc = 0x82EC317C; continue 'dispatch;
	// 82EC3178: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC317C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3180: 4BDE62DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3188 size=224
    let mut pc: u32 = 0x82EC3188;
    'dispatch: loop {
        match pc {
            0x82EC3188 => {
    //   block [0x82EC3188..0x82EC3268)
	// 82EC3188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC318C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC3194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC319C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC31A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC31A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC31A8: 4BFACD51  bl 0x82e6fef8
	ctx.lr = 0x82EC31AC;
	sub_82E6FEF8(ctx, base);
	// 82EC31AC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC31B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC31B4: 388BB38C  addi r4, r11, -0x4c74
	ctx.r[4].s64 = ctx.r[11].s64 + -19572;
	// 82EC31B8: 4BFC6529  bl 0x82e896e0
	ctx.lr = 0x82EC31BC;
	sub_82E896E0(ctx, base);
	// 82EC31BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC31C0: 41820038  beq 0x82ec31f8
	if ctx.cr[0].eq {
	pc = 0x82EC31F8; continue 'dispatch;
	}
	// 82EC31C4: 8943001C  lbz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC31C8: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC31CC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC31D0: 40820008  bne 0x82ec31d8
	if !ctx.cr[0].eq {
	pc = 0x82EC31D8; continue 'dispatch;
	}
	// 82EC31D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC31D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC31DC: 419A001C  beq cr6, 0x82ec31f8
	if ctx.cr[6].eq {
	pc = 0x82EC31F8; continue 'dispatch;
	}
	// 82EC31E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC31E4: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC31E8: 409A0008  bne cr6, 0x82ec31f0
	if !ctx.cr[6].eq {
	pc = 0x82EC31F0; continue 'dispatch;
	}
	// 82EC31EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC31F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC31F4: 48000008  b 0x82ec31fc
	pc = 0x82EC31FC; continue 'dispatch;
	// 82EC31F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC31FC: C19E0004  lfs f12, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC3204: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3208: C17E000C  lfs f11, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC320C: 419A0044  beq cr6, 0x82ec3250
	if ctx.cr[6].eq {
	pc = 0x82EC3250; continue 'dispatch;
	}
	// 82EC3210: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3214: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC3218: 41980010  blt cr6, 0x82ec3228
	if ctx.cr[6].lt {
	pc = 0x82EC3228; continue 'dispatch;
	}
	// 82EC321C: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3220: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EC3224: 4099002C  ble cr6, 0x82ec3250
	if !ctx.cr[6].gt {
	pc = 0x82EC3250; continue 'dispatch;
	}
	// 82EC3228: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC322C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3230: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC3234: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC3238: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC323C: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3240: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC3244: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3248: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC324C: 997E0058  stb r11, 0x58(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EC3250: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC325C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC3260: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3268 size=592
    let mut pc: u32 = 0x82EC3268;
    'dispatch: loop {
        match pc {
            0x82EC3268 => {
    //   block [0x82EC3268..0x82EC34B8)
	// 82EC3268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC326C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC3274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3278: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82EC327C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EC3280: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3284: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC328C: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EC3290: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC3294: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3298: 394BB1E0  addi r10, r11, -0x4e20
	ctx.r[10].s64 = ctx.r[11].s64 + -20000;
	// 82EC329C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC32A0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EC32A4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC32A8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC32AC: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC32B0: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC32B4: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC32B8: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EC32BC: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC32C0: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC32C4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC32C8: D3FF0024  stfs f31, 0x24(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EC32CC: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC32D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC32D4: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC32D8: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC32DC: D3FF0034  stfs f31, 0x34(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EC32E0: D3FF0038  stfs f31, 0x38(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EC32E4: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82EC32E8: D3FF0040  stfs f31, 0x40(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EC32EC: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82EC32F0: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EC32F4: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC32F8: D3FF0050  stfs f31, 0x50(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC32FC: D3FF0054  stfs f31, 0x54(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3300: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC3304: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3308: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC330C: D3FF00C8  stfs f31, 0xc8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC3310: D3FF00CC  stfs f31, 0xcc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC3314: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 82EC3318: D3FF00D4  stfs f31, 0xd4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EC331C: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3320: C3CA0C14  lfs f30, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC3324: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3328: 4182000C  beq 0x82ec3334
	if ctx.cr[0].eq {
	pc = 0x82EC3334; continue 'dispatch;
	}
	// 82EC332C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3330: 48000008  b 0x82ec3338
	pc = 0x82EC3338; continue 'dispatch;
	// 82EC3334: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 82EC3338: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC333C: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EC3340: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC3344: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82EC3348: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC334C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3350: ED4D0032  fmuls f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3354: D15F00D8  stfs f10, 0xd8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EC3358: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC335C: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3360: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3364: D1BF00DC  stfs f13, 0xdc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EC3368: D1BF00EC  stfs f13, 0xec(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EC336C: C18B0BF8  lfs f12, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3374: D19F00E0  stfs f12, 0xe0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EC3378: C16B0EE0  lfs f11, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC337C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3380: D17F00E4  stfs f11, 0xe4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC3384: C14B0A7C  lfs f10, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3388: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC338C: D15F00F0  stfs f10, 0xf0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EC3390: C18BBE10  lfs f12, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3394: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3398: D19F00F4  stfs f12, 0xf4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EC339C: D19F00FC  stfs f12, 0xfc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EC33A0: C00B0B64  lfs f0, 0xb64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC33A4: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EC33A8: 4BDE6609  bl 0x82ca99b0
	ctx.lr = 0x82EC33AC;
	sub_82CA99B0(ctx, base);
	// 82EC33AC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC33B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC33B4: 418200AC  beq 0x82ec3460
	if ctx.cr[0].eq {
	pc = 0x82EC3460; continue 'dispatch;
	}
	// 82EC33B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC33BC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC33C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC33C4: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC33C8: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC33CC: 4B3252AD  bl 0x821e8678
	ctx.lr = 0x82EC33D0;
	sub_821E8678(ctx, base);
	// 82EC33D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC33D4: 41820014  beq 0x82ec33e8
	if ctx.cr[0].eq {
	pc = 0x82EC33E8; continue 'dispatch;
	}
	// 82EC33D8: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC33DC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC33E0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EC33E4: 409A0020  bne cr6, 0x82ec3404
	if !ctx.cr[6].eq {
	pc = 0x82EC3404; continue 'dispatch;
	}
	// 82EC33E8: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC33EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC33F0: 4182000C  beq 0x82ec33fc
	if ctx.cr[0].eq {
	pc = 0x82EC33FC; continue 'dispatch;
	}
	// 82EC33F4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC33F8: 48000008  b 0x82ec3400
	pc = 0x82EC3400; continue 'dispatch;
	// 82EC33FC: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82EC3400: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC3404: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3408: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC340C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC3410: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EC3414: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3418: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC341C: 4B32525D  bl 0x821e8678
	ctx.lr = 0x82EC3420;
	sub_821E8678(ctx, base);
	// 82EC3420: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3424: 4182000C  beq 0x82ec3430
	if ctx.cr[0].eq {
	pc = 0x82EC3430; continue 'dispatch;
	}
	// 82EC3428: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC342C: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC3430: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3434: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3438: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC343C: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EC3440: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3444: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC3448: 4B325231  bl 0x821e8678
	ctx.lr = 0x82EC344C;
	sub_821E8678(ctx, base);
	// 82EC344C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3450: 4182002C  beq 0x82ec347c
	if ctx.cr[0].eq {
	pc = 0x82EC347C; continue 'dispatch;
	}
	// 82EC3454: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3458: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC345C: 48000020  b 0x82ec347c
	pc = 0x82EC347C; continue 'dispatch;
	// 82EC3460: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3464: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3468: 4182000C  beq 0x82ec3474
	if ctx.cr[0].eq {
	pc = 0x82EC3474; continue 'dispatch;
	}
	// 82EC346C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3470: 48000008  b 0x82ec3478
	pc = 0x82EC3478; continue 'dispatch;
	// 82EC3474: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82EC3478: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC347C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3480: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3484: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82EC3488: 4B3A4799  bl 0x82267c20
	ctx.lr = 0x82EC348C;
	sub_82267C20(ctx, base);
	// 82EC348C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC3490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3494: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC3498: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC349C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC34A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC34A4: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC34A8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EC34AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC34B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC34B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC34B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC34B8 size=12
    let mut pc: u32 = 0x82EC34B8;
    'dispatch: loop {
        match pc {
            0x82EC34B8 => {
    //   block [0x82EC34B8..0x82EC34C4)
	// 82EC34B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC34BC: 386BE16C  addi r3, r11, -0x1e94
	ctx.r[3].s64 = ctx.r[11].s64 + -7828;
	// 82EC34C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC34C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC34C8 size=8
    let mut pc: u32 = 0x82EC34C8;
    'dispatch: loop {
        match pc {
            0x82EC34C8 => {
    //   block [0x82EC34C8..0x82EC34D0)
	// 82EC34C8: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82EC34CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC34D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC34D0 size=440
    let mut pc: u32 = 0x82EC34D0;
    'dispatch: loop {
        match pc {
            0x82EC34D0 => {
    //   block [0x82EC34D0..0x82EC3688)
	// 82EC34D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC34D4: 4BDE5F39  bl 0x82ca940c
	ctx.lr = 0x82EC34D8;
	sub_82CA93D0(ctx, base);
	// 82EC34D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC34DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC34E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC34E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC34E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC34EC: 3BABAE40  addi r29, r11, -0x51c0
	ctx.r[29].s64 = ctx.r[11].s64 + -20928;
	// 82EC34F0: 482F8B71  bl 0x831bc060
	ctx.lr = 0x82EC34F4;
	sub_831BC060(ctx, base);
	// 82EC34F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC34F8: 4BDE9659  bl 0x82cacb50
	ctx.lr = 0x82EC34FC;
	sub_82CACB50(ctx, base);
	// 82EC34FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3504: 4082001C  bne 0x82ec3520
	if !ctx.cr[0].eq {
	pc = 0x82EC3520; continue 'dispatch;
	}
	// 82EC3508: 4BA4A801  bl 0x8290dd08
	ctx.lr = 0x82EC350C;
	sub_8290DD08(ctx, base);
	// 82EC350C: 4BDE86A5  bl 0x82cabbb0
	ctx.lr = 0x82EC3510;
	sub_82CABBB0(ctx, base);
	// 82EC3510: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC3514: D01E00E0  stfs f0, 0xe0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EC3518: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC351C: 48000164  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3520: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3524: 3BABAE30  addi r29, r11, -0x51d0
	ctx.r[29].s64 = ctx.r[11].s64 + -20944;
	// 82EC3528: 482F8B39  bl 0x831bc060
	ctx.lr = 0x82EC352C;
	sub_831BC060(ctx, base);
	// 82EC352C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3530: 4BDE9621  bl 0x82cacb50
	ctx.lr = 0x82EC3534;
	sub_82CACB50(ctx, base);
	// 82EC3534: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC353C: 4082001C  bne 0x82ec3558
	if !ctx.cr[0].eq {
	pc = 0x82EC3558; continue 'dispatch;
	}
	// 82EC3540: 4BA4A7C9  bl 0x8290dd08
	ctx.lr = 0x82EC3544;
	sub_8290DD08(ctx, base);
	// 82EC3544: 4BDE866D  bl 0x82cabbb0
	ctx.lr = 0x82EC3548;
	sub_82CABBB0(ctx, base);
	// 82EC3548: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC354C: D01E00DC  stfs f0, 0xdc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EC3550: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3554: 4800012C  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3558: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC355C: 3BABAE20  addi r29, r11, -0x51e0
	ctx.r[29].s64 = ctx.r[11].s64 + -20960;
	// 82EC3560: 482F8B01  bl 0x831bc060
	ctx.lr = 0x82EC3564;
	sub_831BC060(ctx, base);
	// 82EC3564: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3568: 4BDE95E9  bl 0x82cacb50
	ctx.lr = 0x82EC356C;
	sub_82CACB50(ctx, base);
	// 82EC356C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3574: 4082001C  bne 0x82ec3590
	if !ctx.cr[0].eq {
	pc = 0x82EC3590; continue 'dispatch;
	}
	// 82EC3578: 4BA4A791  bl 0x8290dd08
	ctx.lr = 0x82EC357C;
	sub_8290DD08(ctx, base);
	// 82EC357C: 4BDE8635  bl 0x82cabbb0
	ctx.lr = 0x82EC3580;
	sub_82CABBB0(ctx, base);
	// 82EC3580: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC3584: D01E00E4  stfs f0, 0xe4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC3588: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC358C: 480000F4  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3590: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3594: 3BABAE10  addi r29, r11, -0x51f0
	ctx.r[29].s64 = ctx.r[11].s64 + -20976;
	// 82EC3598: 482F8AC9  bl 0x831bc060
	ctx.lr = 0x82EC359C;
	sub_831BC060(ctx, base);
	// 82EC359C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC35A0: 4BDE95B1  bl 0x82cacb50
	ctx.lr = 0x82EC35A4;
	sub_82CACB50(ctx, base);
	// 82EC35A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC35A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC35AC: 4082001C  bne 0x82ec35c8
	if !ctx.cr[0].eq {
	pc = 0x82EC35C8; continue 'dispatch;
	}
	// 82EC35B0: 4BA4A759  bl 0x8290dd08
	ctx.lr = 0x82EC35B4;
	sub_8290DD08(ctx, base);
	// 82EC35B4: 4BDE85FD  bl 0x82cabbb0
	ctx.lr = 0x82EC35B8;
	sub_82CABBB0(ctx, base);
	// 82EC35B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC35BC: D01E00E8  stfs f0, 0xe8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC35C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC35C4: 480000BC  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC35C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC35CC: 3BABAE00  addi r29, r11, -0x5200
	ctx.r[29].s64 = ctx.r[11].s64 + -20992;
	// 82EC35D0: 482F8A91  bl 0x831bc060
	ctx.lr = 0x82EC35D4;
	sub_831BC060(ctx, base);
	// 82EC35D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC35D8: 4BDE9579  bl 0x82cacb50
	ctx.lr = 0x82EC35DC;
	sub_82CACB50(ctx, base);
	// 82EC35DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC35E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC35E4: 4082001C  bne 0x82ec3600
	if !ctx.cr[0].eq {
	pc = 0x82EC3600; continue 'dispatch;
	}
	// 82EC35E8: 4BA4A721  bl 0x8290dd08
	ctx.lr = 0x82EC35EC;
	sub_8290DD08(ctx, base);
	// 82EC35EC: 4BDE85C5  bl 0x82cabbb0
	ctx.lr = 0x82EC35F0;
	sub_82CABBB0(ctx, base);
	// 82EC35F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC35F4: D01E00EC  stfs f0, 0xec(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EC35F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC35FC: 48000084  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3600: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3604: 3BABADEC  addi r29, r11, -0x5214
	ctx.r[29].s64 = ctx.r[11].s64 + -21012;
	// 82EC3608: 482F8A59  bl 0x831bc060
	ctx.lr = 0x82EC360C;
	sub_831BC060(ctx, base);
	// 82EC360C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3610: 4BDE9541  bl 0x82cacb50
	ctx.lr = 0x82EC3614;
	sub_82CACB50(ctx, base);
	// 82EC3614: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC361C: 4082001C  bne 0x82ec3638
	if !ctx.cr[0].eq {
	pc = 0x82EC3638; continue 'dispatch;
	}
	// 82EC3620: 4BA4A6E9  bl 0x8290dd08
	ctx.lr = 0x82EC3624;
	sub_8290DD08(ctx, base);
	// 82EC3624: 4BDE858D  bl 0x82cabbb0
	ctx.lr = 0x82EC3628;
	sub_82CABBB0(ctx, base);
	// 82EC3628: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC362C: D01E00F0  stfs f0, 0xf0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EC3630: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3634: 4800004C  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3638: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC363C: 3BABADD4  addi r29, r11, -0x522c
	ctx.r[29].s64 = ctx.r[11].s64 + -21036;
	// 82EC3640: 482F8A21  bl 0x831bc060
	ctx.lr = 0x82EC3644;
	sub_831BC060(ctx, base);
	// 82EC3644: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3648: 4BDE9509  bl 0x82cacb50
	ctx.lr = 0x82EC364C;
	sub_82CACB50(ctx, base);
	// 82EC364C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3650: 4082002C  bne 0x82ec367c
	if !ctx.cr[0].eq {
	pc = 0x82EC367C; continue 'dispatch;
	}
	// 82EC3654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3658: 4BA4A6B1  bl 0x8290dd08
	ctx.lr = 0x82EC365C;
	sub_8290DD08(ctx, base);
	// 82EC365C: 4BDE8555  bl 0x82cabbb0
	ctx.lr = 0x82EC3660;
	sub_82CABBB0(ctx, base);
	// 82EC3660: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC3664: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3668: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC366C: D01E00F4  stfs f0, 0xf4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EC3670: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3674: D01E00D8  stfs f0, 0xd8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EC3678: 48000008  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC367C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3684: 4BDE5DD8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC3688 size=124
    let mut pc: u32 = 0x82EC3688;
    'dispatch: loop {
        match pc {
            0x82EC3688 => {
    //   block [0x82EC3688..0x82EC3704)
	// 82EC3688: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC368C: C0E60000  lfs f7, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3690: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3694: C1450004  lfs f10, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3698: ECCA02B2  fmuls f6, f10, f10
	ctx.f[6].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC369C: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC36A0: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC36A4: C10B0A98  lfs f8, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC36A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC36AC: ED070232  fmuls f8, f7, f8
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EC36B0: C1250008  lfs f9, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC36B4: ECED0372  fmuls f7, f13, f13
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC36B8: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC36BC: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC36C0: ED40383A  fmadds f10, f0, f0, f7
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EC36C4: ECEB32FA  fmadds f7, f11, f11, f6
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[6].f64) as f32) as f64);
	// 82EC36C8: EC0B683A  fmadds f0, f11, f0, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC36CC: EDAC533A  fmadds f13, f12, f12, f10
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC36D0: ED693A7A  fmadds f11, f9, f9, f7
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EC36D4: EC09033A  fmadds f0, f9, f12, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC36D8: ED485A3C  fnmsubs f10, f8, f8, f11
	ctx.f[10].f64 = -(((ctx.f[8].f64 * ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC36DC: C16B0C4C  lfs f11, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC36E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC36E4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC36E8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC36EC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC36F0: 409A0024  bne cr6, 0x82ec3714
	if !ctx.cr[6].eq {
		sub_82EC3714(ctx, base);
		return;
	}
	// 82EC36F4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC36F8: 409A000C  bne cr6, 0x82ec3704
	if !ctx.cr[6].eq {
		sub_82EC3704(ctx, base);
		return;
	}
	// 82EC36FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3704(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC3704 size=16
    let mut pc: u32 = 0x82EC3704;
    'dispatch: loop {
        match pc {
            0x82EC3704 => {
    //   block [0x82EC3704..0x82EC3714)
	// 82EC3704: EC0A0024  fdivs f0, f10, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3708: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC370C: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC3710: 48000040  b 0x82ec3750
	sub_82EC3714(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3714(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC3714 size=72
    let mut pc: u32 = 0x82EC3714;
    'dispatch: loop {
        match pc {
            0x82EC3714 => {
    //   block [0x82EC3714..0x82EC375C)
	// 82EC3714: ED2A0372  fmuls f9, f10, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3718: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC371C: C14B0A4C  lfs f10, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3720: ED4902B2  fmuls f10, f9, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3724: ED405038  fmsubs f10, f0, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3728: FF0A6000  fcmpu cr6, f10, f12
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[12].f64);
	// 82EC372C: 4198FFD0  blt cr6, 0x82ec36fc
	if ctx.cr[6].lt {
		sub_82EC3688(ctx, base);
		return;
	}
	// 82EC3730: ED80502C  fsqrts f12, f10
	ctx.f[12].f64 = ((ctx.f[10].f64).sqrt() as f32) as f64;
	// 82EC3734: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3738: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC373C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3740: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3744: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EC3748: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC374C: EC0C6824  fdivs f0, f12, f13
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EC3750: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC3754: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC3760 size=100
    let mut pc: u32 = 0x82EC3760;
    'dispatch: loop {
        match pc {
            0x82EC3760 => {
    //   block [0x82EC3760..0x82EC37C4)
	// 82EC3760: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3764: C14300C8  lfs f10, 0xc8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3768: C12300C4  lfs f9, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC376C: C00300F8  lfs f0, 0xf8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3770: C1AB0050  lfs f13, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3774: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3778: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC377C: C14300CC  lfs f10, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3780: C16B004C  lfs f11, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3784: EDAC6ABA  fmadds f13, f12, f10, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC3788: EDAB6A7A  fmadds f13, f11, f9, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC378C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC3790: 40990034  ble cr6, 0x82ec37c4
	if !ctx.cr[6].gt {
		sub_82EC37C4(ctx, base);
		return;
	}
	// 82EC3794: C0030058  lfs f0, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3798: C1A300FC  lfs f13, 0xfc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC379C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC37A0: 40980054  bge cr6, 0x82ec37f4
	if !ctx.cr[6].lt {
		sub_82EC37F4(ctx, base);
		return;
	}
	// 82EC37A4: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EC37A8: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC37AC: C00300C8  lfs f0, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37B0: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC37B4: C00300CC  lfs f0, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37B8: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC37BC: C0030020  lfs f0, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37C0: 48000040  b 0x82ec3800
	sub_82EC37F4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC37C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC37C4 size=48
    let mut pc: u32 = 0x82EC37C4;
    'dispatch: loop {
        match pc {
            0x82EC37C4 => {
    //   block [0x82EC37C4..0x82EC37F4)
	// 82EC37C4: C00300C4  lfs f0, 0xc4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37C8: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC37CC: C00300C8  lfs f0, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37D0: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC37D4: C00300CC  lfs f0, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37D8: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC37DC: C0030058  lfs f0, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37E0: C1A300FC  lfs f13, 0xfc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC37E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC37E8: 4098000C  bge cr6, 0x82ec37f4
	if !ctx.cr[6].lt {
		sub_82EC37F4(ctx, base);
		return;
	}
	// 82EC37EC: C00300F0  lfs f0, 0xf0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37F0: 48000008  b 0x82ec37f8
	sub_82EC37F4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC37F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC37F4 size=20
    let mut pc: u32 = 0x82EC37F4;
    'dispatch: loop {
        match pc {
            0x82EC37F4 => {
    //   block [0x82EC37F4..0x82EC3808)
	// 82EC37F4: C00300EC  lfs f0, 0xec(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37F8: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC37FC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3800: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC3804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3808 size=72
    let mut pc: u32 = 0x82EC3808;
    'dispatch: loop {
        match pc {
            0x82EC3808 => {
    //   block [0x82EC3808..0x82EC3850)
	// 82EC3808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC380C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3814: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC381C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82EC3820: 4B753109  bl 0x82616928
	ctx.lr = 0x82EC3824;
	sub_82616928(ctx, base);
	// 82EC3824: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3828: 41820010  beq 0x82ec3838
	if ctx.cr[0].eq {
	pc = 0x82EC3838; continue 'dispatch;
	}
	// 82EC382C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC3830: 4BFFFA39  bl 0x82ec3268
	ctx.lr = 0x82EC3834;
	sub_82EC3268(ctx, base);
	// 82EC3834: 48000008  b 0x82ec383c
	pc = 0x82EC383C; continue 'dispatch;
	// 82EC3838: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC383C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC3840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC3848: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC384C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3850 size=712
    let mut pc: u32 = 0x82EC3850;
    'dispatch: loop {
        match pc {
            0x82EC3850 => {
    //   block [0x82EC3850..0x82EC3B18)
	// 82EC3850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3854: 4BDE5BB9  bl 0x82ca940c
	ctx.lr = 0x82EC3858;
	sub_82CA93D0(ctx, base);
	// 82EC3858: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EC385C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC3860: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3864: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3868: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC386C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3870: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC3874: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC3878: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC387C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC3880: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3884: 4182000C  beq 0x82ec3890
	if ctx.cr[0].eq {
	pc = 0x82EC3890; continue 'dispatch;
	}
	// 82EC3888: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC388C: 48000008  b 0x82ec3894
	pc = 0x82EC3894; continue 'dispatch;
	// 82EC3890: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82EC3894: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3898: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC389C: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC38A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC38A4: 4B324DD5  bl 0x821e8678
	ctx.lr = 0x82EC38A8;
	sub_821E8678(ctx, base);
	// 82EC38A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC38AC: 41820008  beq 0x82ec38b4
	if ctx.cr[0].eq {
	pc = 0x82EC38B4; continue 'dispatch;
	}
	// 82EC38B0: C3C30004  lfs f30, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC38B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC38B8: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC38BC: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC38C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC38C4: C19E003C  lfs f12, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC38C8: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC38CC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC38D0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC38D4: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC38D8: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC38DC: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC38E0: C14A0C18  lfs f10, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC38E4: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC38E8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC38EC: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC38F0: ED20002C  fsqrts f9, f0
	ctx.f[9].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC38F4: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 82EC38F8: 40990018  ble cr6, 0x82ec3910
	if !ctx.cr[6].gt {
	pc = 0x82EC3910; continue 'dispatch;
	}
	// 82EC38FC: EC1F4824  fdivs f0, f31, f9
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[9].f64) as f32) as f64;
	// 82EC3900: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3904: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3908: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC390C: 48000010  b 0x82ec391c
	pc = 0x82EC391C; continue 'dispatch;
	// 82EC3910: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 82EC3914: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EC3918: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 82EC391C: C18B0050  lfs f12, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3920: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3924: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3928: C10B004C  lfs f8, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC392C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC3930: EC0802FA  fmadds f0, f8, f11, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3934: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EC3938: 41990010  bgt cr6, 0x82ec3948
	if ctx.cr[6].gt {
	pc = 0x82EC3948; continue 'dispatch;
	}
	// 82EC393C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3940: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82EC3944: 409801C4  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3948: C00B0058  lfs f0, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC394C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC3950: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3954: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EC3958: C12B004C  lfs f9, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC395C: C17E004C  lfs f11, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3960: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3964: C10B0050  lfs f8, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC3968: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC396C: C15E0050  lfs f10, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3970: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3974: C0FE0054  lfs f7, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3978: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC397C: C06B0054  lfs f3, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EC3980: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3984: EC030032  fmuls f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3988: C0CB0034  lfs f6, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EC398C: C0FE0034  lfs f7, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3990: ECE73028  fsubs f7, f7, f6
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EC3994: C0BE0038  lfs f5, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EC3998: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EC399C: ECC53028  fsubs f6, f5, f6
	ctx.f[6].f64 = (((ctx.f[5].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EC39A0: C18A0A40  lfs f12, 0xa40(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2624 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC39A4: C05E003C  lfs f2, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EC39A8: FC806090  fmr f4, f12
	ctx.f[4].f64 = ctx.f[12].f64;
	// 82EC39AC: ED6B4828  fsubs f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC39B0: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EC39B4: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC39B8: ECA22828  fsubs f5, f2, f5
	ctx.f[5].f64 = (((ctx.f[2].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EC39BC: ED6A4028  fsubs f11, f10, f8
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EC39C0: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC39C4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC39C8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC39CC: 419A0040  beq cr6, 0x82ec3a0c
	if ctx.cr[6].eq {
	pc = 0x82EC3A0C; continue 'dispatch;
	}
	// 82EC39D0: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC39D4: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC39D8: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC39DC: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC39E0: C10B003C  lfs f8, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC39E4: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC39E8: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC39EC: C12B0034  lfs f9, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC39F0: ED695828  fsubs f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC39F4: C14B0058  lfs f10, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC39F8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC39FC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3A00: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3A04: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3A08: EC805024  fdivs f4, f0, f10
	ctx.f[4].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC3A0C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3A10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3A14: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EC3A18: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EC3A1C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC3A20: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3A24: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EC3A28: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3A2C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EC3A30: D0E10070  stfs f7, 0x70(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC3A34: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3A38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EC3A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3A40: D0C10074  stfs f6, 0x74(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EC3A44: D0A10078  stfs f5, 0x78(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EC3A48: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3A4C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3A50: 4BFFFC39  bl 0x82ec3688
	ctx.lr = 0x82EC3A54;
	sub_82EC3688(ctx, base);
	// 82EC3A54: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3A58: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3A5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3A60: 41980008  blt cr6, 0x82ec3a68
	if ctx.cr[6].lt {
	pc = 0x82EC3A68; continue 'dispatch;
	}
	// 82EC3A64: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC3A68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC3A6C: 4182009C  beq 0x82ec3b08
	if ctx.cr[0].eq {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A70: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3A74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3A78: 40980090  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A7C: FF002000  fcmpu cr6, f0, f4
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 82EC3A80: 40980088  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A84: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3A88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3A8C: 4099007C  ble cr6, 0x82ec3b08
	if !ctx.cr[6].gt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A90: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EC3A94: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 82EC3A98: 4098001C  bge cr6, 0x82ec3ab4
	if !ctx.cr[6].lt {
	pc = 0x82EC3AB4; continue 'dispatch;
	}
	// 82EC3A9C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EC3AA0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC3AA4: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	// 82EC3AA8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EC3AAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC3AB0: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC3AB4: C1BF0058  lfs f13, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3AB8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3ABC: 4098004C  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3AC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC3AC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3AC8: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3ACC: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82EC3AD0: 995F0044  stb r10, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82EC3AD4: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3AD8: C16B0050  lfs f11, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3ADC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3AE0: C14B0054  lfs f10, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3AE4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3AE8: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3AEC: C1AB0058  lfs f13, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3AF0: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3AF4: D19F004C  stfs f12, 0x4c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC3AF8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3AFC: D17F0050  stfs f11, 0x50(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3B00: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3B04: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3B08: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC3B0C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EC3B10: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC3B14: 4BDE5948  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3B18 size=848
    let mut pc: u32 = 0x82EC3B18;
    'dispatch: loop {
        match pc {
            0x82EC3B18 => {
    //   block [0x82EC3B18..0x82EC3E68)
	// 82EC3B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3B20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3B24: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EC3B28: 4BDEA19D  bl 0x82cadcc4
	ctx.lr = 0x82EC3B2C;
	sub_82CADCA0(ctx, base);
	// 82EC3B2C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3B30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3B34: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3B38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3B3C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC3B40: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3B44: 4082000C  bne 0x82ec3b50
	if !ctx.cr[0].eq {
	pc = 0x82EC3B50; continue 'dispatch;
	}
	// 82EC3B48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3B4C: 48000300  b 0x82ec3e4c
	pc = 0x82EC3E4C; continue 'dispatch;
	// 82EC3B50: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC3B54: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EC3B58: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3B5C: C3690C18  lfs f27, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EC3B60: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC3B64: FDA0D890  fmr f13, f27
	ctx.f[13].f64 = ctx.f[27].f64;
	// 82EC3B68: FD80D890  fmr f12, f27
	ctx.f[12].f64 = ctx.f[27].f64;
	// 82EC3B6C: FD60D890  fmr f11, f27
	ctx.f[11].f64 = ctx.f[27].f64;
	// 82EC3B70: C3490C14  lfs f26, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EC3B74: 4081006C  ble 0x82ec3be0
	if !ctx.cr[0].gt {
	pc = 0x82EC3BE0; continue 'dispatch;
	}
	// 82EC3B78: C0EB0034  lfs f7, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3B7C: 393F0060  addi r9, r31, 0x60
	ctx.r[9].s64 = ctx.r[31].s64 + 96;
	// 82EC3B80: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EC3B84: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EC3B88: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC3B8C: C128003C  lfs f9, 0x3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC3B90: ED254828  fsubs f9, f5, f9
	ctx.f[9].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC3B94: C0080034  lfs f0, 0x34(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3B98: ED470028  fsubs f10, f7, f0
	ctx.f[10].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3B9C: C0080038  lfs f0, 0x38(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3BA0: ED060028  fsubs f8, f6, f0
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3BA4: EC090272  fmuls f0, f9, f9
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EC3BA8: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BAC: EC08023A  fmadds f0, f8, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BB0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3BB4: 40990020  ble cr6, 0x82ec3bd4
	if !ctx.cr[6].gt {
	pc = 0x82EC3BD4; continue 'dispatch;
	}
	// 82EC3BB8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3BBC: ED4002B2  fmuls f10, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3BC0: ED000232  fmuls f8, f0, f8
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EC3BC4: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EC3BC8: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC3BCC: ED88602A  fadds f12, f8, f12
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC3BD0: ED60582A  fadds f11, f0, f11
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EC3BD4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC3BD8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC3BDC: 4082FFAC  bne 0x82ec3b88
	if !ctx.cr[0].eq {
	pc = 0x82EC3B88; continue 'dispatch;
	}
	// 82EC3BE0: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3BE4: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BE8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BEC: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3BF0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3BF4: 40990018  ble cr6, 0x82ec3c0c
	if !ctx.cr[6].gt {
	pc = 0x82EC3C0C; continue 'dispatch;
	}
	// 82EC3BF8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3BFC: EF200372  fmuls f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3C00: EEE00332  fmuls f23, f0, f12
	ctx.f[23].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3C04: EF0002F2  fmuls f24, f0, f11
	ctx.f[24].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3C08: 48000010  b 0x82ec3c18
	pc = 0x82EC3C18; continue 'dispatch;
	// 82EC3C0C: FF20D890  fmr f25, f27
	ctx.f[25].f64 = ctx.f[27].f64;
	// 82EC3C10: FEE0D890  fmr f23, f27
	ctx.f[23].f64 = ctx.f[27].f64;
	// 82EC3C14: FF00D890  fmr f24, f27
	ctx.f[24].f64 = ctx.f[27].f64;
	// 82EC3C18: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3C1C: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3C20: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3C24: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3C28: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3C2C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC3C30: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3C34: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3C38: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3C3C: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3C40: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3C44: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3C48: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3C4C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3C50: 40990018  ble cr6, 0x82ec3c68
	if !ctx.cr[6].gt {
	pc = 0x82EC3C68; continue 'dispatch;
	}
	// 82EC3C54: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3C58: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3C5C: EFA002F2  fmuls f29, f0, f11
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3C60: EFC00332  fmuls f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3C64: 48000010  b 0x82ec3c74
	pc = 0x82EC3C74; continue 'dispatch;
	// 82EC3C68: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 82EC3C6C: FFA0D890  fmr f29, f27
	ctx.f[29].f64 = ctx.f[27].f64;
	// 82EC3C70: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82EC3C74: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3C78: C39F00DC  lfs f28, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EC3C7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC3C80: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3C84: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EC3C88: 4B3249F1  bl 0x821e8678
	ctx.lr = 0x82EC3C8C;
	sub_821E8678(ctx, base);
	// 82EC3C8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3C90: 4182010C  beq 0x82ec3d9c
	if ctx.cr[0].eq {
	pc = 0x82EC3D9C; continue 'dispatch;
	}
	// 82EC3C94: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3C98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3C9C: 41820100  beq 0x82ec3d9c
	if ctx.cr[0].eq {
	pc = 0x82EC3D9C; continue 'dispatch;
	}
	// 82EC3CA0: ED9D0672  fmuls f12, f29, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EC3CA4: EC1E05F2  fmuls f0, f30, f23
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[23].f64) as f32) as f64);
	// 82EC3CA8: ED5807F2  fmuls f10, f24, f31
	ctx.f[10].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC3CAC: ED7767F8  fmsubs f11, f23, f31, f12
	ctx.f[11].f64 = (((ctx.f[23].f64 * ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3CB0: EDBD0638  fmsubs f13, f29, f24, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3CB4: ED9E5678  fmsubs f12, f30, f25, f10
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3CB8: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3CBC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3CC0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3CC4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3CC8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3CCC: 409A0074  bne cr6, 0x82ec3d40
	if !ctx.cr[6].eq {
	pc = 0x82EC3D40; continue 'dispatch;
	}
	// 82EC3CD0: FF1FD800  fcmpu cr6, f31, f27
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[27].f64);
	// 82EC3CD4: 409A0018  bne cr6, 0x82ec3cec
	if !ctx.cr[6].eq {
	pc = 0x82EC3CEC; continue 'dispatch;
	}
	// 82EC3CD8: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EC3CDC: 409A0010  bne cr6, 0x82ec3cec
	if !ctx.cr[6].eq {
	pc = 0x82EC3CEC; continue 'dispatch;
	}
	// 82EC3CE0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC3CE4: 396BDBE4  addi r11, r11, -0x241c
	ctx.r[11].s64 = ctx.r[11].s64 + -9244;
	// 82EC3CE8: 4800000C  b 0x82ec3cf4
	pc = 0x82EC3CF4; continue 'dispatch;
	// 82EC3CEC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC3CF0: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EC3CF4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3CF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC3CFC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3D00: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D04: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3D08: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3D0C: ED3D0332  fmuls f9, f29, f12
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3D10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC3D14: EC1D5838  fmsubs f0, f29, f0, f11
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC3D18: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3D1C: EC1E5338  fmsubs f0, f30, f12, f10
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3D20: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3D24: EC1F4B78  fmsubs f0, f31, f13, f9
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC3D28: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3D2C: 4B3BB53D  bl 0x8227f268
	ctx.lr = 0x82EC3D30;
	sub_8227F268(ctx, base);
	// 82EC3D30: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3D34: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3D38: C1630008  lfs f11, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3D3C: 48000030  b 0x82ec3d6c
	pc = 0x82EC3D6C; continue 'dispatch;
	// 82EC3D40: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3D44: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D48: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3D4C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3D50: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D54: ED2C07F2  fmuls f9, f12, f31
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC3D58: ED400772  fmuls f10, f0, f29
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EC3D5C: ED4C57B8  fmsubs f10, f12, f30, f10
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3D60: ED805FF8  fmsubs f12, f0, f31, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC3D64: ED7D4B78  fmsubs f11, f29, f13, f9
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC3D68: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EC3D6C: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EC3D70: ED5F0732  fmuls f10, f31, f28
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3D74: ED3D0732  fmuls f9, f29, f28
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3D78: ED1E0732  fmuls f8, f30, f28
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3D7C: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D80: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3D84: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3D88: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC3D8C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3D90: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC3D94: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC3D98: 48000084  b 0x82ec3e1c
	pc = 0x82EC3E1C; continue 'dispatch;
	// 82EC3D9C: EC1807F2  fmuls f0, f24, f31
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC3DA0: FDA0D090  fmr f13, f26
	ctx.f[13].f64 = ctx.f[26].f64;
	// 82EC3DA4: EC1E0678  fmsubs f0, f30, f25, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3DA8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3DAC: 4098000C  bge cr6, 0x82ec3db8
	if !ctx.cr[6].lt {
	pc = 0x82EC3DB8; continue 'dispatch;
	}
	// 82EC3DB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3DB4: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3DB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC3DBC: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EC3DC0: ED3F0732  fmuls f9, f31, f28
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3DC4: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EC3DC8: ECFE0732  fmuls f7, f30, f28
	ctx.f[7].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3DCC: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3DD0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3DD4: ED1D02F2  fmuls f8, f29, f11
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3DD8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3DDC: ECDE02B2  fmuls f6, f30, f10
	ctx.f[6].f64 = (((ctx.f[30].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3DE0: ECBF0332  fmuls f5, f31, f12
	ctx.f[5].f64 = (((ctx.f[31].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3DE4: ED9E4338  fmsubs f12, f30, f12, f8
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EC3DE8: ED7F32F8  fmsubs f11, f31, f11, f6
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EC3DEC: ED5D2AB8  fmsubs f10, f29, f10, f5
	ctx.f[10].f64 = (((ctx.f[29].f64 * ctx.f[10].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EC3DF0: ED1D0732  fmuls f8, f29, f28
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3DF4: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3DF8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3DFC: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3E00: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3E04: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3E08: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3E0C: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC3E10: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3E14: EDA8582A  fadds f13, f8, f11
	ctx.f[13].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EC3E18: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC3E1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC3E20: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3E24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC3E28: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3E2C: 4B3BB43D  bl 0x8227f268
	ctx.lr = 0x82EC3E30;
	sub_8227F268(ctx, base);
	// 82EC3E30: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E34: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC3E38: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E3C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC3E40: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3E48: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC3E4C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC3E50: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EC3E54: 4BDE9EBD  bl 0x82cadd10
	ctx.lr = 0x82EC3E58;
	sub_82CADCEC(ctx, base);
	// 82EC3E58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3E5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC3E60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3E68 size=344
    let mut pc: u32 = 0x82EC3E68;
    'dispatch: loop {
        match pc {
            0x82EC3E68 => {
    //   block [0x82EC3E68..0x82EC3FC0)
	// 82EC3E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3E6C: 4BDE559D  bl 0x82ca9408
	ctx.lr = 0x82EC3E70;
	sub_82CA93D0(ctx, base);
	// 82EC3E70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3E74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3E78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC3E7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC3E80: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EC3E84: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC3E88: C00A0A48  lfs f0, 0xa48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2632 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E8C: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3E90: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82EC3E94: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EC3E98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3E9C: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC3EA0: 4182006C  beq 0x82ec3f0c
	if ctx.cr[0].eq {
	pc = 0x82EC3F0C; continue 'dispatch;
	}
	// 82EC3EA4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3EA8: C03F00D8  lfs f1, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC3EAC: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EC3EB0: 4BFC3DF9  bl 0x82e87ca8
	ctx.lr = 0x82EC3EB4;
	sub_82E87CA8(ctx, base);
	// 82EC3EB4: 4800004C  b 0x82ec3f00
	pc = 0x82EC3F00; continue 'dispatch;
	// 82EC3EB8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3EBC: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC3EC0: 419A0038  beq cr6, 0x82ec3ef8
	if ctx.cr[6].eq {
	pc = 0x82EC3EF8; continue 'dispatch;
	}
	// 82EC3EC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3EC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3ECC: 4182001C  beq 0x82ec3ee8
	if ctx.cr[0].eq {
	pc = 0x82EC3EE8; continue 'dispatch;
	}
	// 82EC3ED0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3ED4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC3ED8: 4E800421  bctrl
	ctx.lr = 0x82EC3EDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC3EDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC3EE0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC3EE4: 409A0014  bne cr6, 0x82ec3ef8
	if !ctx.cr[6].eq {
	pc = 0x82EC3EF8; continue 'dispatch;
	}
	// 82EC3EE8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC3EEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3EF4: 4BFFF95D  bl 0x82ec3850
	ctx.lr = 0x82EC3EF8;
	sub_82EC3850(ctx, base);
	// 82EC3EF8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC3EFC: 4BFC3875  bl 0x82e87770
	ctx.lr = 0x82EC3F00;
	sub_82E87770(ctx, base);
	// 82EC3F00: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC3F04: 4082FFB4  bne 0x82ec3eb8
	if !ctx.cr[0].eq {
	pc = 0x82EC3EB8; continue 'dispatch;
	}
	// 82EC3F08: 480000AC  b 0x82ec3fb4
	pc = 0x82EC3FB4; continue 'dispatch;
	// 82EC3F0C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3F10: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3F14: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC3F18: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3F1C: 48000090  b 0x82ec3fac
	pc = 0x82EC3FAC; continue 'dispatch;
	// 82EC3F20: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3F24: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3F28: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC3F2C: 419A007C  beq cr6, 0x82ec3fa8
	if ctx.cr[6].eq {
	pc = 0x82EC3FA8; continue 'dispatch;
	}
	// 82EC3F30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3F34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3F38: 4182001C  beq 0x82ec3f54
	if ctx.cr[0].eq {
	pc = 0x82EC3F54; continue 'dispatch;
	}
	// 82EC3F3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC3F44: 4E800421  bctrl
	ctx.lr = 0x82EC3F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC3F48: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC3F4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC3F50: 409A0058  bne cr6, 0x82ec3fa8
	if !ctx.cr[6].eq {
	pc = 0x82EC3FA8; continue 'dispatch;
	}
	// 82EC3F54: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3F58: C01F00D8  lfs f0, 0xd8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3F5C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3F60: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3F64: C19E0038  lfs f12, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3F68: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3F6C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC3F70: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3F74: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3F78: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3F7C: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3F80: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3F84: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3F88: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3F8C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3F90: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC3F94: 40980014  bge cr6, 0x82ec3fa8
	if !ctx.cr[6].lt {
	pc = 0x82EC3FA8; continue 'dispatch;
	}
	// 82EC3F98: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC3F9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3FA4: 4BFFF8AD  bl 0x82ec3850
	ctx.lr = 0x82EC3FA8;
	sub_82EC3850(ctx, base);
	// 82EC3FA8: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3FAC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3FB0: 4082FF70  bne 0x82ec3f20
	if !ctx.cr[0].eq {
	pc = 0x82EC3F20; continue 'dispatch;
	}
	// 82EC3FB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC3FBC: 4BDE549C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3FC0 size=184
    let mut pc: u32 = 0x82EC3FC0;
    'dispatch: loop {
        match pc {
            0x82EC3FC0 => {
    //   block [0x82EC3FC0..0x82EC4078)
	// 82EC3FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3FC4: 4BDE5449  bl 0x82ca940c
	ctx.lr = 0x82EC3FC8;
	sub_82CA93D0(ctx, base);
	// 82EC3FC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3FD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC3FD4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC3FD8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3FDC: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3FE0: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC3FE4: 4BFFFE85  bl 0x82ec3e68
	ctx.lr = 0x82EC3FE8;
	sub_82EC3E68(ctx, base);
	// 82EC3FE8: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC3FEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3FF0: 4182003C  beq 0x82ec402c
	if ctx.cr[0].eq {
	pc = 0x82EC402C; continue 'dispatch;
	}
	// 82EC3FF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3FFC: 4BFFFB1D  bl 0x82ec3b18
	ctx.lr = 0x82EC4000;
	sub_82EC3B18(ctx, base);
	// 82EC4000: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC4004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4008: 4BFFF759  bl 0x82ec3760
	ctx.lr = 0x82EC400C;
	sub_82EC3760(ctx, base);
	// 82EC400C: 4B39C9AD  bl 0x822609b8
	ctx.lr = 0x82EC4010;
	sub_822609B8(ctx, base);
	// 82EC4010: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4014: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4018: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC401C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC4020: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EC4024: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 82EC4028: 48000048  b 0x82ec4070
	pc = 0x82EC4070; continue 'dispatch;
	// 82EC402C: 897F00D0  lbz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EC4030: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC4034: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC4038: 409A002C  bne cr6, 0x82ec4064
	if !ctx.cr[6].eq {
	pc = 0x82EC4064; continue 'dispatch;
	}
	// 82EC403C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4040: 4BFFF721  bl 0x82ec3760
	ctx.lr = 0x82EC4044;
	sub_82EC3760(ctx, base);
	// 82EC4044: 4B39C975  bl 0x822609b8
	ctx.lr = 0x82EC4048;
	sub_822609B8(ctx, base);
	// 82EC4048: C01F00D4  lfs f0, 0xd4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC404C: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4050: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4054: 4098001C  bge cr6, 0x82ec4070
	if !ctx.cr[6].lt {
	pc = 0x82EC4070; continue 'dispatch;
	}
	// 82EC4058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC405C: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 82EC4060: 48000010  b 0x82ec4070
	pc = 0x82EC4070; continue 'dispatch;
	// 82EC4064: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC4068: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC406C: 4BFF0B35  bl 0x82eb4ba0
	ctx.lr = 0x82EC4070;
	sub_82EB4BA0(ctx, base);
	// 82EC4070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC4074: 4BDE53E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC4078 size=156
    let mut pc: u32 = 0x82EC4078;
    'dispatch: loop {
        match pc {
            0x82EC4078 => {
    //   block [0x82EC4078..0x82EC4114)
	// 82EC4078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC407C: 4BDE5389  bl 0x82ca9404
	ctx.lr = 0x82EC4080;
	sub_82CA93D0(ctx, base);
	// 82EC4080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4084: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC4088: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EC408C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EC4090: 419A0070  beq cr6, 0x82ec4100
	if ctx.cr[6].eq {
	pc = 0x82EC4100; continue 'dispatch;
	}
	// 82EC4094: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC4098: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC409C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC40A0: 40990060  ble cr6, 0x82ec4100
	if !ctx.cr[6].gt {
	pc = 0x82EC4100; continue 'dispatch;
	}
	// 82EC40A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC40A8: 3B8B8FD8  addi r28, r11, -0x7028
	ctx.r[28].s64 = ctx.r[11].s64 + -28712;
	// 82EC40AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC40B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC40B4: 4BFBFF75  bl 0x82e84028
	ctx.lr = 0x82EC40B8;
	sub_82E84028(ctx, base);
	// 82EC40B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC40BC: 482F7FA5  bl 0x831bc060
	ctx.lr = 0x82EC40C0;
	sub_831BC060(ctx, base);
	// 82EC40C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC40C4: 4BDE8A8D  bl 0x82cacb50
	ctx.lr = 0x82EC40C8;
	sub_82CACB50(ctx, base);
	// 82EC40C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC40CC: 41820024  beq 0x82ec40f0
	if ctx.cr[0].eq {
	pc = 0x82EC40F0; continue 'dispatch;
	}
	// 82EC40D0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC40D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC40D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EC40DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC40E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC40E4: 4E800421  bctrl
	ctx.lr = 0x82EC40E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC40E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC40EC: 41820020  beq 0x82ec410c
	if ctx.cr[0].eq {
	pc = 0x82EC410C; continue 'dispatch;
	}
	// 82EC40F0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC40F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EC40F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC40FC: 4198FFB0  blt cr6, 0x82ec40ac
	if ctx.cr[6].lt {
	pc = 0x82EC40AC; continue 'dispatch;
	}
	// 82EC4100: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4104: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC4108: 4BDE534C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82EC410C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4110: 4BFFFFF4  b 0x82ec4104
	pc = 0x82EC4104; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4118 size=544
    let mut pc: u32 = 0x82EC4118;
    'dispatch: loop {
        match pc {
            0x82EC4118 => {
    //   block [0x82EC4118..0x82EC4338)
	// 82EC4118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC411C: 4BDE52ED  bl 0x82ca9408
	ctx.lr = 0x82EC4120;
	sub_82CA93D0(ctx, base);
	// 82EC4120: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4128: 897F0394  lbz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EC412C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4130: 41820028  beq 0x82ec4158
	if ctx.cr[0].eq {
	pc = 0x82EC4158; continue 'dispatch;
	}
	// 82EC4134: 897F019D  lbz r11, 0x19d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(413 as u32) ) } as u64;
	// 82EC4138: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC413C: 41820010  beq 0x82ec414c
	if ctx.cr[0].eq {
	pc = 0x82EC414C; continue 'dispatch;
	}
	// 82EC4140: 897F019C  lbz r11, 0x19c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EC4144: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4148: 40820010  bne 0x82ec4158
	if !ctx.cr[0].eq {
	pc = 0x82EC4158; continue 'dispatch;
	}
	// 82EC414C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4150: 917F0398  stw r11, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 82EC4154: 480001DC  b 0x82ec4330
	pc = 0x82EC4330; continue 'dispatch;
	// 82EC4158: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC415C: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4160: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4164: 9B9F0394  stb r28, 0x394(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[28].u8 ) };
	// 82EC4168: 9B9F019D  stb r28, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[28].u8 ) };
	// 82EC416C: 4182000C  beq 0x82ec4178
	if ctx.cr[0].eq {
	pc = 0x82EC4178; continue 'dispatch;
	}
	// 82EC4170: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC4174: 48000008  b 0x82ec417c
	pc = 0x82EC417C; continue 'dispatch;
	// 82EC4178: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC417C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC4180: 419A002C  beq cr6, 0x82ec41ac
	if ctx.cr[6].eq {
	pc = 0x82EC41AC; continue 'dispatch;
	}
	// 82EC4184: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4188: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC418C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4190: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4194: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC4198: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC419C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC41A0: 4E800421  bctrl
	ctx.lr = 0x82EC41A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC41A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC41A8: 41820188  beq 0x82ec4330
	if ctx.cr[0].eq {
	pc = 0x82EC4330; continue 'dispatch;
	}
	// 82EC41AC: 897F0397  lbz r11, 0x397(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(919 as u32) ) } as u64;
	// 82EC41B0: 3BBF0334  addi r29, r31, 0x334
	ctx.r[29].s64 = ctx.r[31].s64 + 820;
	// 82EC41B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC41B8: 4182000C  beq 0x82ec41c4
	if ctx.cr[0].eq {
	pc = 0x82EC41C4; continue 'dispatch;
	}
	// 82EC41BC: 389F02D8  addi r4, r31, 0x2d8
	ctx.r[4].s64 = ctx.r[31].s64 + 728;
	// 82EC41C0: 4800003C  b 0x82ec41fc
	pc = 0x82EC41FC; continue 'dispatch;
	// 82EC41C4: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC41C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC41CC: 4082FFF0  bne 0x82ec41bc
	if !ctx.cr[0].eq {
	pc = 0x82EC41BC; continue 'dispatch;
	}
	// 82EC41D0: 807F01D8  lwz r3, 0x1d8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EC41D4: 3BDF02D8  addi r30, r31, 0x2d8
	ctx.r[30].s64 = ctx.r[31].s64 + 728;
	// 82EC41D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC41DC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC41E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC41E4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC41E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC41EC: 4E800421  bctrl
	ctx.lr = 0x82EC41F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC41F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC41F4: 41820010  beq 0x82ec4204
	if ctx.cr[0].eq {
	pc = 0x82EC4204; continue 'dispatch;
	}
	// 82EC41F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC41FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC4200: 4BFABCF9  bl 0x82e6fef8
	ctx.lr = 0x82EC4204;
	sub_82E6FEF8(ctx, base);
	// 82EC4204: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4208: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82EC420C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4210: 41820048  beq 0x82ec4258
	if ctx.cr[0].eq {
	pc = 0x82EC4258; continue 'dispatch;
	}
	// 82EC4214: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4218: 816A01BC  lwz r11, 0x1bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC421C: 814A01B8  lwz r10, 0x1b8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC4220: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC4224: 419A0010  beq cr6, 0x82ec4234
	if ctx.cr[6].eq {
	pc = 0x82EC4234; continue 'dispatch;
	}
	// 82EC4228: 815F039C  lwz r10, 0x39c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC422C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC4230: 409A0008  bne cr6, 0x82ec4238
	if !ctx.cr[6].eq {
	pc = 0x82EC4238; continue 'dispatch;
	}
	// 82EC4234: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4238: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC423C: D01F0428  stfs f0, 0x428(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), tmp.u32 ) };
	// 82EC4240: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4244: D01F042C  stfs f0, 0x42c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), tmp.u32 ) };
	// 82EC4248: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC424C: D01F0430  stfs f0, 0x430(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 82EC4250: 9BDF0434  stb r30, 0x434(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1076 as u32), ctx.r[30].u8 ) };
	// 82EC4254: 48000008  b 0x82ec425c
	pc = 0x82EC425C; continue 'dispatch;
	// 82EC4258: 9B9F0434  stb r28, 0x434(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1076 as u32), ctx.r[28].u8 ) };
	// 82EC425C: 897F0397  lbz r11, 0x397(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(919 as u32) ) } as u64;
	// 82EC4260: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4264: 40820014  bne 0x82ec4278
	if !ctx.cr[0].eq {
	pc = 0x82EC4278; continue 'dispatch;
	}
	// 82EC4268: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC426C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4270: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC4274: 41820008  beq 0x82ec427c
	if ctx.cr[0].eq {
	pc = 0x82EC427C; continue 'dispatch;
	}
	// 82EC4278: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EC427C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4280: 5566063E  clrlwi r6, r11, 0x18
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC4284: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC4288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC428C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4290: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EC4294: 4BFF585D  bl 0x82eb9af0
	ctx.lr = 0x82EC4298;
	sub_82EB9AF0(ctx, base);
	// 82EC4298: 9B9F0397  stb r28, 0x397(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(919 as u32), ctx.r[28].u8 ) };
	// 82EC429C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC42A0: 40820010  bne 0x82ec42b0
	if !ctx.cr[0].eq {
	pc = 0x82EC42B0; continue 'dispatch;
	}
	// 82EC42A4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EC42A8: 917F0398  stw r11, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 82EC42AC: 48000064  b 0x82ec4310
	pc = 0x82EC4310; continue 'dispatch;
	// 82EC42B0: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC42B4: 816A01B8  lwz r11, 0x1b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC42B8: 814A01BC  lwz r10, 0x1bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC42BC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EC42C0: 419A004C  beq cr6, 0x82ec430c
	if ctx.cr[6].eq {
	pc = 0x82EC430C; continue 'dispatch;
	}
	// 82EC42C4: C01F0338  lfs f0, 0x338(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC42C8: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC42CC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC42D0: 409A0028  bne cr6, 0x82ec42f8
	if !ctx.cr[6].eq {
	pc = 0x82EC42F8; continue 'dispatch;
	}
	// 82EC42D4: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC42D8: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC42DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC42E0: 409A0018  bne cr6, 0x82ec42f8
	if !ctx.cr[6].eq {
	pc = 0x82EC42F8; continue 'dispatch;
	}
	// 82EC42E4: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC42E8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EC42EC: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC42F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC42F4: 419A0008  beq cr6, 0x82ec42fc
	if ctx.cr[6].eq {
	pc = 0x82EC42FC; continue 'dispatch;
	}
	// 82EC42F8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC42FC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4300: 4182000C  beq 0x82ec430c
	if ctx.cr[0].eq {
	pc = 0x82EC430C; continue 'dispatch;
	}
	// 82EC4304: 93DF0398  stw r30, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[30].u32 ) };
	// 82EC4308: 48000008  b 0x82ec4310
	pc = 0x82EC4310; continue 'dispatch;
	// 82EC430C: 939F0398  stw r28, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[28].u32 ) };
	// 82EC4310: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EC4314: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EC4318: 409A0018  bne cr6, 0x82ec4330
	if !ctx.cr[6].eq {
	pc = 0x82EC4330; continue 'dispatch;
	}
	// 82EC431C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC4320: 939F039C  stw r28, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[28].u32 ) };
	// 82EC4324: 9B9F0400  stb r28, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[28].u8 ) };
	// 82EC4328: 939F0390  stw r28, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[28].u32 ) };
	// 82EC432C: 917F03A0  stw r11, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[11].u32 ) };
	// 82EC4330: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC4334: 4BDE5124  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC4338 size=32
    let mut pc: u32 = 0x82EC4338;
    'dispatch: loop {
        match pc {
            0x82EC4338 => {
    //   block [0x82EC4338..0x82EC4358)
	// 82EC4338: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC433C: 806B0228  lwz r3, 0x228(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EC4340: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4344: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4348: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC434C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4350: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4354: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC4358 size=40
    let mut pc: u32 = 0x82EC4358;
    'dispatch: loop {
        match pc {
            0x82EC4358 => {
    //   block [0x82EC4358..0x82EC4380)
	// 82EC4358: 81430054  lwz r10, 0x54(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC435C: 816A01BC  lwz r11, 0x1bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC4360: 80EA01B8  lwz r7, 0x1b8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC4364: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EC4368: 409A0018  bne cr6, 0x82ec4380
	if !ctx.cr[6].eq {
		sub_82EC4380(ctx, base);
		return;
	}
	// 82EC436C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC4370: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC4374: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC4378: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EC437C: 48000078  b 0x82ec43f4
	sub_82EC4380(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC4380 size=124
    let mut pc: u32 = 0x82EC4380;
    'dispatch: loop {
        match pc {
            0x82EC4380 => {
    //   block [0x82EC4380..0x82EC43FC)
	// 82EC4380: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82EC4384: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EC4388: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EC438C: 91060000  stw r8, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4390: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4394: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4398: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC439C: 409A0028  bne cr6, 0x82ec43c4
	if !ctx.cr[6].eq {
	pc = 0x82EC43C4; continue 'dispatch;
	}
	// 82EC43A0: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC43A4: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC43A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC43AC: 409A0018  bne cr6, 0x82ec43c4
	if !ctx.cr[6].eq {
	pc = 0x82EC43C4; continue 'dispatch;
	}
	// 82EC43B0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC43B4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EC43B8: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC43BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC43C0: 419A0008  beq cr6, 0x82ec43c8
	if ctx.cr[6].eq {
	pc = 0x82EC43C8; continue 'dispatch;
	}
	// 82EC43C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC43C8: 5529063F  clrlwi. r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC43CC: 40820030  bne 0x82ec43fc
	if !ctx.cr[0].eq {
		sub_82EC43FC(ctx, base);
		return;
	}
	// 82EC43D0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC43D4: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EC43D8: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EC43DC: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EC43E0: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC43E4: 409AFFAC  bne cr6, 0x82ec4390
	if !ctx.cr[6].eq {
	pc = 0x82EC4390; continue 'dispatch;
	}
	// 82EC43E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC43EC: 91060000  stw r8, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC43F0: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC43F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC43F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC43FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC43FC size=12
    let mut pc: u32 = 0x82EC43FC;
    'dispatch: loop {
        match pc {
            0x82EC43FC => {
    //   block [0x82EC43FC..0x82EC4408)
	// 82EC43FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4400: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EC4404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC4408 size=24
    let mut pc: u32 = 0x82EC4408;
    'dispatch: loop {
        match pc {
            0x82EC4408 => {
    //   block [0x82EC4408..0x82EC4420)
	// 82EC4408: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EC440C: 806A0054  lwz r3, 0x54(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4410: 816A039C  lwz r11, 0x39c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4414: 812301BC  lwz r9, 0x1bc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC4418: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC441C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC4420 size=56
    let mut pc: u32 = 0x82EC4420;
    'dispatch: loop {
        match pc {
            0x82EC4420 => {
    //   block [0x82EC4420..0x82EC4458)
	// 82EC4420: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4424: 39490014  addi r10, r9, 0x14
	ctx.r[10].s64 = ctx.r[9].s64 + 20;
	// 82EC4428: C18B000C  lfs f12, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC442C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC4430: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC4434: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4438: 81280014  lwz r9, 0x14(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC443C: C009003C  lfs f0, 0x3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4440: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC4444: C1A90034  lfs f13, 0x34(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4448: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC444C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC4450: ED4D037A  fmadds f10, f13, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC4454: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC4458 size=56
    let mut pc: u32 = 0x82EC4458;
    'dispatch: loop {
        match pc {
            0x82EC4458 => {
    //   block [0x82EC4458..0x82EC4490)
	// 82EC4458: C00A000C  lfs f0, 0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC445C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC4460: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4464: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC4468: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC446C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC4470: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EC4474: 41980014  blt cr6, 0x82ec4488
	if ctx.cr[6].lt {
	pc = 0x82EC4488; continue 'dispatch;
	}
	// 82EC4478: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EC447C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82EC4480: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4484: 409AFFD4  bne cr6, 0x82ec4458
	if !ctx.cr[6].eq {
	pc = 0x82EC4458; continue 'dispatch;
	}
	// 82EC4488: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EC448C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC4490 size=8
    let mut pc: u32 = 0x82EC4490;
    'dispatch: loop {
        match pc {
            0x82EC4490 => {
    //   block [0x82EC4490..0x82EC4498)
	// 82EC4490: 4BFF17F0  b 0x82eb5c80
	sub_82EB5C80(ctx, base);
	return;
	// 82EC4494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4498 size=172
    let mut pc: u32 = 0x82EC4498;
    'dispatch: loop {
        match pc {
            0x82EC4498 => {
    //   block [0x82EC4498..0x82EC4544)
	// 82EC4498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC449C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC44A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC44A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC44A8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC44AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC44B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC44B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC44B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC44BC: 814BE280  lwz r10, -0x1d80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7552 as u32) ) } as u64;
	// 82EC44C0: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC44C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC44C8: 914BE280  stw r10, -0x1d80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-7552 as u32), ctx.r[10].u32 ) };
	// 82EC44CC: 4BFC780D  bl 0x82e8bcd8
	ctx.lr = 0x82EC44D0;
	sub_82E8BCD8(ctx, base);
	// 82EC44D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC44D4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC44D8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC44DC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82EC44E0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC44E4: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC44E8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC44EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC44F0: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC44F4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC44F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC44FC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC4500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4504: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC4508: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC450C: 4200FFF8  bdnz 0x82ec4504
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4504; continue 'dispatch;
	}
	// 82EC4510: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4514: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC4518: 992100A8  stb r9, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[9].u8 ) };
	// 82EC451C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC4520: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC4524: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4528: 4E800421  bctrl
	ctx.lr = 0x82EC452C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC452C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC4530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC4534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC4538: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC453C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC4540: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4548 size=812
    let mut pc: u32 = 0x82EC4548;
    'dispatch: loop {
        match pc {
            0x82EC4548 => {
    //   block [0x82EC4548..0x82EC4874)
	// 82EC4548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC454C: 4BDE4EBD  bl 0x82ca9408
	ctx.lr = 0x82EC4550;
	sub_82CA93D0(ctx, base);
	// 82EC4550: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4558: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC455C: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC4560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4564: 4082003C  bne 0x82ec45a0
	if !ctx.cr[0].eq {
	pc = 0x82EC45A0; continue 'dispatch;
	}
	// 82EC4568: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC456C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4570: 41820030  beq 0x82ec45a0
	if ctx.cr[0].eq {
	pc = 0x82EC45A0; continue 'dispatch;
	}
	// 82EC4574: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC4578: 480114B9  bl 0x82ed5a30
	ctx.lr = 0x82EC457C;
	sub_82ED5A30(ctx, base);
	// 82EC457C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC4580: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC4584: 419A001C  beq cr6, 0x82ec45a0
	if ctx.cr[6].eq {
	pc = 0x82EC45A0; continue 'dispatch;
	}
	// 82EC4588: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC458C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82EC4590: 4098000C  bge cr6, 0x82ec459c
	if !ctx.cr[6].lt {
	pc = 0x82EC459C; continue 'dispatch;
	}
	// 82EC4594: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EC4598: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EC459C: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EC45A0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC45A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC45A8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC45AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC45B0: 4E800421  bctrl
	ctx.lr = 0x82EC45B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC45B4: 897F0394  lbz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EC45B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC45BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC45C0: 41820060  beq 0x82ec4620
	if ctx.cr[0].eq {
	pc = 0x82EC4620; continue 'dispatch;
	}
	// 82EC45C4: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC45C8: 816A01B8  lwz r11, 0x1b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC45CC: 814A01BC  lwz r10, 0x1bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC45D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC45D4: 419A004C  beq cr6, 0x82ec4620
	if ctx.cr[6].eq {
	pc = 0x82EC4620; continue 'dispatch;
	}
	// 82EC45D8: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC45DC: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC45E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC45E4: 409A0028  bne cr6, 0x82ec460c
	if !ctx.cr[6].eq {
	pc = 0x82EC460C; continue 'dispatch;
	}
	// 82EC45E8: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC45EC: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC45F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC45F4: 409A0018  bne cr6, 0x82ec460c
	if !ctx.cr[6].eq {
	pc = 0x82EC460C; continue 'dispatch;
	}
	// 82EC45F8: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC45FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC4600: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4604: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4608: 419A0008  beq cr6, 0x82ec4610
	if ctx.cr[6].eq {
	pc = 0x82EC4610; continue 'dispatch;
	}
	// 82EC460C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4610: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4614: 4182000C  beq 0x82ec4620
	if ctx.cr[0].eq {
	pc = 0x82EC4620; continue 'dispatch;
	}
	// 82EC4618: 9B9F018C  stb r28, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[28].u8 ) };
	// 82EC461C: 9B9F0394  stb r28, 0x394(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[28].u8 ) };
	// 82EC4620: 4B39C399  bl 0x822609b8
	ctx.lr = 0x82EC4624;
	sub_822609B8(ctx, base);
	// 82EC4624: 809F0414  lwz r4, 0x414(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) } as u64;
	// 82EC4628: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC462C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 82EC4630: 409A0014  bne cr6, 0x82ec4644
	if !ctx.cr[6].eq {
	pc = 0x82EC4644; continue 'dispatch;
	}
	// 82EC4634: 897E006C  lbz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC4638: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC463C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC4640: 48000018  b 0x82ec4658
	pc = 0x82EC4658; continue 'dispatch;
	// 82EC4644: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC464C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4650: 4BFBD109  bl 0x82e81758
	ctx.lr = 0x82EC4654;
	sub_82E81758(ctx, base);
	// 82EC4654: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC4658: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC465C: 809F0414  lwz r4, 0x414(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) } as u64;
	// 82EC4660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC4664: 997F0410  stb r11, 0x410(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), ctx.r[11].u8 ) };
	// 82EC4668: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC466C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4670: 4182000C  beq 0x82ec467c
	if ctx.cr[0].eq {
	pc = 0x82EC467C; continue 'dispatch;
	}
	// 82EC4674: 4BFBD47D  bl 0x82e81af0
	ctx.lr = 0x82EC4678;
	sub_82E81AF0(ctx, base);
	// 82EC4678: 48000008  b 0x82ec4680
	pc = 0x82EC4680; continue 'dispatch;
	// 82EC467C: 4BFBD5BD  bl 0x82e81c38
	ctx.lr = 0x82EC4680;
	sub_82E81C38(ctx, base);
	// 82EC4680: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4684: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4688: 4182000C  beq 0x82ec4694
	if ctx.cr[0].eq {
	pc = 0x82EC4694; continue 'dispatch;
	}
	// 82EC468C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC4690: 48000008  b 0x82ec4698
	pc = 0x82EC4698; continue 'dispatch;
	// 82EC4694: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC4698: 3BDF027C  addi r30, r31, 0x27c
	ctx.r[30].s64 = ctx.r[31].s64 + 636;
	// 82EC469C: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82EC46A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC46A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC46A8: 4BFAB851  bl 0x82e6fef8
	ctx.lr = 0x82EC46AC;
	sub_82E6FEF8(ctx, base);
	// 82EC46AC: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EC46B0: 3BBF02D8  addi r29, r31, 0x2d8
	ctx.r[29].s64 = ctx.r[31].s64 + 728;
	// 82EC46B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC46B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC46BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC46C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC46C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC46C8: 4E800421  bctrl
	ctx.lr = 0x82EC46CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC46CC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC46D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC46D4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82EC46D8: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EC46DC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EC46E0: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC46E4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EC46E8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC46EC: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC46F0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC46F4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC46F8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC46FC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4700: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC4704: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82EC4708: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC470C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC4710: 4200FFF8  bdnz 0x82ec4708
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4708; continue 'dispatch;
	}
	// 82EC4714: 807F01C4  lwz r3, 0x1c4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EC4718: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC471C: 9B8100A8  stb r28, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[28].u8 ) };
	// 82EC4720: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC4724: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4728: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC472C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4730: 4E800421  bctrl
	ctx.lr = 0x82EC4734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4734: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC4738: 987F0396  stb r3, 0x396(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(918 as u32), ctx.r[3].u8 ) };
	// 82EC473C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC4740: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC4744: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4748: 4182000C  beq 0x82ec4754
	if ctx.cr[0].eq {
	pc = 0x82EC4754; continue 'dispatch;
	}
	// 82EC474C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4750: 4800011C  b 0x82ec486c
	pc = 0x82EC486C; continue 'dispatch;
	// 82EC4754: 897F0394  lbz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EC4758: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC475C: 41820020  beq 0x82ec477c
	if ctx.cr[0].eq {
	pc = 0x82EC477C; continue 'dispatch;
	}
	// 82EC4760: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4764: 814B01B8  lwz r10, 0x1b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC4768: 816B01BC  lwz r11, 0x1bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC476C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4770: 409A000C  bne cr6, 0x82ec477c
	if !ctx.cr[6].eq {
	pc = 0x82EC477C; continue 'dispatch;
	}
	// 82EC4774: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4778: 480000F4  b 0x82ec486c
	pc = 0x82EC486C; continue 'dispatch;
	// 82EC477C: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4780: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EC4784: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4788: 41820028  beq 0x82ec47b0
	if ctx.cr[0].eq {
	pc = 0x82EC47B0; continue 'dispatch;
	}
	// 82EC478C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4790: 38BF0435  addi r5, r31, 0x435
	ctx.r[5].s64 = ctx.r[31].s64 + 1077;
	// 82EC4794: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4798: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC479C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC47A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC47A4: 4E800421  bctrl
	ctx.lr = 0x82EC47A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC47A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC47AC: 41820060  beq 0x82ec480c
	if ctx.cr[0].eq {
	pc = 0x82EC480C; continue 'dispatch;
	}
	// 82EC47B0: 4B39C209  bl 0x822609b8
	ctx.lr = 0x82EC47B4;
	sub_822609B8(ctx, base);
	// 82EC47B4: 897F0410  lbz r11, 0x410(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EC47B8: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC47BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC47C0: 4182000C  beq 0x82ec47cc
	if ctx.cr[0].eq {
	pc = 0x82EC47CC; continue 'dispatch;
	}
	// 82EC47C4: C01F043C  lfs f0, 0x43c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC47C8: 48000014  b 0x82ec47dc
	pc = 0x82EC47DC; continue 'dispatch;
	// 82EC47CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC47D0: C19F043C  lfs f12, 0x43c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC47D4: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC47D8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC47DC: C19F0438  lfs f12, 0x438(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC47E0: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC47E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC47E8: 40980020  bge cr6, 0x82ec4808
	if !ctx.cr[6].lt {
	pc = 0x82EC4808; continue 'dispatch;
	}
	// 82EC47EC: 807F01EC  lwz r3, 0x1ec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EC47F0: D1BF0438  stfs f13, 0x438(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), tmp.u32 ) };
	// 82EC47F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC47F8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC47FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4800: 4E800421  bctrl
	ctx.lr = 0x82EC4804;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4804: 987F0435  stb r3, 0x435(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1077 as u32), ctx.r[3].u8 ) };
	// 82EC4808: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EC480C: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC4810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4814: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4818: 997F019D  stb r11, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[11].u8 ) };
	// 82EC481C: 816A0074  lwz r11, 0x74(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EC4820: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4824: 4E800421  bctrl
	ctx.lr = 0x82EC4828;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4828: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC482C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4830: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC4834: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4838: 4E800421  bctrl
	ctx.lr = 0x82EC483C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC483C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC4840: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4844: 41820020  beq 0x82ec4864
	if ctx.cr[0].eq {
	pc = 0x82EC4864; continue 'dispatch;
	}
	// 82EC4848: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC484C: 41820018  beq 0x82ec4864
	if ctx.cr[0].eq {
	pc = 0x82EC4864; continue 'dispatch;
	}
	// 82EC4850: 807F01EC  lwz r3, 0x1ec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EC4854: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4858: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC485C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4860: 4E800421  bctrl
	ctx.lr = 0x82EC4864;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC4868: 9B9F0435  stb r28, 0x435(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1077 as u32), ctx.r[28].u8 ) };
	// 82EC486C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EC4870: 4BDE4BE8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4878 size=580
    let mut pc: u32 = 0x82EC4878;
    'dispatch: loop {
        match pc {
            0x82EC4878 => {
    //   block [0x82EC4878..0x82EC4ABC)
	// 82EC4878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC487C: 4BDE4B8D  bl 0x82ca9408
	ctx.lr = 0x82EC4880;
	sub_82CA93D0(ctx, base);
	// 82EC4880: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4888: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EC488C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EC4890: 409A000C  bne cr6, 0x82ec489c
	if !ctx.cr[6].eq {
	pc = 0x82EC489C; continue 'dispatch;
	}
	// 82EC4894: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4898: 48000214  b 0x82ec4aac
	pc = 0x82EC4AAC; continue 'dispatch;
	// 82EC489C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC48A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC48A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC48A8: 3B8B9128  addi r28, r11, -0x6ed8
	ctx.r[28].s64 = ctx.r[11].s64 + -28376;
	// 82EC48AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC48B0: 3BCB9128  addi r30, r11, -0x6ed8
	ctx.r[30].s64 = ctx.r[11].s64 + -28376;
	// 82EC48B4: 409A00C4  bne cr6, 0x82ec4978
	if !ctx.cr[6].eq {
	pc = 0x82EC4978; continue 'dispatch;
	}
	// 82EC48B8: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC48BC: 816A01B8  lwz r11, 0x1b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC48C0: 814A01BC  lwz r10, 0x1bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC48C4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EC48C8: 419AFFCC  beq cr6, 0x82ec4894
	if ctx.cr[6].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC48CC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82EC48D0: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC48D4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC48D8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EC48DC: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC48E0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EC48E4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC48E8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC48EC: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC48F0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EC48F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC48F8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC48FC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4900: 4200FFF8  bdnz 0x82ec48f8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC48F8; continue 'dispatch;
	}
	// 82EC4904: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4908: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 82EC490C: 9BA100B8  stb r29, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u8 ) };
	// 82EC4910: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EC4914: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4918: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC491C: 93C10120  stw r30, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 82EC4920: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4924: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EC4928: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC492C: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EC4930: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4934: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EC4938: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC493C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4940: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4944: 4200FFF8  bdnz 0x82ec493c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC493C; continue 'dispatch;
	}
	// 82EC4948: 807F01C4  lwz r3, 0x1c4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EC494C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EC4950: 9BA10178  stb r29, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[29].u8 ) };
	// 82EC4954: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82EC4958: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC495C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4960: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4964: 4E800421  bctrl
	ctx.lr = 0x82EC4968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4968: 93810120  stw r28, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 82EC496C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4970: 4082FF24  bne 0x82ec4894
	if !ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC4974: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EC4978: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC497C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4980: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC4984: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4988: 4E800421  bctrl
	ctx.lr = 0x82EC498C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC498C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4990: 4182FF04  beq 0x82ec4894
	if ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC4994: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4998: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC499C: 4182FEF8  beq 0x82ec4894
	if ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC49A0: C01F0404  lfs f0, 0x404(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC49A4: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82EC49A8: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC49AC: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82EC49B0: C01F0408  lfs f0, 0x408(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC49B4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EC49B8: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC49BC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC49C0: C01F040C  lfs f0, 0x40c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC49C4: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC49C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC49CC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC49D0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC49D4: 4200FFF8  bdnz 0x82ec49cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC49CC; continue 'dispatch;
	}
	// 82EC49D8: 807F023C  lwz r3, 0x23c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EC49DC: 3BDF03A4  addi r30, r31, 0x3a4
	ctx.r[30].s64 = ctx.r[31].s64 + 932;
	// 82EC49E0: 9BA10118  stb r29, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[29].u8 ) };
	// 82EC49E4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EC49E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC49EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC49F0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC49F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC49F8: 4E800421  bctrl
	ctx.lr = 0x82EC49FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC49FC: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EC4A00: 987F0400  stb r3, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[3].u8 ) };
	// 82EC4A04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4A08: 4182FE8C  beq 0x82ec4894
	if ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC4A0C: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4A10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC4A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC4A18: 419A007C  beq cr6, 0x82ec4a94
	if ctx.cr[6].eq {
	pc = 0x82EC4A94; continue 'dispatch;
	}
	// 82EC4A1C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EC4A20: 4B2E8031  bl 0x821aca50
	ctx.lr = 0x82EC4A24;
	sub_821ACA50(ctx, base);
	// 82EC4A24: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4A28: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4A2C: 39010180  addi r8, r1, 0x180
	ctx.r[8].s64 = ctx.r[1].s64 + 384;
	// 82EC4A30: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82EC4A34: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC4A38: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4A3C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC4A40: 813F03A0  lwz r9, 0x3a0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4A44: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4A48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4A4C: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC4A50: 80840014  lwz r4, 0x14(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4A54: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC4A58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4A5C: 4E800421  bctrl
	ctx.lr = 0x82EC4A60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4A60: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC4A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC4A68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4A6C: 4182001C  beq 0x82ec4a88
	if ctx.cr[0].eq {
	pc = 0x82EC4A88; continue 'dispatch;
	}
	// 82EC4A70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4A74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC4A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4A7C: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC4A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4A84: 4E800421  bctrl
	ctx.lr = 0x82EC4A88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4A88: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4A8C: 40820028  bne 0x82ec4ab4
	if !ctx.cr[0].eq {
	pc = 0x82EC4AB4; continue 'dispatch;
	}
	// 82EC4A90: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EC4A94: 807F0250  lwz r3, 0x250(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EC4A98: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC4A9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4AA0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4AA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4AA8: 4E800421  bctrl
	ctx.lr = 0x82EC4AAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4AAC: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 82EC4AB0: 4BDE49A8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82EC4AB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4AB8: 4BFFFFF4  b 0x82ec4aac
	pc = 0x82EC4AAC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4AC0 size=1372
    let mut pc: u32 = 0x82EC4AC0;
    'dispatch: loop {
        match pc {
            0x82EC4AC0 => {
    //   block [0x82EC4AC0..0x82EC501C)
	// 82EC4AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC4AC4: 4BDE4931  bl 0x82ca93f4
	ctx.lr = 0x82EC4AC8;
	sub_82CA93D0(ctx, base);
	// 82EC4AC8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82EC4ACC: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4AD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4AD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4AD8: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC4ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4AE0: 4E800421  bctrl
	ctx.lr = 0x82EC4AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4AE4: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4AE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4AEC: 41820520  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4AF0: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4AF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4AF8: 41820060  beq 0x82ec4b58
	if ctx.cr[0].eq {
	pc = 0x82EC4B58; continue 'dispatch;
	}
	// 82EC4AFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B00: 815F039C  lwz r10, 0x39c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4B04: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4B08: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4B0C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC4B10: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B14: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4B18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4B1C: 4E800421  bctrl
	ctx.lr = 0x82EC4B20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4B20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4B24: 418204E8  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4B28: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4B2C: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4B30: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4B34: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4B38: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B40: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4B44: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC4B48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4B4C: 4E800421  bctrl
	ctx.lr = 0x82EC4B50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4B50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4B54: 418204B8  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4B58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC4B60: 83DF0390  lwz r30, 0x390(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4B68: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC4B6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4B70: 4E800421  bctrl
	ctx.lr = 0x82EC4B74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4B74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4B78: 4082000C  bne 0x82ec4b84
	if !ctx.cr[0].eq {
	pc = 0x82EC4B84; continue 'dispatch;
	}
	// 82EC4B7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4B80: 48000490  b 0x82ec5010
	pc = 0x82EC5010; continue 'dispatch;
	// 82EC4B84: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4B88: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC4B8C: 419A0068  beq cr6, 0x82ec4bf4
	if ctx.cr[6].eq {
	pc = 0x82EC4BF4; continue 'dispatch;
	}
	// 82EC4B90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC4B94: 419A0060  beq cr6, 0x82ec4bf4
	if ctx.cr[6].eq {
	pc = 0x82EC4BF4; continue 'dispatch;
	}
	// 82EC4B98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B9C: 815F039C  lwz r10, 0x39c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4BA0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4BA4: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4BA8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC4BAC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4BB0: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4BB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4BB8: 4E800421  bctrl
	ctx.lr = 0x82EC4BBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4BBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4BC0: 4182044C  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4BC4: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4BC8: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4BCC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4BD0: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4BD4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4BD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4BDC: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4BE0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC4BE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4BE8: 4E800421  bctrl
	ctx.lr = 0x82EC4BEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4BEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4BF0: 4182041C  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4BF4: 897F0410  lbz r11, 0x410(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EC4BF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4BFC: 4182000C  beq 0x82ec4c08
	if ctx.cr[0].eq {
	pc = 0x82EC4C08; continue 'dispatch;
	}
	// 82EC4C00: C3FF0420  lfs f31, 0x420(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1056 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC4C04: 48000014  b 0x82ec4c18
	pc = 0x82EC4C18; continue 'dispatch;
	// 82EC4C08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC4C0C: C1BF0420  lfs f13, 0x420(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1056 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4C10: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4C14: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC4C18: 4B39BDA1  bl 0x822609b8
	ctx.lr = 0x82EC4C1C;
	sub_822609B8(ctx, base);
	// 82EC4C1C: C01F0424  lfs f0, 0x424(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4C20: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EC4C24: C003004C  lfs f0, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4C28: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EC4C2C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC4C30: 41980010  blt cr6, 0x82ec4c40
	if ctx.cr[6].lt {
	pc = 0x82EC4C40; continue 'dispatch;
	}
	// 82EC4C34: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC4C38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4C3C: 41820350  beq 0x82ec4f8c
	if ctx.cr[0].eq {
	pc = 0x82EC4F8C; continue 'dispatch;
	}
	// 82EC4C40: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4C44: D01F0424  stfs f0, 0x424(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	// 82EC4C48: 837F039C  lwz r27, 0x39c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4C4C: 82FF03A0  lwz r23, 0x3a0(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4C50: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4C54: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC4C58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4C5C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4C60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4C64: 4E800421  bctrl
	ctx.lr = 0x82EC4C68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4C68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC4C6C: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82EC4C70: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC4C74: 418202A4  beq 0x82ec4f18
	if ctx.cr[0].eq {
	pc = 0x82EC4F18; continue 'dispatch;
	}
	// 82EC4C78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC4C7C: 3B8B9128  addi r28, r11, -0x6ed8
	ctx.r[28].s64 = ctx.r[11].s64 + -28376;
	// 82EC4C80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC4C84: 3B2B9F1C  addi r25, r11, -0x60e4
	ctx.r[25].s64 = ctx.r[11].s64 + -24804;
	// 82EC4C88: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4C8C: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 82EC4C90: 816B01BC  lwz r11, 0x1bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC4C94: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4C98: 419A0008  beq cr6, 0x82ec4ca0
	if ctx.cr[6].eq {
	pc = 0x82EC4CA0; continue 'dispatch;
	}
	// 82EC4C9C: 831EFFEC  lwz r24, -0x14(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82EC4CA0: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC4CA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4CA8: 4182002C  beq 0x82ec4cd4
	if ctx.cr[0].eq {
	pc = 0x82EC4CD4; continue 'dispatch;
	}
	// 82EC4CAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4CB0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EC4CB4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4CB8: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4CBC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC4CC0: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4CC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4CC8: 4E800421  bctrl
	ctx.lr = 0x82EC4CCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4CCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4CD0: 41820248  beq 0x82ec4f18
	if ctx.cr[0].eq {
	pc = 0x82EC4F18; continue 'dispatch;
	}
	// 82EC4CD4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4CD8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EC4CDC: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EC4CE0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EC4CE4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82EC4CE8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4CEC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC4CF0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4CF4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC4CF8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4CFC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC4D00: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D04: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EC4D08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC4D0C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4D10: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4D14: 4200FFF8  bdnz 0x82ec4d0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4D0C; continue 'dispatch;
	}
	// 82EC4D18: 9B4100B8  stb r26, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u8 ) };
	// 82EC4D1C: C01F0338  lfs f0, 0x338(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D20: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4D24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC4D28: 409A0028  bne cr6, 0x82ec4d50
	if !ctx.cr[6].eq {
	pc = 0x82EC4D50; continue 'dispatch;
	}
	// 82EC4D2C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D30: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4D34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4D38: 409A0018  bne cr6, 0x82ec4d50
	if !ctx.cr[6].eq {
	pc = 0x82EC4D50; continue 'dispatch;
	}
	// 82EC4D3C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4D44: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4D48: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4D4C: 419A0008  beq cr6, 0x82ec4d54
	if ctx.cr[6].eq {
	pc = 0x82EC4D54; continue 'dispatch;
	}
	// 82EC4D50: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82EC4D54: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4D58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC4D5C: 41820010  beq 0x82ec4d6c
	if ctx.cr[0].eq {
	pc = 0x82EC4D6C; continue 'dispatch;
	}
	// 82EC4D60: 389F02D8  addi r4, r31, 0x2d8
	ctx.r[4].s64 = ctx.r[31].s64 + 728;
	// 82EC4D64: 4BFAB195  bl 0x82e6fef8
	ctx.lr = 0x82EC4D68;
	sub_82E6FEF8(ctx, base);
	// 82EC4D68: 4800000C  b 0x82ec4d74
	pc = 0x82EC4D74; continue 'dispatch;
	// 82EC4D6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC4D70: 4B2E9939  bl 0x821ae6a8
	ctx.lr = 0x82EC4D74;
	sub_821AE6A8(ctx, base);
	// 82EC4D74: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4D78: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82EC4D7C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EC4D80: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4D84: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4D88: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82EC4D8C: 93A100C0  stw r29, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[29].u32 ) };
	// 82EC4D90: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82EC4D94: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D98: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC4D9C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DA0: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC4DA4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DA8: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC4DAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC4DB0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC4DB4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC4DB8: 4200FFF8  bdnz 0x82ec4db0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4DB0; continue 'dispatch;
	}
	// 82EC4DBC: 9B410118  stb r26, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[26].u8 ) };
	// 82EC4DC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4DC4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC4DC8: 419A0010  beq cr6, 0x82ec4dd8
	if ctx.cr[6].eq {
	pc = 0x82EC4DD8; continue 'dispatch;
	}
	// 82EC4DCC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EC4DD0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EC4DD4: 4B2E98D5  bl 0x821ae6a8
	ctx.lr = 0x82EC4DD8;
	sub_821AE6A8(ctx, base);
	// 82EC4DD8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4DDC: 39210190  addi r9, r1, 0x190
	ctx.r[9].s64 = ctx.r[1].s64 + 400;
	// 82EC4DE0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EC4DE4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4DE8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4DEC: 93A10180  stw r29, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[29].u32 ) };
	// 82EC4DF0: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DF4: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EC4DF8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DFC: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EC4E00: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E04: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82EC4E08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC4E0C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4E10: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4E14: 4200FFF8  bdnz 0x82ec4e0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4E0C; continue 'dispatch;
	}
	// 82EC4E18: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4E1C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC4E20: 9B4101D8  stb r26, 0x1d8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[26].u8 ) };
	// 82EC4E24: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EC4E28: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EC4E2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4E30: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC4E34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4E38: 4E800421  bctrl
	ctx.lr = 0x82EC4E3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4E3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC4E40: 93810180  stw r28, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[28].u32 ) };
	// 82EC4E44: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC4E48: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4E4C: 408200BC  bne 0x82ec4f08
	if !ctx.cr[0].eq {
	pc = 0x82EC4F08; continue 'dispatch;
	}
	// 82EC4E50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4E54: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 82EC4E58: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EC4E5C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4E60: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4E64: 93A10120  stw r29, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[29].u32 ) };
	// 82EC4E68: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E6C: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EC4E70: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E74: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EC4E78: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E7C: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EC4E80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC4E84: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4E88: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4E8C: 4200FFF8  bdnz 0x82ec4e84
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4E84; continue 'dispatch;
	}
	// 82EC4E90: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4E94: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC4E98: 9B410178  stb r26, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[26].u8 ) };
	// 82EC4E9C: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EC4EA0: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82EC4EA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4EA8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC4EAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4EB0: 4E800421  bctrl
	ctx.lr = 0x82EC4EB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4EB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC4EB8: 93810120  stw r28, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 82EC4EBC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC4EC0: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EC4EC4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EC4EC8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EC4ECC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EC4ED0: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4ED4: 40820044  bne 0x82ec4f18
	if !ctx.cr[0].eq {
	pc = 0x82EC4F18; continue 'dispatch;
	}
	// 82EC4ED8: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4EDC: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82EC4EE0: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4EE4: 7F17C378  mr r23, r24
	ctx.r[23].u64 = ctx.r[24].u64;
	// 82EC4EE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC4EEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4EF0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4EF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4EF8: 4E800421  bctrl
	ctx.lr = 0x82EC4EFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4EFC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC4F00: 4082FD88  bne 0x82ec4c88
	if !ctx.cr[0].eq {
	pc = 0x82EC4C88; continue 'dispatch;
	}
	// 82EC4F04: 48000014  b 0x82ec4f18
	pc = 0x82EC4F18; continue 'dispatch;
	// 82EC4F08: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EC4F0C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EC4F10: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EC4F14: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EC4F18: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EC4F1C: 419A0070  beq cr6, 0x82ec4f8c
	if ctx.cr[6].eq {
	pc = 0x82EC4F8C; continue 'dispatch;
	}
	// 82EC4F20: 937F039C  stw r27, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[27].u32 ) };
	// 82EC4F24: 394101F0  addi r10, r1, 0x1f0
	ctx.r[10].s64 = ctx.r[1].s64 + 496;
	// 82EC4F28: 92FF03A0  stw r23, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[23].u32 ) };
	// 82EC4F2C: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4F30: D00101E4  stfs f0, 0x1e4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82EC4F34: 93A101E0  stw r29, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[29].u32 ) };
	// 82EC4F38: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4F3C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82EC4F40: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82EC4F44: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC4F48: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4F4C: D00101EC  stfs f0, 0x1ec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 82EC4F50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4F54: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC4F58: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC4F5C: 4200FFF8  bdnz 0x82ec4f54
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4F54; continue 'dispatch;
	}
	// 82EC4F60: 388101E0  addi r4, r1, 0x1e0
	ctx.r[4].s64 = ctx.r[1].s64 + 480;
	// 82EC4F64: 9B410238  stb r26, 0x238(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), ctx.r[26].u8 ) };
	// 82EC4F68: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 82EC4F6C: 4BFAAF8D  bl 0x82e6fef8
	ctx.lr = 0x82EC4F70;
	sub_82E6FEF8(ctx, base);
	// 82EC4F70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4F74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC4F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4F7C: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC4F80: 995F0400  stb r10, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[10].u8 ) };
	// 82EC4F84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4F88: 4E800421  bctrl
	ctx.lr = 0x82EC4F8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4F8C: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4F90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4F94: 41820078  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4F98: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4F9C: C01F0338  lfs f0, 0x338(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FA0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4FA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC4FA8: 409A0028  bne cr6, 0x82ec4fd0
	if !ctx.cr[6].eq {
	pc = 0x82EC4FD0; continue 'dispatch;
	}
	// 82EC4FAC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FB0: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4FB4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4FB8: 409A0018  bne cr6, 0x82ec4fd0
	if !ctx.cr[6].eq {
	pc = 0x82EC4FD0; continue 'dispatch;
	}
	// 82EC4FBC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FC0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82EC4FC4: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4FC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4FCC: 419A0008  beq cr6, 0x82ec4fd4
	if ctx.cr[6].eq {
	pc = 0x82EC4FD4; continue 'dispatch;
	}
	// 82EC4FD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC4FD4: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC4FD8: 4182001C  beq 0x82ec4ff4
	if ctx.cr[0].eq {
	pc = 0x82EC4FF4; continue 'dispatch;
	}
	// 82EC4FDC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FE0: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EC4FE4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FE8: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EC4FEC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FF0: 48000018  b 0x82ec5008
	pc = 0x82EC5008; continue 'dispatch;
	// 82EC4FF4: C01F02DC  lfs f0, 0x2dc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FF8: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EC4FFC: C01F02E0  lfs f0, 0x2e0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5000: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EC5004: C01F02E4  lfs f0, 0x2e4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5008: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82EC500C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5010: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 82EC5014: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EC5018: 4BDE442C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC5020 size=196
    let mut pc: u32 = 0x82EC5020;
    'dispatch: loop {
        match pc {
            0x82EC5020 => {
    //   block [0x82EC5020..0x82EC50E4)
	// 82EC5020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5028: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC502C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC5030: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5034: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EC5038: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82EC503C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC5040: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5044: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EC5048: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC504C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5050: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC5054: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EC5058: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EC505C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC5060: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC5064: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC5068: 4200FFF8  bdnz 0x82ec5060
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5060; continue 'dispatch;
	}
	// 82EC506C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5070: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC5074: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC5078: 99010108  stb r8, 0x108(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[8].u8 ) };
	// 82EC507C: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5080: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82EC5084: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC5088: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82EC508C: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5090: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC5094: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC5098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC509C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC50A0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC50A4: 4200FFF8  bdnz 0x82ec509c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC509C; continue 'dispatch;
	}
	// 82EC50A8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC50AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC50B0: 81630228  lwz r11, 0x228(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EC50B4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EC50B8: 990100A8  stb r8, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u8 ) };
	// 82EC50BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EC50C0: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC50C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC50C8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC50CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC50D0: 4E800421  bctrl
	ctx.lr = 0x82EC50D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC50D4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EC50D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC50DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC50E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC50E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC50E8 size=292
    let mut pc: u32 = 0x82EC50E8;
    'dispatch: loop {
        match pc {
            0x82EC50E8 => {
    //   block [0x82EC50E8..0x82EC520C)
	// 82EC50E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC50EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC50F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC50F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC50F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC50FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5100: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC5104: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5108: 40820010  bne 0x82ec5118
	if !ctx.cr[0].eq {
	pc = 0x82EC5118; continue 'dispatch;
	}
	// 82EC510C: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5110: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5114: 419A00E0  beq cr6, 0x82ec51f4
	if ctx.cr[6].eq {
	pc = 0x82EC51F4; continue 'dispatch;
	}
	// 82EC5118: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC511C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC5120: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5124: 4082002C  bne 0x82ec5150
	if !ctx.cr[0].eq {
	pc = 0x82EC5150; continue 'dispatch;
	}
	// 82EC5128: 897F0434  lbz r11, 0x434(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1076 as u32) ) } as u64;
	// 82EC512C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5130: 409A0020  bne cr6, 0x82ec5150
	if !ctx.cr[6].eq {
	pc = 0x82EC5150; continue 'dispatch;
	}
	// 82EC5134: 38DF03A0  addi r6, r31, 0x3a0
	ctx.r[6].s64 = ctx.r[31].s64 + 928;
	// 82EC5138: 38BF039C  addi r5, r31, 0x39c
	ctx.r[5].s64 = ctx.r[31].s64 + 924;
	// 82EC513C: 389F0428  addi r4, r31, 0x428
	ctx.r[4].s64 = ctx.r[31].s64 + 1064;
	// 82EC5140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5144: 4BFFF215  bl 0x82ec4358
	ctx.lr = 0x82EC5148;
	sub_82EC4358(ctx, base);
	// 82EC5148: 987F0400  stb r3, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[3].u8 ) };
	// 82EC514C: 48000008  b 0x82ec5154
	pc = 0x82EC5154; continue 'dispatch;
	// 82EC5150: 9BDF0400  stb r30, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	// 82EC5154: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5158: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC515C: 4082002C  bne 0x82ec5188
	if !ctx.cr[0].eq {
	pc = 0x82EC5188; continue 'dispatch;
	}
	// 82EC5160: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC5164: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EC5168: 812B01BC  lwz r9, 0x1bc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC516C: 915F03A0  stw r10, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[10].u32 ) };
	// 82EC5170: 552A003E  slwi r10, r9, 0
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5174: 913F039C  stw r9, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[9].u32 ) };
	// 82EC5178: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC517C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC5180: 409A0008  bne cr6, 0x82ec5188
	if !ctx.cr[6].eq {
	pc = 0x82EC5188; continue 'dispatch;
	}
	// 82EC5184: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	// 82EC5188: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC518C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5190: 41820060  beq 0x82ec51f0
	if ctx.cr[0].eq {
	pc = 0x82EC51F0; continue 'dispatch;
	}
	// 82EC5194: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EC5198: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EC519C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82EC51A0: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EC51A4: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82EC51A8: 98FF0400  stb r7, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[7].u8 ) };
	// 82EC51AC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC51B0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC51B4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC51B8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC51BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC51C0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC51C4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC51C8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC51CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC51D0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC51D4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC51D8: 4200FFF8  bdnz 0x82ec51d0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC51D0; continue 'dispatch;
	}
	// 82EC51DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC51E0: 9BC100A8  stb r30, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u8 ) };
	// 82EC51E4: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 82EC51E8: 4BFAAD11  bl 0x82e6fef8
	ctx.lr = 0x82EC51EC;
	sub_82E6FEF8(ctx, base);
	// 82EC51EC: 48000008  b 0x82ec51f4
	pc = 0x82EC51F4; continue 'dispatch;
	// 82EC51F0: 9BDF0400  stb r30, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	// 82EC51F4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC51F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC51FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5200: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC5204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC5210 size=752
    let mut pc: u32 = 0x82EC5210;
    'dispatch: loop {
        match pc {
            0x82EC5210 => {
    //   block [0x82EC5210..0x82EC5500)
	// 82EC5210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5214: 4BDE41F1  bl 0x82ca9404
	ctx.lr = 0x82EC5218;
	sub_82CA93D0(ctx, base);
	// 82EC5218: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC521C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5220: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC5224: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82EC5228: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC522C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5230: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82EC5234: 409A02C0  bne cr6, 0x82ec54f4
	if !ctx.cr[6].eq {
	pc = 0x82EC54F4; continue 'dispatch;
	}
	// 82EC5238: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC523C: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC5240: 3B8B0014  addi r28, r11, 0x14
	ctx.r[28].s64 = ctx.r[11].s64 + 20;
	// 82EC5244: 814A01B8  lwz r10, 0x1b8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC5248: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC524C: 409A0108  bne cr6, 0x82ec5354
	if !ctx.cr[6].eq {
	pc = 0x82EC5354; continue 'dispatch;
	}
	// 82EC5250: C01F0338  lfs f0, 0x338(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5254: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC5258: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC525C: 409A0028  bne cr6, 0x82ec5284
	if !ctx.cr[6].eq {
	pc = 0x82EC5284; continue 'dispatch;
	}
	// 82EC5260: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5264: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC5268: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC526C: 409A0018  bne cr6, 0x82ec5284
	if !ctx.cr[6].eq {
	pc = 0x82EC5284; continue 'dispatch;
	}
	// 82EC5270: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5274: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82EC5278: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC527C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC5280: 419A0008  beq cr6, 0x82ec5288
	if ctx.cr[6].eq {
	pc = 0x82EC5288; continue 'dispatch;
	}
	// 82EC5284: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC5288: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC528C: 418200B4  beq 0x82ec5340
	if ctx.cr[0].eq {
	pc = 0x82EC5340; continue 'dispatch;
	}
	// 82EC5290: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EC5294: 39010130  addi r8, r1, 0x130
	ctx.r[8].s64 = ctx.r[1].s64 + 304;
	// 82EC5298: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EC529C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EC52A0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EC52A4: 91410120  stw r10, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[10].u32 ) };
	// 82EC52A8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52AC: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EC52B0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52B4: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EC52B8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52BC: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EC52C0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82EC52C4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC52C8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC52CC: 4200FFF8  bdnz 0x82ec52c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC52C4; continue 'dispatch;
	}
	// 82EC52D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC52D4: 39210190  addi r9, r1, 0x190
	ctx.r[9].s64 = ctx.r[1].s64 + 400;
	// 82EC52D8: 9B610178  stb r27, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[27].u8 ) };
	// 82EC52DC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EC52E0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC52E4: 91410180  stw r10, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[10].u32 ) };
	// 82EC52E8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC52EC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52F0: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EC52F4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52F8: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EC52FC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5300: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82EC5304: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC5308: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC530C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC5310: 4200FFF8  bdnz 0x82ec5308
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5308; continue 'dispatch;
	}
	// 82EC5314: 807F0214  lwz r3, 0x214(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EC5318: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 82EC531C: 9B6101D8  stb r27, 0x1d8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[27].u8 ) };
	// 82EC5320: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EC5324: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5328: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC532C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC5330: 4E800421  bctrl
	ctx.lr = 0x82EC5334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC5334: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5338: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC533C: 40820008  bne 0x82ec5344
	if !ctx.cr[0].eq {
	pc = 0x82EC5344; continue 'dispatch;
	}
	// 82EC5340: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC5344: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC5348: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC534C: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC5350: 480001A8  b 0x82ec54f8
	pc = 0x82EC54F8; continue 'dispatch;
	// 82EC5354: 548A063E  clrlwi r10, r4, 0x18
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EC5358: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EC535C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EC5360: 3BAA9128  addi r29, r10, -0x6ed8
	ctx.r[29].s64 = ctx.r[10].s64 + -28376;
	// 82EC5364: 419A00B0  beq cr6, 0x82ec5414
	if ctx.cr[6].eq {
	pc = 0x82EC5414; continue 'dispatch;
	}
	// 82EC5368: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82EC536C: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5370: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC5374: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EC5378: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC537C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EC5380: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC5384: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC5388: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC538C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EC5390: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC5394: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC5398: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC539C: 4200FFF8  bdnz 0x82ec5394
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5394; continue 'dispatch;
	}
	// 82EC53A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC53A4: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82EC53A8: 9B6100B8  stb r27, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[27].u8 ) };
	// 82EC53AC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EC53B0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC53B4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC53B8: 93A100C0  stw r29, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[29].u32 ) };
	// 82EC53BC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC53C0: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC53C4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC53C8: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC53CC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC53D0: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC53D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC53D8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC53DC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC53E0: 4200FFF8  bdnz 0x82ec53d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC53D8; continue 'dispatch;
	}
	// 82EC53E4: 807F0214  lwz r3, 0x214(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EC53E8: 3BC0000C  li r30, 0xc
	ctx.r[30].s64 = 12;
	// 82EC53EC: 9B610118  stb r27, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[27].u8 ) };
	// 82EC53F0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EC53F4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EC53F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC53FC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC5400: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC5404: 4E800421  bctrl
	ctx.lr = 0x82EC5408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC5408: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC540C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC5410: 41820008  beq 0x82ec5418
	if ctx.cr[0].eq {
	pc = 0x82EC5418; continue 'dispatch;
	}
	// 82EC5414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC5418: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC541C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC5420: 57C90739  rlwinm. r9, r30, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC5424: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC5428: 4182000C  beq 0x82ec5434
	if ctx.cr[0].eq {
	pc = 0x82EC5434; continue 'dispatch;
	}
	// 82EC542C: 57DE0776  rlwinm r30, r30, 0, 0x1d, 0x1b
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82EC5430: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EC5434: 57C9077B  rlwinm. r9, r30, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC5438: 41820008  beq 0x82ec5440
	if ctx.cr[0].eq {
	pc = 0x82EC5440; continue 'dispatch;
	}
	// 82EC543C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EC5440: 554B063F  clrlwi. r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5444: 418200B0  beq 0x82ec54f4
	if ctx.cr[0].eq {
	pc = 0x82EC54F4; continue 'dispatch;
	}
	// 82EC5448: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC544C: 394101F0  addi r10, r1, 0x1f0
	ctx.r[10].s64 = ctx.r[1].s64 + 496;
	// 82EC5450: 93A101E0  stw r29, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[29].u32 ) };
	// 82EC5454: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EC5458: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC545C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC5460: 939F039C  stw r28, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[28].u32 ) };
	// 82EC5464: 911F03A0  stw r8, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[8].u32 ) };
	// 82EC5468: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC546C: D00101E4  stfs f0, 0x1e4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82EC5470: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5474: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82EC5478: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC547C: D00101EC  stfs f0, 0x1ec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 82EC5480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC5484: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5488: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC548C: 4200FFF8  bdnz 0x82ec5484
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5484; continue 'dispatch;
	}
	// 82EC5490: 388101E0  addi r4, r1, 0x1e0
	ctx.r[4].s64 = ctx.r[1].s64 + 480;
	// 82EC5494: 9B610238  stb r27, 0x238(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), ctx.r[27].u8 ) };
	// 82EC5498: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 82EC549C: 4BFAAA5D  bl 0x82e6fef8
	ctx.lr = 0x82EC54A0;
	sub_82E6FEF8(ctx, base);
	// 82EC54A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC54A4: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC54A8: 995F0400  stb r10, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[10].u8 ) };
	// 82EC54AC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC54B0: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EC54B4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC54B8: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EC54BC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC54C0: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82EC54C4: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC54C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC54CC: 4182000C  beq 0x82ec54d8
	if ctx.cr[0].eq {
	pc = 0x82EC54D8; continue 'dispatch;
	}
	// 82EC54D0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC54D4: 48000008  b 0x82ec54dc
	pc = 0x82EC54DC; continue 'dispatch;
	// 82EC54D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC54DC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC54E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC54E4: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82EC54E8: 814A0064  lwz r10, 0x64(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC54EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC54F0: 4E800421  bctrl
	ctx.lr = 0x82EC54F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC54F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC54F8: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 82EC54FC: 4BDE3F58  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5500 size=200
    let mut pc: u32 = 0x82EC5500;
    'dispatch: loop {
        match pc {
            0x82EC5500 => {
    //   block [0x82EC5500..0x82EC55C8)
	// 82EC5500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5508: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC550C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5514: 4BFF6315  bl 0x82ebb828
	ctx.lr = 0x82EC5518;
	sub_82EBB828(ctx, base);
	// 82EC5518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC551C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5520: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5524: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5528: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC552C: 40810054  ble 0x82ec5580
	if !ctx.cr[0].gt {
	pc = 0x82EC5580; continue 'dispatch;
	}
	// 82EC5530: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC5534: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5538: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC553C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5540: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5544: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5548: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC554C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5550: 41820014  beq 0x82ec5564
	if ctx.cr[0].eq {
	pc = 0x82EC5564; continue 'dispatch;
	}
	// 82EC5554: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5558: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC555C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5560: 419AFFE0  beq cr6, 0x82ec5540
	if ctx.cr[6].eq {
	pc = 0x82EC5540; continue 'dispatch;
	}
	// 82EC5564: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5568: 41820028  beq 0x82ec5590
	if ctx.cr[0].eq {
	pc = 0x82EC5590; continue 'dispatch;
	}
	// 82EC556C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5570: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5574: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5578: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC557C: 4198FFB8  blt cr6, 0x82ec5534
	if ctx.cr[6].lt {
	pc = 0x82EC5534; continue 'dispatch;
	}
	// 82EC5580: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5584: 409A0018  bne cr6, 0x82ec559c
	if !ctx.cr[6].eq {
	pc = 0x82EC559C; continue 'dispatch;
	}
	// 82EC5588: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC558C: 48000028  b 0x82ec55b4
	pc = 0x82EC55B4; continue 'dispatch;
	// 82EC5590: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5594: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5598: 48000018  b 0x82ec55b0
	pc = 0x82EC55B0; continue 'dispatch;
	// 82EC559C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC55A0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC55A4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC55A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC55AC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC55B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC55B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC55B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC55BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC55C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC55C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC55C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC55C8 size=196
    let mut pc: u32 = 0x82EC55C8;
    'dispatch: loop {
        match pc {
            0x82EC55C8 => {
    //   block [0x82EC55C8..0x82EC568C)
	// 82EC55C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC55CC: 4BDE3E39  bl 0x82ca9404
	ctx.lr = 0x82EC55D0;
	sub_82CA93D0(ctx, base);
	// 82EC55D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC55D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC55D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC55DC: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC55E0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC55E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC55E8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC55EC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC55F0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC55F4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC55F8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC55FC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC5600: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5604: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5608: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC560C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5610: 4082FFF0  bne 0x82ec5600
	if !ctx.cr[0].eq {
	pc = 0x82EC5600; continue 'dispatch;
	}
	// 82EC5614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5618: 4BFFFEE9  bl 0x82ec5500
	ctx.lr = 0x82EC561C;
	sub_82EC5500(ctx, base);
	// 82EC561C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5620: 4082000C  bne 0x82ec562c
	if !ctx.cr[0].eq {
	pc = 0x82EC562C; continue 'dispatch;
	}
	// 82EC5624: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5628: 48000010  b 0x82ec5638
	pc = 0x82EC5638; continue 'dispatch;
	// 82EC562C: 4BFF61FD  bl 0x82ebb828
	ctx.lr = 0x82EC5630;
	sub_82EBB828(ctx, base);
	// 82EC5630: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5634: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5638: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC563C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5640: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5644: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5648: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC564C: 409A0010  bne cr6, 0x82ec565c
	if !ctx.cr[6].eq {
	pc = 0x82EC565C; continue 'dispatch;
	}
	// 82EC5650: 4BFBA409  bl 0x82e7fa58
	ctx.lr = 0x82EC5654;
	sub_82E7FA58(ctx, base);
	// 82EC5654: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5658: 4800000C  b 0x82ec5664
	pc = 0x82EC5664; continue 'dispatch;
	// 82EC565C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5660: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5664: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5668: 41820018  beq 0x82ec5680
	if ctx.cr[0].eq {
	pc = 0x82EC5680; continue 'dispatch;
	}
	// 82EC566C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5670: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5674: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5678: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC567C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5684: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5688: 4BDE3DCC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5690 size=68
    let mut pc: u32 = 0x82EC5690;
    'dispatch: loop {
        match pc {
            0x82EC5690 => {
    //   block [0x82EC5690..0x82EC56D4)
	// 82EC5690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5698: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC569C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC56A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC56A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC56A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC56AC: 4BFFFF1D  bl 0x82ec55c8
	ctx.lr = 0x82EC56B0;
	sub_82EC55C8(ctx, base);
	// 82EC56B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC56B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC56B8: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC56BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC56C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC56C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC56C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC56CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC56D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC56D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC56D8 size=200
    let mut pc: u32 = 0x82EC56D8;
    'dispatch: loop {
        match pc {
            0x82EC56D8 => {
    //   block [0x82EC56D8..0x82EC57A0)
	// 82EC56D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC56DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC56E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC56E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC56E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC56EC: 4BFF604D  bl 0x82ebb738
	ctx.lr = 0x82EC56F0;
	sub_82EBB738(ctx, base);
	// 82EC56F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC56F4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC56F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC56FC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5700: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5704: 40810054  ble 0x82ec5758
	if !ctx.cr[0].gt {
	pc = 0x82EC5758; continue 'dispatch;
	}
	// 82EC5708: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC570C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5710: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5714: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5718: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC571C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5720: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5724: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5728: 41820014  beq 0x82ec573c
	if ctx.cr[0].eq {
	pc = 0x82EC573C; continue 'dispatch;
	}
	// 82EC572C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5730: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5734: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5738: 419AFFE0  beq cr6, 0x82ec5718
	if ctx.cr[6].eq {
	pc = 0x82EC5718; continue 'dispatch;
	}
	// 82EC573C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5740: 41820028  beq 0x82ec5768
	if ctx.cr[0].eq {
	pc = 0x82EC5768; continue 'dispatch;
	}
	// 82EC5744: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5748: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC574C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5750: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5754: 4198FFB8  blt cr6, 0x82ec570c
	if ctx.cr[6].lt {
	pc = 0x82EC570C; continue 'dispatch;
	}
	// 82EC5758: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC575C: 409A0018  bne cr6, 0x82ec5774
	if !ctx.cr[6].eq {
	pc = 0x82EC5774; continue 'dispatch;
	}
	// 82EC5760: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5764: 48000028  b 0x82ec578c
	pc = 0x82EC578C; continue 'dispatch;
	// 82EC5768: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC576C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5770: 48000018  b 0x82ec5788
	pc = 0x82EC5788; continue 'dispatch;
	// 82EC5774: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5778: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC577C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5780: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5784: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5788: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC578C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5790: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5794: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC579C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC57A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC57A0 size=196
    let mut pc: u32 = 0x82EC57A0;
    'dispatch: loop {
        match pc {
            0x82EC57A0 => {
    //   block [0x82EC57A0..0x82EC5864)
	// 82EC57A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC57A4: 4BDE3C61  bl 0x82ca9404
	ctx.lr = 0x82EC57A8;
	sub_82CA93D0(ctx, base);
	// 82EC57A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC57AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC57B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC57B4: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC57B8: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC57BC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC57C0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC57C4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC57C8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC57CC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC57D0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC57D4: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC57D8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC57DC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC57E0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC57E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC57E8: 4082FFF0  bne 0x82ec57d8
	if !ctx.cr[0].eq {
	pc = 0x82EC57D8; continue 'dispatch;
	}
	// 82EC57EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC57F0: 4BFFFEE9  bl 0x82ec56d8
	ctx.lr = 0x82EC57F4;
	sub_82EC56D8(ctx, base);
	// 82EC57F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC57F8: 4082000C  bne 0x82ec5804
	if !ctx.cr[0].eq {
	pc = 0x82EC5804; continue 'dispatch;
	}
	// 82EC57FC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5800: 48000010  b 0x82ec5810
	pc = 0x82EC5810; continue 'dispatch;
	// 82EC5804: 4BFF5F35  bl 0x82ebb738
	ctx.lr = 0x82EC5808;
	sub_82EBB738(ctx, base);
	// 82EC5808: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC580C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5810: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5814: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5818: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC581C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5820: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5824: 409A0010  bne cr6, 0x82ec5834
	if !ctx.cr[6].eq {
	pc = 0x82EC5834; continue 'dispatch;
	}
	// 82EC5828: 4BFBA231  bl 0x82e7fa58
	ctx.lr = 0x82EC582C;
	sub_82E7FA58(ctx, base);
	// 82EC582C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5830: 4800000C  b 0x82ec583c
	pc = 0x82EC583C; continue 'dispatch;
	// 82EC5834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5838: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC583C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5840: 41820018  beq 0x82ec5858
	if ctx.cr[0].eq {
	pc = 0x82EC5858; continue 'dispatch;
	}
	// 82EC5844: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5848: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC584C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5850: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5854: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC585C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5860: 4BDE3BF4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5868 size=68
    let mut pc: u32 = 0x82EC5868;
    'dispatch: loop {
        match pc {
            0x82EC5868 => {
    //   block [0x82EC5868..0x82EC58AC)
	// 82EC5868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC586C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5874: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5878: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC587C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5884: 4BFFFF1D  bl 0x82ec57a0
	ctx.lr = 0x82EC5888;
	sub_82EC57A0(ctx, base);
	// 82EC5888: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC588C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5890: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC5894: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5898: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC589C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC58A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC58A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC58A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC58B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC58B0 size=200
    let mut pc: u32 = 0x82EC58B0;
    'dispatch: loop {
        match pc {
            0x82EC58B0 => {
    //   block [0x82EC58B0..0x82EC5978)
	// 82EC58B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC58B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC58B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC58BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC58C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC58C4: 4BFF5EED  bl 0x82ebb7b0
	ctx.lr = 0x82EC58C8;
	sub_82EBB7B0(ctx, base);
	// 82EC58C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC58CC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC58D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC58D4: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC58D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC58DC: 40810054  ble 0x82ec5930
	if !ctx.cr[0].gt {
	pc = 0x82EC5930; continue 'dispatch;
	}
	// 82EC58E0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC58E4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC58E8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC58EC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC58F0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC58F4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC58F8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC58FC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5900: 41820014  beq 0x82ec5914
	if ctx.cr[0].eq {
	pc = 0x82EC5914; continue 'dispatch;
	}
	// 82EC5904: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5908: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC590C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5910: 419AFFE0  beq cr6, 0x82ec58f0
	if ctx.cr[6].eq {
	pc = 0x82EC58F0; continue 'dispatch;
	}
	// 82EC5914: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5918: 41820028  beq 0x82ec5940
	if ctx.cr[0].eq {
	pc = 0x82EC5940; continue 'dispatch;
	}
	// 82EC591C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5920: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5924: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5928: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC592C: 4198FFB8  blt cr6, 0x82ec58e4
	if ctx.cr[6].lt {
	pc = 0x82EC58E4; continue 'dispatch;
	}
	// 82EC5930: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5934: 409A0018  bne cr6, 0x82ec594c
	if !ctx.cr[6].eq {
	pc = 0x82EC594C; continue 'dispatch;
	}
	// 82EC5938: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC593C: 48000028  b 0x82ec5964
	pc = 0x82EC5964; continue 'dispatch;
	// 82EC5940: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5944: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5948: 48000018  b 0x82ec5960
	pc = 0x82EC5960; continue 'dispatch;
	// 82EC594C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5950: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5954: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5958: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC595C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5960: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5964: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC596C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5970: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5978 size=196
    let mut pc: u32 = 0x82EC5978;
    'dispatch: loop {
        match pc {
            0x82EC5978 => {
    //   block [0x82EC5978..0x82EC5A3C)
	// 82EC5978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC597C: 4BDE3A89  bl 0x82ca9404
	ctx.lr = 0x82EC5980;
	sub_82CA93D0(ctx, base);
	// 82EC5980: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5984: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC598C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5990: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5994: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5998: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC599C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC59A0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC59A4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC59A8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC59AC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC59B0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC59B4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC59B8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC59BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC59C0: 4082FFF0  bne 0x82ec59b0
	if !ctx.cr[0].eq {
	pc = 0x82EC59B0; continue 'dispatch;
	}
	// 82EC59C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC59C8: 4BFFFEE9  bl 0x82ec58b0
	ctx.lr = 0x82EC59CC;
	sub_82EC58B0(ctx, base);
	// 82EC59CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC59D0: 4082000C  bne 0x82ec59dc
	if !ctx.cr[0].eq {
	pc = 0x82EC59DC; continue 'dispatch;
	}
	// 82EC59D4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC59D8: 48000010  b 0x82ec59e8
	pc = 0x82EC59E8; continue 'dispatch;
	// 82EC59DC: 4BFF5DD5  bl 0x82ebb7b0
	ctx.lr = 0x82EC59E0;
	sub_82EBB7B0(ctx, base);
	// 82EC59E0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC59E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC59E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC59EC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC59F0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC59F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC59F8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC59FC: 409A0010  bne cr6, 0x82ec5a0c
	if !ctx.cr[6].eq {
	pc = 0x82EC5A0C; continue 'dispatch;
	}
	// 82EC5A00: 4BFBA059  bl 0x82e7fa58
	ctx.lr = 0x82EC5A04;
	sub_82E7FA58(ctx, base);
	// 82EC5A04: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5A08: 4800000C  b 0x82ec5a14
	pc = 0x82EC5A14; continue 'dispatch;
	// 82EC5A0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5A10: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5A14: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5A18: 41820018  beq 0x82ec5a30
	if ctx.cr[0].eq {
	pc = 0x82EC5A30; continue 'dispatch;
	}
	// 82EC5A1C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5A20: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5A24: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5A28: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5A2C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5A34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5A38: 4BDE3A1C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5A40 size=68
    let mut pc: u32 = 0x82EC5A40;
    'dispatch: loop {
        match pc {
            0x82EC5A40 => {
    //   block [0x82EC5A40..0x82EC5A84)
	// 82EC5A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5A48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5A4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5A50: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5A54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5A58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5A5C: 4BFFFF1D  bl 0x82ec5978
	ctx.lr = 0x82EC5A60;
	sub_82EC5978(ctx, base);
	// 82EC5A60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5A68: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC5A6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5A70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5A74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5A78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5A7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5A80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5A88 size=200
    let mut pc: u32 = 0x82EC5A88;
    'dispatch: loop {
        match pc {
            0x82EC5A88 => {
    //   block [0x82EC5A88..0x82EC5B50)
	// 82EC5A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5A94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5A98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5A9C: 4BFF5BAD  bl 0x82ebb648
	ctx.lr = 0x82EC5AA0;
	sub_82EBB648(ctx, base);
	// 82EC5AA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC5AA4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5AA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5AAC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5AB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5AB4: 40810054  ble 0x82ec5b08
	if !ctx.cr[0].gt {
	pc = 0x82EC5B08; continue 'dispatch;
	}
	// 82EC5AB8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC5ABC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5AC0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5AC4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5AC8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5ACC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5AD0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5AD4: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5AD8: 41820014  beq 0x82ec5aec
	if ctx.cr[0].eq {
	pc = 0x82EC5AEC; continue 'dispatch;
	}
	// 82EC5ADC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5AE0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5AE4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5AE8: 419AFFE0  beq cr6, 0x82ec5ac8
	if ctx.cr[6].eq {
	pc = 0x82EC5AC8; continue 'dispatch;
	}
	// 82EC5AEC: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5AF0: 41820028  beq 0x82ec5b18
	if ctx.cr[0].eq {
	pc = 0x82EC5B18; continue 'dispatch;
	}
	// 82EC5AF4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5AF8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5AFC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5B00: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5B04: 4198FFB8  blt cr6, 0x82ec5abc
	if ctx.cr[6].lt {
	pc = 0x82EC5ABC; continue 'dispatch;
	}
	// 82EC5B08: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5B0C: 409A0018  bne cr6, 0x82ec5b24
	if !ctx.cr[6].eq {
	pc = 0x82EC5B24; continue 'dispatch;
	}
	// 82EC5B10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5B14: 48000028  b 0x82ec5b3c
	pc = 0x82EC5B3C; continue 'dispatch;
	// 82EC5B18: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5B1C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5B20: 48000018  b 0x82ec5b38
	pc = 0x82EC5B38; continue 'dispatch;
	// 82EC5B24: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5B28: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5B2C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5B30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5B34: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5B38: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5B3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5B40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5B44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5B48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5B4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5B50 size=196
    let mut pc: u32 = 0x82EC5B50;
    'dispatch: loop {
        match pc {
            0x82EC5B50 => {
    //   block [0x82EC5B50..0x82EC5C14)
	// 82EC5B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5B54: 4BDE38B1  bl 0x82ca9404
	ctx.lr = 0x82EC5B58;
	sub_82CA93D0(ctx, base);
	// 82EC5B58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5B5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5B60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5B64: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5B68: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5B6C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5B70: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC5B74: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC5B78: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC5B7C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5B80: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC5B84: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC5B88: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5B8C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5B90: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC5B94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5B98: 4082FFF0  bne 0x82ec5b88
	if !ctx.cr[0].eq {
	pc = 0x82EC5B88; continue 'dispatch;
	}
	// 82EC5B9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5BA0: 4BFFFEE9  bl 0x82ec5a88
	ctx.lr = 0x82EC5BA4;
	sub_82EC5A88(ctx, base);
	// 82EC5BA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5BA8: 4082000C  bne 0x82ec5bb4
	if !ctx.cr[0].eq {
	pc = 0x82EC5BB4; continue 'dispatch;
	}
	// 82EC5BAC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5BB0: 48000010  b 0x82ec5bc0
	pc = 0x82EC5BC0; continue 'dispatch;
	// 82EC5BB4: 4BFF5A95  bl 0x82ebb648
	ctx.lr = 0x82EC5BB8;
	sub_82EBB648(ctx, base);
	// 82EC5BB8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5BBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5BC0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5BC4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5BC8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5BCC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5BD0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5BD4: 409A0010  bne cr6, 0x82ec5be4
	if !ctx.cr[6].eq {
	pc = 0x82EC5BE4; continue 'dispatch;
	}
	// 82EC5BD8: 4BFB9E81  bl 0x82e7fa58
	ctx.lr = 0x82EC5BDC;
	sub_82E7FA58(ctx, base);
	// 82EC5BDC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5BE0: 4800000C  b 0x82ec5bec
	pc = 0x82EC5BEC; continue 'dispatch;
	// 82EC5BE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5BE8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5BEC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5BF0: 41820018  beq 0x82ec5c08
	if ctx.cr[0].eq {
	pc = 0x82EC5C08; continue 'dispatch;
	}
	// 82EC5BF4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5BF8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5BFC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5C00: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5C04: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5C0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5C10: 4BDE3844  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5C18 size=68
    let mut pc: u32 = 0x82EC5C18;
    'dispatch: loop {
        match pc {
            0x82EC5C18 => {
    //   block [0x82EC5C18..0x82EC5C5C)
	// 82EC5C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5C24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5C28: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5C2C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5C30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5C34: 4BFFFF1D  bl 0x82ec5b50
	ctx.lr = 0x82EC5C38;
	sub_82EC5B50(ctx, base);
	// 82EC5C38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5C40: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC5C44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5C48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5C4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5C50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5C54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5C58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5C60 size=200
    let mut pc: u32 = 0x82EC5C60;
    'dispatch: loop {
        match pc {
            0x82EC5C60 => {
    //   block [0x82EC5C60..0x82EC5D28)
	// 82EC5C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5C68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5C6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5C74: 4BFF5A4D  bl 0x82ebb6c0
	ctx.lr = 0x82EC5C78;
	sub_82EBB6C0(ctx, base);
	// 82EC5C78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC5C7C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5C80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5C84: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5C88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5C8C: 40810054  ble 0x82ec5ce0
	if !ctx.cr[0].gt {
	pc = 0x82EC5CE0; continue 'dispatch;
	}
	// 82EC5C90: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC5C94: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5C98: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5C9C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5CA0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5CA4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5CA8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5CAC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5CB0: 41820014  beq 0x82ec5cc4
	if ctx.cr[0].eq {
	pc = 0x82EC5CC4; continue 'dispatch;
	}
	// 82EC5CB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5CB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5CBC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5CC0: 419AFFE0  beq cr6, 0x82ec5ca0
	if ctx.cr[6].eq {
	pc = 0x82EC5CA0; continue 'dispatch;
	}
	// 82EC5CC4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5CC8: 41820028  beq 0x82ec5cf0
	if ctx.cr[0].eq {
	pc = 0x82EC5CF0; continue 'dispatch;
	}
	// 82EC5CCC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5CD0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5CD4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5CD8: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5CDC: 4198FFB8  blt cr6, 0x82ec5c94
	if ctx.cr[6].lt {
	pc = 0x82EC5C94; continue 'dispatch;
	}
	// 82EC5CE0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5CE4: 409A0018  bne cr6, 0x82ec5cfc
	if !ctx.cr[6].eq {
	pc = 0x82EC5CFC; continue 'dispatch;
	}
	// 82EC5CE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5CEC: 48000028  b 0x82ec5d14
	pc = 0x82EC5D14; continue 'dispatch;
	// 82EC5CF0: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5CF4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5CF8: 48000018  b 0x82ec5d10
	pc = 0x82EC5D10; continue 'dispatch;
	// 82EC5CFC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5D00: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5D04: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5D08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5D0C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5D10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5D14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5D18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5D1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5D20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5D24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5D28 size=196
    let mut pc: u32 = 0x82EC5D28;
    'dispatch: loop {
        match pc {
            0x82EC5D28 => {
    //   block [0x82EC5D28..0x82EC5DEC)
	// 82EC5D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5D2C: 4BDE36D9  bl 0x82ca9404
	ctx.lr = 0x82EC5D30;
	sub_82CA93D0(ctx, base);
	// 82EC5D30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5D34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5D38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5D3C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5D40: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5D44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5D48: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC5D4C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC5D50: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC5D54: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5D58: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC5D5C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC5D60: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5D64: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5D68: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC5D6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5D70: 4082FFF0  bne 0x82ec5d60
	if !ctx.cr[0].eq {
	pc = 0x82EC5D60; continue 'dispatch;
	}
	// 82EC5D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5D78: 4BFFFEE9  bl 0x82ec5c60
	ctx.lr = 0x82EC5D7C;
	sub_82EC5C60(ctx, base);
	// 82EC5D7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5D80: 4082000C  bne 0x82ec5d8c
	if !ctx.cr[0].eq {
	pc = 0x82EC5D8C; continue 'dispatch;
	}
	// 82EC5D84: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5D88: 48000010  b 0x82ec5d98
	pc = 0x82EC5D98; continue 'dispatch;
	// 82EC5D8C: 4BFF5935  bl 0x82ebb6c0
	ctx.lr = 0x82EC5D90;
	sub_82EBB6C0(ctx, base);
	// 82EC5D90: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5D94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5D98: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5D9C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5DA0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5DA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5DA8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5DAC: 409A0010  bne cr6, 0x82ec5dbc
	if !ctx.cr[6].eq {
	pc = 0x82EC5DBC; continue 'dispatch;
	}
	// 82EC5DB0: 4BFB9CA9  bl 0x82e7fa58
	ctx.lr = 0x82EC5DB4;
	sub_82E7FA58(ctx, base);
	// 82EC5DB4: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5DB8: 4800000C  b 0x82ec5dc4
	pc = 0x82EC5DC4; continue 'dispatch;
	// 82EC5DBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5DC0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5DC4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5DC8: 41820018  beq 0x82ec5de0
	if ctx.cr[0].eq {
	pc = 0x82EC5DE0; continue 'dispatch;
	}
	// 82EC5DCC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5DD0: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5DD4: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5DD8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5DDC: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5DE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5DE8: 4BDE366C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5DF0 size=68
    let mut pc: u32 = 0x82EC5DF0;
    'dispatch: loop {
        match pc {
            0x82EC5DF0 => {
    //   block [0x82EC5DF0..0x82EC5E34)
	// 82EC5DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5DF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5DFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5E00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5E04: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5E08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5E0C: 4BFFFF1D  bl 0x82ec5d28
	ctx.lr = 0x82EC5E10;
	sub_82EC5D28(ctx, base);
	// 82EC5E10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5E18: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC5E1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5E20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5E24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5E28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5E38 size=200
    let mut pc: u32 = 0x82EC5E38;
    'dispatch: loop {
        match pc {
            0x82EC5E38 => {
    //   block [0x82EC5E38..0x82EC5F00)
	// 82EC5E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5E40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5E44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5E48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5E4C: 4BFF570D  bl 0x82ebb558
	ctx.lr = 0x82EC5E50;
	sub_82EBB558(ctx, base);
	// 82EC5E50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC5E54: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5E58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5E5C: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5E60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5E64: 40810054  ble 0x82ec5eb8
	if !ctx.cr[0].gt {
	pc = 0x82EC5EB8; continue 'dispatch;
	}
	// 82EC5E68: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC5E6C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5E70: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5E74: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5E78: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5E7C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5E80: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5E84: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5E88: 41820014  beq 0x82ec5e9c
	if ctx.cr[0].eq {
	pc = 0x82EC5E9C; continue 'dispatch;
	}
	// 82EC5E8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5E90: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5E94: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5E98: 419AFFE0  beq cr6, 0x82ec5e78
	if ctx.cr[6].eq {
	pc = 0x82EC5E78; continue 'dispatch;
	}
	// 82EC5E9C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5EA0: 41820028  beq 0x82ec5ec8
	if ctx.cr[0].eq {
	pc = 0x82EC5EC8; continue 'dispatch;
	}
	// 82EC5EA4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5EA8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5EAC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5EB0: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5EB4: 4198FFB8  blt cr6, 0x82ec5e6c
	if ctx.cr[6].lt {
	pc = 0x82EC5E6C; continue 'dispatch;
	}
	// 82EC5EB8: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5EBC: 409A0018  bne cr6, 0x82ec5ed4
	if !ctx.cr[6].eq {
	pc = 0x82EC5ED4; continue 'dispatch;
	}
	// 82EC5EC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5EC4: 48000028  b 0x82ec5eec
	pc = 0x82EC5EEC; continue 'dispatch;
	// 82EC5EC8: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5ECC: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5ED0: 48000018  b 0x82ec5ee8
	pc = 0x82EC5EE8; continue 'dispatch;
	// 82EC5ED4: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5ED8: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5EDC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5EE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5EE4: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5EE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5EEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5EF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5EF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5EF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5F00 size=196
    let mut pc: u32 = 0x82EC5F00;
    'dispatch: loop {
        match pc {
            0x82EC5F00 => {
    //   block [0x82EC5F00..0x82EC5FC4)
	// 82EC5F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5F04: 4BDE3501  bl 0x82ca9404
	ctx.lr = 0x82EC5F08;
	sub_82CA93D0(ctx, base);
	// 82EC5F08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5F0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5F10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5F14: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5F18: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5F1C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5F20: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC5F24: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC5F28: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC5F2C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5F30: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC5F34: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC5F38: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5F3C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5F40: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC5F44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5F48: 4082FFF0  bne 0x82ec5f38
	if !ctx.cr[0].eq {
	pc = 0x82EC5F38; continue 'dispatch;
	}
	// 82EC5F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5F50: 4BFFFEE9  bl 0x82ec5e38
	ctx.lr = 0x82EC5F54;
	sub_82EC5E38(ctx, base);
	// 82EC5F54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5F58: 4082000C  bne 0x82ec5f64
	if !ctx.cr[0].eq {
	pc = 0x82EC5F64; continue 'dispatch;
	}
	// 82EC5F5C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5F60: 48000010  b 0x82ec5f70
	pc = 0x82EC5F70; continue 'dispatch;
	// 82EC5F64: 4BFF55F5  bl 0x82ebb558
	ctx.lr = 0x82EC5F68;
	sub_82EBB558(ctx, base);
	// 82EC5F68: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5F6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5F70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5F74: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5F78: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5F7C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5F80: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5F84: 409A0010  bne cr6, 0x82ec5f94
	if !ctx.cr[6].eq {
	pc = 0x82EC5F94; continue 'dispatch;
	}
	// 82EC5F88: 4BFB9AD1  bl 0x82e7fa58
	ctx.lr = 0x82EC5F8C;
	sub_82E7FA58(ctx, base);
	// 82EC5F8C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5F90: 4800000C  b 0x82ec5f9c
	pc = 0x82EC5F9C; continue 'dispatch;
	// 82EC5F94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5F98: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5F9C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5FA0: 41820018  beq 0x82ec5fb8
	if ctx.cr[0].eq {
	pc = 0x82EC5FB8; continue 'dispatch;
	}
	// 82EC5FA4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5FA8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5FAC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5FB0: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5FB4: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5FBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5FC0: 4BDE3494  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5FC8 size=68
    let mut pc: u32 = 0x82EC5FC8;
    'dispatch: loop {
        match pc {
            0x82EC5FC8 => {
    //   block [0x82EC5FC8..0x82EC600C)
	// 82EC5FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5FD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5FD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5FD8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5FDC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5FE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5FE4: 4BFFFF1D  bl 0x82ec5f00
	ctx.lr = 0x82EC5FE8;
	sub_82EC5F00(ctx, base);
	// 82EC5FE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5FEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5FF0: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC5FF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5FF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6010 size=200
    let mut pc: u32 = 0x82EC6010;
    'dispatch: loop {
        match pc {
            0x82EC6010 => {
    //   block [0x82EC6010..0x82EC60D8)
	// 82EC6010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC601C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6024: 4BFF55AD  bl 0x82ebb5d0
	ctx.lr = 0x82EC6028;
	sub_82EBB5D0(ctx, base);
	// 82EC6028: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC602C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC6030: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC6034: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6038: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC603C: 40810054  ble 0x82ec6090
	if !ctx.cr[0].gt {
	pc = 0x82EC6090; continue 'dispatch;
	}
	// 82EC6040: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC6044: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6048: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC604C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC6050: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6054: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6058: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC605C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC6060: 41820014  beq 0x82ec6074
	if ctx.cr[0].eq {
	pc = 0x82EC6074; continue 'dispatch;
	}
	// 82EC6064: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6068: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC606C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC6070: 419AFFE0  beq cr6, 0x82ec6050
	if ctx.cr[6].eq {
	pc = 0x82EC6050; continue 'dispatch;
	}
	// 82EC6074: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6078: 41820028  beq 0x82ec60a0
	if ctx.cr[0].eq {
	pc = 0x82EC60A0; continue 'dispatch;
	}
	// 82EC607C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6080: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC6084: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6088: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC608C: 4198FFB8  blt cr6, 0x82ec6044
	if ctx.cr[6].lt {
	pc = 0x82EC6044; continue 'dispatch;
	}
	// 82EC6090: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC6094: 409A0018  bne cr6, 0x82ec60ac
	if !ctx.cr[6].eq {
	pc = 0x82EC60AC; continue 'dispatch;
	}
	// 82EC6098: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC609C: 48000028  b 0x82ec60c4
	pc = 0x82EC60C4; continue 'dispatch;
	// 82EC60A0: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC60A4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC60A8: 48000018  b 0x82ec60c0
	pc = 0x82EC60C0; continue 'dispatch;
	// 82EC60AC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC60B0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC60B4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC60B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC60BC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC60C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC60C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC60C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC60CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC60D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC60D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC60D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC60D8 size=196
    let mut pc: u32 = 0x82EC60D8;
    'dispatch: loop {
        match pc {
            0x82EC60D8 => {
    //   block [0x82EC60D8..0x82EC619C)
	// 82EC60D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC60DC: 4BDE3329  bl 0x82ca9404
	ctx.lr = 0x82EC60E0;
	sub_82CA93D0(ctx, base);
	// 82EC60E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC60E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC60E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC60EC: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC60F0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC60F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC60F8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC60FC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC6100: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC6104: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC6108: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC610C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC6110: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6114: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6118: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC611C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6120: 4082FFF0  bne 0x82ec6110
	if !ctx.cr[0].eq {
	pc = 0x82EC6110; continue 'dispatch;
	}
	// 82EC6124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6128: 4BFFFEE9  bl 0x82ec6010
	ctx.lr = 0x82EC612C;
	sub_82EC6010(ctx, base);
	// 82EC612C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6130: 4082000C  bne 0x82ec613c
	if !ctx.cr[0].eq {
	pc = 0x82EC613C; continue 'dispatch;
	}
	// 82EC6134: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC6138: 48000010  b 0x82ec6148
	pc = 0x82EC6148; continue 'dispatch;
	// 82EC613C: 4BFF5495  bl 0x82ebb5d0
	ctx.lr = 0x82EC6140;
	sub_82EBB5D0(ctx, base);
	// 82EC6140: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6144: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC6148: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC614C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC6150: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC6154: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC6158: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC615C: 409A0010  bne cr6, 0x82ec616c
	if !ctx.cr[6].eq {
	pc = 0x82EC616C; continue 'dispatch;
	}
	// 82EC6160: 4BFB98F9  bl 0x82e7fa58
	ctx.lr = 0x82EC6164;
	sub_82E7FA58(ctx, base);
	// 82EC6164: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC6168: 4800000C  b 0x82ec6174
	pc = 0x82EC6174; continue 'dispatch;
	// 82EC616C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6170: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC6174: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6178: 41820018  beq 0x82ec6190
	if ctx.cr[0].eq {
	pc = 0x82EC6190; continue 'dispatch;
	}
	// 82EC617C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6180: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC6184: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6188: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC618C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC6190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6194: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6198: 4BDE32BC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC61A0 size=68
    let mut pc: u32 = 0x82EC61A0;
    'dispatch: loop {
        match pc {
            0x82EC61A0 => {
    //   block [0x82EC61A0..0x82EC61E4)
	// 82EC61A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC61A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC61A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC61AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC61B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC61B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC61B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC61BC: 4BFFFF1D  bl 0x82ec60d8
	ctx.lr = 0x82EC61C0;
	sub_82EC60D8(ctx, base);
	// 82EC61C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC61C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC61C8: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC61CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC61D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC61D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC61D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC61DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC61E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC61E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC61E8 size=200
    let mut pc: u32 = 0x82EC61E8;
    'dispatch: loop {
        match pc {
            0x82EC61E8 => {
    //   block [0x82EC61E8..0x82EC62B0)
	// 82EC61E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC61EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC61F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC61F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC61F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC61FC: 4BFF52E5  bl 0x82ebb4e0
	ctx.lr = 0x82EC6200;
	sub_82EBB4E0(ctx, base);
	// 82EC6200: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC6204: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC6208: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC620C: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6210: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6214: 40810054  ble 0x82ec6268
	if !ctx.cr[0].gt {
	pc = 0x82EC6268; continue 'dispatch;
	}
	// 82EC6218: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC621C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6220: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC6224: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC6228: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC622C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6230: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6234: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC6238: 41820014  beq 0x82ec624c
	if ctx.cr[0].eq {
	pc = 0x82EC624C; continue 'dispatch;
	}
	// 82EC623C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6240: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC6244: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC6248: 419AFFE0  beq cr6, 0x82ec6228
	if ctx.cr[6].eq {
	pc = 0x82EC6228; continue 'dispatch;
	}
	// 82EC624C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6250: 41820028  beq 0x82ec6278
	if ctx.cr[0].eq {
	pc = 0x82EC6278; continue 'dispatch;
	}
	// 82EC6254: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6258: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC625C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6260: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC6264: 4198FFB8  blt cr6, 0x82ec621c
	if ctx.cr[6].lt {
	pc = 0x82EC621C; continue 'dispatch;
	}
	// 82EC6268: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC626C: 409A0018  bne cr6, 0x82ec6284
	if !ctx.cr[6].eq {
	pc = 0x82EC6284; continue 'dispatch;
	}
	// 82EC6270: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6274: 48000028  b 0x82ec629c
	pc = 0x82EC629C; continue 'dispatch;
	// 82EC6278: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC627C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6280: 48000018  b 0x82ec6298
	pc = 0x82EC6298; continue 'dispatch;
	// 82EC6284: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6288: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC628C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6290: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6294: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC6298: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC629C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC62A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC62A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC62A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC62AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC62B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC62B0 size=196
    let mut pc: u32 = 0x82EC62B0;
    'dispatch: loop {
        match pc {
            0x82EC62B0 => {
    //   block [0x82EC62B0..0x82EC6374)
	// 82EC62B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC62B4: 4BDE3151  bl 0x82ca9404
	ctx.lr = 0x82EC62B8;
	sub_82CA93D0(ctx, base);
	// 82EC62B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC62BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC62C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC62C4: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC62C8: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC62CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC62D0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC62D4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC62D8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC62DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC62E0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC62E4: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC62E8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC62EC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC62F0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC62F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC62F8: 4082FFF0  bne 0x82ec62e8
	if !ctx.cr[0].eq {
	pc = 0x82EC62E8; continue 'dispatch;
	}
	// 82EC62FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6300: 4BFFFEE9  bl 0x82ec61e8
	ctx.lr = 0x82EC6304;
	sub_82EC61E8(ctx, base);
	// 82EC6304: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6308: 4082000C  bne 0x82ec6314
	if !ctx.cr[0].eq {
	pc = 0x82EC6314; continue 'dispatch;
	}
	// 82EC630C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC6310: 48000010  b 0x82ec6320
	pc = 0x82EC6320; continue 'dispatch;
	// 82EC6314: 4BFF51CD  bl 0x82ebb4e0
	ctx.lr = 0x82EC6318;
	sub_82EBB4E0(ctx, base);
	// 82EC6318: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC631C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC6320: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC6324: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC6328: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC632C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC6330: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC6334: 409A0010  bne cr6, 0x82ec6344
	if !ctx.cr[6].eq {
	pc = 0x82EC6344; continue 'dispatch;
	}
	// 82EC6338: 4BFB9721  bl 0x82e7fa58
	ctx.lr = 0x82EC633C;
	sub_82E7FA58(ctx, base);
	// 82EC633C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC6340: 4800000C  b 0x82ec634c
	pc = 0x82EC634C; continue 'dispatch;
	// 82EC6344: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6348: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC634C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6350: 41820018  beq 0x82ec6368
	if ctx.cr[0].eq {
	pc = 0x82EC6368; continue 'dispatch;
	}
	// 82EC6354: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6358: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC635C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6360: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC6364: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC6368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC636C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6370: 4BDE30E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6378 size=68
    let mut pc: u32 = 0x82EC6378;
    'dispatch: loop {
        match pc {
            0x82EC6378 => {
    //   block [0x82EC6378..0x82EC63BC)
	// 82EC6378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC637C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6384: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6388: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC638C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6394: 4BFFFF1D  bl 0x82ec62b0
	ctx.lr = 0x82EC6398;
	sub_82EC62B0(ctx, base);
	// 82EC6398: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC639C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC63A0: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC63A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC63A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC63AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC63B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC63B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC63B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC63C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC63C0 size=200
    let mut pc: u32 = 0x82EC63C0;
    'dispatch: loop {
        match pc {
            0x82EC63C0 => {
    //   block [0x82EC63C0..0x82EC6488)
	// 82EC63C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC63C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC63C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC63CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC63D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC63D4: 4BFF5095  bl 0x82ebb468
	ctx.lr = 0x82EC63D8;
	sub_82EBB468(ctx, base);
	// 82EC63D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC63DC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC63E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC63E4: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC63E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC63EC: 40810054  ble 0x82ec6440
	if !ctx.cr[0].gt {
	pc = 0x82EC6440; continue 'dispatch;
	}
	// 82EC63F0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC63F4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC63F8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC63FC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC6400: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6404: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6408: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC640C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC6410: 41820014  beq 0x82ec6424
	if ctx.cr[0].eq {
	pc = 0x82EC6424; continue 'dispatch;
	}
	// 82EC6414: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6418: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC641C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC6420: 419AFFE0  beq cr6, 0x82ec6400
	if ctx.cr[6].eq {
	pc = 0x82EC6400; continue 'dispatch;
	}
	// 82EC6424: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6428: 41820028  beq 0x82ec6450
	if ctx.cr[0].eq {
	pc = 0x82EC6450; continue 'dispatch;
	}
	// 82EC642C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6430: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC6434: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6438: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC643C: 4198FFB8  blt cr6, 0x82ec63f4
	if ctx.cr[6].lt {
	pc = 0x82EC63F4; continue 'dispatch;
	}
	// 82EC6440: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC6444: 409A0018  bne cr6, 0x82ec645c
	if !ctx.cr[6].eq {
	pc = 0x82EC645C; continue 'dispatch;
	}
	// 82EC6448: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC644C: 48000028  b 0x82ec6474
	pc = 0x82EC6474; continue 'dispatch;
	// 82EC6450: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6454: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6458: 48000018  b 0x82ec6470
	pc = 0x82EC6470; continue 'dispatch;
	// 82EC645C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6460: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6464: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6468: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC646C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC6470: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC6474: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC647C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6480: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6488 size=196
    let mut pc: u32 = 0x82EC6488;
    'dispatch: loop {
        match pc {
            0x82EC6488 => {
    //   block [0x82EC6488..0x82EC654C)
	// 82EC6488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC648C: 4BDE2F79  bl 0x82ca9404
	ctx.lr = 0x82EC6490;
	sub_82CA93D0(ctx, base);
	// 82EC6490: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6494: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC649C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC64A0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC64A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC64A8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC64AC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC64B0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC64B4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC64B8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC64BC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC64C0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC64C4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC64C8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC64CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC64D0: 4082FFF0  bne 0x82ec64c0
	if !ctx.cr[0].eq {
	pc = 0x82EC64C0; continue 'dispatch;
	}
	// 82EC64D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC64D8: 4BFFFEE9  bl 0x82ec63c0
	ctx.lr = 0x82EC64DC;
	sub_82EC63C0(ctx, base);
	// 82EC64DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC64E0: 4082000C  bne 0x82ec64ec
	if !ctx.cr[0].eq {
	pc = 0x82EC64EC; continue 'dispatch;
	}
	// 82EC64E4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC64E8: 48000010  b 0x82ec64f8
	pc = 0x82EC64F8; continue 'dispatch;
	// 82EC64EC: 4BFF4F7D  bl 0x82ebb468
	ctx.lr = 0x82EC64F0;
	sub_82EBB468(ctx, base);
	// 82EC64F0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC64F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC64F8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC64FC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC6500: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC6504: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC6508: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC650C: 409A0010  bne cr6, 0x82ec651c
	if !ctx.cr[6].eq {
	pc = 0x82EC651C; continue 'dispatch;
	}
	// 82EC6510: 4BFB9549  bl 0x82e7fa58
	ctx.lr = 0x82EC6514;
	sub_82E7FA58(ctx, base);
	// 82EC6514: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC6518: 4800000C  b 0x82ec6524
	pc = 0x82EC6524; continue 'dispatch;
	// 82EC651C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6520: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC6524: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6528: 41820018  beq 0x82ec6540
	if ctx.cr[0].eq {
	pc = 0x82EC6540; continue 'dispatch;
	}
	// 82EC652C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6530: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC6534: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6538: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC653C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC6540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6544: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6548: 4BDE2F0C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6550 size=68
    let mut pc: u32 = 0x82EC6550;
    'dispatch: loop {
        match pc {
            0x82EC6550 => {
    //   block [0x82EC6550..0x82EC6594)
	// 82EC6550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6558: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC655C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6560: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC6564: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC656C: 4BFFFF1D  bl 0x82ec6488
	ctx.lr = 0x82EC6570;
	sub_82EC6488(ctx, base);
	// 82EC6570: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6578: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC657C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC658C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6598 size=200
    let mut pc: u32 = 0x82EC6598;
    'dispatch: loop {
        match pc {
            0x82EC6598 => {
    //   block [0x82EC6598..0x82EC6660)
	// 82EC6598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC659C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC65A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC65A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC65A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC65AC: 4BFF4E45  bl 0x82ebb3f0
	ctx.lr = 0x82EC65B0;
	sub_82EBB3F0(ctx, base);
	// 82EC65B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC65B4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC65B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC65BC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC65C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC65C4: 40810054  ble 0x82ec6618
	if !ctx.cr[0].gt {
	pc = 0x82EC6618; continue 'dispatch;
	}
	// 82EC65C8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC65CC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC65D0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC65D4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC65D8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC65DC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC65E0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC65E4: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC65E8: 41820014  beq 0x82ec65fc
	if ctx.cr[0].eq {
	pc = 0x82EC65FC; continue 'dispatch;
	}
	// 82EC65EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC65F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC65F4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC65F8: 419AFFE0  beq cr6, 0x82ec65d8
	if ctx.cr[6].eq {
	pc = 0x82EC65D8; continue 'dispatch;
	}
	// 82EC65FC: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6600: 41820028  beq 0x82ec6628
	if ctx.cr[0].eq {
	pc = 0x82EC6628; continue 'dispatch;
	}
	// 82EC6604: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6608: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC660C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6610: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC6614: 4198FFB8  blt cr6, 0x82ec65cc
	if ctx.cr[6].lt {
	pc = 0x82EC65CC; continue 'dispatch;
	}
	// 82EC6618: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC661C: 409A0018  bne cr6, 0x82ec6634
	if !ctx.cr[6].eq {
	pc = 0x82EC6634; continue 'dispatch;
	}
	// 82EC6620: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6624: 48000028  b 0x82ec664c
	pc = 0x82EC664C; continue 'dispatch;
	// 82EC6628: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC662C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6630: 48000018  b 0x82ec6648
	pc = 0x82EC6648; continue 'dispatch;
	// 82EC6634: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6638: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC663C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6640: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6644: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC6648: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC664C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6658: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC665C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6660 size=196
    let mut pc: u32 = 0x82EC6660;
    'dispatch: loop {
        match pc {
            0x82EC6660 => {
    //   block [0x82EC6660..0x82EC6724)
	// 82EC6660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6664: 4BDE2DA1  bl 0x82ca9404
	ctx.lr = 0x82EC6668;
	sub_82CA93D0(ctx, base);
	// 82EC6668: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC666C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6670: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6674: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC6678: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC667C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC6680: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC6684: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC6688: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC668C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC6690: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC6694: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC6698: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC669C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC66A0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC66A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC66A8: 4082FFF0  bne 0x82ec6698
	if !ctx.cr[0].eq {
	pc = 0x82EC6698; continue 'dispatch;
	}
	// 82EC66AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC66B0: 4BFFFEE9  bl 0x82ec6598
	ctx.lr = 0x82EC66B4;
	sub_82EC6598(ctx, base);
	// 82EC66B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC66B8: 4082000C  bne 0x82ec66c4
	if !ctx.cr[0].eq {
	pc = 0x82EC66C4; continue 'dispatch;
	}
	// 82EC66BC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC66C0: 48000010  b 0x82ec66d0
	pc = 0x82EC66D0; continue 'dispatch;
	// 82EC66C4: 4BFF4D2D  bl 0x82ebb3f0
	ctx.lr = 0x82EC66C8;
	sub_82EBB3F0(ctx, base);
	// 82EC66C8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC66CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC66D0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC66D4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC66D8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC66DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC66E0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC66E4: 409A0010  bne cr6, 0x82ec66f4
	if !ctx.cr[6].eq {
	pc = 0x82EC66F4; continue 'dispatch;
	}
	// 82EC66E8: 4BFB9371  bl 0x82e7fa58
	ctx.lr = 0x82EC66EC;
	sub_82E7FA58(ctx, base);
	// 82EC66EC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC66F0: 4800000C  b 0x82ec66fc
	pc = 0x82EC66FC; continue 'dispatch;
	// 82EC66F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC66F8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC66FC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6700: 41820018  beq 0x82ec6718
	if ctx.cr[0].eq {
	pc = 0x82EC6718; continue 'dispatch;
	}
	// 82EC6704: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6708: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC670C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6710: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC6714: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC6718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC671C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6720: 4BDE2D34  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6728 size=68
    let mut pc: u32 = 0x82EC6728;
    'dispatch: loop {
        match pc {
            0x82EC6728 => {
    //   block [0x82EC6728..0x82EC676C)
	// 82EC6728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC672C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6734: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6738: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC673C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6744: 4BFFFF1D  bl 0x82ec6660
	ctx.lr = 0x82EC6748;
	sub_82EC6660(ctx, base);
	// 82EC6748: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC674C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6750: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC6754: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC675C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6770 size=200
    let mut pc: u32 = 0x82EC6770;
    'dispatch: loop {
        match pc {
            0x82EC6770 => {
    //   block [0x82EC6770..0x82EC6838)
	// 82EC6770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC677C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6784: 4BFF4BF5  bl 0x82ebb378
	ctx.lr = 0x82EC6788;
	sub_82EBB378(ctx, base);
	// 82EC6788: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC678C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC6790: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC6794: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6798: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC679C: 40810054  ble 0x82ec67f0
	if !ctx.cr[0].gt {
	pc = 0x82EC67F0; continue 'dispatch;
	}
	// 82EC67A0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC67A4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC67A8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC67AC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC67B0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC67B4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC67B8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC67BC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC67C0: 41820014  beq 0x82ec67d4
	if ctx.cr[0].eq {
	pc = 0x82EC67D4; continue 'dispatch;
	}
	// 82EC67C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC67C8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC67CC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC67D0: 419AFFE0  beq cr6, 0x82ec67b0
	if ctx.cr[6].eq {
	pc = 0x82EC67B0; continue 'dispatch;
	}
	// 82EC67D4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC67D8: 41820028  beq 0x82ec6800
	if ctx.cr[0].eq {
	pc = 0x82EC6800; continue 'dispatch;
	}
	// 82EC67DC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC67E0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC67E4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC67E8: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC67EC: 4198FFB8  blt cr6, 0x82ec67a4
	if ctx.cr[6].lt {
	pc = 0x82EC67A4; continue 'dispatch;
	}
	// 82EC67F0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC67F4: 409A0018  bne cr6, 0x82ec680c
	if !ctx.cr[6].eq {
	pc = 0x82EC680C; continue 'dispatch;
	}
	// 82EC67F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC67FC: 48000028  b 0x82ec6824
	pc = 0x82EC6824; continue 'dispatch;
	// 82EC6800: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6804: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6808: 48000018  b 0x82ec6820
	pc = 0x82EC6820; continue 'dispatch;
	// 82EC680C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6810: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6814: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6818: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC681C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC6820: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC6824: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC682C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6838 size=196
    let mut pc: u32 = 0x82EC6838;
    'dispatch: loop {
        match pc {
            0x82EC6838 => {
    //   block [0x82EC6838..0x82EC68FC)
	// 82EC6838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC683C: 4BDE2BC9  bl 0x82ca9404
	ctx.lr = 0x82EC6840;
	sub_82CA93D0(ctx, base);
	// 82EC6840: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6844: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6848: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC684C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC6850: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC6854: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC6858: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC685C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC6860: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC6864: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC6868: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC686C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC6870: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6874: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6878: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC687C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6880: 4082FFF0  bne 0x82ec6870
	if !ctx.cr[0].eq {
	pc = 0x82EC6870; continue 'dispatch;
	}
	// 82EC6884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6888: 4BFFFEE9  bl 0x82ec6770
	ctx.lr = 0x82EC688C;
	sub_82EC6770(ctx, base);
	// 82EC688C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6890: 4082000C  bne 0x82ec689c
	if !ctx.cr[0].eq {
	pc = 0x82EC689C; continue 'dispatch;
	}
	// 82EC6894: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC6898: 48000010  b 0x82ec68a8
	pc = 0x82EC68A8; continue 'dispatch;
	// 82EC689C: 4BFF4ADD  bl 0x82ebb378
	ctx.lr = 0x82EC68A0;
	sub_82EBB378(ctx, base);
	// 82EC68A0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC68A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC68A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC68AC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC68B0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC68B4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC68B8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC68BC: 409A0010  bne cr6, 0x82ec68cc
	if !ctx.cr[6].eq {
	pc = 0x82EC68CC; continue 'dispatch;
	}
	// 82EC68C0: 4BFB9199  bl 0x82e7fa58
	ctx.lr = 0x82EC68C4;
	sub_82E7FA58(ctx, base);
	// 82EC68C4: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC68C8: 4800000C  b 0x82ec68d4
	pc = 0x82EC68D4; continue 'dispatch;
	// 82EC68CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC68D0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC68D4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC68D8: 41820018  beq 0x82ec68f0
	if ctx.cr[0].eq {
	pc = 0x82EC68F0; continue 'dispatch;
	}
	// 82EC68DC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC68E0: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC68E4: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC68E8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC68EC: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC68F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC68F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC68F8: 4BDE2B5C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6900 size=68
    let mut pc: u32 = 0x82EC6900;
    'dispatch: loop {
        match pc {
            0x82EC6900 => {
    //   block [0x82EC6900..0x82EC6944)
	// 82EC6900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC690C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6910: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC6914: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC691C: 4BFFFF1D  bl 0x82ec6838
	ctx.lr = 0x82EC6920;
	sub_82EC6838(ctx, base);
	// 82EC6920: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6928: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC692C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6930: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6934: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6938: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC693C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC6948 size=264
    let mut pc: u32 = 0x82EC6948;
    'dispatch: loop {
        match pc {
            0x82EC6948 => {
    //   block [0x82EC6948..0x82EC6A50)
	// 82EC6948: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC694C: 396BEF78  addi r11, r11, -0x1088
	ctx.r[11].s64 = ctx.r[11].s64 + -4232;
	// 82EC6950: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6954: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6958: 419A00F8  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC695C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6960: 396BE4AC  addi r11, r11, -0x1b54
	ctx.r[11].s64 = ctx.r[11].s64 + -6996;
	// 82EC6964: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6968: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC696C: 419A00E4  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC6970: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6974: 396BE6D4  addi r11, r11, -0x192c
	ctx.r[11].s64 = ctx.r[11].s64 + -6444;
	// 82EC6978: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC697C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6980: 419A00D0  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC6984: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6988: 396BE5C0  addi r11, r11, -0x1a40
	ctx.r[11].s64 = ctx.r[11].s64 + -6720;
	// 82EC698C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6990: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6994: 419A00BC  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC6998: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC699C: 396BE7E8  addi r11, r11, -0x1818
	ctx.r[11].s64 = ctx.r[11].s64 + -6168;
	// 82EC69A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69A4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69A8: 419A00A8  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC69AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC69B0: 396BE284  addi r11, r11, -0x1d7c
	ctx.r[11].s64 = ctx.r[11].s64 + -7548;
	// 82EC69B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69B8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69BC: 419A0094  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC69C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC69C4: 396BE398  addi r11, r11, -0x1c68
	ctx.r[11].s64 = ctx.r[11].s64 + -7272;
	// 82EC69C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69CC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69D0: 419A0080  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC69D4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC69D8: 396BEE60  addi r11, r11, -0x11a0
	ctx.r[11].s64 = ctx.r[11].s64 + -4512;
	// 82EC69DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69E0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69E4: 419A006C  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC69E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC69EC: 396BED4C  addi r11, r11, -0x12b4
	ctx.r[11].s64 = ctx.r[11].s64 + -4788;
	// 82EC69F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC69F4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC69F8: 419A0058  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC69FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6A00: 396BEC38  addi r11, r11, -0x13c8
	ctx.r[11].s64 = ctx.r[11].s64 + -5064;
	// 82EC6A04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6A08: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6A0C: 419A0044  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC6A10: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6A14: 396BEB24  addi r11, r11, -0x14dc
	ctx.r[11].s64 = ctx.r[11].s64 + -5340;
	// 82EC6A18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6A1C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6A20: 419A0030  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC6A24: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6A28: 396BEA10  addi r11, r11, -0x15f0
	ctx.r[11].s64 = ctx.r[11].s64 + -5616;
	// 82EC6A2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6A30: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6A34: 419A001C  beq cr6, 0x82ec6a50
	if ctx.cr[6].eq {
		sub_82EC6A50(ctx, base);
		return;
	}
	// 82EC6A38: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC6A3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC6A40: 396BE8FC  addi r11, r11, -0x1704
	ctx.r[11].s64 = ctx.r[11].s64 + -5892;
	// 82EC6A44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6A48: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC6A4C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC6A50 size=8
    let mut pc: u32 = 0x82EC6A50;
    'dispatch: loop {
        match pc {
            0x82EC6A50 => {
    //   block [0x82EC6A50..0x82EC6A58)
	// 82EC6A50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6A54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6A58 size=100
    let mut pc: u32 = 0x82EC6A58;
    'dispatch: loop {
        match pc {
            0x82EC6A58 => {
    //   block [0x82EC6A58..0x82EC6ABC)
	// 82EC6A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6A60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6A64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6A6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6A70: 396BB264  addi r11, r11, -0x4d9c
	ctx.r[11].s64 = ctx.r[11].s64 + -19868;
	// 82EC6A74: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6A78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6A7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6A80: 41820018  beq 0x82ec6a98
	if ctx.cr[0].eq {
	pc = 0x82EC6A98; continue 'dispatch;
	}
	// 82EC6A84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6A88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC6A8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6A90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC6A94: 4E800421  bctrl
	ctx.lr = 0x82EC6A98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC6A98: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82EC6A9C: 4BFF28E5  bl 0x82eb9380
	ctx.lr = 0x82EC6AA0;
	sub_82EB9380(ctx, base);
	// 82EC6AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6AA4: 4BFBFC55  bl 0x82e866f8
	ctx.lr = 0x82EC6AA8;
	sub_82E866F8(ctx, base);
	// 82EC6AA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6AAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6AB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6AB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6AB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6AC0 size=120
    let mut pc: u32 = 0x82EC6AC0;
    'dispatch: loop {
        match pc {
            0x82EC6AC0 => {
    //   block [0x82EC6AC0..0x82EC6B38)
	// 82EC6AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6AC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC6ACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6AD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6AD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC6AD8: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6ADC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6AE0: 41820040  beq 0x82ec6b20
	if ctx.cr[0].eq {
	pc = 0x82EC6B20; continue 'dispatch;
	}
	// 82EC6AE4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6AE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EC6AEC: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC6AF0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC6AF4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC6AF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC6AFC: 40990024  ble cr6, 0x82ec6b20
	if !ctx.cr[6].gt {
	pc = 0x82EC6B20; continue 'dispatch;
	}
	// 82EC6B00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC6B04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC6B08: 4BFC25F1  bl 0x82e890f8
	ctx.lr = 0x82EC6B0C;
	sub_82E890F8(ctx, base);
	// 82EC6B0C: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6B10: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EC6B14: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC6B18: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC6B1C: 4198FFE4  blt cr6, 0x82ec6b00
	if ctx.cr[6].lt {
	pc = 0x82EC6B00; continue 'dispatch;
	}
	// 82EC6B20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6B2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC6B30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6B34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6B38 size=88
    let mut pc: u32 = 0x82EC6B38;
    'dispatch: loop {
        match pc {
            0x82EC6B38 => {
    //   block [0x82EC6B38..0x82EC6B90)
	// 82EC6B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6B40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC6B44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6B4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6B50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC6B54: 4BFFFF05  bl 0x82ec6a58
	ctx.lr = 0x82EC6B58;
	sub_82EC6A58(ctx, base);
	// 82EC6B58: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6B5C: 41820018  beq 0x82ec6b74
	if ctx.cr[0].eq {
	pc = 0x82EC6B74; continue 'dispatch;
	}
	// 82EC6B60: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6B68: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC6B6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC6B70: 4E800421  bctrl
	ctx.lr = 0x82EC6B74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC6B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6B78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6B7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6B80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6B84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC6B88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6B90 size=120
    let mut pc: u32 = 0x82EC6B90;
    'dispatch: loop {
        match pc {
            0x82EC6B90 => {
    //   block [0x82EC6B90..0x82EC6C08)
	// 82EC6B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6B94: 4BDE2879  bl 0x82ca940c
	ctx.lr = 0x82EC6B98;
	sub_82CA93D0(ctx, base);
	// 82EC6B98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6B9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6BA0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC6BA4: 4BFBFA35  bl 0x82e865d8
	ctx.lr = 0x82EC6BA8;
	sub_82E865D8(ctx, base);
	// 82EC6BA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6BAC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EC6BB0: 396BB264  addi r11, r11, -0x4d9c
	ctx.r[11].s64 = ctx.r[11].s64 + -19868;
	// 82EC6BB4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC6BB8: 394AA8F0  addi r10, r10, -0x5710
	ctx.r[10].s64 = ctx.r[10].s64 + -22288;
	// 82EC6BBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC6BC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6BC4: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EC6BC8: 915F0054  stw r10, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EC6BCC: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EC6BD0: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82EC6BD4: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EC6BD8: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EC6BDC: 83BD00AC  lwz r29, 0xac(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EC6BE0: 4B74FD49  bl 0x82616928
	ctx.lr = 0x82EC6BE4;
	sub_82616928(ctx, base);
	// 82EC6BE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6BE8: 41820010  beq 0x82ec6bf8
	if ctx.cr[0].eq {
	pc = 0x82EC6BF8; continue 'dispatch;
	}
	// 82EC6BEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC6BF0: 4BFC2379  bl 0x82e88f68
	ctx.lr = 0x82EC6BF4;
	sub_82E88F68(ctx, base);
	// 82EC6BF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC6BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6BFC: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82EC6C00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6C04: 4BDE2858  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6C08 size=204
    let mut pc: u32 = 0x82EC6C08;
    'dispatch: loop {
        match pc {
            0x82EC6C08 => {
    //   block [0x82EC6C08..0x82EC6CD4)
	// 82EC6C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6C10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6C14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6C18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6C1C: 4BFFFF75  bl 0x82ec6b90
	ctx.lr = 0x82EC6C20;
	sub_82EC6B90(ctx, base);
	// 82EC6C20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6C24: 395F0084  addi r10, r31, 0x84
	ctx.r[10].s64 = ctx.r[31].s64 + 132;
	// 82EC6C28: 38EBB298  addi r7, r11, -0x4d68
	ctx.r[7].s64 = ctx.r[11].s64 + -19816;
	// 82EC6C2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6C30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC6C34: 38CBA8F0  addi r6, r11, -0x5710
	ctx.r[6].s64 = ctx.r[11].s64 + -22288;
	// 82EC6C38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC6C3C: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC6C40: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82EC6C44: 390B9128  addi r8, r11, -0x6ed8
	ctx.r[8].s64 = ctx.r[11].s64 + -28376;
	// 82EC6C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6C4C: 393F00AC  addi r9, r31, 0xac
	ctx.r[9].s64 = ctx.r[31].s64 + 172;
	// 82EC6C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6C54: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EC6C58: 90DF0074  stw r6, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[6].u32 ) };
	// 82EC6C5C: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EC6C60: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EC6C64: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EC6C68: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC6C6C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC6C70: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC6C74: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC6C78: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC6C7C: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC6C80: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC6C84: 98AA001C  stb r5, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 82EC6C88: 90EA0020  stw r7, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC6C8C: 916A0024  stw r11, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC6C90: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC6C94: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC6C98: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC6C9C: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC6CA0: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC6CA4: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC6CA8: 91690018  stw r11, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC6CAC: 98A9001C  stb r5, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 82EC6CB0: 90E90020  stw r7, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC6CB4: 91690024  stw r11, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC6CB8: 93FF00A8  stw r31, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 82EC6CBC: 93FF00D0  stw r31, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 82EC6CC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6CC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6CC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6CCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6CD8 size=312
    let mut pc: u32 = 0x82EC6CD8;
    'dispatch: loop {
        match pc {
            0x82EC6CD8 => {
    //   block [0x82EC6CD8..0x82EC6E10)
	// 82EC6CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6CE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC6CE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6CE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6CEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC6CF0: 548B077F  clrlwi. r11, r4, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6CF4: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82EC6CF8: 4182000C  beq 0x82ec6d04
	if ctx.cr[0].eq {
	pc = 0x82EC6D04; continue 'dispatch;
	}
	// 82EC6CFC: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82EC6D00: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 82EC6D04: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6D08: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82EC6D0C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82EC6D10: 409A0014  bne cr6, 0x82ec6d24
	if !ctx.cr[6].eq {
	pc = 0x82EC6D24; continue 'dispatch;
	}
	// 82EC6D14: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC6D18: 419A0038  beq cr6, 0x82ec6d50
	if ctx.cr[6].eq {
	pc = 0x82EC6D50; continue 'dispatch;
	}
	// 82EC6D1C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EC6D20: 48000030  b 0x82ec6d50
	pc = 0x82EC6D50; continue 'dispatch;
	// 82EC6D24: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82EC6D28: 409A0028  bne cr6, 0x82ec6d50
	if !ctx.cr[6].eq {
	pc = 0x82EC6D50; continue 'dispatch;
	}
	// 82EC6D2C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC6D30: 40990020  ble cr6, 0x82ec6d50
	if !ctx.cr[6].gt {
	pc = 0x82EC6D50; continue 'dispatch;
	}
	// 82EC6D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC6D38: 409A0010  bne cr6, 0x82ec6d48
	if !ctx.cr[6].eq {
	pc = 0x82EC6D48; continue 'dispatch;
	}
	// 82EC6D3C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EC6D40: 48000008  b 0x82ec6d48
	pc = 0x82EC6D48; continue 'dispatch;
	// 82EC6D44: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC6D48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC6D4C: 4198FFF8  blt cr6, 0x82ec6d44
	if ctx.cr[6].lt {
	pc = 0x82EC6D44; continue 'dispatch;
	}
	// 82EC6D50: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC6D54: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC6D58: 4099000C  ble cr6, 0x82ec6d64
	if !ctx.cr[6].gt {
	pc = 0x82EC6D64; continue 'dispatch;
	}
	// 82EC6D5C: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC6D60: 48000008  b 0x82ec6d68
	pc = 0x82EC6D68; continue 'dispatch;
	// 82EC6D64: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EC6D68: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC6D6C: 419A0078  beq cr6, 0x82ec6de4
	if ctx.cr[6].eq {
	pc = 0x82EC6DE4; continue 'dispatch;
	}
	// 82EC6D70: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC6D74: 41980008  blt cr6, 0x82ec6d7c
	if ctx.cr[6].lt {
	pc = 0x82EC6D7C; continue 'dispatch;
	}
	// 82EC6D78: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82EC6D7C: 5563E8FE  srwi r3, r11, 3
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EC6D80: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC6D84: 4B74FBA5  bl 0x82616928
	ctx.lr = 0x82EC6D88;
	sub_82616928(ctx, base);
	// 82EC6D88: 57EB077E  clrlwi r11, r31, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000007u64;
	// 82EC6D8C: 57E9E8FE  srwi r9, r31, 3
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC6D90: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC6D94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6D98: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC6D9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6DA0: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	// 82EC6DA4: 7D4A4A15  add. r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC6DA8: 4182001C  beq 0x82ec6dc4
	if ctx.cr[0].eq {
	pc = 0x82EC6DC4; continue 'dispatch;
	}
	// 82EC6DAC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6DB0: 7D2958AE  lbzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC6DB4: 7D2BF9AE  stbx r9, r11, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u8) };
	// 82EC6DB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6DBC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC6DC0: 4198FFEC  blt cr6, 0x82ec6dac
	if ctx.cr[6].lt {
	pc = 0x82EC6DAC; continue 'dispatch;
	}
	// 82EC6DC4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6DC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6DCC: 41820014  beq 0x82ec6de0
	if ctx.cr[0].eq {
	pc = 0x82EC6DE0; continue 'dispatch;
	}
	// 82EC6DD0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6DD4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC6DD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC6DDC: 4E800421  bctrl
	ctx.lr = 0x82EC6DE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC6DE0: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82EC6DE4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC6DE8: 556AE8FE  srwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6DEC: 556B077E  clrlwi r11, r11, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 82EC6DF0: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EC6DF4: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EC6DF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6E04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC6E08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6E10 size=172
    let mut pc: u32 = 0x82EC6E10;
    'dispatch: loop {
        match pc {
            0x82EC6E10 => {
    //   block [0x82EC6E10..0x82EC6EBC)
	// 82EC6E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6E18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC6E1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6E20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6E24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6E28: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC6E2C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6E30: 4182000C  beq 0x82ec6e3c
	if ctx.cr[0].eq {
	pc = 0x82EC6E3C; continue 'dispatch;
	}
	// 82EC6E34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6E38: 4800006C  b 0x82ec6ea4
	pc = 0x82EC6EA4; continue 'dispatch;
	// 82EC6E3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC6E40: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC6E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC6E48: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EC6E4C: 40990030  ble cr6, 0x82ec6e7c
	if !ctx.cr[6].gt {
	pc = 0x82EC6E7C; continue 'dispatch;
	}
	// 82EC6E50: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC6E54: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6E58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6E5C: 811F0070  lwz r8, 0x70(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC6E60: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC6E64: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC6E68: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC6E6C: 913F0070  stw r9, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82EC6E70: 813F0080  lwz r9, 0x80(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC6E74: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC6E78: 4198FFDC  blt cr6, 0x82ec6e54
	if ctx.cr[6].lt {
	pc = 0x82EC6E54; continue 'dispatch;
	}
	// 82EC6E7C: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC6E80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC6E84: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82EC6E88: 7FCB21D6  mullw r30, r11, r4
	ctx.r[30].s64 = (ctx.r[11].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82EC6E8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC6E90: 4BFFFE49  bl 0x82ec6cd8
	ctx.lr = 0x82EC6E94;
	sub_82EC6CD8(ctx, base);
	// 82EC6E94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC6E98: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6E9C: 4BFC214D  bl 0x82e88fe8
	ctx.lr = 0x82EC6EA0;
	sub_82E88FE8(ctx, base);
	// 82EC6EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC6EA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC6EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6EB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC6EB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6EB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC6EC0 size=68
    let mut pc: u32 = 0x82EC6EC0;
    'dispatch: loop {
        match pc {
            0x82EC6EC0 => {
    //   block [0x82EC6EC0..0x82EC6F04)
	// 82EC6EC0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6EC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC6EC8: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC6ECC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6ED0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6ED4: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC6ED8: 41820024  beq 0x82ec6efc
	if ctx.cr[0].eq {
	pc = 0x82EC6EFC; continue 'dispatch;
	}
	// 82EC6EDC: 81430078  lwz r10, 0x78(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC6EE0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6EE4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6EE8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC6EEC: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6EF0: 81080014  lwz r8, 0x14(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC6EF4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82EC6EF8: 4082FFE8  bne 0x82ec6ee0
	if !ctx.cr[0].eq {
	pc = 0x82EC6EE0; continue 'dispatch;
	}
	// 82EC6EFC: 7C6939D6  mullw r3, r9, r7
	ctx.r[3].s64 = (ctx.r[9].s32 as i64) * (ctx.r[7].s32 as i64);
	// 82EC6F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6F08 size=224
    let mut pc: u32 = 0x82EC6F08;
    'dispatch: loop {
        match pc {
            0x82EC6F08 => {
    //   block [0x82EC6F08..0x82EC6FE8)
	// 82EC6F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6F0C: 4BDE24F9  bl 0x82ca9404
	ctx.lr = 0x82EC6F10;
	sub_82CA93D0(ctx, base);
	// 82EC6F10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6F18: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EC6F1C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EC6F20: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EC6F24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC6F28: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC6F2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC6F30: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82EC6F34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6F38: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EC6F3C: 4B40C41D  bl 0x822d3358
	ctx.lr = 0x82EC6F40;
	sub_822D3358(ctx, base);
	// 82EC6F40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6F44: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EC6F48: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC6F4C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC6F50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC6F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6F58: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC6F5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC6F60: 4E800421  bctrl
	ctx.lr = 0x82EC6F64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC6F64: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC6F68: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6F6C: 41820070  beq 0x82ec6fdc
	if ctx.cr[0].eq {
	pc = 0x82EC6FDC; continue 'dispatch;
	}
	// 82EC6F70: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6F74: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6F78: 41820064  beq 0x82ec6fdc
	if ctx.cr[0].eq {
	pc = 0x82EC6FDC; continue 'dispatch;
	}
	// 82EC6F7C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC6F80: 57C9077E  clrlwi r9, r30, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	// 82EC6F84: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC6F88: 57CBE8FE  srwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC6F8C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6F90: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EC6F94: 41820018  beq 0x82ec6fac
	if ctx.cr[0].eq {
	pc = 0x82EC6FAC; continue 'dispatch;
	}
	// 82EC6F98: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EC6F9C: 7CEB50AE  lbzx r7, r11, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EC6FA0: 7D094830  slw r9, r8, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[8].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 82EC6FA4: 7D293B78  or r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[7].u64;
	// 82EC6FA8: 48000014  b 0x82ec6fbc
	pc = 0x82EC6FBC; continue 'dispatch;
	// 82EC6FAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EC6FB0: 7D0B50AE  lbzx r8, r11, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EC6FB4: 7CE94830  slw r9, r7, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 82EC6FB8: 7D094878  andc r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[9].u64;
	// 82EC6FBC: 7D2B51AE  stbx r9, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u8) };
	// 82EC6FC0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC6FC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC6FC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC6FCC: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC6FD0: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC6FD4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC6FD8: 4BFC2121  bl 0x82e890f8
	ctx.lr = 0x82EC6FDC;
	sub_82E890F8(ctx, base);
	// 82EC6FDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC6FE0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC6FE4: 4BDE2470  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC6FE8 size=52
    let mut pc: u32 = 0x82EC6FE8;
    'dispatch: loop {
        match pc {
            0x82EC6FE8 => {
    //   block [0x82EC6FE8..0x82EC701C)
	// 82EC6FE8: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EC6FEC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC6FF0: 41990098  bgt cr6, 0x82ec7088
	if ctx.cr[6].gt {
		sub_82EC701C(ctx, base);
		return;
	}
	// 82EC6FF4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC6FF8: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC6FFC: 0CCB0000  twi 6, r11, 0
	// 82EC7000: 7D645B96  divwu r11, r4, r11
	ctx.r[11].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 82EC7004: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7008: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC700C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC7010: 4198000C  blt cr6, 0x82ec701c
	if ctx.cr[6].lt {
		sub_82EC701C(ctx, base);
		return;
	}
	// 82EC7014: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC7018: 48000010  b 0x82ec7028
	sub_82EC701C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC701C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC701C size=116
    let mut pc: u32 = 0x82EC701C;
    'dispatch: loop {
        match pc {
            0x82EC701C => {
    //   block [0x82EC701C..0x82EC7090)
	// 82EC701C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7020: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 82EC7024: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EC7028: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC702C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7030: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC7034: 41820054  beq 0x82ec7088
	if ctx.cr[0].eq {
	pc = 0x82EC7088; continue 'dispatch;
	}
	// 82EC7038: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC703C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC7040: 80A30080  lwz r5, 0x80(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC7044: 7D445B96  divwu r10, r4, r11
	ctx.r[10].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 82EC7048: 0CCB0000  twi 6, r11, 0
	// 82EC704C: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82EC7050: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82EC7054: 28050000  cmplwi r5, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7058: 41820030  beq 0x82ec7088
	if ctx.cr[0].eq {
	pc = 0x82EC7088; continue 'dispatch;
	}
	// 82EC705C: 81430078  lwz r10, 0x78(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC7060: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC7064: 81070008  lwz r8, 8(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7068: 81080018  lwz r8, 0x18(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC706C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EC7070: 41980020  blt cr6, 0x82ec7090
	if ctx.cr[6].lt {
		sub_82EC7090(ctx, base);
		return;
	}
	// 82EC7074: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC7078: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82EC707C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC7080: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EC7084: 4198FFDC  blt cr6, 0x82ec7060
	if ctx.cr[6].lt {
	pc = 0x82EC7060; continue 'dispatch;
	}
	// 82EC7088: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC708C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7090 size=24
    let mut pc: u32 = 0x82EC7090;
    'dispatch: loop {
        match pc {
            0x82EC7090 => {
    //   block [0x82EC7090..0x82EC70A8)
	// 82EC7090: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7094: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7098: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC709C: 4198000C  blt cr6, 0x82ec70a8
	if ctx.cr[6].lt {
		sub_82EC70A8(ctx, base);
		return;
	}
	// 82EC70A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC70A4: 48000010  b 0x82ec70b4
	sub_82EC70A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC70A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC70A8 size=36
    let mut pc: u32 = 0x82EC70A8;
    'dispatch: loop {
        match pc {
            0x82EC70A8 => {
    //   block [0x82EC70A8..0x82EC70CC)
	// 82EC70A8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC70AC: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 82EC70B0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EC70B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC70B8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC70BC: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82EC70C0: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC70C4: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 82EC70C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC70D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC70D0 size=12
    let mut pc: u32 = 0x82EC70D0;
    'dispatch: loop {
        match pc {
            0x82EC70D0 => {
    //   block [0x82EC70D0..0x82EC70DC)
	// 82EC70D0: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC70D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC70D8: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC70DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC70DC size=12
    let mut pc: u32 = 0x82EC70DC;
    'dispatch: loop {
        match pc {
            0x82EC70DC => {
    //   block [0x82EC70DC..0x82EC70E8)
	// 82EC70DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC70E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC70E4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC70E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC70E8 size=12
    let mut pc: u32 = 0x82EC70E8;
    'dispatch: loop {
        match pc {
            0x82EC70E8 => {
    //   block [0x82EC70E8..0x82EC70F4)
	// 82EC70E8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC70EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC70F0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC70F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC70F4 size=180
    let mut pc: u32 = 0x82EC70F4;
    'dispatch: loop {
        match pc {
            0x82EC70F4 => {
    //   block [0x82EC70F4..0x82EC71A8)
	// 82EC70F4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC70F8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC70FC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC7100: 4182009C  beq 0x82ec719c
	if ctx.cr[0].eq {
	pc = 0x82EC719C; continue 'dispatch;
	}
	// 82EC7104: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC7108: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC710C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC7110: 394B0074  addi r10, r11, 0x74
	ctx.r[10].s64 = ctx.r[11].s64 + 116;
	// 82EC7114: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7118: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC711C: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7120: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7124: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EC7128: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 82EC712C: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EC7130: 7D293B96  divwu r9, r9, r7
	ctx.r[9].u32 = ctx.r[9].u32 / ctx.r[7].u32;
	// 82EC7134: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82EC7138: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC713C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC7144: 40990058  ble cr6, 0x82ec719c
	if !ctx.cr[6].gt {
	pc = 0x82EC719C; continue 'dispatch;
	}
	// 82EC7148: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC714C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7150: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC7154: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC7158: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC715C: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7160: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC7164: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC7168: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC716C: 409A003C  bne cr6, 0x82ec71a8
	if !ctx.cr[6].eq {
		sub_82EC71A8(ctx, base);
		return;
	}
	// 82EC7170: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7174: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7178: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC717C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC7180: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC7184: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC7188: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC718C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC7190: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7194: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC7198: 4198FFB0  blt cr6, 0x82ec7148
	if ctx.cr[6].lt {
	pc = 0x82EC7148; continue 'dispatch;
	}
	// 82EC719C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC71A0: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC71A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC71A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC71A8 size=40
    let mut pc: u32 = 0x82EC71A8;
    'dispatch: loop {
        match pc {
            0x82EC71A8 => {
    //   block [0x82EC71A8..0x82EC71D0)
	// 82EC71A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC71AC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC71B0: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC71B4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC71B8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC71BC: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC71C0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC71C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC71C8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EC71CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC71D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC71D0 size=12
    let mut pc: u32 = 0x82EC71D0;
    'dispatch: loop {
        match pc {
            0x82EC71D0 => {
    //   block [0x82EC71D0..0x82EC71DC)
	// 82EC71D0: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC71D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC71D8: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC71DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC71DC size=12
    let mut pc: u32 = 0x82EC71DC;
    'dispatch: loop {
        match pc {
            0x82EC71DC => {
    //   block [0x82EC71DC..0x82EC71E8)
	// 82EC71DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC71E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC71E4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC71E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC71E8 size=12
    let mut pc: u32 = 0x82EC71E8;
    'dispatch: loop {
        match pc {
            0x82EC71E8 => {
    //   block [0x82EC71E8..0x82EC71F4)
	// 82EC71E8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC71EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC71F0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC71F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC71F4 size=92
    let mut pc: u32 = 0x82EC71F4;
    'dispatch: loop {
        match pc {
            0x82EC71F4 => {
    //   block [0x82EC71F4..0x82EC7250)
	// 82EC71F4: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC71F8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC71FC: 396B0074  addi r11, r11, 0x74
	ctx.r[11].s64 = ctx.r[11].s64 + 116;
	// 82EC7200: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7204: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EC7208: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC720C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7210: 41820040  beq 0x82ec7250
	if ctx.cr[0].eq {
		sub_82EC7250(ctx, base);
		return;
	}
	// 82EC7214: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7218: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC721C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7220: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EC7224: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC7228: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC722C: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC7230: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7234: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7238: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC723C: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC7240: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EC7244: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC7248: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EC724C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7250 size=16
    let mut pc: u32 = 0x82EC7250;
    'dispatch: loop {
        match pc {
            0x82EC7250 => {
    //   block [0x82EC7250..0x82EC7260)
	// 82EC7250: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7254: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC7258: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC725C: 48000058  b 0x82ec72b4
	sub_82EC7260(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7260 size=276
    let mut pc: u32 = 0x82EC7260;
    'dispatch: loop {
        match pc {
            0x82EC7260 => {
    //   block [0x82EC7260..0x82EC7374)
	// 82EC7260: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7264: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7268: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC726C: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7270: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EC7274: 8129FFFC  lwz r9, -4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EC7278: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC727C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC7280: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC7284: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7288: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC728C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7290: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7294: 91230018  stw r9, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EC7298: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC729C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EC72A0: 409A00D4  bne cr6, 0x82ec7374
	if !ctx.cr[6].eq {
		sub_82EC7374(ctx, base);
		return;
	}
	// 82EC72A4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC72A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC72AC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC72B0: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC72B4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC72B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC72BC: 4198FFA4  blt cr6, 0x82ec7260
	if ctx.cr[6].lt {
	pc = 0x82EC7260; continue 'dispatch;
	}
	// 82EC72C0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC72C4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC72C8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC72CC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC72D0: 41820098  beq 0x82ec7368
	if ctx.cr[0].eq {
	pc = 0x82EC7368; continue 'dispatch;
	}
	// 82EC72D4: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC72D8: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC72DC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC72E0: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC72E4: 814A0070  lwz r10, 0x70(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC72E8: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC72EC: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC72F0: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EC72F4: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 82EC72F8: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EC72FC: 7D293B96  divwu r9, r9, r7
	ctx.r[9].u32 = ctx.r[9].u32 / ctx.r[7].u32;
	// 82EC7300: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82EC7304: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EC7308: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC730C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC7310: 40990058  ble cr6, 0x82ec7368
	if !ctx.cr[6].gt {
	pc = 0x82EC7368; continue 'dispatch;
	}
	// 82EC7314: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7318: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC731C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC7320: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC7324: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7328: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC732C: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC7330: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC7334: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC7338: 409A0064  bne cr6, 0x82ec739c
	if !ctx.cr[6].eq {
		sub_82EC739C(ctx, base);
		return;
	}
	// 82EC733C: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7340: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7344: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7348: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC734C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC7350: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC7354: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC7358: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC735C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7360: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC7364: 4198FFB0  blt cr6, 0x82ec7314
	if ctx.cr[6].lt {
	pc = 0x82EC7314; continue 'dispatch;
	}
	// 82EC7368: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC736C: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC7370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7374(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7374 size=40
    let mut pc: u32 = 0x82EC7374;
    'dispatch: loop {
        match pc {
            0x82EC7374 => {
    //   block [0x82EC7374..0x82EC739C)
	// 82EC7374: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7378: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 82EC737C: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7380: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC7384: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 82EC7388: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC738C: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7390: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC7394: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC7398: 4BFFFEB0  b 0x82ec7248
	sub_82EC71F4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC739C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC739C size=20
    let mut pc: u32 = 0x82EC739C;
    'dispatch: loop {
        match pc {
            0x82EC739C => {
    //   block [0x82EC739C..0x82EC73B0)
	// 82EC739C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC73A0: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC73A4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC73A8: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC73AC: 4BFFFFDC  b 0x82ec7388
	sub_82EC7374(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC73B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC73B0 size=60
    let mut pc: u32 = 0x82EC73B0;
    'dispatch: loop {
        match pc {
            0x82EC73B0 => {
    //   block [0x82EC73B0..0x82EC73EC)
	// 82EC73B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC73B4: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC73B8: 90E30008  stw r7, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82EC73BC: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82EC73C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC73C4: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC73C8: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC73CC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC73D0: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EC73D4: 40820018  bne 0x82ec73ec
	if !ctx.cr[0].eq {
		sub_82EC73EC(ctx, base);
		return;
	}
	// 82EC73D8: 90E30020  stw r7, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC73DC: 90E30018  stw r7, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 82EC73E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC73E4: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC73E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC73EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC73EC size=152
    let mut pc: u32 = 0x82EC73EC;
    'dispatch: loop {
        match pc {
            0x82EC73EC => {
    //   block [0x82EC73EC..0x82EC7484)
	// 82EC73EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC73F0: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 82EC73F4: 80C30004  lwz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC73F8: 392B0074  addi r9, r11, 0x74
	ctx.r[9].s64 = ctx.r[11].s64 + 116;
	// 82EC73FC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC7400: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7404: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7408: 7D4A3050  subf r10, r10, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82EC740C: 7D4A4396  divwu r10, r10, r8
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[8].u32;
	// 82EC7410: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82EC7414: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC7418: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC741C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC7420: 40990088  ble cr6, 0x82ec74a8
	if !ctx.cr[6].gt {
		sub_82EC7484(ctx, base);
		return;
	}
	// 82EC7424: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7428: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC742C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC7430: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EC7434: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7438: 4182002C  beq 0x82ec7464
	if ctx.cr[0].eq {
	pc = 0x82EC7464; continue 'dispatch;
	}
	// 82EC743C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7440: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7444: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 82EC7448: 54C6003E  slwi r6, r6, 0
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EC744C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EC7450: 409A0034  bne cr6, 0x82ec7484
	if !ctx.cr[6].eq {
		sub_82EC7484(ctx, base);
		return;
	}
	// 82EC7454: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7458: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC745C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC7460: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC7464: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7468: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC746C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC7470: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC7474: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7478: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC747C: 4198FFA8  blt cr6, 0x82ec7424
	if ctx.cr[6].lt {
	pc = 0x82EC7424; continue 'dispatch;
	}
	// 82EC7480: 48000028  b 0x82ec74a8
	sub_82EC7484(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7484(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7484 size=56
    let mut pc: u32 = 0x82EC7484;
    'dispatch: loop {
        match pc {
            0x82EC7484 => {
    //   block [0x82EC7484..0x82EC74BC)
	// 82EC7484: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7488: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC748C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC7490: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC7494: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7498: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 82EC749C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC74A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC74A4: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EC74A8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC74AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC74B0: 419AFF30  beq cr6, 0x82ec73e0
	if ctx.cr[6].eq {
		sub_82EC73B0(ctx, base);
		return;
	}
	// 82EC74B4: 98E3001C  stb r7, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u8 ) };
	// 82EC74B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC74C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC74C0 size=556
    let mut pc: u32 = 0x82EC74C0;
    'dispatch: loop {
        match pc {
            0x82EC74C0 => {
    //   block [0x82EC74C0..0x82EC76EC)
	// 82EC74C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC74C4: 4BDE1F2D  bl 0x82ca93f0
	ctx.lr = 0x82EC74C8;
	sub_82CA93D0(ctx, base);
	// 82EC74C8: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82EC74CC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC74D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC74D4: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC74D8: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC74DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC74E0: 408201FC  bne 0x82ec76dc
	if !ctx.cr[0].eq {
	pc = 0x82EC76DC; continue 'dispatch;
	}
	// 82EC74E4: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC74E8: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC74EC: 48000028  b 0x82ec7514
	pc = 0x82EC7514; continue 'dispatch;
	// 82EC74F0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC74F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC74F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC74FC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC7504: 4E800421  bctrl
	ctx.lr = 0x82EC7508;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC7508: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC750C: 408201D0  bne 0x82ec76dc
	if !ctx.cr[0].eq {
	pc = 0x82EC76DC; continue 'dispatch;
	}
	// 82EC7510: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7514: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7518: 4082FFD8  bne 0x82ec74f0
	if !ctx.cr[0].eq {
	pc = 0x82EC74F0; continue 'dispatch;
	}
	// 82EC751C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7520: 808300A8  lwz r4, 0xa8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC7524: 4BFBFE2D  bl 0x82e87350
	ctx.lr = 0x82EC7528;
	sub_82E87350(ctx, base);
	// 82EC7528: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EC752C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC7530: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7534: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7538: 4082000C  bne 0x82ec7544
	if !ctx.cr[0].eq {
	pc = 0x82EC7544; continue 'dispatch;
	}
	// 82EC753C: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82EC7540: 4BFFFE71  bl 0x82ec73b0
	ctx.lr = 0x82EC7544;
	sub_82EC73B0(ctx, base);
	// 82EC7544: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7548: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EC754C: 82EB00A4  lwz r23, 0xa4(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC7550: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EC7554: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EC7558: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC755C: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7560: 4182017C  beq 0x82ec76dc
	if ctx.cr[0].eq {
	pc = 0x82EC76DC; continue 'dispatch;
	}
	// 82EC7564: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC7568: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC756C: 41820168  beq 0x82ec76d4
	if ctx.cr[0].eq {
	pc = 0x82EC76D4; continue 'dispatch;
	}
	// 82EC7570: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC7574: 3B5F0084  addi r26, r31, 0x84
	ctx.r[26].s64 = ctx.r[31].s64 + 132;
	// 82EC7578: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC757C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC7580: 91760000  stw r11, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC7584: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7588: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC758C: 41820018  beq 0x82ec75a4
	if ctx.cr[0].eq {
	pc = 0x82EC75A4; continue 'dispatch;
	}
	// 82EC7590: 815A0018  lwz r10, 0x18(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7594: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7598: 4182000C  beq 0x82ec75a4
	if ctx.cr[0].eq {
	pc = 0x82EC75A4; continue 'dispatch;
	}
	// 82EC759C: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC75A0: 836A0004  lwz r27, 4(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC75A4: 7F18E840  cmplw cr6, r24, r29
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EC75A8: 419A0054  beq cr6, 0x82ec75fc
	if ctx.cr[6].eq {
	pc = 0x82EC75FC; continue 'dispatch;
	}
	// 82EC75AC: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC75B0: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 82EC75B4: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC75B8: 4800002C  b 0x82ec75e4
	pc = 0x82EC75E4; continue 'dispatch;
	// 82EC75BC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC75C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC75C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC75C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC75CC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC75D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC75D4: 4E800421  bctrl
	ctx.lr = 0x82EC75D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC75D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC75DC: 40820014  bne 0x82ec75f0
	if !ctx.cr[0].eq {
	pc = 0x82EC75F0; continue 'dispatch;
	}
	// 82EC75E0: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC75E4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC75E8: 4082FFD4  bne 0x82ec75bc
	if !ctx.cr[0].eq {
	pc = 0x82EC75BC; continue 'dispatch;
	}
	// 82EC75EC: 48000008  b 0x82ec75f4
	pc = 0x82EC75F4; continue 'dispatch;
	// 82EC75F0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82EC75F4: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC75F8: 408200B8  bne 0x82ec76b0
	if !ctx.cr[0].eq {
	pc = 0x82EC76B0; continue 'dispatch;
	}
	// 82EC75FC: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC7600: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC7604: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7608: 48000030  b 0x82ec7638
	pc = 0x82EC7638; continue 'dispatch;
	// 82EC760C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7610: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EC7614: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC7618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC761C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC7620: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC7624: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC7628: 4E800421  bctrl
	ctx.lr = 0x82EC762C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC762C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7630: 40820014  bne 0x82ec7644
	if !ctx.cr[0].eq {
	pc = 0x82EC7644; continue 'dispatch;
	}
	// 82EC7634: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7638: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC763C: 4082FFD0  bne 0x82ec760c
	if !ctx.cr[0].eq {
	pc = 0x82EC760C; continue 'dispatch;
	}
	// 82EC7640: 48000008  b 0x82ec7648
	pc = 0x82EC7648; continue 'dispatch;
	// 82EC7644: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EC7648: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC764C: 40820064  bne 0x82ec76b0
	if !ctx.cr[0].eq {
	pc = 0x82EC76B0; continue 'dispatch;
	}
	// 82EC7650: 83DF00A4  lwz r30, 0xa4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC7654: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7658: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC765C: 4BFC1A25  bl 0x82e89080
	ctx.lr = 0x82EC7660;
	sub_82E89080(ctx, base);
	// 82EC7660: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC7664: 7F04B840  cmplw cr6, r4, r23
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82EC7668: 419A001C  beq cr6, 0x82ec7684
	if ctx.cr[6].eq {
	pc = 0x82EC7684; continue 'dispatch;
	}
	// 82EC766C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7670: 4BFBFCE1  bl 0x82e87350
	ctx.lr = 0x82EC7674;
	sub_82E87350(ctx, base);
	// 82EC7674: EDBF0828  fsubs f13, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC7678: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC767C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC7680: 41980030  blt cr6, 0x82ec76b0
	if ctx.cr[6].lt {
	pc = 0x82EC76B0; continue 'dispatch;
	}
	// 82EC7684: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC7688: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC768C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EC7690: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC7694: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC7698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC769C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82EC76A0: 4BFFF869  bl 0x82ec6f08
	ctx.lr = 0x82EC76A4;
	sub_82EC6F08(ctx, base);
	// 82EC76A4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC76A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC76AC: 41820028  beq 0x82ec76d4
	if ctx.cr[0].eq {
	pc = 0x82EC76D4; continue 'dispatch;
	}
	// 82EC76B0: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC76B4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC76B8: 41820010  beq 0x82ec76c8
	if ctx.cr[0].eq {
	pc = 0x82EC76C8; continue 'dispatch;
	}
	// 82EC76BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC76C0: 4BFFFA11  bl 0x82ec70d0
	ctx.lr = 0x82EC76C4;
	sub_82EC70D0(ctx, base);
	// 82EC76C4: 4BFFFE8C  b 0x82ec7550
	pc = 0x82EC7550; continue 'dispatch;
	// 82EC76C8: 4BFFFB09  bl 0x82ec71d0
	ctx.lr = 0x82EC76CC;
	sub_82EC71D0(ctx, base);
	// 82EC76CC: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EC76D0: 4BFFFE84  b 0x82ec7554
	pc = 0x82EC7554; continue 'dispatch;
	// 82EC76D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC76D8: 48000008  b 0x82ec76e0
	pc = 0x82EC76E0; continue 'dispatch;
	// 82EC76DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC76E0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EC76E4: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82EC76E8: 4BDE1D58  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC76F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC76F0 size=108
    let mut pc: u32 = 0x82EC76F0;
    'dispatch: loop {
        match pc {
            0x82EC76F0 => {
    //   block [0x82EC76F0..0x82EC775C)
	// 82EC76F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC76F4: 4BDE1D19  bl 0x82ca940c
	ctx.lr = 0x82EC76F8;
	sub_82CA93D0(ctx, base);
	// 82EC76F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC76FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7700: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC7704: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC7708: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC770C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC7710: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC7714: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EC7718: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC771C: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82EC7720: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC7724: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC7728: 4BFFF8C1  bl 0x82ec6fe8
	ctx.lr = 0x82EC772C;
	sub_82EC6FE8(ctx, base);
	// 82EC772C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7730: 4082000C  bne 0x82ec773c
	if !ctx.cr[0].eq {
	pc = 0x82EC773C; continue 'dispatch;
	}
	// 82EC7734: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC7738: 4800001C  b 0x82ec7754
	pc = 0x82EC7754; continue 'dispatch;
	// 82EC773C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EC7740: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC7744: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EC7748: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC774C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7750: 4BFFF7B9  bl 0x82ec6f08
	ctx.lr = 0x82EC7754;
	sub_82EC6F08(ctx, base);
	// 82EC7754: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC7758: 4BDE1D04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7760 size=360
    let mut pc: u32 = 0x82EC7760;
    'dispatch: loop {
        match pc {
            0x82EC7760 => {
    //   block [0x82EC7760..0x82EC78C8)
	// 82EC7760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC7768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC776C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC7770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7778: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC777C: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EC7780: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7784: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7788: 41820048  beq 0x82ec77d0
	if ctx.cr[0].eq {
	pc = 0x82EC77D0; continue 'dispatch;
	}
	// 82EC778C: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EC7790: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7794: 4182001C  beq 0x82ec77b0
	if ctx.cr[0].eq {
	pc = 0x82EC77B0; continue 'dispatch;
	}
	// 82EC7798: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC779C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC77A0: 409A0010  bne cr6, 0x82ec77b0
	if !ctx.cr[6].eq {
	pc = 0x82EC77B0; continue 'dispatch;
	}
	// 82EC77A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC77A8: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82EC77AC: 4BFFF925  bl 0x82ec70d0
	ctx.lr = 0x82EC77B0;
	sub_82EC70D0(ctx, base);
	// 82EC77B0: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EC77B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC77B8: 41820018  beq 0x82ec77d0
	if ctx.cr[0].eq {
	pc = 0x82EC77D0; continue 'dispatch;
	}
	// 82EC77BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC77C0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC77C4: 409A000C  bne cr6, 0x82ec77d0
	if !ctx.cr[6].eq {
	pc = 0x82EC77D0; continue 'dispatch;
	}
	// 82EC77C8: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82EC77CC: 4BFFFA05  bl 0x82ec71d0
	ctx.lr = 0x82EC77D0;
	sub_82EC71D0(ctx, base);
	// 82EC77D0: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EC77D4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC77D8: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC77DC: 41820024  beq 0x82ec7800
	if ctx.cr[0].eq {
	pc = 0x82EC7800; continue 'dispatch;
	}
	// 82EC77E0: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EC77E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC77E8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC77EC: 419AFF90  beq cr6, 0x82ec777c
	if ctx.cr[6].eq {
	pc = 0x82EC777C; continue 'dispatch;
	}
	// 82EC77F0: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EC77F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC77F8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC77FC: 419AFF80  beq cr6, 0x82ec777c
	if ctx.cr[6].eq {
	pc = 0x82EC777C; continue 'dispatch;
	}
	// 82EC7800: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EC7804: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7808: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC780C: 41820048  beq 0x82ec7854
	if ctx.cr[0].eq {
	pc = 0x82EC7854; continue 'dispatch;
	}
	// 82EC7810: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EC7814: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7818: 4182001C  beq 0x82ec7834
	if ctx.cr[0].eq {
	pc = 0x82EC7834; continue 'dispatch;
	}
	// 82EC781C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7820: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC7824: 409A0010  bne cr6, 0x82ec7834
	if !ctx.cr[6].eq {
	pc = 0x82EC7834; continue 'dispatch;
	}
	// 82EC7828: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC782C: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 82EC7830: 4BFFF8A1  bl 0x82ec70d0
	ctx.lr = 0x82EC7834;
	sub_82EC70D0(ctx, base);
	// 82EC7834: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EC7838: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC783C: 41820018  beq 0x82ec7854
	if ctx.cr[0].eq {
	pc = 0x82EC7854; continue 'dispatch;
	}
	// 82EC7840: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7844: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC7848: 409A000C  bne cr6, 0x82ec7854
	if !ctx.cr[6].eq {
	pc = 0x82EC7854; continue 'dispatch;
	}
	// 82EC784C: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 82EC7850: 4BFFF981  bl 0x82ec71d0
	ctx.lr = 0x82EC7854;
	sub_82EC71D0(ctx, base);
	// 82EC7854: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EC7858: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC785C: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7860: 41820024  beq 0x82ec7884
	if ctx.cr[0].eq {
	pc = 0x82EC7884; continue 'dispatch;
	}
	// 82EC7864: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EC7868: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC786C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC7870: 419AFF90  beq cr6, 0x82ec7800
	if ctx.cr[6].eq {
	pc = 0x82EC7800; continue 'dispatch;
	}
	// 82EC7874: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EC7878: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC787C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC7880: 419AFF80  beq cr6, 0x82ec7800
	if ctx.cr[6].eq {
	pc = 0x82EC7800; continue 'dispatch;
	}
	// 82EC7884: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC7888: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC788C: 419A0024  beq cr6, 0x82ec78b0
	if ctx.cr[6].eq {
	pc = 0x82EC78B0; continue 'dispatch;
	}
	// 82EC7890: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC7894: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7898: 41820018  beq 0x82ec78b0
	if ctx.cr[0].eq {
	pc = 0x82EC78B0; continue 'dispatch;
	}
	// 82EC789C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC78A0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC78A4: 409A000C  bne cr6, 0x82ec78b0
	if !ctx.cr[6].eq {
	pc = 0x82EC78B0; continue 'dispatch;
	}
	// 82EC78A8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82EC78AC: 4BFBEC85  bl 0x82e86530
	ctx.lr = 0x82EC78B0;
	sub_82E86530(ctx, base);
	// 82EC78B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC78B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC78B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC78BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC78C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC78C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC78C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC78C8 size=404
    let mut pc: u32 = 0x82EC78C8;
    'dispatch: loop {
        match pc {
            0x82EC78C8 => {
    //   block [0x82EC78C8..0x82EC7A5C)
	// 82EC78C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC78CC: 4BDE1B25  bl 0x82ca93f0
	ctx.lr = 0x82EC78D0;
	sub_82CA93D0(ctx, base);
	// 82EC78D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC78D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC78D8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC78DC: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC78E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC78E4: 40820170  bne 0x82ec7a54
	if !ctx.cr[0].eq {
	pc = 0x82EC7A54; continue 'dispatch;
	}
	// 82EC78E8: 81760064  lwz r11, 0x64(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC78EC: 3AE00014  li r23, 0x14
	ctx.r[23].s64 = 20;
	// 82EC78F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC78F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC78F8: 409A00A0  bne cr6, 0x82ec7998
	if !ctx.cr[6].eq {
	pc = 0x82EC7998; continue 'dispatch;
	}
	// 82EC78FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7900: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC7904: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7908: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC790C: 8156006C  lwz r10, 0x6c(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7910: 811F0070  lwz r8, 0x70(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC7914: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC7918: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC791C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EC7920: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC7924: 814900A4  lwz r10, 0xa4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC7928: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC792C: 7F0B41D6  mullw r24, r11, r8
	ctx.r[24].s64 = (ctx.r[11].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82EC7930: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC7934: 40990064  ble cr6, 0x82ec7998
	if !ctx.cr[6].gt {
	pc = 0x82EC7998; continue 'dispatch;
	}
	// 82EC7938: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EC793C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC7940: 7F2BD02E  lwzx r25, r11, r26
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EC7944: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7948: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC794C: 48000028  b 0x82ec7974
	pc = 0x82EC7974; continue 'dispatch;
	// 82EC7950: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7954: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC7958: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC795C: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82EC7960: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC7964: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC7968: 7C8BC214  add r4, r11, r24
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82EC796C: 4BFC178D  bl 0x82e890f8
	ctx.lr = 0x82EC7970;
	sub_82E890F8(ctx, base);
	// 82EC7970: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7974: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7978: 4082FFD8  bne 0x82ec7950
	if !ctx.cr[0].eq {
	pc = 0x82EC7950; continue 'dispatch;
	}
	// 82EC797C: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7980: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EC7984: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC7988: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EC798C: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC7990: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC7994: 4198FFA8  blt cr6, 0x82ec793c
	if ctx.cr[6].lt {
	pc = 0x82EC793C; continue 'dispatch;
	}
	// 82EC7998: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC799C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC79A0: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC79A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC79A8: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC79AC: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC79B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC79B4: 418200A0  beq 0x82ec7a54
	if ctx.cr[0].eq {
	pc = 0x82EC7A54; continue 'dispatch;
	}
	// 82EC79B8: 811F0078  lwz r8, 0x78(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC79BC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC79C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC79C4: 41820018  beq 0x82ec79dc
	if ctx.cr[0].eq {
	pc = 0x82EC79DC; continue 'dispatch;
	}
	// 82EC79C8: 80D60064  lwz r6, 0x64(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC79CC: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EC79D0: 419A0020  beq cr6, 0x82ec79f0
	if ctx.cr[6].eq {
	pc = 0x82EC79F0; continue 'dispatch;
	}
	// 82EC79D4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC79D8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC79DC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC79E0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC79E4: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EC79E8: 4198FFD4  blt cr6, 0x82ec79bc
	if ctx.cr[6].lt {
	pc = 0x82EC79BC; continue 'dispatch;
	}
	// 82EC79EC: 48000068  b 0x82ec7a54
	pc = 0x82EC7A54; continue 'dispatch;
	// 82EC79F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC79F4: 81360064  lwz r9, 0x64(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC79F8: 8116006C  lwz r8, 0x6c(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC79FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A00: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A04: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7A0C: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82EC7A10: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC7A14: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC7A18: 48000034  b 0x82ec7a4c
	pc = 0x82EC7A4C; continue 'dispatch;
	// 82EC7A1C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A20: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC7A24: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC7A28: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7A2C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7A30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7A34: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82EC7A38: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC7A3C: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82EC7A40: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC7A44: 4BFC16B5  bl 0x82e890f8
	ctx.lr = 0x82EC7A48;
	sub_82E890F8(ctx, base);
	// 82EC7A48: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7A4C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7A50: 4082FFCC  bne 0x82ec7a1c
	if !ctx.cr[0].eq {
	pc = 0x82EC7A1C; continue 'dispatch;
	}
	// 82EC7A54: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC7A58: 4BDE19E8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7A60 size=80
    let mut pc: u32 = 0x82EC7A60;
    'dispatch: loop {
        match pc {
            0x82EC7A60 => {
    //   block [0x82EC7A60..0x82EC7AB0)
	// 82EC7A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC7A68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC7A6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7A70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC7A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7A78: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC7A7C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EC7A80: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EC7A84: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82EC7A88: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82EC7A8C: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EC7A90: 4BFF18F1  bl 0x82eb9380
	ctx.lr = 0x82EC7A94;
	sub_82EB9380(ctx, base);
	// 82EC7A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7A98: 4BFFEFC1  bl 0x82ec6a58
	ctx.lr = 0x82EC7A9C;
	sub_82EC6A58(ctx, base);
	// 82EC7A9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC7AA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC7AA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC7AA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC7AAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7AB0 size=244
    let mut pc: u32 = 0x82EC7AB0;
    'dispatch: loop {
        match pc {
            0x82EC7AB0 => {
    //   block [0x82EC7AB0..0x82EC7BA4)
	// 82EC7AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7AB4: 4BDE1951  bl 0x82ca9404
	ctx.lr = 0x82EC7AB8;
	sub_82CA93D0(ctx, base);
	// 82EC7AB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7ABC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC7AC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC7AC4: 4BFBEF05  bl 0x82e869c8
	ctx.lr = 0x82EC7AC8;
	sub_82E869C8(ctx, base);
	// 82EC7AC8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC7ACC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC7AD0: 409A000C  bne cr6, 0x82ec7adc
	if !ctx.cr[6].eq {
	pc = 0x82EC7ADC; continue 'dispatch;
	}
	// 82EC7AD4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC7AD8: 48000088  b 0x82ec7b60
	pc = 0x82EC7B60; continue 'dispatch;
	// 82EC7ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7AE0: 482F4581  bl 0x831bc060
	ctx.lr = 0x82EC7AE4;
	sub_831BC060(ctx, base);
	// 82EC7AE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC7AE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC7AEC: 396BB2D0  addi r11, r11, -0x4d30
	ctx.r[11].s64 = ctx.r[11].s64 + -19760;
	// 82EC7AF0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EC7AF4: 4BDE505D  bl 0x82cacb50
	ctx.lr = 0x82EC7AF8;
	sub_82CACB50(ctx, base);
	// 82EC7AF8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC7AFC: 40820060  bne 0x82ec7b5c
	if !ctx.cr[0].eq {
	pc = 0x82EC7B5C; continue 'dispatch;
	}
	// 82EC7B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7B04: 4BA46205  bl 0x8290dd08
	ctx.lr = 0x82EC7B08;
	sub_8290DD08(ctx, base);
	// 82EC7B08: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EC7B0C: 41820050  beq 0x82ec7b5c
	if ctx.cr[0].eq {
	pc = 0x82EC7B5C; continue 'dispatch;
	}
	// 82EC7B10: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7B14: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC7B18: 3BEB0050  addi r31, r11, 0x50
	ctx.r[31].s64 = ctx.r[11].s64 + 80;
	// 82EC7B1C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7B20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC7B24: 40990038  ble cr6, 0x82ec7b5c
	if !ctx.cr[6].gt {
	pc = 0x82EC7B5C; continue 'dispatch;
	}
	// 82EC7B28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC7B2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7B30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC7B34: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC7B38: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC7B3C: 4BDE5015  bl 0x82cacb50
	ctx.lr = 0x82EC7B40;
	sub_82CACB50(ctx, base);
	// 82EC7B40: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC7B44: 41820024  beq 0x82ec7b68
	if ctx.cr[0].eq {
	pc = 0x82EC7B68; continue 'dispatch;
	}
	// 82EC7B48: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC7B4C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EC7B50: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EC7B54: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC7B58: 4198FFD4  blt cr6, 0x82ec7b2c
	if ctx.cr[6].lt {
	pc = 0x82EC7B2C; continue 'dispatch;
	}
	// 82EC7B5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC7B60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC7B64: 4BDE18F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82EC7B68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7B6C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC7B70: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC7B74: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7B78: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EC7B7C: 4182FFE0  beq 0x82ec7b5c
	if ctx.cr[0].eq {
	pc = 0x82EC7B5C; continue 'dispatch;
	}
	// 82EC7B80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC7B84: 387C0074  addi r3, r28, 0x74
	ctx.r[3].s64 = ctx.r[28].s64 + 116;
	// 82EC7B88: 4BFF1709  bl 0x82eb9290
	ctx.lr = 0x82EC7B8C;
	sub_82EB9290(ctx, base);
	// 82EC7B8C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC7B90: 815C0070  lwz r10, 0x70(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC7B94: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC7B98: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC7B9C: 917C0070  stw r11, 0x70(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EC7BA0: 4BFFFFC0  b 0x82ec7b60
	pc = 0x82EC7B60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC7BA8 size=284
    let mut pc: u32 = 0x82EC7BA8;
    'dispatch: loop {
        match pc {
            0x82EC7BA8 => {
    //   block [0x82EC7BA8..0x82EC7CC4)
	// 82EC7BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7BAC: 4BDE1861  bl 0x82ca940c
	ctx.lr = 0x82EC7BB0;
	sub_82CA93D0(ctx, base);
	// 82EC7BB0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EC7BB4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC7BB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7BBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7BC0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC7BC4: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC7BC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7BCC: 408200E4  bne 0x82ec7cb0
	if !ctx.cr[0].eq {
	pc = 0x82EC7CB0; continue 'dispatch;
	}
	// 82EC7BD0: 4B398DE9  bl 0x822609b8
	ctx.lr = 0x82EC7BD4;
	sub_822609B8(ctx, base);
	// 82EC7BD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7BD8: C3E3004C  lfs f31, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC7BDC: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC7BE0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC7BE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC7BE8: C3CB0BEC  lfs f30, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC7BEC: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EC7BF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7BF4: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7BF8: 418200B0  beq 0x82ec7ca8
	if ctx.cr[0].eq {
	pc = 0x82EC7CA8; continue 'dispatch;
	}
	// 82EC7BFC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC7C00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7C04: 4182009C  beq 0x82ec7ca0
	if ctx.cr[0].eq {
	pc = 0x82EC7CA0; continue 'dispatch;
	}
	// 82EC7C08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC7C0C: 3BDF00AC  addi r30, r31, 0xac
	ctx.r[30].s64 = ctx.r[31].s64 + 172;
	// 82EC7C10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC7C14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC7C18: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC7C1C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7C20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7C24: 41820018  beq 0x82ec7c3c
	if ctx.cr[0].eq {
	pc = 0x82EC7C3C; continue 'dispatch;
	}
	// 82EC7C28: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC7C2C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7C30: 4182000C  beq 0x82ec7c3c
	if ctx.cr[0].eq {
	pc = 0x82EC7C3C; continue 'dispatch;
	}
	// 82EC7C34: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7C38: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7C40: 4B9FAB21  bl 0x828c2760
	ctx.lr = 0x82EC7C44;
	sub_828C2760(ctx, base);
	// 82EC7C44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC7C48: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7C4C: 4BFC1435  bl 0x82e89080
	ctx.lr = 0x82EC7C50;
	sub_82E89080(ctx, base);
	// 82EC7C50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC7C54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7C58: 4BFBF6F9  bl 0x82e87350
	ctx.lr = 0x82EC7C5C;
	sub_82E87350(ctx, base);
	// 82EC7C5C: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82EC7C60: 419A0034  beq cr6, 0x82ec7c94
	if ctx.cr[6].eq {
	pc = 0x82EC7C94; continue 'dispatch;
	}
	// 82EC7C64: EC1F0828  fsubs f0, f31, f1
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC7C68: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC7C6C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC7C70: 40980014  bge cr6, 0x82ec7c84
	if !ctx.cr[6].lt {
	pc = 0x82EC7C84; continue 'dispatch;
	}
	// 82EC7C74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC7C78: C1AB0098  lfs f13, 0x98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC7C7C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC7C80: 41980014  blt cr6, 0x82ec7c94
	if ctx.cr[6].lt {
	pc = 0x82EC7C94; continue 'dispatch;
	}
	// 82EC7C84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC7C88: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EC7C8C: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC7C90: 4BFC1469  bl 0x82e890f8
	ctx.lr = 0x82EC7C94;
	sub_82E890F8(ctx, base);
	// 82EC7C94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC7C98: 4BFFF539  bl 0x82ec71d0
	ctx.lr = 0x82EC7C9C;
	sub_82EC71D0(ctx, base);
	// 82EC7C9C: 4BFFFF50  b 0x82ec7bec
	pc = 0x82EC7BEC; continue 'dispatch;
	// 82EC7CA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC7CA4: 48000010  b 0x82ec7cb4
	pc = 0x82EC7CB4; continue 'dispatch;
	// 82EC7CA8: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 82EC7CAC: 4BFFF705  bl 0x82ec73b0
	ctx.lr = 0x82EC7CB0;
	sub_82EC73B0(ctx, base);
	// 82EC7CB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC7CB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC7CB8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EC7CBC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC7CC0: 4BDE179C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7CC8 size=12
    let mut pc: u32 = 0x82EC7CC8;
    'dispatch: loop {
        match pc {
            0x82EC7CC8 => {
    //   block [0x82EC7CC8..0x82EC7CD4)
	// 82EC7CC8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC7CCC: 386BE284  addi r3, r11, -0x1d7c
	ctx.r[3].s64 = ctx.r[11].s64 + -7548;
	// 82EC7CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7CD8 size=48
    let mut pc: u32 = 0x82EC7CD8;
    'dispatch: loop {
        match pc {
            0x82EC7CD8 => {
    //   block [0x82EC7CD8..0x82EC7D08)
	// 82EC7CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC7CE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7CE4: 4BFBF055  bl 0x82e86d38
	ctx.lr = 0x82EC7CE8;
	sub_82E86D38(ctx, base);
	// 82EC7CE8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC7CEC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC7CF0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC7CF4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82EC7CF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC7CFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC7D00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC7D04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7D08 size=92
    let mut pc: u32 = 0x82EC7D08;
    'dispatch: loop {
        match pc {
            0x82EC7D08 => {
    //   block [0x82EC7D08..0x82EC7D64)
	// 82EC7D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7D0C: 4BDE16FD  bl 0x82ca9408
	ctx.lr = 0x82EC7D10;
	sub_82CA93D0(ctx, base);
	// 82EC7D10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7D14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC7D18: 386000D4  li r3, 0xd4
	ctx.r[3].s64 = 212;
	// 82EC7D1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC7D20: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC7D24: 4B74EC05  bl 0x82616928
	ctx.lr = 0x82EC7D28;
	sub_82616928(ctx, base);
	// 82EC7D28: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC7D2C: 4182002C  beq 0x82ec7d58
	if ctx.cr[0].eq {
	pc = 0x82EC7D58; continue 'dispatch;
	}
	// 82EC7D30: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC7D34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC7D38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC7D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7D40: 4BFFEEC9  bl 0x82ec6c08
	ctx.lr = 0x82EC7D44;
	sub_82EC6C08(ctx, base);
	// 82EC7D44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC7D48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7D4C: 396B2DBC  addi r11, r11, 0x2dbc
	ctx.r[11].s64 = ctx.r[11].s64 + 11708;
	// 82EC7D50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC7D54: 48000008  b 0x82ec7d5c
	pc = 0x82EC7D5C; continue 'dispatch;
	// 82EC7D58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC7D5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC7D60: 4BDE16F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC7D68 size=92
    let mut pc: u32 = 0x82EC7D68;
    'dispatch: loop {
        match pc {
            0x82EC7D68 => {
    //   block [0x82EC7D68..0x82EC7DC4)
	// 82EC7D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC7D70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC7D74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC7D78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC7D80: 4BFBEFB9  bl 0x82e86d38
	ctx.lr = 0x82EC7D84;
	sub_82E86D38(ctx, base);
	// 82EC7D84: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC7D88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC7D8C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC7D90: 388BE284  addi r4, r11, -0x1d7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7548;
	// 82EC7D94: 4BFBF93D  bl 0x82e876d0
	ctx.lr = 0x82EC7D98;
	sub_82E876D0(ctx, base);
	// 82EC7D98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC7D9C: 907F00D8  stw r3, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 82EC7DA0: 40820008  bne 0x82ec7da8
	if !ctx.cr[0].eq {
	pc = 0x82EC7DA8; continue 'dispatch;
	}
	// 82EC7DA4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC7DA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC7DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC7DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC7DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC7DB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC7DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC7DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC7DC8 size=560
    let mut pc: u32 = 0x82EC7DC8;
    'dispatch: loop {
        match pc {
            0x82EC7DC8 => {
    //   block [0x82EC7DC8..0x82EC7FF8)
	// 82EC7DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC7DCC: 4BDE1625  bl 0x82ca93f0
	ctx.lr = 0x82EC7DD0;
	sub_82CA93D0(ctx, base);
	// 82EC7DD0: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC7DD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC7DD8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC7DDC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EC7DE0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC7DE4: 388BC4B4  addi r4, r11, -0x3b4c
	ctx.r[4].s64 = ctx.r[11].s64 + -15180;
	// 82EC7DE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC7DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7DF0: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82EC7DF4: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82EC7DF8: 4B320881  bl 0x821e8678
	ctx.lr = 0x82EC7DFC;
	sub_821E8678(ctx, base);
	// 82EC7DFC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC7E00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EC7E04: 3BCBC064  addi r30, r11, -0x3f9c
	ctx.r[30].s64 = ctx.r[11].s64 + -16284;
	// 82EC7E08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC7E0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC7E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7E14: 4B320865  bl 0x821e8678
	ctx.lr = 0x82EC7E18;
	sub_821E8678(ctx, base);
	// 82EC7E18: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC7E1C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC7E20: 388BD5FC  addi r4, r11, -0x2a04
	ctx.r[4].s64 = ctx.r[11].s64 + -10756;
	// 82EC7E24: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC7E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7E2C: 4B32084D  bl 0x821e8678
	ctx.lr = 0x82EC7E30;
	sub_821E8678(ctx, base);
	// 82EC7E30: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EC7E34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC7E38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC7E3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC7E40: 4B320839  bl 0x821e8678
	ctx.lr = 0x82EC7E44;
	sub_821E8678(ctx, base);
	// 82EC7E44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC7E48: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7E4C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EC7E50: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC7E54: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EC7E58: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7E5C: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82EC7E60: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EC7E64: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82EC7E68: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7E6C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC7E70: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EC7E74: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EC7E78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC7E7C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC7E80: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC7E84: 4200FFF8  bdnz 0x82ec7e7c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC7E7C; continue 'dispatch;
	}
	// 82EC7E88: 9AE100D8  stb r23, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[23].u8 ) };
	// 82EC7E8C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EC7E90: 419A0020  beq cr6, 0x82ec7eb0
	if ctx.cr[6].eq {
	pc = 0x82EC7EB0; continue 'dispatch;
	}
	// 82EC7E94: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7E98: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EC7E9C: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EA0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EC7EA4: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EA8: 9AE100D8  stb r23, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[23].u8 ) };
	// 82EC7EAC: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EC7EB0: C01D0034  lfs f0, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EB4: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 82EC7EB8: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC7EBC: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 82EC7EC0: C01D0038  lfs f0, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EC4: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82EC7EC8: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC7ECC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC7ED0: C01D003C  lfs f0, 0x3c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7ED4: D00100EC  stfs f0, 0xec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EC7ED8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC7EDC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC7EE0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC7EE4: 4200FFF8  bdnz 0x82ec7edc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC7EDC; continue 'dispatch;
	}
	// 82EC7EE8: 9AE10138  stb r23, 0x138(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[23].u8 ) };
	// 82EC7EEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC7EF0: 419A0020  beq cr6, 0x82ec7f10
	if ctx.cr[6].eq {
	pc = 0x82EC7F10; continue 'dispatch;
	}
	// 82EC7EF4: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7EF8: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC7EFC: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F00: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC7F04: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F08: 9AE10138  stb r23, 0x138(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[23].u8 ) };
	// 82EC7F0C: D00100EC  stfs f0, 0xec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EC7F10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC7F14: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82EC7F18: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EC7F1C: 3BCB1890  addi r30, r11, 0x1890
	ctx.r[30].s64 = ctx.r[11].s64 + 6288;
	// 82EC7F20: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EC7F24: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82EC7F28: 4B2E6781  bl 0x821ae6a8
	ctx.lr = 0x82EC7F2C;
	sub_821AE6A8(ctx, base);
	// 82EC7F2C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82EC7F30: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EC7F34: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82EC7F38: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EC7F3C: 4B2E676D  bl 0x821ae6a8
	ctx.lr = 0x82EC7F40;
	sub_821AE6A8(ctx, base);
	// 82EC7F40: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F44: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC7F48: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EC7F4C: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F50: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC7F54: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F58: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC7F5C: 419A005C  beq cr6, 0x82ec7fb8
	if ctx.cr[6].eq {
	pc = 0x82EC7FB8; continue 'dispatch;
	}
	// 82EC7F60: C05B0004  lfs f2, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EC7F64: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82EC7F68: C03B0008  lfs f1, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC7F6C: 419A001C  beq cr6, 0x82ec7f88
	if ctx.cr[6].eq {
	pc = 0x82EC7F88; continue 'dispatch;
	}
	// 82EC7F70: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F74: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC7F78: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F7C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC7F80: C01A000C  lfs f0, 0xc(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC7F84: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC7F88: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EC7F8C: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82EC7F90: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 82EC7F94: 4BFC1B8D  bl 0x82e89b20
	ctx.lr = 0x82EC7F98;
	sub_82E89B20(ctx, base);
	// 82EC7F98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC7F9C: 4082001C  bne 0x82ec7fb8
	if !ctx.cr[0].eq {
	pc = 0x82EC7FB8; continue 'dispatch;
	}
	// 82EC7FA0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EC7FA4: 9AF80000  stb r23, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[23].u8 ) };
	// 82EC7FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC7FAC: 9BF60000  stb r31, 0(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82EC7FB0: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82EC7FB4: 4BDE148C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 82EC7FB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC7FBC: 807900D8  lwz r3, 0xd8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(216 as u32) ) } as u64;
	// 82EC7FC0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EC7FC4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC7FC8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EC7FCC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC7FD0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC7FD4: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82EC7FD8: 4B4093D9  bl 0x822d13b0
	ctx.lr = 0x82EC7FDC;
	sub_822D13B0(ctx, base);
	// 82EC7FDC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC7FE0: 4082000C  bne 0x82ec7fec
	if !ctx.cr[0].eq {
	pc = 0x82EC7FEC; continue 'dispatch;
	}
	// 82EC7FE4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82EC7FE8: 4BFFFFC4  b 0x82ec7fac
	pc = 0x82EC7FAC; continue 'dispatch;
	// 82EC7FEC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC7FF0: 99780000  stb r11, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82EC7FF4: 4BFFFFB4  b 0x82ec7fa8
	pc = 0x82EC7FA8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC7FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC7FF8 size=12
    let mut pc: u32 = 0x82EC7FF8;
    'dispatch: loop {
        match pc {
            0x82EC7FF8 => {
    //   block [0x82EC7FF8..0x82EC8004)
	// 82EC7FF8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC7FFC: 386BE398  addi r3, r11, -0x1c68
	ctx.r[3].s64 = ctx.r[11].s64 + -7272;
	// 82EC8000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8008 size=88
    let mut pc: u32 = 0x82EC8008;
    'dispatch: loop {
        match pc {
            0x82EC8008 => {
    //   block [0x82EC8008..0x82EC8060)
	// 82EC8008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC800C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8010: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC8014: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8018: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC801C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8020: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC8024: 4BFFFA3D  bl 0x82ec7a60
	ctx.lr = 0x82EC8028;
	sub_82EC7A60(ctx, base);
	// 82EC8028: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC802C: 41820018  beq 0x82ec8044
	if ctx.cr[0].eq {
	pc = 0x82EC8044; continue 'dispatch;
	}
	// 82EC8030: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC8034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8038: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC803C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8040: 4E800421  bctrl
	ctx.lr = 0x82EC8044;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC8044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8048: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC804C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8054: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC8058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC805C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8060 size=100
    let mut pc: u32 = 0x82EC8060;
    'dispatch: loop {
        match pc {
            0x82EC8060 => {
    //   block [0x82EC8060..0x82EC80C4)
	// 82EC8060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8064: 4BDE13A5  bl 0x82ca9408
	ctx.lr = 0x82EC8068;
	sub_82CA93D0(ctx, base);
	// 82EC8068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC806C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC8070: 386000DC  li r3, 0xdc
	ctx.r[3].s64 = 220;
	// 82EC8074: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC8078: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC807C: 4B74E8AD  bl 0x82616928
	ctx.lr = 0x82EC8080;
	sub_82616928(ctx, base);
	// 82EC8080: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC8084: 41820034  beq 0x82ec80b8
	if ctx.cr[0].eq {
	pc = 0x82EC80B8; continue 'dispatch;
	}
	// 82EC8088: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC808C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC8090: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8098: 4BFFEB71  bl 0x82ec6c08
	ctx.lr = 0x82EC809C;
	sub_82EC6C08(ctx, base);
	// 82EC809C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC80A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC80A4: 396BB2F8  addi r11, r11, -0x4d08
	ctx.r[11].s64 = ctx.r[11].s64 + -19720;
	// 82EC80A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC80AC: 915F00D8  stw r10, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[10].u32 ) };
	// 82EC80B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC80B4: 48000008  b 0x82ec80bc
	pc = 0x82EC80BC; continue 'dispatch;
	// 82EC80B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC80BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC80C0: 4BDE1398  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC80C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC80C8 size=820
    let mut pc: u32 = 0x82EC80C8;
    'dispatch: loop {
        match pc {
            0x82EC80C8 => {
    //   block [0x82EC80C8..0x82EC83FC)
	// 82EC80C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC80CC: 4BDE1341  bl 0x82ca940c
	ctx.lr = 0x82EC80D0;
	sub_82CA93D0(ctx, base);
	// 82EC80D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC80D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC80D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC80DC: 4B75155D  bl 0x82619638
	ctx.lr = 0x82EC80E0;
	sub_82619638(ctx, base);
	// 82EC80E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC80E4: 4182000C  beq 0x82ec80f0
	if ctx.cr[0].eq {
	pc = 0x82EC80F0; continue 'dispatch;
	}
	// 82EC80E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC80EC: 48000308  b 0x82ec83f4
	pc = 0x82EC83F4; continue 'dispatch;
	// 82EC80F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC80F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC80F8: 3BCBB388  addi r30, r11, -0x4c78
	ctx.r[30].s64 = ctx.r[11].s64 + -19576;
	// 82EC80FC: 482F3F65  bl 0x831bc060
	ctx.lr = 0x82EC8100;
	sub_831BC060(ctx, base);
	// 82EC8100: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8104: 4BDE4A4D  bl 0x82cacb50
	ctx.lr = 0x82EC8108;
	sub_82CACB50(ctx, base);
	// 82EC8108: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC810C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8110: 40820024  bne 0x82ec8134
	if !ctx.cr[0].eq {
	pc = 0x82EC8134; continue 'dispatch;
	}
	// 82EC8114: 4BA45BF5  bl 0x8290dd08
	ctx.lr = 0x82EC8118;
	sub_8290DD08(ctx, base);
	// 82EC8118: 4BDE22A9  bl 0x82caa3c0
	ctx.lr = 0x82EC811C;
	sub_82CAA3C0(ctx, base);
	// 82EC811C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC8120: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8124: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC8128: 4182FFC0  beq 0x82ec80e8
	if ctx.cr[0].eq {
	pc = 0x82EC80E8; continue 'dispatch;
	}
	// 82EC812C: 907D000C  stw r3, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82EC8130: 4BFFFFB8  b 0x82ec80e8
	pc = 0x82EC80E8; continue 'dispatch;
	// 82EC8134: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8138: 3BCBB378  addi r30, r11, -0x4c88
	ctx.r[30].s64 = ctx.r[11].s64 + -19592;
	// 82EC813C: 482F3F25  bl 0x831bc060
	ctx.lr = 0x82EC8140;
	sub_831BC060(ctx, base);
	// 82EC8140: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8144: 4BDE4A0D  bl 0x82cacb50
	ctx.lr = 0x82EC8148;
	sub_82CACB50(ctx, base);
	// 82EC8148: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC814C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8150: 40820040  bne 0x82ec8190
	if !ctx.cr[0].eq {
	pc = 0x82EC8190; continue 'dispatch;
	}
	// 82EC8154: 4BA45BB5  bl 0x8290dd08
	ctx.lr = 0x82EC8158;
	sub_8290DD08(ctx, base);
	// 82EC8158: 4BDE3A59  bl 0x82cabbb0
	ctx.lr = 0x82EC815C;
	sub_82CABBB0(ctx, base);
	// 82EC815C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8160: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC8164: C00B0A7C  lfs f0, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8168: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC816C: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC8170: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8174: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC8178: 40990008  ble cr6, 0x82ec8180
	if !ctx.cr[6].gt {
	pc = 0x82EC8180; continue 'dispatch;
	}
	// 82EC817C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC8180: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC8184: 409AFFF0  bne cr6, 0x82ec8174
	if !ctx.cr[6].eq {
	pc = 0x82EC8174; continue 'dispatch;
	}
	// 82EC8188: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC818C: 4BFFFF5C  b 0x82ec80e8
	pc = 0x82EC80E8; continue 'dispatch;
	// 82EC8190: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8194: 3BCBB368  addi r30, r11, -0x4c98
	ctx.r[30].s64 = ctx.r[11].s64 + -19608;
	// 82EC8198: 482F3EC9  bl 0x831bc060
	ctx.lr = 0x82EC819C;
	sub_831BC060(ctx, base);
	// 82EC819C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC81A0: 4BDE49B1  bl 0x82cacb50
	ctx.lr = 0x82EC81A4;
	sub_82CACB50(ctx, base);
	// 82EC81A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC81A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC81AC: 40820040  bne 0x82ec81ec
	if !ctx.cr[0].eq {
	pc = 0x82EC81EC; continue 'dispatch;
	}
	// 82EC81B0: 4BA45B59  bl 0x8290dd08
	ctx.lr = 0x82EC81B4;
	sub_8290DD08(ctx, base);
	// 82EC81B4: 4BDE39FD  bl 0x82cabbb0
	ctx.lr = 0x82EC81B8;
	sub_82CABBB0(ctx, base);
	// 82EC81B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC81BC: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC81C0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC81C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC81C8: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC81CC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC81D0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC81D4: 40990008  ble cr6, 0x82ec81dc
	if !ctx.cr[6].gt {
	pc = 0x82EC81DC; continue 'dispatch;
	}
	// 82EC81D8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC81DC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC81E0: 409AFFF0  bne cr6, 0x82ec81d0
	if !ctx.cr[6].eq {
	pc = 0x82EC81D0; continue 'dispatch;
	}
	// 82EC81E4: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC81E8: 4BFFFF00  b 0x82ec80e8
	pc = 0x82EC80E8; continue 'dispatch;
	// 82EC81EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC81F0: 3BCB95B8  addi r30, r11, -0x6a48
	ctx.r[30].s64 = ctx.r[11].s64 + -27208;
	// 82EC81F4: 482F3E6D  bl 0x831bc060
	ctx.lr = 0x82EC81F8;
	sub_831BC060(ctx, base);
	// 82EC81F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC81FC: 4BDE4955  bl 0x82cacb50
	ctx.lr = 0x82EC8200;
	sub_82CACB50(ctx, base);
	// 82EC8200: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8208: 4082006C  bne 0x82ec8274
	if !ctx.cr[0].eq {
	pc = 0x82EC8274; continue 'dispatch;
	}
	// 82EC820C: 4BA45AFD  bl 0x8290dd08
	ctx.lr = 0x82EC8210;
	sub_8290DD08(ctx, base);
	// 82EC8210: 4BDE39A1  bl 0x82cabbb0
	ctx.lr = 0x82EC8214;
	sub_82CABBB0(ctx, base);
	// 82EC8214: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8218: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC821C: C00BBE10  lfs f0, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8220: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8224: D01D001C  stfs f0, 0x1c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC8228: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC822C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC8230: 40990008  ble cr6, 0x82ec8238
	if !ctx.cr[6].gt {
	pc = 0x82EC8238; continue 'dispatch;
	}
	// 82EC8234: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC8238: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC823C: 409AFFF0  bne cr6, 0x82ec822c
	if !ctx.cr[6].eq {
	pc = 0x82EC822C; continue 'dispatch;
	}
	// 82EC8240: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8244: D01D001C  stfs f0, 0x1c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC8248: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC824C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8250: 4182000C  beq 0x82ec825c
	if ctx.cr[0].eq {
	pc = 0x82EC825C; continue 'dispatch;
	}
	// 82EC8254: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8258: 4800000C  b 0x82ec8264
	pc = 0x82EC8264; continue 'dispatch;
	// 82EC825C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8260: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8264: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8268: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC826C: D01D001C  stfs f0, 0x1c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC8270: 48000184  b 0x82ec83f4
	pc = 0x82EC83F4; continue 'dispatch;
	// 82EC8274: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8278: 3BCBB354  addi r30, r11, -0x4cac
	ctx.r[30].s64 = ctx.r[11].s64 + -19628;
	// 82EC827C: 482F3DE5  bl 0x831bc060
	ctx.lr = 0x82EC8280;
	sub_831BC060(ctx, base);
	// 82EC8280: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8284: 4BDE48CD  bl 0x82cacb50
	ctx.lr = 0x82EC8288;
	sub_82CACB50(ctx, base);
	// 82EC8288: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC828C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8290: 40820070  bne 0x82ec8300
	if !ctx.cr[0].eq {
	pc = 0x82EC8300; continue 'dispatch;
	}
	// 82EC8294: 4BA45A75  bl 0x8290dd08
	ctx.lr = 0x82EC8298;
	sub_8290DD08(ctx, base);
	// 82EC8298: 4BDE3919  bl 0x82cabbb0
	ctx.lr = 0x82EC829C;
	sub_82CABBB0(ctx, base);
	// 82EC829C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC82A0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC82A4: C00B0AB4  lfs f0, 0xab4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC82A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC82AC: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC82B0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC82B4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC82B8: 41980008  blt cr6, 0x82ec82c0
	if ctx.cr[6].lt {
	pc = 0x82EC82C0; continue 'dispatch;
	}
	// 82EC82BC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC82C0: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC82C4: 409AFFF0  bne cr6, 0x82ec82b4
	if !ctx.cr[6].eq {
	pc = 0x82EC82B4; continue 'dispatch;
	}
	// 82EC82C8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC82CC: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC82D0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC82D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC82D8: 4182000C  beq 0x82ec82e4
	if ctx.cr[0].eq {
	pc = 0x82EC82E4; continue 'dispatch;
	}
	// 82EC82DC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC82E0: 4800000C  b 0x82ec82ec
	pc = 0x82EC82EC; continue 'dispatch;
	// 82EC82E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC82E8: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC82EC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC82F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC82F4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC82F8: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC82FC: 480000F8  b 0x82ec83f4
	pc = 0x82EC83F4; continue 'dispatch;
	// 82EC8300: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8304: 3BCBB348  addi r30, r11, -0x4cb8
	ctx.r[30].s64 = ctx.r[11].s64 + -19640;
	// 82EC8308: 482F3D59  bl 0x831bc060
	ctx.lr = 0x82EC830C;
	sub_831BC060(ctx, base);
	// 82EC830C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8310: 4BDE4841  bl 0x82cacb50
	ctx.lr = 0x82EC8314;
	sub_82CACB50(ctx, base);
	// 82EC8314: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8318: 408200D8  bne 0x82ec83f0
	if !ctx.cr[0].eq {
	pc = 0x82EC83F0; continue 'dispatch;
	}
	// 82EC831C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EC8320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8324: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82EC8328: 4BA459E1  bl 0x8290dd08
	ctx.lr = 0x82EC832C;
	sub_8290DD08(ctx, base);
	// 82EC832C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8330: 4BDE4821  bl 0x82cacb50
	ctx.lr = 0x82EC8334;
	sub_82CACB50(ctx, base);
	// 82EC8334: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8338: 418200AC  beq 0x82ec83e4
	if ctx.cr[0].eq {
	pc = 0x82EC83E4; continue 'dispatch;
	}
	// 82EC833C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8344: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82EC8348: 4BA459C1  bl 0x8290dd08
	ctx.lr = 0x82EC834C;
	sub_8290DD08(ctx, base);
	// 82EC834C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8350: 4BDE4801  bl 0x82cacb50
	ctx.lr = 0x82EC8354;
	sub_82CACB50(ctx, base);
	// 82EC8354: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8358: 4182008C  beq 0x82ec83e4
	if ctx.cr[0].eq {
	pc = 0x82EC83E4; continue 'dispatch;
	}
	// 82EC835C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EC8360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8364: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82EC8368: 4BA459A1  bl 0x8290dd08
	ctx.lr = 0x82EC836C;
	sub_8290DD08(ctx, base);
	// 82EC836C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8370: 4BDE47E1  bl 0x82cacb50
	ctx.lr = 0x82EC8374;
	sub_82CACB50(ctx, base);
	// 82EC8374: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8378: 4182006C  beq 0x82ec83e4
	if ctx.cr[0].eq {
	pc = 0x82EC83E4; continue 'dispatch;
	}
	// 82EC837C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EC8380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8384: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82EC8388: 4BA45981  bl 0x8290dd08
	ctx.lr = 0x82EC838C;
	sub_8290DD08(ctx, base);
	// 82EC838C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8390: 4BDE47C1  bl 0x82cacb50
	ctx.lr = 0x82EC8394;
	sub_82CACB50(ctx, base);
	// 82EC8394: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8398: 41820044  beq 0x82ec83dc
	if ctx.cr[0].eq {
	pc = 0x82EC83DC; continue 'dispatch;
	}
	// 82EC839C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EC83A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC83A4: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82EC83A8: 4BA45961  bl 0x8290dd08
	ctx.lr = 0x82EC83AC;
	sub_8290DD08(ctx, base);
	// 82EC83AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC83B0: 4BDE47A1  bl 0x82cacb50
	ctx.lr = 0x82EC83B4;
	sub_82CACB50(ctx, base);
	// 82EC83B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC83B8: 41820024  beq 0x82ec83dc
	if ctx.cr[0].eq {
	pc = 0x82EC83DC; continue 'dispatch;
	}
	// 82EC83BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EC83C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC83C4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82EC83C8: 4BA45941  bl 0x8290dd08
	ctx.lr = 0x82EC83CC;
	sub_8290DD08(ctx, base);
	// 82EC83CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC83D0: 4BDE4781  bl 0x82cacb50
	ctx.lr = 0x82EC83D4;
	sub_82CACB50(ctx, base);
	// 82EC83D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC83D8: 40820018  bne 0x82ec83f0
	if !ctx.cr[0].eq {
	pc = 0x82EC83F0; continue 'dispatch;
	}
	// 82EC83DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC83E0: 48000008  b 0x82ec83e8
	pc = 0x82EC83E8; continue 'dispatch;
	// 82EC83E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC83E8: 997D0020  stb r11, 0x20(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82EC83EC: 4BFFFCFC  b 0x82ec80e8
	pc = 0x82EC80E8; continue 'dispatch;
	// 82EC83F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC83F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC83F8: 4BDE1064  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC8400 size=228
    let mut pc: u32 = 0x82EC8400;
    'dispatch: loop {
        match pc {
            0x82EC8400 => {
    //   block [0x82EC8400..0x82EC84E4)
	// 82EC8400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8408: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC840C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8410: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8418: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC841C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC8420: 4B2FBEC9  bl 0x821c42e8
	ctx.lr = 0x82EC8424;
	sub_821C42E8(ctx, base);
	// 82EC8424: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8428: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC842C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC8430: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC8434: 40980098  bge cr6, 0x82ec84cc
	if !ctx.cr[6].lt {
	pc = 0x82EC84CC; continue 'dispatch;
	}
	// 82EC8438: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC843C: 7D6A19D6  mullw r11, r10, r3
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[3].s32 as i64);
	// 82EC8440: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EC8444: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EC8448: 40980084  bge cr6, 0x82ec84cc
	if !ctx.cr[6].lt {
	pc = 0x82EC84CC; continue 'dispatch;
	}
	// 82EC844C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8450: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC8454: 7D2A3A14  add r9, r10, r7
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82EC8458: 3949000C  addi r10, r9, 0xc
	ctx.r[10].s64 = ctx.r[9].s64 + 12;
	// 82EC845C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC8460: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC8464: 419A0044  beq cr6, 0x82ec84a8
	if ctx.cr[6].eq {
	pc = 0x82EC84A8; continue 'dispatch;
	}
	// 82EC8468: C00AFFF8  lfs f0, -8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC846C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8470: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC8474: 409A0028  bne cr6, 0x82ec849c
	if !ctx.cr[6].eq {
	pc = 0x82EC849C; continue 'dispatch;
	}
	// 82EC8478: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC847C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8480: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC8484: 409A0018  bne cr6, 0x82ec849c
	if !ctx.cr[6].eq {
	pc = 0x82EC849C; continue 'dispatch;
	}
	// 82EC8488: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC848C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EC8490: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8494: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC8498: 419A0008  beq cr6, 0x82ec84a0
	if ctx.cr[6].eq {
	pc = 0x82EC84A0; continue 'dispatch;
	}
	// 82EC849C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC84A0: 5508063F  clrlwi. r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EC84A4: 4082001C  bne 0x82ec84c0
	if !ctx.cr[0].eq {
	pc = 0x82EC84C0; continue 'dispatch;
	}
	// 82EC84A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC84AC: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 82EC84B0: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82EC84B4: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EC84B8: 4198FFA4  blt cr6, 0x82ec845c
	if ctx.cr[6].lt {
	pc = 0x82EC845C; continue 'dispatch;
	}
	// 82EC84BC: 48000010  b 0x82ec84cc
	pc = 0x82EC84CC; continue 'dispatch;
	// 82EC84C0: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC84C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC84C8: 7D4B392E  stwx r10, r11, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u32) };
	// 82EC84CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC84D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC84D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC84D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC84DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC84E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC84E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC84E8 size=132
    let mut pc: u32 = 0x82EC84E8;
    'dispatch: loop {
        match pc {
            0x82EC84E8 => {
    //   block [0x82EC84E8..0x82EC856C)
	// 82EC84E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC84EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC84F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC84F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC84F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC84FC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC8500: 4B2FBDE9  bl 0x821c42e8
	ctx.lr = 0x82EC8504;
	sub_821C42E8(ctx, base);
	// 82EC8504: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8508: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC850C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC8510: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC8514: 40980044  bge cr6, 0x82ec8558
	if !ctx.cr[6].lt {
	pc = 0x82EC8558; continue 'dispatch;
	}
	// 82EC8518: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC851C: 7D6A19D6  mullw r11, r10, r3
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[3].s32 as i64);
	// 82EC8520: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EC8524: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC8528: 40980030  bge cr6, 0x82ec8558
	if !ctx.cr[6].lt {
	pc = 0x82EC8558; continue 'dispatch;
	}
	// 82EC852C: 55692834  slwi r9, r11, 5
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC8530: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC8534: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8538: 7D0B482E  lwzx r8, r11, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC853C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC8540: 419A000C  beq cr6, 0x82ec854c
	if ctx.cr[6].eq {
	pc = 0x82EC854C; continue 'dispatch;
	}
	// 82EC8544: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC8548: 7D0B492E  stwx r8, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 82EC854C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC8550: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 82EC8554: 4082FFE0  bne 0x82ec8534
	if !ctx.cr[0].eq {
	pc = 0x82EC8534; continue 'dispatch;
	}
	// 82EC8558: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC855C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC8570 size=208
    let mut pc: u32 = 0x82EC8570;
    'dispatch: loop {
        match pc {
            0x82EC8570 => {
    //   block [0x82EC8570..0x82EC8640)
	// 82EC8570: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82EC8574: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82EC8578: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC857C: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC8580: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC8584: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8588: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC858C: 7CAB49D7  mullw. r5, r11, r9
	ctx.r[5].s64 = (ctx.r[11].s32 as i64) * (ctx.r[9].s32 as i64);
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82EC8590: 418200A4  beq 0x82ec8634
	if ctx.cr[0].eq {
	pc = 0x82EC8634; continue 'dispatch;
	}
	// 82EC8594: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EC8598: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82EC859C: 38E9DBFC  addi r7, r9, -0x2404
	ctx.r[7].s64 = ctx.r[9].s64 + -9220;
	// 82EC85A0: 3D207FFF  lis r9, 0x7fff
	ctx.r[9].s64 = 2147418112;
	// 82EC85A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EC85A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC85AC: C1A40BEC  lfs f13, 0xbec(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC85B0: 6128FFFF  ori r8, r9, 0xffff
	ctx.r[8].u64 = ctx.r[9].u64 | 65535;
	// 82EC85B4: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC85B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC85BC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EC85C0: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82EC85C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC85C8: 7FC9592E  stwx r30, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u32) };
	// 82EC85CC: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC85D0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC85D4: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EC85D8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC85DC: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC85E0: C0070004  lfs f0, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC85E4: D0090008  stfs f0, 8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC85E8: C0070008  lfs f0, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC85EC: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC85F0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC85F4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC85F8: D1A90010  stfs f13, 0x10(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC85FC: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8600: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC8604: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC8608: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC860C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC8610: 91090018  stw r8, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC8614: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8618: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EC861C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82EC8620: 9089001C  stw r4, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EC8624: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8628: 7FE9312E  stwx r31, r9, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32), ctx.r[31].u32) };
	// 82EC862C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC8630: 4198FF84  blt cr6, 0x82ec85b4
	if ctx.cr[6].lt {
	pc = 0x82EC85B4; continue 'dispatch;
	}
	// 82EC8634: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8638: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82EC863C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC8640 size=4
    let mut pc: u32 = 0x82EC8640;
    'dispatch: loop {
        match pc {
            0x82EC8640 => {
    //   block [0x82EC8640..0x82EC8644)
	// 82EC8640: 4BFFFF30  b 0x82ec8570
	sub_82EC8570(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC8648 size=16
    let mut pc: u32 = 0x82EC8648;
    'dispatch: loop {
        match pc {
            0x82EC8648 => {
    //   block [0x82EC8648..0x82EC8658)
	// 82EC8648: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC864C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC8650: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EC8654: 4BFFFE94  b 0x82ec84e8
	sub_82EC84E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC8658 size=828
    let mut pc: u32 = 0x82EC8658;
    'dispatch: loop {
        match pc {
            0x82EC8658 => {
    //   block [0x82EC8658..0x82EC8994)
	// 82EC8658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC865C: 4BDE0D95  bl 0x82ca93f0
	ctx.lr = 0x82EC8660;
	sub_82CA93D0(ctx, base);
	// 82EC8660: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8664: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC866C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EC8670: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8674: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 82EC8678: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC867C: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC8680: 617BFFFF  ori r27, r11, 0xffff
	ctx.r[27].u64 = ctx.r[11].u64 | 65535;
	// 82EC8684: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC8688: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC868C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC8690: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC8694: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82EC8698: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82EC869C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82EC86A0: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC86A4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC86A8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC86AC: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82EC86B0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EC86B4: 4098029C  bge cr6, 0x82ec8950
	if !ctx.cr[6].lt {
	pc = 0x82EC8950; continue 'dispatch;
	}
	// 82EC86B8: 82DF0030  lwz r22, 0x30(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC86BC: 3F008334  lis r24, -0x7ccc
	ctx.r[24].s64 = -2093744128;
	// 82EC86C0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC86C4: 7F0BB000  cmpw cr6, r11, r22
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[22].s32, &mut ctx.xer);
	// 82EC86C8: 40980260  bge cr6, 0x82ec8928
	if !ctx.cr[6].lt {
	pc = 0x82EC8928; continue 'dispatch;
	}
	// 82EC86CC: 835F0034  lwz r26, 0x34(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC86D0: 833F0038  lwz r25, 0x38(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC86D4: 83DF003C  lwz r30, 0x3c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC86D8: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82EC86DC: 7F1ED800  cmpw cr6, r30, r27
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82EC86E0: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82EC86E4: 409A00C8  bne cr6, 0x82ec87ac
	if !ctx.cr[6].eq {
	pc = 0x82EC87AC; continue 'dispatch;
	}
	// 82EC86E8: 92FF003C  stw r23, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[23].u32 ) };
	// 82EC86EC: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC86F0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC86F4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC86F8: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82EC86FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC8700: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EC8704: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EC8708: 40990060  ble cr6, 0x82ec8768
	if !ctx.cr[6].gt {
	pc = 0x82EC8768; continue 'dispatch;
	}
	// 82EC870C: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8710: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8714: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC8718: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC871C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EC8720: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC8724: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82EC8728: 7FCB0194  addze r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	// 82EC872C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8730: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EC8734: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8738: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EC873C: 4B2FB715  bl 0x821c3e50
	ctx.lr = 0x82EC8740;
	sub_821C3E50(ctx, base);
	// 82EC8740: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8744: 4080000C  bge 0x82ec8750
	if !ctx.cr[0].lt {
	pc = 0x82EC8750; continue 'dispatch;
	}
	// 82EC8748: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82EC874C: 48000008  b 0x82ec8754
	pc = 0x82EC8754; continue 'dispatch;
	// 82EC8750: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82EC8754: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EC8758: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC875C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EC8760: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EC8764: 4199FFB0  bgt cr6, 0x82ec8714
	if ctx.cr[6].gt {
	pc = 0x82EC8714; continue 'dispatch;
	}
	// 82EC8768: 83DF003C  lwz r30, 0x3c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC876C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC8770: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8774: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC8778: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC877C: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC8780: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8784: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC8788: 4B2FB6C9  bl 0x821c3e50
	ctx.lr = 0x82EC878C;
	sub_821C3E50(ctx, base);
	// 82EC878C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC8790: 4181000C  bgt 0x82ec879c
	if ctx.cr[0].gt {
	pc = 0x82EC879C; continue 'dispatch;
	}
	// 82EC8794: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82EC8798: 4800000C  b 0x82ec87a4
	pc = 0x82EC87A4; continue 'dispatch;
	// 82EC879C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EC87A0: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EC87A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC87A8: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 82EC87AC: 897F0048  lbz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC87B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC87B4: 418200AC  beq 0x82ec8860
	if ctx.cr[0].eq {
	pc = 0x82EC8860; continue 'dispatch;
	}
	// 82EC87B8: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC87BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC87C0: 41980094  blt cr6, 0x82ec8854
	if ctx.cr[6].lt {
	pc = 0x82EC8854; continue 'dispatch;
	}
	// 82EC87C4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC87C8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC87CC: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC87D0: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC87D4: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC87D8: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC87DC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EC87E0: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC87E4: 7F07D000  cmpw cr6, r7, r26
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82EC87E8: 409A006C  bne cr6, 0x82ec8854
	if !ctx.cr[6].eq {
	pc = 0x82EC8854; continue 'dispatch;
	}
	// 82EC87EC: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC87F0: 7F07C800  cmpw cr6, r7, r25
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82EC87F4: 409A0060  bne cr6, 0x82ec8854
	if !ctx.cr[6].eq {
	pc = 0x82EC8854; continue 'dispatch;
	}
	// 82EC87F8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC87FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EC8800: 419A0040  beq cr6, 0x82ec8840
	if ctx.cr[6].eq {
	pc = 0x82EC8840; continue 'dispatch;
	}
	// 82EC8804: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8808: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC880C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC8810: C19F0050  lfs f12, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8814: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8818: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC881C: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC8820: C19F0054  lfs f12, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8824: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC8828: C17F0058  lfs f11, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC882C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8830: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC8834: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC8838: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC883C: 41980120  blt cr6, 0x82ec895c
	if ctx.cr[6].lt {
	pc = 0x82EC895C; continue 'dispatch;
	}
	// 82EC8840: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 82EC8844: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EC8848: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC884C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC8850: 4098FF7C  bge cr6, 0x82ec87cc
	if !ctx.cr[6].lt {
	pc = 0x82EC87CC; continue 'dispatch;
	}
	// 82EC8854: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82EC8858: 9AFF0048  stb r23, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[23].u8 ) };
	// 82EC885C: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EC8860: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8864: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC8868: 813F0044  lwz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC886C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC8870: 7CEB51D6  mullw r7, r11, r10
	ctx.r[7].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82EC8874: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EC8878: 40980094  bge cr6, 0x82ec890c
	if !ctx.cr[6].lt {
	pc = 0x82EC890C; continue 'dispatch;
	}
	// 82EC887C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8880: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8884: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC8888: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC888C: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC8890: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8894: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EC8898: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC889C: 7F06D000  cmpw cr6, r6, r26
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82EC88A0: 409A006C  bne cr6, 0x82ec890c
	if !ctx.cr[6].eq {
	pc = 0x82EC890C; continue 'dispatch;
	}
	// 82EC88A4: 80CB0018  lwz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC88A8: 7F06C800  cmpw cr6, r6, r25
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82EC88AC: 409A0060  bne cr6, 0x82ec890c
	if !ctx.cr[6].eq {
	pc = 0x82EC890C; continue 'dispatch;
	}
	// 82EC88B0: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC88B4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EC88B8: 419A0040  beq cr6, 0x82ec88f8
	if ctx.cr[6].eq {
	pc = 0x82EC88F8; continue 'dispatch;
	}
	// 82EC88BC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC88C0: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC88C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC88C8: C19F0050  lfs f12, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC88CC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC88D0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC88D4: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC88D8: C19F0054  lfs f12, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC88DC: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC88E0: C17F0058  lfs f11, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC88E4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC88E8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC88EC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC88F0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC88F4: 41980090  blt cr6, 0x82ec8984
	if ctx.cr[6].lt {
	pc = 0x82EC8984; continue 'dispatch;
	}
	// 82EC88F8: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82EC88FC: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EC8900: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8904: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EC8908: 4198FF7C  blt cr6, 0x82ec8884
	if ctx.cr[6].lt {
	pc = 0x82EC8884; continue 'dispatch;
	}
	// 82EC890C: 39790001  addi r11, r25, 1
	ctx.r[11].s64 = ctx.r[25].s64 + 1;
	// 82EC8910: 937F003C  stw r27, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	// 82EC8914: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EC8918: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC891C: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC8920: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC8924: 4198FDAC  blt cr6, 0x82ec86d0
	if ctx.cr[6].lt {
	pc = 0x82EC86D0; continue 'dispatch;
	}
	// 82EC8928: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC892C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EC8930: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC8934: 937F003C  stw r27, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	// 82EC8938: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82EC893C: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EC8940: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC8944: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC8948: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC894C: 4198FD74  blt cr6, 0x82ec86c0
	if ctx.cr[6].lt {
	pc = 0x82EC86C0; continue 'dispatch;
	}
	// 82EC8950: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC8954: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC8958: 4BDE0AE8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 82EC895C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC8960: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC8964: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC8968: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC896C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8970: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC8974: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EC8978: 552B2834  slwi r11, r9, 5
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC897C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC8980: 4BFFFFD4  b 0x82ec8954
	pc = 0x82EC8954; continue 'dispatch;
	// 82EC8984: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC8988: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC898C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC8990: 4BFFFFD8  b 0x82ec8968
	pc = 0x82EC8968; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC8998 size=88
    let mut pc: u32 = 0x82EC8998;
    'dispatch: loop {
        match pc {
            0x82EC8998 => {
    //   block [0x82EC8998..0x82EC89F0)
	// 82EC8998: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC899C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC89A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC89A4: 396B1B30  addi r11, r11, 0x1b30
	ctx.r[11].s64 = ctx.r[11].s64 + 6960;
	// 82EC89A8: C00A0A7C  lfs f0, 0xa7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC89AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC89B0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC89B4: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC89B8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EC89BC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC89C0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC89C4: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC89C8: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82EC89CC: D1A30014  stfs f13, 0x14(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC89D0: C1A90C14  lfs f13, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC89D4: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EC89D8: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC89DC: 816A0718  lwz r11, 0x718(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC89E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC89E4: 4182000C  beq 0x82ec89f0
	if ctx.cr[0].eq {
		sub_82EC89F0(ctx, base);
		return;
	}
	// 82EC89E8: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC89EC: 48000008  b 0x82ec89f4
	sub_82EC89F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC89F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC89F0 size=20
    let mut pc: u32 = 0x82EC89F0;
    'dispatch: loop {
        match pc {
            0x82EC89F0 => {
    //   block [0x82EC89F0..0x82EC8A04)
	// 82EC89F0: FD806890  fmr f12, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82EC89F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC89F8: 4182000C  beq 0x82ec8a04
	if ctx.cr[0].eq {
		sub_82EC8A04(ctx, base);
		return;
	}
	// 82EC89FC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8A00: 48000008  b 0x82ec8a08
	sub_82EC8A04(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8A04(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC8A04 size=88
    let mut pc: u32 = 0x82EC8A04;
    'dispatch: loop {
        match pc {
            0x82EC8A04 => {
    //   block [0x82EC8A04..0x82EC8A5C)
	// 82EC8A04: FC006890  fmr f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC8A08: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC8A0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8A10: C00B0C70  lfs f0, 0xc70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8A14: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8A18: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC8A1C: 816A0718  lwz r11, 0x718(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8A20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8A24: 41820008  beq 0x82ec8a2c
	if ctx.cr[0].eq {
	pc = 0x82EC8A2C; continue 'dispatch;
	}
	// 82EC8A28: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8A2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8A30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC8A34: C00BBE10  lfs f0, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8A38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8A3C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8A40: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC8A44: 99430020  stb r10, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82EC8A48: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8A4C: D003004C  stfs f0, 0x4c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC8A50: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC8A54: D0030054  stfs f0, 0x54(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC8A58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8A60 size=148
    let mut pc: u32 = 0x82EC8A60;
    'dispatch: loop {
        match pc {
            0x82EC8A60 => {
    //   block [0x82EC8A60..0x82EC8AF4)
	// 82EC8A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8A68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC8A6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8A70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8A74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8A78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8A7C: 396B1B30  addi r11, r11, 0x1b30
	ctx.r[11].s64 = ctx.r[11].s64 + 6960;
	// 82EC8A80: 3D4082ED  lis r10, -0x7d13
	ctx.r[10].s64 = -2098397184;
	// 82EC8A84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EC8A88: 388A8648  addi r4, r10, -0x79b8
	ctx.r[4].s64 = ctx.r[10].s64 + -31160;
	// 82EC8A8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC8A90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8A94: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8A98: 4BFBA6D1  bl 0x82e83168
	ctx.lr = 0x82EC8A9C;
	sub_82E83168(ctx, base);
	// 82EC8A9C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8AA0: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82EC8AA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8AA8: 41820010  beq 0x82ec8ab8
	if ctx.cr[0].eq {
	pc = 0x82EC8AB8; continue 'dispatch;
	}
	// 82EC8AAC: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC8AB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8AB4: 4E800421  bctrl
	ctx.lr = 0x82EC8AB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC8AB8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8ABC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8AC0: 41820010  beq 0x82ec8ad0
	if ctx.cr[0].eq {
	pc = 0x82EC8AD0; continue 'dispatch;
	}
	// 82EC8AC4: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC8AC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8ACC: 4E800421  bctrl
	ctx.lr = 0x82EC8AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC8AD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC8AD4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC8AD8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC8ADC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC8AE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8AE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8AE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC8AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC8AF8 size=328
    let mut pc: u32 = 0x82EC8AF8;
    'dispatch: loop {
        match pc {
            0x82EC8AF8 => {
    //   block [0x82EC8AF8..0x82EC8C40)
	// 82EC8AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8AFC: 4BDE090D  bl 0x82ca9408
	ctx.lr = 0x82EC8B00;
	sub_82CA93D0(ctx, base);
	// 82EC8B00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8B04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC8B08: 4BFBC8A1  bl 0x82e853a8
	ctx.lr = 0x82EC8B0C;
	sub_82E853A8(ctx, base);
	// 82EC8B0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC8B10: 4082000C  bne 0x82ec8b1c
	if !ctx.cr[0].eq {
	pc = 0x82EC8B1C; continue 'dispatch;
	}
	// 82EC8B14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC8B18: 48000120  b 0x82ec8c38
	pc = 0x82EC8C38; continue 'dispatch;
	// 82EC8B1C: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82EC8B20: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC8B24: 3D4007FF  lis r10, 0x7ff
	ctx.r[10].s64 = 134152192;
	// 82EC8B28: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82EC8B2C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EC8B30: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8B34: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC8B38: 7FEB49D6  mullw r31, r11, r9
	ctx.r[31].s64 = (ctx.r[11].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82EC8B3C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC8B40: 57E32834  slwi r3, r31, 5
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EC8B44: 40990008  ble cr6, 0x82ec8b4c
	if !ctx.cr[6].gt {
	pc = 0x82EC8B4C; continue 'dispatch;
	}
	// 82EC8B48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC8B4C: 4B74DDDD  bl 0x82616928
	ctx.lr = 0x82EC8B50;
	sub_82616928(ctx, base);
	// 82EC8B50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8B54: 41820060  beq 0x82ec8bb4
	if ctx.cr[0].eq {
	pc = 0x82EC8BB4; continue 'dispatch;
	}
	// 82EC8B58: 353FFFFF  addic. r9, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC8B5C: 41800050  blt 0x82ec8bac
	if ctx.cr[0].lt {
	pc = 0x82EC8BAC; continue 'dispatch;
	}
	// 82EC8B60: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82EC8B64: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EC8B68: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 82EC8B6C: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 82EC8B70: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EC8B74: C1A70BEC  lfs f13, 0xbec(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8B78: C0080C18  lfs f0, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8B7C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC8B80: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC8B84: 910BFFF4  stw r8, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 82EC8B88: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EC8B8C: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EC8B90: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC8B94: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC8B98: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC8B9C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EC8BA0: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82EC8BA4: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82EC8BA8: 4080FFD4  bge 0x82ec8b7c
	if !ctx.cr[0].lt {
	pc = 0x82EC8B7C; continue 'dispatch;
	}
	// 82EC8BAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC8BB0: 48000008  b 0x82ec8bb8
	pc = 0x82EC8BB8; continue 'dispatch;
	// 82EC8BB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC8BB8: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EC8BBC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC8BC0: 57E3103A  slwi r3, r31, 2
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EC8BC4: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EC8BC8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC8BCC: 40990008  ble cr6, 0x82ec8bd4
	if !ctx.cr[6].gt {
	pc = 0x82EC8BD4; continue 'dispatch;
	}
	// 82EC8BD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC8BD4: 4B74DD55  bl 0x82616928
	ctx.lr = 0x82EC8BD8;
	sub_82616928(ctx, base);
	// 82EC8BD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC8BDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC8BE0: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EC8BE4: 419A003C  beq cr6, 0x82ec8c20
	if ctx.cr[6].eq {
	pc = 0x82EC8C20; continue 'dispatch;
	}
	// 82EC8BE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC8BEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC8BF0: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8BF4: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EC8BF8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC8BFC: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82EC8C00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC8C04: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82EC8C08: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EC8C0C: 90E8001C  stw r7, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82EC8C10: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC8C14: 7CC9412E  stwx r6, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[6].u32) };
	// 82EC8C18: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC8C1C: 4198FFD4  blt cr6, 0x82ec8bf0
	if ctx.cr[6].lt {
	pc = 0x82EC8BF0; continue 'dispatch;
	}
	// 82EC8C20: 3D6082ED  lis r11, -0x7d13
	ctx.r[11].s64 = -2098397184;
	// 82EC8C24: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC8C28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC8C2C: 388B8648  addi r4, r11, -0x79b8
	ctx.r[4].s64 = ctx.r[11].s64 + -31160;
	// 82EC8C30: 4BFBA3D9  bl 0x82e83008
	ctx.lr = 0x82EC8C34;
	sub_82E83008(ctx, base);
	// 82EC8C34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC8C38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC8C3C: 4BDE081C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC8C40 size=340
    let mut pc: u32 = 0x82EC8C40;
    'dispatch: loop {
        match pc {
            0x82EC8C40 => {
    //   block [0x82EC8C40..0x82EC8D94)
	// 82EC8C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8C48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8C4C: EC00082C  fsqrts f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64).sqrt() as f32) as f64;
	// 82EC8C50: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8C54: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC8C58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC8C5C: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8C60: ED2C0028  fsubs f9, f12, f0
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC8C64: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC8C68: C143001C  lfs f10, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC8C6C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC8C70: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8C74: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82EC8C78: ED6B5024  fdivs f11, f11, f10
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC8C7C: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82EC8C80: 41980014  blt cr6, 0x82ec8c94
	if ctx.cr[6].lt {
	pc = 0x82EC8C94; continue 'dispatch;
	}
	// 82EC8C84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8C88: 7D605FAE  stfiwx f11, 0, r11
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8C8C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8C90: 48000014  b 0x82ec8ca4
	pc = 0x82EC8CA4; continue 'dispatch;
	// 82EC8C94: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8C98: 7D605FAE  stfiwx f11, 0, r11
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8C9C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8CA0: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82EC8CA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC8CA8: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 82EC8CAC: EDAD5024  fdivs f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC8CB0: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82EC8CB4: 41980014  blt cr6, 0x82ec8cc8
	if ctx.cr[6].lt {
	pc = 0x82EC8CC8; continue 'dispatch;
	}
	// 82EC8CB8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8CBC: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8CC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8CC4: 48000014  b 0x82ec8cd8
	pc = 0x82EC8CD8; continue 'dispatch;
	// 82EC8CC8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8CCC: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8CD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8CD4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC8CD8: EDA95024  fdivs f13, f9, f10
	ctx.f[13].f64 = ((ctx.f[9].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC8CDC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC8CE0: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82EC8CE4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EC8CE8: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82EC8CEC: 41980014  blt cr6, 0x82ec8d00
	if ctx.cr[6].lt {
	pc = 0x82EC8D00; continue 'dispatch;
	}
	// 82EC8CF0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8CF4: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8CF8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8CFC: 48000014  b 0x82ec8d10
	pc = 0x82EC8D10; continue 'dispatch;
	// 82EC8D00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8D04: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8D08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8D0C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82EC8D10: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EC8D14: 9143002C  stw r10, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82EC8D18: EC0C5024  fdivs f0, f12, f10
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC8D1C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EC8D20: 41980014  blt cr6, 0x82ec8d34
	if ctx.cr[6].lt {
	pc = 0x82EC8D34; continue 'dispatch;
	}
	// 82EC8D24: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8D28: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8D2C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8D30: 48000014  b 0x82ec8d44
	pc = 0x82EC8D44; continue 'dispatch;
	// 82EC8D34: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC8D38: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EC8D3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC8D40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC8D44: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82EC8D48: 91230034  stw r9, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 82EC8D4C: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 82EC8D50: 91430038  stw r10, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82EC8D54: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EC8D58: 91030030  stw r8, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 82EC8D5C: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8D60: D003004C  stfs f0, 0x4c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC8D64: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8D68: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC8D6C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8D70: D0030054  stfs f0, 0x54(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC8D74: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EC8D78: D0230058  stfs f1, 0x58(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC8D7C: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EC8D80: 4BFFF8D9  bl 0x82ec8658
	ctx.lr = 0x82EC8D84;
	sub_82EC8658(ctx, base);
	// 82EC8D84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC8D88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8D8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8D98 size=56
    let mut pc: u32 = 0x82EC8D98;
    'dispatch: loop {
        match pc {
            0x82EC8D98 => {
    //   block [0x82EC8D98..0x82EC8DD0)
	// 82EC8D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8DA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8DA4: 3860005C  li r3, 0x5c
	ctx.r[3].s64 = 92;
	// 82EC8DA8: 4B74DB81  bl 0x82616928
	ctx.lr = 0x82EC8DAC;
	sub_82616928(ctx, base);
	// 82EC8DAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8DB0: 4182000C  beq 0x82ec8dbc
	if ctx.cr[0].eq {
	pc = 0x82EC8DBC; continue 'dispatch;
	}
	// 82EC8DB4: 4BFFFBE5  bl 0x82ec8998
	ctx.lr = 0x82EC8DB8;
	sub_82EC8998(ctx, base);
	// 82EC8DB8: 48000008  b 0x82ec8dc0
	pc = 0x82EC8DC0; continue 'dispatch;
	// 82EC8DBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC8DC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC8DC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8DC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8DCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8DD0 size=88
    let mut pc: u32 = 0x82EC8DD0;
    'dispatch: loop {
        match pc {
            0x82EC8DD0 => {
    //   block [0x82EC8DD0..0x82EC8E28)
	// 82EC8DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8DD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC8DDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8DE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8DE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8DE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC8DEC: 4BFFFC75  bl 0x82ec8a60
	ctx.lr = 0x82EC8DF0;
	sub_82EC8A60(ctx, base);
	// 82EC8DF0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC8DF4: 41820018  beq 0x82ec8e0c
	if ctx.cr[0].eq {
	pc = 0x82EC8E0C; continue 'dispatch;
	}
	// 82EC8DF8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC8DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8E00: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC8E04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8E08: 4E800421  bctrl
	ctx.lr = 0x82EC8E0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC8E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8E10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC8E14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8E18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8E1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC8E20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8E24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8E28 size=156
    let mut pc: u32 = 0x82EC8E28;
    'dispatch: loop {
        match pc {
            0x82EC8E28 => {
    //   block [0x82EC8E28..0x82EC8EC4)
	// 82EC8E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8E2C: 4BDE05D5  bl 0x82ca9400
	ctx.lr = 0x82EC8E30;
	sub_82CA93D0(ctx, base);
	// 82EC8E30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8E34: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC8E38: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC8E3C: 3BEBC3A0  addi r31, r11, -0x3c60
	ctx.r[31].s64 = ctx.r[11].s64 + -15456;
	// 82EC8E40: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC8E44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC8E48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC8E4C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82EC8E50: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82EC8E54: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82EC8E58: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82EC8E5C: 4B31F81D  bl 0x821e8678
	ctx.lr = 0x82EC8E60;
	sub_821E8678(ctx, base);
	// 82EC8E60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8E64: 41820008  beq 0x82ec8e6c
	if ctx.cr[0].eq {
	pc = 0x82EC8E6C; continue 'dispatch;
	}
	// 82EC8E68: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8E6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC8E70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC8E74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC8E78: 4B31F801  bl 0x821e8678
	ctx.lr = 0x82EC8E7C;
	sub_821E8678(ctx, base);
	// 82EC8E7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8E80: 41820008  beq 0x82ec8e88
	if ctx.cr[0].eq {
	pc = 0x82EC8E88; continue 'dispatch;
	}
	// 82EC8E84: 83830004  lwz r28, 4(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC8E88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC8E8C: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82EC8E90: 419A001C  beq cr6, 0x82ec8eac
	if ctx.cr[6].eq {
	pc = 0x82EC8EAC; continue 'dispatch;
	}
	// 82EC8E94: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 82EC8E98: 419A0014  beq cr6, 0x82ec8eac
	if ctx.cr[6].eq {
	pc = 0x82EC8EAC; continue 'dispatch;
	}
	// 82EC8E9C: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82EC8EA0: 419A000C  beq cr6, 0x82ec8eac
	if ctx.cr[6].eq {
	pc = 0x82EC8EAC; continue 'dispatch;
	}
	// 82EC8EA4: 997B0000  stb r11, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82EC8EA8: 4800000C  b 0x82ec8eb4
	pc = 0x82EC8EB4; continue 'dispatch;
	// 82EC8EAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC8EB0: 995B0000  stb r10, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EC8EB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC8EB8: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82EC8EBC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC8EC0: 4BDE0590  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC8EC8 size=12
    let mut pc: u32 = 0x82EC8EC8;
    'dispatch: loop {
        match pc {
            0x82EC8EC8 => {
    //   block [0x82EC8EC8..0x82EC8ED4)
	// 82EC8EC8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC8ECC: 386BE5C0  addi r3, r11, -0x1a40
	ctx.r[3].s64 = ctx.r[11].s64 + -6720;
	// 82EC8ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8ED8 size=92
    let mut pc: u32 = 0x82EC8ED8;
    'dispatch: loop {
        match pc {
            0x82EC8ED8 => {
    //   block [0x82EC8ED8..0x82EC8F34)
	// 82EC8ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8EDC: 4BDE052D  bl 0x82ca9408
	ctx.lr = 0x82EC8EE0;
	sub_82CA93D0(ctx, base);
	// 82EC8EE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8EE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC8EE8: 386000D4  li r3, 0xd4
	ctx.r[3].s64 = 212;
	// 82EC8EEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC8EF0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC8EF4: 4B74DA35  bl 0x82616928
	ctx.lr = 0x82EC8EF8;
	sub_82616928(ctx, base);
	// 82EC8EF8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC8EFC: 4182002C  beq 0x82ec8f28
	if ctx.cr[0].eq {
	pc = 0x82EC8F28; continue 'dispatch;
	}
	// 82EC8F00: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC8F04: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC8F08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC8F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8F10: 4BFFDCF9  bl 0x82ec6c08
	ctx.lr = 0x82EC8F14;
	sub_82EC6C08(ctx, base);
	// 82EC8F14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8F1C: 396BB3B4  addi r11, r11, -0x4c4c
	ctx.r[11].s64 = ctx.r[11].s64 + -19532;
	// 82EC8F20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC8F24: 48000008  b 0x82ec8f2c
	pc = 0x82EC8F2C; continue 'dispatch;
	// 82EC8F28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC8F2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC8F30: 4BDE0528  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC8F38 size=72
    let mut pc: u32 = 0x82EC8F38;
    'dispatch: loop {
        match pc {
            0x82EC8F38 => {
    //   block [0x82EC8F38..0x82EC8F80)
	// 82EC8F38: C1A40034  lfs f13, 0x34(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8F3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC8F40: C0050034  lfs f0, 0x34(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC8F44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC8F48: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC8F4C: C1850038  lfs f12, 0x38(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8F50: C1A40038  lfs f13, 0x38(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC8F54: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC8F58: C164003C  lfs f11, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC8F5C: C185003C  lfs f12, 0x3c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC8F60: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC8F64: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC8F68: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC8F6C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC8F70: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC8F74: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC8F78: 99670000  stb r11, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82EC8F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8F80 size=100
    let mut pc: u32 = 0x82EC8F80;
    'dispatch: loop {
        match pc {
            0x82EC8F80 => {
    //   block [0x82EC8F80..0x82EC8FE4)
	// 82EC8F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8F88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8F8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC8F94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC8F98: 396BB408  addi r11, r11, -0x4bf8
	ctx.r[11].s64 = ctx.r[11].s64 + -19448;
	// 82EC8F9C: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC8FA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC8FA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC8FA8: 41820018  beq 0x82ec8fc0
	if ctx.cr[0].eq {
	pc = 0x82EC8FC0; continue 'dispatch;
	}
	// 82EC8FAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC8FB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC8FB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC8FB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC8FBC: 4E800421  bctrl
	ctx.lr = 0x82EC8FC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC8FC0: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82EC8FC4: 4BFF03BD  bl 0x82eb9380
	ctx.lr = 0x82EC8FC8;
	sub_82EB9380(ctx, base);
	// 82EC8FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC8FCC: 4BFBD72D  bl 0x82e866f8
	ctx.lr = 0x82EC8FD0;
	sub_82E866F8(ctx, base);
	// 82EC8FD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC8FD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC8FD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC8FDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC8FE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC8FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC8FE8 size=88
    let mut pc: u32 = 0x82EC8FE8;
    'dispatch: loop {
        match pc {
            0x82EC8FE8 => {
    //   block [0x82EC8FE8..0x82EC9040)
	// 82EC8FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC8FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC8FF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC8FF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC8FF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC8FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9000: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC9004: 4BFFFF7D  bl 0x82ec8f80
	ctx.lr = 0x82EC9008;
	sub_82EC8F80(ctx, base);
	// 82EC9008: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC900C: 41820018  beq 0x82ec9024
	if ctx.cr[0].eq {
	pc = 0x82EC9024; continue 'dispatch;
	}
	// 82EC9010: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC9014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9018: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC901C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9020: 4E800421  bctrl
	ctx.lr = 0x82EC9024;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC9024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9028: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC902C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC9030: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC9034: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC9038: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC903C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9040 size=80
    let mut pc: u32 = 0x82EC9040;
    'dispatch: loop {
        match pc {
            0x82EC9040 => {
    //   block [0x82EC9040..0x82EC9090)
	// 82EC9040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC9048: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC904C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9050: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC9054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9058: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC905C: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 82EC9060: 917F00B8  stw r11, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EC9064: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EC9068: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EC906C: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EC9070: 4BFF0311  bl 0x82eb9380
	ctx.lr = 0x82EC9074;
	sub_82EB9380(ctx, base);
	// 82EC9074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9078: 4BFFFF09  bl 0x82ec8f80
	ctx.lr = 0x82EC907C;
	sub_82EC8F80(ctx, base);
	// 82EC907C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC9080: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC9084: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC9088: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC908C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9090 size=204
    let mut pc: u32 = 0x82EC9090;
    'dispatch: loop {
        match pc {
            0x82EC9090 => {
    //   block [0x82EC9090..0x82EC915C)
	// 82EC9090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC9098: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC909C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC90A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC90A4: 480011B5  bl 0x82eca258
	ctx.lr = 0x82EC90A8;
	sub_82ECA258(ctx, base);
	// 82EC90A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC90AC: 395F007C  addi r10, r31, 0x7c
	ctx.r[10].s64 = ctx.r[31].s64 + 124;
	// 82EC90B0: 38EBB43C  addi r7, r11, -0x4bc4
	ctx.r[7].s64 = ctx.r[11].s64 + -19396;
	// 82EC90B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC90B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC90BC: 38CBA8F0  addi r6, r11, -0x5710
	ctx.r[6].s64 = ctx.r[11].s64 + -22288;
	// 82EC90C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC90C4: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC90C8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82EC90CC: 390B9128  addi r8, r11, -0x6ed8
	ctx.r[8].s64 = ctx.r[11].s64 + -28376;
	// 82EC90D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC90D4: 393F00A4  addi r9, r31, 0xa4
	ctx.r[9].s64 = ctx.r[31].s64 + 164;
	// 82EC90D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC90DC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EC90E0: 90DF006C  stw r6, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[6].u32 ) };
	// 82EC90E4: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EC90E8: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EC90EC: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EC90F0: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC90F4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC90F8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC90FC: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC9100: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC9104: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC9108: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC910C: 98AA001C  stb r5, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 82EC9110: 90EA0020  stw r7, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC9114: 916A0024  stw r11, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC9118: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC911C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC9120: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC9124: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC9128: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC912C: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EC9130: 91690018  stw r11, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC9134: 98A9001C  stb r5, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 82EC9138: 90E90020  stw r7, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC913C: 91690024  stw r11, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC9140: 93FF00A0  stw r31, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 82EC9144: 93FF00C8  stw r31, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[31].u32 ) };
	// 82EC9148: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC914C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC9150: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC9154: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC9158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9160 size=68
    let mut pc: u32 = 0x82EC9160;
    'dispatch: loop {
        match pc {
            0x82EC9160 => {
    //   block [0x82EC9160..0x82EC91A4)
	// 82EC9160: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9164: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC9168: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC916C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9170: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9174: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC9178: 41820024  beq 0x82ec919c
	if ctx.cr[0].eq {
	pc = 0x82EC919C; continue 'dispatch;
	}
	// 82EC917C: 81430070  lwz r10, 0x70(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC9180: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9184: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9188: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC918C: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9190: 81080014  lwz r8, 0x14(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC9194: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82EC9198: 4082FFE8  bne 0x82ec9180
	if !ctx.cr[0].eq {
	pc = 0x82EC9180; continue 'dispatch;
	}
	// 82EC919C: 7C6939D6  mullw r3, r9, r7
	ctx.r[3].s64 = (ctx.r[9].s32 as i64) * (ctx.r[7].s32 as i64);
	// 82EC91A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC91A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC91A8 size=172
    let mut pc: u32 = 0x82EC91A8;
    'dispatch: loop {
        match pc {
            0x82EC91A8 => {
    //   block [0x82EC91A8..0x82EC9254)
	// 82EC91A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC91AC: 4BDE0259  bl 0x82ca9404
	ctx.lr = 0x82EC91B0;
	sub_82CA93D0(ctx, base);
	// 82EC91B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC91B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC91B8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EC91BC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EC91C0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EC91C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC91C8: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC91CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC91D0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82EC91D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC91D8: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EC91DC: 4B40A17D  bl 0x822d3358
	ctx.lr = 0x82EC91E0;
	sub_822D3358(ctx, base);
	// 82EC91E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC91E4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EC91E8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC91EC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC91F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC91F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC91F8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC91FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9200: 4E800421  bctrl
	ctx.lr = 0x82EC9204;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC9204: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC9208: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC920C: 4182003C  beq 0x82ec9248
	if ctx.cr[0].eq {
	pc = 0x82EC9248; continue 'dispatch;
	}
	// 82EC9210: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9214: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9218: 41820030  beq 0x82ec9248
	if ctx.cr[0].eq {
	pc = 0x82EC9248; continue 'dispatch;
	}
	// 82EC921C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC9220: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC9224: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC9228: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC922C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC9230: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82EC9234: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9238: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC923C: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC9240: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC9244: 4BFBFEB5  bl 0x82e890f8
	ctx.lr = 0x82EC9248;
	sub_82E890F8(ctx, base);
	// 82EC9248: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC924C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC9250: 4BDE0204  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9258 size=52
    let mut pc: u32 = 0x82EC9258;
    'dispatch: loop {
        match pc {
            0x82EC9258 => {
    //   block [0x82EC9258..0x82EC928C)
	// 82EC9258: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EC925C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC9260: 41990098  bgt cr6, 0x82ec92f8
	if ctx.cr[6].gt {
		sub_82EC928C(ctx, base);
		return;
	}
	// 82EC9264: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9268: 81630068  lwz r11, 0x68(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC926C: 0CCB0000  twi 6, r11, 0
	// 82EC9270: 7D645B96  divwu r11, r4, r11
	ctx.r[11].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 82EC9274: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9278: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC927C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC9280: 4198000C  blt cr6, 0x82ec928c
	if ctx.cr[6].lt {
		sub_82EC928C(ctx, base);
		return;
	}
	// 82EC9284: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC9288: 48000010  b 0x82ec9298
	sub_82EC928C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC928C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC928C size=116
    let mut pc: u32 = 0x82EC928C;
    'dispatch: loop {
        match pc {
            0x82EC928C => {
    //   block [0x82EC928C..0x82EC9300)
	// 82EC928C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9290: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 82EC9294: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EC9298: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC929C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC92A0: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC92A4: 41820054  beq 0x82ec92f8
	if ctx.cr[0].eq {
	pc = 0x82EC92F8; continue 'dispatch;
	}
	// 82EC92A8: 81630068  lwz r11, 0x68(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC92AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC92B0: 80A30078  lwz r5, 0x78(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC92B4: 7D445B96  divwu r10, r4, r11
	ctx.r[10].u32 = ctx.r[4].u32 / ctx.r[11].u32;
	// 82EC92B8: 0CCB0000  twi 6, r11, 0
	// 82EC92BC: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82EC92C0: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82EC92C4: 28050000  cmplwi r5, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC92C8: 41820030  beq 0x82ec92f8
	if ctx.cr[0].eq {
	pc = 0x82EC92F8; continue 'dispatch;
	}
	// 82EC92CC: 81430070  lwz r10, 0x70(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC92D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC92D4: 81070008  lwz r8, 8(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC92D8: 81080018  lwz r8, 0x18(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC92DC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EC92E0: 41980020  blt cr6, 0x82ec9300
	if ctx.cr[6].lt {
		sub_82EC9300(ctx, base);
		return;
	}
	// 82EC92E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC92E8: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82EC92EC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC92F0: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EC92F4: 4198FFDC  blt cr6, 0x82ec92d0
	if ctx.cr[6].lt {
	pc = 0x82EC92D0; continue 'dispatch;
	}
	// 82EC92F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC92FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9300 size=24
    let mut pc: u32 = 0x82EC9300;
    'dispatch: loop {
        match pc {
            0x82EC9300 => {
    //   block [0x82EC9300..0x82EC9318)
	// 82EC9300: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9304: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9308: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC930C: 4198000C  blt cr6, 0x82ec9318
	if ctx.cr[6].lt {
		sub_82EC9318(ctx, base);
		return;
	}
	// 82EC9310: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC9314: 48000010  b 0x82ec9324
	sub_82EC9318(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9318 size=36
    let mut pc: u32 = 0x82EC9318;
    'dispatch: loop {
        match pc {
            0x82EC9318 => {
    //   block [0x82EC9318..0x82EC933C)
	// 82EC9318: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC931C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 82EC9320: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EC9324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9328: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC932C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82EC9330: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC9334: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 82EC9338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9340 size=12
    let mut pc: u32 = 0x82EC9340;
    'dispatch: loop {
        match pc {
            0x82EC9340 => {
    //   block [0x82EC9340..0x82EC934C)
	// 82EC9340: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC9344: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9348: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC934C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC934C size=12
    let mut pc: u32 = 0x82EC934C;
    'dispatch: loop {
        match pc {
            0x82EC934C => {
    //   block [0x82EC934C..0x82EC9358)
	// 82EC934C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9350: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9354: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9358 size=12
    let mut pc: u32 = 0x82EC9358;
    'dispatch: loop {
        match pc {
            0x82EC9358 => {
    //   block [0x82EC9358..0x82EC9364)
	// 82EC9358: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC935C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC9360: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9364(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9364 size=180
    let mut pc: u32 = 0x82EC9364;
    'dispatch: loop {
        match pc {
            0x82EC9364 => {
    //   block [0x82EC9364..0x82EC9418)
	// 82EC9364: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9368: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC936C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC9370: 4182009C  beq 0x82ec940c
	if ctx.cr[0].eq {
	pc = 0x82EC940C; continue 'dispatch;
	}
	// 82EC9374: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC9378: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC937C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC9380: 394B006C  addi r10, r11, 0x6c
	ctx.r[10].s64 = ctx.r[11].s64 + 108;
	// 82EC9384: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9388: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC938C: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9390: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9394: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EC9398: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 82EC939C: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EC93A0: 7D293B96  divwu r9, r9, r7
	ctx.r[9].u32 = ctx.r[9].u32 / ctx.r[7].u32;
	// 82EC93A4: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82EC93A8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC93AC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC93B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC93B4: 40990058  ble cr6, 0x82ec940c
	if !ctx.cr[6].gt {
	pc = 0x82EC940C; continue 'dispatch;
	}
	// 82EC93B8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC93BC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC93C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC93C4: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC93C8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC93CC: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC93D0: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC93D4: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC93D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC93DC: 409A003C  bne cr6, 0x82ec9418
	if !ctx.cr[6].eq {
		sub_82EC9418(ctx, base);
		return;
	}
	// 82EC93E0: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC93E4: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC93E8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC93EC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC93F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC93F4: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC93F8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC93FC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC9400: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9404: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC9408: 4198FFB0  blt cr6, 0x82ec93b8
	if ctx.cr[6].lt {
	pc = 0x82EC93B8; continue 'dispatch;
	}
	// 82EC940C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC9410: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC9414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9418 size=40
    let mut pc: u32 = 0x82EC9418;
    'dispatch: loop {
        match pc {
            0x82EC9418 => {
    //   block [0x82EC9418..0x82EC9440)
	// 82EC9418: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC941C: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9420: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC9424: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC9428: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC942C: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC9430: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC9434: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9438: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EC943C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9440 size=12
    let mut pc: u32 = 0x82EC9440;
    'dispatch: loop {
        match pc {
            0x82EC9440 => {
    //   block [0x82EC9440..0x82EC944C)
	// 82EC9440: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC9444: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9448: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC944C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC944C size=12
    let mut pc: u32 = 0x82EC944C;
    'dispatch: loop {
        match pc {
            0x82EC944C => {
    //   block [0x82EC944C..0x82EC9458)
	// 82EC944C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9454: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9458 size=12
    let mut pc: u32 = 0x82EC9458;
    'dispatch: loop {
        match pc {
            0x82EC9458 => {
    //   block [0x82EC9458..0x82EC9464)
	// 82EC9458: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC945C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9460: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9464(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9464 size=92
    let mut pc: u32 = 0x82EC9464;
    'dispatch: loop {
        match pc {
            0x82EC9464 => {
    //   block [0x82EC9464..0x82EC94C0)
	// 82EC9464: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9468: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC946C: 396B006C  addi r11, r11, 0x6c
	ctx.r[11].s64 = ctx.r[11].s64 + 108;
	// 82EC9470: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9474: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EC9478: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC947C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9480: 41820040  beq 0x82ec94c0
	if ctx.cr[0].eq {
		sub_82EC94C0(ctx, base);
		return;
	}
	// 82EC9484: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9488: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC948C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9490: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EC9494: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC9498: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC949C: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC94A0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC94A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC94A8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC94AC: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC94B0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EC94B4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC94B8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EC94BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC94C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC94C0 size=16
    let mut pc: u32 = 0x82EC94C0;
    'dispatch: loop {
        match pc {
            0x82EC94C0 => {
    //   block [0x82EC94C0..0x82EC94D0)
	// 82EC94C0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC94C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC94C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC94CC: 48000058  b 0x82ec9524
	sub_82EC94D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC94D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC94D0 size=276
    let mut pc: u32 = 0x82EC94D0;
    'dispatch: loop {
        match pc {
            0x82EC94D0 => {
    //   block [0x82EC94D0..0x82EC95E4)
	// 82EC94D0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC94D4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC94D8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC94DC: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC94E0: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EC94E4: 8129FFFC  lwz r9, -4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EC94E8: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC94EC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC94F0: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC94F4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC94F8: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC94FC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9500: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9504: 91230018  stw r9, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EC9508: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EC950C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EC9510: 409A00D4  bne cr6, 0x82ec95e4
	if !ctx.cr[6].eq {
		sub_82EC95E4(ctx, base);
		return;
	}
	// 82EC9514: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9518: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC951C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC9520: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC9524: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9528: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC952C: 4198FFA4  blt cr6, 0x82ec94d0
	if ctx.cr[6].lt {
	pc = 0x82EC94D0; continue 'dispatch;
	}
	// 82EC9530: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9534: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9538: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC953C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EC9540: 41820098  beq 0x82ec95d8
	if ctx.cr[0].eq {
	pc = 0x82EC95D8; continue 'dispatch;
	}
	// 82EC9544: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC9548: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82EC954C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC9550: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9554: 814A0068  lwz r10, 0x68(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9558: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC955C: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9560: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EC9564: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 82EC9568: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EC956C: 7D293B96  divwu r9, r9, r7
	ctx.r[9].u32 = ctx.r[9].u32 / ctx.r[7].u32;
	// 82EC9570: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82EC9574: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EC9578: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC957C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC9580: 40990058  ble cr6, 0x82ec95d8
	if !ctx.cr[6].gt {
	pc = 0x82EC95D8; continue 'dispatch;
	}
	// 82EC9584: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9588: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC958C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC9590: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EC9594: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9598: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC959C: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EC95A0: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EC95A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC95A8: 409A0064  bne cr6, 0x82ec960c
	if !ctx.cr[6].eq {
		sub_82EC960C(ctx, base);
		return;
	}
	// 82EC95AC: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC95B0: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC95B4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC95B8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EC95BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC95C0: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EC95C4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC95C8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC95CC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC95D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC95D4: 4198FFB0  blt cr6, 0x82ec9584
	if ctx.cr[6].lt {
	pc = 0x82EC9584; continue 'dispatch;
	}
	// 82EC95D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC95DC: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC95E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC95E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC95E4 size=40
    let mut pc: u32 = 0x82EC95E4;
    'dispatch: loop {
        match pc {
            0x82EC95E4 => {
    //   block [0x82EC95E4..0x82EC960C)
	// 82EC95E4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC95E8: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 82EC95EC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC95F0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC95F4: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 82EC95F8: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC95FC: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9600: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC9604: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9608: 4BFFFEB0  b 0x82ec94b8
	sub_82EC9464(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC960C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC960C size=20
    let mut pc: u32 = 0x82EC960C;
    'dispatch: loop {
        match pc {
            0x82EC960C => {
    //   block [0x82EC960C..0x82EC9620)
	// 82EC960C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9610: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9614: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC9618: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82EC961C: 4BFFFFDC  b 0x82ec95f8
	sub_82EC95E4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC9620 size=60
    let mut pc: u32 = 0x82EC9620;
    'dispatch: loop {
        match pc {
            0x82EC9620 => {
    //   block [0x82EC9620..0x82EC965C)
	// 82EC9620: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC9624: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC9628: 90E30008  stw r7, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82EC962C: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82EC9630: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9634: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9638: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC963C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9640: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EC9644: 40820018  bne 0x82ec965c
	if !ctx.cr[0].eq {
		sub_82EC965C(ctx, base);
		return;
	}
	// 82EC9648: 90E30020  stw r7, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EC964C: 90E30018  stw r7, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 82EC9650: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC9654: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC9658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC965C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC965C size=152
    let mut pc: u32 = 0x82EC965C;
    'dispatch: loop {
        match pc {
            0x82EC965C => {
    //   block [0x82EC965C..0x82EC96F4)
	// 82EC965C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9660: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 82EC9664: 80C30004  lwz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9668: 392B006C  addi r9, r11, 0x6c
	ctx.r[9].s64 = ctx.r[11].s64 + 108;
	// 82EC966C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9670: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9674: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9678: 7D4A3050  subf r10, r10, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82EC967C: 7D4A4396  divwu r10, r10, r8
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[8].u32;
	// 82EC9680: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 82EC9684: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC9688: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC968C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9690: 40990088  ble cr6, 0x82ec9718
	if !ctx.cr[6].gt {
		sub_82EC96F4(ctx, base);
		return;
	}
	// 82EC9694: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9698: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC969C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC96A0: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EC96A4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC96A8: 4182002C  beq 0x82ec96d4
	if ctx.cr[0].eq {
	pc = 0x82EC96D4; continue 'dispatch;
	}
	// 82EC96AC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC96B0: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC96B4: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 82EC96B8: 54C6003E  slwi r6, r6, 0
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EC96BC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EC96C0: 409A0034  bne cr6, 0x82ec96f4
	if !ctx.cr[6].eq {
		sub_82EC96F4(ctx, base);
		return;
	}
	// 82EC96C4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC96C8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC96CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC96D0: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC96D4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC96D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC96DC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC96E0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC96E4: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC96E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC96EC: 4198FFA8  blt cr6, 0x82ec9694
	if ctx.cr[6].lt {
	pc = 0x82EC9694; continue 'dispatch;
	}
	// 82EC96F0: 48000028  b 0x82ec9718
	sub_82EC96F4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC96F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC96F4 size=56
    let mut pc: u32 = 0x82EC96F4;
    'dispatch: loop {
        match pc {
            0x82EC96F4 => {
    //   block [0x82EC96F4..0x82EC972C)
	// 82EC96F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC96F8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC96FC: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC9700: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC9704: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9708: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 82EC970C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EC9710: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9714: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EC9718: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC971C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9720: 419AFF30  beq cr6, 0x82ec9650
	if ctx.cr[6].eq {
		sub_82EC9620(ctx, base);
		return;
	}
	// 82EC9724: 98E3001C  stb r7, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u8 ) };
	// 82EC9728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC9730 size=556
    let mut pc: u32 = 0x82EC9730;
    'dispatch: loop {
        match pc {
            0x82EC9730 => {
    //   block [0x82EC9730..0x82EC995C)
	// 82EC9730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9734: 4BDDFCBD  bl 0x82ca93f0
	ctx.lr = 0x82EC9738;
	sub_82CA93D0(ctx, base);
	// 82EC9738: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82EC973C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9744: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC9748: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC974C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9750: 408201FC  bne 0x82ec994c
	if !ctx.cr[0].eq {
	pc = 0x82EC994C; continue 'dispatch;
	}
	// 82EC9754: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC9758: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC975C: 48000028  b 0x82ec9784
	pc = 0x82EC9784; continue 'dispatch;
	// 82EC9760: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC9768: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC976C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9774: 4E800421  bctrl
	ctx.lr = 0x82EC9778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC9778: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC977C: 408201D0  bne 0x82ec994c
	if !ctx.cr[0].eq {
	pc = 0x82EC994C; continue 'dispatch;
	}
	// 82EC9780: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9784: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9788: 4082FFD8  bne 0x82ec9760
	if !ctx.cr[0].eq {
	pc = 0x82EC9760; continue 'dispatch;
	}
	// 82EC978C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9790: 808300A8  lwz r4, 0xa8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC9794: 4BFBDBBD  bl 0x82e87350
	ctx.lr = 0x82EC9798;
	sub_82E87350(ctx, base);
	// 82EC9798: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EC979C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC97A0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC97A4: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC97A8: 4082000C  bne 0x82ec97b4
	if !ctx.cr[0].eq {
	pc = 0x82EC97B4; continue 'dispatch;
	}
	// 82EC97AC: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 82EC97B0: 4BFFFE71  bl 0x82ec9620
	ctx.lr = 0x82EC97B4;
	sub_82EC9620(ctx, base);
	// 82EC97B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC97B8: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EC97BC: 82EB00A4  lwz r23, 0xa4(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC97C0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EC97C4: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EC97C8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC97CC: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC97D0: 4182017C  beq 0x82ec994c
	if ctx.cr[0].eq {
	pc = 0x82EC994C; continue 'dispatch;
	}
	// 82EC97D4: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC97D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC97DC: 41820168  beq 0x82ec9944
	if ctx.cr[0].eq {
	pc = 0x82EC9944; continue 'dispatch;
	}
	// 82EC97E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC97E4: 3B5F007C  addi r26, r31, 0x7c
	ctx.r[26].s64 = ctx.r[31].s64 + 124;
	// 82EC97E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC97EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC97F0: 91760000  stw r11, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC97F4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC97F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC97FC: 41820018  beq 0x82ec9814
	if ctx.cr[0].eq {
	pc = 0x82EC9814; continue 'dispatch;
	}
	// 82EC9800: 815A0018  lwz r10, 0x18(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9804: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9808: 4182000C  beq 0x82ec9814
	if ctx.cr[0].eq {
	pc = 0x82EC9814; continue 'dispatch;
	}
	// 82EC980C: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9810: 836A0004  lwz r27, 4(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9814: 7F18E840  cmplw cr6, r24, r29
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EC9818: 419A0054  beq cr6, 0x82ec986c
	if ctx.cr[6].eq {
	pc = 0x82EC986C; continue 'dispatch;
	}
	// 82EC981C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC9820: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 82EC9824: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9828: 4800002C  b 0x82ec9854
	pc = 0x82EC9854; continue 'dispatch;
	// 82EC982C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9830: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC9834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC9838: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC983C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC9840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9844: 4E800421  bctrl
	ctx.lr = 0x82EC9848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC9848: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC984C: 40820014  bne 0x82ec9860
	if !ctx.cr[0].eq {
	pc = 0x82EC9860; continue 'dispatch;
	}
	// 82EC9850: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9854: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9858: 4082FFD4  bne 0x82ec982c
	if !ctx.cr[0].eq {
	pc = 0x82EC982C; continue 'dispatch;
	}
	// 82EC985C: 48000008  b 0x82ec9864
	pc = 0x82EC9864; continue 'dispatch;
	// 82EC9860: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82EC9864: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9868: 408200B8  bne 0x82ec9920
	if !ctx.cr[0].eq {
	pc = 0x82EC9920; continue 'dispatch;
	}
	// 82EC986C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC9870: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC9874: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9878: 48000030  b 0x82ec98a8
	pc = 0x82EC98A8; continue 'dispatch;
	// 82EC987C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9880: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EC9884: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC9888: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC988C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9890: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC9894: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9898: 4E800421  bctrl
	ctx.lr = 0x82EC989C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC989C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC98A0: 40820014  bne 0x82ec98b4
	if !ctx.cr[0].eq {
	pc = 0x82EC98B4; continue 'dispatch;
	}
	// 82EC98A4: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC98A8: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC98AC: 4082FFD0  bne 0x82ec987c
	if !ctx.cr[0].eq {
	pc = 0x82EC987C; continue 'dispatch;
	}
	// 82EC98B0: 48000008  b 0x82ec98b8
	pc = 0x82EC98B8; continue 'dispatch;
	// 82EC98B4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EC98B8: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC98BC: 40820064  bne 0x82ec9920
	if !ctx.cr[0].eq {
	pc = 0x82EC9920; continue 'dispatch;
	}
	// 82EC98C0: 83DF009C  lwz r30, 0x9c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EC98C4: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC98C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC98CC: 4BFBF7B5  bl 0x82e89080
	ctx.lr = 0x82EC98D0;
	sub_82E89080(ctx, base);
	// 82EC98D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC98D4: 7F04B840  cmplw cr6, r4, r23
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82EC98D8: 419A001C  beq cr6, 0x82ec98f4
	if ctx.cr[6].eq {
	pc = 0x82EC98F4; continue 'dispatch;
	}
	// 82EC98DC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC98E0: 4BFBDA71  bl 0x82e87350
	ctx.lr = 0x82EC98E4;
	sub_82E87350(ctx, base);
	// 82EC98E4: EDBF0828  fsubs f13, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC98E8: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC98EC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC98F0: 41980030  blt cr6, 0x82ec9920
	if ctx.cr[6].lt {
	pc = 0x82EC9920; continue 'dispatch;
	}
	// 82EC98F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC98F8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC98FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EC9900: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC9904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC9908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC990C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82EC9910: 4BFFF899  bl 0x82ec91a8
	ctx.lr = 0x82EC9914;
	sub_82EC91A8(ctx, base);
	// 82EC9914: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC9918: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC991C: 41820028  beq 0x82ec9944
	if ctx.cr[0].eq {
	pc = 0x82EC9944; continue 'dispatch;
	}
	// 82EC9920: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9924: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC9928: 41820010  beq 0x82ec9938
	if ctx.cr[0].eq {
	pc = 0x82EC9938; continue 'dispatch;
	}
	// 82EC992C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC9930: 4BFFFA11  bl 0x82ec9340
	ctx.lr = 0x82EC9934;
	sub_82EC9340(ctx, base);
	// 82EC9934: 4BFFFE8C  b 0x82ec97c0
	pc = 0x82EC97C0; continue 'dispatch;
	// 82EC9938: 4BFFFB09  bl 0x82ec9440
	ctx.lr = 0x82EC993C;
	sub_82EC9440(ctx, base);
	// 82EC993C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EC9940: 4BFFFE84  b 0x82ec97c4
	pc = 0x82EC97C4; continue 'dispatch;
	// 82EC9944: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC9948: 48000008  b 0x82ec9950
	pc = 0x82EC9950; continue 'dispatch;
	// 82EC994C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC9950: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EC9954: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82EC9958: 4BDDFAE8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9960 size=108
    let mut pc: u32 = 0x82EC9960;
    'dispatch: loop {
        match pc {
            0x82EC9960 => {
    //   block [0x82EC9960..0x82EC99CC)
	// 82EC9960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9964: 4BDDFAA9  bl 0x82ca940c
	ctx.lr = 0x82EC9968;
	sub_82CA93D0(ctx, base);
	// 82EC9968: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC996C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9970: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC9974: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EC9978: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC997C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC9980: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC9984: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EC9988: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC998C: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82EC9990: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC9994: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC9998: 4BFFF8C1  bl 0x82ec9258
	ctx.lr = 0x82EC999C;
	sub_82EC9258(ctx, base);
	// 82EC999C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC99A0: 4082000C  bne 0x82ec99ac
	if !ctx.cr[0].eq {
	pc = 0x82EC99AC; continue 'dispatch;
	}
	// 82EC99A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC99A8: 4800001C  b 0x82ec99c4
	pc = 0x82EC99C4; continue 'dispatch;
	// 82EC99AC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EC99B0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC99B4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EC99B8: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC99BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC99C0: 4BFFF7E9  bl 0x82ec91a8
	ctx.lr = 0x82EC99C4;
	sub_82EC91A8(ctx, base);
	// 82EC99C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC99C8: 4BDDFA94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC99D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC99D0 size=360
    let mut pc: u32 = 0x82EC99D0;
    'dispatch: loop {
        match pc {
            0x82EC99D0 => {
    //   block [0x82EC99D0..0x82EC9B38)
	// 82EC99D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC99D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC99D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC99DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC99E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC99E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC99E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC99EC: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EC99F0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC99F4: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC99F8: 41820048  beq 0x82ec9a40
	if ctx.cr[0].eq {
	pc = 0x82EC9A40; continue 'dispatch;
	}
	// 82EC99FC: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC9A00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9A04: 4182001C  beq 0x82ec9a20
	if ctx.cr[0].eq {
	pc = 0x82EC9A20; continue 'dispatch;
	}
	// 82EC9A08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A0C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A10: 409A0010  bne cr6, 0x82ec9a20
	if !ctx.cr[6].eq {
	pc = 0x82EC9A20; continue 'dispatch;
	}
	// 82EC9A14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC9A18: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 82EC9A1C: 4BFFF925  bl 0x82ec9340
	ctx.lr = 0x82EC9A20;
	sub_82EC9340(ctx, base);
	// 82EC9A20: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EC9A24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9A28: 41820018  beq 0x82ec9a40
	if ctx.cr[0].eq {
	pc = 0x82EC9A40; continue 'dispatch;
	}
	// 82EC9A2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A30: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A34: 409A000C  bne cr6, 0x82ec9a40
	if !ctx.cr[6].eq {
	pc = 0x82EC9A40; continue 'dispatch;
	}
	// 82EC9A38: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 82EC9A3C: 4BFFFA05  bl 0x82ec9440
	ctx.lr = 0x82EC9A40;
	sub_82EC9440(ctx, base);
	// 82EC9A40: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EC9A44: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC9A48: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9A4C: 41820024  beq 0x82ec9a70
	if ctx.cr[0].eq {
	pc = 0x82EC9A70; continue 'dispatch;
	}
	// 82EC9A50: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC9A54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A58: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A5C: 419AFF90  beq cr6, 0x82ec99ec
	if ctx.cr[6].eq {
	pc = 0x82EC99EC; continue 'dispatch;
	}
	// 82EC9A60: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EC9A64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A68: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A6C: 419AFF80  beq cr6, 0x82ec99ec
	if ctx.cr[6].eq {
	pc = 0x82EC99EC; continue 'dispatch;
	}
	// 82EC9A70: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EC9A74: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC9A78: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9A7C: 41820048  beq 0x82ec9ac4
	if ctx.cr[0].eq {
	pc = 0x82EC9AC4; continue 'dispatch;
	}
	// 82EC9A80: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC9A84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9A88: 4182001C  beq 0x82ec9aa4
	if ctx.cr[0].eq {
	pc = 0x82EC9AA4; continue 'dispatch;
	}
	// 82EC9A8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9A90: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9A94: 409A0010  bne cr6, 0x82ec9aa4
	if !ctx.cr[6].eq {
	pc = 0x82EC9AA4; continue 'dispatch;
	}
	// 82EC9A98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC9A9C: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 82EC9AA0: 4BFFF8A1  bl 0x82ec9340
	ctx.lr = 0x82EC9AA4;
	sub_82EC9340(ctx, base);
	// 82EC9AA4: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EC9AA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9AAC: 41820018  beq 0x82ec9ac4
	if ctx.cr[0].eq {
	pc = 0x82EC9AC4; continue 'dispatch;
	}
	// 82EC9AB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9AB4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9AB8: 409A000C  bne cr6, 0x82ec9ac4
	if !ctx.cr[6].eq {
	pc = 0x82EC9AC4; continue 'dispatch;
	}
	// 82EC9ABC: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 82EC9AC0: 4BFFF981  bl 0x82ec9440
	ctx.lr = 0x82EC9AC4;
	sub_82EC9440(ctx, base);
	// 82EC9AC4: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EC9AC8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC9ACC: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9AD0: 41820024  beq 0x82ec9af4
	if ctx.cr[0].eq {
	pc = 0x82EC9AF4; continue 'dispatch;
	}
	// 82EC9AD4: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EC9AD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9ADC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9AE0: 419AFF90  beq cr6, 0x82ec9a70
	if ctx.cr[6].eq {
	pc = 0x82EC9A70; continue 'dispatch;
	}
	// 82EC9AE4: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EC9AE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9AEC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9AF0: 419AFF80  beq cr6, 0x82ec9a70
	if ctx.cr[6].eq {
	pc = 0x82EC9A70; continue 'dispatch;
	}
	// 82EC9AF4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC9AF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EC9AFC: 419A0024  beq cr6, 0x82ec9b20
	if ctx.cr[6].eq {
	pc = 0x82EC9B20; continue 'dispatch;
	}
	// 82EC9B00: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC9B04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9B08: 41820018  beq 0x82ec9b20
	if ctx.cr[0].eq {
	pc = 0x82EC9B20; continue 'dispatch;
	}
	// 82EC9B0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9B10: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EC9B14: 409A000C  bne cr6, 0x82ec9b20
	if !ctx.cr[6].eq {
	pc = 0x82EC9B20; continue 'dispatch;
	}
	// 82EC9B18: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82EC9B1C: 4BFBCA15  bl 0x82e86530
	ctx.lr = 0x82EC9B20;
	sub_82E86530(ctx, base);
	// 82EC9B20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC9B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC9B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC9B2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC9B30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC9B34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9B38 size=404
    let mut pc: u32 = 0x82EC9B38;
    'dispatch: loop {
        match pc {
            0x82EC9B38 => {
    //   block [0x82EC9B38..0x82EC9CCC)
	// 82EC9B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9B3C: 4BDDF8B5  bl 0x82ca93f0
	ctx.lr = 0x82EC9B40;
	sub_82CA93D0(ctx, base);
	// 82EC9B40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9B44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9B48: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC9B4C: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC9B50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9B54: 40820170  bne 0x82ec9cc4
	if !ctx.cr[0].eq {
	pc = 0x82EC9CC4; continue 'dispatch;
	}
	// 82EC9B58: 81760064  lwz r11, 0x64(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9B5C: 3AE00014  li r23, 0x14
	ctx.r[23].s64 = 20;
	// 82EC9B60: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9B64: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9B68: 409A00A0  bne cr6, 0x82ec9c08
	if !ctx.cr[6].eq {
	pc = 0x82EC9C08; continue 'dispatch;
	}
	// 82EC9B6C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9B70: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC9B74: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9B78: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC9B7C: 8156006C  lwz r10, 0x6c(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC9B80: 811F0068  lwz r8, 0x68(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9B84: 80FF0078  lwz r7, 0x78(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC9B88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9B8C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EC9B90: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EC9B94: 814900A4  lwz r10, 0xa4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC9B98: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC9B9C: 7F0B41D6  mullw r24, r11, r8
	ctx.r[24].s64 = (ctx.r[11].s32 as i64) * (ctx.r[8].s32 as i64);
	// 82EC9BA0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC9BA4: 40990064  ble cr6, 0x82ec9c08
	if !ctx.cr[6].gt {
	pc = 0x82EC9C08; continue 'dispatch;
	}
	// 82EC9BA8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EC9BAC: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC9BB0: 7F2BD02E  lwzx r25, r11, r26
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EC9BB4: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9BB8: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9BBC: 48000028  b 0x82ec9be4
	pc = 0x82EC9BE4; continue 'dispatch;
	// 82EC9BC0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9BC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC9BC8: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9BCC: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82EC9BD0: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC9BD4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC9BD8: 7C8BC214  add r4, r11, r24
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82EC9BDC: 4BFBF51D  bl 0x82e890f8
	ctx.lr = 0x82EC9BE0;
	sub_82E890F8(ctx, base);
	// 82EC9BE0: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9BE4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9BE8: 4082FFD8  bne 0x82ec9bc0
	if !ctx.cr[0].eq {
	pc = 0x82EC9BC0; continue 'dispatch;
	}
	// 82EC9BEC: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC9BF0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EC9BF4: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC9BF8: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EC9BFC: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC9C00: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9C04: 4198FFA8  blt cr6, 0x82ec9bac
	if ctx.cr[6].lt {
	pc = 0x82EC9BAC; continue 'dispatch;
	}
	// 82EC9C08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9C0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC9C10: 80FF0078  lwz r7, 0x78(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC9C14: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC9C18: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9C1C: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC9C20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC9C24: 418200A0  beq 0x82ec9cc4
	if ctx.cr[0].eq {
	pc = 0x82EC9CC4; continue 'dispatch;
	}
	// 82EC9C28: 811F0070  lwz r8, 0x70(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC9C2C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9C30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9C34: 41820018  beq 0x82ec9c4c
	if ctx.cr[0].eq {
	pc = 0x82EC9C4C; continue 'dispatch;
	}
	// 82EC9C38: 80D60064  lwz r6, 0x64(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9C3C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EC9C40: 419A0020  beq cr6, 0x82ec9c60
	if ctx.cr[6].eq {
	pc = 0x82EC9C60; continue 'dispatch;
	}
	// 82EC9C44: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC9C48: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9C4C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC9C50: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC9C54: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EC9C58: 4198FFD4  blt cr6, 0x82ec9c2c
	if ctx.cr[6].lt {
	pc = 0x82EC9C2C; continue 'dispatch;
	}
	// 82EC9C5C: 48000068  b 0x82ec9cc4
	pc = 0x82EC9CC4; continue 'dispatch;
	// 82EC9C60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C64: 81360064  lwz r9, 0x64(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9C68: 8116006C  lwz r8, 0x6c(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC9C6C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C70: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C74: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C78: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9C7C: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82EC9C80: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC9C84: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9C88: 48000034  b 0x82ec9cbc
	pc = 0x82EC9CBC; continue 'dispatch;
	// 82EC9C8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9C90: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EC9C94: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9C98: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9C9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9CA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9CA4: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82EC9CA8: 7D6BBB96  divwu r11, r11, r23
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[23].u32;
	// 82EC9CAC: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82EC9CB0: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EC9CB4: 4BFBF445  bl 0x82e890f8
	ctx.lr = 0x82EC9CB8;
	sub_82E890F8(ctx, base);
	// 82EC9CB8: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9CBC: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9CC0: 4082FFCC  bne 0x82ec9c8c
	if !ctx.cr[0].eq {
	pc = 0x82EC9C8C; continue 'dispatch;
	}
	// 82EC9CC4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC9CC8: 4BDDF778  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC9CD0 size=252
    let mut pc: u32 = 0x82EC9CD0;
    'dispatch: loop {
        match pc {
            0x82EC9CD0 => {
    //   block [0x82EC9CD0..0x82EC9DCC)
	// 82EC9CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9CD4: 4BDDF739  bl 0x82ca940c
	ctx.lr = 0x82EC9CD8;
	sub_82CA93D0(ctx, base);
	// 82EC9CD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9CDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC9CE0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82EC9CE4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC9CE8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EC9CEC: 409A0014  bne cr6, 0x82ec9d00
	if !ctx.cr[6].eq {
	pc = 0x82EC9D00; continue 'dispatch;
	}
	// 82EC9CF0: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9CF4: 419A0038  beq cr6, 0x82ec9d2c
	if ctx.cr[6].eq {
	pc = 0x82EC9D2C; continue 'dispatch;
	}
	// 82EC9CF8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC9CFC: 48000030  b 0x82ec9d2c
	pc = 0x82EC9D2C; continue 'dispatch;
	// 82EC9D00: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82EC9D04: 409A0028  bne cr6, 0x82ec9d2c
	if !ctx.cr[6].eq {
	pc = 0x82EC9D2C; continue 'dispatch;
	}
	// 82EC9D08: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9D0C: 40990020  ble cr6, 0x82ec9d2c
	if !ctx.cr[6].gt {
	pc = 0x82EC9D2C; continue 'dispatch;
	}
	// 82EC9D10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9D14: 409A0010  bne cr6, 0x82ec9d24
	if !ctx.cr[6].eq {
	pc = 0x82EC9D24; continue 'dispatch;
	}
	// 82EC9D18: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EC9D1C: 48000008  b 0x82ec9d24
	pc = 0x82EC9D24; continue 'dispatch;
	// 82EC9D20: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC9D24: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EC9D28: 4198FFF8  blt cr6, 0x82ec9d20
	if ctx.cr[6].lt {
	pc = 0x82EC9D20; continue 'dispatch;
	}
	// 82EC9D2C: 83FD000C  lwz r31, 0xc(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9D30: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC9D34: 4099000C  ble cr6, 0x82ec9d40
	if !ctx.cr[6].gt {
	pc = 0x82EC9D40; continue 'dispatch;
	}
	// 82EC9D38: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC9D3C: 48000008  b 0x82ec9d44
	pc = 0x82EC9D44; continue 'dispatch;
	// 82EC9D40: 909D000C  stw r4, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EC9D44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9D48: 419A007C  beq cr6, 0x82ec9dc4
	if ctx.cr[6].eq {
	pc = 0x82EC9DC4; continue 'dispatch;
	}
	// 82EC9D4C: 7F1F2040  cmplw cr6, r31, r4
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EC9D50: 41980008  blt cr6, 0x82ec9d58
	if ctx.cr[6].lt {
	pc = 0x82EC9D58; continue 'dispatch;
	}
	// 82EC9D54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC9D58: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EC9D5C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC9D60: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EC9D64: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EC9D68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC9D6C: 40990008  ble cr6, 0x82ec9d74
	if !ctx.cr[6].gt {
	pc = 0x82EC9D74; continue 'dispatch;
	}
	// 82EC9D70: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EC9D74: 4B74CBB5  bl 0x82616928
	ctx.lr = 0x82EC9D78;
	sub_82616928(ctx, base);
	// 82EC9D78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC9D7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC9D80: 419A0024  beq cr6, 0x82ec9da4
	if ctx.cr[6].eq {
	pc = 0x82EC9DA4; continue 'dispatch;
	}
	// 82EC9D84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC9D88: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EC9D8C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9D90: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC9D94: 7C095C2E  lfsx f0, r9, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC9D98: 7C0BF52E  stfsx f0, r11, r30
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 82EC9D9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC9DA0: 4082FFEC  bne 0x82ec9d8c
	if !ctx.cr[0].eq {
	pc = 0x82EC9D8C; continue 'dispatch;
	}
	// 82EC9DA4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9DA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9DAC: 41820014  beq 0x82ec9dc0
	if ctx.cr[0].eq {
	pc = 0x82EC9DC0; continue 'dispatch;
	}
	// 82EC9DB0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC9DB4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC9DB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC9DBC: 4E800421  bctrl
	ctx.lr = 0x82EC9DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC9DC0: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EC9DC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC9DC8: 4BDDF694  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9DD0 size=244
    let mut pc: u32 = 0x82EC9DD0;
    'dispatch: loop {
        match pc {
            0x82EC9DD0 => {
    //   block [0x82EC9DD0..0x82EC9EC4)
	// 82EC9DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9DD4: 4BDDF631  bl 0x82ca9404
	ctx.lr = 0x82EC9DD8;
	sub_82CA93D0(ctx, base);
	// 82EC9DD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9DDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC9DE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC9DE4: 4BFBCBE5  bl 0x82e869c8
	ctx.lr = 0x82EC9DE8;
	sub_82E869C8(ctx, base);
	// 82EC9DE8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC9DEC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC9DF0: 409A000C  bne cr6, 0x82ec9dfc
	if !ctx.cr[6].eq {
	pc = 0x82EC9DFC; continue 'dispatch;
	}
	// 82EC9DF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC9DF8: 48000088  b 0x82ec9e80
	pc = 0x82EC9E80; continue 'dispatch;
	// 82EC9DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9E00: 482F2261  bl 0x831bc060
	ctx.lr = 0x82EC9E04;
	sub_831BC060(ctx, base);
	// 82EC9E04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC9E08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC9E0C: 396BB2D0  addi r11, r11, -0x4d30
	ctx.r[11].s64 = ctx.r[11].s64 + -19760;
	// 82EC9E10: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EC9E14: 4BDE2D3D  bl 0x82cacb50
	ctx.lr = 0x82EC9E18;
	sub_82CACB50(ctx, base);
	// 82EC9E18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC9E1C: 40820060  bne 0x82ec9e7c
	if !ctx.cr[0].eq {
	pc = 0x82EC9E7C; continue 'dispatch;
	}
	// 82EC9E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9E24: 4BA43EE5  bl 0x8290dd08
	ctx.lr = 0x82EC9E28;
	sub_8290DD08(ctx, base);
	// 82EC9E28: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EC9E2C: 41820050  beq 0x82ec9e7c
	if ctx.cr[0].eq {
	pc = 0x82EC9E7C; continue 'dispatch;
	}
	// 82EC9E30: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9E34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC9E38: 3BEB0050  addi r31, r11, 0x50
	ctx.r[31].s64 = ctx.r[11].s64 + 80;
	// 82EC9E3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC9E44: 40990038  ble cr6, 0x82ec9e7c
	if !ctx.cr[6].gt {
	pc = 0x82EC9E7C; continue 'dispatch;
	}
	// 82EC9E48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC9E4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9E50: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC9E54: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC9E58: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC9E5C: 4BDE2CF5  bl 0x82cacb50
	ctx.lr = 0x82EC9E60;
	sub_82CACB50(ctx, base);
	// 82EC9E60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC9E64: 41820024  beq 0x82ec9e88
	if ctx.cr[0].eq {
	pc = 0x82EC9E88; continue 'dispatch;
	}
	// 82EC9E68: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC9E6C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EC9E70: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EC9E74: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC9E78: 4198FFD4  blt cr6, 0x82ec9e4c
	if ctx.cr[6].lt {
	pc = 0x82EC9E4C; continue 'dispatch;
	}
	// 82EC9E7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC9E80: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC9E84: 4BDDF5D0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82EC9E88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9E8C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC9E90: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EC9E94: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9E98: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EC9E9C: 4182FFE0  beq 0x82ec9e7c
	if ctx.cr[0].eq {
	pc = 0x82EC9E7C; continue 'dispatch;
	}
	// 82EC9EA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC9EA4: 387C006C  addi r3, r28, 0x6c
	ctx.r[3].s64 = ctx.r[28].s64 + 108;
	// 82EC9EA8: 4BFEF3E9  bl 0x82eb9290
	ctx.lr = 0x82EC9EAC;
	sub_82EB9290(ctx, base);
	// 82EC9EAC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC9EB0: 815C0068  lwz r10, 0x68(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC9EB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC9EB8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC9EBC: 917C0068  stw r11, 0x68(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EC9EC0: 4BFFFFC0  b 0x82ec9e80
	pc = 0x82EC9E80; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC9EC8 size=284
    let mut pc: u32 = 0x82EC9EC8;
    'dispatch: loop {
        match pc {
            0x82EC9EC8 => {
    //   block [0x82EC9EC8..0x82EC9FE4)
	// 82EC9EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9ECC: 4BDDF541  bl 0x82ca940c
	ctx.lr = 0x82EC9ED0;
	sub_82CA93D0(ctx, base);
	// 82EC9ED0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EC9ED4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC9ED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9EDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC9EE0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC9EE4: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC9EE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9EEC: 408200E4  bne 0x82ec9fd0
	if !ctx.cr[0].eq {
	pc = 0x82EC9FD0; continue 'dispatch;
	}
	// 82EC9EF0: 4B396AC9  bl 0x822609b8
	ctx.lr = 0x82EC9EF4;
	sub_822609B8(ctx, base);
	// 82EC9EF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9EF8: C3E3004C  lfs f31, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC9EFC: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EC9F00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC9F04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC9F08: C3CB0BEC  lfs f30, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC9F0C: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EC9F10: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC9F14: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC9F18: 418200B0  beq 0x82ec9fc8
	if ctx.cr[0].eq {
	pc = 0x82EC9FC8; continue 'dispatch;
	}
	// 82EC9F1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC9F20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9F24: 4182009C  beq 0x82ec9fc0
	if ctx.cr[0].eq {
	pc = 0x82EC9FC0; continue 'dispatch;
	}
	// 82EC9F28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC9F2C: 3BDF00A4  addi r30, r31, 0xa4
	ctx.r[30].s64 = ctx.r[31].s64 + 164;
	// 82EC9F30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC9F34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC9F38: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC9F3C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9F40: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9F44: 41820018  beq 0x82ec9f5c
	if ctx.cr[0].eq {
	pc = 0x82EC9F5C; continue 'dispatch;
	}
	// 82EC9F48: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC9F4C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC9F50: 4182000C  beq 0x82ec9f5c
	if ctx.cr[0].eq {
	pc = 0x82EC9F5C; continue 'dispatch;
	}
	// 82EC9F54: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9F58: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC9F60: 4BFA7411  bl 0x82e71370
	ctx.lr = 0x82EC9F64;
	sub_82E71370(ctx, base);
	// 82EC9F64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC9F68: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9F6C: 4BFBF115  bl 0x82e89080
	ctx.lr = 0x82EC9F70;
	sub_82E89080(ctx, base);
	// 82EC9F70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC9F74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9F78: 4BFBD3D9  bl 0x82e87350
	ctx.lr = 0x82EC9F7C;
	sub_82E87350(ctx, base);
	// 82EC9F7C: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82EC9F80: 419A0034  beq cr6, 0x82ec9fb4
	if ctx.cr[6].eq {
	pc = 0x82EC9FB4; continue 'dispatch;
	}
	// 82EC9F84: EC1F0828  fsubs f0, f31, f1
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC9F88: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC9F8C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC9F90: 40980014  bge cr6, 0x82ec9fa4
	if !ctx.cr[6].lt {
	pc = 0x82EC9FA4; continue 'dispatch;
	}
	// 82EC9F94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC9F98: C1AB0098  lfs f13, 0x98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC9F9C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC9FA0: 41980014  blt cr6, 0x82ec9fb4
	if ctx.cr[6].lt {
	pc = 0x82EC9FB4; continue 'dispatch;
	}
	// 82EC9FA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC9FA8: 809F00C4  lwz r4, 0xc4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EC9FAC: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC9FB0: 4BFBF149  bl 0x82e890f8
	ctx.lr = 0x82EC9FB4;
	sub_82E890F8(ctx, base);
	// 82EC9FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC9FB8: 4BFFF489  bl 0x82ec9440
	ctx.lr = 0x82EC9FBC;
	sub_82EC9440(ctx, base);
	// 82EC9FBC: 4BFFFF50  b 0x82ec9f0c
	pc = 0x82EC9F0C; continue 'dispatch;
	// 82EC9FC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC9FC4: 48000010  b 0x82ec9fd4
	pc = 0x82EC9FD4; continue 'dispatch;
	// 82EC9FC8: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 82EC9FCC: 4BFFF655  bl 0x82ec9620
	ctx.lr = 0x82EC9FD0;
	sub_82EC9620(ctx, base);
	// 82EC9FD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC9FD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC9FD8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EC9FDC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC9FE0: 4BDDF47C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC9FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC9FE8 size=172
    let mut pc: u32 = 0x82EC9FE8;
    'dispatch: loop {
        match pc {
            0x82EC9FE8 => {
    //   block [0x82EC9FE8..0x82ECA094)
	// 82EC9FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC9FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC9FF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC9FF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC9FF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC9FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA000: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECA004: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA008: 4182000C  beq 0x82eca014
	if ctx.cr[0].eq {
	pc = 0x82ECA014; continue 'dispatch;
	}
	// 82ECA00C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECA010: 4800006C  b 0x82eca07c
	pc = 0x82ECA07C; continue 'dispatch;
	// 82ECA014: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ECA018: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECA01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECA020: 915F0068  stw r10, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82ECA024: 40990030  ble cr6, 0x82eca054
	if !ctx.cr[6].gt {
	pc = 0x82ECA054; continue 'dispatch;
	}
	// 82ECA028: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82ECA02C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECA030: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ECA034: 811F0068  lwz r8, 0x68(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82ECA038: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ECA03C: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECA040: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82ECA044: 913F0068  stw r9, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82ECA048: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECA04C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ECA050: 4198FFDC  blt cr6, 0x82eca02c
	if ctx.cr[6].lt {
	pc = 0x82ECA02C; continue 'dispatch;
	}
	// 82ECA054: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82ECA058: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ECA05C: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82ECA060: 7FCB21D6  mullw r30, r11, r4
	ctx.r[30].s64 = (ctx.r[11].s32 as i64) * (ctx.r[4].s32 as i64);
	// 82ECA064: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA068: 4BFFFC69  bl 0x82ec9cd0
	ctx.lr = 0x82ECA06C;
	sub_82EC9CD0(ctx, base);
	// 82ECA06C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA070: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA074: 4BFBEF75  bl 0x82e88fe8
	ctx.lr = 0x82ECA078;
	sub_82E88FE8(ctx, base);
	// 82ECA078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA07C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA080: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA084: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA088: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA08C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA098 size=88
    let mut pc: u32 = 0x82ECA098;
    'dispatch: loop {
        match pc {
            0x82ECA098 => {
    //   block [0x82ECA098..0x82ECA0F0)
	// 82ECA098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA09C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA0A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECA0A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA0A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA0AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA0B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECA0B4: 4BFFEF8D  bl 0x82ec9040
	ctx.lr = 0x82ECA0B8;
	sub_82EC9040(ctx, base);
	// 82ECA0B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ECA0BC: 41820018  beq 0x82eca0d4
	if ctx.cr[0].eq {
	pc = 0x82ECA0D4; continue 'dispatch;
	}
	// 82ECA0C0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ECA0C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA0C8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ECA0CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA0D0: 4E800421  bctrl
	ctx.lr = 0x82ECA0D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECA0D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA0D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA0DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA0E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA0E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA0E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA0F0 size=12
    let mut pc: u32 = 0x82ECA0F0;
    'dispatch: loop {
        match pc {
            0x82ECA0F0 => {
    //   block [0x82ECA0F0..0x82ECA0FC)
	// 82ECA0F0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECA0F4: 386BE6D4  addi r3, r11, -0x192c
	ctx.r[3].s64 = ctx.r[11].s64 + -6444;
	// 82ECA0F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA100 size=92
    let mut pc: u32 = 0x82ECA100;
    'dispatch: loop {
        match pc {
            0x82ECA100 => {
    //   block [0x82ECA100..0x82ECA15C)
	// 82ECA100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA104: 4BDDF305  bl 0x82ca9408
	ctx.lr = 0x82ECA108;
	sub_82CA93D0(ctx, base);
	// 82ECA108: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA10C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECA110: 386000CC  li r3, 0xcc
	ctx.r[3].s64 = 204;
	// 82ECA114: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECA118: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECA11C: 4B74C80D  bl 0x82616928
	ctx.lr = 0x82ECA120;
	sub_82616928(ctx, base);
	// 82ECA120: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECA124: 4182002C  beq 0x82eca150
	if ctx.cr[0].eq {
	pc = 0x82ECA150; continue 'dispatch;
	}
	// 82ECA128: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ECA12C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECA130: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA138: 4BFFEF59  bl 0x82ec9090
	ctx.lr = 0x82ECA13C;
	sub_82EC9090(ctx, base);
	// 82ECA13C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECA140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA144: 396BB474  addi r11, r11, -0x4b8c
	ctx.r[11].s64 = ctx.r[11].s64 + -19340;
	// 82ECA148: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECA14C: 48000008  b 0x82eca154
	pc = 0x82ECA154; continue 'dispatch;
	// 82ECA150: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECA154: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECA158: 4BDDF300  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ECA160 size=244
    let mut pc: u32 = 0x82ECA160;
    'dispatch: loop {
        match pc {
            0x82ECA160 => {
    //   block [0x82ECA160..0x82ECA254)
	// 82ECA160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA164: 4BDDF2A1  bl 0x82ca9404
	ctx.lr = 0x82ECA168;
	sub_82CA93D0(ctx, base);
	// 82ECA168: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA16C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECA170: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECA174: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82ECA178: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ECA17C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA180: 418200B8  beq 0x82eca238
	if ctx.cr[0].eq {
	pc = 0x82ECA238; continue 'dispatch;
	}
	// 82ECA184: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ECA188: 388B1048  addi r4, r11, 0x1048
	ctx.r[4].s64 = ctx.r[11].s64 + 4168;
	// 82ECA18C: 4B39D385  bl 0x82267510
	ctx.lr = 0x82ECA190;
	sub_82267510(ctx, base);
	// 82ECA190: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ECA194: 418200A4  beq 0x82eca238
	if ctx.cr[0].eq {
	pc = 0x82ECA238; continue 'dispatch;
	}
	// 82ECA198: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ECA19C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ECA1A0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ECA1A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ECA1A8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82ECA1AC: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ECA1B0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82ECA1B4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ECA1B8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ECA1BC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ECA1C0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82ECA1C4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82ECA1C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA1CC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ECA1D0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ECA1D4: 4200FFF8  bdnz 0x82eca1cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82ECA1CC; continue 'dispatch;
	}
	// 82ECA1D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ECA1DC: 9BE100B8  stb r31, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u8 ) };
	// 82ECA1E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ECA1E4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82ECA1E8: 396B10BC  addi r11, r11, 0x10bc
	ctx.r[11].s64 = ctx.r[11].s64 + 4284;
	// 82ECA1EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ECA1F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ECA1F4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82ECA1F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ECA1FC: 4B2E44AD  bl 0x821ae6a8
	ctx.lr = 0x82ECA200;
	sub_821AE6A8(ctx, base);
	// 82ECA200: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ECA204: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82ECA208: 389D0034  addi r4, r29, 0x34
	ctx.r[4].s64 = ctx.r[29].s64 + 52;
	// 82ECA20C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA210: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ECA214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ECA218: 4E800421  bctrl
	ctx.lr = 0x82ECA21C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ECA21C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ECA220: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ECA224: 409A000C  bne cr6, 0x82eca230
	if !ctx.cr[6].eq {
	pc = 0x82ECA230; continue 'dispatch;
	}
	// 82ECA228: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ECA22C: 48000010  b 0x82eca23c
	pc = 0x82ECA23C; continue 'dispatch;
	// 82ECA230: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ECA234: 4800000C  b 0x82eca240
	pc = 0x82ECA240; continue 'dispatch;
	// 82ECA238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ECA23C: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECA240: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ECA244: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ECA248: 997B0000  stb r11, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82ECA24C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82ECA250: 4BDDF204  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA258 size=112
    let mut pc: u32 = 0x82ECA258;
    'dispatch: loop {
        match pc {
            0x82ECA258 => {
    //   block [0x82ECA258..0x82ECA2C8)
	// 82ECA258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA25C: 4BDDF1B1  bl 0x82ca940c
	ctx.lr = 0x82ECA260;
	sub_82CA93D0(ctx, base);
	// 82ECA260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA268: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82ECA26C: 4BFBC36D  bl 0x82e865d8
	ctx.lr = 0x82ECA270;
	sub_82E865D8(ctx, base);
	// 82ECA270: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECA274: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ECA278: 396BB408  addi r11, r11, -0x4bf8
	ctx.r[11].s64 = ctx.r[11].s64 + -19448;
	// 82ECA27C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ECA280: 394AA8F0  addi r10, r10, -0x5710
	ctx.r[10].s64 = ctx.r[10].s64 + -22288;
	// 82ECA284: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ECA288: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECA28C: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82ECA290: 915F0054  stw r10, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82ECA294: 93BF005C  stw r29, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82ECA298: 93BF0060  stw r29, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82ECA29C: 83DE00AC  lwz r30, 0xac(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 82ECA2A0: 4B74C689  bl 0x82616928
	ctx.lr = 0x82ECA2A4;
	sub_82616928(ctx, base);
	// 82ECA2A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA2A8: 41820010  beq 0x82eca2b8
	if ctx.cr[0].eq {
	pc = 0x82ECA2B8; continue 'dispatch;
	}
	// 82ECA2AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA2B0: 4BFBECB9  bl 0x82e88f68
	ctx.lr = 0x82ECA2B4;
	sub_82E88F68(ctx, base);
	// 82ECA2B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ECA2B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA2BC: 93BF0064  stw r29, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82ECA2C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA2C4: 4BDDF198  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA2C8 size=120
    let mut pc: u32 = 0x82ECA2C8;
    'dispatch: loop {
        match pc {
            0x82ECA2C8 => {
    //   block [0x82ECA2C8..0x82ECA340)
	// 82ECA2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA2D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECA2D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA2D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA2DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECA2E0: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA2E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA2E8: 41820040  beq 0x82eca328
	if ctx.cr[0].eq {
	pc = 0x82ECA328; continue 'dispatch;
	}
	// 82ECA2EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA2F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ECA2F4: 816B00A4  lwz r11, 0xa4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) } as u64;
	// 82ECA2F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ECA2FC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECA304: 40990024  ble cr6, 0x82eca328
	if !ctx.cr[6].gt {
	pc = 0x82ECA328; continue 'dispatch;
	}
	// 82ECA308: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ECA30C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ECA310: 4BFBEDE9  bl 0x82e890f8
	ctx.lr = 0x82ECA314;
	sub_82E890F8(ctx, base);
	// 82ECA314: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA318: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82ECA31C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA320: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ECA324: 4198FFE4  blt cr6, 0x82eca308
	if ctx.cr[6].lt {
	pc = 0x82ECA308; continue 'dispatch;
	}
	// 82ECA328: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA32C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA334: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA340 size=88
    let mut pc: u32 = 0x82ECA340;
    'dispatch: loop {
        match pc {
            0x82ECA340 => {
    //   block [0x82ECA340..0x82ECA398)
	// 82ECA340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA34C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA354: 4BFFFF05  bl 0x82eca258
	ctx.lr = 0x82ECA358;
	sub_82ECA258(ctx, base);
	// 82ECA358: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECA35C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ECA360: 394BB4C4  addi r10, r11, -0x4b3c
	ctx.r[10].s64 = ctx.r[11].s64 + -19260;
	// 82ECA364: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ECA368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA36C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ECA370: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ECA374: 913F006C  stw r9, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82ECA378: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82ECA37C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ECA380: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82ECA384: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ECA388: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA38C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA398 size=104
    let mut pc: u32 = 0x82ECA398;
    'dispatch: loop {
        match pc {
            0x82ECA398 => {
    //   block [0x82ECA398..0x82ECA400)
	// 82ECA398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA39C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA3A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECA3A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA3A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA3AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA3B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ECA3B4: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82ECA3B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA3BC: 4182000C  beq 0x82eca3c8
	if ctx.cr[0].eq {
	pc = 0x82ECA3C8; continue 'dispatch;
	}
	// 82ECA3C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECA3C4: 48000024  b 0x82eca3e8
	pc = 0x82ECA3E8; continue 'dispatch;
	// 82ECA3C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ECA3CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA3D0: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82ECA3D4: 4BFBDA55  bl 0x82e87e28
	ctx.lr = 0x82ECA3D8;
	sub_82E87E28(ctx, base);
	// 82ECA3D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA3DC: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ECA3E0: 4BFBEC09  bl 0x82e88fe8
	ctx.lr = 0x82ECA3E4;
	sub_82E88FE8(ctx, base);
	// 82ECA3E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA3E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA3EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA3F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA3F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA3F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA400 size=12
    let mut pc: u32 = 0x82ECA400;
    'dispatch: loop {
        match pc {
            0x82ECA400 => {
    //   block [0x82ECA400..0x82ECA40C)
	// 82ECA400: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECA404: 386BE7E8  addi r3, r11, -0x1818
	ctx.r[3].s64 = ctx.r[11].s64 + -6168;
	// 82ECA408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA410 size=92
    let mut pc: u32 = 0x82ECA410;
    'dispatch: loop {
        match pc {
            0x82ECA410 => {
    //   block [0x82ECA410..0x82ECA46C)
	// 82ECA410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA414: 4BDDEFF5  bl 0x82ca9408
	ctx.lr = 0x82ECA418;
	sub_82CA93D0(ctx, base);
	// 82ECA418: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA41C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECA420: 38600078  li r3, 0x78
	ctx.r[3].s64 = 120;
	// 82ECA424: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ECA428: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ECA42C: 4B74C4FD  bl 0x82616928
	ctx.lr = 0x82ECA430;
	sub_82616928(ctx, base);
	// 82ECA430: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ECA434: 4182002C  beq 0x82eca460
	if ctx.cr[0].eq {
	pc = 0x82ECA460; continue 'dispatch;
	}
	// 82ECA438: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ECA43C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ECA440: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ECA444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA448: 4BFFFEF9  bl 0x82eca340
	ctx.lr = 0x82ECA44C;
	sub_82ECA340(ctx, base);
	// 82ECA44C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ECA450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ECA454: 396BB4FC  addi r11, r11, -0x4b04
	ctx.r[11].s64 = ctx.r[11].s64 + -19204;
	// 82ECA458: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ECA45C: 48000008  b 0x82eca464
	pc = 0x82ECA464; continue 'dispatch;
	// 82ECA460: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ECA464: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ECA468: 4BDDEFF0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ECA470 size=132
    let mut pc: u32 = 0x82ECA470;
    'dispatch: loop {
        match pc {
            0x82ECA470 => {
    //   block [0x82ECA470..0x82ECA4F4)
	// 82ECA470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ECA474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ECA478: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ECA47C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ECA480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ECA484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ECA488: 4BFBC8B1  bl 0x82e86d38
	ctx.lr = 0x82ECA48C;
	sub_82E86D38(ctx, base);
	// 82ECA48C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECA490: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ECA494: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECA498: 388BE6D4  addi r4, r11, -0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + -6444;
	// 82ECA49C: 4BFBD235  bl 0x82e876d0
	ctx.lr = 0x82ECA4A0;
	sub_82E876D0(ctx, base);
	// 82ECA4A0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82ECA4A4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ECA4A8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ECA4AC: 388BE398  addi r4, r11, -0x1c68
	ctx.r[4].s64 = ctx.r[11].s64 + -7272;
	// 82ECA4B0: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82ECA4B4: 4BFBD21D  bl 0x82e876d0
	ctx.lr = 0x82ECA4B8;
	sub_82E876D0(ctx, base);
	// 82ECA4B8: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ECA4BC: 907F007C  stw r3, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82ECA4C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ECA4C4: 409A0008  bne cr6, 0x82eca4cc
	if !ctx.cr[6].eq {
	pc = 0x82ECA4CC; continue 'dispatch;
	}
	// 82ECA4C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ECA4CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ECA4D0: 409A0008  bne cr6, 0x82eca4d8
	if !ctx.cr[6].eq {
	pc = 0x82ECA4D8; continue 'dispatch;
	}
	// 82ECA4D4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ECA4D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ECA4DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ECA4E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ECA4E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ECA4E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ECA4EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ECA4F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA4F8 size=4
    let mut pc: u32 = 0x82ECA4F8;
    'dispatch: loop {
        match pc {
            0x82ECA4F8 => {
    //   block [0x82ECA4F8..0x82ECA4FC)
	// 82ECA4F8: 4800001C  b 0x82eca514
	sub_82ECA4FC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA4FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA4FC size=40
    let mut pc: u32 = 0x82ECA4FC;
    'dispatch: loop {
        match pc {
            0x82ECA4FC => {
    //   block [0x82ECA4FC..0x82ECA524)
	// 82ECA4FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA500: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ECA504: 409A0038  bne cr6, 0x82eca53c
	if !ctx.cr[6].eq {
		sub_82ECA524(ctx, base);
		return;
	}
	// 82ECA508: 8163006C  lwz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECA50C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA510: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82ECA514: 8163006C  lwz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ECA518: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA51C: 4082FFE0  bne 0x82eca4fc
	if !ctx.cr[0].eq {
	pc = 0x82ECA4FC; continue 'dispatch;
	}
	// 82ECA520: 4800001C  b 0x82eca53c
	sub_82ECA524(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA524(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA524 size=48
    let mut pc: u32 = 0x82ECA524;
    'dispatch: loop {
        match pc {
            0x82ECA524 => {
    //   block [0x82ECA524..0x82ECA554)
	// 82ECA524: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA528: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ECA52C: 409A001C  bne cr6, 0x82eca548
	if !ctx.cr[6].eq {
	pc = 0x82ECA548; continue 'dispatch;
	}
	// 82ECA530: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ECA534: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ECA538: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82ECA53C: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ECA540: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA544: 4082FFE0  bne 0x82eca524
	if !ctx.cr[0].eq {
	pc = 0x82ECA524; continue 'dispatch;
	}
	// 82ECA548: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ECA54C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ECA550: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA554(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA554 size=12
    let mut pc: u32 = 0x82ECA554;
    'dispatch: loop {
        match pc {
            0x82ECA554 => {
    //   block [0x82ECA554..0x82ECA560)
	// 82ECA554: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ECA558: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ECA55C: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA560 size=12
    let mut pc: u32 = 0x82ECA560;
    'dispatch: loop {
        match pc {
            0x82ECA560 => {
    //   block [0x82ECA560..0x82ECA56C)
	// 82ECA560: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ECA564: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ECA568: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ECA56C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ECA56C size=8
    let mut pc: u32 = 0x82ECA56C;
    'dispatch: loop {
        match pc {
            0x82ECA56C => {
    //   block [0x82ECA56C..0x82ECA574)
	// 82ECA56C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82ECA570: 4BFBBFC0  b 0x82e86530
	sub_82E86530(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


