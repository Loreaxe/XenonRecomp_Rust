pub fn sub_832B9E94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9E94 size=16
    let mut pc: u32 = 0x832B9E94;
    'dispatch: loop {
        match pc {
            0x832B9E94 => {
    //   block [0x832B9E94..0x832B9EA4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9EA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9EA4 size=16
    let mut pc: u32 = 0x832B9EA4;
    'dispatch: loop {
        match pc {
            0x832B9EA4 => {
    //   block [0x832B9EA4..0x832B9EB4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9EB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9EB4 size=16
    let mut pc: u32 = 0x832B9EB4;
    'dispatch: loop {
        match pc {
            0x832B9EB4 => {
    //   block [0x832B9EB4..0x832B9EC4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9EC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9EC4 size=16
    let mut pc: u32 = 0x832B9EC4;
    'dispatch: loop {
        match pc {
            0x832B9EC4 => {
    //   block [0x832B9EC4..0x832B9ED4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9ED4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9ED4 size=16
    let mut pc: u32 = 0x832B9ED4;
    'dispatch: loop {
        match pc {
            0x832B9ED4 => {
    //   block [0x832B9ED4..0x832B9EE4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9EE4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9EE4 size=16
    let mut pc: u32 = 0x832B9EE4;
    'dispatch: loop {
        match pc {
            0x832B9EE4 => {
    //   block [0x832B9EE4..0x832B9EF4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9EF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9EF4 size=16
    let mut pc: u32 = 0x832B9EF4;
    'dispatch: loop {
        match pc {
            0x832B9EF4 => {
    //   block [0x832B9EF4..0x832B9F04)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F04(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F04 size=16
    let mut pc: u32 = 0x832B9F04;
    'dispatch: loop {
        match pc {
            0x832B9F04 => {
    //   block [0x832B9F04..0x832B9F14)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F14 size=16
    let mut pc: u32 = 0x832B9F14;
    'dispatch: loop {
        match pc {
            0x832B9F14 => {
    //   block [0x832B9F14..0x832B9F24)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F24(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F24 size=16
    let mut pc: u32 = 0x832B9F24;
    'dispatch: loop {
        match pc {
            0x832B9F24 => {
    //   block [0x832B9F24..0x832B9F34)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F34 size=16
    let mut pc: u32 = 0x832B9F34;
    'dispatch: loop {
        match pc {
            0x832B9F34 => {
    //   block [0x832B9F34..0x832B9F44)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F44 size=16
    let mut pc: u32 = 0x832B9F44;
    'dispatch: loop {
        match pc {
            0x832B9F44 => {
    //   block [0x832B9F44..0x832B9F54)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F54 size=16
    let mut pc: u32 = 0x832B9F54;
    'dispatch: loop {
        match pc {
            0x832B9F54 => {
    //   block [0x832B9F54..0x832B9F64)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F64 size=16
    let mut pc: u32 = 0x832B9F64;
    'dispatch: loop {
        match pc {
            0x832B9F64 => {
    //   block [0x832B9F64..0x832B9F74)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F74 size=16
    let mut pc: u32 = 0x832B9F74;
    'dispatch: loop {
        match pc {
            0x832B9F74 => {
    //   block [0x832B9F74..0x832B9F84)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F84 size=16
    let mut pc: u32 = 0x832B9F84;
    'dispatch: loop {
        match pc {
            0x832B9F84 => {
    //   block [0x832B9F84..0x832B9F94)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9F94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9F94 size=16
    let mut pc: u32 = 0x832B9F94;
    'dispatch: loop {
        match pc {
            0x832B9F94 => {
    //   block [0x832B9F94..0x832B9FA4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9FA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9FA4 size=16
    let mut pc: u32 = 0x832B9FA4;
    'dispatch: loop {
        match pc {
            0x832B9FA4 => {
    //   block [0x832B9FA4..0x832B9FB4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9FB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9FB4 size=16
    let mut pc: u32 = 0x832B9FB4;
    'dispatch: loop {
        match pc {
            0x832B9FB4 => {
    //   block [0x832B9FB4..0x832B9FC4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9FC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9FC4 size=16
    let mut pc: u32 = 0x832B9FC4;
    'dispatch: loop {
        match pc {
            0x832B9FC4 => {
    //   block [0x832B9FC4..0x832B9FD4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9FD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9FD4 size=16
    let mut pc: u32 = 0x832B9FD4;
    'dispatch: loop {
        match pc {
            0x832B9FD4 => {
    //   block [0x832B9FD4..0x832B9FE4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9FE4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9FE4 size=16
    let mut pc: u32 = 0x832B9FE4;
    'dispatch: loop {
        match pc {
            0x832B9FE4 => {
    //   block [0x832B9FE4..0x832B9FF4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B9FF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B9FF4 size=16
    let mut pc: u32 = 0x832B9FF4;
    'dispatch: loop {
        match pc {
            0x832B9FF4 => {
    //   block [0x832B9FF4..0x832BA004)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA004(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA004 size=16
    let mut pc: u32 = 0x832BA004;
    'dispatch: loop {
        match pc {
            0x832BA004 => {
    //   block [0x832BA004..0x832BA014)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA014(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA014 size=16
    let mut pc: u32 = 0x832BA014;
    'dispatch: loop {
        match pc {
            0x832BA014 => {
    //   block [0x832BA014..0x832BA024)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA024(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA024 size=16
    let mut pc: u32 = 0x832BA024;
    'dispatch: loop {
        match pc {
            0x832BA024 => {
    //   block [0x832BA024..0x832BA034)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA034(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA034 size=16
    let mut pc: u32 = 0x832BA034;
    'dispatch: loop {
        match pc {
            0x832BA034 => {
    //   block [0x832BA034..0x832BA044)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA044(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA044 size=16
    let mut pc: u32 = 0x832BA044;
    'dispatch: loop {
        match pc {
            0x832BA044 => {
    //   block [0x832BA044..0x832BA054)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA054(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA054 size=16
    let mut pc: u32 = 0x832BA054;
    'dispatch: loop {
        match pc {
            0x832BA054 => {
    //   block [0x832BA054..0x832BA064)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA064(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA064 size=16
    let mut pc: u32 = 0x832BA064;
    'dispatch: loop {
        match pc {
            0x832BA064 => {
    //   block [0x832BA064..0x832BA074)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA074(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA074 size=16
    let mut pc: u32 = 0x832BA074;
    'dispatch: loop {
        match pc {
            0x832BA074 => {
    //   block [0x832BA074..0x832BA084)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA084(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA084 size=16
    let mut pc: u32 = 0x832BA084;
    'dispatch: loop {
        match pc {
            0x832BA084 => {
    //   block [0x832BA084..0x832BA094)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA094(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA094 size=16
    let mut pc: u32 = 0x832BA094;
    'dispatch: loop {
        match pc {
            0x832BA094 => {
    //   block [0x832BA094..0x832BA0A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA0A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA0A4 size=16
    let mut pc: u32 = 0x832BA0A4;
    'dispatch: loop {
        match pc {
            0x832BA0A4 => {
    //   block [0x832BA0A4..0x832BA0B4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA0B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA0B4 size=16
    let mut pc: u32 = 0x832BA0B4;
    'dispatch: loop {
        match pc {
            0x832BA0B4 => {
    //   block [0x832BA0B4..0x832BA0C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA0C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA0C4 size=16
    let mut pc: u32 = 0x832BA0C4;
    'dispatch: loop {
        match pc {
            0x832BA0C4 => {
    //   block [0x832BA0C4..0x832BA0D4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA0D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA0D4 size=16
    let mut pc: u32 = 0x832BA0D4;
    'dispatch: loop {
        match pc {
            0x832BA0D4 => {
    //   block [0x832BA0D4..0x832BA0E4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA0E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA0E4 size=16
    let mut pc: u32 = 0x832BA0E4;
    'dispatch: loop {
        match pc {
            0x832BA0E4 => {
    //   block [0x832BA0E4..0x832BA0F4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA0F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA0F4 size=16
    let mut pc: u32 = 0x832BA0F4;
    'dispatch: loop {
        match pc {
            0x832BA0F4 => {
    //   block [0x832BA0F4..0x832BA104)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA104(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA104 size=16
    let mut pc: u32 = 0x832BA104;
    'dispatch: loop {
        match pc {
            0x832BA104 => {
    //   block [0x832BA104..0x832BA114)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA114(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA114 size=16
    let mut pc: u32 = 0x832BA114;
    'dispatch: loop {
        match pc {
            0x832BA114 => {
    //   block [0x832BA114..0x832BA124)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA124(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA124 size=16
    let mut pc: u32 = 0x832BA124;
    'dispatch: loop {
        match pc {
            0x832BA124 => {
    //   block [0x832BA124..0x832BA134)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA134(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA134 size=16
    let mut pc: u32 = 0x832BA134;
    'dispatch: loop {
        match pc {
            0x832BA134 => {
    //   block [0x832BA134..0x832BA144)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA144(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA144 size=16
    let mut pc: u32 = 0x832BA144;
    'dispatch: loop {
        match pc {
            0x832BA144 => {
    //   block [0x832BA144..0x832BA154)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA154(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA154 size=16
    let mut pc: u32 = 0x832BA154;
    'dispatch: loop {
        match pc {
            0x832BA154 => {
    //   block [0x832BA154..0x832BA164)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA164(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA164 size=16
    let mut pc: u32 = 0x832BA164;
    'dispatch: loop {
        match pc {
            0x832BA164 => {
    //   block [0x832BA164..0x832BA174)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA174(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA174 size=16
    let mut pc: u32 = 0x832BA174;
    'dispatch: loop {
        match pc {
            0x832BA174 => {
    //   block [0x832BA174..0x832BA184)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA184(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA184 size=16
    let mut pc: u32 = 0x832BA184;
    'dispatch: loop {
        match pc {
            0x832BA184 => {
    //   block [0x832BA184..0x832BA194)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA194(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA194 size=16
    let mut pc: u32 = 0x832BA194;
    'dispatch: loop {
        match pc {
            0x832BA194 => {
    //   block [0x832BA194..0x832BA1A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA1A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA1A4 size=16
    let mut pc: u32 = 0x832BA1A4;
    'dispatch: loop {
        match pc {
            0x832BA1A4 => {
    //   block [0x832BA1A4..0x832BA1B4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA1B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA1B4 size=16
    let mut pc: u32 = 0x832BA1B4;
    'dispatch: loop {
        match pc {
            0x832BA1B4 => {
    //   block [0x832BA1B4..0x832BA1C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA1C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA1C4 size=16
    let mut pc: u32 = 0x832BA1C4;
    'dispatch: loop {
        match pc {
            0x832BA1C4 => {
    //   block [0x832BA1C4..0x832BA1D4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA1D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA1D4 size=16
    let mut pc: u32 = 0x832BA1D4;
    'dispatch: loop {
        match pc {
            0x832BA1D4 => {
    //   block [0x832BA1D4..0x832BA1E4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA1E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA1E4 size=16
    let mut pc: u32 = 0x832BA1E4;
    'dispatch: loop {
        match pc {
            0x832BA1E4 => {
    //   block [0x832BA1E4..0x832BA1F4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA1F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA1F4 size=16
    let mut pc: u32 = 0x832BA1F4;
    'dispatch: loop {
        match pc {
            0x832BA1F4 => {
    //   block [0x832BA1F4..0x832BA204)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA204(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA204 size=16
    let mut pc: u32 = 0x832BA204;
    'dispatch: loop {
        match pc {
            0x832BA204 => {
    //   block [0x832BA204..0x832BA214)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA214(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA214 size=16
    let mut pc: u32 = 0x832BA214;
    'dispatch: loop {
        match pc {
            0x832BA214 => {
    //   block [0x832BA214..0x832BA224)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA224(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA224 size=16
    let mut pc: u32 = 0x832BA224;
    'dispatch: loop {
        match pc {
            0x832BA224 => {
    //   block [0x832BA224..0x832BA234)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA234(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA234 size=16
    let mut pc: u32 = 0x832BA234;
    'dispatch: loop {
        match pc {
            0x832BA234 => {
    //   block [0x832BA234..0x832BA244)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA244(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA244 size=16
    let mut pc: u32 = 0x832BA244;
    'dispatch: loop {
        match pc {
            0x832BA244 => {
    //   block [0x832BA244..0x832BA254)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA254(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA254 size=16
    let mut pc: u32 = 0x832BA254;
    'dispatch: loop {
        match pc {
            0x832BA254 => {
    //   block [0x832BA254..0x832BA264)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA264(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA264 size=16
    let mut pc: u32 = 0x832BA264;
    'dispatch: loop {
        match pc {
            0x832BA264 => {
    //   block [0x832BA264..0x832BA274)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA274(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA274 size=16
    let mut pc: u32 = 0x832BA274;
    'dispatch: loop {
        match pc {
            0x832BA274 => {
    //   block [0x832BA274..0x832BA284)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA284(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA284 size=16
    let mut pc: u32 = 0x832BA284;
    'dispatch: loop {
        match pc {
            0x832BA284 => {
    //   block [0x832BA284..0x832BA294)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA294(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA294 size=16
    let mut pc: u32 = 0x832BA294;
    'dispatch: loop {
        match pc {
            0x832BA294 => {
    //   block [0x832BA294..0x832BA2A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA2A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA2A4 size=16
    let mut pc: u32 = 0x832BA2A4;
    'dispatch: loop {
        match pc {
            0x832BA2A4 => {
    //   block [0x832BA2A4..0x832BA2B4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA2B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA2B4 size=16
    let mut pc: u32 = 0x832BA2B4;
    'dispatch: loop {
        match pc {
            0x832BA2B4 => {
    //   block [0x832BA2B4..0x832BA2C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA2C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA2C4 size=16
    let mut pc: u32 = 0x832BA2C4;
    'dispatch: loop {
        match pc {
            0x832BA2C4 => {
    //   block [0x832BA2C4..0x832BA2D4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA2D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA2D4 size=16
    let mut pc: u32 = 0x832BA2D4;
    'dispatch: loop {
        match pc {
            0x832BA2D4 => {
    //   block [0x832BA2D4..0x832BA2E4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA2E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA2E4 size=16
    let mut pc: u32 = 0x832BA2E4;
    'dispatch: loop {
        match pc {
            0x832BA2E4 => {
    //   block [0x832BA2E4..0x832BA2F4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA2F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA2F4 size=16
    let mut pc: u32 = 0x832BA2F4;
    'dispatch: loop {
        match pc {
            0x832BA2F4 => {
    //   block [0x832BA2F4..0x832BA304)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA304(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA304 size=16
    let mut pc: u32 = 0x832BA304;
    'dispatch: loop {
        match pc {
            0x832BA304 => {
    //   block [0x832BA304..0x832BA314)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA314(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA314 size=16
    let mut pc: u32 = 0x832BA314;
    'dispatch: loop {
        match pc {
            0x832BA314 => {
    //   block [0x832BA314..0x832BA324)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA324(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA324 size=16
    let mut pc: u32 = 0x832BA324;
    'dispatch: loop {
        match pc {
            0x832BA324 => {
    //   block [0x832BA324..0x832BA334)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA334(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA334 size=16
    let mut pc: u32 = 0x832BA334;
    'dispatch: loop {
        match pc {
            0x832BA334 => {
    //   block [0x832BA334..0x832BA344)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA344(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA344 size=16
    let mut pc: u32 = 0x832BA344;
    'dispatch: loop {
        match pc {
            0x832BA344 => {
    //   block [0x832BA344..0x832BA354)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA354(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA354 size=16
    let mut pc: u32 = 0x832BA354;
    'dispatch: loop {
        match pc {
            0x832BA354 => {
    //   block [0x832BA354..0x832BA364)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA364(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA364 size=16
    let mut pc: u32 = 0x832BA364;
    'dispatch: loop {
        match pc {
            0x832BA364 => {
    //   block [0x832BA364..0x832BA374)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA374(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA374 size=16
    let mut pc: u32 = 0x832BA374;
    'dispatch: loop {
        match pc {
            0x832BA374 => {
    //   block [0x832BA374..0x832BA384)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA384(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA384 size=16
    let mut pc: u32 = 0x832BA384;
    'dispatch: loop {
        match pc {
            0x832BA384 => {
    //   block [0x832BA384..0x832BA394)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA394(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA394 size=16
    let mut pc: u32 = 0x832BA394;
    'dispatch: loop {
        match pc {
            0x832BA394 => {
    //   block [0x832BA394..0x832BA3A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA3A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA3A4 size=16
    let mut pc: u32 = 0x832BA3A4;
    'dispatch: loop {
        match pc {
            0x832BA3A4 => {
    //   block [0x832BA3A4..0x832BA3B4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA3B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA3B4 size=16
    let mut pc: u32 = 0x832BA3B4;
    'dispatch: loop {
        match pc {
            0x832BA3B4 => {
    //   block [0x832BA3B4..0x832BA3C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA3C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA3C4 size=16
    let mut pc: u32 = 0x832BA3C4;
    'dispatch: loop {
        match pc {
            0x832BA3C4 => {
    //   block [0x832BA3C4..0x832BA3D4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA3D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA3D4 size=16
    let mut pc: u32 = 0x832BA3D4;
    'dispatch: loop {
        match pc {
            0x832BA3D4 => {
    //   block [0x832BA3D4..0x832BA3E4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA3E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA3E4 size=16
    let mut pc: u32 = 0x832BA3E4;
    'dispatch: loop {
        match pc {
            0x832BA3E4 => {
    //   block [0x832BA3E4..0x832BA3F4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA3F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA3F4 size=16
    let mut pc: u32 = 0x832BA3F4;
    'dispatch: loop {
        match pc {
            0x832BA3F4 => {
    //   block [0x832BA3F4..0x832BA404)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA404(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA404 size=16
    let mut pc: u32 = 0x832BA404;
    'dispatch: loop {
        match pc {
            0x832BA404 => {
    //   block [0x832BA404..0x832BA414)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA414(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA414 size=16
    let mut pc: u32 = 0x832BA414;
    'dispatch: loop {
        match pc {
            0x832BA414 => {
    //   block [0x832BA414..0x832BA424)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA424(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA424 size=16
    let mut pc: u32 = 0x832BA424;
    'dispatch: loop {
        match pc {
            0x832BA424 => {
    //   block [0x832BA424..0x832BA434)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA434(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA434 size=16
    let mut pc: u32 = 0x832BA434;
    'dispatch: loop {
        match pc {
            0x832BA434 => {
    //   block [0x832BA434..0x832BA444)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA444(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA444 size=16
    let mut pc: u32 = 0x832BA444;
    'dispatch: loop {
        match pc {
            0x832BA444 => {
    //   block [0x832BA444..0x832BA454)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA454(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA454 size=16
    let mut pc: u32 = 0x832BA454;
    'dispatch: loop {
        match pc {
            0x832BA454 => {
    //   block [0x832BA454..0x832BA464)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA464(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA464 size=16
    let mut pc: u32 = 0x832BA464;
    'dispatch: loop {
        match pc {
            0x832BA464 => {
    //   block [0x832BA464..0x832BA474)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA474(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA474 size=16
    let mut pc: u32 = 0x832BA474;
    'dispatch: loop {
        match pc {
            0x832BA474 => {
    //   block [0x832BA474..0x832BA484)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA484(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA484 size=16
    let mut pc: u32 = 0x832BA484;
    'dispatch: loop {
        match pc {
            0x832BA484 => {
    //   block [0x832BA484..0x832BA494)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA494(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA494 size=16
    let mut pc: u32 = 0x832BA494;
    'dispatch: loop {
        match pc {
            0x832BA494 => {
    //   block [0x832BA494..0x832BA4A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA4A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA4A4 size=16
    let mut pc: u32 = 0x832BA4A4;
    'dispatch: loop {
        match pc {
            0x832BA4A4 => {
    //   block [0x832BA4A4..0x832BA4B4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA4B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA4B4 size=16
    let mut pc: u32 = 0x832BA4B4;
    'dispatch: loop {
        match pc {
            0x832BA4B4 => {
    //   block [0x832BA4B4..0x832BA4C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA4C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA4C4 size=16
    let mut pc: u32 = 0x832BA4C4;
    'dispatch: loop {
        match pc {
            0x832BA4C4 => {
    //   block [0x832BA4C4..0x832BA4D4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA4D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA4D4 size=16
    let mut pc: u32 = 0x832BA4D4;
    'dispatch: loop {
        match pc {
            0x832BA4D4 => {
    //   block [0x832BA4D4..0x832BA4E4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA4E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA4E4 size=16
    let mut pc: u32 = 0x832BA4E4;
    'dispatch: loop {
        match pc {
            0x832BA4E4 => {
    //   block [0x832BA4E4..0x832BA4F4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA4F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA4F4 size=16
    let mut pc: u32 = 0x832BA4F4;
    'dispatch: loop {
        match pc {
            0x832BA4F4 => {
    //   block [0x832BA4F4..0x832BA504)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA504(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA504 size=16
    let mut pc: u32 = 0x832BA504;
    'dispatch: loop {
        match pc {
            0x832BA504 => {
    //   block [0x832BA504..0x832BA514)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA514(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA514 size=16
    let mut pc: u32 = 0x832BA514;
    'dispatch: loop {
        match pc {
            0x832BA514 => {
    //   block [0x832BA514..0x832BA524)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA524(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA524 size=16
    let mut pc: u32 = 0x832BA524;
    'dispatch: loop {
        match pc {
            0x832BA524 => {
    //   block [0x832BA524..0x832BA534)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA534(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA534 size=16
    let mut pc: u32 = 0x832BA534;
    'dispatch: loop {
        match pc {
            0x832BA534 => {
    //   block [0x832BA534..0x832BA544)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA544(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA544 size=16
    let mut pc: u32 = 0x832BA544;
    'dispatch: loop {
        match pc {
            0x832BA544 => {
    //   block [0x832BA544..0x832BA554)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA554(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA554 size=16
    let mut pc: u32 = 0x832BA554;
    'dispatch: loop {
        match pc {
            0x832BA554 => {
    //   block [0x832BA554..0x832BA564)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA564(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA564 size=16
    let mut pc: u32 = 0x832BA564;
    'dispatch: loop {
        match pc {
            0x832BA564 => {
    //   block [0x832BA564..0x832BA574)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA574(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA574 size=16
    let mut pc: u32 = 0x832BA574;
    'dispatch: loop {
        match pc {
            0x832BA574 => {
    //   block [0x832BA574..0x832BA584)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA584(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA584 size=16
    let mut pc: u32 = 0x832BA584;
    'dispatch: loop {
        match pc {
            0x832BA584 => {
    //   block [0x832BA584..0x832BA594)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA594(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA594 size=16
    let mut pc: u32 = 0x832BA594;
    'dispatch: loop {
        match pc {
            0x832BA594 => {
    //   block [0x832BA594..0x832BA5A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA5A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA5A4 size=16
    let mut pc: u32 = 0x832BA5A4;
    'dispatch: loop {
        match pc {
            0x832BA5A4 => {
    //   block [0x832BA5A4..0x832BA5B4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA5B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA5B4 size=16
    let mut pc: u32 = 0x832BA5B4;
    'dispatch: loop {
        match pc {
            0x832BA5B4 => {
    //   block [0x832BA5B4..0x832BA5C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA5C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA5C4 size=16
    let mut pc: u32 = 0x832BA5C4;
    'dispatch: loop {
        match pc {
            0x832BA5C4 => {
    //   block [0x832BA5C4..0x832BA5D4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA5D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA5D4 size=16
    let mut pc: u32 = 0x832BA5D4;
    'dispatch: loop {
        match pc {
            0x832BA5D4 => {
    //   block [0x832BA5D4..0x832BA5E4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA5E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA5E4 size=16
    let mut pc: u32 = 0x832BA5E4;
    'dispatch: loop {
        match pc {
            0x832BA5E4 => {
    //   block [0x832BA5E4..0x832BA5F4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA5F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA5F4 size=16
    let mut pc: u32 = 0x832BA5F4;
    'dispatch: loop {
        match pc {
            0x832BA5F4 => {
    //   block [0x832BA5F4..0x832BA604)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA604(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA604 size=16
    let mut pc: u32 = 0x832BA604;
    'dispatch: loop {
        match pc {
            0x832BA604 => {
    //   block [0x832BA604..0x832BA614)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA614(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA614 size=16
    let mut pc: u32 = 0x832BA614;
    'dispatch: loop {
        match pc {
            0x832BA614 => {
    //   block [0x832BA614..0x832BA624)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA624(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA624 size=16
    let mut pc: u32 = 0x832BA624;
    'dispatch: loop {
        match pc {
            0x832BA624 => {
    //   block [0x832BA624..0x832BA634)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA634(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA634 size=16
    let mut pc: u32 = 0x832BA634;
    'dispatch: loop {
        match pc {
            0x832BA634 => {
    //   block [0x832BA634..0x832BA644)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA644(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA644 size=16
    let mut pc: u32 = 0x832BA644;
    'dispatch: loop {
        match pc {
            0x832BA644 => {
    //   block [0x832BA644..0x832BA654)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA654(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA654 size=16
    let mut pc: u32 = 0x832BA654;
    'dispatch: loop {
        match pc {
            0x832BA654 => {
    //   block [0x832BA654..0x832BA664)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA664(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA664 size=16
    let mut pc: u32 = 0x832BA664;
    'dispatch: loop {
        match pc {
            0x832BA664 => {
    //   block [0x832BA664..0x832BA674)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA674(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA674 size=16
    let mut pc: u32 = 0x832BA674;
    'dispatch: loop {
        match pc {
            0x832BA674 => {
    //   block [0x832BA674..0x832BA684)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA684(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA684 size=16
    let mut pc: u32 = 0x832BA684;
    'dispatch: loop {
        match pc {
            0x832BA684 => {
    //   block [0x832BA684..0x832BA694)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA694(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA694 size=16
    let mut pc: u32 = 0x832BA694;
    'dispatch: loop {
        match pc {
            0x832BA694 => {
    //   block [0x832BA694..0x832BA6A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA6A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA6A4 size=16
    let mut pc: u32 = 0x832BA6A4;
    'dispatch: loop {
        match pc {
            0x832BA6A4 => {
    //   block [0x832BA6A4..0x832BA6B4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA6B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA6B4 size=16
    let mut pc: u32 = 0x832BA6B4;
    'dispatch: loop {
        match pc {
            0x832BA6B4 => {
    //   block [0x832BA6B4..0x832BA6C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA6C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA6C4 size=16
    let mut pc: u32 = 0x832BA6C4;
    'dispatch: loop {
        match pc {
            0x832BA6C4 => {
    //   block [0x832BA6C4..0x832BA6D4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA6D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA6D4 size=16
    let mut pc: u32 = 0x832BA6D4;
    'dispatch: loop {
        match pc {
            0x832BA6D4 => {
    //   block [0x832BA6D4..0x832BA6E4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA6E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA6E4 size=16
    let mut pc: u32 = 0x832BA6E4;
    'dispatch: loop {
        match pc {
            0x832BA6E4 => {
    //   block [0x832BA6E4..0x832BA6F4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA6F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA6F4 size=16
    let mut pc: u32 = 0x832BA6F4;
    'dispatch: loop {
        match pc {
            0x832BA6F4 => {
    //   block [0x832BA6F4..0x832BA704)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA704(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA704 size=16
    let mut pc: u32 = 0x832BA704;
    'dispatch: loop {
        match pc {
            0x832BA704 => {
    //   block [0x832BA704..0x832BA714)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA714(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA714 size=16
    let mut pc: u32 = 0x832BA714;
    'dispatch: loop {
        match pc {
            0x832BA714 => {
    //   block [0x832BA714..0x832BA724)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA724(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA724 size=16
    let mut pc: u32 = 0x832BA724;
    'dispatch: loop {
        match pc {
            0x832BA724 => {
    //   block [0x832BA724..0x832BA734)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA734(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA734 size=16
    let mut pc: u32 = 0x832BA734;
    'dispatch: loop {
        match pc {
            0x832BA734 => {
    //   block [0x832BA734..0x832BA744)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA744(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA744 size=16
    let mut pc: u32 = 0x832BA744;
    'dispatch: loop {
        match pc {
            0x832BA744 => {
    //   block [0x832BA744..0x832BA754)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA754(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA754 size=16
    let mut pc: u32 = 0x832BA754;
    'dispatch: loop {
        match pc {
            0x832BA754 => {
    //   block [0x832BA754..0x832BA764)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA764(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA764 size=16
    let mut pc: u32 = 0x832BA764;
    'dispatch: loop {
        match pc {
            0x832BA764 => {
    //   block [0x832BA764..0x832BA774)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA774(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA774 size=16
    let mut pc: u32 = 0x832BA774;
    'dispatch: loop {
        match pc {
            0x832BA774 => {
    //   block [0x832BA774..0x832BA784)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA784(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA784 size=16
    let mut pc: u32 = 0x832BA784;
    'dispatch: loop {
        match pc {
            0x832BA784 => {
    //   block [0x832BA784..0x832BA794)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA794(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA794 size=16
    let mut pc: u32 = 0x832BA794;
    'dispatch: loop {
        match pc {
            0x832BA794 => {
    //   block [0x832BA794..0x832BA7A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA7A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA7A4 size=16
    let mut pc: u32 = 0x832BA7A4;
    'dispatch: loop {
        match pc {
            0x832BA7A4 => {
    //   block [0x832BA7A4..0x832BA7B4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA7B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA7B4 size=16
    let mut pc: u32 = 0x832BA7B4;
    'dispatch: loop {
        match pc {
            0x832BA7B4 => {
    //   block [0x832BA7B4..0x832BA7C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA7C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA7C4 size=16
    let mut pc: u32 = 0x832BA7C4;
    'dispatch: loop {
        match pc {
            0x832BA7C4 => {
    //   block [0x832BA7C4..0x832BA7D4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA7D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA7D4 size=16
    let mut pc: u32 = 0x832BA7D4;
    'dispatch: loop {
        match pc {
            0x832BA7D4 => {
    //   block [0x832BA7D4..0x832BA7E4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA7E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA7E4 size=16
    let mut pc: u32 = 0x832BA7E4;
    'dispatch: loop {
        match pc {
            0x832BA7E4 => {
    //   block [0x832BA7E4..0x832BA7F4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA7F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA7F4 size=16
    let mut pc: u32 = 0x832BA7F4;
    'dispatch: loop {
        match pc {
            0x832BA7F4 => {
    //   block [0x832BA7F4..0x832BA804)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA804(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA804 size=16
    let mut pc: u32 = 0x832BA804;
    'dispatch: loop {
        match pc {
            0x832BA804 => {
    //   block [0x832BA804..0x832BA814)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA814(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA814 size=16
    let mut pc: u32 = 0x832BA814;
    'dispatch: loop {
        match pc {
            0x832BA814 => {
    //   block [0x832BA814..0x832BA824)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA824(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA824 size=16
    let mut pc: u32 = 0x832BA824;
    'dispatch: loop {
        match pc {
            0x832BA824 => {
    //   block [0x832BA824..0x832BA834)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA834(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA834 size=16
    let mut pc: u32 = 0x832BA834;
    'dispatch: loop {
        match pc {
            0x832BA834 => {
    //   block [0x832BA834..0x832BA844)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA844(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA844 size=16
    let mut pc: u32 = 0x832BA844;
    'dispatch: loop {
        match pc {
            0x832BA844 => {
    //   block [0x832BA844..0x832BA854)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA854(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA854 size=16
    let mut pc: u32 = 0x832BA854;
    'dispatch: loop {
        match pc {
            0x832BA854 => {
    //   block [0x832BA854..0x832BA864)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA864(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA864 size=16
    let mut pc: u32 = 0x832BA864;
    'dispatch: loop {
        match pc {
            0x832BA864 => {
    //   block [0x832BA864..0x832BA874)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA874(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA874 size=16
    let mut pc: u32 = 0x832BA874;
    'dispatch: loop {
        match pc {
            0x832BA874 => {
    //   block [0x832BA874..0x832BA884)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA884(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA884 size=16
    let mut pc: u32 = 0x832BA884;
    'dispatch: loop {
        match pc {
            0x832BA884 => {
    //   block [0x832BA884..0x832BA894)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA894(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA894 size=16
    let mut pc: u32 = 0x832BA894;
    'dispatch: loop {
        match pc {
            0x832BA894 => {
    //   block [0x832BA894..0x832BA8A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA8A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA8A4 size=16
    let mut pc: u32 = 0x832BA8A4;
    'dispatch: loop {
        match pc {
            0x832BA8A4 => {
    //   block [0x832BA8A4..0x832BA8B4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA8B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA8B4 size=16
    let mut pc: u32 = 0x832BA8B4;
    'dispatch: loop {
        match pc {
            0x832BA8B4 => {
    //   block [0x832BA8B4..0x832BA8C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA8C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA8C4 size=16
    let mut pc: u32 = 0x832BA8C4;
    'dispatch: loop {
        match pc {
            0x832BA8C4 => {
    //   block [0x832BA8C4..0x832BA8D4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA8D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA8D4 size=4
    let mut pc: u32 = 0x832BA8D4;
    'dispatch: loop {
        match pc {
            0x832BA8D4 => {
    //   block [0x832BA8D4..0x832BA8D8)
	// 832BA8D4: 48000000  b 0x832ba8d4
	pc = 0x832BA8D4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BA8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BA8D8 size=8
    let mut pc: u32 = 0x832BA8D8;
    'dispatch: loop {
        match pc {
            0x832BA8D8 => {
    //   block [0x832BA8D8..0x832BA8E0)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BAC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BAC00 size=172
    let mut pc: u32 = 0x832BAC00;
    'dispatch: loop {
        match pc {
            0x832BAC00 => {
    //   block [0x832BAC00..0x832BACAC)
	// 832BAC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BAC04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BAC08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BAC0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BAC10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BAC14: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832BAC18: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 832BAC1C: 3BEBC46C  addi r31, r11, -0x3b94
	ctx.r[31].s64 = ctx.r[11].s64 + -15252;
	// 832BAC20: 38E4001F  addi r7, r4, 0x1f
	ctx.r[7].s64 = ctx.r[4].s64 + 31;
	// 832BAC24: 54FE0034  rlwinm r30, r7, 0, 0, 0x1a
	ctx.r[30].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 832BAC28: 812802DC  lwz r9, 0x2dc(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(732 as u32) ) } as u64;
	// 832BAC2C: 817FFDB0  lwz r11, -0x250(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-592 as u32) ) } as u64;
	// 832BAC30: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 832BAC34: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 832BAC38: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 832BAC3C: 90C802DC  stw r6, 0x2dc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(732 as u32), ctx.r[6].u32 ) };
	// 832BAC40: 4B92F151  bl 0x82be9d90
	ctx.lr = 0x832BAC44;
	sub_82BE9D90(ctx, base);
	// 832BAC44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832BAC48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BAC4C: 917FFDB0  stw r11, -0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-592 as u32), ctx.r[11].u32 ) };
	// 832BAC50: 419A003C  beq cr6, 0x832bac8c
	if ctx.cr[6].eq {
	pc = 0x832BAC8C; continue 'dispatch;
	}
	// 832BAC54: 815FFE18  lwz r10, -0x1e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-488 as u32) ) } as u64;
	// 832BAC58: 7D23F214  add r9, r3, r30
	ctx.r[9].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 832BAC5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BAC60: 419A002C  beq cr6, 0x832bac8c
	if ctx.cr[6].eq {
	pc = 0x832BAC8C; continue 'dispatch;
	}
	// 832BAC64: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BAC68: 811FFFFC  lwz r8, -4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 832BAC6C: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 832BAC70: 7D07582E  lwzx r8, r7, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 832BAC74: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BAC78: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 832BAC7C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BAC80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BAC84: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 832BAC88: 4082FFE8  bne 0x832bac70
	if !ctx.cr[0].eq {
	pc = 0x832BAC70; continue 'dispatch;
	}
	// 832BAC8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832BAC90: 917FFE18  stw r11, -0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-488 as u32), ctx.r[11].u32 ) };
	// 832BAC94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BAC98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BAC9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BACA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BACA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BACA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BACB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BACB0 size=36
    let mut pc: u32 = 0x832BACB0;
    'dispatch: loop {
        match pc {
            0x832BACB0 => {
    //   block [0x832BACB0..0x832BACD4)
	// 832BACB0: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BACB4: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 832BACB8: 390966B0  addi r8, r9, 0x66b0
	ctx.r[8].s64 = ctx.r[9].s64 + 26288;
	// 832BACBC: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 832BACC0: 994966B0  stb r10, 0x66b0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(26288 as u32), ctx.r[10].u8 ) };
	// 832BACC4: 21480001  subfic r10, r8, 1
	ctx.xer.ca = ctx.r[8].u32 <= 1 as u32;
	ctx.r[10].s64 = (1 as i64) - ctx.r[8].s64;
	// 832BACC8: 89230000  lbz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BACCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BACD0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BACD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BACD4 size=40
    let mut pc: u32 = 0x832BACD4;
    'dispatch: loop {
        match pc {
            0x832BACD4 => {
    //   block [0x832BACD4..0x832BACFC)
	// 832BACD4: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 832BACD8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832BACDC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BACE0: 89030000  lbz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BACE4: 2F0900FF  cmpwi cr6, r9, 0xff
	ctx.cr[6].compare_i32(ctx.r[9].s32, 255, &mut ctx.xer);
	// 832BACE8: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 832BACEC: 409AFFDC  bne cr6, 0x832bacc8
	if !ctx.cr[6].eq {
		sub_832BACB0(ctx, base);
		return;
	}
	// 832BACF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BACF4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 832BACF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BAD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BAD00 size=760
    let mut pc: u32 = 0x832BAD00;
    'dispatch: loop {
        match pc {
            0x832BAD00 => {
    //   block [0x832BAD00..0x832BAFF8)
	// 832BAD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BAD04: 4B9EE6FD  bl 0x82ca9400
	ctx.lr = 0x832BAD08;
	sub_82CA93D0(ctx, base);
	// 832BAD08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BAD0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 832BAD10: 817D0114  lwz r11, 0x114(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BAD14: 815D0118  lwz r10, 0x118(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BAD18: 1D6B0184  mulli r11, r11, 0x184
	ctx.r[11].s64 = ctx.r[11].s64 * 388;
	// 832BAD1C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BAD20: 812AFFD8  lwz r9, -0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-40 as u32) ) } as u64;
	// 832BAD24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BAD28: 419A02C8  beq cr6, 0x832baff0
	if ctx.cr[6].eq {
	pc = 0x832BAFF0; continue 'dispatch;
	}
	// 832BAD2C: 817D02B4  lwz r11, 0x2b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(692 as u32) ) } as u64;
	// 832BAD30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BAD34: 419A02BC  beq cr6, 0x832baff0
	if ctx.cr[6].eq {
	pc = 0x832BAFF0; continue 'dispatch;
	}
	// 832BAD38: 3B5D0354  addi r26, r29, 0x354
	ctx.r[26].s64 = ctx.r[29].s64 + 852;
	// 832BAD3C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 832BAD40: 419A0020  beq cr6, 0x832bad60
	if ctx.cr[6].eq {
	pc = 0x832BAD60; continue 'dispatch;
	}
	// 832BAD44: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BAD48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BAD4C: 419A0014  beq cr6, 0x832bad60
	if ctx.cr[6].eq {
	pc = 0x832BAD60; continue 'dispatch;
	}
	// 832BAD50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BAD54: 4AEDBC75  bl 0x821969c8
	ctx.lr = 0x832BAD58;
	sub_821969C8(ctx, base);
	// 832BAD58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BAD5C: 409A0294  bne cr6, 0x832baff0
	if !ctx.cr[6].eq {
	pc = 0x832BAFF0; continue 'dispatch;
	}
	// 832BAD60: 817D0114  lwz r11, 0x114(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BAD64: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 832BAD68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BAD6C: 4099026C  ble cr6, 0x832bafd8
	if !ctx.cr[6].gt {
	pc = 0x832BAFD8; continue 'dispatch;
	}
	// 832BAD70: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832BAD74: 817D0118  lwz r11, 0x118(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BAD78: 7FDC5A14  add r30, r28, r11
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 832BAD7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BAD80: 817E015C  lwz r11, 0x15c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 832BAD84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BAD88: 4E800421  bctrl
	ctx.lr = 0x832BAD8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BAD8C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BAD90: 419A0234  beq cr6, 0x832bafc4
	if ctx.cr[6].eq {
	pc = 0x832BAFC4; continue 'dispatch;
	}
	// 832BAD94: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BAD98: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BAD9C: 7FEA5851  subf. r31, r10, r11
	ctx.r[31].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 832BADA0: 4080000C  bge 0x832badac
	if !ctx.cr[0].lt {
	pc = 0x832BADAC; continue 'dispatch;
	}
	// 832BADA4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BADA8: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 832BADAC: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 832BADB0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 832BADB4: 4199001C  bgt cr6, 0x832badd0
	if ctx.cr[6].gt {
	pc = 0x832BADD0; continue 'dispatch;
	}
	// 832BADB8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BADBC: 815E0044  lwz r10, 0x44(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 832BADC0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 832BADC4: 40990200  ble cr6, 0x832bafc4
	if !ctx.cr[6].gt {
	pc = 0x832BAFC4; continue 'dispatch;
	}
	// 832BADC8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 832BADCC: 419A01F8  beq cr6, 0x832bafc4
	if ctx.cr[6].eq {
	pc = 0x832BAFC4; continue 'dispatch;
	}
	// 832BADD0: 817E0160  lwz r11, 0x160(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 832BADD4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832BADD8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 832BADDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BADE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BADE4: 4E800421  bctrl
	ctx.lr = 0x832BADE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BADE8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BADEC: 419A01D8  beq cr6, 0x832bafc4
	if ctx.cr[6].eq {
	pc = 0x832BAFC4; continue 'dispatch;
	}
	// 832BADF0: 817E0058  lwz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 832BADF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BADF8: 419A0014  beq cr6, 0x832bae0c
	if ctx.cr[6].eq {
	pc = 0x832BAE0C; continue 'dispatch;
	}
	// 832BADFC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BAE00: 5545083C  slwi r5, r10, 1
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BAE04: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 832BAE08: 48000008  b 0x832bae10
	pc = 0x832BAE10; continue 'dispatch;
	// 832BAE0C: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BAE10: 7F05F840  cmplw cr6, r5, r31
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[31].u32, &mut ctx.xer);
	// 832BAE14: 4099000C  ble cr6, 0x832bae20
	if !ctx.cr[6].gt {
	pc = 0x832BAE20; continue 'dispatch;
	}
	// 832BAE18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 832BAE1C: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 832BAE20: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BAE24: 813E0044  lwz r9, 0x44(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 832BAE28: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 832BAE2C: 41990014  bgt cr6, 0x832bae40
	if ctx.cr[6].gt {
	pc = 0x832BAE40; continue 'dispatch;
	}
	// 832BAE30: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 832BAE34: 7D495830  slw r9, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 832BAE38: 7D252838  and r5, r9, r5
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[5].u64;
	// 832BAE3C: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 832BAE40: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BAE44: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 832BAE48: 7FE45050  subf r31, r4, r10
	ctx.r[31].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 832BAE4C: 7F1F2840  cmplw cr6, r31, r5
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[5].u32, &mut ctx.xer);
	// 832BAE50: 409800E0  bge cr6, 0x832baf30
	if !ctx.cr[6].lt {
	pc = 0x832BAF30; continue 'dispatch;
	}
	// 832BAE54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BAE58: 419A0068  beq cr6, 0x832baec0
	if ctx.cr[6].eq {
	pc = 0x832BAEC0; continue 'dispatch;
	}
	// 832BAE5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BAE60: 419A0040  beq cr6, 0x832baea0
	if ctx.cr[6].eq {
	pc = 0x832BAEA0; continue 'dispatch;
	}
	// 832BAE64: 57EBF87E  srwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BAE68: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BAE6C: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 832BAE70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BAE74: 419A0024  beq cr6, 0x832bae98
	if ctx.cr[6].eq {
	pc = 0x832BAE98; continue 'dispatch;
	}
	// 832BAE78: 89090000  lbz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BAE7C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BAE80: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 832BAE84: 39080080  addi r8, r8, 0x80
	ctx.r[8].s64 = ctx.r[8].s64 + 128;
	// 832BAE88: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 832BAE8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832BAE90: 4082FFE8  bne 0x832bae78
	if !ctx.cr[0].eq {
	pc = 0x832BAE78; continue 'dispatch;
	}
	// 832BAE94: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BAE98: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 832BAE9C: 48000028  b 0x832baec4
	pc = 0x832BAEC4; continue 'dispatch;
	// 832BAEA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 832BAEA4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BAEA8: 4B9EE5D9  bl 0x82ca9480
	ctx.lr = 0x832BAEAC;
	sub_82CA9480(ctx, base);
	// 832BAEAC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BAEB0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BAEB4: 7D5F5A14  add r10, r31, r11
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 832BAEB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 832BAEBC: 48000008  b 0x832baec4
	pc = 0x832BAEC4; continue 'dispatch;
	// 832BAEC0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BAEC4: 817E0058  lwz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 832BAEC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BAECC: 419A003C  beq cr6, 0x832baf08
	if ctx.cr[6].eq {
	pc = 0x832BAF08; continue 'dispatch;
	}
	// 832BAED0: 7D7F2850  subf r11, r31, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[31].s64;
	// 832BAED4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 832BAED8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BAEDC: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BAEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BAEE4: 419A0038  beq cr6, 0x832baf1c
	if ctx.cr[6].eq {
	pc = 0x832BAF1C; continue 'dispatch;
	}
	// 832BAEE8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BAEEC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BAEF0: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 832BAEF4: 39080080  addi r8, r8, 0x80
	ctx.r[8].s64 = ctx.r[8].s64 + 128;
	// 832BAEF8: 99090000  stb r8, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 832BAEFC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 832BAF00: 4082FFE8  bne 0x832baee8
	if !ctx.cr[0].eq {
	pc = 0x832BAEE8; continue 'dispatch;
	}
	// 832BAF04: 48000014  b 0x832baf18
	pc = 0x832BAF18; continue 'dispatch;
	// 832BAF08: 7CBF2850  subf r5, r31, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[31].s64;
	// 832BAF0C: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BAF10: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 832BAF14: 4B9EE56D  bl 0x82ca9480
	ctx.lr = 0x832BAF18;
	sub_82CA9480(ctx, base);
	// 832BAF18: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BAF1C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BAF20: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 832BAF24: 7D4B2A14  add r10, r11, r5
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 832BAF28: 915E0018  stw r10, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 832BAF2C: 48000058  b 0x832baf84
	pc = 0x832BAF84; continue 'dispatch;
	// 832BAF30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BAF34: 419A0038  beq cr6, 0x832baf6c
	if ctx.cr[6].eq {
	pc = 0x832BAF6C; continue 'dispatch;
	}
	// 832BAF38: 54ABF87E  srwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BAF3C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BAF40: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 832BAF44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BAF48: 419A0030  beq cr6, 0x832baf78
	if ctx.cr[6].eq {
	pc = 0x832BAF78; continue 'dispatch;
	}
	// 832BAF4C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BAF50: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BAF54: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 832BAF58: 39080080  addi r8, r8, 0x80
	ctx.r[8].s64 = ctx.r[8].s64 + 128;
	// 832BAF5C: 99090000  stb r8, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 832BAF60: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 832BAF64: 4082FFE8  bne 0x832baf4c
	if !ctx.cr[0].eq {
	pc = 0x832BAF4C; continue 'dispatch;
	}
	// 832BAF68: 4800000C  b 0x832baf74
	pc = 0x832BAF74; continue 'dispatch;
	// 832BAF6C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BAF70: 4B9EE511  bl 0x82ca9480
	ctx.lr = 0x832BAF74;
	sub_82CA9480(ctx, base);
	// 832BAF74: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BAF78: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BAF7C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 832BAF80: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 832BAF84: 817E0058  lwz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 832BAF88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BAF8C: 419A000C  beq cr6, 0x832baf98
	if ctx.cr[6].eq {
	pc = 0x832BAF98; continue 'dispatch;
	}
	// 832BAF90: 54A5F87E  srwi r5, r5, 1
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shr(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BAF94: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 832BAF98: 817E0164  lwz r11, 0x164(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 832BAF9C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 832BAFA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BAFA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BAFA8: 4E800421  bctrl
	ctx.lr = 0x832BAFAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BAFAC: 815E015C  lwz r10, 0x15c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 832BAFB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BAFB4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832BAFB8: 4E800421  bctrl
	ctx.lr = 0x832BAFBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BAFBC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BAFC0: 409AFDD4  bne cr6, 0x832bad94
	if !ctx.cr[6].eq {
	pc = 0x832BAD94; continue 'dispatch;
	}
	// 832BAFC4: 817D0114  lwz r11, 0x114(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BAFC8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 832BAFCC: 3B9C0184  addi r28, r28, 0x184
	ctx.r[28].s64 = ctx.r[28].s64 + 388;
	// 832BAFD0: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BAFD4: 4198FDA0  blt cr6, 0x832bad74
	if ctx.cr[6].lt {
	pc = 0x832BAD74; continue 'dispatch;
	}
	// 832BAFD8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 832BAFDC: 419A0014  beq cr6, 0x832baff0
	if ctx.cr[6].eq {
	pc = 0x832BAFF0; continue 'dispatch;
	}
	// 832BAFE0: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BAFE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BAFE8: 419A0008  beq cr6, 0x832baff0
	if ctx.cr[6].eq {
	pc = 0x832BAFF0; continue 'dispatch;
	}
	// 832BAFEC: 4BD509D5  bl 0x8300b9c0
	ctx.lr = 0x832BAFF0;
	sub_8300B9C0(ctx, base);
	// 832BAFF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832BAFF4: 4B9EE45C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BAFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BAFF8 size=308
    let mut pc: u32 = 0x832BAFF8;
    'dispatch: loop {
        match pc {
            0x832BAFF8 => {
    //   block [0x832BAFF8..0x832BB12C)
	// 832BAFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BAFFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BB000: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BB004: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BB008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BB00C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 832BB010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BB014: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BB018: 419A0008  beq cr6, 0x832bb020
	if ctx.cr[6].eq {
	pc = 0x832BB020; continue 'dispatch;
	}
	// 832BB01C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 832BB020: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BB024: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BB028: 915F0334  stw r10, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[10].u32 ) };
	// 832BB02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB030: 419A000C  beq cr6, 0x832bb03c
	if ctx.cr[6].eq {
	pc = 0x832BB03C; continue 'dispatch;
	}
	// 832BB034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BB038: 4BFFFCC9  bl 0x832bad00
	ctx.lr = 0x832BB03C;
	sub_832BAD00(ctx, base);
	// 832BB03C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BB040: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BB044: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 832BB048: 409A003C  bne cr6, 0x832bb084
	if !ctx.cr[6].eq {
	pc = 0x832BB084; continue 'dispatch;
	}
	// 832BB04C: 48005A6D  bl 0x832c0ab8
	ctx.lr = 0x832BB050;
	sub_832C0AB8(ctx, base);
	// 832BB050: 817F0328  lwz r11, 0x328(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(808 as u32) ) } as u64;
	// 832BB054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB058: 409A0008  bne cr6, 0x832bb060
	if !ctx.cr[6].eq {
	pc = 0x832BB060; continue 'dispatch;
	}
	// 832BB05C: 907F0328  stw r3, 0x328(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(808 as u32), ctx.r[3].u32 ) };
	// 832BB060: 817F0328  lwz r11, 0x328(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(808 as u32) ) } as u64;
	// 832BB064: 3D400004  lis r10, 4
	ctx.r[10].s64 = 262144;
	// 832BB068: 614993E0  ori r9, r10, 0x93e0
	ctx.r[9].u64 = ctx.r[10].u64 | 37856;
	// 832BB06C: 7D0B1850  subf r8, r11, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BB070: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BB074: 40990010  ble cr6, 0x832bb084
	if !ctx.cr[6].gt {
	pc = 0x832BB084; continue 'dispatch;
	}
	// 832BB078: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 832BB07C: 907F0328  stw r3, 0x328(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(808 as u32), ctx.r[3].u32 ) };
	// 832BB080: 917F032C  stw r11, 0x32c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(812 as u32), ctx.r[11].u32 ) };
	// 832BB084: 815F014C  lwz r10, 0x14c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 832BB088: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BB08C: 813F0148  lwz r9, 0x148(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 832BB090: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BB094: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BB098: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BB09C: 5507003C  rlwinm r7, r8, 0, 0, 0x1e
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB0A0: 90FF0108  stw r7, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[7].u32 ) };
	// 832BB0A4: 54E5003E  slwi r5, r7, 0
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BB0A8: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BB0AC: 54C407FE  clrlwi r4, r6, 0x1f
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 832BB0B0: 909F010C  stw r4, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[4].u32 ) };
	// 832BB0B4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BB0B8: 546B003C  rlwinm r11, r3, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB0BC: 7CE55850  subf r7, r5, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 832BB0C0: 90FF0104  stw r7, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[7].u32 ) };
	// 832BB0C4: 419A001C  beq cr6, 0x832bb0e0
	if ctx.cr[6].eq {
	pc = 0x832BB0E0; continue 'dispatch;
	}
	// 832BB0C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BB0CC: 556A003C  rlwinm r10, r11, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB0D0: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 832BB0D4: 7D2B2A14  add r9, r11, r5
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 832BB0D8: 913F0100  stw r9, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[9].u32 ) };
	// 832BB0DC: 4800001C  b 0x832bb0f8
	pc = 0x832BB0F8; continue 'dispatch;
	// 832BB0E0: 80DF0100  lwz r6, 0x100(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 832BB0E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832BB0E8: 817F0154  lwz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 832BB0EC: 387F0150  addi r3, r31, 0x150
	ctx.r[3].s64 = ctx.r[31].s64 + 336;
	// 832BB0F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BB0F4: 4E800421  bctrl
	ctx.lr = 0x832BB0F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BB0F8: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BB0FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB100: 419A000C  beq cr6, 0x832bb10c
	if ctx.cr[6].eq {
	pc = 0x832BB10C; continue 'dispatch;
	}
	// 832BB104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BB108: 4BFFFBF9  bl 0x832bad00
	ctx.lr = 0x832BB10C;
	sub_832BAD00(ctx, base);
	// 832BB10C: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 832BB110: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 832BB114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BB118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BB11C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BB120: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BB124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BB128: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB130 size=252
    let mut pc: u32 = 0x832BB130;
    'dispatch: loop {
        match pc {
            0x832BB130 => {
    //   block [0x832BB130..0x832BB22C)
	// 832BB130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BB134: 4B9EE2CD  bl 0x82ca9400
	ctx.lr = 0x832BB138;
	sub_82CA93D0(ctx, base);
	// 832BB138: 7FE51851  subf. r31, r5, r3
	ctx.r[31].s64 = ctx.r[3].s64 - ctx.r[5].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 832BB13C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832BB140: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832BB144: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 832BB148: 40800008  bge 0x832bb150
	if !ctx.cr[0].lt {
	pc = 0x832BB150; continue 'dispatch;
	}
	// 832BB14C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 832BB150: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832BB154: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 832BB158: 4099005C  ble cr6, 0x832bb1b4
	if !ctx.cr[6].gt {
	pc = 0x832BB1B4; continue 'dispatch;
	}
	// 832BB15C: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BB160: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 832BB164: 7D0A2214  add r8, r10, r4
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 832BB168: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BB16C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BB170: 834B0004  lwz r26, 4(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BB174: 7F7EF038  and r30, r27, r30
	ctx.r[30].u64 = ctx.r[27].u64 & ctx.r[30].u64;
	// 832BB178: 7D5B5050  subf r10, r27, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[27].s64;
	// 832BB17C: 57DE07FE  clrlwi r30, r30, 0x1f
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 832BB180: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832BB184: 409900A0  ble cr6, 0x832bb224
	if !ctx.cr[6].gt {
	pc = 0x832BB224; continue 'dispatch;
	}
	// 832BB188: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832BB18C: 4099000C  ble cr6, 0x832bb198
	if !ctx.cr[6].gt {
	pc = 0x832BB198; continue 'dispatch;
	}
	// 832BB190: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 832BB194: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 832BB198: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 832BB19C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 832BB1A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BB1A4: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 832BB1A8: 4198FFC0  blt cr6, 0x832bb168
	if ctx.cr[6].lt {
	pc = 0x832BB168; continue 'dispatch;
	}
	// 832BB1AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 832BB1B0: 409A0028  bne cr6, 0x832bb1d8
	if !ctx.cr[6].eq {
	pc = 0x832BB1D8; continue 'dispatch;
	}
	// 832BB1B4: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BB1B8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BB1BC: 78A90020  clrldi r9, r5, 0x20
	ctx.r[9].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 832BB1C0: 78680020  clrldi r8, r3, 0x20
	ctx.r[8].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 832BB1C4: 7CAB202E  lwzx r5, r11, r4
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 832BB1C8: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 832BB1CC: 7D4B49D2  mulld r10, r11, r9
	ctx.r[10].s64 = ctx.r[11].s64 * ctx.r[9].s64;
	// 832BB1D0: 7D2A4392  divdu r9, r10, r8
	ctx.r[9].u64 = ctx.r[10].u64 / ctx.r[8].u64;
	// 832BB1D4: 553D003E  slwi r29, r9, 0
	ctx.r[29].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 832BB1D8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 832BB1DC: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 832BB1E0: 40980034  bge cr6, 0x832bb214
	if !ctx.cr[6].lt {
	pc = 0x832BB214; continue 'dispatch;
	}
	// 832BB1E4: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BB1E8: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 832BB1EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BB1F0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BB1F4: 7D25F038  and r5, r9, r30
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[30].u64;
	// 832BB1F8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BB1FC: 54BE07FE  clrlwi r30, r5, 0x1f
	ctx.r[30].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 832BB200: 40990024  ble cr6, 0x832bb224
	if !ctx.cr[6].gt {
	pc = 0x832BB224; continue 'dispatch;
	}
	// 832BB204: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832BB208: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BB20C: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 832BB210: 4198FFDC  blt cr6, 0x832bb1ec
	if ctx.cr[6].lt {
	pc = 0x832BB1EC; continue 'dispatch;
	}
	// 832BB214: 93C70000  stw r30, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 832BB218: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 832BB21C: 93860000  stw r28, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 832BB220: 4B9EE230  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 832BB224: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 832BB228: 4B9EE228  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB230 size=52
    let mut pc: u32 = 0x832BB230;
    'dispatch: loop {
        match pc {
            0x832BB230 => {
    //   block [0x832BB230..0x832BB264)
	// 832BB230: 8163FF1C  lwz r11, -0xe4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-228 as u32) ) } as u64;
	// 832BB234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB238: 409A0044  bne cr6, 0x832bb27c
	if !ctx.cr[6].eq {
		sub_832BB27C(ctx, base);
		return;
	}
	// 832BB23C: 8143FF48  lwz r10, -0xb8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-184 as u32) ) } as u64;
	// 832BB240: 8163FF44  lwz r11, -0xbc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-188 as u32) ) } as u64;
	// 832BB244: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832BB248: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 832BB24C: 1D0A0064  mulli r8, r10, 0x64
	ctx.r[8].s64 = ctx.r[10].s64 * 100;
	// 832BB250: 7D684B96  divwu r11, r8, r9
	ctx.r[11].u32 = ctx.r[8].u32 / ctx.r[9].u32;
	// 832BB254: 2B0B0032  cmplwi cr6, r11, 0x32
	ctx.cr[6].compare_u32(ctx.r[11].u32, 50 as u32, &mut ctx.xer);
	// 832BB258: 4098000C  bge cr6, 0x832bb264
	if !ctx.cr[6].lt {
		sub_832BB264(ctx, base);
		return;
	}
	// 832BB25C: 206BFFFF  subfic r3, r11, -1
	ctx.xer.ca = ctx.r[11].u32 <= -1 as u32;
	ctx.r[3].s64 = (-1 as i64) - ctx.r[11].s64;
	// 832BB260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB264(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB264 size=24
    let mut pc: u32 = 0x832BB264;
    'dispatch: loop {
        match pc {
            0x832BB264 => {
    //   block [0x832BB264..0x832BB27C)
	// 832BB264: 816300F8  lwz r11, 0xf8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) } as u64;
	// 832BB268: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 832BB26C: 419A0010  beq cr6, 0x832bb27c
	if ctx.cr[6].eq {
		sub_832BB27C(ctx, base);
		return;
	}
	// 832BB270: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 832BB274: 7C6B5050  subf r3, r11, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832BB278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB27C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB27C size=8
    let mut pc: u32 = 0x832BB27C;
    'dispatch: loop {
        match pc {
            0x832BB27C => {
    //   block [0x832BB27C..0x832BB284)
	// 832BB27C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BB280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BB288 size=76
    let mut pc: u32 = 0x832BB288;
    'dispatch: loop {
        match pc {
            0x832BB288 => {
    //   block [0x832BB288..0x832BB2D4)
	// 832BB288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BB28C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BB290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BB294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BB298: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BB29C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BB2A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 832BB2A4: 397FFDAC  addi r11, r31, -0x254
	ctx.r[11].s64 = ctx.r[31].s64 + -596;
	// 832BB2A8: 386B0150  addi r3, r11, 0x150
	ctx.r[3].s64 = ctx.r[11].s64 + 336;
	// 832BB2AC: 815FFF0C  lwz r10, -0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-244 as u32) ) } as u64;
	// 832BB2B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832BB2B4: 4E800421  bctrl
	ctx.lr = 0x832BB2B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BB2B8: 93DF00F8  stw r30, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u32 ) };
	// 832BB2BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BB2C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BB2C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BB2C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BB2CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BB2D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB2D8 size=8
    let mut pc: u32 = 0x832BB2D8;
    'dispatch: loop {
        match pc {
            0x832BB2D8 => {
    //   block [0x832BB2D8..0x832BB2E0)
	// 832BB2D8: 35630104  addic. r11, r3, 0x104
	ctx.xer.ca = (ctx.r[3].u32 > (!(260 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 260;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BB2DC: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB2E0 size=12
    let mut pc: u32 = 0x832BB2E0;
    'dispatch: loop {
        match pc {
            0x832BB2E0 => {
    //   block [0x832BB2E0..0x832BB2EC)
	// 832BB2E0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BB2E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BB2E8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB2EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB2EC size=8
    let mut pc: u32 = 0x832BB2EC;
    'dispatch: loop {
        match pc {
            0x832BB2EC => {
    //   block [0x832BB2EC..0x832BB2F4)
	// 832BB2EC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BB2F0: 4AEDB6D8  b 0x821969c8
	sub_821969C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB2F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB2F4 size=4
    let mut pc: u32 = 0x832BB2F4;
    'dispatch: loop {
        match pc {
            0x832BB2F4 => {
    //   block [0x832BB2F4..0x832BB2F8)
	// 832BB2F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BB2F8 size=84
    let mut pc: u32 = 0x832BB2F8;
    'dispatch: loop {
        match pc {
            0x832BB2F8 => {
    //   block [0x832BB2F8..0x832BB34C)
	// 832BB2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BB2FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BB300: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BB304: 35630104  addic. r11, r3, 0x104
	ctx.xer.ca = (ctx.r[3].u32 > (!(260 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 260;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BB308: 41820030  beq 0x832bb338
	if ctx.cr[0].eq {
	pc = 0x832BB338; continue 'dispatch;
	}
	// 832BB30C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BB310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BB314: 419A0024  beq cr6, 0x832bb338
	if ctx.cr[6].eq {
	pc = 0x832BB338; continue 'dispatch;
	}
	// 832BB318: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BB31C: 4AEDB6AD  bl 0x821969c8
	ctx.lr = 0x832BB320;
	sub_821969C8(ctx, base);
	// 832BB320: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 832BB324: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 832BB328: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832BB32C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BB330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BB334: 4E800020  blr
	return;
	// 832BB338: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BB33C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832BB340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BB344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BB348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB350 size=8
    let mut pc: u32 = 0x832BB350;
    'dispatch: loop {
        match pc {
            0x832BB350 => {
    //   block [0x832BB350..0x832BB358)
	// 832BB350: 35630104  addic. r11, r3, 0x104
	ctx.xer.ca = (ctx.r[3].u32 > (!(260 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 260;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BB354: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB358 size=12
    let mut pc: u32 = 0x832BB358;
    'dispatch: loop {
        match pc {
            0x832BB358 => {
    //   block [0x832BB358..0x832BB364)
	// 832BB358: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BB35C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BB360: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB364(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB364 size=8
    let mut pc: u32 = 0x832BB364;
    'dispatch: loop {
        match pc {
            0x832BB364 => {
    //   block [0x832BB364..0x832BB36C)
	// 832BB364: 4BD5065C  b 0x8300b9c0
	sub_8300B9C0(ctx, base);
	return;
	// 832BB368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB370 size=8
    let mut pc: u32 = 0x832BB370;
    'dispatch: loop {
        match pc {
            0x832BB370 => {
    //   block [0x832BB370..0x832BB378)
	// 832BB370: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BB374: 4BA07B0C  b 0x82cc2e80
	sub_82CC2E80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB378 size=16
    let mut pc: u32 = 0x832BB378;
    'dispatch: loop {
        match pc {
            0x832BB378 => {
    //   block [0x832BB378..0x832BB388)
	// 832BB378: 8163FFFC  lwz r11, -4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-4 as u32) ) } as u64;
	// 832BB37C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 832BB380: 206BFFFF  subfic r3, r11, -1
	ctx.xer.ca = ctx.r[11].u32 <= -1 as u32;
	ctx.r[3].s64 = (-1 as i64) - ctx.r[11].s64;
	// 832BB384: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB388 size=8
    let mut pc: u32 = 0x832BB388;
    'dispatch: loop {
        match pc {
            0x832BB388 => {
    //   block [0x832BB388..0x832BB390)
	// 832BB388: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BB38C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BB390 size=76
    let mut pc: u32 = 0x832BB390;
    'dispatch: loop {
        match pc {
            0x832BB390 => {
    //   block [0x832BB390..0x832BB3DC)
	// 832BB390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BB394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BB398: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BB39C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BB3A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BB3A4: 8163FDC0  lwz r11, -0x240(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-576 as u32) ) } as u64;
	// 832BB3A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 832BB3AC: 3BE3FCAC  addi r31, r3, -0x354
	ctx.r[31].s64 = ctx.r[3].s64 + -852;
	// 832BB3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB3B4: 419A000C  beq cr6, 0x832bb3c0
	if ctx.cr[6].eq {
	pc = 0x832BB3C0; continue 'dispatch;
	}
	// 832BB3B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BB3BC: 4BFFF945  bl 0x832bad00
	ctx.lr = 0x832BB3C0;
	sub_832BAD00(ctx, base);
	// 832BB3C0: 93DF0350  stw r30, 0x350(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(848 as u32), ctx.r[30].u32 ) };
	// 832BB3C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BB3C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BB3CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BB3D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BB3D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BB3D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB3E0 size=12
    let mut pc: u32 = 0x832BB3E0;
    'dispatch: loop {
        match pc {
            0x832BB3E0 => {
    //   block [0x832BB3E0..0x832BB3EC)
	// 832BB3E0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 832BB3E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BB3E8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB3EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB3EC size=8
    let mut pc: u32 = 0x832BB3EC;
    'dispatch: loop {
        match pc {
            0x832BB3EC => {
    //   block [0x832BB3EC..0x832BB3F4)
	// 832BB3EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB3F0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB3F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB3F4 size=172
    let mut pc: u32 = 0x832BB3F4;
    'dispatch: loop {
        match pc {
            0x832BB3F4 => {
    //   block [0x832BB3F4..0x832BB4A0)
	// 832BB3F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BB3F8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 832BB3FC: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 832BB400: 388B0018  addi r4, r11, 0x18
	ctx.r[4].s64 = ctx.r[11].s64 + 24;
	// 832BB404: 8103029C  lwz r8, 0x29c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(668 as u32) ) } as u64;
	// 832BB408: 39080007  addi r8, r8, 7
	ctx.r[8].s64 = ctx.r[8].s64 + 7;
	// 832BB40C: 55070038  rlwinm r7, r8, 0, 0, 0x1c
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB410: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 832BB414: 810302A0  lwz r8, 0x2a0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(672 as u32) ) } as u64;
	// 832BB418: 38C80007  addi r6, r8, 7
	ctx.r[6].s64 = ctx.r[8].s64 + 7;
	// 832BB41C: 54C50038  rlwinm r5, r6, 0, 0, 0x1c
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB420: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 832BB424: 8103029C  lwz r8, 0x29c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(668 as u32) ) } as u64;
	// 832BB428: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 832BB42C: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BB430: 38E80007  addi r7, r8, 7
	ctx.r[7].s64 = ctx.r[8].s64 + 7;
	// 832BB434: 54E60038  rlwinm r6, r7, 0, 0, 0x1c
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB438: 90CB000C  stw r6, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 832BB43C: 810302A0  lwz r8, 0x2a0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(672 as u32) ) } as u64;
	// 832BB440: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 832BB444: 54A8F87E  srwi r8, r5, 1
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BB448: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 832BB44C: 912B0024  stw r9, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 832BB450: 39080007  addi r8, r8, 7
	ctx.r[8].s64 = ctx.r[8].s64 + 7;
	// 832BB454: 912B0030  stw r9, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 832BB458: 55070038  rlwinm r7, r8, 0, 0, 0x1c
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB45C: 90EB0010  stw r7, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 832BB460: 80C30020  lwz r6, 0x20(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BB464: 54C567FE  rlwinm r5, r6, 0xc, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x000FFFFFu64;
	// 832BB468: 90AB003C  stw r5, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[5].u32 ) };
	// 832BB46C: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 832BB470: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 832BB474: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 832BB478: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 832BB47C: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 832BB480: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 832BB484: 914B0038  stw r10, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 832BB488: 914B0044  stw r10, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 832BB48C: 80630394  lwz r3, 0x394(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(916 as u32) ) } as u64;
	// 832BB490: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BB494: 419A000C  beq cr6, 0x832bb4a0
	if ctx.cr[6].eq {
		sub_832BB4A0(ctx, base);
		return;
	}
	// 832BB498: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 832BB49C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BB4A0 size=20
    let mut pc: u32 = 0x832BB4A0;
    'dispatch: loop {
        match pc {
            0x832BB4A0 => {
    //   block [0x832BB4A0..0x832BB4B4)
	// 832BB4A0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 832BB4A4: 386B0048  addi r3, r11, 0x48
	ctx.r[3].s64 = ctx.r[11].s64 + 72;
	// 832BB4A8: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 832BB4AC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832BB4B0: 4B9EDFD0  b 0x82ca9480
	sub_82CA9480(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BB4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BB4B8 size=4320
    let mut pc: u32 = 0x832BB4B8;
    'dispatch: loop {
        match pc {
            0x832BB4B8 => {
    //   block [0x832BB4B8..0x832BC598)
	// 832BB4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BB4BC: 4B9EDF19  bl 0x82ca93d4
	ctx.lr = 0x832BB4C0;
	sub_82CA93D0(ctx, base);
	// 832BB4C0: 9421FAA0  stwu r1, -0x560(r1)
	ea = ctx.r[1].u32.wrapping_add(-1376 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BB4C4: 7C8F2378  mr r15, r4
	ctx.r[15].u64 = ctx.r[4].u64;
	// 832BB4C8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 832BB4CC: 55E90462  rlwinm r9, r15, 0, 0x11, 0x11
	ctx.r[9].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB4D0: 3D408350  lis r10, -0x7cb0
	ctx.r[10].s64 = -2091909120;
	// 832BB4D4: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 832BB4D8: 3A000001  li r16, 1
	ctx.r[16].s64 = 1;
	// 832BB4DC: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 832BB4E0: 3BEB09C0  addi r31, r11, 0x9c0
	ctx.r[31].s64 = ctx.r[11].s64 + 2496;
	// 832BB4E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BB4E8: 3A4AC49C  addi r18, r10, -0x3b64
	ctx.r[18].s64 = ctx.r[10].s64 + -15204;
	// 832BB4EC: 409A0014  bne cr6, 0x832bb500
	if !ctx.cr[6].eq {
	pc = 0x832BB500; continue 'dispatch;
	}
	// 832BB4F0: 7E0B8378  mr r11, r16
	ctx.r[11].u64 = ctx.r[16].u64;
	// 832BB4F4: 7E2A8B78  mr r10, r17
	ctx.r[10].u64 = ctx.r[17].u64;
	// 832BB4F8: 9172001C  stw r11, 0x1c(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 832BB4FC: 91520024  stw r10, 0x24(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 832BB500: 38A0039C  li r5, 0x39c
	ctx.r[5].s64 = 924;
	// 832BB504: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BB508: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 832BB50C: 4B9EE4A5  bl 0x82ca99b0
	ctx.lr = 0x832BB510;
	sub_82CA99B0(ctx, base);
	// 832BB510: 480055A9  bl 0x832c0ab8
	ctx.lr = 0x832BB514;
	sub_832C0AB8(ctx, base);
	// 832BB514: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832BB518: 55F5014A  rlwinm r21, r15, 0, 5, 5
	ctx.r[21].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB51C: 9061041C  stw r3, 0x41c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1052 as u32), ctx.r[3].u32 ) };
	// 832BB520: 3AEB66AC  addi r23, r11, 0x66ac
	ctx.r[23].s64 = ctx.r[11].s64 + 26284;
	// 832BB524: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 832BB528: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 832BB52C: 99770004  stb r11, 4(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 832BB530: 419A0018  beq cr6, 0x832bb548
	if ctx.cr[6].eq {
	pc = 0x832BB548; continue 'dispatch;
	}
	// 832BB534: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 832BB538: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 832BB53C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 832BB540: 4B9EDF41  bl 0x82ca9480
	ctx.lr = 0x832BB544;
	sub_82CA9480(ctx, base);
	// 832BB544: 48000084  b 0x832bb5c8
	pc = 0x832BB5C8; continue 'dispatch;
	// 832BB548: 55EB018C  rlwinm r11, r15, 0, 6, 6
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB54C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB550: 419A0014  beq cr6, 0x832bb564
	if ctx.cr[6].eq {
	pc = 0x832BB564; continue 'dispatch;
	}
	// 832BB554: 81720020  lwz r11, 0x20(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BB558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB55C: 419A0008  beq cr6, 0x832bb564
	if ctx.cr[6].eq {
	pc = 0x832BB564; continue 'dispatch;
	}
	// 832BB560: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 832BB564: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 832BB568: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 832BB56C: 91720020  stw r11, 0x20(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 832BB570: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 832BB574: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 832BB578: 7FE903A6  mtctr r31
	ctx.ctr.u64 = ctx.r[31].u64;
	// 832BB57C: 4E800421  bctrl
	ctx.lr = 0x832BB580;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BB580: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BB584: 409A0028  bne cr6, 0x832bb5ac
	if !ctx.cr[6].eq {
	pc = 0x832BB5AC; continue 'dispatch;
	}
	// 832BB588: 89770004  lbz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BB58C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB590: 409A0FFC  bne cr6, 0x832bc58c
	if !ctx.cr[6].eq {
	pc = 0x832BC58C; continue 'dispatch;
	}
	// 832BB594: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832BB598: 386BFE00  addi r3, r11, -0x200
	ctx.r[3].s64 = ctx.r[11].s64 + -512;
	// 832BB59C: 4BFFF715  bl 0x832bacb0
	ctx.lr = 0x832BB5A0;
	sub_832BACB0(ctx, base);
	// 832BB5A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BB5A4: 38210560  addi r1, r1, 0x560
	ctx.r[1].s64 = ctx.r[1].s64 + 1376;
	// 832BB5A8: 4B9EDE7C  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
	// 832BB5AC: 81610280  lwz r11, 0x280(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(640 as u32) ) } as u64;
	// 832BB5B0: 38C0002C  li r6, 0x2c
	ctx.r[6].s64 = 44;
	// 832BB5B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832BB5B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BB5BC: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 832BB5C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BB5C4: 4E800421  bctrl
	ctx.lr = 0x832BB5C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BB5C8: 3D60664B  lis r11, 0x664b
	ctx.r[11].s64 = 1716191232;
	// 832BB5CC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BB5D0: 3D40674B  lis r10, 0x674b
	ctx.r[10].s64 = 1732968448;
	// 832BB5D4: 617E4942  ori r30, r11, 0x4942
	ctx.r[30].u64 = ctx.r[11].u64 | 18754;
	// 832BB5D8: 3D20684B  lis r9, 0x684b
	ctx.r[9].s64 = 1749745664;
	// 832BB5DC: 615D4942  ori r29, r10, 0x4942
	ctx.r[29].u64 = ctx.r[10].u64 | 18754;
	// 832BB5E0: 61394942  ori r25, r9, 0x4942
	ctx.r[25].u64 = ctx.r[9].u64 | 18754;
	// 832BB5E4: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BB5E8: 419A0024  beq cr6, 0x832bb60c
	if ctx.cr[6].eq {
	pc = 0x832BB60C; continue 'dispatch;
	}
	// 832BB5EC: 7F04E840  cmplw cr6, r4, r29
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832BB5F0: 419A001C  beq cr6, 0x832bb60c
	if ctx.cr[6].eq {
	pc = 0x832BB60C; continue 'dispatch;
	}
	// 832BB5F4: 7F04C840  cmplw cr6, r4, r25
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[25].u32, &mut ctx.xer);
	// 832BB5F8: 419A0014  beq cr6, 0x832bb60c
	if ctx.cr[6].eq {
	pc = 0x832BB60C; continue 'dispatch;
	}
	// 832BB5FC: 3D60694B  lis r11, 0x694b
	ctx.r[11].s64 = 1766522880;
	// 832BB600: 616A4942  ori r10, r11, 0x4942
	ctx.r[10].u64 = ctx.r[11].u64 | 18754;
	// 832BB604: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BB608: 409A0010  bne cr6, 0x832bb618
	if !ctx.cr[6].eq {
	pc = 0x832BB618; continue 'dispatch;
	}
	// 832BB60C: 816102A0  lwz r11, 0x2a0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(672 as u32) ) } as u64;
	// 832BB610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB614: 419A0010  beq cr6, 0x832bb624
	if ctx.cr[6].eq {
	pc = 0x832BB624; continue 'dispatch;
	}
	// 832BB618: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832BB61C: 386BFE14  addi r3, r11, -0x1ec
	ctx.r[3].s64 = ctx.r[11].s64 + -492;
	// 832BB620: 48000F4C  b 0x832bc56c
	pc = 0x832BC56C; continue 'dispatch;
	// 832BB624: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 832BB628: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 832BB62C: 409A0010  bne cr6, 0x832bb63c
	if !ctx.cr[6].eq {
	pc = 0x832BB63C; continue 'dispatch;
	}
	// 832BB630: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832BB634: 386BFE28  addi r3, r11, -0x1d8
	ctx.r[3].s64 = ctx.r[11].s64 + -472;
	// 832BB638: 48000F34  b 0x832bc56c
	pc = 0x832BC56C; continue 'dispatch;
	// 832BB63C: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 832BB640: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 832BB644: 41980F20  blt cr6, 0x832bc564
	if ctx.cr[6].lt {
	pc = 0x832BC564; continue 'dispatch;
	}
	// 832BB648: 3D60000F  lis r11, 0xf
	ctx.r[11].s64 = 983040;
	// 832BB64C: 616A4240  ori r10, r11, 0x4240
	ctx.r[10].u64 = ctx.r[11].u64 | 16960;
	// 832BB650: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BB654: 41990F10  bgt cr6, 0x832bc564
	if ctx.cr[6].gt {
	pc = 0x832BC564; continue 'dispatch;
	}
	// 832BB658: 8301005C  lwz r24, 0x5c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BB65C: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BB660: 7F18D040  cmplw cr6, r24, r26
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[26].u32, &mut ctx.xer);
	// 832BB664: 41990F00  bgt cr6, 0x832bc564
	if ctx.cr[6].gt {
	pc = 0x832BC564; continue 'dispatch;
	}
	// 832BB668: 83610078  lwz r27, 0x78(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 832BB66C: 2B1B0100  cmplwi cr6, r27, 0x100
	ctx.cr[6].compare_u32(ctx.r[27].u32, 256 as u32, &mut ctx.xer);
	// 832BB670: 41990EF4  bgt cr6, 0x832bc564
	if ctx.cr[6].gt {
	pc = 0x832BC564; continue 'dispatch;
	}
	// 832BB674: 397B0001  addi r11, r27, 1
	ctx.r[11].s64 = ctx.r[27].s64 + 1;
	// 832BB678: 7D4BF9D6  mullw r10, r11, r31
	ctx.r[10].s64 = (ctx.r[11].s32 as i64) * (ctx.r[31].s32 as i64);
	// 832BB67C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BB680: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BB684: 41980EE0  blt cr6, 0x832bc564
	if ctx.cr[6].lt {
	pc = 0x832BC564; continue 'dispatch;
	}
	// 832BB688: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 832BB68C: 2B097FFF  cmplwi cr6, r9, 0x7fff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32767 as u32, &mut ctx.xer);
	// 832BB690: 41990ED4  bgt cr6, 0x832bc564
	if ctx.cr[6].gt {
	pc = 0x832BC564; continue 'dispatch;
	}
	// 832BB694: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 832BB698: 2B087FFF  cmplwi cr6, r8, 0x7fff
	ctx.cr[6].compare_u32(ctx.r[8].u32, 32767 as u32, &mut ctx.xer);
	// 832BB69C: 41990EC8  bgt cr6, 0x832bc564
	if ctx.cr[6].gt {
	pc = 0x832BC564; continue 'dispatch;
	}
	// 832BB6A0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 832BB6A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BB6A8: 419A0EBC  beq cr6, 0x832bc564
	if ctx.cr[6].eq {
	pc = 0x832BC564; continue 'dispatch;
	}
	// 832BB6AC: 80C10070  lwz r6, 0x70(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 832BB6B0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 832BB6B4: 419A0EB0  beq cr6, 0x832bc564
	if ctx.cr[6].eq {
	pc = 0x832BC564; continue 'dispatch;
	}
	// 832BB6B8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 832BB6BC: 3949000F  addi r10, r9, 0xf
	ctx.r[10].s64 = ctx.r[9].s64 + 15;
	// 832BB6C0: 910103D0  stw r8, 0x3d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(976 as u32), ctx.r[8].u32 ) };
	// 832BB6C4: 554AE13E  srwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BB6C8: 91210130  stw r9, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[9].u32 ) };
	// 832BB6CC: 5567039C  rlwinm r7, r11, 0, 0xe, 0xe
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB6D0: 912103CC  stw r9, 0x3cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(972 as u32), ctx.r[9].u32 ) };
	// 832BB6D4: 38AA000F  addi r5, r10, 0xf
	ctx.r[5].s64 = ctx.r[10].s64 + 15;
	// 832BB6D8: 91010134  stw r8, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[8].u32 ) };
	// 832BB6DC: 7CE77B78  or r7, r7, r15
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[15].u64;
	// 832BB6E0: 91610154  stw r11, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 832BB6E4: 556A02D6  rlwinm r10, r11, 0, 0xb, 0xb
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB6E8: 54A50036  rlwinm r5, r5, 0, 0, 0x1b
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB6EC: 54E70100  rlwinm r7, r7, 0, 4, 0
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB6F0: 90A101F4  stw r5, 0x1f4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(500 as u32), ctx.r[5].u32 ) };
	// 832BB6F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BB6F8: 90E10150  stw r7, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[7].u32 ) };
	// 832BB6FC: 409A000C  bne cr6, 0x832bb708
	if !ctx.cr[6].eq {
	pc = 0x832BB708; continue 'dispatch;
	}
	// 832BB700: 54E70314  rlwinm r7, r7, 0, 0xc, 0xa
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB704: 90E10150  stw r7, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[7].u32 ) };
	// 832BB708: 55EA0046  rlwinm r10, r15, 0, 1, 3
	ctx.r[10].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB70C: 3E807000  lis r20, 0x7000
	ctx.r[20].s64 = 1879048192;
	// 832BB710: 7F0AA040  cmplw cr6, r10, r20
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[20].u32, &mut ctx.xer);
	// 832BB714: 419A0084  beq cr6, 0x832bb798
	if ctx.cr[6].eq {
	pc = 0x832BB798; continue 'dispatch;
	}
	// 832BB718: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BB71C: 419A000C  beq cr6, 0x832bb728
	if ctx.cr[6].eq {
	pc = 0x832BB728; continue 'dispatch;
	}
	// 832BB720: 7D473B78  or r7, r10, r7
	ctx.r[7].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 832BB724: 4800000C  b 0x832bb730
	pc = 0x832BB730; continue 'dispatch;
	// 832BB728: 556B0046  rlwinm r11, r11, 0, 1, 3
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB72C: 7D673B78  or r7, r11, r7
	ctx.r[7].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	// 832BB730: 3D403000  lis r10, 0x3000
	ctx.r[10].s64 = 805306368;
	// 832BB734: 90E10150  stw r7, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[7].u32 ) };
	// 832BB738: 54EB0046  rlwinm r11, r7, 0, 1, 3
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB73C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BB740: 41990030  bgt cr6, 0x832bb770
	if ctx.cr[6].gt {
	pc = 0x832BB770; continue 'dispatch;
	}
	// 832BB744: 419A0020  beq cr6, 0x832bb764
	if ctx.cr[6].eq {
	pc = 0x832BB764; continue 'dispatch;
	}
	// 832BB748: 3D401000  lis r10, 0x1000
	ctx.r[10].s64 = 268435456;
	// 832BB74C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BB750: 419A0040  beq cr6, 0x832bb790
	if ctx.cr[6].eq {
	pc = 0x832BB790; continue 'dispatch;
	}
	// 832BB754: 3D402000  lis r10, 0x2000
	ctx.r[10].s64 = 536870912;
	// 832BB758: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BB75C: 409A003C  bne cr6, 0x832bb798
	if !ctx.cr[6].eq {
	pc = 0x832BB798; continue 'dispatch;
	}
	// 832BB760: 48000030  b 0x832bb790
	pc = 0x832BB790; continue 'dispatch;
	// 832BB764: 552B083C  slwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BB768: 91610130  stw r11, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 832BB76C: 4800002C  b 0x832bb798
	pc = 0x832BB798; continue 'dispatch;
	// 832BB770: 3D404000  lis r10, 0x4000
	ctx.r[10].s64 = 1073741824;
	// 832BB774: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BB778: 419A0010  beq cr6, 0x832bb788
	if ctx.cr[6].eq {
	pc = 0x832BB788; continue 'dispatch;
	}
	// 832BB77C: 3D405000  lis r10, 0x5000
	ctx.r[10].s64 = 1342177280;
	// 832BB780: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BB784: 409A0014  bne cr6, 0x832bb798
	if !ctx.cr[6].eq {
	pc = 0x832BB798; continue 'dispatch;
	}
	// 832BB788: 552B083C  slwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BB78C: 91610130  stw r11, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 832BB790: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BB794: 91010134  stw r8, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[8].u32 ) };
	// 832BB798: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BB79C: 419A001C  beq cr6, 0x832bb7b8
	if ctx.cr[6].eq {
	pc = 0x832BB7B8; continue 'dispatch;
	}
	// 832BB7A0: 7F04E840  cmplw cr6, r4, r29
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832BB7A4: 419A0014  beq cr6, 0x832bb7b8
	if ctx.cr[6].eq {
	pc = 0x832BB7B8; continue 'dispatch;
	}
	// 832BB7A8: 7F04C840  cmplw cr6, r4, r25
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[25].u32, &mut ctx.xer);
	// 832BB7AC: 409A0018  bne cr6, 0x832bb7c4
	if !ctx.cr[6].eq {
	pc = 0x832BB7C4; continue 'dispatch;
	}
	// 832BB7B0: 60EB8000  ori r11, r7, 0x8000
	ctx.r[11].u64 = ctx.r[7].u64 | 32768;
	// 832BB7B4: 4800000C  b 0x832bb7c0
	pc = 0x832BB7C0; continue 'dispatch;
	// 832BB7B8: 64EB0001  oris r11, r7, 1
	ctx.r[11].u64 = ctx.r[7].u64 | 65536;
	// 832BB7BC: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 832BB7C0: 91610150  stw r11, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 832BB7C4: 55EB04E6  rlwinm r11, r15, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB7C8: 93810138  stw r28, 0x138(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[28].u32 ) };
	// 832BB7CC: 93E1020C  stw r31, 0x20c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(524 as u32), ctx.r[31].u32 ) };
	// 832BB7D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB7D4: 419A0028  beq cr6, 0x832bb7fc
	if ctx.cr[6].eq {
	pc = 0x832BB7FC; continue 'dispatch;
	}
	// 832BB7D8: 81520010  lwz r10, 0x10(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(16 as u32) ) } as u64;
	// 832BB7DC: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 832BB7E0: 419A001C  beq cr6, 0x832bb7fc
	if ctx.cr[6].eq {
	pc = 0x832BB7FC; continue 'dispatch;
	}
	// 832BB7E4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BB7E8: 91410144  stw r10, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[10].u32 ) };
	// 832BB7EC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 832BB7F0: 91520010  stw r10, 0x10(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 832BB7F4: 91610148  stw r11, 0x148(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 832BB7F8: 4800000C  b 0x832bb804
	pc = 0x832BB804; continue 'dispatch;
	// 832BB7FC: 90610144  stw r3, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[3].u32 ) };
	// 832BB800: 90C10148  stw r6, 0x148(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[6].u32 ) };
	// 832BB804: 54CBF87E  srwi r11, r6, 1
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BB808: 90610420  stw r3, 0x420(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1056 as u32), ctx.r[3].u32 ) };
	// 832BB80C: 3948000F  addi r10, r8, 0xf
	ctx.r[10].s64 = ctx.r[8].s64 + 15;
	// 832BB810: 90C10424  stw r6, 0x424(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1060 as u32), ctx.r[6].u32 ) };
	// 832BB814: 7D2B1A14  add r9, r11, r3
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 832BB818: 93410158  stw r26, 0x158(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[26].u32 ) };
	// 832BB81C: 5548E13E  srwi r8, r10, 4
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BB820: 93610210  stw r27, 0x210(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(528 as u32), ctx.r[27].u32 ) };
	// 832BB824: 7D693397  divwu. r11, r9, r6
	ctx.r[11].u32 = ctx.r[9].u32 / ctx.r[6].u32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BB828: 93010208  stw r24, 0x208(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(520 as u32), ctx.r[24].u32 ) };
	// 832BB82C: 7CE829D6  mullw r7, r8, r5
	ctx.r[7].s64 = (ctx.r[8].s32 as i64) * (ctx.r[5].s32 as i64);
	// 832BB830: 91610428  stw r11, 0x428(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1064 as u32), ctx.r[11].u32 ) };
	// 832BB834: 90E101F8  stw r7, 0x1f8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(504 as u32), ctx.r[7].u32 ) };
	// 832BB838: 4082000C  bne 0x832bb844
	if !ctx.cr[0].eq {
	pc = 0x832BB844; continue 'dispatch;
	}
	// 832BB83C: 7E0B8378  mr r11, r16
	ctx.r[11].u64 = ctx.r[16].u64;
	// 832BB840: 91610428  stw r11, 0x428(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1064 as u32), ctx.r[11].u32 ) };
	// 832BB844: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB848: 38610430  addi r3, r1, 0x430
	ctx.r[3].s64 = ctx.r[1].s64 + 1072;
	// 832BB84C: 4800394D  bl 0x832bf198
	ctx.lr = 0x832BB850;
	sub_832BF198(ctx, base);
	// 832BB850: 81610428  lwz r11, 0x428(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1064 as u32) ) } as u64;
	// 832BB854: 38610434  addi r3, r1, 0x434
	ctx.r[3].s64 = ctx.r[1].s64 + 1076;
	// 832BB858: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB85C: 4800393D  bl 0x832bf198
	ctx.lr = 0x832BB860;
	sub_832BF198(ctx, base);
	// 832BB860: 81410428  lwz r10, 0x428(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1064 as u32) ) } as u64;
	// 832BB864: 38610438  addi r3, r1, 0x438
	ctx.r[3].s64 = ctx.r[1].s64 + 1080;
	// 832BB868: 5544103A  slwi r4, r10, 2
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB86C: 4800392D  bl 0x832bf198
	ctx.lr = 0x832BB870;
	sub_832BF198(ctx, base);
	// 832BB870: 81210428  lwz r9, 0x428(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1064 as u32) ) } as u64;
	// 832BB874: 3861043C  addi r3, r1, 0x43c
	ctx.r[3].s64 = ctx.r[1].s64 + 1084;
	// 832BB878: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB87C: 4800391D  bl 0x832bf198
	ctx.lr = 0x832BB880;
	sub_832BF198(ctx, base);
	// 832BB880: 81010428  lwz r8, 0x428(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1064 as u32) ) } as u64;
	// 832BB884: 38610440  addi r3, r1, 0x440
	ctx.r[3].s64 = ctx.r[1].s64 + 1088;
	// 832BB888: 5504103A  slwi r4, r8, 2
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB88C: 4800390D  bl 0x832bf198
	ctx.lr = 0x832BB890;
	sub_832BF198(ctx, base);
	// 832BB890: 80E10428  lwz r7, 0x428(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1064 as u32) ) } as u64;
	// 832BB894: 38610444  addi r3, r1, 0x444
	ctx.r[3].s64 = ctx.r[1].s64 + 1092;
	// 832BB898: 54E4103A  slwi r4, r7, 2
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB89C: 480038FD  bl 0x832bf198
	ctx.lr = 0x832BB8A0;
	sub_832BF198(ctx, base);
	// 832BB8A0: 80C10428  lwz r6, 0x428(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1064 as u32) ) } as u64;
	// 832BB8A4: 38610448  addi r3, r1, 0x448
	ctx.r[3].s64 = ctx.r[1].s64 + 1096;
	// 832BB8A8: 54C4103A  slwi r4, r6, 2
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB8AC: 480038ED  bl 0x832bf198
	ctx.lr = 0x832BB8B0;
	sub_832BF198(ctx, base);
	// 832BB8B0: 8172001C  lwz r11, 0x1c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BB8B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BB8B8: 409A0008  bne cr6, 0x832bb8c0
	if !ctx.cr[6].eq {
	pc = 0x832BB8C0; continue 'dispatch;
	}
	// 832BB8BC: 7E0B8378  mr r11, r16
	ctx.r[11].u64 = ctx.r[16].u64;
	// 832BB8C0: 1C8B0184  mulli r4, r11, 0x184
	ctx.r[4].s64 = ctx.r[11].s64 * 388;
	// 832BB8C4: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 832BB8C8: 480038D1  bl 0x832bf198
	ctx.lr = 0x832BB8CC;
	sub_832BF198(ctx, base);
	// 832BB8CC: 8172001C  lwz r11, 0x1c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BB8D0: 3861024C  addi r3, r1, 0x24c
	ctx.r[3].s64 = ctx.r[1].s64 + 588;
	// 832BB8D4: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB8D8: 480038C1  bl 0x832bf198
	ctx.lr = 0x832BB8DC;
	sub_832BF198(ctx, base);
	// 832BB8DC: 81610130  lwz r11, 0x130(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) } as u64;
	// 832BB8E0: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 832BB8E4: 394B000F  addi r10, r11, 0xf
	ctx.r[10].s64 = ctx.r[11].s64 + 15;
	// 832BB8E8: 554B0036  rlwinm r11, r10, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB8EC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BB8F0: 556918F8  rlwinm r9, r11, 3, 3, 0x1c
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 832BB8F4: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BB8F8: 556800FE  clrlwi r8, r11, 3
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 832BB8FC: 54E608FC  rlwinm r6, r7, 1, 3, 0x1e
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x7FFFFFFFu64;
	// 832BB900: 556AE8FE  srwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BB904: 5567F0FC  rlwinm r7, r11, 0x1e, 3, 0x1e
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 832BB908: 556BE13E  srwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BB90C: 38A9020F  addi r5, r9, 0x20f
	ctx.r[5].s64 = ctx.r[9].s64 + 527;
	// 832BB910: 3888020F  addi r4, r8, 0x20f
	ctx.r[4].s64 = ctx.r[8].s64 + 527;
	// 832BB914: 3866020F  addi r3, r6, 0x20f
	ctx.r[3].s64 = ctx.r[6].s64 + 527;
	// 832BB918: 390A020F  addi r8, r10, 0x20f
	ctx.r[8].s64 = ctx.r[10].s64 + 527;
	// 832BB91C: 38CB020F  addi r6, r11, 0x20f
	ctx.r[6].s64 = ctx.r[11].s64 + 527;
	// 832BB920: 54AB0036  rlwinm r11, r5, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB924: 548A0036  rlwinm r10, r4, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB928: 54690036  rlwinm r9, r3, 0, 0, 0x1b
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB92C: 38E7040F  addi r7, r7, 0x40f
	ctx.r[7].s64 = ctx.r[7].s64 + 1039;
	// 832BB930: 55050036  rlwinm r5, r8, 0, 0, 0x1b
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB934: 54E40036  rlwinm r4, r7, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB938: 54C30036  rlwinm r3, r6, 0, 0, 0x1b
	ctx.r[3].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 832BB93C: 90A10250  stw r5, 0x250(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(592 as u32), ctx.r[5].u32 ) };
	// 832BB940: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 832BB944: 90A10260  stw r5, 0x260(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(608 as u32), ctx.r[5].u32 ) };
	// 832BB948: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 832BB94C: 90610254  stw r3, 0x254(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(596 as u32), ctx.r[3].u32 ) };
	// 832BB950: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 832BB954: 91610258  stw r11, 0x258(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 832BB958: 9141025C  stw r10, 0x25c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(604 as u32), ctx.r[10].u32 ) };
	// 832BB95C: 90A10264  stw r5, 0x264(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(612 as u32), ctx.r[5].u32 ) };
	// 832BB960: 90810268  stw r4, 0x268(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(616 as u32), ctx.r[4].u32 ) };
	// 832BB964: 9081026C  stw r4, 0x26c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(620 as u32), ctx.r[4].u32 ) };
	// 832BB968: 91210270  stw r9, 0x270(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(624 as u32), ctx.r[9].u32 ) };
	// 832BB96C: 409A0048  bne cr6, 0x832bb9b4
	if !ctx.cr[6].eq {
	pc = 0x832BB9B4; continue 'dispatch;
	}
	// 832BB970: 8161020C  lwz r11, 0x20c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(524 as u32) ) } as u64;
	// 832BB974: 3861027C  addi r3, r1, 0x27c
	ctx.r[3].s64 = ctx.r[1].s64 + 636;
	// 832BB978: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 832BB97C: 5544103A  slwi r4, r10, 2
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB980: 48003819  bl 0x832bf198
	ctx.lr = 0x832BB984;
	sub_832BF198(ctx, base);
	// 832BB984: 81210210  lwz r9, 0x210(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(528 as u32) ) } as u64;
	// 832BB988: 386103D4  addi r3, r1, 0x3d4
	ctx.r[3].s64 = ctx.r[1].s64 + 980;
	// 832BB98C: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB990: 48003809  bl 0x832bf198
	ctx.lr = 0x832BB994;
	sub_832BF198(ctx, base);
	// 832BB994: 81010210  lwz r8, 0x210(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(528 as u32) ) } as u64;
	// 832BB998: 386103D8  addi r3, r1, 0x3d8
	ctx.r[3].s64 = ctx.r[1].s64 + 984;
	// 832BB99C: 5504103A  slwi r4, r8, 2
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB9A0: 480037F9  bl 0x832bf198
	ctx.lr = 0x832BB9A4;
	sub_832BF198(ctx, base);
	// 832BB9A4: 80E10210  lwz r7, 0x210(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(528 as u32) ) } as u64;
	// 832BB9A8: 386103DC  addi r3, r1, 0x3dc
	ctx.r[3].s64 = ctx.r[1].s64 + 988;
	// 832BB9AC: 54E4103A  slwi r4, r7, 2
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BB9B0: 480037E9  bl 0x832bf198
	ctx.lr = 0x832BB9B4;
	sub_832BF198(ctx, base);
	// 832BB9B4: 3880039C  li r4, 0x39c
	ctx.r[4].s64 = 924;
	// 832BB9B8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 832BB9BC: 4BFFF245  bl 0x832bac00
	ctx.lr = 0x832BB9C0;
	sub_832BAC00(ctx, base);
	// 832BB9C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BB9C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BB9C8: 419A04DC  beq cr6, 0x832bbea4
	if ctx.cr[6].eq {
	pc = 0x832BBEA4; continue 'dispatch;
	}
	// 832BB9CC: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 832BB9D0: 38A0039C  li r5, 0x39c
	ctx.r[5].s64 = 924;
	// 832BB9D4: 4B9EDAAD  bl 0x82ca9480
	ctx.lr = 0x832BB9D8;
	sub_82CA9480(ctx, base);
	// 832BB9D8: 817F0304  lwz r11, 0x304(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(772 as u32) ) } as u64;
	// 832BB9DC: 93FF016C  stw r31, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[31].u32 ) };
	// 832BB9E0: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 832BB9E4: 922B0000  stw r17, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 832BB9E8: 815F0308  lwz r10, 0x308(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(776 as u32) ) } as u64;
	// 832BB9EC: 922A0000  stw r17, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 832BB9F0: 813F030C  lwz r9, 0x30c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(780 as u32) ) } as u64;
	// 832BB9F4: 92290000  stw r17, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 832BB9F8: 811F0310  lwz r8, 0x310(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(784 as u32) ) } as u64;
	// 832BB9FC: 92280000  stw r17, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 832BBA00: 80FF0314  lwz r7, 0x314(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(788 as u32) ) } as u64;
	// 832BBA04: 92270000  stw r17, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 832BBA08: 80DF0318  lwz r6, 0x318(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(792 as u32) ) } as u64;
	// 832BBA0C: 92260000  stw r17, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 832BBA10: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BBA14: 419A0078  beq cr6, 0x832bba8c
	if ctx.cr[6].eq {
	pc = 0x832BBA8C; continue 'dispatch;
	}
	// 832BBA18: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BBA1C: 390B000B  addi r8, r11, 0xb
	ctx.r[8].s64 = ctx.r[11].s64 + 11;
	// 832BBA20: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BBA24: 3936002C  addi r9, r22, 0x2c
	ctx.r[9].s64 = ctx.r[22].s64 + 44;
	// 832BBA28: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BBA2C: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BBA30: 913F02A4  stw r9, 0x2a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[9].u32 ) };
	// 832BBA34: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BBA38: 7D6BB214  add r11, r11, r22
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 832BBA3C: 7D4AB214  add r10, r10, r22
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 832BBA40: 7CC9B214  add r6, r9, r22
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[22].u64;
	// 832BBA44: 38AB002C  addi r5, r11, 0x2c
	ctx.r[5].s64 = ctx.r[11].s64 + 44;
	// 832BBA48: 388A002C  addi r4, r10, 0x2c
	ctx.r[4].s64 = ctx.r[10].s64 + 44;
	// 832BBA4C: 90DF02A8  stw r6, 0x2a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(680 as u32), ctx.r[6].u32 ) };
	// 832BBA50: 90BF02AC  stw r5, 0x2ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(684 as u32), ctx.r[5].u32 ) };
	// 832BBA54: 909F014C  stw r4, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[4].u32 ) };
	// 832BBA58: 38FF0394  addi r7, r31, 0x394
	ctx.r[7].s64 = ctx.r[31].s64 + 916;
	// 832BBA5C: 80BF02F8  lwz r5, 0x2f8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(760 as u32) ) } as u64;
	// 832BBA60: 38DF00E8  addi r6, r31, 0xe8
	ctx.r[6].s64 = ctx.r[31].s64 + 232;
	// 832BBA64: 809F014C  lwz r4, 0x14c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 832BBA68: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BBA6C: 4BFFF6C5  bl 0x832bb130
	ctx.lr = 0x832BBA70;
	sub_832BB130(ctx, base);
	// 832BBA70: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 832BBA74: 907F00E4  stw r3, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[3].u32 ) };
	// 832BBA78: 409A00B4  bne cr6, 0x832bbb2c
	if !ctx.cr[6].eq {
	pc = 0x832BBB2C; continue 'dispatch;
	}
	// 832BBA7C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832BBA80: 386BFEA8  addi r3, r11, -0x158
	ctx.r[3].s64 = ctx.r[11].s64 + -344;
	// 832BBA84: 4BFFF22D  bl 0x832bacb0
	ctx.lr = 0x832BBA88;
	sub_832BACB0(ctx, base);
	// 832BBA88: 480003EC  b 0x832bbe74
	pc = 0x832BBE74; continue 'dispatch;
	// 832BBA8C: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 832BBA90: 815F0150  lwz r10, 0x150(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 832BBA94: 80BF02A4  lwz r5, 0x2a4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 832BBA98: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BBA9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBAA0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BBAA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832BBAA8: 4E800421  bctrl
	ctx.lr = 0x832BBAAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBAAC: 813F00E0  lwz r9, 0xe0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BBAB0: 80BF02A8  lwz r5, 0x2a8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 832BBAB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBAB8: 811F0150  lwz r8, 0x150(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 832BBABC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BBAC0: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BBAC4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 832BBAC8: 4E800421  bctrl
	ctx.lr = 0x832BBACC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBACC: 80FF00E0  lwz r7, 0xe0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BBAD0: 80BF02AC  lwz r5, 0x2ac(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(684 as u32) ) } as u64;
	// 832BBAD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBAD8: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 832BBADC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BBAE0: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BBAE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BBAE8: 4E800421  bctrl
	ctx.lr = 0x832BBAEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBAEC: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 832BBAF0: 80BF014C  lwz r5, 0x14c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 832BBAF4: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BBAF8: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 832BBAFC: 813F0150  lwz r9, 0x150(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 832BBB00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBB04: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BBB08: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BBB0C: 4E800421  bctrl
	ctx.lr = 0x832BBB10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBB10: 811F0170  lwz r8, 0x170(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 832BBB14: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 832BBB18: 419AFF40  beq cr6, 0x832bba58
	if ctx.cr[6].eq {
	pc = 0x832BBA58; continue 'dispatch;
	}
	// 832BBB1C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832BBB20: 386BFE8C  addi r3, r11, -0x174
	ctx.r[3].s64 = ctx.r[11].s64 + -372;
	// 832BBB24: 4BFFF18D  bl 0x832bacb0
	ctx.lr = 0x832BBB28;
	sub_832BACB0(ctx, base);
	// 832BBB28: 4800034C  b 0x832bbe74
	pc = 0x832BBE74; continue 'dispatch;
	// 832BBB2C: 55EB056A  rlwinm r11, r15, 0, 0x15, 0x15
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BBB30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BBB34: 409A0150  bne cr6, 0x832bbc84
	if !ctx.cr[6].eq {
	pc = 0x832BBC84; continue 'dispatch;
	}
	// 832BBB38: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 832BBB3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BBB40: 4BFFF8A1  bl 0x832bb3e0
	ctx.lr = 0x832BBB44;
	sub_832BB3E0(ctx, base);
	// 832BBB44: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 832BBB48: 7E298B78  mr r9, r17
	ctx.r[9].u64 = ctx.r[17].u64;
	// 832BBB4C: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	// 832BBB50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BBB54: 409900D0  ble cr6, 0x832bbc24
	if !ctx.cr[6].gt {
	pc = 0x832BBC24; continue 'dispatch;
	}
	// 832BBB58: 3BC100CC  addi r30, r1, 0xcc
	ctx.r[30].s64 = ctx.r[1].s64 + 204;
	// 832BBB5C: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BBB60: 815EFFFC  lwz r10, -4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 832BBB64: 390B000F  addi r8, r11, 0xf
	ctx.r[8].s64 = ctx.r[11].s64 + 15;
	// 832BBB68: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BBB6C: 551D0036  rlwinm r29, r8, 0, 0, 0x1b
	ctx.r[29].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 832BBB70: 419A0024  beq cr6, 0x832bbb94
	if ctx.cr[6].eq {
	pc = 0x832BBB94; continue 'dispatch;
	}
	// 832BBB74: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 832BBB78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBB7C: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 832BBB80: 7C8A59D6  mullw r4, r10, r11
	ctx.r[4].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 832BBB84: 48003615  bl 0x832bf198
	ctx.lr = 0x832BBB88;
	sub_832BF198(ctx, base);
	// 832BBB88: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 832BBB8C: 911E0004  stw r8, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 832BBB90: 7E098378  mr r9, r16
	ctx.r[9].u64 = ctx.r[16].u64;
	// 832BBB94: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BBB98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BBB9C: 419A001C  beq cr6, 0x832bbbb8
	if ctx.cr[6].eq {
	pc = 0x832BBBB8; continue 'dispatch;
	}
	// 832BBBA0: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 832BBBA4: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 832BBBA8: 7C8BE9D6  mullw r4, r11, r29
	ctx.r[4].s64 = (ctx.r[11].s32 as i64) * (ctx.r[29].s32 as i64);
	// 832BBBAC: 480035ED  bl 0x832bf198
	ctx.lr = 0x832BBBB0;
	sub_832BF198(ctx, base);
	// 832BBBB0: 93BE0010  stw r29, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 832BBBB4: 7E098378  mr r9, r16
	ctx.r[9].u64 = ctx.r[16].u64;
	// 832BBBB8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BBBBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BBBC0: 419A001C  beq cr6, 0x832bbbdc
	if ctx.cr[6].eq {
	pc = 0x832BBBDC; continue 'dispatch;
	}
	// 832BBBC4: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 832BBBC8: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 832BBBCC: 7C8BE9D6  mullw r4, r11, r29
	ctx.r[4].s64 = (ctx.r[11].s32 as i64) * (ctx.r[29].s32 as i64);
	// 832BBBD0: 480035C9  bl 0x832bf198
	ctx.lr = 0x832BBBD4;
	sub_832BF198(ctx, base);
	// 832BBBD4: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 832BBBD8: 7E098378  mr r9, r16
	ctx.r[9].u64 = ctx.r[16].u64;
	// 832BBBDC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BBBE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BBBE4: 419A0024  beq cr6, 0x832bbc08
	if ctx.cr[6].eq {
	pc = 0x832BBC08; continue 'dispatch;
	}
	// 832BBBE8: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 832BBBEC: 387E0024  addi r3, r30, 0x24
	ctx.r[3].s64 = ctx.r[30].s64 + 36;
	// 832BBBF0: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 832BBBF4: 7C8A59D6  mullw r4, r10, r11
	ctx.r[4].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 832BBBF8: 480035A1  bl 0x832bf198
	ctx.lr = 0x832BBBFC;
	sub_832BF198(ctx, base);
	// 832BBBFC: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 832BBC00: 911E0028  stw r8, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 832BBC04: 7E098378  mr r9, r16
	ctx.r[9].u64 = ctx.r[16].u64;
	// 832BBC08: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 832BBC0C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 832BBC10: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 832BBC14: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 832BBC18: 4198FF44  blt cr6, 0x832bbb5c
	if ctx.cr[6].lt {
	pc = 0x832BBB5C; continue 'dispatch;
	}
	// 832BBC1C: 2F1C0002  cmpwi cr6, r28, 2
	ctx.cr[6].compare_i32(ctx.r[28].s32, 2, &mut ctx.xer);
	// 832BBC20: 40980034  bge cr6, 0x832bbc54
	if !ctx.cr[6].lt {
	pc = 0x832BBC54; continue 'dispatch;
	}
	// 832BBC24: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BBC28: 390100E4  addi r8, r1, 0xe4
	ctx.r[8].s64 = ctx.r[1].s64 + 228;
	// 832BBC2C: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 832BBC30: 215C0002  subfic r10, r28, 2
	ctx.xer.ca = ctx.r[28].u32 <= 2 as u32;
	ctx.r[10].s64 = (2 as i64) - ctx.r[28].s64;
	// 832BBC34: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BBC38: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 832BBC3C: 922BFFF4  stw r17, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[17].u32 ) };
	// 832BBC40: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BBC44: 922B0000  stw r17, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 832BBC48: 922BFFE8  stw r17, -0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), ctx.r[17].u32 ) };
	// 832BBC4C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 832BBC50: 4082FFEC  bne 0x832bbc3c
	if !ctx.cr[0].eq {
	pc = 0x832BBC3C; continue 'dispatch;
	}
	// 832BBC54: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BBC58: 419A002C  beq cr6, 0x832bbc84
	if ctx.cr[6].eq {
	pc = 0x832BBC84; continue 'dispatch;
	}
	// 832BBC5C: 38800078  li r4, 0x78
	ctx.r[4].s64 = 120;
	// 832BBC60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BBC64: 4BFFEF9D  bl 0x832bac00
	ctx.lr = 0x832BBC68;
	sub_832BAC00(ctx, base);
	// 832BBC68: 907F0398  stw r3, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[3].u32 ) };
	// 832BBC6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BBC70: 419A0204  beq cr6, 0x832bbe74
	if ctx.cr[6].eq {
	pc = 0x832BBE74; continue 'dispatch;
	}
	// 832BBC74: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 832BBC78: 907F00BC  stw r3, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[3].u32 ) };
	// 832BBC7C: 38A00078  li r5, 0x78
	ctx.r[5].s64 = 120;
	// 832BBC80: 4B9ED801  bl 0x82ca9480
	ctx.lr = 0x832BBC84;
	sub_82CA9480(ctx, base);
	// 832BBC84: 55EB01CE  rlwinm r11, r15, 0, 7, 7
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BBC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BBC8C: 419A0020  beq cr6, 0x832bbcac
	if ctx.cr[6].eq {
	pc = 0x832BBCAC; continue 'dispatch;
	}
	// 832BBC90: 81720014  lwz r11, 0x14(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BBC94: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 832BBC98: 419A0014  beq cr6, 0x832bbcac
	if ctx.cr[6].eq {
	pc = 0x832BBCAC; continue 'dispatch;
	}
	// 832BBC9C: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 832BBCA0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 832BBCA4: 91720014  stw r11, 0x14(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 832BBCA8: 4800000C  b 0x832bbcb4
	pc = 0x832BBCB4; continue 'dispatch;
	// 832BBCAC: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 832BBCB0: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 832BBCB4: 55EB0252  rlwinm r11, r15, 0, 9, 9
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BBCB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BBCBC: 419A0020  beq cr6, 0x832bbcdc
	if ctx.cr[6].eq {
	pc = 0x832BBCDC; continue 'dispatch;
	}
	// 832BBCC0: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BBCC4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 832BBCC8: 419A0014  beq cr6, 0x832bbcdc
	if ctx.cr[6].eq {
	pc = 0x832BBCDC; continue 'dispatch;
	}
	// 832BBCCC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 832BBCD0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 832BBCD4: 91720018  stw r11, 0x18(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 832BBCD8: 48000008  b 0x832bbce0
	pc = 0x832BBCE0; continue 'dispatch;
	// 832BBCDC: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	// 832BBCE0: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 832BBCE4: 419A001C  beq cr6, 0x832bbd00
	if ctx.cr[6].eq {
	pc = 0x832BBD00; continue 'dispatch;
	}
	// 832BBCE8: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 832BBCEC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BBCF0: 554B003C  rlwinm r11, r10, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 832BBCF4: 7D2BB214  add r9, r11, r22
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 832BBCF8: 913F0148  stw r9, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[9].u32 ) };
	// 832BBCFC: 480001D4  b 0x832bbed0
	pc = 0x832BBED0; continue 'dispatch;
	// 832BBD00: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 832BBD04: 809F0298  lwz r4, 0x298(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 832BBD08: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 832BBD0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBD10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BBD14: 4E800421  bctrl
	ctx.lr = 0x832BBD18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBD18: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 832BBD1C: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 832BBD20: 907F0298  stw r3, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[3].u32 ) };
	// 832BBD24: 7D6A4B96  divwu r11, r10, r9
	ctx.r[11].u32 = ctx.r[10].u32 / ctx.r[9].u32;
	// 832BBD28: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BBD2C: 7D0B4A14  add r8, r11, r9
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 832BBD30: 7F034040  cmplw cr6, r3, r8
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[8].u32, &mut ctx.xer);
	// 832BBD34: 41980014  blt cr6, 0x832bbd48
	if ctx.cr[6].lt {
	pc = 0x832BBD48; continue 'dispatch;
	}
	// 832BBD38: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BBD3C: 61EF2000  ori r15, r15, 0x2000
	ctx.r[15].u64 = ctx.r[15].u64 | 8192;
	// 832BBD40: 61692000  ori r9, r11, 0x2000
	ctx.r[9].u64 = ctx.r[11].u64 | 8192;
	// 832BBD44: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 832BBD48: 55EB04A4  rlwinm r11, r15, 0, 0x12, 0x12
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BBD4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BBD50: 419A00C4  beq cr6, 0x832bbe14
	if ctx.cr[6].eq {
	pc = 0x832BBE14; continue 'dispatch;
	}
	// 832BBD54: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 832BBD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BBD5C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BBD60: 5528003C  rlwinm r8, r9, 0, 0, 0x1e
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 832BBD64: 7D685050  subf r11, r8, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 832BBD68: 3BAB0008  addi r29, r11, 8
	ctx.r[29].s64 = ctx.r[11].s64 + 8;
	// 832BBD6C: 389D0400  addi r4, r29, 0x400
	ctx.r[4].s64 = ctx.r[29].s64 + 1024;
	// 832BBD70: 4BFFEE91  bl 0x832bac00
	ctx.lr = 0x832BBD74;
	sub_832BAC00(ctx, base);
	// 832BBD74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BBD78: 907F0148  stw r3, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[3].u32 ) };
	// 832BBD7C: 409A0034  bne cr6, 0x832bbdb0
	if !ctx.cr[6].eq {
	pc = 0x832BBDB0; continue 'dispatch;
	}
	// 832BBD80: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BBD84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BBD88: 419A00EC  beq cr6, 0x832bbe74
	if ctx.cr[6].eq {
	pc = 0x832BBE74; continue 'dispatch;
	}
	// 832BBD8C: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BBD90: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BBD94: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BBD98: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BBD9C: 409A00D4  bne cr6, 0x832bbe70
	if !ctx.cr[6].eq {
	pc = 0x832BBE70; continue 'dispatch;
	}
	// 832BBDA0: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BBDA4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BBDA8: 4E800421  bctrl
	ctx.lr = 0x832BBDAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBDAC: 480000C8  b 0x832bbe74
	pc = 0x832BBE74; continue 'dispatch;
	// 832BBDB0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 832BBDB4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 832BBDB8: 815F015C  lwz r10, 0x15c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 832BBDBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BBDC0: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 832BBDC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BBDC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBDCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832BBDD0: 4E800421  bctrl
	ctx.lr = 0x832BBDD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBDD4: 813F014C  lwz r9, 0x14c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 832BBDD8: 80DF0148  lwz r6, 0x148(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 832BBDDC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 832BBDE0: 811F0154  lwz r8, 0x154(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 832BBDE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BBDE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBDEC: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BBDF0: 54A5003C  rlwinm r5, r5, 0, 0, 0x1e
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 832BBDF4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 832BBDF8: 4E800421  bctrl
	ctx.lr = 0x832BBDFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBDFC: 809F0164  lwz r4, 0x164(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 832BBE00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBE04: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	// 832BBE08: 4E800421  bctrl
	ctx.lr = 0x832BBE0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBE0C: 923F0184  stw r17, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[17].u32 ) };
	// 832BBE10: 480000C0  b 0x832bbed0
	pc = 0x832BBED0; continue 'dispatch;
	// 832BBE14: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 832BBE18: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 832BBE1C: 388B0400  addi r4, r11, 0x400
	ctx.r[4].s64 = ctx.r[11].s64 + 1024;
	// 832BBE20: 48003379  bl 0x832bf198
	ctx.lr = 0x832BBE24;
	sub_832BF198(ctx, base);
	// 832BBE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BBE28: 809F0298  lwz r4, 0x298(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 832BBE2C: 4BFFEDD5  bl 0x832bac00
	ctx.lr = 0x832BBE30;
	sub_832BAC00(ctx, base);
	// 832BBE30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 832BBE34: 909F0294  stw r4, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[4].u32 ) };
	// 832BBE38: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 832BBE3C: 409A0074  bne cr6, 0x832bbeb0
	if !ctx.cr[6].eq {
	pc = 0x832BBEB0; continue 'dispatch;
	}
	// 832BBE40: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BBE44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BBE48: 419A002C  beq cr6, 0x832bbe74
	if ctx.cr[6].eq {
	pc = 0x832BBE74; continue 'dispatch;
	}
	// 832BBE4C: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BBE50: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BBE54: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BBE58: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BBE5C: 409A0014  bne cr6, 0x832bbe70
	if !ctx.cr[6].eq {
	pc = 0x832BBE70; continue 'dispatch;
	}
	// 832BBE60: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BBE64: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BBE68: 4E800421  bctrl
	ctx.lr = 0x832BBE6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBE6C: 48000008  b 0x832bbe74
	pc = 0x832BBE74; continue 'dispatch;
	// 832BBE70: 4B9F02D1  bl 0x82cac140
	ctx.lr = 0x832BBE74;
	sub_82CAC140(ctx, base);
	// 832BBE74: 897FFFFE  lbz r11, -2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BBE78: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 832BBE7C: 897FFFFF  lbz r11, -1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BBE80: 7C6BF850  subf r3, r11, r31
	ctx.r[3].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 832BBE84: 409A001C  bne cr6, 0x832bbea0
	if !ctx.cr[6].eq {
	pc = 0x832BBEA0; continue 'dispatch;
	}
	// 832BBE88: 815FFFF4  lwz r10, -0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BBE8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832BBE90: 4E800421  bctrl
	ctx.lr = 0x832BBE94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBE94: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832BBE98: 386BFE7C  addi r3, r11, -0x184
	ctx.r[3].s64 = ctx.r[11].s64 + -388;
	// 832BBE9C: 480006D0  b 0x832bc56c
	pc = 0x832BC56C; continue 'dispatch;
	// 832BBEA0: 4B9F02A1  bl 0x82cac140
	ctx.lr = 0x832BBEA4;
	sub_82CAC140(ctx, base);
	// 832BBEA4: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832BBEA8: 386BFE7C  addi r3, r11, -0x184
	ctx.r[3].s64 = ctx.r[11].s64 + -388;
	// 832BBEAC: 480006C0  b 0x832bc56c
	pc = 0x832BC56C; continue 'dispatch;
	// 832BBEB0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 832BBEB4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 832BBEB8: 80BF0298  lwz r5, 0x298(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 832BBEBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BBEC0: 815F015C  lwz r10, 0x15c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 832BBEC4: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 832BBEC8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832BBECC: 4E800421  bctrl
	ctx.lr = 0x832BBED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BBED0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BBED4: 3A60FFFF  li r19, -1
	ctx.r[19].s64 = -1;
	// 832BBED8: 927F000C  stw r19, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[19].u32 ) };
	// 832BBEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BBEE0: 419A001C  beq cr6, 0x832bbefc
	if ctx.cr[6].eq {
	pc = 0x832BBEFC; continue 'dispatch;
	}
	// 832BBEE4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BBEE8: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 832BBEEC: 1D0A07D0  mulli r8, r10, 0x7d0
	ctx.r[8].s64 = ctx.r[10].s64 * 2000;
	// 832BBEF0: 7CE84B92  divdu r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 / ctx.r[9].u64;
	// 832BBEF4: 90FF02C8  stw r7, 0x2c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(712 as u32), ctx.r[7].u32 ) };
	// 832BBEF8: 4800000C  b 0x832bbf04
	pc = 0x832BBF04; continue 'dispatch;
	// 832BBEFC: 396007D0  li r11, 0x7d0
	ctx.r[11].s64 = 2000;
	// 832BBF00: 917F02C8  stw r11, 0x2c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(712 as u32), ctx.r[11].u32 ) };
	// 832BBF04: 921F00FC  stw r16, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[16].u32 ) };
	// 832BBF08: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BBF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BBF10: 4BFFF0E9  bl 0x832baff8
	ctx.lr = 0x832BBF14;
	sub_832BAFF8(ctx, base);
	// 832BBF14: 48004BA5  bl 0x832c0ab8
	ctx.lr = 0x832BBF18;
	sub_832C0AB8(ctx, base);
	// 832BBF18: 817F02EC  lwz r11, 0x2ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(748 as u32) ) } as u64;
	// 832BBF1C: 815F0118  lwz r10, 0x118(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BBF20: 3E800001  lis r20, 1
	ctx.r[20].s64 = 65536;
	// 832BBF24: 7D2B1850  subf r9, r11, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BBF28: 913F02EC  stw r9, 0x2ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(748 as u32), ctx.r[9].u32 ) };
	// 832BBF2C: 928A0040  stw r20, 0x40(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[20].u32 ) };
	// 832BBF30: 811F00E0  lwz r8, 0xe0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BBF34: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 832BBF38: 923F0114  stw r17, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[17].u32 ) };
	// 832BBF3C: 419A007C  beq cr6, 0x832bbfb8
	if ctx.cr[6].eq {
	pc = 0x832BBFB8; continue 'dispatch;
	}
	// 832BBF40: 8172001C  lwz r11, 0x1c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BBF44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BBF48: 419A0070  beq cr6, 0x832bbfb8
	if ctx.cr[6].eq {
	pc = 0x832BBFB8; continue 'dispatch;
	}
	// 832BBF4C: 39120024  addi r8, r18, 0x24
	ctx.r[8].s64 = ctx.r[18].s64 + 36;
	// 832BBF50: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 832BBF54: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BBF58: 7E2A8B78  mr r10, r17
	ctx.r[10].u64 = ctx.r[17].u64;
	// 832BBF5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BBF60: 4099004C  ble cr6, 0x832bbfac
	if !ctx.cr[6].gt {
	pc = 0x832BBFAC; continue 'dispatch;
	}
	// 832BBF64: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BBF68: 817F02AC  lwz r11, 0x2ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(684 as u32) ) } as u64;
	// 832BBF6C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BBF70: 7F064800  cmpw cr6, r6, r9
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[9].s32, &mut ctx.xer);
	// 832BBF74: 419A001C  beq cr6, 0x832bbf90
	if ctx.cr[6].eq {
	pc = 0x832BBF90; continue 'dispatch;
	}
	// 832BBF78: 80DF00E0  lwz r6, 0xe0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BBF7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832BBF80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BBF84: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 832BBF88: 4198FFE4  blt cr6, 0x832bbf6c
	if ctx.cr[6].lt {
	pc = 0x832BBF6C; continue 'dispatch;
	}
	// 832BBF8C: 48000020  b 0x832bbfac
	pc = 0x832BBFAC; continue 'dispatch;
	// 832BBF90: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BBF94: 813F011C  lwz r9, 0x11c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 832BBF98: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BBF9C: 7D46492E  stwx r10, r6, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 832BBFA0: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BBFA4: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 832BBFA8: 90BF0114  stw r5, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[5].u32 ) };
	// 832BBFAC: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 832BBFB0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 832BBFB4: 4082FFA0  bne 0x832bbf54
	if !ctx.cr[0].eq {
	pc = 0x832BBF54; continue 'dispatch;
	}
	// 832BBFB8: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 832BBFBC: 7E0A8378  mr r10, r16
	ctx.r[10].u64 = ctx.r[16].u64;
	// 832BBFC0: 91720024  stw r11, 0x24(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 832BBFC4: 7E368B78  mr r22, r17
	ctx.r[22].u64 = ctx.r[17].u64;
	// 832BBFC8: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BBFCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BBFD0: 9152001C  stw r10, 0x1c(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 832BBFD4: 409903D8  ble cr6, 0x832bc3ac
	if !ctx.cr[6].gt {
	pc = 0x832BC3AC; continue 'dispatch;
	}
	// 832BBFD8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 832BBFDC: 7E388B78  mr r24, r17
	ctx.r[24].u64 = ctx.r[17].u64;
	// 832BBFE0: 7E3E8B78  mr r30, r17
	ctx.r[30].u64 = ctx.r[17].u64;
	// 832BBFE4: 3AE003E8  li r23, 0x3e8
	ctx.r[23].s64 = 1000;
	// 832BBFE8: 6175E800  ori r21, r11, 0xe800
	ctx.r[21].u64 = ctx.r[11].u64 | 59392;
	// 832BBFEC: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BBFF0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BBFF4: 922B000C  stw r17, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[17].u32 ) };
	// 832BBFF8: 817F011C  lwz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 832BBFFC: 815F02A8  lwz r10, 0x2a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 832BC000: 7D38582E  lwzx r9, r24, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 832BC004: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BC008: 7D28502E  lwzx r9, r8, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 832BC00C: 55270000  rlwinm r7, r9, 0, 0, 0
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 832BC010: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 832BC014: 409A0010  bne cr6, 0x832bc024
	if !ctx.cr[6].eq {
	pc = 0x832BC024; continue 'dispatch;
	}
	// 832BC018: 552800C6  rlwinm r8, r9, 0, 3, 3
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 832BC01C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 832BC020: 419A0320  beq cr6, 0x832bc340
	if ctx.cr[6].eq {
	pc = 0x832BC340; continue 'dispatch;
	}
	// 832BC024: 81120000  lwz r8, 0(r18)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BC028: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 832BC02C: 419A0314  beq cr6, 0x832bc340
	if ctx.cr[6].eq {
	pc = 0x832BC340; continue 'dispatch;
	}
	// 832BC030: 553C043E  clrlwi r28, r9, 0x10
	ctx.r[28].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 832BC034: 7F1CA840  cmplw cr6, r28, r21
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[21].u32, &mut ctx.xer);
	// 832BC038: 41990308  bgt cr6, 0x832bc340
	if ctx.cr[6].gt {
	pc = 0x832BC340; continue 'dispatch;
	}
	// 832BC03C: 7D78582E  lwzx r11, r24, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 832BC040: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 832BC044: 813F02A4  lwz r9, 0x2a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 832BC048: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832BC04C: 81010144  lwz r8, 0x144(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 832BC050: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 832BC054: 7D69382E  lwzx r11, r9, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 832BC058: 7CCA382E  lwzx r6, r10, r7
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 832BC05C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BC060: 54C92F38  rlwinm r9, r6, 5, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x07FFFFFFu64;
	// 832BC064: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BC068: 54CB1FFE  rlwinm r11, r6, 3, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x1FFFFFFFu64;
	// 832BC06C: 54AAF0BE  srwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BC070: 3B690008  addi r27, r9, 8
	ctx.r[27].s64 = ctx.r[9].s64 + 8;
	// 832BC074: 388A00FF  addi r4, r10, 0xff
	ctx.r[4].s64 = ctx.r[10].s64 + 255;
	// 832BC078: 3B4B0001  addi r26, r11, 1
	ctx.r[26].s64 = ctx.r[11].s64 + 1;
	// 832BC07C: 5499002E  rlwinm r25, r4, 0, 0, 0x17
	ctx.r[25].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 832BC080: 419A0084  beq cr6, 0x832bc104
	if ctx.cr[6].eq {
	pc = 0x832BC104; continue 'dispatch;
	}
	// 832BC084: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 832BC088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC08C: 419A0078  beq cr6, 0x832bc104
	if ctx.cr[6].eq {
	pc = 0x832BC104; continue 'dispatch;
	}
	// 832BC090: 81410424  lwz r10, 0x424(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1060 as u32) ) } as u64;
	// 832BC094: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 832BC098: 80E10420  lwz r7, 0x420(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1056 as u32) ) } as u64;
	// 832BC09C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 832BC0A0: 7D4607B4  extsw r6, r10
	ctx.r[6].s64 = ctx.r[10].s32 as i64;
	// 832BC0A4: F9010090  std r8, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u64 ) };
	// 832BC0A8: C9810090  lfd f12, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 832BC0AC: 7CE507B4  extsw r5, r7
	ctx.r[5].s64 = ctx.r[7].s32 as i64;
	// 832BC0B0: F8C10098  std r6, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[6].u64 ) };
	// 832BC0B4: C9A10098  lfd f13, 0x98(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 832BC0B8: F92100A0  std r9, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u64 ) };
	// 832BC0BC: 7F8407B4  extsw r4, r28
	ctx.r[4].s64 = ctx.r[28].s32 as i64;
	// 832BC0C0: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 832BC0C4: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 832BC0C8: C96100A8  lfd f11, 0xa8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 832BC0CC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 832BC0D0: FD206E9C  fcfid f9, f13
	ctx.f[9].f64 = (ctx.f[13].s64 as f64);
	// 832BC0D4: C80100A0  lfd f0, 0xa0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 832BC0D8: C9010080  lfd f8, 0x80(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 832BC0DC: FCA0069C  fcfid f5, f0
	ctx.f[5].f64 = (ctx.f[0].s64 as f64);
	// 832BC0E0: FCE0669C  fcfid f7, f12
	ctx.f[7].f64 = (ctx.f[12].s64 as f64);
	// 832BC0E4: FCC0469C  fcfid f6, f8
	ctx.f[6].f64 = (ctx.f[8].s64 as f64);
	// 832BC0E8: FC8A0272  fmul f4, f10, f9
	ctx.f[4].f64 = ctx.f[10].f64 * ctx.f[9].f64;
	// 832BC0EC: FC660172  fmul f3, f6, f5
	ctx.f[3].f64 = ctx.f[6].f64 * ctx.f[5].f64;
	// 832BC0F0: FC4401F2  fmul f2, f4, f7
	ctx.f[2].f64 = ctx.f[4].f64 * ctx.f[7].f64;
	// 832BC0F4: FC221824  fdiv f1, f2, f3
	ctx.f[1].f64 = ctx.f[2].f64 / ctx.f[3].f64;
	// 832BC0F8: FC00081E  fctiwz f0, f1
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 832BC0FC: D8010088  stfd f0, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.f[0].u64 ) };
	// 832BC100: 83A1008C  lwz r29, 0x8c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 832BC104: 7F1DA840  cmplw cr6, r29, r21
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[21].u32, &mut ctx.xer);
	// 832BC108: 40990008  ble cr6, 0x832bc110
	if !ctx.cr[6].gt {
	pc = 0x832BC110; continue 'dispatch;
	}
	// 832BC10C: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	// 832BC110: 7D7AD9D6  mullw r11, r26, r27
	ctx.r[11].s64 = (ctx.r[26].s32 as i64) * (ctx.r[27].s32 as i64);
	// 832BC114: 7D4BE1D6  mullw r10, r11, r28
	ctx.r[10].s64 = (ctx.r[11].s32 as i64) * (ctx.r[28].s32 as i64);
	// 832BC118: 5549F0FE  rlwinm r9, r10, 0x1e, 3, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 832BC11C: 7F194840  cmplw cr6, r25, r9
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BC120: 41990220  bgt cr6, 0x832bc340
	if ctx.cr[6].gt {
	pc = 0x832BC340; continue 'dispatch;
	}
	// 832BC124: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC128: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 832BC12C: 80FF0020  lwz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BC130: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 832BC134: 81520000  lwz r10, 0(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BC138: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 832BC13C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 832BC140: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC144: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832BC148: 4E800421  bctrl
	ctx.lr = 0x832BC14C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BC14C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BC150: 419A01F0  beq cr6, 0x832bc340
	if ctx.cr[6].eq {
	pc = 0x832BC340; continue 'dispatch;
	}
	// 832BC154: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC158: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC15C: 938B0020  stw r28, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 832BC160: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC164: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC168: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 832BC16C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BC170: 409A0008  bne cr6, 0x832bc178
	if !ctx.cr[6].eq {
	pc = 0x832BC178; continue 'dispatch;
	}
	// 832BC174: 926B0034  stw r19, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[19].u32 ) };
	// 832BC178: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC17C: 39590010  addi r10, r25, 0x10
	ctx.r[10].s64 = ctx.r[25].s64 + 16;
	// 832BC180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BC184: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC188: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832BC18C: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC190: 7D1E5A14  add r8, r30, r11
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC194: 80880008  lwz r4, 8(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BC198: 4BFFEA69  bl 0x832bac00
	ctx.lr = 0x832BC19C;
	sub_832BAC00(ctx, base);
	// 832BC19C: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC1A0: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC1A4: 9067000C  stw r3, 0xc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 832BC1A8: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC1AC: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC1B0: 80C3000C  lwz r6, 0xc(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC1B4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 832BC1B8: 409A0014  bne cr6, 0x832bc1cc
	if !ctx.cr[6].eq {
	pc = 0x832BC1CC; continue 'dispatch;
	}
	// 832BC1BC: 81630178  lwz r11, 0x178(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) } as u64;
	// 832BC1C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BC1C4: 4E800421  bctrl
	ctx.lr = 0x832BC1C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BC1C8: 48000178  b 0x832bc340
	pc = 0x832BC340; continue 'dispatch;
	// 832BC1CC: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 832BC1D0: 216B02EE  subfic r11, r11, 0x2ee
	ctx.xer.ca = ctx.r[11].u32 <= 750 as u32;
	ctx.r[11].s64 = (750 as i64) - ctx.r[11].s64;
	// 832BC1D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BC1D8: 40980008  bge cr6, 0x832bc1e0
	if !ctx.cr[6].lt {
	pc = 0x832BC1E0; continue 'dispatch;
	}
	// 832BC1DC: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 832BC1E0: 395BFFF8  addi r10, r27, -8
	ctx.r[10].s64 = ctx.r[27].s64 + -8;
	// 832BC1E4: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 832BC1E8: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 832BC1EC: 7BA70020  clrldi r7, r29, 0x20
	ctx.r[7].u64 = ctx.r[29].u64 & 0x00000000FFFFFFFFu64;
	// 832BC1F0: 5506DFFE  rlwinm r6, r8, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 832BC1F4: 7CA939D2  mulld r5, r9, r7
	ctx.r[5].s64 = ctx.r[9].s64 * ctx.r[7].s64;
	// 832BC1F8: 90C30058  stw r6, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 832BC1FC: 7B440020  clrldi r4, r26, 0x20
	ctx.r[4].u64 = ctx.r[26].u64 & 0x00000000FFFFFFFFu64;
	// 832BC200: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC204: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC208: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC20C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BC210: 7C6A4A14  add r3, r10, r9
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 832BC214: 906B0010  stw r3, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 832BC218: 7D6521D2  mulld r11, r5, r4
	ctx.r[11].s64 = ctx.r[5].s64 * ctx.r[4].s64;
	// 832BC21C: 796A0FA4  sldi r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64.wrapping_shl(1);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 832BC220: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC224: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC228: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC22C: 7D2ABB92  divdu r9, r10, r23
	ctx.r[9].u64 = ctx.r[10].u64 / ctx.r[23].u64;
	// 832BC230: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 832BC234: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC238: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC23C: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC240: 5528003A  rlwinm r8, r9, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 832BC244: 90CB0018  stw r6, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 832BC248: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC24C: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC250: 9105004C  stw r8, 0x4c(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(76 as u32), ctx.r[8].u32 ) };
	// 832BC254: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC258: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC25C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BC260: 808B004C  lwz r4, 0x4c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 832BC264: 7C645050  subf r3, r4, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 832BC268: 2F030010  cmpwi cr6, r3, 0x10
	ctx.cr[6].compare_i32(ctx.r[3].s32, 16, &mut ctx.xer);
	// 832BC26C: 4098000C  bge cr6, 0x832bc278
	if !ctx.cr[6].lt {
	pc = 0x832BC278; continue 'dispatch;
	}
	// 832BC270: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 832BC274: 914B004C  stw r10, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 832BC278: 817F011C  lwz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 832BC27C: 815F02A8  lwz r10, 0x2a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 832BC280: 7D38582E  lwzx r9, r24, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 832BC284: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BC288: 7D68502E  lwzx r11, r8, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 832BC28C: 55670000  rlwinm r7, r11, 0, 0, 0
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BC290: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 832BC294: 409A0014  bne cr6, 0x832bc2a8
	if !ctx.cr[6].eq {
	pc = 0x832BC2A8; continue 'dispatch;
	}
	// 832BC298: 556A00C6  rlwinm r10, r11, 0, 3, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BC29C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 832BC2A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BC2A4: 409A0008  bne cr6, 0x832bc2ac
	if !ctx.cr[6].eq {
	pc = 0x832BC2AC; continue 'dispatch;
	}
	// 832BC2A8: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 832BC2AC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 832BC2B0: 5563043E  clrlwi r3, r11, 0x10
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 832BC2B4: 480038F5  bl 0x832bfba8
	ctx.lr = 0x832BC2B8;
	sub_832BFBA8(ctx, base);
	// 832BC2B8: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC2BC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC2C0: 906B0014  stw r3, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 832BC2C4: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC2C8: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC2CC: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BC2D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BC2D4: 409A001C  bne cr6, 0x832bc2f0
	if !ctx.cr[6].eq {
	pc = 0x832BC2F0; continue 'dispatch;
	}
	// 832BC2D8: 81630178  lwz r11, 0x178(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) } as u64;
	// 832BC2DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BC2E0: 4E800421  bctrl
	ctx.lr = 0x832BC2E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BC2E4: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC2E8: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC2EC: 922A000C  stw r17, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[17].u32 ) };
	// 832BC2F0: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC2F4: 81520004  lwz r10, 4(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BC2F8: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC2FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832BC300: 91520004  stw r10, 4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 832BC304: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BC308: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 832BC30C: 392A0080  addi r9, r10, 0x80
	ctx.r[9].s64 = ctx.r[10].s64 + 128;
	// 832BC310: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 832BC314: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BC318: 815F0118  lwz r10, 0x118(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC31C: 7CBE5214  add r5, r30, r10
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 832BC320: 817F02F0  lwz r11, 0x2f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(752 as u32) ) } as u64;
	// 832BC324: 811F02F4  lwz r8, 0x2f4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(756 as u32) ) } as u64;
	// 832BC328: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BC32C: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832BC330: 7C8B4A14  add r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 832BC334: 7C643B96  divwu r3, r4, r7
	ctx.r[3].u32 = ctx.r[4].u32 / ctx.r[7].u32;
	// 832BC338: 7D633050  subf r11, r3, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[3].s64;
	// 832BC33C: 91650044  stw r11, 0x44(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 832BC340: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC344: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC348: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 832BC34C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BC350: 409A0008  bne cr6, 0x832bc358
	if !ctx.cr[6].eq {
	pc = 0x832BC358; continue 'dispatch;
	}
	// 832BC354: 928B0040  stw r20, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[20].u32 ) };
	// 832BC358: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC35C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BC360: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC364: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BC368: 409A002C  bne cr6, 0x832bc394
	if !ctx.cr[6].eq {
	pc = 0x832BC394; continue 'dispatch;
	}
	// 832BC36C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BC370: 815F011C  lwz r10, 0x11c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 832BC374: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832BC378: 7C785214  add r3, r24, r10
	ctx.r[3].u64 = ctx.r[24].u64 + ctx.r[10].u64;
	// 832BC37C: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 832BC380: 7D765850  subf r11, r22, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[22].s64;
	// 832BC384: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 832BC388: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BC38C: 4B9ED0F5  bl 0x82ca9480
	ctx.lr = 0x832BC390;
	sub_82CA9480(ctx, base);
	// 832BC390: 48000010  b 0x832bc3a0
	pc = 0x832BC3A0; continue 'dispatch;
	// 832BC394: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 832BC398: 3BDE0184  addi r30, r30, 0x184
	ctx.r[30].s64 = ctx.r[30].s64 + 388;
	// 832BC39C: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 832BC3A0: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BC3A4: 7F165840  cmplw cr6, r22, r11
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BC3A8: 4198FC44  blt cr6, 0x832bbfec
	if ctx.cr[6].lt {
	pc = 0x832BBFEC; continue 'dispatch;
	}
	// 832BC3AC: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BC3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC3B4: 419A00B8  beq cr6, 0x832bc46c
	if ctx.cr[6].eq {
	pc = 0x832BC46C; continue 'dispatch;
	}
	// 832BC3B8: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC3BC: 921F00F8  stw r16, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[16].u32 ) };
	// 832BC3C0: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BC3C4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BC3C8: 409A00A4  bne cr6, 0x832bc46c
	if !ctx.cr[6].eq {
	pc = 0x832BC46C; continue 'dispatch;
	}
	// 832BC3CC: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC3D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC3D4: 409A004C  bne cr6, 0x832bc420
	if !ctx.cr[6].eq {
	pc = 0x832BC420; continue 'dispatch;
	}
	// 832BC3D8: 3860FFF3  li r3, -0xd
	ctx.r[3].s64 = -13;
	// 832BC3DC: 48002875  bl 0x832bec50
	ctx.lr = 0x832BC3E0;
	sub_832BEC50(ctx, base);
	// 832BC3E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BC3E4: 9172000C  stw r11, 0xc(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 832BC3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC3EC: 419A0080  beq cr6, 0x832bc46c
	if ctx.cr[6].eq {
	pc = 0x832BC46C; continue 'dispatch;
	}
	// 832BC3F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BC3F4: 920B0000  stw r16, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[16].u32 ) };
	// 832BC3F8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BC3FC: 409A0010  bne cr6, 0x832bc40c
	if !ctx.cr[6].eq {
	pc = 0x832BC40C; continue 'dispatch;
	}
	// 832BC400: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC404: 4BA0BA65  bl 0x82cc7e68
	ctx.lr = 0x832BC408;
	sub_82CC7E68(ctx, base);
	// 832BC408: 4800000C  b 0x832bc414
	pc = 0x832BC414; continue 'dispatch;
	// 832BC40C: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BC410: 4BD4F5B1  bl 0x8300b9c0
	ctx.lr = 0x832BC414;
	sub_8300B9C0(ctx, base);
	// 832BC414: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC41C: 419A0050  beq cr6, 0x832bc46c
	if ctx.cr[6].eq {
	pc = 0x832BC46C; continue 'dispatch;
	}
	// 832BC420: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 832BC424: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 832BC428: 390AB378  addi r8, r10, -0x4c88
	ctx.r[8].s64 = ctx.r[10].s64 + -19592;
	// 832BC42C: 38E9B390  addi r7, r9, -0x4c70
	ctx.r[7].s64 = ctx.r[9].s64 + -19568;
	// 832BC430: 911F0364  stw r8, 0x364(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(868 as u32), ctx.r[8].u32 ) };
	// 832BC434: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BC438: 90FF0368  stw r7, 0x368(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(872 as u32), ctx.r[7].u32 ) };
	// 832BC43C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BC440: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BC444: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 832BC448: 3BDF0354  addi r30, r31, 0x354
	ctx.r[30].s64 = ctx.r[31].s64 + 852;
	// 832BC44C: 4BD4F4ED  bl 0x8300b938
	ctx.lr = 0x832BC450;
	sub_8300B938(ctx, base);
	// 832BC450: 907F0358  stw r3, 0x358(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(856 as u32), ctx.r[3].u32 ) };
	// 832BC454: 80DD0018  lwz r6, 0x18(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BC458: 90DF0354  stw r6, 0x354(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(852 as u32), ctx.r[6].u32 ) };
	// 832BC45C: 93DD0018  stw r30, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 832BC460: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BC464: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 832BC468: 90BD0020  stw r5, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[5].u32 ) };
	// 832BC46C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BC470: 556A0108  rlwinm r10, r11, 0, 4, 4
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BC474: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BC478: 409A007C  bne cr6, 0x832bc4f4
	if !ctx.cr[6].eq {
	pc = 0x832BC4F4; continue 'dispatch;
	}
	// 832BC47C: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 832BC480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC484: 409A0070  bne cr6, 0x832bc4f4
	if !ctx.cr[6].eq {
	pc = 0x832BC4F4; continue 'dispatch;
	}
	// 832BC488: 80720008  lwz r3, 8(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BC48C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BC490: 409A004C  bne cr6, 0x832bc4dc
	if !ctx.cr[6].eq {
	pc = 0x832BC4DC; continue 'dispatch;
	}
	// 832BC494: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 832BC498: 480027B9  bl 0x832bec50
	ctx.lr = 0x832BC49C;
	sub_832BEC50(ctx, base);
	// 832BC49C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BC4A0: 91720008  stw r11, 8(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 832BC4A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC4A8: 419A004C  beq cr6, 0x832bc4f4
	if ctx.cr[6].eq {
	pc = 0x832BC4F4; continue 'dispatch;
	}
	// 832BC4AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BC4B0: 920B0000  stw r16, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[16].u32 ) };
	// 832BC4B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BC4B8: 409A0010  bne cr6, 0x832bc4c8
	if !ctx.cr[6].eq {
	pc = 0x832BC4C8; continue 'dispatch;
	}
	// 832BC4BC: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC4C0: 4BA0B9A9  bl 0x82cc7e68
	ctx.lr = 0x832BC4C4;
	sub_82CC7E68(ctx, base);
	// 832BC4C4: 4800000C  b 0x832bc4d0
	pc = 0x832BC4D0; continue 'dispatch;
	// 832BC4C8: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BC4CC: 4BD4F4F5  bl 0x8300b9c0
	ctx.lr = 0x832BC4D0;
	sub_8300B9C0(ctx, base);
	// 832BC4D0: 80720008  lwz r3, 8(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BC4D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BC4D8: 419A001C  beq cr6, 0x832bc4f4
	if ctx.cr[6].eq {
	pc = 0x832BC4F4; continue 'dispatch;
	}
	// 832BC4DC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 832BC4E0: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 832BC4E4: 38CBB288  addi r6, r11, -0x4d78
	ctx.r[6].s64 = ctx.r[11].s64 + -19832;
	// 832BC4E8: 38AAB230  addi r5, r10, -0x4dd0
	ctx.r[5].s64 = ctx.r[10].s64 + -19920;
	// 832BC4EC: 389F0254  addi r4, r31, 0x254
	ctx.r[4].s64 = ctx.r[31].s64 + 596;
	// 832BC4F0: 48002899  bl 0x832bed88
	ctx.lr = 0x832BC4F4;
	sub_832BED88(ctx, base);
	// 832BC4F4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 832BC4F8: 815F0148  lwz r10, 0x148(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 832BC4FC: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 832BC500: 3D00832C  lis r8, -0x7cd4
	ctx.r[8].s64 = -2094268416;
	// 832BC504: 3CE0832C  lis r7, -0x7cd4
	ctx.r[7].s64 = -2094268416;
	// 832BC508: 38CBB350  addi r6, r11, -0x4cb0
	ctx.r[6].s64 = ctx.r[11].s64 + -19632;
	// 832BC50C: 38A9B2D8  addi r5, r9, -0x4d28
	ctx.r[5].s64 = ctx.r[9].s64 + -19752;
	// 832BC510: 3888B2F8  addi r4, r8, -0x4d08
	ctx.r[4].s64 = ctx.r[8].s64 + -19720;
	// 832BC514: 90DF024C  stw r6, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[6].u32 ) };
	// 832BC518: 3867B370  addi r3, r7, -0x4c90
	ctx.r[3].s64 = ctx.r[7].s64 + -19600;
	// 832BC51C: 90BF0244  stw r5, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[5].u32 ) };
	// 832BC520: 909F0248  stw r4, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[4].u32 ) };
	// 832BC524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BC528: 907F0250  stw r3, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[3].u32 ) };
	// 832BC52C: 409A002C  bne cr6, 0x832bc558
	if !ctx.cr[6].eq {
	pc = 0x832BC558; continue 'dispatch;
	}
	// 832BC530: 55EB0294  rlwinm r11, r15, 0, 0xa, 0xa
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BC534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC538: 409A0020  bne cr6, 0x832bc558
	if !ctx.cr[6].eq {
	pc = 0x832BC558; continue 'dispatch;
	}
	// 832BC53C: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 832BC540: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 832BC544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BC548: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BC54C: 4E800421  bctrl
	ctx.lr = 0x832BC550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BC550: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BC554: 409AFFEC  bne cr6, 0x832bc540
	if !ctx.cr[6].eq {
	pc = 0x832BC540; continue 'dispatch;
	}
	// 832BC558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BC55C: 38210560  addi r1, r1, 0x560
	ctx.r[1].s64 = ctx.r[1].s64 + 1376;
	// 832BC560: 4B9ECEC4  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
	// 832BC564: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832BC568: 386BFE5C  addi r3, r11, -0x1a4
	ctx.r[3].s64 = ctx.r[11].s64 + -420;
	// 832BC56C: 4BFFE745  bl 0x832bacb0
	ctx.lr = 0x832BC570;
	sub_832BACB0(ctx, base);
	// 832BC570: 55EB014A  rlwinm r11, r15, 0, 5, 5
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 832BC574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC578: 409A0014  bne cr6, 0x832bc58c
	if !ctx.cr[6].eq {
	pc = 0x832BC58C; continue 'dispatch;
	}
	// 832BC57C: 81610294  lwz r11, 0x294(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(660 as u32) ) } as u64;
	// 832BC580: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 832BC584: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BC588: 4E800421  bctrl
	ctx.lr = 0x832BC58C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BC58C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BC590: 38210560  addi r1, r1, 0x560
	ctx.r[1].s64 = ctx.r[1].s64 + 1376;
	// 832BC594: 4B9ECE90  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BC598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BC598 size=296
    let mut pc: u32 = 0x832BC598;
    'dispatch: loop {
        match pc {
            0x832BC598 => {
    //   block [0x832BC598..0x832BC6C0)
	// 832BC598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BC59C: 4B9ECE71  bl 0x82ca940c
	ctx.lr = 0x832BC5A0;
	sub_82CA93D0(ctx, base);
	// 832BC5A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BC5A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BC5A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 832BC5AC: 817F02C0  lwz r11, 0x2c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(704 as u32) ) } as u64;
	// 832BC5B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC5B4: 409A001C  bne cr6, 0x832bc5d0
	if !ctx.cr[6].eq {
	pc = 0x832BC5D0; continue 'dispatch;
	}
	// 832BC5B8: 48004501  bl 0x832c0ab8
	ctx.lr = 0x832BC5BC;
	sub_832C0AB8(ctx, base);
	// 832BC5BC: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 832BC5C0: 907F02C0  stw r3, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[3].u32 ) };
	// 832BC5C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832BC5C8: 93DF0344  stw r30, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[30].u32 ) };
	// 832BC5CC: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 832BC5D0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BC5D4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 832BC5D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC5DC: 419A007C  beq cr6, 0x832bc658
	if ctx.cr[6].eq {
	pc = 0x832BC658; continue 'dispatch;
	}
	// 832BC5E0: 480044D9  bl 0x832c0ab8
	ctx.lr = 0x832BC5E4;
	sub_832C0AB8(ctx, base);
	// 832BC5E4: 817F02C4  lwz r11, 0x2c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(708 as u32) ) } as u64;
	// 832BC5E8: 815F02B4  lwz r10, 0x2b4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 832BC5EC: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BC5F0: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832BC5F4: 80DF0118  lwz r6, 0x118(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BC5F8: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BC5FC: 79050020  clrldi r5, r8, 0x20
	ctx.r[5].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 832BC600: 809F02C0  lwz r4, 0x2c0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(704 as u32) ) } as u64;
	// 832BC604: 7D6549D2  mulld r11, r5, r9
	ctx.r[11].s64 = ctx.r[5].s64 * ctx.r[9].s64;
	// 832BC608: 81260040  lwz r9, 0x40(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 832BC60C: 1D0B03E8  mulli r8, r11, 0x3e8
	ctx.r[8].s64 = ctx.r[11].s64 * 1000;
	// 832BC610: 7CE83B92  divdu r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 / ctx.r[7].u64;
	// 832BC614: 54E6003E  slwi r6, r7, 0
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BC618: 7CA649D2  mulld r5, r6, r9
	ctx.r[5].s64 = ctx.r[6].s64 * ctx.r[9].s64;
	// 832BC61C: 78AB8402  rldicl r11, r5, 0x30, 0x10
	ctx.r[11].u64 = ctx.r[5].u64 & 0x000000000000FFFFu64;
	// 832BC620: 5569003E  slwi r9, r11, 0
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BC624: 7D091850  subf r8, r9, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[9].s64;
	// 832BC628: 7D644051  subf. r11, r4, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BC62C: 4180002C  blt 0x832bc658
	if ctx.cr[0].lt {
	pc = 0x832BC658; continue 'dispatch;
	}
	// 832BC630: 813F02C8  lwz r9, 0x2c8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 832BC634: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 832BC638: 40990020  ble cr6, 0x832bc658
	if !ctx.cr[6].gt {
	pc = 0x832BC658; continue 'dispatch;
	}
	// 832BC63C: 813F0114  lwz r9, 0x114(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BC640: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BC644: 409A0024  bne cr6, 0x832bc668
	if !ctx.cr[6].eq {
	pc = 0x832BC668; continue 'dispatch;
	}
	// 832BC648: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 832BC64C: 907F02C0  stw r3, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[3].u32 ) };
	// 832BC650: 93DF0344  stw r30, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[30].u32 ) };
	// 832BC654: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 832BC658: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BC65C: 93BF0334  stw r29, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[29].u32 ) };
	// 832BC660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BC664: 4B9ECDF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 832BC668: 2F0B02D5  cmpwi cr6, r11, 0x2d5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 725, &mut ctx.xer);
	// 832BC66C: 40990008  ble cr6, 0x832bc674
	if !ctx.cr[6].gt {
	pc = 0x832BC674; continue 'dispatch;
	}
	// 832BC670: 93BF0338  stw r29, 0x338(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(824 as u32), ctx.r[29].u32 ) };
	// 832BC674: 817F0340  lwz r11, 0x340(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) } as u64;
	// 832BC678: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 832BC67C: 41980018  blt cr6, 0x832bc694
	if ctx.cr[6].lt {
	pc = 0x832BC694; continue 'dispatch;
	}
	// 832BC680: 93DF0340  stw r30, 0x340(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(832 as u32), ctx.r[30].u32 ) };
	// 832BC684: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BC688: 93BF0334  stw r29, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[29].u32 ) };
	// 832BC68C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BC690: 4B9ECDCC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 832BC694: 815F033C  lwz r10, 0x33c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) } as u64;
	// 832BC698: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832BC69C: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 832BC6A0: 93BF0110  stw r29, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[29].u32 ) };
	// 832BC6A4: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 832BC6A8: 917F0340  stw r11, 0x340(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(832 as u32), ctx.r[11].u32 ) };
	// 832BC6AC: 913F0334  stw r9, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[9].u32 ) };
	// 832BC6B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BC6B4: 911F033C  stw r8, 0x33c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(828 as u32), ctx.r[8].u32 ) };
	// 832BC6B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BC6BC: 4B9ECDA0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BC6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BC6C0 size=300
    let mut pc: u32 = 0x832BC6C0;
    'dispatch: loop {
        match pc {
            0x832BC6C0 => {
    //   block [0x832BC6C0..0x832BC7EC)
	// 832BC6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BC6C4: 4B9ECD49  bl 0x82ca940c
	ctx.lr = 0x832BC6C8;
	sub_82CA93D0(ctx, base);
	// 832BC6C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BC6CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BC6D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BC6D4: 409A0010  bne cr6, 0x832bc6e4
	if !ctx.cr[6].eq {
	pc = 0x832BC6E4; continue 'dispatch;
	}
	// 832BC6D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BC6DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BC6E0: 4B9ECD7C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 832BC6E4: 817F0320  lwz r11, 0x320(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(800 as u32) ) } as u64;
	// 832BC6E8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC6EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BC6F0: 419AFFE8  beq cr6, 0x832bc6d8
	if ctx.cr[6].eq {
	pc = 0x832BC6D8; continue 'dispatch;
	}
	// 832BC6F4: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 832BC6F8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 832BC6FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC700: 419A0008  beq cr6, 0x832bc708
	if ctx.cr[6].eq {
	pc = 0x832BC708; continue 'dispatch;
	}
	// 832BC704: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 832BC708: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BC70C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC710: 409AFFC8  bne cr6, 0x832bc6d8
	if !ctx.cr[6].eq {
	pc = 0x832BC6D8; continue 'dispatch;
	}
	// 832BC714: 817F02BC  lwz r11, 0x2bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(700 as u32) ) } as u64;
	// 832BC718: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 832BC71C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC720: 419A0020  beq cr6, 0x832bc740
	if ctx.cr[6].eq {
	pc = 0x832BC740; continue 'dispatch;
	}
	// 832BC724: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 832BC728: 419A0018  beq cr6, 0x832bc740
	if ctx.cr[6].eq {
	pc = 0x832BC740; continue 'dispatch;
	}
	// 832BC72C: 815F02E8  lwz r10, 0x2e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 832BC730: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 832BC734: 93DF02BC  stw r30, 0x2bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(700 as u32), ctx.r[30].u32 ) };
	// 832BC738: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BC73C: 917F02E8  stw r11, 0x2e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(744 as u32), ctx.r[11].u32 ) };
	// 832BC740: 817F032C  lwz r11, 0x32c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(812 as u32) ) } as u64;
	// 832BC744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC748: 419A0034  beq cr6, 0x832bc77c
	if ctx.cr[6].eq {
	pc = 0x832BC77C; continue 'dispatch;
	}
	// 832BC74C: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 832BC750: 93DF032C  stw r30, 0x32c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(812 as u32), ctx.r[30].u32 ) };
	// 832BC754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC758: 419A001C  beq cr6, 0x832bc774
	if ctx.cr[6].eq {
	pc = 0x832BC774; continue 'dispatch;
	}
	// 832BC75C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BC760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BC764: 4800136D  bl 0x832bdad0
	ctx.lr = 0x832BC768;
	sub_832BDAD0(ctx, base);
	// 832BC768: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BC76C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BC770: 48001361  bl 0x832bdad0
	ctx.lr = 0x832BC774;
	sub_832BDAD0(ctx, base);
	// 832BC774: 93DF02C0  stw r30, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[30].u32 ) };
	// 832BC778: 93DF0344  stw r30, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[30].u32 ) };
	// 832BC77C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 832BC780: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BC784: 419A000C  beq cr6, 0x832bc790
	if ctx.cr[6].eq {
	pc = 0x832BC790; continue 'dispatch;
	}
	// 832BC788: 93DF02C0  stw r30, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[30].u32 ) };
	// 832BC78C: 93DF0344  stw r30, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[30].u32 ) };
	// 832BC790: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 832BC794: 93DF0334  stw r30, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[30].u32 ) };
	// 832BC798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC79C: 93BF017C  stw r29, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[29].u32 ) };
	// 832BC7A0: 419A0034  beq cr6, 0x832bc7d4
	if ctx.cr[6].eq {
	pc = 0x832BC7D4; continue 'dispatch;
	}
	// 832BC7A4: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BC7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC7AC: 419A0028  beq cr6, 0x832bc7d4
	if ctx.cr[6].eq {
	pc = 0x832BC7D4; continue 'dispatch;
	}
	// 832BC7B0: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 832BC7B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC7B8: 409A001C  bne cr6, 0x832bc7d4
	if !ctx.cr[6].eq {
	pc = 0x832BC7D4; continue 'dispatch;
	}
	// 832BC7BC: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 832BC7C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BC7C4: 419A0010  beq cr6, 0x832bc7d4
	if ctx.cr[6].eq {
	pc = 0x832BC7D4; continue 'dispatch;
	}
	// 832BC7C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BC7CC: 80BF00C8  lwz r5, 0xc8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 832BC7D0: 4B9ED1E1  bl 0x82ca99b0
	ctx.lr = 0x832BC7D4;
	sub_82CA99B0(ctx, base);
	// 832BC7D4: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 832BC7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BC7DC: 93DF0144  stw r30, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[30].u32 ) };
	// 832BC7E0: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 832BC7E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BC7E8: 4B9ECC74  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BC7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BC7F0 size=492
    let mut pc: u32 = 0x832BC7F0;
    'dispatch: loop {
        match pc {
            0x832BC7F0 => {
    //   block [0x832BC7F0..0x832BC9DC)
	// 832BC7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BC7F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BC7F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BC7FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BC800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BC804: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BC808: 813F02FC  lwz r9, 0x2fc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) } as u64;
	// 832BC80C: 3569FFFF  addic. r11, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BC810: 917F02FC  stw r11, 0x2fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(764 as u32), ctx.r[11].u32 ) };
	// 832BC814: 40800010  bge 0x832bc824
	if !ctx.cr[0].lt {
	pc = 0x832BC824; continue 'dispatch;
	}
	// 832BC818: 817F02F8  lwz r11, 0x2f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(760 as u32) ) } as u64;
	// 832BC81C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832BC820: 917F02FC  stw r11, 0x2fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(764 as u32), ctx.r[11].u32 ) };
	// 832BC824: 817F0324  lwz r11, 0x324(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(804 as u32) ) } as u64;
	// 832BC828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC82C: 419A0048  beq cr6, 0x832bc874
	if ctx.cr[6].eq {
	pc = 0x832BC874; continue 'dispatch;
	}
	// 832BC830: 815F02CC  lwz r10, 0x2cc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) } as u64;
	// 832BC834: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 832BC838: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BC83C: 40990020  ble cr6, 0x832bc85c
	if !ctx.cr[6].gt {
	pc = 0x832BC85C; continue 'dispatch;
	}
	// 832BC840: 811F02D0  lwz r8, 0x2d0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(720 as u32) ) } as u64;
	// 832BC844: 80FF0320  lwz r7, 0x320(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(800 as u32) ) } as u64;
	// 832BC848: 915F02D4  stw r10, 0x2d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(724 as u32), ctx.r[10].u32 ) };
	// 832BC84C: 917F02CC  stw r11, 0x2cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(716 as u32), ctx.r[11].u32 ) };
	// 832BC850: 911F02D8  stw r8, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[8].u32 ) };
	// 832BC854: 90FF02D0  stw r7, 0x2d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(720 as u32), ctx.r[7].u32 ) };
	// 832BC858: 4800001C  b 0x832bc874
	pc = 0x832BC874; continue 'dispatch;
	// 832BC85C: 815F02D4  lwz r10, 0x2d4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(724 as u32) ) } as u64;
	// 832BC860: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BC864: 40990010  ble cr6, 0x832bc874
	if !ctx.cr[6].gt {
	pc = 0x832BC874; continue 'dispatch;
	}
	// 832BC868: 815F0320  lwz r10, 0x320(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(800 as u32) ) } as u64;
	// 832BC86C: 917F02D4  stw r11, 0x2d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(724 as u32), ctx.r[11].u32 ) };
	// 832BC870: 915F02D8  stw r10, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[10].u32 ) };
	// 832BC874: 817F02FC  lwz r11, 0x2fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) } as u64;
	// 832BC878: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 832BC87C: 815F0300  lwz r10, 0x300(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) } as u64;
	// 832BC880: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BC884: 909F0324  stw r4, 0x324(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(804 as u32), ctx.r[4].u32 ) };
	// 832BC888: 7C88512E  stwx r4, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[4].u32) };
	// 832BC88C: 80FF0308  lwz r7, 0x308(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(776 as u32) ) } as u64;
	// 832BC890: 80DF02E0  lwz r6, 0x2e0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) } as u64;
	// 832BC894: 80BF02FC  lwz r5, 0x2fc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) } as u64;
	// 832BC898: 54A3103A  slwi r3, r5, 2
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 832BC89C: 7CC7192E  stwx r6, r7, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[3].u32), ctx.r[6].u32) };
	// 832BC8A0: 817F0304  lwz r11, 0x304(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(772 as u32) ) } as u64;
	// 832BC8A4: 815F02E4  lwz r10, 0x2e4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) } as u64;
	// 832BC8A8: 811F02FC  lwz r8, 0x2fc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) } as u64;
	// 832BC8AC: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832BC8B0: 7D4B392E  stwx r10, r11, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u32) };
	// 832BC8B4: 80DF030C  lwz r6, 0x30c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(780 as u32) ) } as u64;
	// 832BC8B8: 80BF02E8  lwz r5, 0x2e8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 832BC8BC: 807F02FC  lwz r3, 0x2fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) } as u64;
	// 832BC8C0: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BC8C4: 7CA6592E  stwx r5, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 832BC8C8: 815F0184  lwz r10, 0x184(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 832BC8CC: 811F0310  lwz r8, 0x310(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(784 as u32) ) } as u64;
	// 832BC8D0: 80FF02FC  lwz r7, 0x2fc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) } as u64;
	// 832BC8D4: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BC8D8: 7D48312E  stwx r10, r8, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32), ctx.r[10].u32) };
	// 832BC8DC: 80BF0188  lwz r5, 0x188(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 832BC8E0: 807F0314  lwz r3, 0x314(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(788 as u32) ) } as u64;
	// 832BC8E4: 817F02FC  lwz r11, 0x2fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) } as u64;
	// 832BC8E8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BC8EC: 7CA3512E  stwx r5, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 832BC8F0: 811F0318  lwz r8, 0x318(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(792 as u32) ) } as u64;
	// 832BC8F4: 80FF018C  lwz r7, 0x18c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 832BC8F8: 80DF02FC  lwz r6, 0x2fc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) } as u64;
	// 832BC8FC: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BC900: 7CE8292E  stwx r7, r8, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32), ctx.r[7].u32) };
	// 832BC904: 807F02B8  lwz r3, 0x2b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(696 as u32) ) } as u64;
	// 832BC908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BC90C: 409A0038  bne cr6, 0x832bc944
	if !ctx.cr[6].eq {
	pc = 0x832BC944; continue 'dispatch;
	}
	// 832BC910: 817F02F4  lwz r11, 0x2f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(756 as u32) ) } as u64;
	// 832BC914: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BC918: 813F02F0  lwz r9, 0x2f0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(752 as u32) ) } as u64;
	// 832BC91C: 1D0B03E8  mulli r8, r11, 0x3e8
	ctx.r[8].s64 = ctx.r[11].s64 * 1000;
	// 832BC920: 80FF0300  lwz r7, 0x300(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) } as u64;
	// 832BC924: 7CC84B92  divdu r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 / ctx.r[9].u64;
	// 832BC928: 54C5003E  slwi r5, r6, 0
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BC92C: 7C652050  subf r3, r5, r4
	ctx.r[3].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 832BC930: 7C6A392E  stwx r3, r10, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32), ctx.r[3].u32) };
	// 832BC934: 93DF018C  stw r30, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[30].u32 ) };
	// 832BC938: 909F02B8  stw r4, 0x2b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(696 as u32), ctx.r[4].u32 ) };
	// 832BC93C: 93DF0188  stw r30, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[30].u32 ) };
	// 832BC940: 48000018  b 0x832bc958
	pc = 0x832BC958; continue 'dispatch;
	// 832BC944: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BC948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC94C: 419A000C  beq cr6, 0x832bc958
	if ctx.cr[6].eq {
	pc = 0x832BC958; continue 'dispatch;
	}
	// 832BC950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BC954: 4BFFE3AD  bl 0x832bad00
	ctx.lr = 0x832BC958;
	sub_832BAD00(ctx, base);
	// 832BC958: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 832BC95C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BC960: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 832BC964: 419A000C  beq cr6, 0x832bc970
	if ctx.cr[6].eq {
	pc = 0x832BC970; continue 'dispatch;
	}
	// 832BC968: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 832BC96C: 917F00B8  stw r11, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 832BC970: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 832BC974: 815F02C0  lwz r10, 0x2c0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(704 as u32) ) } as u64;
	// 832BC978: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 832BC97C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BC980: 913F02B4  stw r9, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[9].u32 ) };
	// 832BC984: 409A001C  bne cr6, 0x832bc9a0
	if !ctx.cr[6].eq {
	pc = 0x832BC9A0; continue 'dispatch;
	}
	// 832BC988: 48004131  bl 0x832c0ab8
	ctx.lr = 0x832BC98C;
	sub_832C0AB8(ctx, base);
	// 832BC98C: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 832BC990: 907F02C0  stw r3, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[3].u32 ) };
	// 832BC994: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832BC998: 93DF0344  stw r30, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[30].u32 ) };
	// 832BC99C: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 832BC9A0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BC9A4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 832BC9A8: 813F0144  lwz r9, 0x144(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 832BC9AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BC9B0: 915F02BC  stw r10, 0x2bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(700 as u32), ctx.r[10].u32 ) };
	// 832BC9B4: 93DF017C  stw r30, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[30].u32 ) };
	// 832BC9B8: 917F0320  stw r11, 0x320(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(800 as u32), ctx.r[11].u32 ) };
	// 832BC9BC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 832BC9C0: 913F0034  stw r9, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 832BC9C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BC9C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BC9CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BC9D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BC9D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BC9D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BC9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BC9E0 size=332
    let mut pc: u32 = 0x832BC9E0;
    'dispatch: loop {
        match pc {
            0x832BC9E0 => {
    //   block [0x832BC9E0..0x832BCB2C)
	// 832BC9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BC9E4: 4B9ECA0D  bl 0x82ca93f0
	ctx.lr = 0x832BC9E8;
	sub_82CA93D0(ctx, base);
	// 832BC9E8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BC9EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 832BC9F0: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 832BC9F4: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 832BC9F8: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 832BC9FC: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 832BCA00: 7F262A14  add r25, r6, r5
	ctx.r[25].u64 = ctx.r[6].u64 + ctx.r[5].u64;
	// 832BCA04: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BCA08: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BCA0C: 419A0118  beq cr6, 0x832bcb24
	if ctx.cr[6].eq {
	pc = 0x832BCB24; continue 'dispatch;
	}
	// 832BCA10: 81430118  lwz r10, 0x118(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BCA14: 1D640184  mulli r11, r4, 0x184
	ctx.r[11].s64 = ctx.r[4].s64 * 388;
	// 832BCA18: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 832BCA1C: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BCA20: 811D0018  lwz r8, 0x18(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BCA24: 831D0014  lwz r24, 0x14(r29)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BCA28: 7F484851  subf. r26, r8, r9
	ctx.r[26].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 832BCA2C: 40800014  bge 0x832bca40
	if !ctx.cr[0].lt {
	pc = 0x832BCA40; continue 'dispatch;
	}
	// 832BCA30: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BCA34: 7F4BD214  add r26, r11, r26
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 832BCA38: 48000008  b 0x832bca40
	pc = 0x832BCA40; continue 'dispatch;
	// 832BCA3C: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 832BCA40: 7F06B840  cmplw cr6, r6, r23
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BCA44: 419900E0  bgt cr6, 0x832bcb24
	if ctx.cr[6].gt {
	pc = 0x832BCB24; continue 'dispatch;
	}
	// 832BCA48: 7F06B040  cmplw cr6, r6, r22
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[22].u32, &mut ctx.xer);
	// 832BCA4C: 419800D8  blt cr6, 0x832bcb24
	if ctx.cr[6].lt {
	pc = 0x832BCB24; continue 'dispatch;
	}
	// 832BCA50: 7F19B840  cmplw cr6, r25, r23
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BCA54: 419900D0  bgt cr6, 0x832bcb24
	if ctx.cr[6].gt {
	pc = 0x832BCB24; continue 'dispatch;
	}
	// 832BCA58: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BCA5C: 7D5A5850  subf r10, r26, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 832BCA60: 555E0036  rlwinm r30, r10, 0, 0, 0x1b
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 832BCA64: 2B1E0010  cmplwi cr6, r30, 0x10
	ctx.cr[6].compare_u32(ctx.r[30].u32, 16 as u32, &mut ctx.xer);
	// 832BCA68: 40990008  ble cr6, 0x832bca70
	if !ctx.cr[6].gt {
	pc = 0x832BCA70; continue 'dispatch;
	}
	// 832BCA6C: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 832BCA70: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 832BCA74: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 832BCA78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832BCA7C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 832BCA80: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 832BCA84: 48003445  bl 0x832bfec8
	ctx.lr = 0x832BCA88;
	sub_832BFEC8(ctx, base);
	// 832BCA88: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BCA8C: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832BCA90: 4099000C  ble cr6, 0x832bca9c
	if !ctx.cr[6].gt {
	pc = 0x832BCA9C; continue 'dispatch;
	}
	// 832BCA94: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 832BCA98: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 832BCA9C: 7F7FD850  subf r27, r31, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	// 832BCAA0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BCAA4: 4099000C  ble cr6, 0x832bcab0
	if !ctx.cr[6].gt {
	pc = 0x832BCAB0; continue 'dispatch;
	}
	// 832BCAA8: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 832BCAAC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 832BCAB0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BCAB4: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 832BCAB8: 7FC35850  subf r30, r3, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 832BCABC: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 832BCAC0: 40980044  bge cr6, 0x832bcb04
	if !ctx.cr[6].lt {
	pc = 0x832BCB04; continue 'dispatch;
	}
	// 832BCAC4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BCAC8: 419A0024  beq cr6, 0x832bcaec
	if ctx.cr[6].eq {
	pc = 0x832BCAEC; continue 'dispatch;
	}
	// 832BCACC: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BCAD0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 832BCAD4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 832BCAD8: 4B9EC9A9  bl 0x82ca9480
	ctx.lr = 0x832BCADC;
	sub_82CA9480(ctx, base);
	// 832BCADC: 7FFEF850  subf r31, r30, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 832BCAE0: 7D7CF214  add r11, r28, r30
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 832BCAE4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 832BCAE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 832BCAEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 832BCAF0: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BCAF4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BCAF8: 4B9EC989  bl 0x82ca9480
	ctx.lr = 0x832BCAFC;
	sub_82CA9480(ctx, base);
	// 832BCAFC: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BCB00: 48000014  b 0x832bcb14
	pc = 0x832BCB14; continue 'dispatch;
	// 832BCB04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 832BCB08: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BCB0C: 4B9EC975  bl 0x82ca9480
	ctx.lr = 0x832BCB10;
	sub_82CA9480(ctx, base);
	// 832BCB10: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BCB14: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 832BCB18: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BCB1C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BCB20: 409AFF1C  bne cr6, 0x832bca3c
	if !ctx.cr[6].eq {
	pc = 0x832BCA3C; continue 'dispatch;
	}
	// 832BCB24: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 832BCB28: 4B9EC918  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BCB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BCB30 size=692
    let mut pc: u32 = 0x832BCB30;
    'dispatch: loop {
        match pc {
            0x832BCB30 => {
    //   block [0x832BCB30..0x832BCDE4)
	// 832BCB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BCB34: 4B9EC8B9  bl 0x82ca93ec
	ctx.lr = 0x832BCB38;
	sub_82CA93D0(ctx, base);
	// 832BCB38: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BCB3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BCB40: 48003F79  bl 0x832c0ab8
	ctx.lr = 0x832BCB44;
	sub_832C0AB8(ctx, base);
	// 832BCB44: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 832BCB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BCB4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 832BCB50: 4BFFFB71  bl 0x832bc6c0
	ctx.lr = 0x832BCB54;
	sub_832BC6C0(ctx, base);
	// 832BCB54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BCB58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BCB5C: 409A000C  bne cr6, 0x832bcb68
	if !ctx.cr[6].eq {
	pc = 0x832BCB68; continue 'dispatch;
	}
	// 832BCB60: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 832BCB64: 4B9EC8D8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
	// 832BCB68: 82FF0100  lwz r23, 0x100(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 832BCB6C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 832BCB70: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 832BCB74: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BCB78: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 832BCB7C: 82BF00BC  lwz r21, 0xbc(r31)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BCB80: 7ECBBA14  add r22, r11, r23
	ctx.r[22].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 832BCB84: 839F011C  lwz r28, 0x11c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 832BCB88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BCB8C: 40990090  ble cr6, 0x832bcc1c
	if !ctx.cr[6].gt {
	pc = 0x832BCC1C; continue 'dispatch;
	}
	// 832BCB90: 7F1EB040  cmplw cr6, r30, r22
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[22].u32, &mut ctx.xer);
	// 832BCB94: 41990088  bgt cr6, 0x832bcc1c
	if ctx.cr[6].gt {
	pc = 0x832BCC1C; continue 'dispatch;
	}
	// 832BCB98: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BCB9C: 41980080  blt cr6, 0x832bcc1c
	if ctx.cr[6].lt {
	pc = 0x832BCC1C; continue 'dispatch;
	}
	// 832BCBA0: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BCBA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BCBA8: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BCBAC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 832BCBB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BCBB4: 40990054  ble cr6, 0x832bcc08
	if !ctx.cr[6].gt {
	pc = 0x832BCC08; continue 'dispatch;
	}
	// 832BCBB8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 832BCBBC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BCBC0: 7F0AC800  cmpw cr6, r10, r25
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[25].s32, &mut ctx.xer);
	// 832BCBC4: 419A001C  beq cr6, 0x832bcbe0
	if ctx.cr[6].eq {
	pc = 0x832BCBE0; continue 'dispatch;
	}
	// 832BCBC8: 815F0114  lwz r10, 0x114(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BCBCC: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 832BCBD0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BCBD4: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 832BCBD8: 4198FFE4  blt cr6, 0x832bcbbc
	if ctx.cr[6].lt {
	pc = 0x832BCBBC; continue 'dispatch;
	}
	// 832BCBDC: 4800002C  b 0x832bcc08
	pc = 0x832BCC08; continue 'dispatch;
	// 832BCBE0: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 832BCBE4: 419A0024  beq cr6, 0x832bcc08
	if ctx.cr[6].eq {
	pc = 0x832BCC08; continue 'dispatch;
	}
	// 832BCBE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 832BCBEC: 419A001C  beq cr6, 0x832bcc08
	if ctx.cr[6].eq {
	pc = 0x832BCC08; continue 'dispatch;
	}
	// 832BCBF0: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 832BCBF4: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 832BCBF8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 832BCBFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 832BCC00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BCC04: 4BFFFDDD  bl 0x832bc9e0
	ctx.lr = 0x832BCC08;
	sub_832BC9E0(ctx, base);
	// 832BCC08: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BCC0C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 832BCC10: 7FDDF214  add r30, r29, r30
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 832BCC14: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 832BCC18: 4198FF78  blt cr6, 0x832bcb90
	if ctx.cr[6].lt {
	pc = 0x832BCB90; continue 'dispatch;
	}
	// 832BCC1C: 4AFA9495  bl 0x822660b0
	ctx.lr = 0x832BCC20;
	sub_822660B0(ctx, base);
	// 832BCC20: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832BCC24: 3B8BC200  addi r28, r11, -0x3e00
	ctx.r[28].s64 = ctx.r[11].s64 + -15872;
	// 832BCC28: 816BC200  lwz r11, -0x3e00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15872 as u32) ) } as u64;
	// 832BCC2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCC30: 409A000C  bne cr6, 0x832bcc3c
	if !ctx.cr[6].eq {
	pc = 0x832BCC3C; continue 'dispatch;
	}
	// 832BCC34: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BCC38: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BCC3C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BCC40: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BCC44: 3F40C000  lis r26, -0x4000
	ctx.r[26].s64 = -1073741824;
	// 832BCC48: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BCC4C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 832BCC50: 4099000C  ble cr6, 0x832bcc5c
	if !ctx.cr[6].gt {
	pc = 0x832BCC5C; continue 'dispatch;
	}
	// 832BCC54: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 832BCC58: 4800000C  b 0x832bcc64
	pc = 0x832BCC64; continue 'dispatch;
	// 832BCC5C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 832BCC60: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832BCC64: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 832BCC68: 7F7BC050  subf r27, r27, r24
	ctx.r[27].s64 = ctx.r[24].s64 - ctx.r[27].s64;
	// 832BCC6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCC70: 419A0100  beq cr6, 0x832bcd70
	if ctx.cr[6].eq {
	pc = 0x832BCD70; continue 'dispatch;
	}
	// 832BCC74: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 832BCC78: 419A00F8  beq cr6, 0x832bcd70
	if ctx.cr[6].eq {
	pc = 0x832BCD70; continue 'dispatch;
	}
	// 832BCC7C: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 832BCC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCC84: 409A00A8  bne cr6, 0x832bcd2c
	if !ctx.cr[6].eq {
	pc = 0x832BCD2C; continue 'dispatch;
	}
	// 832BCC88: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 832BCC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCC90: 409A009C  bne cr6, 0x832bcd2c
	if !ctx.cr[6].eq {
	pc = 0x832BCD2C; continue 'dispatch;
	}
	// 832BCC94: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 832BCC98: 815F0198  lwz r10, 0x198(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 832BCC9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BCCA0: 41980008  blt cr6, 0x832bcca8
	if ctx.cr[6].lt {
	pc = 0x832BCCA8; continue 'dispatch;
	}
	// 832BCCA4: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 832BCCA8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BCCAC: 813F019C  lwz r9, 0x19c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 832BCCB0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BCCB4: 5507F0BE  srwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832BCCB8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 832BCCBC: 40980070  bge cr6, 0x832bcd2c
	if !ctx.cr[6].lt {
	pc = 0x832BCD2C; continue 'dispatch;
	}
	// 832BCCC0: 3BBF0254  addi r29, r31, 0x254
	ctx.r[29].s64 = ctx.r[31].s64 + 596;
	// 832BCCC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 832BCCC8: 419A0020  beq cr6, 0x832bcce8
	if ctx.cr[6].eq {
	pc = 0x832BCCE8; continue 'dispatch;
	}
	// 832BCCCC: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BCCD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BCCD4: 419A0014  beq cr6, 0x832bcce8
	if ctx.cr[6].eq {
	pc = 0x832BCCE8; continue 'dispatch;
	}
	// 832BCCD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BCCDC: 4AED9CED  bl 0x821969c8
	ctx.lr = 0x832BCCE0;
	sub_821969C8(ctx, base);
	// 832BCCE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BCCE4: 409A0030  bne cr6, 0x832bcd14
	if !ctx.cr[6].eq {
	pc = 0x832BCD14; continue 'dispatch;
	}
	// 832BCCE8: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 832BCCEC: 387F0150  addi r3, r31, 0x150
	ctx.r[3].s64 = ctx.r[31].s64 + 336;
	// 832BCCF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BCCF4: 4E800421  bctrl
	ctx.lr = 0x832BCCF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BCCF8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 832BCCFC: 419A0030  beq cr6, 0x832bcd2c
	if ctx.cr[6].eq {
	pc = 0x832BCD2C; continue 'dispatch;
	}
	// 832BCD00: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BCD04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BCD08: 419A0024  beq cr6, 0x832bcd2c
	if ctx.cr[6].eq {
	pc = 0x832BCD2C; continue 'dispatch;
	}
	// 832BCD0C: 4BD4ECB5  bl 0x8300b9c0
	ctx.lr = 0x832BCD10;
	sub_8300B9C0(ctx, base);
	// 832BCD10: 4800001C  b 0x832bcd2c
	pc = 0x832BCD2C; continue 'dispatch;
	// 832BCD14: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BCD18: 556A0108  rlwinm r10, r11, 0, 4, 4
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BCD1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BCD20: 409A000C  bne cr6, 0x832bcd2c
	if !ctx.cr[6].eq {
	pc = 0x832BCD2C; continue 'dispatch;
	}
	// 832BCD24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BCD28: 4BA06159  bl 0x82cc2e80
	ctx.lr = 0x832BCD2C;
	sub_82CC2E80(ctx, base);
	// 832BCD2C: 833F0020  lwz r25, 0x20(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BCD30: 7F1EB040  cmplw cr6, r30, r22
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[22].u32, &mut ctx.xer);
	// 832BCD34: 4199003C  bgt cr6, 0x832bcd70
	if ctx.cr[6].gt {
	pc = 0x832BCD70; continue 'dispatch;
	}
	// 832BCD38: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BCD3C: 41980034  blt cr6, 0x832bcd70
	if ctx.cr[6].lt {
	pc = 0x832BCD70; continue 'dispatch;
	}
	// 832BCD40: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 832BCD44: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 832BCD48: 393F0120  addi r9, r31, 0x120
	ctx.r[9].s64 = ctx.r[31].s64 + 288;
	// 832BCD4C: 80FF010C  lwz r7, 0x10c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 832BCD50: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 832BCD54: 80BF00C4  lwz r5, 0xc4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 832BCD58: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 832BCD5C: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 832BCD60: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 832BCD64: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 832BCD68: 48007C81  bl 0x832c49e8
	ctx.lr = 0x832BCD6C;
	sub_832C49E8(ctx, base);
	// 832BCD6C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 832BCD70: 817F02E4  lwz r11, 0x2e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) } as u64;
	// 832BCD74: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 832BCD78: 917F02E4  stw r11, 0x2e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(740 as u32), ctx.r[11].u32 ) };
	// 832BCD7C: 4AFA9335  bl 0x822660b0
	ctx.lr = 0x832BCD80;
	sub_822660B0(ctx, base);
	// 832BCD80: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BCD84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCD88: 409A000C  bne cr6, 0x832bcd94
	if !ctx.cr[6].eq {
	pc = 0x832BCD94; continue 'dispatch;
	}
	// 832BCD8C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BCD90: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BCD94: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BCD98: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BCD9C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BCDA0: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 832BCDA4: 4199000C  bgt cr6, 0x832bcdb0
	if ctx.cr[6].gt {
	pc = 0x832BCDB0; continue 'dispatch;
	}
	// 832BCDA8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 832BCDAC: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832BCDB0: 817F02E0  lwz r11, 0x2e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) } as u64;
	// 832BCDB4: 813F0144  lwz r9, 0x144(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 832BCDB8: 7D785850  subf r11, r24, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[24].s64;
	// 832BCDBC: 7F194840  cmplw cr6, r25, r9
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BCDC0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BCDC4: 911F02E0  stw r8, 0x2e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(736 as u32), ctx.r[8].u32 ) };
	// 832BCDC8: 40990008  ble cr6, 0x832bcdd0
	if !ctx.cr[6].gt {
	pc = 0x832BCDD0; continue 'dispatch;
	}
	// 832BCDCC: 933F0144  stw r25, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[25].u32 ) };
	// 832BCDD0: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 832BCDD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BCDD8: 4BFFFA19  bl 0x832bc7f0
	ctx.lr = 0x832BCDDC;
	sub_832BC7F0(ctx, base);
	// 832BCDDC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 832BCDE0: 4B9EC65C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BCDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BCDE8 size=560
    let mut pc: u32 = 0x832BCDE8;
    'dispatch: loop {
        match pc {
            0x832BCDE8 => {
    //   block [0x832BCDE8..0x832BD018)
	// 832BCDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BCDEC: 4B9EC5FD  bl 0x82ca93e8
	ctx.lr = 0x832BCDF0;
	sub_82CA93D0(ctx, base);
	// 832BCDF0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BCDF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BCDF8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 832BCDFC: 48003CBD  bl 0x832c0ab8
	ctx.lr = 0x832BCE00;
	sub_832C0AB8(ctx, base);
	// 832BCE00: 831F0100  lwz r24, 0x100(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 832BCE04: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 832BCE08: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 832BCE0C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 832BCE10: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BCE14: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 832BCE18: 829F00BC  lwz r20, 0xbc(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BCE1C: 7EEBC214  add r23, r11, r24
	ctx.r[23].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 832BCE20: 839F011C  lwz r28, 0x11c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 832BCE24: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BCE28: 4099009C  ble cr6, 0x832bcec4
	if !ctx.cr[6].gt {
	pc = 0x832BCEC4; continue 'dispatch;
	}
	// 832BCE2C: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BCE30: 41990094  bgt cr6, 0x832bcec4
	if ctx.cr[6].gt {
	pc = 0x832BCEC4; continue 'dispatch;
	}
	// 832BCE34: 7F1EC040  cmplw cr6, r30, r24
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[24].u32, &mut ctx.xer);
	// 832BCE38: 4198008C  blt cr6, 0x832bcec4
	if ctx.cr[6].lt {
	pc = 0x832BCEC4; continue 'dispatch;
	}
	// 832BCE3C: 56CB07BC  rlwinm r11, r22, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0xFFFFFFFFu64;
	// 832BCE40: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BCE44: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 832BCE48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCE4C: 419A0064  beq cr6, 0x832bceb0
	if ctx.cr[6].eq {
	pc = 0x832BCEB0; continue 'dispatch;
	}
	// 832BCE50: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BCE54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BCE58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BCE5C: 40990054  ble cr6, 0x832bceb0
	if !ctx.cr[6].gt {
	pc = 0x832BCEB0; continue 'dispatch;
	}
	// 832BCE60: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 832BCE64: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BCE68: 7F0AD000  cmpw cr6, r10, r26
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[26].s32, &mut ctx.xer);
	// 832BCE6C: 419A001C  beq cr6, 0x832bce88
	if ctx.cr[6].eq {
	pc = 0x832BCE88; continue 'dispatch;
	}
	// 832BCE70: 815F0114  lwz r10, 0x114(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BCE74: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 832BCE78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BCE7C: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 832BCE80: 4198FFE4  blt cr6, 0x832bce64
	if ctx.cr[6].lt {
	pc = 0x832BCE64; continue 'dispatch;
	}
	// 832BCE84: 4800002C  b 0x832bceb0
	pc = 0x832BCEB0; continue 'dispatch;
	// 832BCE88: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 832BCE8C: 419A0024  beq cr6, 0x832bceb0
	if ctx.cr[6].eq {
	pc = 0x832BCEB0; continue 'dispatch;
	}
	// 832BCE90: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 832BCE94: 419A001C  beq cr6, 0x832bceb0
	if ctx.cr[6].eq {
	pc = 0x832BCEB0; continue 'dispatch;
	}
	// 832BCE98: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 832BCE9C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 832BCEA0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 832BCEA4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 832BCEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BCEAC: 4BFFFB35  bl 0x832bc9e0
	ctx.lr = 0x832BCEB0;
	sub_832BC9E0(ctx, base);
	// 832BCEB0: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BCEB4: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 832BCEB8: 7FDDF214  add r30, r29, r30
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 832BCEBC: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 832BCEC0: 4198FF6C  blt cr6, 0x832bce2c
	if ctx.cr[6].lt {
	pc = 0x832BCE2C; continue 'dispatch;
	}
	// 832BCEC4: 4AFA91ED  bl 0x822660b0
	ctx.lr = 0x832BCEC8;
	sub_822660B0(ctx, base);
	// 832BCEC8: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832BCECC: 3BABC200  addi r29, r11, -0x3e00
	ctx.r[29].s64 = ctx.r[11].s64 + -15872;
	// 832BCED0: 816BC200  lwz r11, -0x3e00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15872 as u32) ) } as u64;
	// 832BCED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCED8: 409A000C  bne cr6, 0x832bcee4
	if !ctx.cr[6].eq {
	pc = 0x832BCEE4; continue 'dispatch;
	}
	// 832BCEDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BCEE0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BCEE4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BCEE8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BCEEC: 3F60C000  lis r27, -0x4000
	ctx.r[27].s64 = -1073741824;
	// 832BCEF0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BCEF4: 7F09D840  cmplw cr6, r9, r27
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832BCEF8: 4099000C  ble cr6, 0x832bcf04
	if !ctx.cr[6].gt {
	pc = 0x832BCF04; continue 'dispatch;
	}
	// 832BCEFC: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 832BCF00: 4800000C  b 0x832bcf0c
	pc = 0x832BCF0C; continue 'dispatch;
	// 832BCF04: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 832BCF08: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832BCF0C: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 832BCF10: 7F95C850  subf r28, r21, r25
	ctx.r[28].s64 = ctx.r[25].s64 - ctx.r[21].s64;
	// 832BCF14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCF18: 419A0094  beq cr6, 0x832bcfac
	if ctx.cr[6].eq {
	pc = 0x832BCFAC; continue 'dispatch;
	}
	// 832BCF1C: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 832BCF20: 419A008C  beq cr6, 0x832bcfac
	if ctx.cr[6].eq {
	pc = 0x832BCFAC; continue 'dispatch;
	}
	// 832BCF24: 835F0020  lwz r26, 0x20(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BCF28: 574B0420  rlwinm r11, r26, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 832BCF2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BCF30: 419A0014  beq cr6, 0x832bcf44
	if ctx.cr[6].eq {
	pc = 0x832BCF44; continue 'dispatch;
	}
	// 832BCF34: 56CB07BC  rlwinm r11, r22, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0xFFFFFFFFu64;
	// 832BCF38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCF3C: 409A0070  bne cr6, 0x832bcfac
	if !ctx.cr[6].eq {
	pc = 0x832BCFAC; continue 'dispatch;
	}
	// 832BCF40: 48000028  b 0x832bcf68
	pc = 0x832BCF68; continue 'dispatch;
	// 832BCF44: 56CB07FE  clrlwi r11, r22, 0x1f
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x00000001u64;
	// 832BCF48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCF4C: 409A0008  bne cr6, 0x832bcf54
	if !ctx.cr[6].eq {
	pc = 0x832BCF54; continue 'dispatch;
	}
	// 832BCF50: 635A0200  ori r26, r26, 0x200
	ctx.r[26].u64 = ctx.r[26].u64 | 512;
	// 832BCF54: 56CB07BC  rlwinm r11, r22, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0xFFFFFFFFu64;
	// 832BCF58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCF5C: 409A000C  bne cr6, 0x832bcf68
	if !ctx.cr[6].eq {
	pc = 0x832BCF68; continue 'dispatch;
	}
	// 832BCF60: 574B0314  rlwinm r11, r26, 0, 0xc, 0xa
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 832BCF64: 657A0002  oris r26, r11, 2
	ctx.r[26].u64 = ctx.r[11].u64 | 131072;
	// 832BCF68: 635A0100  ori r26, r26, 0x100
	ctx.r[26].u64 = ctx.r[26].u64 | 256;
	// 832BCF6C: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BCF70: 4199003C  bgt cr6, 0x832bcfac
	if ctx.cr[6].gt {
	pc = 0x832BCFAC; continue 'dispatch;
	}
	// 832BCF74: 7F1EC040  cmplw cr6, r30, r24
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[24].u32, &mut ctx.xer);
	// 832BCF78: 41980034  blt cr6, 0x832bcfac
	if ctx.cr[6].lt {
	pc = 0x832BCFAC; continue 'dispatch;
	}
	// 832BCF7C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 832BCF80: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 832BCF84: 393F0120  addi r9, r31, 0x120
	ctx.r[9].s64 = ctx.r[31].s64 + 288;
	// 832BCF88: 80FF010C  lwz r7, 0x10c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 832BCF8C: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 832BCF90: 80BF00C4  lwz r5, 0xc4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 832BCF94: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 832BCF98: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 832BCF9C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 832BCFA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 832BCFA4: 48007A45  bl 0x832c49e8
	ctx.lr = 0x832BCFA8;
	sub_832C49E8(ctx, base);
	// 832BCFA8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 832BCFAC: 817F02E4  lwz r11, 0x2e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) } as u64;
	// 832BCFB0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 832BCFB4: 917F02E4  stw r11, 0x2e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(740 as u32), ctx.r[11].u32 ) };
	// 832BCFB8: 4AFA90F9  bl 0x822660b0
	ctx.lr = 0x832BCFBC;
	sub_822660B0(ctx, base);
	// 832BCFBC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BCFC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BCFC4: 409A000C  bne cr6, 0x832bcfd0
	if !ctx.cr[6].eq {
	pc = 0x832BCFD0; continue 'dispatch;
	}
	// 832BCFC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BCFCC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BCFD0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BCFD4: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BCFD8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BCFDC: 7F09D840  cmplw cr6, r9, r27
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832BCFE0: 4199000C  bgt cr6, 0x832bcfec
	if ctx.cr[6].gt {
	pc = 0x832BCFEC; continue 'dispatch;
	}
	// 832BCFE4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 832BCFE8: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832BCFEC: 817F02E0  lwz r11, 0x2e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) } as u64;
	// 832BCFF0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BCFF4: 813F0144  lwz r9, 0x144(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 832BCFF8: 7D795850  subf r11, r25, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[25].s64;
	// 832BCFFC: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BD000: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BD004: 911F02E0  stw r8, 0x2e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(736 as u32), ctx.r[8].u32 ) };
	// 832BD008: 40990008  ble cr6, 0x832bd010
	if !ctx.cr[6].gt {
	pc = 0x832BD010; continue 'dispatch;
	}
	// 832BD00C: 935F0144  stw r26, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[26].u32 ) };
	// 832BD010: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 832BD014: 4B9EC424  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BD018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BD018 size=508
    let mut pc: u32 = 0x832BD018;
    'dispatch: loop {
        match pc {
            0x832BD018 => {
    //   block [0x832BD018..0x832BD214)
	// 832BD018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BD01C: 4B9EC3F1  bl 0x82ca940c
	ctx.lr = 0x832BD020;
	sub_82CA93D0(ctx, base);
	// 832BD020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BD024: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BD028: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832BD02C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BD030: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 832BD034: 419A01D8  beq cr6, 0x832bd20c
	if ctx.cr[6].eq {
	pc = 0x832BD20C; continue 'dispatch;
	}
	// 832BD038: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 832BD03C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BD040: 409A01CC  bne cr6, 0x832bd20c
	if !ctx.cr[6].eq {
	pc = 0x832BD20C; continue 'dispatch;
	}
	// 832BD044: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 832BD048: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BD04C: 409A01C0  bne cr6, 0x832bd20c
	if !ctx.cr[6].eq {
	pc = 0x832BD20C; continue 'dispatch;
	}
	// 832BD050: 817F0334  lwz r11, 0x334(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(820 as u32) ) } as u64;
	// 832BD054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD058: 409A000C  bne cr6, 0x832bd064
	if !ctx.cr[6].eq {
	pc = 0x832BD064; continue 'dispatch;
	}
	// 832BD05C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BD060: 4BFFF539  bl 0x832bc598
	ctx.lr = 0x832BD064;
	sub_832BC598(ctx, base);
	// 832BD064: 817F0338  lwz r11, 0x338(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) } as u64;
	// 832BD068: 93BF0334  stw r29, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[29].u32 ) };
	// 832BD06C: 93BF017C  stw r29, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[29].u32 ) };
	// 832BD070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD074: 419A000C  beq cr6, 0x832bd080
	if ctx.cr[6].eq {
	pc = 0x832BD080; continue 'dispatch;
	}
	// 832BD078: 93BF0338  stw r29, 0x338(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(824 as u32), ctx.r[29].u32 ) };
	// 832BD07C: 48000070  b 0x832bd0ec
	pc = 0x832BD0EC; continue 'dispatch;
	// 832BD080: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD084: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 832BD088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD08C: 40990114  ble cr6, 0x832bd1a0
	if !ctx.cr[6].gt {
	pc = 0x832BD1A0; continue 'dispatch;
	}
	// 832BD090: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 832BD094: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BD098: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BD09C: 812B0054  lwz r9, 0x54(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BD0A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BD0A4: 419A002C  beq cr6, 0x832bd0d0
	if ctx.cr[6].eq {
	pc = 0x832BD0D0; continue 'dispatch;
	}
	// 832BD0A8: 93AB0054  stw r29, 0x54(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 832BD0AC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BD0B0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 832BD0B4: 4099001C  ble cr6, 0x832bd0d0
	if !ctx.cr[6].gt {
	pc = 0x832BD0D0; continue 'dispatch;
	}
	// 832BD0B8: 813F0118  lwz r9, 0x118(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BD0BC: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 832BD0C0: 80E90044  lwz r7, 0x44(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(68 as u32) ) } as u64;
	// 832BD0C4: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 832BD0C8: 41990008  bgt cr6, 0x832bd0d0
	if ctx.cr[6].gt {
	pc = 0x832BD0D0; continue 'dispatch;
	}
	// 832BD0CC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 832BD0D0: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD0D4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 832BD0D8: 394A0184  addi r10, r10, 0x184
	ctx.r[10].s64 = ctx.r[10].s64 + 388;
	// 832BD0DC: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BD0E0: 4198FFB4  blt cr6, 0x832bd094
	if ctx.cr[6].lt {
	pc = 0x832BD094; continue 'dispatch;
	}
	// 832BD0E4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832BD0E8: 419A00B8  beq cr6, 0x832bd1a0
	if ctx.cr[6].eq {
	pc = 0x832BD1A0; continue 'dispatch;
	}
	// 832BD0EC: 817F0330  lwz r11, 0x330(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(816 as u32) ) } as u64;
	// 832BD0F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832BD0F4: 917F0330  stw r11, 0x330(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(816 as u32), ctx.r[11].u32 ) };
	// 832BD0F8: 807F0358  lwz r3, 0x358(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(856 as u32) ) } as u64;
	// 832BD0FC: 809F0258  lwz r4, 0x258(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 832BD100: 48001881  bl 0x832be980
	ctx.lr = 0x832BD104;
	sub_832BE980(ctx, base);
	// 832BD104: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BD108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD10C: 480009C5  bl 0x832bdad0
	ctx.lr = 0x832BD110;
	sub_832BDAD0(ctx, base);
	// 832BD110: 815F0198  lwz r10, 0x198(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 832BD114: 813F019C  lwz r9, 0x19c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 832BD118: 1D0A001D  mulli r8, r10, 0x1d
	ctx.r[8].s64 = ctx.r[10].s64 * 29;
	// 832BD11C: 5507D97E  srwi r7, r8, 5
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(5);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832BD120: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 832BD124: 40980038  bge cr6, 0x832bd15c
	if !ctx.cr[6].lt {
	pc = 0x832BD15C; continue 'dispatch;
	}
	// 832BD128: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 832BD12C: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 832BD130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BD134: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BD138: 4E800421  bctrl
	ctx.lr = 0x832BD13C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD13C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BD140: 419A001C  beq cr6, 0x832bd15c
	if ctx.cr[6].eq {
	pc = 0x832BD15C; continue 'dispatch;
	}
	// 832BD144: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 832BD148: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 832BD14C: 1D2B001D  mulli r9, r11, 0x1d
	ctx.r[9].s64 = ctx.r[11].s64 * 29;
	// 832BD150: 5528D97E  srwi r8, r9, 5
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BD154: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 832BD158: 4198FFD4  blt cr6, 0x832bd12c
	if ctx.cr[6].lt {
	pc = 0x832BD12C; continue 'dispatch;
	}
	// 832BD15C: 93BF02C0  stw r29, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[29].u32 ) };
	// 832BD160: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BD164: 93BF0344  stw r29, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[29].u32 ) };
	// 832BD168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD16C: 48000965  bl 0x832bdad0
	ctx.lr = 0x832BD170;
	sub_832BDAD0(ctx, base);
	// 832BD170: 357F0354  addic. r11, r31, 0x354
	ctx.xer.ca = (ctx.r[31].u32 > (!(852 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 852;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BD174: 41820014  beq 0x832bd188
	if ctx.cr[0].eq {
	pc = 0x832BD188; continue 'dispatch;
	}
	// 832BD178: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BD17C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BD180: 419A0008  beq cr6, 0x832bd188
	if ctx.cr[6].eq {
	pc = 0x832BD188; continue 'dispatch;
	}
	// 832BD184: 4BD4E83D  bl 0x8300b9c0
	ctx.lr = 0x832BD188;
	sub_8300B9C0(ctx, base);
	// 832BD188: 357F0254  addic. r11, r31, 0x254
	ctx.xer.ca = (ctx.r[31].u32 > (!(596 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 596;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BD18C: 41820014  beq 0x832bd1a0
	if ctx.cr[0].eq {
	pc = 0x832BD1A0; continue 'dispatch;
	}
	// 832BD190: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BD194: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BD198: 419A0008  beq cr6, 0x832bd1a0
	if ctx.cr[6].eq {
	pc = 0x832BD1A0; continue 'dispatch;
	}
	// 832BD19C: 4BD4E825  bl 0x8300b9c0
	ctx.lr = 0x832BD1A0;
	sub_8300B9C0(ctx, base);
	// 832BD1A0: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD1A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 832BD1A8: 915F017C  stw r10, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[10].u32 ) };
	// 832BD1AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD1B0: 419A000C  beq cr6, 0x832bd1bc
	if ctx.cr[6].eq {
	pc = 0x832BD1BC; continue 'dispatch;
	}
	// 832BD1B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD1B8: 4BFFDB49  bl 0x832bad00
	ctx.lr = 0x832BD1BC;
	sub_832BAD00(ctx, base);
	// 832BD1BC: 480038FD  bl 0x832c0ab8
	ctx.lr = 0x832BD1C0;
	sub_832C0AB8(ctx, base);
	// 832BD1C0: 817F02BC  lwz r11, 0x2bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(700 as u32) ) } as u64;
	// 832BD1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD1C8: 419A0020  beq cr6, 0x832bd1e8
	if ctx.cr[6].eq {
	pc = 0x832BD1E8; continue 'dispatch;
	}
	// 832BD1CC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 832BD1D0: 419A0018  beq cr6, 0x832bd1e8
	if ctx.cr[6].eq {
	pc = 0x832BD1E8; continue 'dispatch;
	}
	// 832BD1D4: 815F02E8  lwz r10, 0x2e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 832BD1D8: 93BF02BC  stw r29, 0x2bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(700 as u32), ctx.r[29].u32 ) };
	// 832BD1DC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832BD1E0: 7D2B1A14  add r9, r11, r3
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 832BD1E4: 913F02E8  stw r9, 0x2e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(744 as u32), ctx.r[9].u32 ) };
	// 832BD1E8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BD1EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BD1F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BD1F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BD1F8: 40980008  bge cr6, 0x832bd200
	if !ctx.cr[6].lt {
	pc = 0x832BD200; continue 'dispatch;
	}
	// 832BD1FC: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 832BD200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD204: 4BFFDDF5  bl 0x832baff8
	ctx.lr = 0x832BD208;
	sub_832BAFF8(ctx, base);
	// 832BD208: 93BF017C  stw r29, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[29].u32 ) };
	// 832BD20C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BD210: 4B9EC24C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BD218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BD218 size=552
    let mut pc: u32 = 0x832BD218;
    'dispatch: loop {
        match pc {
            0x832BD218 => {
    //   block [0x832BD218..0x832BD440)
	// 832BD218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BD21C: 4B9EC1DD  bl 0x82ca93f8
	ctx.lr = 0x832BD220;
	sub_82CA93D0(ctx, base);
	// 832BD220: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BD224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BD228: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BD22C: 419A020C  beq cr6, 0x832bd438
	if ctx.cr[6].eq {
	pc = 0x832BD438; continue 'dispatch;
	}
	// 832BD230: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 832BD234: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BD238: 409A0200  bne cr6, 0x832bd438
	if !ctx.cr[6].eq {
	pc = 0x832BD438; continue 'dispatch;
	}
	// 832BD23C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 832BD240: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BD244: 409A01F4  bne cr6, 0x832bd438
	if !ctx.cr[6].eq {
	pc = 0x832BD438; continue 'dispatch;
	}
	// 832BD248: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BD24C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 832BD250: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 832BD254: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 832BD258: 933F017C  stw r25, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[25].u32 ) };
	// 832BD25C: 931F0334  stw r24, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[24].u32 ) };
	// 832BD260: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 832BD264: 40980008  bge cr6, 0x832bd26c
	if !ctx.cr[6].lt {
	pc = 0x832BD26C; continue 'dispatch;
	}
	// 832BD268: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 832BD26C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD274: 419A0030  beq cr6, 0x832bd2a4
	if ctx.cr[6].eq {
	pc = 0x832BD2A4; continue 'dispatch;
	}
	// 832BD278: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BD27C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BD280: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BD284: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 832BD288: 7D6A5B96  divwu r11, r10, r11
	ctx.r[11].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 832BD28C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 832BD290: 4198000C  blt cr6, 0x832bd29c
	if ctx.cr[6].lt {
	pc = 0x832BD29C; continue 'dispatch;
	}
	// 832BD294: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 832BD298: 48000010  b 0x832bd2a8
	pc = 0x832BD2A8; continue 'dispatch;
	// 832BD29C: 7FCBE050  subf r30, r11, r28
	ctx.r[30].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 832BD2A0: 48000008  b 0x832bd2a8
	pc = 0x832BD2A8; continue 'dispatch;
	// 832BD2A4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 832BD2A8: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BD2AC: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 832BD2B0: 419A0184  beq cr6, 0x832bd434
	if ctx.cr[6].eq {
	pc = 0x832BD434; continue 'dispatch;
	}
	// 832BD2B4: 815F014C  lwz r10, 0x14c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 832BD2B8: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BD2BC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BD2C0: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 832BD2C4: 552707FE  clrlwi r7, r9, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 832BD2C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 832BD2CC: 419A000C  beq cr6, 0x832bd2d8
	if ctx.cr[6].eq {
	pc = 0x832BD2D8; continue 'dispatch;
	}
	// 832BD2D0: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 832BD2D4: 4800003C  b 0x832bd310
	pc = 0x832BD310; continue 'dispatch;
	// 832BD2D8: 397CFFFE  addi r11, r28, -2
	ctx.r[11].s64 = ctx.r[28].s64 + -2;
	// 832BD2DC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 832BD2E0: 4198002C  blt cr6, 0x832bd30c
	if ctx.cr[6].lt {
	pc = 0x832BD30C; continue 'dispatch;
	}
	// 832BD2E4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BD2E8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 832BD2EC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BD2F0: 552707FE  clrlwi r7, r9, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 832BD2F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 832BD2F8: 409A0014  bne cr6, 0x832bd30c
	if !ctx.cr[6].eq {
	pc = 0x832BD30C; continue 'dispatch;
	}
	// 832BD2FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832BD300: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 832BD304: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 832BD308: 4098FFE4  bge cr6, 0x832bd2ec
	if !ctx.cr[6].lt {
	pc = 0x832BD2EC; continue 'dispatch;
	}
	// 832BD30C: 3B6B0001  addi r27, r11, 1
	ctx.r[27].s64 = ctx.r[11].s64 + 1;
	// 832BD310: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BD314: 40990010  ble cr6, 0x832bd324
	if !ctx.cr[6].gt {
	pc = 0x832BD324; continue 'dispatch;
	}
	// 832BD318: 83BF00FC  lwz r29, 0xfc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 832BD31C: 931F00FC  stw r24, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[24].u32 ) };
	// 832BD320: 4800000C  b 0x832bd32c
	pc = 0x832BD32C; continue 'dispatch;
	// 832BD324: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 832BD328: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 832BD32C: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 832BD330: 4198000C  blt cr6, 0x832bd33c
	if ctx.cr[6].lt {
	pc = 0x832BD33C; continue 'dispatch;
	}
	// 832BD334: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 832BD338: 40990018  ble cr6, 0x832bd350
	if !ctx.cr[6].gt {
	pc = 0x832BD350; continue 'dispatch;
	}
	// 832BD33C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832BD340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD344: 4BFFDCB5  bl 0x832baff8
	ctx.lr = 0x832BD348;
	sub_832BAFF8(ctx, base);
	// 832BD348: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 832BD34C: 419A00E8  beq cr6, 0x832bd434
	if ctx.cr[6].eq {
	pc = 0x832BD434; continue 'dispatch;
	}
	// 832BD350: 3BDF0354  addi r30, r31, 0x354
	ctx.r[30].s64 = ctx.r[31].s64 + 852;
	// 832BD354: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BD358: 419A0018  beq cr6, 0x832bd370
	if ctx.cr[6].eq {
	pc = 0x832BD370; continue 'dispatch;
	}
	// 832BD35C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BD360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BD364: 419A000C  beq cr6, 0x832bd370
	if ctx.cr[6].eq {
	pc = 0x832BD370; continue 'dispatch;
	}
	// 832BD368: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BD36C: 4AED965D  bl 0x821969c8
	ctx.lr = 0x832BD370;
	sub_821969C8(ctx, base);
	// 832BD370: 835F00F8  lwz r26, 0xf8(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 832BD374: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 832BD378: 419A0010  beq cr6, 0x832bd388
	if ctx.cr[6].eq {
	pc = 0x832BD388; continue 'dispatch;
	}
	// 832BD37C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BD380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD384: 4800074D  bl 0x832bdad0
	ctx.lr = 0x832BD388;
	sub_832BDAD0(ctx, base);
	// 832BD388: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BD38C: 815F0320  lwz r10, 0x320(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(800 as u32) ) } as u64;
	// 832BD390: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BD394: 419A0010  beq cr6, 0x832bd3a4
	if ctx.cr[6].eq {
	pc = 0x832BD3A4; continue 'dispatch;
	}
	// 832BD398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD39C: 4BFFF795  bl 0x832bcb30
	ctx.lr = 0x832BD3A0;
	sub_832BCB30(ctx, base);
	// 832BD3A0: 933F0110  stw r25, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[25].u32 ) };
	// 832BD3A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD3A8: 4BFFFC71  bl 0x832bd018
	ctx.lr = 0x832BD3AC;
	sub_832BD018(ctx, base);
	// 832BD3AC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BD3B0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 832BD3B4: 419A0040  beq cr6, 0x832bd3f4
	if ctx.cr[6].eq {
	pc = 0x832BD3F4; continue 'dispatch;
	}
	// 832BD3B8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 832BD3BC: 419A0018  beq cr6, 0x832bd3d4
	if ctx.cr[6].eq {
	pc = 0x832BD3D4; continue 'dispatch;
	}
	// 832BD3C0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BD3C4: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832BD3C8: 409A000C  bne cr6, 0x832bd3d4
	if !ctx.cr[6].eq {
	pc = 0x832BD3D4; continue 'dispatch;
	}
	// 832BD3CC: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 832BD3D0: 933F00FC  stw r25, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[25].u32 ) };
	// 832BD3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD3D8: 4BFFF759  bl 0x832bcb30
	ctx.lr = 0x832BD3DC;
	sub_832BCB30(ctx, base);
	// 832BD3DC: 933F0110  stw r25, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[25].u32 ) };
	// 832BD3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD3E4: 4BFFFC35  bl 0x832bd018
	ctx.lr = 0x832BD3E8;
	sub_832BD018(ctx, base);
	// 832BD3E8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BD3EC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 832BD3F0: 409AFFC8  bne cr6, 0x832bd3b8
	if !ctx.cr[6].eq {
	pc = 0x832BD3B8; continue 'dispatch;
	}
	// 832BD3F4: 931F02C0  stw r24, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[24].u32 ) };
	// 832BD3F8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 832BD3FC: 931F0344  stw r24, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[24].u32 ) };
	// 832BD400: 419A0008  beq cr6, 0x832bd408
	if ctx.cr[6].eq {
	pc = 0x832BD408; continue 'dispatch;
	}
	// 832BD404: 933F00FC  stw r25, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[25].u32 ) };
	// 832BD408: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BD40C: 419A0014  beq cr6, 0x832bd420
	if ctx.cr[6].eq {
	pc = 0x832BD420; continue 'dispatch;
	}
	// 832BD410: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BD414: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BD418: 419A0008  beq cr6, 0x832bd420
	if ctx.cr[6].eq {
	pc = 0x832BD420; continue 'dispatch;
	}
	// 832BD41C: 4BD4E5A5  bl 0x8300b9c0
	ctx.lr = 0x832BD420;
	sub_8300B9C0(ctx, base);
	// 832BD420: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 832BD424: 419A0010  beq cr6, 0x832bd434
	if ctx.cr[6].eq {
	pc = 0x832BD434; continue 'dispatch;
	}
	// 832BD428: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BD42C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD430: 480006A1  bl 0x832bdad0
	ctx.lr = 0x832BD434;
	sub_832BDAD0(ctx, base);
	// 832BD434: 931F017C  stw r24, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[24].u32 ) };
	// 832BD438: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 832BD43C: 4B9EC00C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BD440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BD440 size=720
    let mut pc: u32 = 0x832BD440;
    'dispatch: loop {
        match pc {
            0x832BD440 => {
    //   block [0x832BD440..0x832BD710)
	// 832BD440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BD444: 4B9EBFC9  bl 0x82ca940c
	ctx.lr = 0x832BD448;
	sub_82CA93D0(ctx, base);
	// 832BD448: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BD44C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BD450: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BD454: 419A02B4  beq cr6, 0x832bd708
	if ctx.cr[6].eq {
	pc = 0x832BD708; continue 'dispatch;
	}
	// 832BD458: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BD45C: 48000485  bl 0x832bd8e0
	ctx.lr = 0x832BD460;
	sub_832BD8E0(ctx, base);
	// 832BD460: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832BD464: 3BCBC4A8  addi r30, r11, -0x3b58
	ctx.r[30].s64 = ctx.r[11].s64 + -15192;
	// 832BD468: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BD46C: 556A0108  rlwinm r10, r11, 0, 4, 4
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BD470: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BD474: 409A0018  bne cr6, 0x832bd48c
	if !ctx.cr[6].eq {
	pc = 0x832BD48C; continue 'dispatch;
	}
	// 832BD478: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 832BD47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD480: 409A000C  bne cr6, 0x832bd48c
	if !ctx.cr[6].eq {
	pc = 0x832BD48C; continue 'dispatch;
	}
	// 832BD484: 807EFFFC  lwz r3, -4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 832BD488: 48000008  b 0x832bd490
	pc = 0x832BD490; continue 'dispatch;
	// 832BD48C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BD490: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD498: 419A000C  beq cr6, 0x832bd4a4
	if ctx.cr[6].eq {
	pc = 0x832BD4A4; continue 'dispatch;
	}
	// 832BD49C: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BD4A0: 48000008  b 0x832bd4a8
	pc = 0x832BD4A8; continue 'dispatch;
	// 832BD4A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BD4A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 832BD4AC: 38DF0354  addi r6, r31, 0x354
	ctx.r[6].s64 = ctx.r[31].s64 + 852;
	// 832BD4B0: 389F0254  addi r4, r31, 0x254
	ctx.r[4].s64 = ctx.r[31].s64 + 596;
	// 832BD4B4: 48001ACD  bl 0x832bef80
	ctx.lr = 0x832BD4B8;
	sub_832BEF80(ctx, base);
	// 832BD4B8: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 832BD4BC: 419A001C  beq cr6, 0x832bd4d8
	if ctx.cr[6].eq {
	pc = 0x832BD4D8; continue 'dispatch;
	}
	// 832BD4C0: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 832BD4C4: 419A007C  beq cr6, 0x832bd540
	if ctx.cr[6].eq {
	pc = 0x832BD540; continue 'dispatch;
	}
	// 832BD4C8: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 832BD4CC: 409A0014  bne cr6, 0x832bd4e0
	if !ctx.cr[6].eq {
	pc = 0x832BD4E0; continue 'dispatch;
	}
	// 832BD4D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BD4D4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832BD4D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832BD4DC: 917EFFFC  stw r11, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 832BD4E0: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD4E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832BD4E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD4EC: 409900B4  ble cr6, 0x832bd5a0
	if !ctx.cr[6].gt {
	pc = 0x832BD5A0; continue 'dispatch;
	}
	// 832BD4F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 832BD4F4: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BD4F8: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BD4FC: 81630178  lwz r11, 0x178(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) } as u64;
	// 832BD500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BD504: 4E800421  bctrl
	ctx.lr = 0x832BD508;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD508: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BD50C: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BD510: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BD514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD518: 419A0038  beq cr6, 0x832bd550
	if ctx.cr[6].eq {
	pc = 0x832BD550; continue 'dispatch;
	}
	// 832BD51C: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BD520: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BD524: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BD528: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BD52C: 409A0020  bne cr6, 0x832bd54c
	if !ctx.cr[6].eq {
	pc = 0x832BD54C; continue 'dispatch;
	}
	// 832BD530: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BD534: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BD538: 4E800421  bctrl
	ctx.lr = 0x832BD53C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD53C: 48000014  b 0x832bd550
	pc = 0x832BD550; continue 'dispatch;
	// 832BD540: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832BD544: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BD548: 4BFFFF98  b 0x832bd4e0
	pc = 0x832BD4E0; continue 'dispatch;
	// 832BD54C: 4B9EEBF5  bl 0x82cac140
	ctx.lr = 0x832BD550;
	sub_82CAC140(ctx, base);
	// 832BD550: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BD554: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832BD558: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BD55C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD560: 419A002C  beq cr6, 0x832bd58c
	if ctx.cr[6].eq {
	pc = 0x832BD58C; continue 'dispatch;
	}
	// 832BD564: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BD568: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BD56C: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BD570: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BD574: 409A0014  bne cr6, 0x832bd588
	if !ctx.cr[6].eq {
	pc = 0x832BD588; continue 'dispatch;
	}
	// 832BD578: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BD57C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BD580: 4E800421  bctrl
	ctx.lr = 0x832BD584;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD584: 48000008  b 0x832bd58c
	pc = 0x832BD58C; continue 'dispatch;
	// 832BD588: 4B9EEBB9  bl 0x82cac140
	ctx.lr = 0x832BD58C;
	sub_82CAC140(ctx, base);
	// 832BD58C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD590: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 832BD594: 3BDE0184  addi r30, r30, 0x184
	ctx.r[30].s64 = ctx.r[30].s64 + 388;
	// 832BD598: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BD59C: 4198FF58  blt cr6, 0x832bd4f4
	if ctx.cr[6].lt {
	pc = 0x832BD4F4; continue 'dispatch;
	}
	// 832BD5A0: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 832BD5A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD5A8: 419A0038  beq cr6, 0x832bd5e0
	if ctx.cr[6].eq {
	pc = 0x832BD5E0; continue 'dispatch;
	}
	// 832BD5AC: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BD5B0: 5549014A  rlwinm r9, r10, 0, 5, 5
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 832BD5B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BD5B8: 409A006C  bne cr6, 0x832bd624
	if !ctx.cr[6].eq {
	pc = 0x832BD624; continue 'dispatch;
	}
	// 832BD5BC: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BD5C0: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BD5C4: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BD5C8: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BD5CC: 409A0054  bne cr6, 0x832bd620
	if !ctx.cr[6].eq {
	pc = 0x832BD620; continue 'dispatch;
	}
	// 832BD5D0: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BD5D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BD5D8: 4E800421  bctrl
	ctx.lr = 0x832BD5DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD5DC: 48000048  b 0x832bd624
	pc = 0x832BD624; continue 'dispatch;
	// 832BD5E0: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 832BD5E4: 387F0150  addi r3, r31, 0x150
	ctx.r[3].s64 = ctx.r[31].s64 + 336;
	// 832BD5E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BD5EC: 4E800421  bctrl
	ctx.lr = 0x832BD5F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD5F0: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 832BD5F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD5F8: 419A002C  beq cr6, 0x832bd624
	if ctx.cr[6].eq {
	pc = 0x832BD624; continue 'dispatch;
	}
	// 832BD5FC: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BD600: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BD604: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BD608: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BD60C: 409A0014  bne cr6, 0x832bd620
	if !ctx.cr[6].eq {
	pc = 0x832BD620; continue 'dispatch;
	}
	// 832BD610: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BD614: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BD618: 4E800421  bctrl
	ctx.lr = 0x832BD61C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD61C: 48000008  b 0x832bd624
	pc = 0x832BD624; continue 'dispatch;
	// 832BD620: 4B9EEB21  bl 0x82cac140
	ctx.lr = 0x832BD624;
	sub_82CAC140(ctx, base);
	// 832BD624: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 832BD628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD62C: 419A002C  beq cr6, 0x832bd658
	if ctx.cr[6].eq {
	pc = 0x832BD658; continue 'dispatch;
	}
	// 832BD630: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BD634: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BD638: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BD63C: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BD640: 409A0014  bne cr6, 0x832bd654
	if !ctx.cr[6].eq {
	pc = 0x832BD654; continue 'dispatch;
	}
	// 832BD644: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BD648: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BD64C: 4E800421  bctrl
	ctx.lr = 0x832BD650;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD650: 48000008  b 0x832bd658
	pc = 0x832BD658; continue 'dispatch;
	// 832BD654: 4B9EEAED  bl 0x82cac140
	ctx.lr = 0x832BD658;
	sub_82CAC140(ctx, base);
	// 832BD658: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 832BD65C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD660: 419A002C  beq cr6, 0x832bd68c
	if ctx.cr[6].eq {
	pc = 0x832BD68C; continue 'dispatch;
	}
	// 832BD664: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BD668: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BD66C: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BD670: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BD674: 409A0014  bne cr6, 0x832bd688
	if !ctx.cr[6].eq {
	pc = 0x832BD688; continue 'dispatch;
	}
	// 832BD678: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BD67C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BD680: 4E800421  bctrl
	ctx.lr = 0x832BD684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD684: 48000008  b 0x832bd68c
	pc = 0x832BD68C; continue 'dispatch;
	// 832BD688: 4B9EEAB9  bl 0x82cac140
	ctx.lr = 0x832BD68C;
	sub_82CAC140(ctx, base);
	// 832BD68C: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 832BD690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD694: 419A0038  beq cr6, 0x832bd6cc
	if ctx.cr[6].eq {
	pc = 0x832BD6CC; continue 'dispatch;
	}
	// 832BD698: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 832BD69C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BD6A0: 419A002C  beq cr6, 0x832bd6cc
	if ctx.cr[6].eq {
	pc = 0x832BD6CC; continue 'dispatch;
	}
	// 832BD6A4: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BD6A8: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BD6AC: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BD6B0: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BD6B4: 409A0014  bne cr6, 0x832bd6c8
	if !ctx.cr[6].eq {
	pc = 0x832BD6C8; continue 'dispatch;
	}
	// 832BD6B8: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BD6BC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BD6C0: 4E800421  bctrl
	ctx.lr = 0x832BD6C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD6C4: 48000008  b 0x832bd6cc
	pc = 0x832BD6CC; continue 'dispatch;
	// 832BD6C8: 4B9EEA79  bl 0x82cac140
	ctx.lr = 0x832BD6CC;
	sub_82CAC140(ctx, base);
	// 832BD6CC: 38A0039C  li r5, 0x39c
	ctx.r[5].s64 = 924;
	// 832BD6D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BD6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD6D8: 4B9EC2D9  bl 0x82ca99b0
	ctx.lr = 0x832BD6DC;
	sub_82CA99B0(ctx, base);
	// 832BD6DC: 897FFFFE  lbz r11, -2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BD6E0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 832BD6E4: 897FFFFF  lbz r11, -1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BD6E8: 7C6BF850  subf r3, r11, r31
	ctx.r[3].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 832BD6EC: 409A0018  bne cr6, 0x832bd704
	if !ctx.cr[6].eq {
	pc = 0x832BD704; continue 'dispatch;
	}
	// 832BD6F0: 815FFFF4  lwz r10, -0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BD6F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832BD6F8: 4E800421  bctrl
	ctx.lr = 0x832BD6FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD6FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BD700: 4B9EBD5C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 832BD704: 4B9EEA3D  bl 0x82cac140
	ctx.lr = 0x832BD708;
	sub_82CAC140(ctx, base);
	// 832BD708: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BD70C: 4B9EBD50  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BD710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BD710 size=464
    let mut pc: u32 = 0x832BD710;
    'dispatch: loop {
        match pc {
            0x832BD710 => {
    //   block [0x832BD710..0x832BD8E0)
	// 832BD710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BD714: 4B9EBCF9  bl 0x82ca940c
	ctx.lr = 0x832BD718;
	sub_82CA93D0(ctx, base);
	// 832BD718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BD71C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BD720: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BD724: 409A0010  bne cr6, 0x832bd734
	if !ctx.cr[6].eq {
	pc = 0x832BD734; continue 'dispatch;
	}
	// 832BD728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BD72C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BD730: 4B9EBD2C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 832BD734: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 832BD738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD73C: 409A0010  bne cr6, 0x832bd74c
	if !ctx.cr[6].eq {
	pc = 0x832BD74C; continue 'dispatch;
	}
	// 832BD740: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 832BD744: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BD748: 419AFFE0  beq cr6, 0x832bd728
	if ctx.cr[6].eq {
	pc = 0x832BD728; continue 'dispatch;
	}
	// 832BD74C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BD750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD754: 409AFFD4  bne cr6, 0x832bd728
	if !ctx.cr[6].eq {
	pc = 0x832BD728; continue 'dispatch;
	}
	// 832BD758: 83BF02C0  lwz r29, 0x2c0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(704 as u32) ) } as u64;
	// 832BD75C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 832BD760: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 832BD764: 409A0028  bne cr6, 0x832bd78c
	if !ctx.cr[6].eq {
	pc = 0x832BD78C; continue 'dispatch;
	}
	// 832BD768: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 832BD76C: 409A001C  bne cr6, 0x832bd788
	if !ctx.cr[6].eq {
	pc = 0x832BD788; continue 'dispatch;
	}
	// 832BD770: 48003349  bl 0x832c0ab8
	ctx.lr = 0x832BD774;
	sub_832C0AB8(ctx, base);
	// 832BD774: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 832BD778: 907F02C0  stw r3, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[3].u32 ) };
	// 832BD77C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832BD780: 93DF0344  stw r30, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[30].u32 ) };
	// 832BD784: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 832BD788: 83BF02C0  lwz r29, 0x2c0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(704 as u32) ) } as u64;
	// 832BD78C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD794: 419A000C  beq cr6, 0x832bd7a0
	if ctx.cr[6].eq {
	pc = 0x832BD7A0; continue 'dispatch;
	}
	// 832BD798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BD79C: 4BFFD565  bl 0x832bad00
	ctx.lr = 0x832BD7A0;
	sub_832BAD00(ctx, base);
	// 832BD7A0: 48003319  bl 0x832c0ab8
	ctx.lr = 0x832BD7A4;
	sub_832C0AB8(ctx, base);
	// 832BD7A4: 817F02BC  lwz r11, 0x2bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(700 as u32) ) } as u64;
	// 832BD7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD7AC: 419A0020  beq cr6, 0x832bd7cc
	if ctx.cr[6].eq {
	pc = 0x832BD7CC; continue 'dispatch;
	}
	// 832BD7B0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 832BD7B4: 419A0018  beq cr6, 0x832bd7cc
	if ctx.cr[6].eq {
	pc = 0x832BD7CC; continue 'dispatch;
	}
	// 832BD7B8: 815F02E8  lwz r10, 0x2e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 832BD7BC: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BD7C0: 93DF02BC  stw r30, 0x2bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(700 as u32), ctx.r[30].u32 ) };
	// 832BD7C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BD7C8: 917F02E8  stw r11, 0x2e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(744 as u32), ctx.r[11].u32 ) };
	// 832BD7CC: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 832BD7D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BD7D4: 409A0070  bne cr6, 0x832bd844
	if !ctx.cr[6].eq {
	pc = 0x832BD844; continue 'dispatch;
	}
	// 832BD7D8: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD7DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD7E0: 419A0010  beq cr6, 0x832bd7f0
	if ctx.cr[6].eq {
	pc = 0x832BD7F0; continue 'dispatch;
	}
	// 832BD7E4: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 832BD7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD7EC: 419A0058  beq cr6, 0x832bd844
	if ctx.cr[6].eq {
	pc = 0x832BD844; continue 'dispatch;
	}
	// 832BD7F0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BD7F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD7F8: 419AFF30  beq cr6, 0x832bd728
	if ctx.cr[6].eq {
	pc = 0x832BD728; continue 'dispatch;
	}
	// 832BD7FC: 815F02B4  lwz r10, 0x2b4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 832BD800: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 832BD804: 811F02C4  lwz r8, 0x2c4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(708 as u32) ) } as u64;
	// 832BD808: 80FF0018  lwz r7, 0x18(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BD80C: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 832BD810: 80BF0118  lwz r5, 0x118(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BD814: 78C40020  clrldi r4, r6, 0x20
	ctx.r[4].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 832BD818: 7D6439D2  mulld r11, r4, r7
	ctx.r[11].s64 = ctx.r[4].s64 * ctx.r[7].s64;
	// 832BD81C: 81450040  lwz r10, 0x40(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) } as u64;
	// 832BD820: 1D0B03E8  mulli r8, r11, 0x3e8
	ctx.r[8].s64 = ctx.r[11].s64 * 1000;
	// 832BD824: 7CE84B92  divdu r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 / ctx.r[9].u64;
	// 832BD828: 54E6003E  slwi r6, r7, 0
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BD82C: 7CA651D2  mulld r5, r6, r10
	ctx.r[5].s64 = ctx.r[6].s64 * ctx.r[10].s64;
	// 832BD830: 78A48402  rldicl r4, r5, 0x30, 0x10
	ctx.r[4].u64 = ctx.r[5].u64 & 0x000000000000FFFFu64;
	// 832BD834: 548B003E  slwi r11, r4, 0
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BD838: 7D4B1850  subf r10, r11, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BD83C: 7D3D5051  subf. r9, r29, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BD840: 4080FEE8  bge 0x832bd728
	if !ctx.cr[0].lt {
	pc = 0x832BD728; continue 'dispatch;
	}
	// 832BD844: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 832BD848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD84C: 409A0088  bne cr6, 0x832bd8d4
	if !ctx.cr[6].eq {
	pc = 0x832BD8D4; continue 'dispatch;
	}
	// 832BD850: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BD854: 556A0108  rlwinm r10, r11, 0, 4, 4
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BD858: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BD85C: 409A0028  bne cr6, 0x832bd884
	if !ctx.cr[6].eq {
	pc = 0x832BD884; continue 'dispatch;
	}
	// 832BD860: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 832BD864: 815F0198  lwz r10, 0x198(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 832BD868: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BD86C: 41980008  blt cr6, 0x832bd874
	if ctx.cr[6].lt {
	pc = 0x832BD874; continue 'dispatch;
	}
	// 832BD870: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 832BD874: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 832BD878: 5569F87E  srwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BD87C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BD880: 40980054  bge cr6, 0x832bd8d4
	if !ctx.cr[6].lt {
	pc = 0x832BD8D4; continue 'dispatch;
	}
	// 832BD884: 3BDF0254  addi r30, r31, 0x254
	ctx.r[30].s64 = ctx.r[31].s64 + 596;
	// 832BD888: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BD88C: 419A0020  beq cr6, 0x832bd8ac
	if ctx.cr[6].eq {
	pc = 0x832BD8AC; continue 'dispatch;
	}
	// 832BD890: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BD894: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BD898: 419A0014  beq cr6, 0x832bd8ac
	if ctx.cr[6].eq {
	pc = 0x832BD8AC; continue 'dispatch;
	}
	// 832BD89C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BD8A0: 4AED9129  bl 0x821969c8
	ctx.lr = 0x832BD8A4;
	sub_821969C8(ctx, base);
	// 832BD8A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BD8A8: 409A002C  bne cr6, 0x832bd8d4
	if !ctx.cr[6].eq {
	pc = 0x832BD8D4; continue 'dispatch;
	}
	// 832BD8AC: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 832BD8B0: 387F0150  addi r3, r31, 0x150
	ctx.r[3].s64 = ctx.r[31].s64 + 336;
	// 832BD8B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BD8B8: 4E800421  bctrl
	ctx.lr = 0x832BD8BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD8BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BD8C0: 419A0014  beq cr6, 0x832bd8d4
	if ctx.cr[6].eq {
	pc = 0x832BD8D4; continue 'dispatch;
	}
	// 832BD8C4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BD8C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BD8CC: 419A0008  beq cr6, 0x832bd8d4
	if ctx.cr[6].eq {
	pc = 0x832BD8D4; continue 'dispatch;
	}
	// 832BD8D0: 4BD4E0F1  bl 0x8300b9c0
	ctx.lr = 0x832BD8D4;
	sub_8300B9C0(ctx, base);
	// 832BD8D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BD8D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BD8DC: 4B9EBB80  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BD8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BD8E0 size=348
    let mut pc: u32 = 0x832BD8E0;
    'dispatch: loop {
        match pc {
            0x832BD8E0 => {
    //   block [0x832BD8E0..0x832BDA3C)
	// 832BD8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BD8E4: 4B9EBB1D  bl 0x82ca9400
	ctx.lr = 0x832BD8E8;
	sub_82CA93D0(ctx, base);
	// 832BD8E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BD8EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BD8F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BD8F4: 409A000C  bne cr6, 0x832bd900
	if !ctx.cr[6].eq {
	pc = 0x832BD900; continue 'dispatch;
	}
	// 832BD8F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832BD8FC: 4B9EBB54  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 832BD900: 480031B9  bl 0x832c0ab8
	ctx.lr = 0x832BD904;
	sub_832C0AB8(ctx, base);
	// 832BD904: 817F02BC  lwz r11, 0x2bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(700 as u32) ) } as u64;
	// 832BD908: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832BD90C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD910: 419A0020  beq cr6, 0x832bd930
	if ctx.cr[6].eq {
	pc = 0x832BD930; continue 'dispatch;
	}
	// 832BD914: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 832BD918: 419A0018  beq cr6, 0x832bd930
	if ctx.cr[6].eq {
	pc = 0x832BD930; continue 'dispatch;
	}
	// 832BD91C: 815F02E8  lwz r10, 0x2e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 832BD920: 939F02BC  stw r28, 0x2bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(700 as u32), ctx.r[28].u32 ) };
	// 832BD924: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832BD928: 7D2B1A14  add r9, r11, r3
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 832BD92C: 913F02E8  stw r9, 0x2e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(744 as u32), ctx.r[9].u32 ) };
	// 832BD930: 3B7F0354  addi r27, r31, 0x354
	ctx.r[27].s64 = ctx.r[31].s64 + 852;
	// 832BD934: 835F00EC  lwz r26, 0xec(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 832BD938: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 832BD93C: 939F0324  stw r28, 0x324(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(804 as u32), ctx.r[28].u32 ) };
	// 832BD940: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BD944: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 832BD948: 419A0018  beq cr6, 0x832bd960
	if ctx.cr[6].eq {
	pc = 0x832BD960; continue 'dispatch;
	}
	// 832BD94C: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BD950: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BD954: 419A000C  beq cr6, 0x832bd960
	if ctx.cr[6].eq {
	pc = 0x832BD960; continue 'dispatch;
	}
	// 832BD958: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BD95C: 4AED906D  bl 0x821969c8
	ctx.lr = 0x832BD960;
	sub_821969C8(ctx, base);
	// 832BD960: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD964: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 832BD968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD96C: 40990034  ble cr6, 0x832bd9a0
	if !ctx.cr[6].gt {
	pc = 0x832BD9A0; continue 'dispatch;
	}
	// 832BD970: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 832BD974: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BD978: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BD97C: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 832BD980: 81630170  lwz r11, 0x170(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 832BD984: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BD988: 4E800421  bctrl
	ctx.lr = 0x832BD98C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BD98C: 815F0114  lwz r10, 0x114(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BD990: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 832BD994: 3BDE0184  addi r30, r30, 0x184
	ctx.r[30].s64 = ctx.r[30].s64 + 388;
	// 832BD998: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BD99C: 4198FFD8  blt cr6, 0x832bd974
	if ctx.cr[6].lt {
	pc = 0x832BD974; continue 'dispatch;
	}
	// 832BD9A0: 4AFA8711  bl 0x822660b0
	ctx.lr = 0x832BD9A4;
	sub_822660B0(ctx, base);
	// 832BD9A4: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832BD9A8: 394BC200  addi r10, r11, -0x3e00
	ctx.r[10].s64 = ctx.r[11].s64 + -15872;
	// 832BD9AC: 816BC200  lwz r11, -0x3e00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15872 as u32) ) } as u64;
	// 832BD9B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD9B4: 409A000C  bne cr6, 0x832bd9c0
	if !ctx.cr[6].eq {
	pc = 0x832BD9C0; continue 'dispatch;
	}
	// 832BD9B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BD9BC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BD9C0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BD9C4: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BD9C8: 3D00C000  lis r8, -0x4000
	ctx.r[8].s64 = -1073741824;
	// 832BD9CC: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 832BD9D0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 832BD9D4: 4199000C  bgt cr6, 0x832bd9e0
	if ctx.cr[6].gt {
	pc = 0x832BD9E0; continue 'dispatch;
	}
	// 832BD9D8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 832BD9DC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832BD9E0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 832BD9E4: 409A0020  bne cr6, 0x832bda04
	if !ctx.cr[6].eq {
	pc = 0x832BDA04; continue 'dispatch;
	}
	// 832BD9E8: 817F02C0  lwz r11, 0x2c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(704 as u32) ) } as u64;
	// 832BD9EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BD9F0: 419A0010  beq cr6, 0x832bda00
	if ctx.cr[6].eq {
	pc = 0x832BDA00; continue 'dispatch;
	}
	// 832BD9F4: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 832BD9F8: 917F0344  stw r11, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[11].u32 ) };
	// 832BD9FC: 48000008  b 0x832bda04
	pc = 0x832BDA04; continue 'dispatch;
	// 832BDA00: 939F0344  stw r28, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[28].u32 ) };
	// 832BDA04: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BDA08: 419A0014  beq cr6, 0x832bda1c
	if ctx.cr[6].eq {
	pc = 0x832BDA1C; continue 'dispatch;
	}
	// 832BDA0C: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BDA10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BDA14: 419A0008  beq cr6, 0x832bda1c
	if ctx.cr[6].eq {
	pc = 0x832BDA1C; continue 'dispatch;
	}
	// 832BDA18: 4BD4DFA9  bl 0x8300b9c0
	ctx.lr = 0x832BDA1C;
	sub_8300B9C0(ctx, base);
	// 832BDA1C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BDA20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BDA24: 419A000C  beq cr6, 0x832bda30
	if ctx.cr[6].eq {
	pc = 0x832BDA30; continue 'dispatch;
	}
	// 832BDA28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BDA2C: 4BFFD2D5  bl 0x832bad00
	ctx.lr = 0x832BDA30;
	sub_832BAD00(ctx, base);
	// 832BDA30: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 832BDA34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832BDA38: 4B9EBA18  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BDA40 size=12
    let mut pc: u32 = 0x832BDA40;
    'dispatch: loop {
        match pc {
            0x832BDA40 => {
    //   block [0x832BDA40..0x832BDA4C)
	// 832BDA40: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 832BDA44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BDA48: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDA4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BDA4C size=12
    let mut pc: u32 = 0x832BDA4C;
    'dispatch: loop {
        match pc {
            0x832BDA4C => {
    //   block [0x832BDA4C..0x832BDA58)
	// 832BDA4C: 81030114  lwz r8, 0x114(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BDA50: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 832BDA54: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BDA58 size=12
    let mut pc: u32 = 0x832BDA58;
    'dispatch: loop {
        match pc {
            0x832BDA58 => {
    //   block [0x832BDA58..0x832BDA64)
	// 832BDA58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BDA5C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 832BDA60: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDA64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BDA64 size=48
    let mut pc: u32 = 0x832BDA64;
    'dispatch: loop {
        match pc {
            0x832BDA64 => {
    //   block [0x832BDA64..0x832BDA94)
	// 832BDA64: 812302AC  lwz r9, 0x2ac(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(684 as u32) ) } as u64;
	// 832BDA68: 8163011C  lwz r11, 0x11c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(284 as u32) ) } as u64;
	// 832BDA6C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BDA70: 54C4103A  slwi r4, r6, 2
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BDA74: 7CC4482E  lwzx r6, r4, r9
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 832BDA78: 7F063800  cmpw cr6, r6, r7
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[7].s32, &mut ctx.xer);
	// 832BDA7C: 419A0018  beq cr6, 0x832bda94
	if ctx.cr[6].eq {
		sub_832BDA94(ctx, base);
		return;
	}
	// 832BDA80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832BDA84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BDA88: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 832BDA8C: 4198FFE0  blt cr6, 0x832bda6c
	if ctx.cr[6].lt {
	pc = 0x832BDA6C; continue 'dispatch;
	}
	// 832BDA90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDA94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BDA94 size=8
    let mut pc: u32 = 0x832BDA94;
    'dispatch: loop {
        match pc {
            0x832BDA94 => {
    //   block [0x832BDA94..0x832BDA9C)
	// 832BDA94: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 832BDA98: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDA9C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BDA9C size=24
    let mut pc: u32 = 0x832BDA9C;
    'dispatch: loop {
        match pc {
            0x832BDA9C => {
    //   block [0x832BDA9C..0x832BDAB4)
	// 832BDA9C: 1D6A0184  mulli r11, r10, 0x184
	ctx.r[11].s64 = ctx.r[10].s64 * 388;
	// 832BDAA0: 81430118  lwz r10, 0x118(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BDAA4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BDAA8: 812A0168  lwz r9, 0x168(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(360 as u32) ) } as u64;
	// 832BDAAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BDAB0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDAB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BDAB4 size=24
    let mut pc: u32 = 0x832BDAB4;
    'dispatch: loop {
        match pc {
            0x832BDAB4 => {
    //   block [0x832BDAB4..0x832BDACC)
	// 832BDAB4: 81430118  lwz r10, 0x118(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BDAB8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 832BDABC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BDAC0: 81630168  lwz r11, 0x168(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(360 as u32) ) } as u64;
	// 832BDAC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BDAC8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BDAD0 size=464
    let mut pc: u32 = 0x832BDAD0;
    'dispatch: loop {
        match pc {
            0x832BDAD0 => {
    //   block [0x832BDAD0..0x832BDCA0)
	// 832BDAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BDAD4: 4B9EB919  bl 0x82ca93ec
	ctx.lr = 0x832BDAD8;
	sub_82CA93D0(ctx, base);
	// 832BDAD8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BDADC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 832BDAE0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 832BDAE4: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 832BDAE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BDAEC: 7F56D378  mr r22, r26
	ctx.r[22].u64 = ctx.r[26].u64;
	// 832BDAF0: 419A00D8  beq cr6, 0x832bdbc8
	if ctx.cr[6].eq {
	pc = 0x832BDBC8; continue 'dispatch;
	}
	// 832BDAF4: 817E0114  lwz r11, 0x114(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BDAF8: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 832BDAFC: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 832BDB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BDB04: 409900C4  ble cr6, 0x832bdbc8
	if !ctx.cr[6].gt {
	pc = 0x832BDBC8; continue 'dispatch;
	}
	// 832BDB08: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 832BDB0C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 832BDB10: 3AE0FFFF  li r23, -1
	ctx.r[23].s64 = -1;
	// 832BDB14: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BDB18: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BDB1C: 814B0174  lwz r10, 0x174(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(372 as u32) ) } as u64;
	// 832BDB20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BDB24: 419A0070  beq cr6, 0x832bdb94
	if ctx.cr[6].eq {
	pc = 0x832BDB94; continue 'dispatch;
	}
	// 832BDB28: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 832BDB2C: 409A0024  bne cr6, 0x832bdb50
	if !ctx.cr[6].eq {
	pc = 0x832BDB50; continue 'dispatch;
	}
	// 832BDB30: 357E0354  addic. r11, r30, 0x354
	ctx.xer.ca = (ctx.r[30].u32 > (!(852 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + 852;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BDB34: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	// 832BDB38: 41820018  beq 0x832bdb50
	if ctx.cr[0].eq {
	pc = 0x832BDB50; continue 'dispatch;
	}
	// 832BDB3C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BDB40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BDB44: 419A000C  beq cr6, 0x832bdb50
	if ctx.cr[6].eq {
	pc = 0x832BDB50; continue 'dispatch;
	}
	// 832BDB48: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 832BDB4C: 4AED8E7D  bl 0x821969c8
	ctx.lr = 0x832BDB50;
	sub_821969C8(ctx, base);
	// 832BDB50: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BDB54: 7F0A0034  cntlzw r10, r24
	ctx.r[10].u64 = if ctx.r[24].u32 == 0 { 32 } else { ctx.r[24].u32.leading_zeros() as u64 };
	// 832BDB58: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BDB5C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 832BDB60: 69240001  xori r4, r9, 1
	ctx.r[4].u64 = ctx.r[9].u64 ^ 1;
	// 832BDB64: 81030174  lwz r8, 0x174(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(372 as u32) ) } as u64;
	// 832BDB68: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 832BDB6C: 4E800421  bctrl
	ctx.lr = 0x832BDB70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BDB70: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BDB74: 419A0060  beq cr6, 0x832bdbd4
	if ctx.cr[6].eq {
	pc = 0x832BDBD4; continue 'dispatch;
	}
	// 832BDB78: 817E00F8  lwz r11, 0xf8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 832BDB7C: 7F76DB78  mr r22, r27
	ctx.r[22].u64 = ctx.r[27].u64;
	// 832BDB80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BDB84: 409A0010  bne cr6, 0x832bdb94
	if !ctx.cr[6].eq {
	pc = 0x832BDB94; continue 'dispatch;
	}
	// 832BDB88: 937E00F8  stw r27, 0xf8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(248 as u32), ctx.r[27].u32 ) };
	// 832BDB8C: 935E02C0  stw r26, 0x2c0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(704 as u32), ctx.r[26].u32 ) };
	// 832BDB90: 935E0344  stw r26, 0x344(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(836 as u32), ctx.r[26].u32 ) };
	// 832BDB94: 817E0114  lwz r11, 0x114(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 832BDB98: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 832BDB9C: 3BBD0184  addi r29, r29, 0x184
	ctx.r[29].s64 = ctx.r[29].s64 + 388;
	// 832BDBA0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BDBA4: 4198FF70  blt cr6, 0x832bdb14
	if ctx.cr[6].lt {
	pc = 0x832BDB14; continue 'dispatch;
	}
	// 832BDBA8: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 832BDBAC: 419A001C  beq cr6, 0x832bdbc8
	if ctx.cr[6].eq {
	pc = 0x832BDBC8; continue 'dispatch;
	}
	// 832BDBB0: 357E0354  addic. r11, r30, 0x354
	ctx.xer.ca = (ctx.r[30].u32 > (!(852 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + 852;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BDBB4: 41820014  beq 0x832bdbc8
	if ctx.cr[0].eq {
	pc = 0x832BDBC8; continue 'dispatch;
	}
	// 832BDBB8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BDBBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BDBC0: 419A0008  beq cr6, 0x832bdbc8
	if ctx.cr[6].eq {
	pc = 0x832BDBC8; continue 'dispatch;
	}
	// 832BDBC4: 4BD4DDFD  bl 0x8300b9c0
	ctx.lr = 0x832BDBC8;
	sub_8300B9C0(ctx, base);
	// 832BDBC8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 832BDBCC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 832BDBD0: 4B9EB86C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
	// 832BDBD4: 817E00F8  lwz r11, 0xf8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 832BDBD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BDBDC: 419AFFB8  beq cr6, 0x832bdb94
	if ctx.cr[6].eq {
	pc = 0x832BDB94; continue 'dispatch;
	}
	// 832BDBE0: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BDBE4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BDBE8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BDBEC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832BDBF0: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BDBF4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BDBF8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BDBFC: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 832BDC00: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BDC04: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 832BDC08: 409A0010  bne cr6, 0x832bdc18
	if !ctx.cr[6].eq {
	pc = 0x832BDC18; continue 'dispatch;
	}
	// 832BDC0C: 817E0320  lwz r11, 0x320(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(800 as u32) ) } as u64;
	// 832BDC10: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 832BDC14: 409A0084  bne cr6, 0x832bdc98
	if !ctx.cr[6].eq {
	pc = 0x832BDC98; continue 'dispatch;
	}
	// 832BDC18: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 832BDC1C: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BDC20: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 832BDC24: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BDC28: 7D695851  subf. r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BDC2C: 4080000C  bge 0x832bdc38
	if !ctx.cr[0].lt {
	pc = 0x832BDC38; continue 'dispatch;
	}
	// 832BDC30: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BDC34: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BDC38: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 832BDC3C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 832BDC40: 40980058  bge cr6, 0x832bdc98
	if !ctx.cr[6].lt {
	pc = 0x832BDC98; continue 'dispatch;
	}
	// 832BDC44: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832BDC48: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BDC4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BDC50: 7D654850  subf r11, r5, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 832BDC54: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 832BDC58: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832BDC5C: 40980034  bge cr6, 0x832bdc90
	if !ctx.cr[6].lt {
	pc = 0x832BDC90; continue 'dispatch;
	}
	// 832BDC60: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BDC64: 7EAB1850  subf r21, r11, r3
	ctx.r[21].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BDC68: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BDC6C: 7CB52850  subf r5, r21, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[21].s64;
	// 832BDC70: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 832BDC74: 4B9EBD3D  bl 0x82ca99b0
	ctx.lr = 0x832BDC78;
	sub_82CA99B0(ctx, base);
	// 832BDC78: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 832BDC7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BDC80: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BDC84: 4B9EBD2D  bl 0x82ca99b0
	ctx.lr = 0x832BDC88;
	sub_82CA99B0(ctx, base);
	// 832BDC88: 935E00F8  stw r26, 0xf8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(248 as u32), ctx.r[26].u32 ) };
	// 832BDC8C: 4BFFFF08  b 0x832bdb94
	pc = 0x832BDB94; continue 'dispatch;
	// 832BDC90: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 832BDC94: 4B9EBD1D  bl 0x82ca99b0
	ctx.lr = 0x832BDC98;
	sub_82CA99B0(ctx, base);
	// 832BDC98: 935E00F8  stw r26, 0xf8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(248 as u32), ctx.r[26].u32 ) };
	// 832BDC9C: 4BFFFEF8  b 0x832bdb94
	pc = 0x832BDB94; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832BDCA0 size=408
    let mut pc: u32 = 0x832BDCA0;
    'dispatch: loop {
        match pc {
            0x832BDCA0 => {
    //   block [0x832BDCA0..0x832BDE38)
	// 832BDCA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BDCA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BDCA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BDCAC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BDCB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BDCB4: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BDCB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BDCBC: 419A0168  beq cr6, 0x832bde24
	if ctx.cr[6].eq {
	pc = 0x832BDE24; continue 'dispatch;
	}
	// 832BDCC0: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 832BDCC4: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 832BDCC8: 40990008  ble cr6, 0x832bdcd0
	if !ctx.cr[6].gt {
	pc = 0x832BDCD0; continue 'dispatch;
	}
	// 832BDCCC: 39607FFF  li r11, 0x7fff
	ctx.r[11].s64 = 32767;
	// 832BDCD0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 832BDCD4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 832BDCD8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 832BDCDC: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 832BDCE0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 832BDCE4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 832BDCE8: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 832BDCEC: C0090C20  lfs f0, 0xc20(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BDCF0: C84A0F10  lfd f2, 0xf10(r10)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3856 as u32) ) };
	// 832BDCF4: EC2C0032  fmuls f1, f12, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 832BDCF8: 4AF407B1  bl 0x821fe4a8
	ctx.lr = 0x832BDCFC;
	sub_821FE4A8(ctx, base);
	// 832BDCFC: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BDD00: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 832BDD04: 4BA1BAAD  bl 0x82cd97b0
	ctx.lr = 0x832BDD08;
	sub_82CD97B0(ctx, base);
	// 832BDD08: 80DF00C4  lwz r6, 0xc4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 832BDD0C: 80BF0024  lwz r5, 0x24(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 832BDD10: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 832BDD14: C9610058  lfd f11, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 832BDD18: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 832BDD1C: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 832BDD20: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 832BDD24: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 832BDD28: FC284824  fdiv f1, f8, f9
	ctx.f[1].f64 = ctx.f[8].f64 / ctx.f[9].f64;
	// 832BDD2C: 4AF36085  bl 0x821f3db0
	ctx.lr = 0x832BDD30;
	sub_821F3DB0(ctx, base);
	// 832BDD30: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 832BDD34: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BDD38: C8040E78  lfd f0, 0xe78(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(3704 as u32) ) };
	// 832BDD3C: FCE10032  fmul f7, f1, f0
	ctx.f[7].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 832BDD40: FC203818  frsp f1, f7
	ctx.f[1].f64 = (ctx.f[7].f64 as f32) as f64;
	// 832BDD44: 4BA1BAE5  bl 0x82cd9828
	ctx.lr = 0x832BDD48;
	sub_82CD9828(ctx, base);
	// 832BDD48: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 832BDD4C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BDD50: 419A00D4  beq cr6, 0x832bde24
	if ctx.cr[6].eq {
	pc = 0x832BDE24; continue 'dispatch;
	}
	// 832BDD54: 80BF0100  lwz r5, 0x100(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 832BDD58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BDD5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 832BDD60: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 832BDD64: 915F00FC  stw r10, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	// 832BDD68: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 832BDD6C: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 832BDD70: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 832BDD74: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 832BDD78: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 832BDD7C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 832BDD80: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 832BDD84: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 832BDD88: 98A10058  stb r5, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u8 ) };
	// 832BDD8C: 419A0030  beq cr6, 0x832bddbc
	if ctx.cr[6].eq {
	pc = 0x832BDDBC; continue 'dispatch;
	}
	// 832BDD90: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 832BDD94: 54A9003E  slwi r9, r5, 0
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BDD98: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 832BDD9C: C0089484  lfs f0, -0x6b7c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BDDA0: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 832BDDA4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832BDDA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832BDDAC: 990BFFFC  stb r8, -4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[8].u8 ) };
	// 832BDDB0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 832BDDB4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BDDB8: 4198FFE8  blt cr6, 0x832bdda0
	if ctx.cr[6].lt {
	pc = 0x832BDDA0; continue 'dispatch;
	}
	// 832BDDBC: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 832BDDC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BDDC4: 40990054  ble cr6, 0x832bde18
	if !ctx.cr[6].gt {
	pc = 0x832BDE18; continue 'dispatch;
	}
	// 832BDDC8: 5566003E  slwi r6, r11, 0
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BDDCC: 391F0168  addi r8, r31, 0x168
	ctx.r[8].s64 = ctx.r[31].s64 + 360;
	// 832BDDD0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 832BDDD4: 419A0038  beq cr6, 0x832bde0c
	if ctx.cr[6].eq {
	pc = 0x832BDE0C; continue 'dispatch;
	}
	// 832BDDD8: 80E8FFD0  lwz r7, -0x30(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-48 as u32) ) } as u64;
	// 832BDDDC: 39410074  addi r10, r1, 0x74
	ctx.r[10].s64 = ctx.r[1].s64 + 116;
	// 832BDDE0: 813F0100  lwz r9, 0x100(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 832BDDE4: 397F0108  addi r11, r31, 0x108
	ctx.r[11].s64 = ctx.r[31].s64 + 264;
	// 832BDDE8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BDDEC: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 832BDDF0: 409A000C  bne cr6, 0x832bddfc
	if !ctx.cr[6].eq {
	pc = 0x832BDDFC; continue 'dispatch;
	}
	// 832BDDF4: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BDDF8: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832BDDFC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BDE00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BDE04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 832BDE08: 4082FFE0  bne 0x832bdde8
	if !ctx.cr[0].eq {
	pc = 0x832BDDE8; continue 'dispatch;
	}
	// 832BDE0C: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 832BDE10: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 832BDE14: 4082FFBC  bne 0x832bddd0
	if !ctx.cr[0].eq {
	pc = 0x832BDDD0; continue 'dispatch;
	}
	// 832BDE18: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 832BDE1C: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BDE20: 4BA1B5C1  bl 0x82cd93e0
	ctx.lr = 0x832BDE24;
	sub_82CD93E0(ctx, base);
	// 832BDE24: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 832BDE28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BDE2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BDE30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BDE34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BDE38 size=100
    let mut pc: u32 = 0x832BDE38;
    'dispatch: loop {
        match pc {
            0x832BDE38 => {
    //   block [0x832BDE38..0x832BDE9C)
	// 832BDE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BDE3C: 4B9EB5D1  bl 0x82ca940c
	ctx.lr = 0x832BDE40;
	sub_82CA93D0(ctx, base);
	// 832BDE40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BDE44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BDE48: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 832BDE4C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 832BDE50: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 832BDE54: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BDE58: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 832BDE5C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BDE60: 40990008  ble cr6, 0x832bde68
	if !ctx.cr[6].gt {
	pc = 0x832BDE68; continue 'dispatch;
	}
	// 832BDE64: 7FCB5050  subf r30, r11, r10
	ctx.r[30].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832BDE68: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BDE6C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 832BDE70: 809F0098  lwz r4, 0x98(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 832BDE74: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BDE78: 4B9EBB39  bl 0x82ca99b0
	ctx.lr = 0x832BDE7C;
	sub_82CA99B0(ctx, base);
	// 832BDE7C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832BDE80: 40980014  bge cr6, 0x832bde94
	if !ctx.cr[6].lt {
	pc = 0x832BDE94; continue 'dispatch;
	}
	// 832BDE84: 7CBEE850  subf r5, r30, r29
	ctx.r[5].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 832BDE88: 809F0098  lwz r4, 0x98(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 832BDE8C: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BDE90: 4B9EBB21  bl 0x82ca99b0
	ctx.lr = 0x832BDE94;
	sub_82CA99B0(ctx, base);
	// 832BDE94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BDE98: 4B9EB5C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BDEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BDEA0 size=448
    let mut pc: u32 = 0x832BDEA0;
    'dispatch: loop {
        match pc {
            0x832BDEA0 => {
    //   block [0x832BDEA0..0x832BE060)
	// 832BDEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BDEA4: 4B9EB55D  bl 0x82ca9400
	ctx.lr = 0x832BDEA8;
	sub_82CA93D0(ctx, base);
	// 832BDEA8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BDEAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BDEB0: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 832BDEB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BDEB8: 409A019C  bne cr6, 0x832be054
	if !ctx.cr[6].eq {
	pc = 0x832BE054; continue 'dispatch;
	}
	// 832BDEBC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 832BDEC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BDEC4: 419A0190  beq cr6, 0x832be054
	if ctx.cr[6].eq {
	pc = 0x832BE054; continue 'dispatch;
	}
	// 832BDEC8: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 832BDECC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BDED0: 419A0178  beq cr6, 0x832be048
	if ctx.cr[6].eq {
	pc = 0x832BE048; continue 'dispatch;
	}
	// 832BDED4: 83DF00E4  lwz r30, 0xe4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 832BDED8: 48002BE1  bl 0x832c0ab8
	ctx.lr = 0x832BDEDC;
	sub_832C0AB8(ctx, base);
	// 832BDEDC: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 832BDEE0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 832BDEE4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 832BDEE8: 7D4B1850  subf r10, r11, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BDEEC: 2B0A000C  cmplwi cr6, r10, 0xc
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12 as u32, &mut ctx.xer);
	// 832BDEF0: 419900E8  bgt cr6, 0x832bdfd8
	if ctx.cr[6].gt {
	pc = 0x832BDFD8; continue 'dispatch;
	}
	// 832BDEF4: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 832BDEF8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BDEFC: 40980014  bge cr6, 0x832bdf10
	if !ctx.cr[6].lt {
	pc = 0x832BDF10; continue 'dispatch;
	}
	// 832BDF00: 815F00BC  lwz r10, 0xbc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BDF04: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832BDF08: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 832BDF0C: 48000008  b 0x832bdf14
	pc = 0x832BDF14; continue 'dispatch;
	// 832BDF10: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 832BDF14: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 832BDF18: 4098000C  bge cr6, 0x832bdf24
	if !ctx.cr[6].lt {
	pc = 0x832BDF24; continue 'dispatch;
	}
	// 832BDF1C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 832BDF20: 4800000C  b 0x832bdf2c
	pc = 0x832BDF2C; continue 'dispatch;
	// 832BDF24: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 832BDF28: 556B003A  rlwinm r11, r11, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BDF2C: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 832BDF30: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BDF34: 40980018  bge cr6, 0x832bdf4c
	if !ctx.cr[6].lt {
	pc = 0x832BDF4C; continue 'dispatch;
	}
	// 832BDF38: 815F00DC  lwz r10, 0xdc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 832BDF3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BDF40: 419A0114  beq cr6, 0x832be054
	if ctx.cr[6].eq {
	pc = 0x832BE054; continue 'dispatch;
	}
	// 832BDF44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BDF48: 419A010C  beq cr6, 0x832be054
	if ctx.cr[6].eq {
	pc = 0x832BE054; continue 'dispatch;
	}
	// 832BDF4C: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 832BDF50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BDF54: 419800F0  blt cr6, 0x832be044
	if ctx.cr[6].lt {
	pc = 0x832BE044; continue 'dispatch;
	}
	// 832BDF58: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 832BDF5C: 3BDF005C  addi r30, r31, 0x5c
	ctx.r[30].s64 = ctx.r[31].s64 + 92;
	// 832BDF60: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 832BDF64: 555D083C  slwi r29, r10, 1
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 832BDF68: 935F0054  stw r26, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 832BDF6C: 815F00BC  lwz r10, 0xbc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BDF70: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BDF74: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 832BDF78: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BDF7C: 40990008  ble cr6, 0x832bdf84
	if !ctx.cr[6].gt {
	pc = 0x832BDF84; continue 'dispatch;
	}
	// 832BDF80: 7F8B5050  subf r28, r11, r10
	ctx.r[28].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832BDF84: 815E005C  lwz r10, 0x5c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BDF88: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 832BDF8C: 809E0098  lwz r4, 0x98(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 832BDF90: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BDF94: 4B9EBA1D  bl 0x82ca99b0
	ctx.lr = 0x832BDF98;
	sub_82CA99B0(ctx, base);
	// 832BDF98: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832BDF9C: 40980014  bge cr6, 0x832bdfb0
	if !ctx.cr[6].lt {
	pc = 0x832BDFB0; continue 'dispatch;
	}
	// 832BDFA0: 7CBCE850  subf r5, r28, r29
	ctx.r[5].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 832BDFA4: 809E0098  lwz r4, 0x98(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 832BDFA8: 807E005C  lwz r3, 0x5c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BDFAC: 4B9EBA05  bl 0x82ca99b0
	ctx.lr = 0x832BDFB0;
	sub_82CA99B0(ctx, base);
	// 832BDFB0: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 832BDFB4: 813F00D8  lwz r9, 0xd8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 832BDFB8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BDFBC: 815F00BC  lwz r10, 0xbc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BDFC0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 832BDFC4: 917F00D8  stw r11, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 832BDFC8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BDFCC: 4198000C  blt cr6, 0x832bdfd8
	if ctx.cr[6].lt {
	pc = 0x832BDFD8; continue 'dispatch;
	}
	// 832BDFD0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BDFD4: 917F00D8  stw r11, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 832BDFD8: 83DF005C  lwz r30, 0x5c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BDFDC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 832BDFE0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 832BDFE4: 93610080  stw r27, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 832BDFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BDFEC: 4BA1B665  bl 0x82cd9650
	ctx.lr = 0x832BDFF0;
	sub_82CD9650(ctx, base);
	// 832BDFF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832BDFF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BDFF8: 4BA1B659  bl 0x82cd9650
	ctx.lr = 0x832BDFFC;
	sub_82CD9650(ctx, base);
	// 832BDFFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832BE000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BE004: 4BA1B64D  bl 0x82cd9650
	ctx.lr = 0x832BE008;
	sub_82CD9650(ctx, base);
	// 832BE008: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BE00C: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 832BE010: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BE014: 2B090400  cmplwi cr6, r9, 0x400
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1024 as u32, &mut ctx.xer);
	// 832BE018: 4098FFC4  bge cr6, 0x832bdfdc
	if !ctx.cr[6].lt {
	pc = 0x832BDFDC; continue 'dispatch;
	}
	// 832BE01C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 832BE020: 48002A99  bl 0x832c0ab8
	ctx.lr = 0x832BE024;
	sub_832C0AB8(ctx, base);
	// 832BE024: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 832BE028: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 832BE02C: 7D2B1850  subf r9, r11, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BE030: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 832BE034: 907F00EC  stw r3, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[3].u32 ) };
	// 832BE038: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BE03C: 4098FF1C  bge cr6, 0x832bdf58
	if !ctx.cr[6].lt {
	pc = 0x832BDF58; continue 'dispatch;
	}
	// 832BE040: 4BFFFEB4  b 0x832bdef4
	pc = 0x832BDEF4; continue 'dispatch;
	// 832BE044: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 832BE048: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BE04C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 832BE050: 4B9EB400  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 832BE054: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BE058: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 832BE05C: 4B9EB3F4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BE060 size=52
    let mut pc: u32 = 0x832BE060;
    'dispatch: loop {
        match pc {
            0x832BE060 => {
    //   block [0x832BE060..0x832BE094)
	// 832BE060: 816300DC  lwz r11, 0xdc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(220 as u32) ) } as u64;
	// 832BE064: 814300D8  lwz r10, 0xd8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) } as u64;
	// 832BE068: 812300BC  lwz r9, 0xbc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BE06C: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BE070: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BE074: 40990008  ble cr6, 0x832be07c
	if !ctx.cr[6].gt {
	pc = 0x832BE07C; continue 'dispatch;
	}
	// 832BE078: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 832BE07C: 812300B8  lwz r9, 0xb8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(184 as u32) ) } as u64;
	// 832BE080: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BE084: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 832BE088: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832BE08C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BE090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BE098 size=412
    let mut pc: u32 = 0x832BE098;
    'dispatch: loop {
        match pc {
            0x832BE098 => {
    //   block [0x832BE098..0x832BE234)
	// 832BE098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BE09C: 4B9EB361  bl 0x82ca93fc
	ctx.lr = 0x832BE0A0;
	sub_82CA93D0(ctx, base);
	// 832BE0A0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BE0A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BE0A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 832BE0AC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832BE0B0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 832BE0B4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 832BE0B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE0BC: 4BA1B435  bl 0x82cd94f0
	ctx.lr = 0x832BE0C0;
	sub_82CD94F0(ctx, base);
	// 832BE0C0: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 832BE0C4: 813F005C  lwz r9, 0x5c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BE0C8: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 832BE0CC: 939F0010  stw r28, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 832BE0D0: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 832BE0D4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 832BE0D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 832BE0DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE0E0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832BE0E4: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 832BE0E8: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 832BE0EC: 4BA1B3A5  bl 0x82cd9490
	ctx.lr = 0x832BE0F0;
	sub_82CD9490(ctx, base);
	// 832BE0F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832BE0F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE0F8: 4BA1B609  bl 0x82cd9700
	ctx.lr = 0x832BE0FC;
	sub_82CD9700(ctx, base);
	// 832BE0FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832BE100: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE104: 4BA1B5A5  bl 0x82cd96a8
	ctx.lr = 0x832BE108;
	sub_82CD96A8(ctx, base);
	// 832BE108: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BE10C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE110: 4BA1B439  bl 0x82cd9548
	ctx.lr = 0x832BE114;
	sub_82CD9548(ctx, base);
	// 832BE114: 939F0078  stw r28, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 832BE118: 480029A1  bl 0x832c0ab8
	ctx.lr = 0x832BE11C;
	sub_832C0AB8(ctx, base);
	// 832BE11C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832BE120: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 832BE124: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE128: 4BA1B529  bl 0x82cd9650
	ctx.lr = 0x832BE12C;
	sub_82CD9650(ctx, base);
	// 832BE12C: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832BE130: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	// 832BE134: 3F60C000  lis r27, -0x4000
	ctx.r[27].s64 = -1073741824;
	// 832BE138: 3BCBC200  addi r30, r11, -0x3e00
	ctx.r[30].s64 = ctx.r[11].s64 + -15872;
	// 832BE13C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BE140: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 832BE144: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832BE148: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE14C: 4BA1B505  bl 0x82cd9650
	ctx.lr = 0x832BE150;
	sub_82CD9650(ctx, base);
	// 832BE150: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BE154: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832BE158: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 832BE15C: 419A000C  beq cr6, 0x832be168
	if ctx.cr[6].eq {
	pc = 0x832BE168; continue 'dispatch;
	}
	// 832BE160: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 832BE164: 480000B0  b 0x832be214
	pc = 0x832BE214; continue 'dispatch;
	// 832BE168: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 832BE16C: 409A00A8  bne cr6, 0x832be214
	if !ctx.cr[6].eq {
	pc = 0x832BE214; continue 'dispatch;
	}
	// 832BE170: 4AFA7F41  bl 0x822660b0
	ctx.lr = 0x832BE174;
	sub_822660B0(ctx, base);
	// 832BE174: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BE17C: 409A000C  bne cr6, 0x832be188
	if !ctx.cr[6].eq {
	pc = 0x832BE188; continue 'dispatch;
	}
	// 832BE180: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BE184: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BE188: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BE18C: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BE190: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BE194: 7F09D840  cmplw cr6, r9, r27
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832BE198: 4199000C  bgt cr6, 0x832be1a4
	if ctx.cr[6].gt {
	pc = 0x832BE1A4; continue 'dispatch;
	}
	// 832BE19C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 832BE1A0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832BE1A4: 7D795050  subf r11, r25, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[25].s64;
	// 832BE1A8: 2B0B0032  cmplwi cr6, r11, 0x32
	ctx.cr[6].compare_u32(ctx.r[11].u32, 50 as u32, &mut ctx.xer);
	// 832BE1AC: 40990068  ble cr6, 0x832be214
	if !ctx.cr[6].gt {
	pc = 0x832BE214; continue 'dispatch;
	}
	// 832BE1B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BE1B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE1B8: 4BA1B391  bl 0x82cd9548
	ctx.lr = 0x832BE1BC;
	sub_82CD9548(ctx, base);
	// 832BE1BC: 939F0078  stw r28, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 832BE1C0: 4AFA7EF1  bl 0x822660b0
	ctx.lr = 0x832BE1C4;
	sub_822660B0(ctx, base);
	// 832BE1C4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BE1CC: 409A000C  bne cr6, 0x832be1d8
	if !ctx.cr[6].eq {
	pc = 0x832BE1D8; continue 'dispatch;
	}
	// 832BE1D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BE1D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BE1D8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BE1DC: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BE1E0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BE1E4: 7F09D840  cmplw cr6, r9, r27
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832BE1E8: 4099000C  ble cr6, 0x832be1f4
	if !ctx.cr[6].gt {
	pc = 0x832BE1F4; continue 'dispatch;
	}
	// 832BE1EC: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 832BE1F0: 4800000C  b 0x832be1fc
	pc = 0x832BE1FC; continue 'dispatch;
	// 832BE1F4: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 832BE1F8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832BE1FC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 832BE200: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832BE204: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE208: 4BA1B449  bl 0x82cd9650
	ctx.lr = 0x832BE20C;
	sub_82CD9650(ctx, base);
	// 832BE20C: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	// 832BE210: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BE214: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 832BE218: 815F0064  lwz r10, 0x64(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 832BE21C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BE220: 4199FF20  bgt cr6, 0x832be140
	if ctx.cr[6].gt {
	pc = 0x832BE140; continue 'dispatch;
	}
	// 832BE224: 48002895  bl 0x832c0ab8
	ctx.lr = 0x832BE228;
	sub_832C0AB8(ctx, base);
	// 832BE228: 907F0090  stw r3, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 832BE22C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 832BE230: 4B9EB21C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BE238 size=124
    let mut pc: u32 = 0x832BE238;
    'dispatch: loop {
        match pc {
            0x832BE238 => {
    //   block [0x832BE238..0x832BE2B4)
	// 832BE238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BE23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BE240: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BE244: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832BE248: 814B00D8  lwz r10, 0xd8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 832BE24C: 812B00BC  lwz r9, 0xbc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BE250: 7D445214  add r10, r4, r10
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 832BE254: 914B00D8  stw r10, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[10].u32 ) };
	// 832BE258: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BE25C: 4198000C  blt cr6, 0x832be268
	if ctx.cr[6].lt {
	pc = 0x832BE268; continue 'dispatch;
	}
	// 832BE260: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 832BE264: 914B00D8  stw r10, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[10].u32 ) };
	// 832BE268: 814B00DC  lwz r10, 0xdc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 832BE26C: 812B00D0  lwz r9, 0xd0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 832BE270: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 832BE274: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BE278: 914B00DC  stw r10, 0xdc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 832BE27C: 409A0024  bne cr6, 0x832be2a0
	if !ctx.cr[6].eq {
	pc = 0x832BE2A0; continue 'dispatch;
	}
	// 832BE280: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BE284: 409A001C  bne cr6, 0x832be2a0
	if !ctx.cr[6].eq {
	pc = 0x832BE2A0; continue 'dispatch;
	}
	// 832BE288: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 832BE28C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BE290: 409A0010  bne cr6, 0x832be2a0
	if !ctx.cr[6].eq {
	pc = 0x832BE2A0; continue 'dispatch;
	}
	// 832BE294: 386B005C  addi r3, r11, 0x5c
	ctx.r[3].s64 = ctx.r[11].s64 + 92;
	// 832BE298: 808B002C  lwz r4, 0x2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 832BE29C: 4BFFFDFD  bl 0x832be098
	ctx.lr = 0x832BE2A0;
	sub_832BE098(ctx, base);
	// 832BE2A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BE2A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832BE2A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BE2AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BE2B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BE2B8 size=20
    let mut pc: u32 = 0x832BE2B8;
    'dispatch: loop {
        match pc {
            0x832BE2B8 => {
    //   block [0x832BE2B8..0x832BE2CC)
	// 832BE2B8: 2F047FFF  cmpwi cr6, r4, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[4].s32, 32767, &mut ctx.xer);
	// 832BE2BC: 40990008  ble cr6, 0x832be2c4
	if !ctx.cr[6].gt {
	pc = 0x832BE2C4; continue 'dispatch;
	}
	// 832BE2C0: 38807FFF  li r4, 0x7fff
	ctx.r[4].s64 = 32767;
	// 832BE2C4: 908300C8  stw r4, 0xc8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[4].u32 ) };
	// 832BE2C8: 4BFFF9D8  b 0x832bdca0
	sub_832BDCA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BE2D0 size=24
    let mut pc: u32 = 0x832BE2D0;
    'dispatch: loop {
        match pc {
            0x832BE2D0 => {
    //   block [0x832BE2D0..0x832BE2E8)
	// 832BE2D0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 832BE2D4: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 832BE2D8: 40990008  ble cr6, 0x832be2e0
	if !ctx.cr[6].gt {
	pc = 0x832BE2E0; continue 'dispatch;
	}
	// 832BE2DC: 3C800001  lis r4, 1
	ctx.r[4].s64 = 65536;
	// 832BE2E0: 908300CC  stw r4, 0xcc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[4].u32 ) };
	// 832BE2E4: 4BFFF9BC  b 0x832bdca0
	sub_832BDCA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832BE2E8 size=384
    let mut pc: u32 = 0x832BE2E8;
    'dispatch: loop {
        match pc {
            0x832BE2E8 => {
    //   block [0x832BE2E8..0x832BE468)
	// 832BE2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BE2EC: 4B9EB119  bl 0x82ca9404
	ctx.lr = 0x832BE2F0;
	sub_82CA93D0(ctx, base);
	// 832BE2F0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 832BE2F4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BE2F8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 832BE2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BE300: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 832BE304: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 832BE308: 2B1E000C  cmplwi cr6, r30, 0xc
	ctx.cr[6].compare_u32(ctx.r[30].u32, 12 as u32, &mut ctx.xer);
	// 832BE30C: 40990008  ble cr6, 0x832be314
	if !ctx.cr[6].gt {
	pc = 0x832BE314; continue 'dispatch;
	}
	// 832BE310: 3BC0000C  li r30, 0xc
	ctx.r[30].s64 = 12;
	// 832BE314: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 832BE318: 815F00F8  lwz r10, 0xf8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 832BE31C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 832BE320: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832BE324: C3EB9490  lfs f31, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 832BE328: 409A00B0  bne cr6, 0x832be3d8
	if !ctx.cr[6].eq {
	pc = 0x832BE3D8; continue 'dispatch;
	}
	// 832BE32C: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 832BE330: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BE334: 419A0010  beq cr6, 0x832be344
	if ctx.cr[6].eq {
	pc = 0x832BE344; continue 'dispatch;
	}
	// 832BE338: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 832BE33C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BE340: 409A0098  bne cr6, 0x832be3d8
	if !ctx.cr[6].eq {
	pc = 0x832BE3D8; continue 'dispatch;
	}
	// 832BE344: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 832BE348: 57C5103A  slwi r5, r30, 2
	ctx.r[5].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BE34C: 93BF00F8  stw r29, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[29].u32 ) };
	// 832BE350: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 832BE354: 387F0108  addi r3, r31, 0x108
	ctx.r[3].s64 = ctx.r[31].s64 + 264;
	// 832BE358: 4B9EB129  bl 0x82ca9480
	ctx.lr = 0x832BE35C;
	sub_82CA9480(ctx, base);
	// 832BE35C: 811F0100  lwz r8, 0x100(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 832BE360: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BE364: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 832BE368: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 832BE36C: 9BA10058  stb r29, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u8 ) };
	// 832BE370: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 832BE374: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 832BE378: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 832BE37C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 832BE380: 38DF005C  addi r6, r31, 0x5c
	ctx.r[6].s64 = ctx.r[31].s64 + 92;
	// 832BE384: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 832BE388: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 832BE38C: 90A10064  stw r5, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 832BE390: 419A0038  beq cr6, 0x832be3c8
	if ctx.cr[6].eq {
	pc = 0x832BE3C8; continue 'dispatch;
	}
	// 832BE394: 38EB00FF  addi r7, r11, 0xff
	ctx.r[7].s64 = ctx.r[11].s64 + 255;
	// 832BE398: 39610071  addi r11, r1, 0x71
	ctx.r[11].s64 = ctx.r[1].s64 + 113;
	// 832BE39C: 392600AC  addi r9, r6, 0xac
	ctx.r[9].s64 = ctx.r[6].s64 + 172;
	// 832BE3A0: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE3A4: 7CE45038  and r4, r7, r10
	ctx.r[4].u64 = ctx.r[7].u64 & ctx.r[10].u64;
	// 832BE3A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832BE3AC: D3EB0003  stfs f31, 3(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), tmp.u32 ) };
	// 832BE3B0: 988BFFFF  stb r4, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[4].u8 ) };
	// 832BE3B4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 832BE3B8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 832BE3BC: 98AB0000  stb r5, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 832BE3C0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 832BE3C4: 4198FFDC  blt cr6, 0x832be3a0
	if ctx.cr[6].lt {
	pc = 0x832BE3A0; continue 'dispatch;
	}
	// 832BE3C8: 99010060  stb r8, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u8 ) };
	// 832BE3CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 832BE3D0: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE3D4: 4BA1AFB5  bl 0x82cd9388
	ctx.lr = 0x832BE3D8;
	sub_82CD9388(ctx, base);
	// 832BE3D8: 93DF0104  stw r30, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 832BE3DC: 57C5103A  slwi r5, r30, 2
	ctx.r[5].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BE3E0: 93BF00FC  stw r29, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[29].u32 ) };
	// 832BE3E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 832BE3E8: 387F0138  addi r3, r31, 0x138
	ctx.r[3].s64 = ctx.r[31].s64 + 312;
	// 832BE3EC: 4B9EB095  bl 0x82ca9480
	ctx.lr = 0x832BE3F0;
	sub_82CA9480(ctx, base);
	// 832BE3F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BE3F4: 419A0060  beq cr6, 0x832be454
	if ctx.cr[6].eq {
	pc = 0x832BE454; continue 'dispatch;
	}
	// 832BE3F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 832BE3FC: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 832BE400: 395F0168  addi r10, r31, 0x168
	ctx.r[10].s64 = ctx.r[31].s64 + 360;
	// 832BE404: C00B0C20  lfs f0, 0xc20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BE408: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BE40C: 419A0034  beq cr6, 0x832be440
	if ctx.cr[6].eq {
	pc = 0x832BE440; continue 'dispatch;
	}
	// 832BE410: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE414: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 832BE418: 40990008  ble cr6, 0x832be420
	if !ctx.cr[6].gt {
	pc = 0x832BE420; continue 'dispatch;
	}
	// 832BE41C: 39607FFF  li r11, 0x7fff
	ctx.r[11].s64 = 32767;
	// 832BE420: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 832BE424: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 832BE428: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 832BE42C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 832BE430: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 832BE434: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 832BE438: D14A0000  stfs f10, 0(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832BE43C: 48000008  b 0x832be444
	pc = 0x832BE444; continue 'dispatch;
	// 832BE440: D3EA0000  stfs f31, 0(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832BE444: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832BE448: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 832BE44C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BE450: 4082FFB8  bne 0x832be408
	if !ctx.cr[0].eq {
	pc = 0x832BE408; continue 'dispatch;
	}
	// 832BE454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BE458: 4BFFF849  bl 0x832bdca0
	ctx.lr = 0x832BE45C;
	sub_832BDCA0(ctx, base);
	// 832BE45C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 832BE460: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 832BE464: 4B9EAFF0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BE468 size=44
    let mut pc: u32 = 0x832BE468;
    'dispatch: loop {
        match pc {
            0x832BE468 => {
    //   block [0x832BE468..0x832BE494)
	// 832BE468: 816300D0  lwz r11, 0xd0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 832BE46C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 832BE470: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BE474: 419A0010  beq cr6, 0x832be484
	if ctx.cr[6].eq {
	pc = 0x832BE484; continue 'dispatch;
	}
	// 832BE478: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 832BE47C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BE480: 409A000C  bne cr6, 0x832be48c
	if !ctx.cr[6].eq {
	pc = 0x832BE48C; continue 'dispatch;
	}
	// 832BE484: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832BE488: 916300F8  stw r11, 0xf8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 832BE48C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BE490: 4BFFFE58  b 0x832be2e8
	sub_832BE2E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BE498 size=188
    let mut pc: u32 = 0x832BE498;
    'dispatch: loop {
        match pc {
            0x832BE498 => {
    //   block [0x832BE498..0x832BE554)
	// 832BE498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BE49C: 4B9EAF71  bl 0x82ca940c
	ctx.lr = 0x832BE4A0;
	sub_82CA93D0(ctx, base);
	// 832BE4A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BE4A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BE4A8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 832BE4AC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 832BE4B0: 419A0034  beq cr6, 0x832be4e4
	if ctx.cr[6].eq {
	pc = 0x832BE4E4; continue 'dispatch;
	}
	// 832BE4B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BE4B8: 409A0090  bne cr6, 0x832be548
	if !ctx.cr[6].eq {
	pc = 0x832BE548; continue 'dispatch;
	}
	// 832BE4BC: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 832BE4C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 832BE4C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832BE4C8: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 832BE4CC: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 832BE4D0: 93BF00D0  stw r29, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 832BE4D4: 93BF00D8  stw r29, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 832BE4D8: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 832BE4DC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 832BE4E0: 4B9EAF7C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 832BE4E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BE4E8: 419A0060  beq cr6, 0x832be548
	if ctx.cr[6].eq {
	pc = 0x832BE548; continue 'dispatch;
	}
	// 832BE4EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832BE4F0: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BE4F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BE4F8: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 832BE4FC: 3BDF005C  addi r30, r31, 0x5c
	ctx.r[30].s64 = ctx.r[31].s64 + 92;
	// 832BE500: 4BA1B091  bl 0x82cd9590
	ctx.lr = 0x832BE504;
	sub_82CD9590(ctx, base);
	// 832BE504: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BE508: 41980020  blt cr6, 0x832be528
	if ctx.cr[6].lt {
	pc = 0x832BE528; continue 'dispatch;
	}
	// 832BE50C: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 832BE510: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832BE514: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE518: 4BA1AF21  bl 0x82cd9438
	ctx.lr = 0x832BE51C;
	sub_82CD9438(ctx, base);
	// 832BE51C: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BE520: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 832BE524: 419AFFE8  beq cr6, 0x832be50c
	if ctx.cr[6].eq {
	pc = 0x832BE50C; continue 'dispatch;
	}
	// 832BE528: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 832BE52C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE530: 4BA1B179  bl 0x82cd96a8
	ctx.lr = 0x832BE534;
	sub_82CD96A8(ctx, base);
	// 832BE534: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BE538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BE53C: 80BF00BC  lwz r5, 0xbc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BE540: 4BFFF8F9  bl 0x832bde38
	ctx.lr = 0x832BE544;
	sub_832BDE38(ctx, base);
	// 832BE544: 93BF0038  stw r29, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u32 ) };
	// 832BE548: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 832BE54C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 832BE550: 4B9EAF0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BE558 size=160
    let mut pc: u32 = 0x832BE558;
    'dispatch: loop {
        match pc {
            0x832BE558 => {
    //   block [0x832BE558..0x832BE5F8)
	// 832BE558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BE55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BE560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BE564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BE568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BE56C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BE570: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 832BE574: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 832BE578: 419A0020  beq cr6, 0x832be598
	if ctx.cr[6].eq {
	pc = 0x832BE598; continue 'dispatch;
	}
	// 832BE57C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 832BE580: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BE584: 419A0054  beq cr6, 0x832be5d8
	if ctx.cr[6].eq {
	pc = 0x832BE5D8; continue 'dispatch;
	}
	// 832BE588: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BE58C: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BE590: 4BA1B001  bl 0x82cd9590
	ctx.lr = 0x832BE594;
	sub_82CD9590(ctx, base);
	// 832BE594: 48000040  b 0x832be5d4
	pc = 0x832BE5D4; continue 'dispatch;
	// 832BE598: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 832BE59C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BE5A0: 409A0020  bne cr6, 0x832be5c0
	if !ctx.cr[6].eq {
	pc = 0x832BE5C0; continue 'dispatch;
	}
	// 832BE5A4: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 832BE5A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BE5AC: 409A002C  bne cr6, 0x832be5d8
	if !ctx.cr[6].eq {
	pc = 0x832BE5D8; continue 'dispatch;
	}
	// 832BE5B0: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 832BE5B4: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 832BE5B8: 4BFFFAE1  bl 0x832be098
	ctx.lr = 0x832BE5BC;
	sub_832BE098(ctx, base);
	// 832BE5BC: 4800001C  b 0x832be5d8
	pc = 0x832BE5D8; continue 'dispatch;
	// 832BE5C0: 480024F9  bl 0x832c0ab8
	ctx.lr = 0x832BE5C4;
	sub_832C0AB8(ctx, base);
	// 832BE5C4: 907F00EC  stw r3, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[3].u32 ) };
	// 832BE5C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BE5CC: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BE5D0: 4BA1AF79  bl 0x82cd9548
	ctx.lr = 0x832BE5D4;
	sub_82CD9548(ctx, base);
	// 832BE5D4: 93DF00D4  stw r30, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[30].u32 ) };
	// 832BE5D8: 93DF00D4  stw r30, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[30].u32 ) };
	// 832BE5DC: 57C3003E  slwi r3, r30, 0
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 832BE5E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BE5E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BE5E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BE5EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BE5F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BE5F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BE5F8 size=156
    let mut pc: u32 = 0x832BE5F8;
    'dispatch: loop {
        match pc {
            0x832BE5F8 => {
    //   block [0x832BE5F8..0x832BE694)
	// 832BE5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BE5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BE600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BE604: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BE608: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BE60C: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BE610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BE614: 419A006C  beq cr6, 0x832be680
	if ctx.cr[6].eq {
	pc = 0x832BE680; continue 'dispatch;
	}
	// 832BE618: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832BE61C: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 832BE620: 4BA1AF71  bl 0x82cd9590
	ctx.lr = 0x832BE624;
	sub_82CD9590(ctx, base);
	// 832BE624: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 832BE628: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 832BE62C: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BE630: 4BA1AC81  bl 0x82cd92b0
	ctx.lr = 0x832BE634;
	sub_82CD92B0(ctx, base);
	// 832BE634: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 832BE638: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BE63C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BE640: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 832BE644: 419A002C  beq cr6, 0x832be670
	if ctx.cr[6].eq {
	pc = 0x832BE670; continue 'dispatch;
	}
	// 832BE648: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BE64C: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 832BE650: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BE654: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BE658: 409A0014  bne cr6, 0x832be66c
	if !ctx.cr[6].eq {
	pc = 0x832BE66C; continue 'dispatch;
	}
	// 832BE65C: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BE660: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BE664: 4E800421  bctrl
	ctx.lr = 0x832BE668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BE668: 48000008  b 0x832be670
	pc = 0x832BE670; continue 'dispatch;
	// 832BE66C: 4B9EDAD5  bl 0x82cac140
	ctx.lr = 0x832BE670;
	sub_82CAC140(ctx, base);
	// 832BE670: 3D408350  lis r10, -0x7cb0
	ctx.r[10].s64 = -2091909120;
	// 832BE674: 816AC494  lwz r11, -0x3b6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15212 as u32) ) } as u64;
	// 832BE678: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832BE67C: 916AC494  stw r11, -0x3b6c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-15212 as u32), ctx.r[11].u32 ) };
	// 832BE680: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832BE684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BE688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BE68C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BE690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BE698 size=624
    let mut pc: u32 = 0x832BE698;
    'dispatch: loop {
        match pc {
            0x832BE698 => {
    //   block [0x832BE698..0x832BE908)
	// 832BE698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BE69C: 4B9EAD61  bl 0x82ca93fc
	ctx.lr = 0x832BE6A0;
	sub_82CA93D0(ctx, base);
	// 832BE6A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BE6A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 832BE6A8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 832BE6AC: 38A00184  li r5, 0x184
	ctx.r[5].s64 = 388;
	// 832BE6B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BE6B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BE6B8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 832BE6BC: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 832BE6C0: 4B9EB2F1  bl 0x82ca99b0
	ctx.lr = 0x832BE6C4;
	sub_82CA99B0(ctx, base);
	// 832BE6C4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832BE6C8: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 832BE6CC: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 832BE6D0: 937F0028  stw r27, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[27].u32 ) };
	// 832BE6D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BE6D8: 939F0054  stw r28, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 832BE6DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 832BE6E0: 935F002C  stw r26, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	// 832BE6E4: 4B9EB2CD  bl 0x82ca99b0
	ctx.lr = 0x832BE6E8;
	sub_82CA99B0(ctx, base);
	// 832BE6E8: 397BFFF0  addi r11, r27, -0x10
	ctx.r[11].s64 = ctx.r[27].s64 + -16;
	// 832BE6EC: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 832BE6F0: 9B410054  stb r26, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u8 ) };
	// 832BE6F4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 832BE6F8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 832BE6FC: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 832BE700: 98E1008A  stb r7, 0x8a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(138 as u32), ctx.r[7].u8 ) };
	// 832BE704: 5548DFFE  rlwinm r8, r10, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 832BE708: 9B21008B  stb r25, 0x8b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(139 as u32), ctx.r[25].u8 ) };
	// 832BE70C: 3B5F005C  addi r26, r31, 0x5c
	ctx.r[26].s64 = ctx.r[31].s64 + 92;
	// 832BE710: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 832BE714: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 832BE718: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 832BE71C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 832BE720: 98C10050  stb r6, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u8 ) };
	// 832BE724: 4BA1B3DD  bl 0x82cd9b00
	ctx.lr = 0x832BE728;
	sub_82CD9B00(ctx, base);
	// 832BE728: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BE72C: 40980010  bge cr6, 0x832be73c
	if !ctx.cr[6].lt {
	pc = 0x832BE73C; continue 'dispatch;
	}
	// 832BE730: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BE734: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 832BE738: 4B9EAD14  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 832BE73C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 832BE740: 3940021C  li r10, 0x21c
	ctx.r[10].s64 = 540;
	// 832BE744: 811F002C  lwz r8, 0x2c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 832BE748: 392003E8  li r9, 0x3e8
	ctx.r[9].s64 = 1000;
	// 832BE74C: 7D671E70  srawi r7, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 832BE750: 80DF0024  lwz r6, 0x24(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 832BE754: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 832BE758: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 832BE75C: 7C8741D6  mullw r4, r7, r8
	ctx.r[4].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 832BE760: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 832BE764: 939F003C  stw r28, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 832BE768: 7D6431D6  mullw r11, r4, r6
	ctx.r[11].s64 = (ctx.r[4].s32 as i64) * (ctx.r[6].s32 as i64);
	// 832BE76C: 1C6B0258  mulli r3, r11, 0x258
	ctx.r[3].s64 = ctx.r[11].s64 * 600;
	// 832BE770: 7D434B96  divwu r10, r3, r9
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[9].u32;
	// 832BE774: 1D0B0032  mulli r8, r11, 0x32
	ctx.r[8].s64 = ctx.r[11].s64 * 50;
	// 832BE778: 38EA03FF  addi r7, r10, 0x3ff
	ctx.r[7].s64 = ctx.r[10].s64 + 1023;
	// 832BE77C: 7D484B96  divwu r10, r8, r9
	ctx.r[10].u32 = ctx.r[8].u32 / ctx.r[9].u32;
	// 832BE780: 54E3002A  rlwinm r3, r7, 0, 0, 0x15
	ctx.r[3].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 832BE784: 38CA00FF  addi r6, r10, 0xff
	ctx.r[6].s64 = ctx.r[10].s64 + 255;
	// 832BE788: 1C83005A  mulli r4, r3, 0x5a
	ctx.r[4].s64 = ctx.r[3].s64 * 90;
	// 832BE78C: 907F00BC  stw r3, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[3].u32 ) };
	// 832BE790: 54CA002E  rlwinm r10, r6, 0, 0, 0x17
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 832BE794: 7D242B96  divwu r9, r4, r5
	ctx.r[9].u32 = ctx.r[4].u32 / ctx.r[5].u32;
	// 832BE798: 915F00C0  stw r10, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 832BE79C: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 832BE7A0: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BE7A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BE7A8: 419A0034  beq cr6, 0x832be7dc
	if ctx.cr[6].eq {
	pc = 0x832BE7DC; continue 'dispatch;
	}
	// 832BE7AC: 813D0018  lwz r9, 0x18(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BE7B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BE7B4: 419A0028  beq cr6, 0x832be7dc
	if ctx.cr[6].eq {
	pc = 0x832BE7DC; continue 'dispatch;
	}
	// 832BE7B8: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BE7BC: 79270020  clrldi r7, r9, 0x20
	ctx.r[7].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 832BE7C0: 79660020  clrldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 832BE7C4: 7CA839D2  mulld r5, r8, r7
	ctx.r[5].s64 = ctx.r[8].s64 * ctx.r[7].s64;
	// 832BE7C8: 7C8531D2  mulld r4, r5, r6
	ctx.r[4].s64 = ctx.r[5].s64 * ctx.r[6].s64;
	// 832BE7CC: 794B0020  clrldi r11, r10, 0x20
	ctx.r[11].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 832BE7D0: 7D445B92  divdu r10, r4, r11
	ctx.r[10].u64 = ctx.r[4].u64 / ctx.r[11].u64;
	// 832BE7D4: 555E003E  slwi r30, r10, 0
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 832BE7D8: 48000008  b 0x832be7e0
	pc = 0x832BE7E0; continue 'dispatch;
	// 832BE7DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 832BE7E0: 4B92B5B1  bl 0x82be9d90
	ctx.lr = 0x832BE7E4;
	sub_82BE9D90(ctx, base);
	// 832BE7E4: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 832BE7E8: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 832BE7EC: 907F00B8  stw r3, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[3].u32 ) };
	// 832BE7F0: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 832BE7F4: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 832BE7F8: 409A000C  bne cr6, 0x832be804
	if !ctx.cr[6].eq {
	pc = 0x832BE804; continue 'dispatch;
	}
	// 832BE7FC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BE800: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 832BE804: 39607FFF  li r11, 0x7fff
	ctx.r[11].s64 = 32767;
	// 832BE808: 939F0100  stw r28, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[28].u32 ) };
	// 832BE80C: 2F1B0010  cmpwi cr6, r27, 0x10
	ctx.cr[6].compare_i32(ctx.r[27].s32, 16, &mut ctx.xer);
	// 832BE810: 939F0104  stw r28, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[28].u32 ) };
	// 832BE814: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 832BE818: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 832BE81C: 409A000C  bne cr6, 0x832be828
	if !ctx.cr[6].eq {
	pc = 0x832BE828; continue 'dispatch;
	}
	// 832BE820: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 832BE824: 4800000C  b 0x832be830
	pc = 0x832BE830; continue 'dispatch;
	// 832BE828: 3D608080  lis r11, -0x7f80
	ctx.r[11].s64 = -2139095040;
	// 832BE82C: 616B8080  ori r11, r11, 0x8080
	ctx.r[11].u64 = ctx.r[11].u64 | 32896;
	// 832BE830: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 832BE834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BE838: 4BFFF469  bl 0x832bdca0
	ctx.lr = 0x832BE83C;
	sub_832BDCA0(ctx, base);
	// 832BE83C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BE840: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 832BE844: 80BF00BC  lwz r5, 0xbc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BE848: 4BFFF5F1  bl 0x832bde38
	ctx.lr = 0x832BE84C;
	sub_832BDE38(ctx, base);
	// 832BE84C: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 832BE850: 939F00D8  stw r28, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[28].u32 ) };
	// 832BE854: 939F00D0  stw r28, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[28].u32 ) };
	// 832BE858: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BE85C: 40980008  bge cr6, 0x832be864
	if !ctx.cr[6].lt {
	pc = 0x832BE864; continue 'dispatch;
	}
	// 832BE860: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 832BE864: 3D408350  lis r10, -0x7cb0
	ctx.r[10].s64 = -2091909120;
	// 832BE868: 917F00E0  stw r11, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 832BE86C: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 832BE870: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 832BE874: 3D00832C  lis r8, -0x7cd4
	ctx.r[8].s64 = -2094268416;
	// 832BE878: 939F00D4  stw r28, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 832BE87C: 3CE0832C  lis r7, -0x7cd4
	ctx.r[7].s64 = -2094268416;
	// 832BE880: 933F0038  stw r25, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[25].u32 ) };
	// 832BE884: 3929DEA0  addi r9, r9, -0x2160
	ctx.r[9].s64 = ctx.r[9].s64 + -8544;
	// 832BE888: 3908E060  addi r8, r8, -0x1fa0
	ctx.r[8].s64 = ctx.r[8].s64 + -8096;
	// 832BE88C: 816AC494  lwz r11, -0x3b6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15212 as u32) ) } as u64;
	// 832BE890: 38E7E238  addi r7, r7, -0x1dc8
	ctx.r[7].s64 = ctx.r[7].s64 + -7624;
	// 832BE894: 913F015C  stw r9, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[9].u32 ) };
	// 832BE898: 3C60832C  lis r3, -0x7cd4
	ctx.r[3].s64 = -2094268416;
	// 832BE89C: 911F0160  stw r8, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[8].u32 ) };
	// 832BE8A0: 3CC0832C  lis r6, -0x7cd4
	ctx.r[6].s64 = -2094268416;
	// 832BE8A4: 90FF0164  stw r7, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[7].u32 ) };
	// 832BE8A8: 3CA0832C  lis r5, -0x7cd4
	ctx.r[5].s64 = -2094268416;
	// 832BE8AC: 3C80832C  lis r4, -0x7cd4
	ctx.r[4].s64 = -2094268416;
	// 832BE8B0: 3FC0832C  lis r30, -0x7cd4
	ctx.r[30].s64 = -2094268416;
	// 832BE8B4: 3FA0832C  lis r29, -0x7cd4
	ctx.r[29].s64 = -2094268416;
	// 832BE8B8: 3F80832C  lis r28, -0x7cd4
	ctx.r[28].s64 = -2094268416;
	// 832BE8BC: 3863E498  addi r3, r3, -0x1b68
	ctx.r[3].s64 = ctx.r[3].s64 + -7016;
	// 832BE8C0: 38C6E2B8  addi r6, r6, -0x1d48
	ctx.r[6].s64 = ctx.r[6].s64 + -7496;
	// 832BE8C4: 38A5E2D0  addi r5, r5, -0x1d30
	ctx.r[5].s64 = ctx.r[5].s64 + -7472;
	// 832BE8C8: 907F0174  stw r3, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[3].u32 ) };
	// 832BE8CC: 3884E558  addi r4, r4, -0x1aa8
	ctx.r[4].s64 = ctx.r[4].s64 + -6824;
	// 832BE8D0: 90DF0168  stw r6, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[6].u32 ) };
	// 832BE8D4: 393EE5F8  addi r9, r30, -0x1a08
	ctx.r[9].s64 = ctx.r[30].s64 + -6664;
	// 832BE8D8: 90BF016C  stw r5, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[5].u32 ) };
	// 832BE8DC: 391DE468  addi r8, r29, -0x1b98
	ctx.r[8].s64 = ctx.r[29].s64 + -7064;
	// 832BE8E0: 909F0170  stw r4, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[4].u32 ) };
	// 832BE8E4: 38FCE2E8  addi r7, r28, -0x1d18
	ctx.r[7].s64 = ctx.r[28].s64 + -7448;
	// 832BE8E8: 913F0178  stw r9, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[9].u32 ) };
	// 832BE8EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832BE8F0: 911F017C  stw r8, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[8].u32 ) };
	// 832BE8F4: 90FF0180  stw r7, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[7].u32 ) };
	// 832BE8F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BE8FC: 916AC494  stw r11, -0x3b6c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-15212 as u32), ctx.r[11].u32 ) };
	// 832BE900: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 832BE904: 4B9EAB48  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BE908 size=12
    let mut pc: u32 = 0x832BE908;
    'dispatch: loop {
        match pc {
            0x832BE908 => {
    //   block [0x832BE908..0x832BE914)
	// 832BE908: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 832BE90C: 386BE698  addi r3, r11, -0x1968
	ctx.r[3].s64 = ctx.r[11].s64 + -6504;
	// 832BE910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BE918 size=40
    let mut pc: u32 = 0x832BE918;
    'dispatch: loop {
        match pc {
            0x832BE918 => {
    //   block [0x832BE918..0x832BE940)
	// 832BE918: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 832BE91C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BE920: 419A0048  beq cr6, 0x832be968
	if ctx.cr[6].eq {
		sub_832BE940(ctx, base);
		return;
	}
	// 832BE924: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BE928: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 832BE92C: 409A0014  bne cr6, 0x832be940
	if !ctx.cr[6].eq {
		sub_832BE940(ctx, base);
		return;
	}
	// 832BE930: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE934: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BE938: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 832BE93C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BE940 size=48
    let mut pc: u32 = 0x832BE940;
    'dispatch: loop {
        match pc {
            0x832BE940 => {
    //   block [0x832BE940..0x832BE970)
	// 832BE940: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE944: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BE948: 419A0020  beq cr6, 0x832be968
	if ctx.cr[6].eq {
	pc = 0x832BE968; continue 'dispatch;
	}
	// 832BE94C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE950: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 832BE954: 419A001C  beq cr6, 0x832be970
	if ctx.cr[6].eq {
		sub_832BE970(ctx, base);
		return;
	}
	// 832BE958: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE95C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 832BE960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BE964: 409AFFE8  bne cr6, 0x832be94c
	if !ctx.cr[6].eq {
	pc = 0x832BE94C; continue 'dispatch;
	}
	// 832BE968: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BE96C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832BE970 size=16
    let mut pc: u32 = 0x832BE970;
    'dispatch: loop {
        match pc {
            0x832BE970 => {
    //   block [0x832BE970..0x832BE980)
	// 832BE970: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BE974: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 832BE978: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832BE97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BE980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BE980 size=168
    let mut pc: u32 = 0x832BE980;
    'dispatch: loop {
        match pc {
            0x832BE980 => {
    //   block [0x832BE980..0x832BEA28)
	// 832BE980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BE984: 4B9EAA89  bl 0x82ca940c
	ctx.lr = 0x832BE988;
	sub_82CA93D0(ctx, base);
	// 832BE988: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BE98C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 832BE990: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 832BE994: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BE998: 409A0020  bne cr6, 0x832be9b8
	if !ctx.cr[6].eq {
	pc = 0x832BE9B8; continue 'dispatch;
	}
	// 832BE99C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BE9A0: 419A0080  beq cr6, 0x832bea20
	if ctx.cr[6].eq {
	pc = 0x832BEA20; continue 'dispatch;
	}
	// 832BE9A4: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BE9A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BE9AC: 4AED801D  bl 0x821969c8
	ctx.lr = 0x832BE9B0;
	sub_821969C8(ctx, base);
	// 832BE9B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832BE9B4: 4B9EAAA8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 832BE9B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BE9BC: 409A0018  bne cr6, 0x832be9d4
	if !ctx.cr[6].eq {
	pc = 0x832BE9D4; continue 'dispatch;
	}
	// 832BE9C0: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BE9C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BE9C8: 4AED8001  bl 0x821969c8
	ctx.lr = 0x832BE9CC;
	sub_821969C8(ctx, base);
	// 832BE9CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832BE9D0: 4B9EAA8C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 832BE9D4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 832BE9D8: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 832BE9DC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 832BE9E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BE9E4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 832BE9E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832BE9EC: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 832BE9F0: 4AEBB921  bl 0x8217a310
	ctx.lr = 0x832BE9F4;
	sub_8217A310(ctx, base);
	// 832BE9F4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 832BE9F8: 4198001C  blt cr6, 0x832bea14
	if ctx.cr[6].lt {
	pc = 0x832BEA14; continue 'dispatch;
	}
	// 832BE9FC: 409A0024  bne cr6, 0x832bea20
	if !ctx.cr[6].eq {
	pc = 0x832BEA20; continue 'dispatch;
	}
	// 832BEA00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 832BEA04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BEA08: 4AED7FC1  bl 0x821969c8
	ctx.lr = 0x832BEA0C;
	sub_821969C8(ctx, base);
	// 832BEA0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832BEA10: 4B9EAA4C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 832BEA14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 832BEA18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BEA1C: 4AED7FAD  bl 0x821969c8
	ctx.lr = 0x832BEA20;
	sub_821969C8(ctx, base);
	// 832BEA20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832BEA24: 4B9EAA38  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BEA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BEA28 size=384
    let mut pc: u32 = 0x832BEA28;
    'dispatch: loop {
        match pc {
            0x832BEA28 => {
    //   block [0x832BEA28..0x832BEBA8)
	// 832BEA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BEA2C: 4B9EA9DD  bl 0x82ca9408
	ctx.lr = 0x832BEA30;
	sub_82CA93D0(ctx, base);
	// 832BEA30: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BEA34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 832BEA38: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832BEA3C: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BEA40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832BEA44: 917C001C  stw r11, 0x1c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 832BEA48: 83FC0018  lwz r31, 0x18(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BEA4C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 832BEA50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BEA54: 419A00A8  beq cr6, 0x832beafc
	if ctx.cr[6].eq {
	pc = 0x832BEAFC; continue 'dispatch;
	}
	// 832BEA58: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BEA5C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 832BEA60: 409A0140  bne cr6, 0x832beba0
	if !ctx.cr[6].eq {
	pc = 0x832BEBA0; continue 'dispatch;
	}
	// 832BEA64: 809C001C  lwz r4, 0x1c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BEA68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BEA6C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 832BEA70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832BEA74: 4E800421  bctrl
	ctx.lr = 0x832BEA78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BEA78: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 832BEA7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BEA80: 419A0070  beq cr6, 0x832beaf0
	if ctx.cr[6].eq {
	pc = 0x832BEAF0; continue 'dispatch;
	}
	// 832BEA84: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BEA88: 409A0010  bne cr6, 0x832bea98
	if !ctx.cr[6].eq {
	pc = 0x832BEA98; continue 'dispatch;
	}
	// 832BEA8C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 832BEA90: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 832BEA94: 4800005C  b 0x832beaf0
	pc = 0x832BEAF0; continue 'dispatch;
	// 832BEA98: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BEA9C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BEAA0: 41980010  blt cr6, 0x832beab0
	if ctx.cr[6].lt {
	pc = 0x832BEAB0; continue 'dispatch;
	}
	// 832BEAA4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 832BEAA8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 832BEAAC: 48000044  b 0x832beaf0
	pc = 0x832BEAF0; continue 'dispatch;
	// 832BEAB0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BEAB4: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	// 832BEAB8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 832BEABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BEAC0: 419A0028  beq cr6, 0x832beae8
	if ctx.cr[6].eq {
	pc = 0x832BEAE8; continue 'dispatch;
	}
	// 832BEAC4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BEAC8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BEACC: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832BEAD0: 409800C4  bge cr6, 0x832beb94
	if !ctx.cr[6].lt {
	pc = 0x832BEB94; continue 'dispatch;
	}
	// 832BEAD4: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BEAD8: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 832BEADC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 832BEAE0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 832BEAE4: 409AFFE0  bne cr6, 0x832beac4
	if !ctx.cr[6].eq {
	pc = 0x832BEAC4; continue 'dispatch;
	}
	// 832BEAE8: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 832BEAEC: 93E90008  stw r31, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 832BEAF0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BEAF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BEAF8: 409AFF60  bne cr6, 0x832bea58
	if !ctx.cr[6].eq {
	pc = 0x832BEA58; continue 'dispatch;
	}
	// 832BEAFC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 832BEB00: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 832BEB04: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BEB08: 419A0098  beq cr6, 0x832beba0
	if ctx.cr[6].eq {
	pc = 0x832BEBA0; continue 'dispatch;
	}
	// 832BEB0C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 832BEB10: 2B0A0040  cmplwi cr6, r10, 0x40
	ctx.cr[6].compare_u32(ctx.r[10].u32, 64 as u32, &mut ctx.xer);
	// 832BEB14: 4098002C  bge cr6, 0x832beb40
	if !ctx.cr[6].lt {
	pc = 0x832BEB40; continue 'dispatch;
	}
	// 832BEB18: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BEB1C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 832BEB20: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 832BEB24: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 832BEB28: 7D2A412E  stwx r9, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 832BEB2C: 7D6A392E  stwx r11, r10, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 832BEB30: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BEB34: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BEB38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BEB3C: 409AFFD4  bne cr6, 0x832beb10
	if !ctx.cr[6].eq {
	pc = 0x832BEB10; continue 'dispatch;
	}
	// 832BEB40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BEB44: 419A005C  beq cr6, 0x832beba0
	if ctx.cr[6].eq {
	pc = 0x832BEBA0; continue 'dispatch;
	}
	// 832BEB48: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 832BEB4C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BEB50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832BEB54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BEB58: 4AEBB7B9  bl 0x8217a310
	ctx.lr = 0x832BEB5C;
	sub_8217A310(ctx, base);
	// 832BEB5C: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 832BEB60: 4098FEE8  bge cr6, 0x832bea48
	if !ctx.cr[6].lt {
	pc = 0x832BEA48; continue 'dispatch;
	}
	// 832BEB64: 547F103A  slwi r31, r3, 2
	ctx.r[31].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 832BEB68: 809C001C  lwz r4, 0x1c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BEB6C: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 832BEB70: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 832BEB74: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 832BEB78: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BEB7C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832BEB80: 4E800421  bctrl
	ctx.lr = 0x832BEB84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BEB84: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 832BEB88: 7C7F402E  lwzx r3, r31, r8
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 832BEB8C: 4BD4CE35  bl 0x8300b9c0
	ctx.lr = 0x832BEB90;
	sub_8300B9C0(ctx, base);
	// 832BEB90: 4BFFFEB8  b 0x832bea48
	pc = 0x832BEA48; continue 'dispatch;
	// 832BEB94: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BEB98: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 832BEB9C: 4BFFFF50  b 0x832beaec
	pc = 0x832BEAEC; continue 'dispatch;
	// 832BEBA0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 832BEBA4: 4B9EA8B4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BEBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BEBA8 size=168
    let mut pc: u32 = 0x832BEBA8;
    'dispatch: loop {
        match pc {
            0x832BEBA8 => {
    //   block [0x832BEBA8..0x832BEC50)
	// 832BEBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BEBAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BEBB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BEBB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BEBB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BEBBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BEBC0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BEBC4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BEBC8: 4AED7E01  bl 0x821969c8
	ctx.lr = 0x832BEBCC;
	sub_821969C8(ctx, base);
	// 832BEBCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BEBD0: 419A0030  beq cr6, 0x832bec00
	if ctx.cr[6].eq {
	pc = 0x832BEC00; continue 'dispatch;
	}
	// 832BEBD4: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 832BEBD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832BEBDC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BEBE0: 4AED7DE9  bl 0x821969c8
	ctx.lr = 0x832BEBE4;
	sub_821969C8(ctx, base);
	// 832BEBE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BEBE8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 832BEBEC: 419A0030  beq cr6, 0x832bec1c
	if ctx.cr[6].eq {
	pc = 0x832BEC1C; continue 'dispatch;
	}
	// 832BEBF0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 832BEBF4: 409A003C  bne cr6, 0x832bec30
	if !ctx.cr[6].eq {
	pc = 0x832BEC30; continue 'dispatch;
	}
	// 832BEBF8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BEBFC: 4BD4CDC5  bl 0x8300b9c0
	ctx.lr = 0x832BEC00;
	sub_8300B9C0(ctx, base);
	// 832BEC00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BEC04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BEC08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BEC0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BEC10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BEC14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BEC18: 4E800020  blr
	return;
	// 832BEC1C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BEC20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BEC24: 419A000C  beq cr6, 0x832bec30
	if ctx.cr[6].eq {
	pc = 0x832BEC30; continue 'dispatch;
	}
	// 832BEC28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BEC2C: 4BFFFDFD  bl 0x832bea28
	ctx.lr = 0x832BEC30;
	sub_832BEA28(ctx, base);
	// 832BEC30: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BEC34: 4BD4CD8D  bl 0x8300b9c0
	ctx.lr = 0x832BEC38;
	sub_8300B9C0(ctx, base);
	// 832BEC38: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BEC3C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BEC40: 4AED7D89  bl 0x821969c8
	ctx.lr = 0x832BEC44;
	sub_821969C8(ctx, base);
	// 832BEC44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832BEC48: 409AFF90  bne cr6, 0x832bebd8
	if !ctx.cr[6].eq {
	pc = 0x832BEBD8; continue 'dispatch;
	}
	// 832BEC4C: 4BFFFFB4  b 0x832bec00
	pc = 0x832BEC00; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BEC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BEC50 size=312
    let mut pc: u32 = 0x832BEC50;
    'dispatch: loop {
        match pc {
            0x832BEC50 => {
    //   block [0x832BEC50..0x832BED88)
	// 832BEC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BEC54: 4B9EA7B5  bl 0x82ca9408
	ctx.lr = 0x832BEC58;
	sub_82CA93D0(ctx, base);
	// 832BEC58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BEC5C: 3D408350  lis r10, -0x7cb0
	ctx.r[10].s64 = -2091909120;
	// 832BEC60: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832BEC64: 3BAAC474  addi r29, r10, -0x3b8c
	ctx.r[29].s64 = ctx.r[10].s64 + -15244;
	// 832BEC68: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 832BEC6C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 832BEC70: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BEC74: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BEC78: 419A0020  beq cr6, 0x832bec98
	if ctx.cr[6].eq {
	pc = 0x832BEC98; continue 'dispatch;
	}
	// 832BEC7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832BEC80: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BEC84: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 832BEC88: 4198FFE8  blt cr6, 0x832bec70
	if ctx.cr[6].lt {
	pc = 0x832BEC70; continue 'dispatch;
	}
	// 832BEC8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BEC90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832BEC94: 4B9EA7C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 832BEC98: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BEC9C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 832BECA0: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 832BECA4: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832BECA8: 3BCA67B0  addi r30, r10, 0x67b0
	ctx.r[30].s64 = ctx.r[10].s64 + 26544;
	// 832BECAC: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BECB0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 832BECB4: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 832BECB8: 7D07E92E  stwx r8, r7, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	// 832BECBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BECC0: 419A0084  beq cr6, 0x832bed44
	if ctx.cr[6].eq {
	pc = 0x832BED44; continue 'dispatch;
	}
	// 832BECC4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BECC8: 40980008  bge cr6, 0x832becd0
	if !ctx.cr[6].lt {
	pc = 0x832BECD0; continue 'dispatch;
	}
	// 832BECCC: 7C6300D0  neg r3, r3
	ctx.r[3].s64 = -ctx.r[3].s64;
	// 832BECD0: 396003E8  li r11, 0x3e8
	ctx.r[11].s64 = 1000;
	// 832BECD4: 911F001C  stw r8, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 832BECD8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 832BECDC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 832BECE0: 7D2B1BD6  divw r9, r11, r3
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[3].s32;
	// 832BECE4: 939F0018  stw r28, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 832BECE8: 939F0020  stw r28, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 832BECEC: 3C800000  lis r4, 0
	ctx.r[4].s64 = 0;
	// 832BECF0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 832BECF4: 391F0010  addi r8, r31, 0x10
	ctx.r[8].s64 = ctx.r[31].s64 + 16;
	// 832BECF8: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 832BECFC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 832BED00: 38AAEBA8  addi r5, r10, -0x1458
	ctx.r[5].s64 = ctx.r[10].s64 + -5208;
	// 832BED04: 60848000  ori r4, r4, 0x8000
	ctx.r[4].u64 = ctx.r[4].u64 | 32768;
	// 832BED08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BED0C: 4BA04F0D  bl 0x82cc3c18
	ctx.lr = 0x832BED10;
	sub_82CC3C18(ctx, base);
	// 832BED10: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 832BED14: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 832BED18: 4BA03959  bl 0x82cc2670
	ctx.lr = 0x832BED1C;
	sub_82CC2670(ctx, base);
	// 832BED1C: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BED20: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 832BED24: 409A002C  bne cr6, 0x832bed50
	if !ctx.cr[6].eq {
	pc = 0x832BED50; continue 'dispatch;
	}
	// 832BED28: 39600024  li r11, 0x24
	ctx.r[11].s64 = 36;
	// 832BED2C: 7D5EF850  subf r10, r30, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 832BED30: 7D6A5BD6  divw r11, r10, r11
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	// 832BED34: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 832BED38: 4098000C  bge cr6, 0x832bed44
	if !ctx.cr[6].lt {
	pc = 0x832BED44; continue 'dispatch;
	}
	// 832BED3C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BED40: 7F8BE92E  stwx r28, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[28].u32) };
	// 832BED44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BED48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832BED4C: 4B9EA70C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 832BED50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BED54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BED58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BED5C: 4BD4CBDD  bl 0x8300b938
	ctx.lr = 0x832BED60;
	sub_8300B938(ctx, base);
	// 832BED60: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 832BED64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 832BED68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BED6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BED70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BED74: 4BA03F6D  bl 0x82cc2ce0
	ctx.lr = 0x832BED78;
	sub_82CC2CE0(ctx, base);
	// 832BED78: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 832BED7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BED80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832BED84: 4B9EA6D4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BED88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BED88 size=104
    let mut pc: u32 = 0x832BED88;
    'dispatch: loop {
        match pc {
            0x832BED88 => {
    //   block [0x832BED88..0x832BEDF0)
	// 832BED88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BED8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BED90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BED94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BED98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BED9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 832BEDA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BEDA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BEDA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BEDAC: 90BE0010  stw r5, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 832BEDB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BEDB4: 90DE0014  stw r6, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 832BEDB8: 4BD4CB81  bl 0x8300b938
	ctx.lr = 0x832BEDBC;
	sub_8300B938(ctx, base);
	// 832BEDBC: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 832BEDC0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BEDC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BEDC8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BEDCC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 832BEDD0: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 832BEDD4: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 832BEDD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BEDDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BEDE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BEDE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BEDE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BEDEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BEDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BEDF0 size=168
    let mut pc: u32 = 0x832BEDF0;
    'dispatch: loop {
        match pc {
            0x832BEDF0 => {
    //   block [0x832BEDF0..0x832BEE98)
	// 832BEDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BEDF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BEDF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BEDFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BEE00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BEE04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BEE08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 832BEE0C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BEE10: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BEE14: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 832BEE18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BEE1C: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 832BEE20: 409A0024  bne cr6, 0x832bee44
	if !ctx.cr[6].eq {
	pc = 0x832BEE44; continue 'dispatch;
	}
	// 832BEE24: 48000075  bl 0x832bee98
	ctx.lr = 0x832BEE28;
	sub_832BEE98(ctx, base);
	// 832BEE28: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BEE2C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BEE30: 4AED7B99  bl 0x821969c8
	ctx.lr = 0x832BEE34;
	sub_821969C8(ctx, base);
	// 832BEE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BEE38: 480000D9  bl 0x832bef10
	ctx.lr = 0x832BEE3C;
	sub_832BEF10(ctx, base);
	// 832BEE3C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 832BEE40: 4800002C  b 0x832bee6c
	pc = 0x832BEE6C; continue 'dispatch;
	// 832BEE44: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 832BEE48: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BEE4C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 832BEE50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BEE54: 4AED7B75  bl 0x821969c8
	ctx.lr = 0x832BEE58;
	sub_821969C8(ctx, base);
	// 832BEE58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 832BEE5C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BEE60: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832BEE64: 4BD4CB5D  bl 0x8300b9c0
	ctx.lr = 0x832BEE68;
	sub_8300B9C0(ctx, base);
	// 832BEE68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 832BEE6C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BEE70: 4BA03941  bl 0x82cc27b0
	ctx.lr = 0x832BEE74;
	sub_82CC27B0(ctx, base);
	// 832BEE74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832BEE78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BEE7C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832BEE80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BEE84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BEE88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BEE8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BEE90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BEE94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BEE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BEE98 size=116
    let mut pc: u32 = 0x832BEE98;
    'dispatch: loop {
        match pc {
            0x832BEE98 => {
    //   block [0x832BEE98..0x832BEF0C)
	// 832BEE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BEE9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BEEA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832BEEA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BEEA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BEEAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BEEB0: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BEEB4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BEEB8: 4B00A4D1  bl 0x822c9388
	ctx.lr = 0x832BEEBC;
	sub_822C9388(ctx, base);
	// 832BEEBC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 832BEEC0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BEEC4: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 832BEEC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BEECC: 4BA035F5  bl 0x82cc24c0
	ctx.lr = 0x832BEED0;
	sub_82CC24C0(ctx, base);
	// 832BEED0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832BEED4: 419A0018  beq cr6, 0x832beeec
	if ctx.cr[6].eq {
	pc = 0x832BEEEC; continue 'dispatch;
	}
	// 832BEED8: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 832BEEDC: 409A0018  bne cr6, 0x832beef4
	if !ctx.cr[6].eq {
	pc = 0x832BEEF4; continue 'dispatch;
	}
	// 832BEEE0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BEEE4: 4BD4CADD  bl 0x8300b9c0
	ctx.lr = 0x832BEEE8;
	sub_8300B9C0(ctx, base);
	// 832BEEE8: 4800000C  b 0x832beef4
	pc = 0x832BEEF4; continue 'dispatch;
	// 832BEEEC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BEEF0: 4BA08F79  bl 0x82cc7e68
	ctx.lr = 0x832BEEF4;
	sub_82CC7E68(ctx, base);
	// 832BEEF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832BEEF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BEEFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BEF00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832BEF04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BEF08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BEF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BEF10 size=112
    let mut pc: u32 = 0x832BEF10;
    'dispatch: loop {
        match pc {
            0x832BEF10 => {
    //   block [0x832BEF10..0x832BEF80)
	// 832BEF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BEF14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832BEF18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832BEF1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BEF20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BEF24: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BEF28: 4BA03889  bl 0x82cc27b0
	ctx.lr = 0x832BEF2C;
	sub_82CC27B0(ctx, base);
	// 832BEF2C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BEF30: 4BA03881  bl 0x82cc27b0
	ctx.lr = 0x832BEF34;
	sub_82CC27B0(ctx, base);
	// 832BEF34: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BEF38: 4BA03879  bl 0x82cc27b0
	ctx.lr = 0x832BEF3C;
	sub_82CC27B0(ctx, base);
	// 832BEF3C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832BEF40: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 832BEF44: 392B67B0  addi r9, r11, 0x67b0
	ctx.r[9].s64 = ctx.r[11].s64 + 26544;
	// 832BEF48: 7D09F850  subf r8, r9, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 832BEF4C: 7D6853D6  divw r11, r8, r10
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	// 832BEF50: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 832BEF54: 40980018  bge cr6, 0x832bef6c
	if !ctx.cr[6].lt {
	pc = 0x832BEF6C; continue 'dispatch;
	}
	// 832BEF58: 3D408350  lis r10, -0x7cb0
	ctx.r[10].s64 = -2091909120;
	// 832BEF5C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BEF60: 390AC474  addi r8, r10, -0x3b8c
	ctx.r[8].s64 = ctx.r[10].s64 + -15244;
	// 832BEF64: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 832BEF68: 7CE9412E  stwx r7, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u32) };
	// 832BEF6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832BEF70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832BEF74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832BEF78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832BEF7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BEF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BEF80 size=532
    let mut pc: u32 = 0x832BEF80;
    'dispatch: loop {
        match pc {
            0x832BEF80 => {
    //   block [0x832BEF80..0x832BF194)
	// 832BEF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BEF84: 4B9EA47D  bl 0x82ca9400
	ctx.lr = 0x832BEF88;
	sub_82CA93D0(ctx, base);
	// 832BEF88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BEF8C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 832BEF90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BEF94: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 832BEF98: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 832BEF9C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 832BEFA0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 832BEFA4: 4BFFF975  bl 0x832be918
	ctx.lr = 0x832BEFA8;
	sub_832BE918(ctx, base);
	// 832BEFA8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 832BEFAC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BEFB0: 419A0008  beq cr6, 0x832befb8
	if ctx.cr[6].eq {
	pc = 0x832BEFB8; continue 'dispatch;
	}
	// 832BEFB4: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 832BEFB8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 832BEFBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BEFC0: 4BFFF959  bl 0x832be918
	ctx.lr = 0x832BEFC4;
	sub_832BE918(ctx, base);
	// 832BEFC4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832BEFC8: 419A0008  beq cr6, 0x832befd0
	if ctx.cr[6].eq {
	pc = 0x832BEFD0; continue 'dispatch;
	}
	// 832BEFCC: 61080002  ori r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u64 | 2;
	// 832BEFD0: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 832BEFD4: 419A01A8  beq cr6, 0x832bf17c
	if ctx.cr[6].eq {
	pc = 0x832BF17C; continue 'dispatch;
	}
	// 832BEFD8: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 832BEFDC: 419A0184  beq cr6, 0x832bf160
	if ctx.cr[6].eq {
	pc = 0x832BF160; continue 'dispatch;
	}
	// 832BEFE0: 2F080003  cmpwi cr6, r8, 3
	ctx.cr[6].compare_i32(ctx.r[8].s32, 3, &mut ctx.xer);
	// 832BEFE4: 419A0010  beq cr6, 0x832beff4
	if ctx.cr[6].eq {
	pc = 0x832BEFF4; continue 'dispatch;
	}
	// 832BEFE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BEFEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832BEFF0: 4B9EA460  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 832BEFF4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BEFF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832BEFFC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 832BF000: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BF004: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 832BF008: 915E0020  stw r10, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 832BF00C: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BF010: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BF014: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BF018: 409A0074  bne cr6, 0x832bf08c
	if !ctx.cr[6].eq {
	pc = 0x832BF08C; continue 'dispatch;
	}
	// 832BF01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BF020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BF024: 409A0034  bne cr6, 0x832bf058
	if !ctx.cr[6].eq {
	pc = 0x832BF058; continue 'dispatch;
	}
	// 832BF028: 4BFFFE71  bl 0x832bee98
	ctx.lr = 0x832BF02C;
	sub_832BEE98(ctx, base);
	// 832BF02C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BF030: 4BFFFE69  bl 0x832bee98
	ctx.lr = 0x832BF034;
	sub_832BEE98(ctx, base);
	// 832BF034: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BF038: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BF03C: 4BFFF945  bl 0x832be980
	ctx.lr = 0x832BF040;
	sub_832BE980(ctx, base);
	// 832BF040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BF044: 4BFFFECD  bl 0x832bef10
	ctx.lr = 0x832BF048;
	sub_832BEF10(ctx, base);
	// 832BF048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BF04C: 4BFFFEC5  bl 0x832bef10
	ctx.lr = 0x832BF050;
	sub_832BEF10(ctx, base);
	// 832BF050: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 832BF054: 480000E8  b 0x832bf13c
	pc = 0x832BF13C; continue 'dispatch;
	// 832BF058: 4BFFFE41  bl 0x832bee98
	ctx.lr = 0x832BF05C;
	sub_832BEE98(ctx, base);
	// 832BF05C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 832BF060: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BF064: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BF068: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BF06C: 4BFFF915  bl 0x832be980
	ctx.lr = 0x832BF070;
	sub_832BE980(ctx, base);
	// 832BF070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BF074: 4BFFFE9D  bl 0x832bef10
	ctx.lr = 0x832BF078;
	sub_832BEF10(ctx, base);
	// 832BF078: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832BF07C: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BF080: 4BD4C941  bl 0x8300b9c0
	ctx.lr = 0x832BF084;
	sub_8300B9C0(ctx, base);
	// 832BF084: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 832BF088: 480000B4  b 0x832bf13c
	pc = 0x832BF13C; continue 'dispatch;
	// 832BF08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BF090: 409A003C  bne cr6, 0x832bf0cc
	if !ctx.cr[6].eq {
	pc = 0x832BF0CC; continue 'dispatch;
	}
	// 832BF094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BF098: 4BFFFE01  bl 0x832bee98
	ctx.lr = 0x832BF09C;
	sub_832BEE98(ctx, base);
	// 832BF09C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 832BF0A0: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BF0A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BF0A8: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BF0AC: 4BFFF8D5  bl 0x832be980
	ctx.lr = 0x832BF0B0;
	sub_832BE980(ctx, base);
	// 832BF0B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BF0B4: 4BFFFE5D  bl 0x832bef10
	ctx.lr = 0x832BF0B8;
	sub_832BEF10(ctx, base);
	// 832BF0B8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832BF0BC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BF0C0: 4BD4C901  bl 0x8300b9c0
	ctx.lr = 0x832BF0C4;
	sub_8300B9C0(ctx, base);
	// 832BF0C4: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 832BF0C8: 48000074  b 0x832bf13c
	pc = 0x832BF13C; continue 'dispatch;
	// 832BF0CC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 832BF0D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BF0D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BF0D8: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BF0DC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BF0E0: 4BFFF8A1  bl 0x832be980
	ctx.lr = 0x832BF0E4;
	sub_832BE980(ctx, base);
	// 832BF0E4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 832BF0E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BF0EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BF0F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF0F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BF0F8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832BF0FC: 409A0010  bne cr6, 0x832bf10c
	if !ctx.cr[6].eq {
	pc = 0x832BF10C; continue 'dispatch;
	}
	// 832BF100: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BF104: 4BA08D65  bl 0x82cc7e68
	ctx.lr = 0x832BF108;
	sub_82CC7E68(ctx, base);
	// 832BF108: 4800000C  b 0x832bf114
	pc = 0x832BF114; continue 'dispatch;
	// 832BF10C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BF110: 4BD4C8B1  bl 0x8300b9c0
	ctx.lr = 0x832BF114;
	sub_8300B9C0(ctx, base);
	// 832BF114: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF118: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832BF11C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BF120: 409A0010  bne cr6, 0x832bf130
	if !ctx.cr[6].eq {
	pc = 0x832BF130; continue 'dispatch;
	}
	// 832BF124: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BF128: 4BA08D41  bl 0x82cc7e68
	ctx.lr = 0x832BF12C;
	sub_82CC7E68(ctx, base);
	// 832BF12C: 4800000C  b 0x832bf138
	pc = 0x832BF138; continue 'dispatch;
	// 832BF130: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BF134: 4BD4C88D  bl 0x8300b9c0
	ctx.lr = 0x832BF138;
	sub_8300B9C0(ctx, base);
	// 832BF138: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 832BF13C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BF140: 4BA03671  bl 0x82cc27b0
	ctx.lr = 0x832BF144;
	sub_82CC27B0(ctx, base);
	// 832BF144: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BF148: 4BA03669  bl 0x82cc27b0
	ctx.lr = 0x832BF14C;
	sub_82CC27B0(ctx, base);
	// 832BF14C: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 832BF150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BF154: 935B0004  stw r26, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 832BF158: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832BF15C: 4B9EA2F4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 832BF160: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 832BF164: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 832BF168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832BF16C: 4BFFFC85  bl 0x832bedf0
	ctx.lr = 0x832BF170;
	sub_832BEDF0(ctx, base);
	// 832BF170: 5463083C  slwi r3, r3, 1
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 832BF174: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832BF178: 4B9EA2D8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 832BF17C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 832BF180: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 832BF184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BF188: 4BFFFC69  bl 0x832bedf0
	ctx.lr = 0x832BF18C;
	sub_832BEDF0(ctx, base);
	// 832BF18C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832BF190: 4B9EA2C0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BF198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BF198 size=284
    let mut pc: u32 = 0x832BF198;
    'dispatch: loop {
        match pc {
            0x832BF198 => {
    //   block [0x832BF198..0x832BF2B4)
	// 832BF198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BF19C: 4B9EA25D  bl 0x82ca93f8
	ctx.lr = 0x832BF1A0;
	sub_82CA93D0(ctx, base);
	// 832BF1A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BF1A4: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832BF1A8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 832BF1AC: 3BEBC21C  addi r31, r11, -0x3de4
	ctx.r[31].s64 = ctx.r[11].s64 + -15844;
	// 832BF1B0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 832BF1B4: 815F0254  lwz r10, 0x254(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 832BF1B8: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 832BF1BC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BF1C0: 409A00A4  bne cr6, 0x832bf264
	if !ctx.cr[6].eq {
	pc = 0x832BF264; continue 'dispatch;
	}
	// 832BF1C4: 55432036  slwi r3, r10, 4
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 832BF1C8: 4B92ABC9  bl 0x82be9d90
	ctx.lr = 0x832BF1CC;
	sub_82BE9D90(ctx, base);
	// 832BF1CC: 83DF0254  lwz r30, 0x254(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 832BF1D0: 839F024C  lwz r28, 0x24c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 832BF1D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 832BF1D8: 57D8103A  slwi r24, r30, 2
	ctx.r[24].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 832BF1DC: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BF1E0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 832BF1E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 832BF1E8: 7F6BEA14  add r27, r11, r29
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BF1EC: 4B9EA295  bl 0x82ca9480
	ctx.lr = 0x832BF1F0;
	sub_82CA9480(ctx, base);
	// 832BF1F0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 832BF1F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 832BF1F8: 809F0250  lwz r4, 0x250(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 832BF1FC: 4B9EA285  bl 0x82ca9480
	ctx.lr = 0x832BF200;
	sub_82CA9480(ctx, base);
	// 832BF200: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BF204: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 832BF208: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 832BF20C: 419A0044  beq cr6, 0x832bf250
	if ctx.cr[6].eq {
	pc = 0x832BF250; continue 'dispatch;
	}
	// 832BF210: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 832BF214: 419A003C  beq cr6, 0x832bf250
	if ctx.cr[6].eq {
	pc = 0x832BF250; continue 'dispatch;
	}
	// 832BF218: 897CFFFE  lbz r11, -2(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(-2 as u32) ) } as u64;
	// 832BF21C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 832BF220: 897CFFFF  lbz r11, -1(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(-1 as u32) ) } as u64;
	// 832BF224: 7C6BE050  subf r3, r11, r28
	ctx.r[3].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 832BF228: 409A0024  bne cr6, 0x832bf24c
	if !ctx.cr[6].eq {
	pc = 0x832BF24C; continue 'dispatch;
	}
	// 832BF22C: 815CFFF4  lwz r10, -0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-12 as u32) ) } as u64;
	// 832BF230: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832BF234: 4E800421  bctrl
	ctx.lr = 0x832BF238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832BF238: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 832BF23C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 832BF240: 93BF024C  stw r29, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[29].u32 ) };
	// 832BF244: 911F0250  stw r8, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[8].u32 ) };
	// 832BF248: 48000024  b 0x832bf26c
	pc = 0x832BF26C; continue 'dispatch;
	// 832BF24C: 4B9ECEF5  bl 0x82cac140
	ctx.lr = 0x832BF250;
	sub_82CAC140(ctx, base);
	// 832BF250: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 832BF254: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 832BF258: 93BF024C  stw r29, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[29].u32 ) };
	// 832BF25C: 911F0250  stw r8, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[8].u32 ) };
	// 832BF260: 4800000C  b 0x832bf26c
	pc = 0x832BF26C; continue 'dispatch;
	// 832BF264: 83BF024C  lwz r29, 0x24c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 832BF268: 811F0250  lwz r8, 0x250(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 832BF26C: 3939001F  addi r9, r25, 0x1f
	ctx.r[9].s64 = ctx.r[25].s64 + 31;
	// 832BF270: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF274: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BF278: 55290034  rlwinm r9, r9, 0, 0, 0x1a
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 832BF27C: 5545D97E  srwi r5, r10, 5
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shr(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BF280: 5524D97E  srwi r4, r9, 5
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shr(5);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BF284: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832BF288: 7CE42850  subf r7, r4, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 832BF28C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 832BF290: 38670001  addi r3, r7, 1
	ctx.r[3].s64 = ctx.r[7].s64 + 1;
	// 832BF294: 546B2DB4  rlwinm r11, r3, 5, 0x16, 0x1a
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x07FFFFFFu64;
	// 832BF298: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 832BF29C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832BF2A0: 7D66412E  stwx r11, r6, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 832BF2A4: 7F46E92E  stwx r26, r6, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[29].u32), ctx.r[26].u32) };
	// 832BF2A8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832BF2AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 832BF2B0: 4B9EA198  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BF2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832BF2B8 size=772
    let mut pc: u32 = 0x832BF2B8;
    'dispatch: loop {
        match pc {
            0x832BF2B8 => {
    //   block [0x832BF2B8..0x832BF5BC)
	// 832BF2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BF2BC: 4B9EA125  bl 0x82ca93e0
	ctx.lr = 0x832BF2C0;
	sub_82CA93D0(ctx, base);
	// 832BF2C0: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 832BF2C4: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 832BF2C8: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 832BF2CC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BF2D0: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 832BF2D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 832BF2D8: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 832BF2DC: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 832BF2E0: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 832BF2E4: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF2E8: 7D144378  mr r20, r8
	ctx.r[20].u64 = ctx.r[8].u64;
	// 832BF2EC: C3AB9484  lfs f29, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 832BF2F0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 832BF2F4: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF2F8: 83D50000  lwz r30, 0(r21)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF2FC: 83950004  lwz r28, 4(r21)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BF300: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 832BF304: 83F50008  lwz r31, 8(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BF308: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 832BF30C: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	// 832BF310: 40980028  bge cr6, 0x832bf338
	if !ctx.cr[6].lt {
	pc = 0x832BF338; continue 'dispatch;
	}
	// 832BF314: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832BF318: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 832BF31C: 7FEBB42E  lfsx f31, r11, r22
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 832BF320: FFC0F850  fneg f30, f31
	ctx.f[30].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 832BF324: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BF328: 7D4BC02E  lwzx r10, r11, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 832BF32C: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF330: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 832BF334: 4198FFE4  blt cr6, 0x832bf318
	if ctx.cr[6].lt {
	pc = 0x832BF318; continue 'dispatch;
	}
	// 832BF338: 3AE30008  addi r23, r3, 8
	ctx.r[23].s64 = ctx.r[3].s64 + 8;
	// 832BF33C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 832BF340: 2B120002  cmplwi cr6, r18, 2
	ctx.cr[6].compare_u32(ctx.r[18].u32, 2 as u32, &mut ctx.xer);
	// 832BF344: 40990258  ble cr6, 0x832bf59c
	if !ctx.cr[6].gt {
	pc = 0x832BF59C; continue 'dispatch;
	}
	// 832BF348: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832BF34C: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 832BF350: 3A6BC20C  addi r19, r11, -0x3df4
	ctx.r[19].s64 = ctx.r[11].s64 + -15860;
	// 832BF354: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BF358: 409A0018  bne cr6, 0x832bf370
	if !ctx.cr[6].eq {
	pc = 0x832BF370; continue 'dispatch;
	}
	// 832BF35C: 7F1CA040  cmplw cr6, r28, r20
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[20].u32, &mut ctx.xer);
	// 832BF360: 4098023C  bge cr6, 0x832bf59c
	if !ctx.cr[6].lt {
	pc = 0x832BF59C; continue 'dispatch;
	}
	// 832BF364: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF368: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 832BF36C: 3BE00020  li r31, 0x20
	ctx.r[31].s64 = 32;
	// 832BF370: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 832BF374: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 832BF378: 57DEF87E  srwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 832BF37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BF380: 419A0060  beq cr6, 0x832bf3e0
	if ctx.cr[6].eq {
	pc = 0x832BF3E0; continue 'dispatch;
	}
	// 832BF384: 2B1F0004  cmplwi cr6, r31, 4
	ctx.cr[6].compare_u32(ctx.r[31].u32, 4 as u32, &mut ctx.xer);
	// 832BF388: 4098003C  bge cr6, 0x832bf3c4
	if !ctx.cr[6].lt {
	pc = 0x832BF3C4; continue 'dispatch;
	}
	// 832BF38C: 7F1CA040  cmplw cr6, r28, r20
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[20].u32, &mut ctx.xer);
	// 832BF390: 4098020C  bge cr6, 0x832bf59c
	if !ctx.cr[6].lt {
	pc = 0x832BF59C; continue 'dispatch;
	}
	// 832BF394: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF398: 215F0004  subfic r10, r31, 4
	ctx.xer.ca = ctx.r[31].u32 <= 4 as u32;
	ctx.r[10].s64 = (4 as i64) - ctx.r[31].s64;
	// 832BF39C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 832BF3A0: 7D69F830  slw r9, r11, r31
	if (ctx.r[31].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[11].u32) << ((ctx.r[31].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF3A4: 7D28F378  or r8, r9, r30
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[30].u64;
	// 832BF3A8: 7D7E5430  srw r30, r11, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = ((ctx.r[11].u32) >> ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF3AC: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 832BF3B0: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 832BF3B4: 7D6B98AE  lbzx r11, r11, r19
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 832BF3B8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 832BF3BC: 7F6B3214  add r27, r11, r6
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 832BF3C0: 48000024  b 0x832bf3e4
	pc = 0x832BF3E4; continue 'dispatch;
	// 832BF3C4: 57CB073E  clrlwi r11, r30, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 832BF3C8: 57DEE13E  srwi r30, r30, 4
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 832BF3CC: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 832BF3D0: 7D6B98AE  lbzx r11, r11, r19
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 832BF3D4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 832BF3D8: 7F6B3214  add r27, r11, r6
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 832BF3DC: 48000008  b 0x832bf3e4
	pc = 0x832BF3E4; continue 'dispatch;
	// 832BF3E0: 3B660008  addi r27, r6, 8
	ctx.r[27].s64 = ctx.r[6].s64 + 8;
	// 832BF3E4: 7F1B9040  cmplw cr6, r27, r18
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[18].u32, &mut ctx.xer);
	// 832BF3E8: 40990008  ble cr6, 0x832bf3f0
	if !ctx.cr[6].gt {
	pc = 0x832BF3F0; continue 'dispatch;
	}
	// 832BF3EC: 7E5B9378  mr r27, r18
	ctx.r[27].u64 = ctx.r[18].u64;
	// 832BF3F0: 2B1F0004  cmplwi cr6, r31, 4
	ctx.cr[6].compare_u32(ctx.r[31].u32, 4 as u32, &mut ctx.xer);
	// 832BF3F4: 40980030  bge cr6, 0x832bf424
	if !ctx.cr[6].lt {
	pc = 0x832BF424; continue 'dispatch;
	}
	// 832BF3F8: 7F1CA040  cmplw cr6, r28, r20
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[20].u32, &mut ctx.xer);
	// 832BF3FC: 409801A0  bge cr6, 0x832bf59c
	if !ctx.cr[6].lt {
	pc = 0x832BF59C; continue 'dispatch;
	}
	// 832BF400: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF404: 215F0004  subfic r10, r31, 4
	ctx.xer.ca = ctx.r[31].u32 <= 4 as u32;
	ctx.r[10].s64 = (4 as i64) - ctx.r[31].s64;
	// 832BF408: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 832BF40C: 7D69F830  slw r9, r11, r31
	if (ctx.r[31].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[11].u32) << ((ctx.r[31].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF410: 7D28F378  or r8, r9, r30
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[30].u64;
	// 832BF414: 7D7E5430  srw r30, r11, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = ((ctx.r[11].u32) >> ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF418: 550B073E  clrlwi r11, r8, 0x1c
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 832BF41C: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 832BF420: 48000010  b 0x832bf430
	pc = 0x832BF430; continue 'dispatch;
	// 832BF424: 57CB073E  clrlwi r11, r30, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 832BF428: 57DEE13E  srwi r30, r30, 4
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 832BF42C: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 832BF430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832BF434: 409A005C  bne cr6, 0x832bf490
	if !ctx.cr[6].eq {
	pc = 0x832BF490; continue 'dispatch;
	}
	// 832BF438: 7D66D850  subf r11, r6, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[6].s64;
	// 832BF43C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BF440: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 832BF444: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 832BF448: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 832BF44C: 4B9EA565  bl 0x82ca99b0
	ctx.lr = 0x832BF450;
	sub_82CA99B0(ctx, base);
	// 832BF450: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BF454: 7EFDBA14  add r23, r29, r23
	ctx.r[23].u64 = ctx.r[29].u64 + ctx.r[23].u64;
	// 832BF458: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 832BF45C: 7D4BC02E  lwzx r10, r11, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 832BF460: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF464: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BF468: 4099012C  ble cr6, 0x832bf594
	if !ctx.cr[6].gt {
	pc = 0x832BF594; continue 'dispatch;
	}
	// 832BF46C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 832BF470: 7FEBB42E  lfsx f31, r11, r22
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 832BF474: FFC0F850  fneg f30, f31
	ctx.f[30].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 832BF478: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BF47C: 7D4BC02E  lwzx r10, r11, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 832BF480: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF484: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BF488: 4199FFE4  bgt cr6, 0x832bf46c
	if ctx.cr[6].gt {
	pc = 0x832BF46C; continue 'dispatch;
	}
	// 832BF48C: 48000108  b 0x832bf594
	pc = 0x832BF594; continue 'dispatch;
	// 832BF490: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832BF494: 40980100  bge cr6, 0x832bf594
	if !ctx.cr[6].lt {
	pc = 0x832BF594; continue 'dispatch;
	}
	// 832BF498: 574A103A  slwi r10, r26, 2
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832BF49C: 7CF6C050  subf r7, r22, r24
	ctx.r[7].s64 = ctx.r[24].s64 - ctx.r[22].s64;
	// 832BF4A0: 7D0AB214  add r8, r10, r22
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 832BF4A4: 7D47402E  lwzx r10, r7, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 832BF4A8: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF4AC: 7F064840  cmplw cr6, r6, r9
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BF4B0: 409A0014  bne cr6, 0x832bf4c4
	if !ctx.cr[6].eq {
	pc = 0x832BF4C4; continue 'dispatch;
	}
	// 832BF4B4: C3E80000  lfs f31, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 832BF4B8: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 832BF4BC: FFC0F850  fneg f30, f31
	ctx.f[30].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 832BF4C0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 832BF4C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832BF4C8: 4098003C  bge cr6, 0x832bf504
	if !ctx.cr[6].lt {
	pc = 0x832BF504; continue 'dispatch;
	}
	// 832BF4CC: 7F1CA040  cmplw cr6, r28, r20
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[20].u32, &mut ctx.xer);
	// 832BF4D0: 409800C4  bge cr6, 0x832bf594
	if !ctx.cr[6].lt {
	pc = 0x832BF594; continue 'dispatch;
	}
	// 832BF4D4: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF4D8: 208B0020  subfic r4, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[4].s64 = (32 as i64) - ctx.r[11].s64;
	// 832BF4DC: 7C7F5850  subf r3, r31, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 832BF4E0: 7CAAF830  slw r10, r5, r31
	if (ctx.r[31].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[5].u32) << ((ctx.r[31].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF4E4: 7D49F378  or r9, r10, r30
	ctx.r[9].u64 = ctx.r[10].u64 | ctx.r[30].u64;
	// 832BF4E8: 7F242430  srw r4, r25, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[25].u32) >> ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF4EC: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 832BF4F0: 7C894838  and r9, r4, r9
	ctx.r[9].u64 = ctx.r[4].u64 & ctx.r[9].u64;
	// 832BF4F4: 7CBE1C30  srw r30, r5, r3
	if (ctx.r[3].u8 & 0x20) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = ((ctx.r[5].u32) >> ((ctx.r[3].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF4F8: 3BEA0020  addi r31, r10, 0x20
	ctx.r[31].s64 = ctx.r[10].s64 + 32;
	// 832BF4FC: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 832BF500: 48000018  b 0x832bf518
	pc = 0x832BF518; continue 'dispatch;
	// 832BF504: 214B0020  subfic r10, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[10].s64 = (32 as i64) - ctx.r[11].s64;
	// 832BF508: 7FEBF850  subf r31, r11, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 832BF50C: 7F295430  srw r9, r25, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[25].u32) >> ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF510: 7D29F038  and r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[30].u64;
	// 832BF514: 7FDE5C30  srw r30, r30, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = ((ctx.r[30].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF518: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BF51C: 419A0064  beq cr6, 0x832bf580
	if ctx.cr[6].eq {
	pc = 0x832BF580; continue 'dispatch;
	}
	// 832BF520: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BF524: 409A0018  bne cr6, 0x832bf53c
	if !ctx.cr[6].eq {
	pc = 0x832BF53C; continue 'dispatch;
	}
	// 832BF528: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF52C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 832BF530: 3BE0001F  li r31, 0x1f
	ctx.r[31].s64 = 31;
	// 832BF534: 555EF87E  srwi r30, r10, 1
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 832BF538: 48000010  b 0x832bf548
	pc = 0x832BF548; continue 'dispatch;
	// 832BF53C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 832BF540: 57DEF87E  srwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 832BF544: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 832BF548: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 832BF54C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BF550: 419A000C  beq cr6, 0x832bf55c
	if ctx.cr[6].eq {
	pc = 0x832BF55C; continue 'dispatch;
	}
	// 832BF554: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 832BF558: 48000008  b 0x832bf560
	pc = 0x832BF560; continue 'dispatch;
	// 832BF55C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 832BF560: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 832BF564: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 832BF568: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 832BF56C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 832BF570: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 832BF574: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 832BF578: D1570000  stfs f10, 0(r23)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832BF57C: 48000008  b 0x832bf584
	pc = 0x832BF584; continue 'dispatch;
	// 832BF580: D3B70000  stfs f29, 0(r23)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832BF584: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 832BF588: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 832BF58C: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832BF590: 4198FF14  blt cr6, 0x832bf4a4
	if ctx.cr[6].lt {
	pc = 0x832BF4A4; continue 'dispatch;
	}
	// 832BF594: 7F069040  cmplw cr6, r6, r18
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[18].u32, &mut ctx.xer);
	// 832BF598: 4198FDBC  blt cr6, 0x832bf354
	if ctx.cr[6].lt {
	pc = 0x832BF354; continue 'dispatch;
	}
	// 832BF59C: 93950004  stw r28, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 832BF5A0: 93D50000  stw r30, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 832BF5A4: 93F50008  stw r31, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 832BF5A8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 832BF5AC: CBA1FF70  lfd f29, -0x90(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 832BF5B0: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 832BF5B4: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 832BF5B8: 4B9E9E78  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BF5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832BF5C0 size=1512
    let mut pc: u32 = 0x832BF5C0;
    'dispatch: loop {
        match pc {
            0x832BF5C0 => {
    //   block [0x832BF5C0..0x832BFBA8)
	// 832BF5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BF5C4: 4B9E9E25  bl 0x82ca93e8
	ctx.lr = 0x832BF5C8;
	sub_82CA93D0(ctx, base);
	// 832BF5C8: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 832BF5CC: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 832BF5D0: E981E000  ld r12, -0x2000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8192 as u32) ) };
	// 832BF5D4: E981D000  ld r12, -0x3000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-12288 as u32) ) };
	// 832BF5D8: E981C000  ld r12, -0x4000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16384 as u32) ) };
	// 832BF5DC: 9421BEB0  stwu r1, -0x4150(r1)
	ea = ctx.r[1].u32.wrapping_add(-16720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BF5E0: 54D907FE  clrlwi r25, r6, 0x1f
	ctx.r[25].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 832BF5E4: 83C141A4  lwz r30, 0x41a4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(16804 as u32) ) } as u64;
	// 832BF5E8: 7D344B78  mr r20, r9
	ctx.r[20].u64 = ctx.r[9].u64;
	// 832BF5EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 832BF5F0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 832BF5F4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 832BF5F8: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 832BF5FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 832BF600: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 832BF604: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 832BF608: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832BF60C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832BF610: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 832BF614: 419A0030  beq cr6, 0x832bf644
	if ctx.cr[6].eq {
	pc = 0x832BF644; continue 'dispatch;
	}
	// 832BF618: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BF61C: 41980014  blt cr6, 0x832bf630
	if ctx.cr[6].lt {
	pc = 0x832BF630; continue 'dispatch;
	}
	// 832BF620: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832BF624: 38214150  addi r1, r1, 0x4150
	ctx.r[1].s64 = ctx.r[1].s64 + 16720;
	// 832BF628: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 832BF62C: 4B9E9E0C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
	// 832BF630: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF634: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BF638: 3960001E  li r11, 0x1e
	ctx.r[11].s64 = 30;
	// 832BF63C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 832BF640: 5529F0BE  srwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF644: 3B8100E0  addi r28, r1, 0xe0
	ctx.r[28].s64 = ctx.r[1].s64 + 224;
	// 832BF648: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 832BF64C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 832BF650: 419A03BC  beq cr6, 0x832bfa0c
	if ctx.cr[6].eq {
	pc = 0x832BFA0C; continue 'dispatch;
	}
	// 832BF654: 3D008350  lis r8, -0x7cb0
	ctx.r[8].s64 = -2091909120;
	// 832BF658: 82E141B4  lwz r23, 0x41b4(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(16820 as u32) ) } as u64;
	// 832BF65C: 83A141AC  lwz r29, 0x41ac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(16812 as u32) ) } as u64;
	// 832BF660: 3BE8C408  addi r31, r8, -0x3bf8
	ctx.r[31].s64 = ctx.r[8].s64 + -15352;
	// 832BF664: 4800000C  b 0x832bf670
	pc = 0x832BF670; continue 'dispatch;
	// 832BF668: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 832BF66C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832BF670: 2B0B001D  cmplwi cr6, r11, 0x1d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 29 as u32, &mut ctx.xer);
	// 832BF674: 40980034  bge cr6, 0x832bf6a8
	if !ctx.cr[6].lt {
	pc = 0x832BF6A8; continue 'dispatch;
	}
	// 832BF678: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BF67C: 40980390  bge cr6, 0x832bfa0c
	if !ctx.cr[6].lt {
	pc = 0x832BFA0C; continue 'dispatch;
	}
	// 832BF680: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF684: 20EB001D  subfic r7, r11, 0x1d
	ctx.xer.ca = ctx.r[11].u32 <= 29 as u32;
	ctx.r[7].s64 = (29 as i64) - ctx.r[11].s64;
	// 832BF688: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BF68C: 7D065830  slw r6, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF690: 7CC54B78  or r5, r6, r9
	ctx.r[5].u64 = ctx.r[6].u64 | ctx.r[9].u64;
	// 832BF694: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 832BF698: 7D093C30  srw r9, r8, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[8].u32) >> ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF69C: 54A800FE  clrlwi r8, r5, 3
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0x1FFFFFFFu64;
	// 832BF6A0: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 832BF6A4: 48000010  b 0x832bf6b4
	pc = 0x832BF6B4; continue 'dispatch;
	// 832BF6A8: 552800FE  clrlwi r8, r9, 3
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 832BF6AC: 55291F7E  srwi r9, r9, 0x1d
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(29);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF6B0: 396BFFE3  addi r11, r11, -0x1d
	ctx.r[11].s64 = ctx.r[11].s64 + -29;
	// 832BF6B4: 5505D97E  srwi r5, r8, 5
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shr(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BF6B8: 5506167A  rlwinm r6, r8, 2, 0x19, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 832BF6BC: 54A5024E  rlwinm r5, r5, 0, 9, 7
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 832BF6C0: 550400C6  rlwinm r4, r8, 0, 3, 3
	ctx.r[4].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 832BF6C4: 78A50020  clrldi r5, r5, 0x20
	ctx.r[5].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 832BF6C8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 832BF6CC: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 832BF6D0: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 832BF6D4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 832BF6D8: 7D66FC2E  lfsx f11, r6, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 832BF6DC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 832BF6E0: EC0C02F2  fmuls f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 832BF6E4: 419A0008  beq cr6, 0x832bf6ec
	if ctx.cr[6].eq {
	pc = 0x832BF6EC; continue 'dispatch;
	}
	// 832BF6E8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 832BF6EC: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832BF6F0: 2B0B001D  cmplwi cr6, r11, 0x1d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 29 as u32, &mut ctx.xer);
	// 832BF6F4: 40980034  bge cr6, 0x832bf728
	if !ctx.cr[6].lt {
	pc = 0x832BF728; continue 'dispatch;
	}
	// 832BF6F8: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BF6FC: 40980310  bge cr6, 0x832bfa0c
	if !ctx.cr[6].lt {
	pc = 0x832BFA0C; continue 'dispatch;
	}
	// 832BF700: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF704: 20EB001D  subfic r7, r11, 0x1d
	ctx.xer.ca = ctx.r[11].u32 <= 29 as u32;
	ctx.r[7].s64 = (29 as i64) - ctx.r[11].s64;
	// 832BF708: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BF70C: 7D065830  slw r6, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF710: 7CC54B78  or r5, r6, r9
	ctx.r[5].u64 = ctx.r[6].u64 | ctx.r[9].u64;
	// 832BF714: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 832BF718: 7D093C30  srw r9, r8, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[8].u32) >> ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF71C: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 832BF720: 54A800FE  clrlwi r8, r5, 3
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0x1FFFFFFFu64;
	// 832BF724: 48000010  b 0x832bf734
	pc = 0x832BF734; continue 'dispatch;
	// 832BF728: 552800FE  clrlwi r8, r9, 3
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 832BF72C: 55291F7E  srwi r9, r9, 0x1d
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(29);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF730: 396BFFE3  addi r11, r11, -0x1d
	ctx.r[11].s64 = ctx.r[11].s64 + -29;
	// 832BF734: 5505D97E  srwi r5, r8, 5
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shr(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832BF738: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832BF73C: 5506167A  rlwinm r6, r8, 2, 0x19, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 832BF740: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 832BF744: 54A5024E  rlwinm r5, r5, 0, 9, 7
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 832BF748: 550400C6  rlwinm r4, r8, 0, 3, 3
	ctx.r[4].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 832BF74C: 78A50020  clrldi r5, r5, 0x20
	ctx.r[5].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 832BF750: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 832BF754: F8A10068  std r5, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u64 ) };
	// 832BF758: 7D66FC2E  lfsx f11, r6, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 832BF75C: C8010068  lfd f0, 0x68(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 832BF760: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 832BF764: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 832BF768: EC0C02F2  fmuls f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 832BF76C: 419A0008  beq cr6, 0x832bf774
	if ctx.cr[6].eq {
	pc = 0x832BF774; continue 'dispatch;
	}
	// 832BF770: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 832BF774: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 832BF778: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832BF77C: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 832BF780: 419801B0  blt cr6, 0x832bf930
	if ctx.cr[6].lt {
	pc = 0x832BF930; continue 'dispatch;
	}
	// 832BF784: 38C10074  addi r6, r1, 0x74
	ctx.r[6].s64 = ctx.r[1].s64 + 116;
	// 832BF788: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 832BF78C: 40980030  bge cr6, 0x832bf7bc
	if !ctx.cr[6].lt {
	pc = 0x832BF7BC; continue 'dispatch;
	}
	// 832BF790: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BF794: 40980224  bge cr6, 0x832bf9b8
	if !ctx.cr[6].lt {
	pc = 0x832BF9B8; continue 'dispatch;
	}
	// 832BF798: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF79C: 20EB0008  subfic r7, r11, 8
	ctx.xer.ca = ctx.r[11].u32 <= 8 as u32;
	ctx.r[7].s64 = (8 as i64) - ctx.r[11].s64;
	// 832BF7A0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BF7A4: 7D045830  slw r4, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF7A8: 7C834B78  or r3, r4, r9
	ctx.r[3].u64 = ctx.r[4].u64 | ctx.r[9].u64;
	// 832BF7AC: 7D073C30  srw r7, r8, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[8].u32) >> ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF7B0: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 832BF7B4: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832BF7B8: 48000010  b 0x832bf7c8
	pc = 0x832BF7C8; continue 'dispatch;
	// 832BF7BC: 5527C23E  srwi r7, r9, 8
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shr(8);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832BF7C0: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 832BF7C4: 5528063E  clrlwi r8, r9, 0x18
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 832BF7C8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832BF7CC: 2B08005F  cmplwi cr6, r8, 0x5f
	ctx.cr[6].compare_u32(ctx.r[8].u32, 95 as u32, &mut ctx.xer);
	// 832BF7D0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 832BF7D4: 40990008  ble cr6, 0x832bf7dc
	if !ctx.cr[6].gt {
	pc = 0x832BF7DC; continue 'dispatch;
	}
	// 832BF7D8: 3900005F  li r8, 0x5f
	ctx.r[8].s64 = 95;
	// 832BF7DC: 393FFE80  addi r9, r31, -0x180
	ctx.r[9].s64 = ctx.r[31].s64 + -384;
	// 832BF7E0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BF7E4: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 832BF7E8: 7C084C2E  lfsx f0, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BF7EC: D006FFFC  stfs f0, -4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 832BF7F0: 40980030  bge cr6, 0x832bf820
	if !ctx.cr[6].lt {
	pc = 0x832BF820; continue 'dispatch;
	}
	// 832BF7F4: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BF7F8: 409801C0  bge cr6, 0x832bf9b8
	if !ctx.cr[6].lt {
	pc = 0x832BF9B8; continue 'dispatch;
	}
	// 832BF7FC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF800: 210B0008  subfic r8, r11, 8
	ctx.xer.ca = ctx.r[11].u32 <= 8 as u32;
	ctx.r[8].s64 = (8 as i64) - ctx.r[11].s64;
	// 832BF804: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BF808: 7D245830  slw r4, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF80C: 7C833B78  or r3, r4, r7
	ctx.r[3].u64 = ctx.r[4].u64 | ctx.r[7].u64;
	// 832BF810: 7D284430  srw r8, r9, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[9].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF814: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 832BF818: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832BF81C: 48000010  b 0x832bf82c
	pc = 0x832BF82C; continue 'dispatch;
	// 832BF820: 54E8C23E  srwi r8, r7, 8
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shr(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BF824: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 832BF828: 54E9063E  clrlwi r9, r7, 0x18
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 832BF82C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832BF830: 2B09005F  cmplwi cr6, r9, 0x5f
	ctx.cr[6].compare_u32(ctx.r[9].u32, 95 as u32, &mut ctx.xer);
	// 832BF834: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 832BF838: 40990008  ble cr6, 0x832bf840
	if !ctx.cr[6].gt {
	pc = 0x832BF840; continue 'dispatch;
	}
	// 832BF83C: 3920005F  li r9, 0x5f
	ctx.r[9].s64 = 95;
	// 832BF840: 38FFFE80  addi r7, r31, -0x180
	ctx.r[7].s64 = ctx.r[31].s64 + -384;
	// 832BF844: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BF848: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 832BF84C: 7C043C2E  lfsx f0, r4, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BF850: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832BF854: 40980030  bge cr6, 0x832bf884
	if !ctx.cr[6].lt {
	pc = 0x832BF884; continue 'dispatch;
	}
	// 832BF858: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BF85C: 4098015C  bge cr6, 0x832bf9b8
	if !ctx.cr[6].lt {
	pc = 0x832BF9B8; continue 'dispatch;
	}
	// 832BF860: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF864: 20EB0008  subfic r7, r11, 8
	ctx.xer.ca = ctx.r[11].u32 <= 8 as u32;
	ctx.r[7].s64 = (8 as i64) - ctx.r[11].s64;
	// 832BF868: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BF86C: 7D245830  slw r4, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF870: 7C834378  or r3, r4, r8
	ctx.r[3].u64 = ctx.r[4].u64 | ctx.r[8].u64;
	// 832BF874: 7D273C30  srw r7, r9, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[9].u32) >> ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF878: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 832BF87C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832BF880: 48000010  b 0x832bf890
	pc = 0x832BF890; continue 'dispatch;
	// 832BF884: 5507C23E  srwi r7, r8, 8
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(8);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832BF888: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 832BF88C: 5509063E  clrlwi r9, r8, 0x18
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 832BF890: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832BF894: 2B09005F  cmplwi cr6, r9, 0x5f
	ctx.cr[6].compare_u32(ctx.r[9].u32, 95 as u32, &mut ctx.xer);
	// 832BF898: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 832BF89C: 40990008  ble cr6, 0x832bf8a4
	if !ctx.cr[6].gt {
	pc = 0x832BF8A4; continue 'dispatch;
	}
	// 832BF8A0: 3920005F  li r9, 0x5f
	ctx.r[9].s64 = 95;
	// 832BF8A4: 391FFE80  addi r8, r31, -0x180
	ctx.r[8].s64 = ctx.r[31].s64 + -384;
	// 832BF8A8: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BF8AC: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 832BF8B0: 7C04442E  lfsx f0, r4, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BF8B4: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 832BF8B8: 40980030  bge cr6, 0x832bf8e8
	if !ctx.cr[6].lt {
	pc = 0x832BF8E8; continue 'dispatch;
	}
	// 832BF8BC: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BF8C0: 409800F8  bge cr6, 0x832bf9b8
	if !ctx.cr[6].lt {
	pc = 0x832BF9B8; continue 'dispatch;
	}
	// 832BF8C4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF8C8: 210B0008  subfic r8, r11, 8
	ctx.xer.ca = ctx.r[11].u32 <= 8 as u32;
	ctx.r[8].s64 = (8 as i64) - ctx.r[11].s64;
	// 832BF8CC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BF8D0: 7D245830  slw r4, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF8D4: 7C833B78  or r3, r4, r7
	ctx.r[3].u64 = ctx.r[4].u64 | ctx.r[7].u64;
	// 832BF8D8: 7D294430  srw r9, r9, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF8DC: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 832BF8E0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832BF8E4: 48000010  b 0x832bf8f4
	pc = 0x832BF8F4; continue 'dispatch;
	// 832BF8E8: 54E9C23E  srwi r9, r7, 8
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF8EC: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 832BF8F0: 54E8063E  clrlwi r8, r7, 0x18
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 832BF8F4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832BF8F8: 2B08005F  cmplwi cr6, r8, 0x5f
	ctx.cr[6].compare_u32(ctx.r[8].u32, 95 as u32, &mut ctx.xer);
	// 832BF8FC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 832BF900: 40990008  ble cr6, 0x832bf908
	if !ctx.cr[6].gt {
	pc = 0x832BF908; continue 'dispatch;
	}
	// 832BF904: 3900005F  li r8, 0x5f
	ctx.r[8].s64 = 95;
	// 832BF908: 38FFFE80  addi r7, r31, -0x180
	ctx.r[7].s64 = ctx.r[31].s64 + -384;
	// 832BF90C: 5504103A  slwi r4, r8, 2
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BF910: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 832BF914: 387DFFFD  addi r3, r29, -3
	ctx.r[3].s64 = ctx.r[29].s64 + -3;
	// 832BF918: 7F051840  cmplw cr6, r5, r3
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832BF91C: 7C043C2E  lfsx f0, r4, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BF920: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 832BF924: 38C60010  addi r6, r6, 0x10
	ctx.r[6].s64 = ctx.r[6].s64 + 16;
	// 832BF928: 4198FE60  blt cr6, 0x832bf788
	if ctx.cr[6].lt {
	pc = 0x832BF788; continue 'dispatch;
	}
	// 832BF92C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 832BF930: 7F05E840  cmplw cr6, r5, r29
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832BF934: 40980088  bge cr6, 0x832bf9bc
	if !ctx.cr[6].lt {
	pc = 0x832BF9BC; continue 'dispatch;
	}
	// 832BF938: 54A7103A  slwi r7, r5, 2
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832BF93C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 832BF940: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 832BF944: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 832BF948: 40980030  bge cr6, 0x832bf978
	if !ctx.cr[6].lt {
	pc = 0x832BF978; continue 'dispatch;
	}
	// 832BF94C: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832BF950: 40980060  bge cr6, 0x832bf9b0
	if !ctx.cr[6].lt {
	pc = 0x832BF9B0; continue 'dispatch;
	}
	// 832BF954: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BF958: 20CB0008  subfic r6, r11, 8
	ctx.xer.ca = ctx.r[11].u32 <= 8 as u32;
	ctx.r[6].s64 = (8 as i64) - ctx.r[11].s64;
	// 832BF95C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BF960: 7D045830  slw r4, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF964: 7C834B78  or r3, r4, r9
	ctx.r[3].u64 = ctx.r[4].u64 | ctx.r[9].u64;
	// 832BF968: 7D093430  srw r9, r8, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[8].u32) >> ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 832BF96C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 832BF970: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832BF974: 48000010  b 0x832bf984
	pc = 0x832BF984; continue 'dispatch;
	// 832BF978: 5528063E  clrlwi r8, r9, 0x18
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 832BF97C: 5529C23E  srwi r9, r9, 8
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BF980: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 832BF984: 2B08005F  cmplwi cr6, r8, 0x5f
	ctx.cr[6].compare_u32(ctx.r[8].u32, 95 as u32, &mut ctx.xer);
	// 832BF988: 40990008  ble cr6, 0x832bf990
	if !ctx.cr[6].gt {
	pc = 0x832BF990; continue 'dispatch;
	}
	// 832BF98C: 3900005F  li r8, 0x5f
	ctx.r[8].s64 = 95;
	// 832BF990: 38DFFE80  addi r6, r31, -0x180
	ctx.r[6].s64 = ctx.r[31].s64 + -384;
	// 832BF994: 5504103A  slwi r4, r8, 2
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 832BF998: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 832BF99C: 7F05E840  cmplw cr6, r5, r29
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832BF9A0: 7C04342E  lfsx f0, r4, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BF9A4: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832BF9A8: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 832BF9AC: 4198FF98  blt cr6, 0x832bf944
	if ctx.cr[6].lt {
	pc = 0x832BF944; continue 'dispatch;
	}
	// 832BF9B0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 832BF9B4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832BF9B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 832BF9BC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 832BF9C0: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 832BF9C4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 832BF9C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832BF9CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 832BF9D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832BF9D4: 4BFFF8E5  bl 0x832bf2b8
	ctx.lr = 0x832BF9D8;
	sub_832BF2B8(ctx, base);
	// 832BF9D8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 832BF9DC: 419A0018  beq cr6, 0x832bf9f4
	if ctx.cr[6].eq {
	pc = 0x832BF9F4; continue 'dispatch;
	}
	// 832BF9E0: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 832BF9E4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 832BF9E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 832BF9EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 832BF9F0: 480053C1  bl 0x832c4db0
	ctx.lr = 0x832BF9F4;
	sub_832C4DB0(ctx, base);
	// 832BF9F4: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BF9F8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BF9FC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 832BFA00: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 832BFA04: 7F1AC040  cmplw cr6, r26, r24
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[24].u32, &mut ctx.xer);
	// 832BFA08: 4198FC60  blt cr6, 0x832bf668
	if ctx.cr[6].lt {
	pc = 0x832BF668; continue 'dispatch;
	}
	// 832BFA0C: 2B180001  cmplwi cr6, r24, 1
	ctx.cr[6].compare_u32(ctx.r[24].u32, 1 as u32, &mut ctx.xer);
	// 832BFA10: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 832BFA14: 409A00BC  bne cr6, 0x832bfad0
	if !ctx.cr[6].eq {
	pc = 0x832BFAD0; continue 'dispatch;
	}
	// 832BFA18: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 832BFA1C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BFA20: 419A0080  beq cr6, 0x832bfaa0
	if ctx.cr[6].eq {
	pc = 0x832BFAA0; continue 'dispatch;
	}
	// 832BFA24: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 832BFA28: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 832BFA2C: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
	// 832BFA30: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 832BFA34: C1A79484  lfs f13, -0x6b7c(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 832BFA38: 39080E68  addi r8, r8, 0xe68
	ctx.r[8].s64 = ctx.r[8].s64 + 3688;
	// 832BFA3C: C1860E74  lfs f12, 0xe74(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3700 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 832BFA40: C0050E70  lfs f0, 0xe70(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BFA44: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 832BFA48: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BFA4C: ED4B07F2  fmuls f10, f11, f31
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 832BFA50: ED2A002A  fadds f9, f10, f0
	ctx.f[9].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 832BFA54: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 832BFA58: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 832BFA5C: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 832BFA60: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 832BFA64: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 832BFA68: 7D08242E  lfsx f8, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 832BFA6C: FCE862AE  fsel f7, f8, f10, f12
	ctx.f[7].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[10].f64 } else { ctx.f[12].f64 };
	// 832BFA70: ECC70028  fsubs f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 832BFA74: FF066800  fcmpu cr6, f6, f13
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[13].f64);
	// 832BFA78: 7C600026  mfcr r3
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[3].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 832BFA7C: 5467DF7A  rlwinm r7, r3, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 832BFA80: 5466F77A  rlwinm r6, r3, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 832BFA84: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 832BFA88: 7CA82C2E  lfsx f5, r8, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 832BFA8C: FC85382E  fsel f4, f5, f0, f7
	ctx.f[4].f64 = if ctx.f[5].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[7].f64 };
	// 832BFA90: FC60201E  fctiwz f3, f4
	ctx.f[3].s64 = if ctx.f[4].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[4].f64.trunc() as i32 as i64 };
	// 832BFA94: 7C605FAE  stfiwx f3, 0, r11
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 832BFA98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BFA9C: 4082FFA8  bne 0x832bfa44
	if !ctx.cr[0].eq {
	pc = 0x832BFA44; continue 'dispatch;
	}
	// 832BFAA0: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 832BFAA4: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	// 832BFAA8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 832BFAAC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BFAB0: 419A00E0  beq cr6, 0x832bfb90
	if ctx.cr[6].eq {
	pc = 0x832BFB90; continue 'dispatch;
	}
	// 832BFAB4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BFAB8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BFABC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 832BFAC0: B0E80000  sth r7, 0(r8)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 832BFAC4: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 832BFAC8: 4082FFEC  bne 0x832bfab4
	if !ctx.cr[0].eq {
	pc = 0x832BFAB4; continue 'dispatch;
	}
	// 832BFACC: 480000C4  b 0x832bfb90
	pc = 0x832BFB90; continue 'dispatch;
	// 832BFAD0: 5769083C  slwi r9, r27, 1
	ctx.r[9].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BFAD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BFAD8: 419A0080  beq cr6, 0x832bfb58
	if ctx.cr[6].eq {
	pc = 0x832BFB58; continue 'dispatch;
	}
	// 832BFADC: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 832BFAE0: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 832BFAE4: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
	// 832BFAE8: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 832BFAEC: C1A79484  lfs f13, -0x6b7c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 832BFAF0: 39080E68  addi r8, r8, 0xe68
	ctx.r[8].s64 = ctx.r[8].s64 + 3688;
	// 832BFAF4: C1860E74  lfs f12, 0xe74(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3700 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 832BFAF8: C0050E70  lfs f0, 0xe70(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832BFAFC: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 832BFB00: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BFB04: ED5F02F2  fmuls f10, f31, f11
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[11].f64) as f32) as f64);
	// 832BFB08: ED2A002A  fadds f9, f10, f0
	ctx.f[9].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 832BFB0C: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 832BFB10: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 832BFB14: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 832BFB18: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 832BFB1C: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 832BFB20: 7D08242E  lfsx f8, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 832BFB24: FCE862AE  fsel f7, f8, f10, f12
	ctx.f[7].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[10].f64 } else { ctx.f[12].f64 };
	// 832BFB28: ECC70028  fsubs f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 832BFB2C: FF066800  fcmpu cr6, f6, f13
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[13].f64);
	// 832BFB30: 7C600026  mfcr r3
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[3].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 832BFB34: 5467DF7A  rlwinm r7, r3, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 832BFB38: 5466F77A  rlwinm r6, r3, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 832BFB3C: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 832BFB40: 7CA82C2E  lfsx f5, r8, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 832BFB44: FC85382E  fsel f4, f5, f0, f7
	ctx.f[4].f64 = if ctx.f[5].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[7].f64 };
	// 832BFB48: FC60201E  fctiwz f3, f4
	ctx.f[3].s64 = if ctx.f[4].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[4].f64.trunc() as i32 as i64 };
	// 832BFB4C: 7C605FAE  stfiwx f3, 0, r11
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 832BFB50: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BFB54: 4082FFA8  bne 0x832bfafc
	if !ctx.cr[0].eq {
	pc = 0x832BFAFC; continue 'dispatch;
	}
	// 832BFB58: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 832BFB5C: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 832BFB60: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BFB64: 419A002C  beq cr6, 0x832bfb90
	if ctx.cr[6].eq {
	pc = 0x832BFB90; continue 'dispatch;
	}
	// 832BFB68: 38E100E0  addi r7, r1, 0xe0
	ctx.r[7].s64 = ctx.r[1].s64 + 224;
	// 832BFB6C: 5768103A  slwi r8, r27, 2
	ctx.r[8].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832BFB70: 7CE7A050  subf r7, r7, r20
	ctx.r[7].s64 = ctx.r[20].s64 - ctx.r[7].s64;
	// 832BFB74: 7CC8582E  lwzx r6, r8, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 832BFB78: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BFB7C: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BFB80: 50A6801E  rlwimi r6, r5, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[5].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 832BFB84: 7CC7592E  stwx r6, r7, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 832BFB88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BFB8C: 4082FFE8  bne 0x832bfb74
	if !ctx.cr[0].eq {
	pc = 0x832BFB74; continue 'dispatch;
	}
	// 832BFB90: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 832BFB94: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832BFB98: 554300FE  clrlwi r3, r10, 3
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 832BFB9C: 38214150  addi r1, r1, 0x4150
	ctx.r[1].s64 = ctx.r[1].s64 + 16720;
	// 832BFBA0: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 832BFBA4: 4B9E9894  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BFBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832BFBA8 size=796
    let mut pc: u32 = 0x832BFBA8;
    'dispatch: loop {
        match pc {
            0x832BFBA8 => {
    //   block [0x832BFBA8..0x832BFEC4)
	// 832BFBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BFBAC: 4B9E9835  bl 0x82ca93e0
	ctx.lr = 0x832BFBB0;
	sub_82CA93D0(ctx, base);
	// 832BFBB0: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 832BFBB4: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 832BFBB8: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 832BFBBC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BFBC0: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 832BFBC4: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 832BFBC8: 2B03AC44  cmplwi cr6, r3, 0xac44
	ctx.cr[6].compare_u32(ctx.r[3].u32, 44100 as u32, &mut ctx.xer);
	// 832BFBCC: 4198000C  blt cr6, 0x832bfbd8
	if ctx.cr[6].lt {
	pc = 0x832BFBD8; continue 'dispatch;
	}
	// 832BFBD0: 3B400800  li r26, 0x800
	ctx.r[26].s64 = 2048;
	// 832BFBD4: 48000018  b 0x832bfbec
	pc = 0x832BFBEC; continue 'dispatch;
	// 832BFBD8: 39605622  li r11, 0x5622
	ctx.r[11].s64 = 22050;
	// 832BFBDC: 7D4B1810  subfc r10, r11, r3
	ctx.xer.ca = ctx.r[3].u32 >= ctx.r[11].u32;
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832BFBE0: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 832BFBE4: 552B002C  rlwinm r11, r9, 0, 0, 0x16
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 832BFBE8: 3B4B0400  addi r26, r11, 0x400
	ctx.r[26].s64 = ctx.r[11].s64 + 1024;
	// 832BFBEC: 7D7AA9D6  mullw r11, r26, r21
	ctx.r[11].s64 = (ctx.r[26].s32 as i64) * (ctx.r[21].s32 as i64);
	// 832BFBF0: 566A07FE  clrlwi r10, r19, 0x1f
	ctx.r[10].u64 = ctx.r[19].u32 as u64 & 0x00000001u64;
	// 832BFBF4: 3A400001  li r18, 1
	ctx.r[18].s64 = 1;
	// 832BFBF8: 5578083C  slwi r24, r11, 1
	ctx.r[24].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 832BFBFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BFC00: 409A0010  bne cr6, 0x832bfc10
	if !ctx.cr[6].eq {
	pc = 0x832BFC10; continue 'dispatch;
	}
	// 832BFC04: 7C63A9D6  mullw r3, r3, r21
	ctx.r[3].s64 = (ctx.r[3].s32 as i64) * (ctx.r[21].s32 as i64);
	// 832BFC08: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 832BFC0C: 7E559378  mr r21, r18
	ctx.r[21].u64 = ctx.r[18].u64;
	// 832BFC10: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832BFC14: 39230001  addi r9, r3, 1
	ctx.r[9].s64 = ctx.r[3].s64 + 1;
	// 832BFC18: 3A8BC220  addi r20, r11, -0x3de0
	ctx.r[20].s64 = ctx.r[11].s64 + -15840;
	// 832BFC1C: 5756F87E  srwi r22, r26, 1
	ctx.r[22].u32 = ctx.r[26].u32.wrapping_shr(1);
	ctx.r[22].u64 = ctx.r[22].u32 as u64;
	// 832BFC20: 5537F87E  srwi r23, r9, 1
	ctx.r[23].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 832BFC24: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 832BFC28: 39740004  addi r11, r20, 4
	ctx.r[11].s64 = ctx.r[20].s64 + 4;
	// 832BFC2C: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 832BFC30: 7F09B840  cmplw cr6, r9, r23
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BFC34: 40980064  bge cr6, 0x832bfc98
	if !ctx.cr[6].lt {
	pc = 0x832BFC98; continue 'dispatch;
	}
	// 832BFC38: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BFC3C: 7F09B840  cmplw cr6, r9, r23
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BFC40: 4098003C  bge cr6, 0x832bfc7c
	if !ctx.cr[6].lt {
	pc = 0x832BFC7C; continue 'dispatch;
	}
	// 832BFC44: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832BFC48: 7F09B840  cmplw cr6, r9, r23
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BFC4C: 40980038  bge cr6, 0x832bfc84
	if !ctx.cr[6].lt {
	pc = 0x832BFC84; continue 'dispatch;
	}
	// 832BFC50: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BFC54: 7F09B840  cmplw cr6, r9, r23
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BFC58: 40980034  bge cr6, 0x832bfc8c
	if !ctx.cr[6].lt {
	pc = 0x832BFC8C; continue 'dispatch;
	}
	// 832BFC5C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BFC60: 7F09B840  cmplw cr6, r9, r23
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[23].u32, &mut ctx.xer);
	// 832BFC64: 40980030  bge cr6, 0x832bfc94
	if !ctx.cr[6].lt {
	pc = 0x832BFC94; continue 'dispatch;
	}
	// 832BFC68: 3B7B0005  addi r27, r27, 5
	ctx.r[27].s64 = ctx.r[27].s64 + 5;
	// 832BFC6C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 832BFC70: 2B1B0019  cmplwi cr6, r27, 0x19
	ctx.cr[6].compare_u32(ctx.r[27].u32, 25 as u32, &mut ctx.xer);
	// 832BFC74: 4198FFB8  blt cr6, 0x832bfc2c
	if ctx.cr[6].lt {
	pc = 0x832BFC2C; continue 'dispatch;
	}
	// 832BFC78: 48000020  b 0x832bfc98
	pc = 0x832BFC98; continue 'dispatch;
	// 832BFC7C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 832BFC80: 48000018  b 0x832bfc98
	pc = 0x832BFC98; continue 'dispatch;
	// 832BFC84: 3B7B0002  addi r27, r27, 2
	ctx.r[27].s64 = ctx.r[27].s64 + 2;
	// 832BFC88: 48000010  b 0x832bfc98
	pc = 0x832BFC98; continue 'dispatch;
	// 832BFC8C: 3B7B0003  addi r27, r27, 3
	ctx.r[27].s64 = ctx.r[27].s64 + 3;
	// 832BFC90: 48000008  b 0x832bfc98
	pc = 0x832BFC98; continue 'dispatch;
	// 832BFC94: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 832BFC98: 7AC90020  clrldi r9, r22, 0x20
	ctx.r[9].u64 = ctx.r[22].u64 & 0x00000000FFFFFFFFu64;
	// 832BFC9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 832BFCA0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 832BFCA4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 832BFCA8: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 832BFCAC: 3B2BB480  addi r25, r11, -0x4b80
	ctx.r[25].s64 = ctx.r[11].s64 + -19328;
	// 832BFCB0: FC006818  frsp f0, f13
	ctx.f[0].f64 = (ctx.f[13].f64 as f32) as f64;
	// 832BFCB4: 570BF87E  srwi r11, r24, 1
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BFCB8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 832BFCBC: C3B9E004  lfs f29, -0x1ffc(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 832BFCC0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 832BFCC4: 38CB00AF  addi r6, r11, 0xaf
	ctx.r[6].s64 = ctx.r[11].s64 + 175;
	// 832BFCC8: 54DC0036  rlwinm r28, r6, 0, 0, 0x1b
	ctx.r[28].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 832BFCCC: CBC80D30  lfd f30, 0xd30(r8)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3376 as u32) ) };
	// 832BFCD0: CBE70DF0  lfd f31, 0xdf0(r7)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(3568 as u32) ) };
	// 832BFCD4: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 832BFCD8: 40990040  ble cr6, 0x832bfd18
	if !ctx.cr[6].gt {
	pc = 0x832BFD18; continue 'dispatch;
	}
	// 832BFCDC: FDA00034  frsqrte f13, f0
	ctx.fpscr.enable_flush_mode_unconditional();
	ctx.f[13].f64 = 1.0f64 / ctx.f[0].f64.sqrt();
	// 832BFCE0: FD800372  fmul f12, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[0].f64 * ctx.f[13].f64;
	// 832BFCE4: FD6CFB7C  fnmsub f11, f12, f13, f31
	ctx.f[11].f64 = -(ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[31].f64);
	// 832BFCE8: FD4B0372  fmul f10, f11, f13
	ctx.f[10].f64 = ctx.f[11].f64 * ctx.f[13].f64;
	// 832BFCEC: FD2A07B2  fmul f9, f10, f30
	ctx.f[9].f64 = ctx.f[10].f64 * ctx.f[30].f64;
	// 832BFCF0: FD000272  fmul f8, f0, f9
	ctx.f[8].f64 = ctx.f[0].f64 * ctx.f[9].f64;
	// 832BFCF4: FCE8FA7C  fnmsub f7, f8, f9, f31
	ctx.f[7].f64 = -(ctx.f[8].f64 * ctx.f[9].f64 - ctx.f[31].f64);
	// 832BFCF8: FCC70272  fmul f6, f7, f9
	ctx.f[6].f64 = ctx.f[7].f64 * ctx.f[9].f64;
	// 832BFCFC: FCA607B2  fmul f5, f6, f30
	ctx.f[5].f64 = ctx.f[6].f64 * ctx.f[30].f64;
	// 832BFD00: FC800172  fmul f4, f0, f5
	ctx.f[4].f64 = ctx.f[0].f64 * ctx.f[5].f64;
	// 832BFD04: FC64F97C  fnmsub f3, f4, f5, f31
	ctx.f[3].f64 = -(ctx.f[4].f64 * ctx.f[5].f64 - ctx.f[31].f64);
	// 832BFD08: FC430172  fmul f2, f3, f5
	ctx.f[2].f64 = ctx.f[3].f64 * ctx.f[5].f64;
	// 832BFD0C: FC2207B2  fmul f1, f2, f30
	ctx.f[1].f64 = ctx.f[2].f64 * ctx.f[30].f64;
	// 832BFD10: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 832BFD14: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 832BFD18: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 832BFD1C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 832BFD20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832BFD24: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832BFD28: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BFD2C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 832BFD30: 394B0017  addi r10, r11, 0x17
	ctx.r[10].s64 = ctx.r[11].s64 + 23;
	// 832BFD34: 555D0036  rlwinm r29, r10, 0, 0, 0x1b
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 832BFD38: 419A0020  beq cr6, 0x832bfd58
	if ctx.cr[6].eq {
	pc = 0x832BFD58; continue 'dispatch;
	}
	// 832BFD3C: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BFD40: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 832BFD44: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 832BFD48: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BFD4C: 394B000F  addi r10, r11, 0xf
	ctx.r[10].s64 = ctx.r[11].s64 + 15;
	// 832BFD50: 555E0036  rlwinm r30, r10, 0, 0, 0x1b
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 832BFD54: 48000014  b 0x832bfd68
	pc = 0x832BFD68; continue 'dispatch;
	// 832BFD58: 56CB103A  slwi r11, r22, 2
	ctx.r[11].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832BFD5C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832BFD60: 396B000F  addi r11, r11, 0xf
	ctx.r[11].s64 = ctx.r[11].s64 + 15;
	// 832BFD64: 557E0036  rlwinm r30, r11, 0, 0, 0x1b
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BFD68: 7D7EC214  add r11, r30, r24
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[24].u64;
	// 832BFD6C: 396B000F  addi r11, r11, 0xf
	ctx.r[11].s64 = ctx.r[11].s64 + 15;
	// 832BFD70: 55630036  rlwinm r3, r11, 0, 0, 0x1b
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832BFD74: 4B92A01D  bl 0x82be9d90
	ctx.lr = 0x832BFD78;
	sub_82BE9D90(ctx, base);
	// 832BFD78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BFD7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832BFD80: 409A0018  bne cr6, 0x832bfd98
	if !ctx.cr[6].eq {
	pc = 0x832BFD98; continue 'dispatch;
	}
	// 832BFD84: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 832BFD88: CBA1FF70  lfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 832BFD8C: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 832BFD90: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 832BFD94: 4B9E969C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
	// 832BFD98: 38A00098  li r5, 0x98
	ctx.r[5].s64 = 152;
	// 832BFD9C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832BFDA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BFDA4: 4B9E9C0D  bl 0x82ca99b0
	ctx.lr = 0x832BFDA8;
	sub_82CA99B0(ctx, base);
	// 832BFDA8: 7B4B0020  clrldi r11, r26, 0x20
	ctx.r[11].u64 = ctx.r[26].u64 & 0x00000000FFFFFFFFu64;
	// 832BFDAC: 395F00A0  addi r10, r31, 0xa0
	ctx.r[10].s64 = ctx.r[31].s64 + 160;
	// 832BFDB0: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 832BFDB4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 832BFDB8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 832BFDBC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 832BFDC0: 7D3FE214  add r9, r31, r28
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[28].u64;
	// 832BFDC4: FC006818  frsp f0, f13
	ctx.f[0].f64 = (ctx.f[13].f64 as f32) as f64;
	// 832BFDC8: 7D1FEA14  add r8, r31, r29
	ctx.r[8].u64 = ctx.r[31].u64 + ctx.r[29].u64;
	// 832BFDCC: 7CFFF214  add r7, r31, r30
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 832BFDD0: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 832BFDD4: 5706E13E  srwi r6, r24, 4
	ctx.r[6].u32 = ctx.r[24].u32.wrapping_shr(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832BFDD8: 913F0024  stw r9, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 832BFDDC: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 832BFDE0: 90FF001C  stw r7, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 832BFDE4: 927F002C  stw r19, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[19].u32 ) };
	// 832BFDE8: 92BF0010  stw r21, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[21].u32 ) };
	// 832BFDEC: 937F0018  stw r27, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[27].u32 ) };
	// 832BFDF0: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 832BFDF4: 931F0008  stw r24, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 832BFDF8: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 832BFDFC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 832BFE00: 40990040  ble cr6, 0x832bfe40
	if !ctx.cr[6].gt {
	pc = 0x832BFE40; continue 'dispatch;
	}
	// 832BFE04: FDA00034  frsqrte f13, f0
	ctx.fpscr.enable_flush_mode_unconditional();
	ctx.f[13].f64 = 1.0f64 / ctx.f[0].f64.sqrt();
	// 832BFE08: FD800372  fmul f12, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[0].f64 * ctx.f[13].f64;
	// 832BFE0C: FD6CFB7C  fnmsub f11, f12, f13, f31
	ctx.f[11].f64 = -(ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[31].f64);
	// 832BFE10: FD4B0372  fmul f10, f11, f13
	ctx.f[10].f64 = ctx.f[11].f64 * ctx.f[13].f64;
	// 832BFE14: FD2A07B2  fmul f9, f10, f30
	ctx.f[9].f64 = ctx.f[10].f64 * ctx.f[30].f64;
	// 832BFE18: FD000272  fmul f8, f0, f9
	ctx.f[8].f64 = ctx.f[0].f64 * ctx.f[9].f64;
	// 832BFE1C: FCE8FA7C  fnmsub f7, f8, f9, f31
	ctx.f[7].f64 = -(ctx.f[8].f64 * ctx.f[9].f64 - ctx.f[31].f64);
	// 832BFE20: FCC70272  fmul f6, f7, f9
	ctx.f[6].f64 = ctx.f[7].f64 * ctx.f[9].f64;
	// 832BFE24: FCA607B2  fmul f5, f6, f30
	ctx.f[5].f64 = ctx.f[6].f64 * ctx.f[30].f64;
	// 832BFE28: FC800172  fmul f4, f0, f5
	ctx.f[4].f64 = ctx.f[0].f64 * ctx.f[5].f64;
	// 832BFE2C: FC64F97C  fnmsub f3, f4, f5, f31
	ctx.f[3].f64 = -(ctx.f[4].f64 * ctx.f[5].f64 - ctx.f[31].f64);
	// 832BFE30: FC430172  fmul f2, f3, f5
	ctx.f[2].f64 = ctx.f[3].f64 * ctx.f[5].f64;
	// 832BFE34: FC2207B2  fmul f1, f2, f30
	ctx.f[1].f64 = ctx.f[2].f64 * ctx.f[30].f64;
	// 832BFE38: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 832BFE3C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 832BFE40: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 832BFE44: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 832BFE48: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 832BFE4C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 832BFE50: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BFE54: 419A003C  beq cr6, 0x832bfe90
	if ctx.cr[6].eq {
	pc = 0x832BFE90; continue 'dispatch;
	}
	// 832BFE58: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 832BFE5C: 397F0034  addi r11, r31, 0x34
	ctx.r[11].s64 = ctx.r[31].s64 + 52;
	// 832BFE60: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 832BFE64: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 832BFE68: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BFE6C: 7CD639D6  mullw r6, r22, r7
	ctx.r[6].s64 = (ctx.r[22].s32 as i64) * (ctx.r[7].s32 as i64);
	// 832BFE70: 7CA6BB97  divwu. r5, r6, r23
	ctx.r[5].u32 = ctx.r[6].u32 / ctx.r[23].u32;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 832BFE74: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 832BFE78: 40820008  bne 0x832bfe80
	if !ctx.cr[0].eq {
	pc = 0x832BFE80; continue 'dispatch;
	}
	// 832BFE7C: 924B0000  stw r18, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[18].u32 ) };
	// 832BFE80: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832BFE84: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832BFE88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832BFE8C: 4082FFDC  bne 0x832bfe68
	if !ctx.cr[0].eq {
	pc = 0x832BFE68; continue 'dispatch;
	}
	// 832BFE90: 3968000D  addi r11, r8, 0xd
	ctx.r[11].s64 = ctx.r[8].s64 + 13;
	// 832BFE94: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BFE98: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BFE9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832BFEA0: 7EC9F92E  stwx r22, r9, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), ctx.r[22].u32) };
	// 832BFEA4: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 832BFEA8: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832BFEAC: 925F0014  stw r18, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[18].u32 ) };
	// 832BFEB0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 832BFEB4: CBA1FF70  lfd f29, -0x90(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 832BFEB8: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 832BFEBC: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 832BFEC0: 4B9E9570  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BFEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832BFEC8 size=304
    let mut pc: u32 = 0x832BFEC8;
    'dispatch: loop {
        match pc {
            0x832BFEC8 => {
    //   block [0x832BFEC8..0x832BFFF8)
	// 832BFEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BFECC: 4B9E9535  bl 0x82ca9400
	ctx.lr = 0x832BFED0;
	sub_82CA93D0(ctx, base);
	// 832BFED0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832BFED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832BFED8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 832BFEDC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 832BFEE0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 832BFEE4: 3B5F0034  addi r26, r31, 0x34
	ctx.r[26].s64 = ctx.r[31].s64 + 52;
	// 832BFEE8: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832BFEEC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 832BFEF0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 832BFEF4: 811F0028  lwz r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 832BFEF8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 832BFEFC: 80FF0024  lwz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 832BFF00: C03F0004  lfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 832BFF04: 80DF002C  lwz r6, 0x2c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 832BFF08: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 832BFF0C: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BFF10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BFF14: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 832BFF18: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 832BFF1C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 832BFF20: 4BFFF6A1  bl 0x832bf5c0
	ctx.lr = 0x832BFF24;
	sub_832BF5C0(ctx, base);
	// 832BFF24: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832BFF28: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 832BFF2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832BFF30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832BFF34: 419A000C  beq cr6, 0x832bff40
	if ctx.cr[6].eq {
	pc = 0x832BFF40; continue 'dispatch;
	}
	// 832BFF38: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 832BFF3C: 4800005C  b 0x832bff98
	pc = 0x832BFF98; continue 'dispatch;
	// 832BFF40: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BFF44: 5549F87E  srwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832BFF48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832BFF4C: 419A004C  beq cr6, 0x832bff98
	if ctx.cr[6].eq {
	pc = 0x832BFF98; continue 'dispatch;
	}
	// 832BFF50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832BFF54: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BFF58: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 832BFF5C: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BFF60: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 832BFF64: 7CAA322E  lhzx r5, r10, r6
	ctx.r[5].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 832BFF68: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 832BFF6C: A0880000  lhz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 832BFF70: 7CA30734  extsh r3, r5
	ctx.r[3].s64 = ctx.r[5].s16 as i64;
	// 832BFF74: 7C860734  extsh r6, r4
	ctx.r[6].s64 = ctx.r[4].s16 as i64;
	// 832BFF78: 7CE339D6  mullw r7, r3, r7
	ctx.r[7].s64 = (ctx.r[3].s32 as i64) * (ctx.r[7].s32 as i64);
	// 832BFF7C: 7CC659D6  mullw r6, r6, r11
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[11].s32 as i64);
	// 832BFF80: 7CA73214  add r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 832BFF84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832BFF88: 7C854B96  divwu r4, r5, r9
	ctx.r[4].u32 = ctx.r[5].u32 / ctx.r[9].u32;
	// 832BFF8C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832BFF90: B0880000  sth r4, 0(r8)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u16 ) };
	// 832BFF94: 4198FFC0  blt cr6, 0x832bff54
	if ctx.cr[6].lt {
	pc = 0x832BFF54; continue 'dispatch;
	}
	// 832BFF98: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BFF9C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BFFA0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 832BFFA4: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BFFA8: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 832BFFAC: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832BFFB0: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832BFFB4: 4B9E94CD  bl 0x82ca9480
	ctx.lr = 0x832BFFB8;
	sub_82CA9480(ctx, base);
	// 832BFFB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832BFFBC: 419A0014  beq cr6, 0x832bffd0
	if ctx.cr[6].eq {
	pc = 0x832BFFD0; continue 'dispatch;
	}
	// 832BFFC0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832BFFC4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832BFFC8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832BFFCC: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 832BFFD0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 832BFFD4: 419A000C  beq cr6, 0x832bffe0
	if ctx.cr[6].eq {
	pc = 0x832BFFE0; continue 'dispatch;
	}
	// 832BFFD8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 832BFFDC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BFFE0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832BFFE4: 419A000C  beq cr6, 0x832bfff0
	if ctx.cr[6].eq {
	pc = 0x832BFFF0; continue 'dispatch;
	}
	// 832BFFE8: 7D7AEA14  add r11, r26, r29
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[29].u64;
	// 832BFFEC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832BFFF0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 832BFFF4: 4B9E945C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832BFFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832BFFF8 size=268
    let mut pc: u32 = 0x832BFFF8;
    'dispatch: loop {
        match pc {
            0x832BFFF8 => {
    //   block [0x832BFFF8..0x832C0104)
	// 832BFFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832BFFFC: 4B9E940D  bl 0x82ca9408
	ctx.lr = 0x832C0000;
	sub_82CA93D0(ctx, base);
	// 832C0000: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832C0004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832C0008: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 832C000C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 832C0010: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 832C0014: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 832C0018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832C001C: 419A000C  beq cr6, 0x832c0028
	if ctx.cr[6].eq {
	pc = 0x832C0028; continue 'dispatch;
	}
	// 832C0020: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832C0024: 4E800421  bctrl
	ctx.lr = 0x832C0028;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832C0028: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 832C002C: 419A002C  beq cr6, 0x832c0058
	if ctx.cr[6].eq {
	pc = 0x832C0058; continue 'dispatch;
	}
	// 832C0030: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 832C0034: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832C0038: 419A0020  beq cr6, 0x832c0058
	if ctx.cr[6].eq {
	pc = 0x832C0058; continue 'dispatch;
	}
	// 832C003C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 832C0040: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 832C0044: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832C0048: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 832C004C: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 832C0050: 4BA078E9  bl 0x82cc7938
	ctx.lr = 0x832C0054;
	sub_82CC7938(ctx, base);
	// 832C0054: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 832C0058: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 832C005C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 832C0060: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 832C0064: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 832C0068: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 832C006C: 4BA0361D  bl 0x82cc3688
	ctx.lr = 0x832C0070;
	sub_82CC3688(ctx, base);
	// 832C0070: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832C0074: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832C0078: 419A000C  beq cr6, 0x832c0084
	if ctx.cr[6].eq {
	pc = 0x832C0084; continue 'dispatch;
	}
	// 832C007C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 832C0080: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 832C0084: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 832C0088: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 832C008C: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832C0090: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 832C0094: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 832C0098: 813F0080  lwz r9, 0x80(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 832C009C: 811F005C  lwz r8, 0x5c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832C00A0: 80FF0040  lwz r7, 0x40(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 832C00A4: 7D684850  subf r11, r8, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 832C00A8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 832C00AC: 41980008  blt cr6, 0x832c00b4
	if ctx.cr[6].lt {
	pc = 0x832C00B4; continue 'dispatch;
	}
	// 832C00B0: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 832C00B4: 815F00FC  lwz r10, 0xfc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 832C00B8: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 832C00BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832C00C0: 419A0014  beq cr6, 0x832c00d4
	if ctx.cr[6].eq {
	pc = 0x832C00D4; continue 'dispatch;
	}
	// 832C00C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832C00C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832C00CC: 4E800421  bctrl
	ctx.lr = 0x832C00D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832C00D0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832C00D4: 39630003  addi r11, r3, 3
	ctx.r[11].s64 = ctx.r[3].s64 + 3;
	// 832C00D8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 832C00DC: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832C00E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832C00E4: 419A0018  beq cr6, 0x832c00fc
	if ctx.cr[6].eq {
	pc = 0x832C00FC; continue 'dispatch;
	}
	// 832C00E8: 7D20542C  lwbrx r9, 0, r10
	ctx.r[9].u64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32) }).swap_bytes() as u64;
	// 832C00EC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832C00F0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 832C00F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832C00F8: 4082FFF0  bne 0x832c00e8
	if !ctx.cr[0].eq {
	pc = 0x832C00E8; continue 'dispatch;
	}
	// 832C00FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832C0100: 4B9E9358  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832C0108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832C0108 size=200
    let mut pc: u32 = 0x832C0108;
    'dispatch: loop {
        match pc {
            0x832C0108 => {
    //   block [0x832C0108..0x832C01D0)
	// 832C0108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832C010C: 4B9E92FD  bl 0x82ca9408
	ctx.lr = 0x832C0110;
	sub_82CA93D0(ctx, base);
	// 832C0110: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832C0114: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 832C0118: 788B0020  clrldi r11, r4, 0x20
	ctx.r[11].u64 = ctx.r[4].u64 & 0x00000000FFFFFFFFu64;
	// 832C011C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 832C0120: 1D2B03E8  mulli r9, r11, 0x3e8
	ctx.r[9].s64 = ctx.r[11].s64 * 1000;
	// 832C0124: 815E0084  lwz r10, 0x84(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 832C0128: 7D095392  divdu r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 / ctx.r[10].u64;
	// 832C012C: 551D003E  slwi r29, r8, 0
	ctx.r[29].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 832C0130: 48000989  bl 0x832c0ab8
	ctx.lr = 0x832C0134;
	sub_832C0AB8(ctx, base);
	// 832C0134: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 832C0138: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 832C013C: 7D5CE850  subf r10, r28, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 832C0140: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832C0144: 7CEBFA14  add r7, r11, r31
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 832C0148: 90FE0088  stw r7, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 832C014C: 80DE0088  lwz r6, 0x88(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 832C0150: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 832C0154: 40990074  ble cr6, 0x832c01c8
	if !ctx.cr[6].gt {
	pc = 0x832C01C8; continue 'dispatch;
	}
	// 832C0158: 3D608350  lis r11, -0x7cb0
	ctx.r[11].s64 = -2091909120;
	// 832C015C: 3FA0C000  lis r29, -0x4000
	ctx.r[29].s64 = -1073741824;
	// 832C0160: 3BEBC200  addi r31, r11, -0x3e00
	ctx.r[31].s64 = ctx.r[11].s64 + -15872;
	// 832C0164: 4AFA5F4D  bl 0x822660b0
	ctx.lr = 0x832C0168;
	sub_822660B0(ctx, base);
	// 832C0168: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832C016C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832C0170: 409A000C  bne cr6, 0x832c017c
	if !ctx.cr[6].eq {
	pc = 0x832C017C; continue 'dispatch;
	}
	// 832C0174: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 832C0178: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832C017C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832C0180: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 832C0184: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832C0188: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832C018C: 4199000C  bgt cr6, 0x832c0198
	if ctx.cr[6].gt {
	pc = 0x832C0198; continue 'dispatch;
	}
	// 832C0190: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 832C0194: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832C0198: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 832C019C: 7D3C5050  subf r9, r28, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[28].s64;
	// 832C01A0: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 832C01A4: 4198FFC0  blt cr6, 0x832c0164
	if ctx.cr[6].lt {
	pc = 0x832C0164; continue 'dispatch;
	}
	// 832C01A8: 813E0088  lwz r9, 0x88(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 832C01AC: 7D6AE050  subf r11, r10, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[10].s64;
	// 832C01B0: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 832C01B4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 832C01B8: 917E0088  stw r11, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 832C01BC: 815E0088  lwz r10, 0x88(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 832C01C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832C01C4: 4199FFA0  bgt cr6, 0x832c0164
	if ctx.cr[6].gt {
	pc = 0x832C0164; continue 'dispatch;
	}
	// 832C01C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832C01CC: 4B9E928C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832C01D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832C01D0 size=932
    let mut pc: u32 = 0x832C01D0;
    'dispatch: loop {
        match pc {
            0x832C01D0 => {
    //   block [0x832C01D0..0x832C0574)
	// 832C01D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832C01D4: 4B9E921D  bl 0x82ca93f0
	ctx.lr = 0x832C01D8;
	sub_82CA93D0(ctx, base);
	// 832C01D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832C01DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832C01E0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 832C01E4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 832C01E8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 832C01EC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 832C01F0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832C01F4: 7F96E378  mr r22, r28
	ctx.r[22].u64 = ctx.r[28].u64;
	// 832C01F8: 7F37CB78  mr r23, r25
	ctx.r[23].u64 = ctx.r[25].u64;
	// 832C01FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832C0200: 419A0010  beq cr6, 0x832c0210
	if ctx.cr[6].eq {
	pc = 0x832C0210; continue 'dispatch;
	}
	// 832C0204: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832C0208: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 832C020C: 4B9E9234  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 832C0210: 480008A9  bl 0x832c0ab8
	ctx.lr = 0x832C0214;
	sub_832C0AB8(ctx, base);
	// 832C0214: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 832C0218: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 832C021C: 419A00D8  beq cr6, 0x832c02f4
	if ctx.cr[6].eq {
	pc = 0x832C02F4; continue 'dispatch;
	}
	// 832C0220: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832C0224: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832C0228: 419A00CC  beq cr6, 0x832c02f4
	if ctx.cr[6].eq {
	pc = 0x832C02F4; continue 'dispatch;
	}
	// 832C022C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 832C0230: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 832C0234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832C0238: 419A0010  beq cr6, 0x832c0248
	if ctx.cr[6].eq {
	pc = 0x832C0248; continue 'dispatch;
	}
	// 832C023C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832C0240: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832C0244: 4E800421  bctrl
	ctx.lr = 0x832C0248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832C0248: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832C024C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832C0250: 40990068  ble cr6, 0x832c02b8
	if !ctx.cr[6].gt {
	pc = 0x832C02B8; continue 'dispatch;
	}
	// 832C0254: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 832C0258: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832C025C: 4199005C  bgt cr6, 0x832c02b8
	if ctx.cr[6].gt {
	pc = 0x832C02B8; continue 'dispatch;
	}
	// 832C0260: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832C0264: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 832C0268: 815F0064  lwz r10, 0x64(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 832C026C: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 832C0270: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832C0274: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 832C0278: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 832C027C: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 832C0280: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 832C0284: 911F004C  stw r8, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[8].u32 ) };
	// 832C0288: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 832C028C: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 832C0290: 90FF0060  stw r7, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 832C0294: 80DF0070  lwz r6, 0x70(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 832C0298: 80BF0060  lwz r5, 0x60(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 832C029C: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 832C02A0: 40990054  ble cr6, 0x832c02f4
	if !ctx.cr[6].gt {
	pc = 0x832C02F4; continue 'dispatch;
	}
	// 832C02A4: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 832C02A8: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 832C02AC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832C02B0: 913F0060  stw r9, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 832C02B4: 48000040  b 0x832c02f4
	pc = 0x832C02F4; continue 'dispatch;
	// 832C02B8: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 832C02BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 832C02C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832C02C4: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 832C02C8: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 832C02CC: 4BA0766D  bl 0x82cc7938
	ctx.lr = 0x832C02D0;
	sub_82CC7938(ctx, base);
	// 832C02D0: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 832C02D4: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 832C02D8: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 832C02DC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 832C02E0: 933F004C  stw r25, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[25].u32 ) };
	// 832C02E4: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 832C02E8: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 832C02EC: 813F006C  lwz r9, 0x6c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 832C02F0: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 832C02F4: 3B5F004C  addi r26, r31, 0x4c
	ctx.r[26].s64 = ctx.r[31].s64 + 76;
	// 832C02F8: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 832C02FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832C0300: 419A0100  beq cr6, 0x832c0400
	if ctx.cr[6].eq {
	pc = 0x832C0400; continue 'dispatch;
	}
	// 832C0304: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832C0308: 40990008  ble cr6, 0x832c0310
	if !ctx.cr[6].gt {
	pc = 0x832C0310; continue 'dispatch;
	}
	// 832C030C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 832C0310: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832C0314: 7F7ED850  subf r27, r30, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[30].s64;
	// 832C0318: 7F3ECA14  add r25, r30, r25
	ctx.r[25].u64 = ctx.r[30].u64 + ctx.r[25].u64;
	// 832C031C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 832C0320: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 832C0324: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 832C0328: 813F0060  lwz r9, 0x60(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 832C032C: 7FA95050  subf r29, r9, r10
	ctx.r[29].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 832C0330: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 832C0334: 4199006C  bgt cr6, 0x832c03a0
	if ctx.cr[6].gt {
	pc = 0x832C03A0; continue 'dispatch;
	}
	// 832C0338: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 832C033C: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 832C0340: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832C0344: 4B9E913D  bl 0x82ca9480
	ctx.lr = 0x832C0348;
	sub_82CA9480(ctx, base);
	// 832C0348: 80FF006C  lwz r7, 0x6c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 832C034C: 7F9DE214  add r28, r29, r28
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[28].u64;
	// 832C0350: 7FDDF050  subf r30, r29, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 832C0354: 7D1D00D0  neg r8, r29
	ctx.r[8].s64 = -ctx.r[29].s64;
	// 832C0358: 90FF0060  stw r7, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 832C035C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 832C0360: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832C0364: 7D60D028  lwarx r11, 0, r26
	// lwarx
	let ea = ctx.r[26].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832C0368: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 832C036C: 7D40D12D  stwcx. r10, 0, r26
	// stwcx.
	let addr = ctx.r[26].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832C0370: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832C0374: 4082FFE8  bne 0x832c035c
	if !ctx.cr[0].eq {
	pc = 0x832C035C; continue 'dispatch;
	}
	// 832C0378: 38DF0064  addi r6, r31, 0x64
	ctx.r[6].s64 = ctx.r[31].s64 + 100;
	// 832C037C: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 832C0380: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832C0384: 7CA03028  lwarx r5, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 832C0388: 7C9D2A14  add r4, r29, r5
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[5].u64;
	// 832C038C: 7C80312D  stwcx. r4, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832C0390: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832C0394: 4082FFE8  bne 0x832c037c
	if !ctx.cr[0].eq {
	pc = 0x832C037C; continue 'dispatch;
	}
	// 832C0398: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832C039C: 419A0064  beq cr6, 0x832c0400
	if ctx.cr[6].eq {
	pc = 0x832C0400; continue 'dispatch;
	}
	// 832C03A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 832C03A4: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 832C03A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832C03AC: 4B9E90D5  bl 0x82ca9480
	ctx.lr = 0x832C03B0;
	sub_82CA9480(ctx, base);
	// 832C03B0: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 832C03B4: 7F9EE214  add r28, r30, r28
	ctx.r[28].u64 = ctx.r[30].u64 + ctx.r[28].u64;
	// 832C03B8: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 832C03BC: 7CDE00D0  neg r6, r30
	ctx.r[6].s64 = -ctx.r[30].s64;
	// 832C03C0: 90FF0060  stw r7, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 832C03C4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 832C03C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832C03CC: 7D40D028  lwarx r10, 0, r26
	// lwarx
	let ea = ctx.r[26].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 832C03D0: 7D265214  add r9, r6, r10
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 832C03D4: 7D20D12D  stwcx. r9, 0, r26
	// stwcx.
	let addr = ctx.r[26].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832C03D8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832C03DC: 4082FFE8  bne 0x832c03c4
	if !ctx.cr[0].eq {
	pc = 0x832C03C4; continue 'dispatch;
	}
	// 832C03E0: 38BF0064  addi r5, r31, 0x64
	ctx.r[5].s64 = ctx.r[31].s64 + 100;
	// 832C03E4: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 832C03E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832C03EC: 7C802828  lwarx r4, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 832C03F0: 7C7E2214  add r3, r30, r4
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[4].u64;
	// 832C03F4: 7C60292D  stwcx. r3, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832C03F8: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832C03FC: 4082FFE8  bne 0x832c03e4
	if !ctx.cr[0].eq {
	pc = 0x832C03E4; continue 'dispatch;
	}
	// 832C0400: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 832C0404: 419A00C8  beq cr6, 0x832c04cc
	if ctx.cr[6].eq {
	pc = 0x832C04CC; continue 'dispatch;
	}
	// 832C0408: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 832C040C: 409A0024  bne cr6, 0x832c0430
	if !ctx.cr[6].eq {
	pc = 0x832C0430; continue 'dispatch;
	}
	// 832C0410: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 832C0414: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 832C0418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832C041C: 419AFEDC  beq cr6, 0x832c02f8
	if ctx.cr[6].eq {
	pc = 0x832C02F8; continue 'dispatch;
	}
	// 832C0420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832C0424: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832C0428: 4E800421  bctrl
	ctx.lr = 0x832C042C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832C042C: 4BFFFECC  b 0x832c02f8
	pc = 0x832C02F8; continue 'dispatch;
	// 832C0430: 48000689  bl 0x832c0ab8
	ctx.lr = 0x832C0434;
	sub_832C0AB8(ctx, base);
	// 832C0434: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 832C0438: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 832C043C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 832C0440: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 832C0444: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 832C0448: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 832C044C: 4BA0323D  bl 0x82cc3688
	ctx.lr = 0x832C0450;
	sub_82CC3688(ctx, base);
	// 832C0450: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832C0454: 7F04D840  cmplw cr6, r4, r27
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[27].u32, &mut ctx.xer);
	// 832C0458: 4098000C  bge cr6, 0x832c0464
	if !ctx.cr[6].lt {
	pc = 0x832C0464; continue 'dispatch;
	}
	// 832C045C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 832C0460: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 832C0464: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 832C0468: 7F24CA14  add r25, r4, r25
	ctx.r[25].u64 = ctx.r[4].u64 + ctx.r[25].u64;
	// 832C046C: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 832C0470: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832C0474: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832C0478: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 832C047C: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 832C0480: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 832C0484: 7D2B2214  add r9, r11, r4
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 832C0488: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 832C048C: 811F0084  lwz r8, 0x84(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 832C0490: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 832C0494: 419A0010  beq cr6, 0x832c04a4
	if ctx.cr[6].eq {
	pc = 0x832C04A4; continue 'dispatch;
	}
	// 832C0498: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 832C049C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832C04A0: 4BFFFC69  bl 0x832c0108
	ctx.lr = 0x832C04A4;
	sub_832C0108(ctx, base);
	// 832C04A4: 48000615  bl 0x832c0ab8
	ctx.lr = 0x832C04A8;
	sub_832C0AB8(ctx, base);
	// 832C04A8: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 832C04AC: 7D5E1850  subf r10, r30, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	// 832C04B0: 7D781850  subf r11, r24, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[24].s64;
	// 832C04B4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 832C04B8: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 832C04BC: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 832C04C0: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832C04C4: 913F0034  stw r9, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 832C04C8: 48000018  b 0x832c04e0
	pc = 0x832C04E0; continue 'dispatch;
	// 832C04CC: 480005ED  bl 0x832c0ab8
	ctx.lr = 0x832C04D0;
	sub_832C0AB8(ctx, base);
	// 832C04D0: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 832C04D4: 7D781850  subf r11, r24, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[24].s64;
	// 832C04D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832C04DC: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 832C04E0: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 832C04E4: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 832C04E8: 813F0040  lwz r9, 0x40(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 832C04EC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832C04F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 832C04F4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832C04F8: 41980008  blt cr6, 0x832c0500
	if ctx.cr[6].lt {
	pc = 0x832C0500; continue 'dispatch;
	}
	// 832C04FC: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 832C0500: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 832C0504: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 832C0508: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 832C050C: 3D2B0002  addis r9, r11, 2
	ctx.r[9].s64 = ctx.r[11].s64 + 131072;
	// 832C0510: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832C0514: 4099000C  ble cr6, 0x832c0520
	if !ctx.cr[6].gt {
	pc = 0x832C0520; continue 'dispatch;
	}
	// 832C0518: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 832C051C: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 832C0520: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 832C0524: 419A001C  beq cr6, 0x832c0540
	if ctx.cr[6].eq {
	pc = 0x832C0540; continue 'dispatch;
	}
	// 832C0528: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 832C052C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832C0530: 419A0010  beq cr6, 0x832c0540
	if ctx.cr[6].eq {
	pc = 0x832C0540; continue 'dispatch;
	}
	// 832C0534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832C0538: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832C053C: 4E800421  bctrl
	ctx.lr = 0x832C0540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832C0540: 39790003  addi r11, r25, 3
	ctx.r[11].s64 = ctx.r[25].s64 + 3;
	// 832C0544: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 832C0548: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832C054C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832C0550: 419A0018  beq cr6, 0x832c0568
	if ctx.cr[6].eq {
	pc = 0x832C0568; continue 'dispatch;
	}
	// 832C0554: 7D20542C  lwbrx r9, 0, r10
	ctx.r[9].u64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32) }).swap_bytes() as u64;
	// 832C0558: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832C055C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 832C0560: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832C0564: 4082FFF0  bne 0x832c0554
	if !ctx.cr[0].eq {
	pc = 0x832C0554; continue 'dispatch;
	}
	// 832C0568: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 832C056C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 832C0570: 4B9E8ED0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832C0578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832C0578 size=32
    let mut pc: u32 = 0x832C0578;
    'dispatch: loop {
        match pc {
            0x832C0578 => {
    //   block [0x832C0578..0x832C0598)
	// 832C0578: 3D640002  addis r11, r4, 2
	ctx.r[11].s64 = ctx.r[4].s64 + 131072;
	// 832C057C: 3D200004  lis r9, 4
	ctx.r[9].s64 = 262144;
	// 832C0580: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832C0584: 556A001C  rlwinm r10, r11, 0, 0, 0xe
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832C0588: 612B1000  ori r11, r9, 0x1000
	ctx.r[11].u64 = ctx.r[9].u64 | 4096;
	// 832C058C: 386A1000  addi r3, r10, 0x1000
	ctx.r[3].s64 = ctx.r[10].s64 + 4096;
	// 832C0590: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832C0594: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832C0598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832C0598 size=8
    let mut pc: u32 = 0x832C0598;
    'dispatch: loop {
        match pc {
            0x832C0598 => {
    //   block [0x832C0598..0x832C05A0)
	// 832C0598: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 832C059C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832C05A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832C05A0 size=140
    let mut pc: u32 = 0x832C05A0;
    'dispatch: loop {
        match pc {
            0x832C05A0 => {
    //   block [0x832C05A0..0x832C062C)
	// 832C05A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832C05A4: 4B9E8E61  bl 0x82ca9404
	ctx.lr = 0x832C05A8;
	sub_82CA93D0(ctx, base);
	// 832C05A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832C05AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832C05B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 832C05B4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 832C05B8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 832C05BC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 832C05C0: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 832C05C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832C05C8: 419A000C  beq cr6, 0x832c05d4
	if ctx.cr[6].eq {
	pc = 0x832C05D4; continue 'dispatch;
	}
	// 832C05CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 832C05D0: 4E800421  bctrl
	ctx.lr = 0x832C05D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832C05D4: 397E0FFF  addi r11, r30, 0xfff
	ctx.r[11].s64 = ctx.r[30].s64 + 4095;
	// 832C05D8: 813F00FC  lwz r9, 0xfc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 832C05DC: 57AA001C  rlwinm r10, r29, 0, 0, 0xe
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 832C05E0: 556B0026  rlwinm r11, r11, 0, 0, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832C05E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 832C05E8: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 832C05EC: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832C05F0: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 832C05F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832C05F8: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 832C05FC: 90FF0070  stw r7, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[7].u32 ) };
	// 832C0600: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 832C0604: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 832C0608: 911F004C  stw r8, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[8].u32 ) };
	// 832C060C: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 832C0610: 937F0084  stw r27, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 832C0614: 419A0010  beq cr6, 0x832c0624
	if ctx.cr[6].eq {
	pc = 0x832C0624; continue 'dispatch;
	}
	// 832C0618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832C061C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 832C0620: 4E800421  bctrl
	ctx.lr = 0x832C0624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832C0624: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832C0628: 4B9E8E2C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


