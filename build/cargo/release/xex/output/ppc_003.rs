pub fn sub_821ADD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADD50 size=160
    let mut pc: u32 = 0x821ADD50;
    'dispatch: loop {
        match pc {
            0x821ADD50 => {
    //   block [0x821ADD50..0x821ADDF0)
	// 821ADD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADD54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ADD58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADD5C: 89630003  lbz r11, 3(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(3 as u32) ) } as u64;
	// 821ADD60: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821ADD64: 89230002  lbz r9, 2(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 821ADD68: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821ADD6C: 5567403E  rotlwi r7, r11, 8
	ctx.r[7].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 821ADD70: 88C30001  lbz r6, 1(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 821ADD74: 88A30000  lbz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADD78: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821ADD7C: 7CE34B78  or r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 | ctx.r[9].u64;
	// 821ADD80: 39681390  addi r11, r8, 0x1390
	ctx.r[11].s64 = ctx.r[8].s64 + 5008;
	// 821ADD84: 5469402E  slwi r9, r3, 8
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821ADD88: 39041350  addi r8, r4, 0x1350
	ctx.r[8].s64 = ctx.r[4].s64 + 4944;
	// 821ADD8C: 7D273378  or r7, r9, r6
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[6].u64;
	// 821ADD90: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821ADD94: 54E7402E  slwi r7, r7, 8
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(8);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADDF0 size=888
    let mut pc: u32 = 0x821ADDF0;
    'dispatch: loop {
        match pc {
            0x821ADDF0 => {
    //   block [0x821ADDF0..0x821AE168)
	// 821ADDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADDF4: 48AFB611  bl 0x82ca9404
	ctx.lr = 0x821ADDF8;
	sub_82CA93D0(ctx, base);
	// 821ADDF8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADDFC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821ADE00: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821ADE04: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821ADE08: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ADE0C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821ADE10: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADE14: 41820010  beq 0x821ade24
	if ctx.cr[0].eq {
	pc = 0x821ADE24; continue 'dispatch;
	}
	// 821ADE18: 83EB000C  lwz r31, 0xc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ADE1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ADE20: 409A0008  bne cr6, 0x821ade28
	if !ctx.cr[6].eq {
	pc = 0x821ADE28; continue 'dispatch;
	}
	// 821ADE24: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821ADE28: 809D002C  lwz r4, 0x2c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 821ADE2C: 807D0028  lwz r3, 0x28(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 821ADE30: 4800DFE1  bl 0x821bbe10
	ctx.lr = 0x821ADE34;
	sub_821BBE10(ctx, base);
	// 821ADE34: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821ADE38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ADE3C: 419A0018  beq cr6, 0x821ade54
	if ctx.cr[6].eq {
	pc = 0x821ADE54; continue 'dispatch;
	}
	// 821ADE40: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821ADE44: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821ADE48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADE4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADE50: 409A0008  bne cr6, 0x821ade58
	if !ctx.cr[6].eq {
	pc = 0x821ADE58; continue 'dispatch;
	}
	// 821ADE54: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821ADE58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADE5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADE60: 419A0300  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADE64: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821ADE68: 419A0018  beq cr6, 0x821ade80
	if ctx.cr[6].eq {
	pc = 0x821ADE80; continue 'dispatch;
	}
	// 821ADE6C: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 821ADE70: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821ADE74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADE78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADE7C: 409A0008  bne cr6, 0x821ade84
	if !ctx.cr[6].eq {
	pc = 0x821ADE84; continue 'dispatch;
	}
	// 821ADE80: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821ADE84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADE88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADE8C: 419A02D4  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADE90: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821ADE94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADE98: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 821ADE9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ADEA0: 4E800421  bctrl
	ctx.lr = 0x821ADEA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ADEA4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821ADEA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ADEAC: 419A02B4  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADEB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821ADEB4: 4BFDFE4D  bl 0x8218dd00
	ctx.lr = 0x821ADEB8;
	sub_8218DD00(ctx, base);
	// 821ADEB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821ADEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADEC0: 419A02A0  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADEC4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821ADEC8: 894B0068  lbz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 821ADECC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADED0: 419A0230  beq cr6, 0x821ae100
	if ctx.cr[6].eq {
	pc = 0x821AE100; continue 'dispatch;
	}
	// 821ADED4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821ADED8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821ADEDC: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 821ADEE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADEE4: 419A00F4  beq cr6, 0x821adfd8
	if ctx.cr[6].eq {
	pc = 0x821ADFD8; continue 'dispatch;
	}
	// 821ADEE8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821ADEEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADEF0: 419A0024  beq cr6, 0x821adf14
	if ctx.cr[6].eq {
	pc = 0x821ADF14; continue 'dispatch;
	}
	// 821ADEF4: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821ADEF8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ADEFC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821ADF00: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821ADF04: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADF08: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821ADF0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADF10: 480000CC  b 0x821adfdc
	pc = 0x821ADFDC; continue 'dispatch;
	// 821ADF14: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821ADF18: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821ADF1C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821ADF20: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821ADF24: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821ADF28: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADF2C: 40810054  ble 0x821adf80
	if !ctx.cr[0].gt {
	pc = 0x821ADF80; continue 'dispatch;
	}
	// 821ADF30: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821ADF34: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821ADF38: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821ADF3C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADF40: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 821ADF44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821ADF48: 41980008  blt cr6, 0x821adf50
	if ctx.cr[6].lt {
	pc = 0x821ADF50; continue 'dispatch;
	}
	// 821ADF4C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821ADF50: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821ADF54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821ADF58: 419A0014  beq cr6, 0x821adf6c
	if ctx.cr[6].eq {
	pc = 0x821ADF6C; continue 'dispatch;
	}
	// 821ADF5C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821ADF60: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821ADF64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ADF68: 4800000C  b 0x821adf74
	pc = 0x821ADF74; continue 'dispatch;
	// 821ADF6C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821ADF70: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821ADF74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADF78: 4199FFB8  bgt cr6, 0x821adf30
	if ctx.cr[6].gt {
	pc = 0x821ADF30; continue 'dispatch;
	}
	// 821ADF7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821ADF80: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821ADF84: 419A0040  beq cr6, 0x821adfc4
	if ctx.cr[6].eq {
	pc = 0x821ADFC4; continue 'dispatch;
	}
	// 821ADF88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ADF8C: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821ADF90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADF94: 41990008  bgt cr6, 0x821adf9c
	if ctx.cr[6].gt {
	pc = 0x821ADF9C; continue 'dispatch;
	}
	// 821ADF98: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821ADF9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADFA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADFA4: 409A0020  bne cr6, 0x821adfc4
	if !ctx.cr[6].eq {
	pc = 0x821ADFC4; continue 'dispatch;
	}
	// 821ADFA8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821ADFAC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821ADFB0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821ADFB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADFB8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821ADFBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADFC0: 4800001C  b 0x821adfdc
	pc = 0x821ADFDC; continue 'dispatch;
	// 821ADFC4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821ADFC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ADFCC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821ADFD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821ADFD4: 48000008  b 0x821adfdc
	pc = 0x821ADFDC; continue 'dispatch;
	// 821ADFD8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821ADFDC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ADFE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADFE4: 419A017C  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADFE8: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 821ADFEC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821ADFF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ADFF4: 419A016C  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821ADFF8: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 821ADFFC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821AE000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE004: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AE008: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821AE00C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AE010: 80890070  lwz r4, 0x70(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(112 as u32) ) } as u64;
	// 821AE014: 4807EEBD  bl 0x8222ced0
	ctx.lr = 0x821AE018;
	sub_8222CED0(ctx, base);
	// 821AE018: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE020: 409A0044  bne cr6, 0x821ae064
	if !ctx.cr[6].eq {
	pc = 0x821AE064; continue 'dispatch;
	}
	// 821AE024: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AE028: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 821AE02C: 394B0CA0  addi r10, r11, 0xca0
	ctx.r[10].s64 = ctx.r[11].s64 + 3232;
	// 821AE030: 3969206C  addi r11, r9, 0x206c
	ctx.r[11].s64 = ctx.r[9].s64 + 8300;
	// 821AE034: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE038: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE03C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821AE040: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821AE044: 419A0014  beq cr6, 0x821ae058
	if ctx.cr[6].eq {
	pc = 0x821AE058; continue 'dispatch;
	}
	// 821AE048: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821AE04C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AE050: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821AE054: 419AFFE0  beq cr6, 0x821ae034
	if ctx.cr[6].eq {
	pc = 0x821AE034; continue 'dispatch;
	}
	// 821AE058: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821AE05C: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821AE060: 4800001C  b 0x821ae07c
	pc = 0x821AE07C; continue 'dispatch;
	// 821AE064: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821AE068: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE06C: 388A206C  addi r4, r10, 0x206c
	ctx.r[4].s64 = ctx.r[10].s64 + 8300;
	// 821AE070: 480BF789  bl 0x8226d7f8
	ctx.lr = 0x821AE074;
	sub_8226D7F8(ctx, base);
	// 821AE074: 7C690034  cntlzw r9, r3
	ctx.r[9].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821AE078: 553FDFFE  rlwinm r31, r9, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821AE07C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE080: 48066D59  bl 0x82214dd8
	ctx.lr = 0x821AE084;
	sub_82214DD8(ctx, base);
	// 821AE084: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821AE088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE08C: 419A00D4  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821AE090: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821AE094: 419A0018  beq cr6, 0x821ae0ac
	if ctx.cr[6].eq {
	pc = 0x821AE0AC; continue 'dispatch;
	}
	// 821AE098: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AE09C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AE0A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AE0A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE0A8: 409A0008  bne cr6, 0x821ae0b0
	if !ctx.cr[6].eq {
	pc = 0x821AE0B0; continue 'dispatch;
	}
	// 821AE0AC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821AE0B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AE0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE0B8: 419A00A8  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821AE0BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AE0C0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821AE0C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821AE0C8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821AE0CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE0D0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AE0D4: 480667C5  bl 0x82214898
	ctx.lr = 0x821AE0D8;
	sub_82214898(ctx, base);
	// 821AE0D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AE0DC: 387E0074  addi r3, r30, 0x74
	ctx.r[3].s64 = ctx.r[30].s64 + 116;
	// 821AE0E0: 48323DE9  bl 0x824d1ec8
	ctx.lr = 0x821AE0E4;
	sub_824D1EC8(ctx, base);
	// 821AE0E4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821AE0E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE0EC: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 821AE0F0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821AE0F4: 4BFE5D45  bl 0x82193e38
	ctx.lr = 0x821AE0F8;
	sub_82193E38(ctx, base);
	// 821AE0F8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821AE0FC: 48AFB358  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 821AE100: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE168 size=240
    let mut pc: u32 = 0x821AE168;
    'dispatch: loop {
        match pc {
            0x821AE168 => {
    //   block [0x821AE168..0x821AE258)
	// 821AE168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE16C: 48AFB299  bl 0x82ca9404
	ctx.lr = 0x821AE170;
	sub_82CA93D0(ctx, base);
	// 821AE170: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE174: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821AE178: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE17C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AE180: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 821AE184: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821AE188: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821AE18C: 93FD0018  stw r31, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 821AE190: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821AE194: 9BDF009C  stb r30, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u8 ) };
	// 821AE198: 38CA7E70  addi r6, r10, 0x7e70
	ctx.r[6].s64 = ctx.r[10].s64 + 32368;
	// 821AE19C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AE1A0: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821AE1A4: 55451838  slwi r5, r10, 3
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AE1A8: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AE1AC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 821AE1B0: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AE1B4: 38EB2008  addi r7, r11, 0x2008
	ctx.r[7].s64 = ctx.r[11].s64 + 8200;
	// 821AE1B8: 810B2000  lwz r8, 0x2000(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AE1BC: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821AE1C0: 55441838  slwi r4, r10, 3
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AE1C4: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 821AE1C8: 5509083C  slwi r9, r8, 1
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE1CC: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821AE1D0: 912B2000  stw r9, 0x2000(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8192 as u32), ctx.r[9].u32 ) };
	// 821AE1D4: 7CC4392E  stwx r6, r4, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32), ctx.r[6].u32) };
	// 821AE1D8: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821AE1DC: 812B4008  lwz r9, 0x4008(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821AE1E0: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE1E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AE1E8: 912B4008  stw r9, 0x4008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16392 as u32), ctx.r[9].u32 ) };
	// 821AE1EC: 914B400C  stw r10, 0x400c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16396 as u32), ctx.r[10].u32 ) };
	// 821AE1F0: 480BCE89  bl 0x8226b078
	ctx.lr = 0x821AE1F4;
	sub_8226B078(ctx, base);
	// 821AE1F4: 38BF0088  addi r5, r31, 0x88
	ctx.r[5].s64 = ctx.r[31].s64 + 136;
	// 821AE1F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AE1FC: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821AE200: 4890D999  bl 0x82abbb98
	ctx.lr = 0x821AE204;
	sub_82ABBB98(ctx, base);
	// 821AE204: 80DF007C  lwz r6, 0x7c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821AE208: 3C608332  lis r3, -0x7cce
	ctx.r[3].s64 = -2093875200;
	// 821AE20C: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 821AE210: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AE214: 38FF00A4  addi r7, r31, 0xa4
	ctx.r[7].s64 = ctx.r[31].s64 + 164;
	// 821AE218: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821AE21C: 91660010  stw r11, 0x10(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821AE220: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AE224: 91660014  stw r11, 0x14(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821AE228: 91660018  stw r11, 0x18(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821AE22C: 9386001C  stw r28, 0x1c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
	// 821AE230: 91660028  stw r11, 0x28(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 821AE234: 9166002C  stw r11, 0x2c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 821AE238: 93660034  stw r27, 0x34(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(52 as u32), ctx.r[27].u32 ) };
	// 821AE23C: 994316DE  stb r10, 0x16de(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(5854 as u32), ctx.r[10].u8 ) };
	// 821AE240: 992816DF  stb r9, 0x16df(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(5855 as u32), ctx.r[9].u8 ) };
	// 821AE244: 90FD001C  stw r7, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 821AE248: 9BDD0708  stb r30, 0x708(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1800 as u32), ctx.r[30].u8 ) };
	// 821AE24C: 9BDD0709  stb r30, 0x709(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1801 as u32), ctx.r[30].u8 ) };
	// 821AE250: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE254: 48AFB200  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE258 size=240
    let mut pc: u32 = 0x821AE258;
    'dispatch: loop {
        match pc {
            0x821AE258 => {
    //   block [0x821AE258..0x821AE348)
	// 821AE258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE25C: 48AFB1A9  bl 0x82ca9404
	ctx.lr = 0x821AE260;
	sub_82CA93D0(ctx, base);
	// 821AE260: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE264: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821AE268: 38C0007F  li r6, 0x7f
	ctx.r[6].s64 = 127;
	// 821AE26C: 38ABA99C  addi r5, r11, -0x5664
	ctx.r[5].s64 = ctx.r[11].s64 + -22116;
	// 821AE270: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821AE274: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821AE278: 4BFFFEF1  bl 0x821ae168
	ctx.lr = 0x821AE27C;
	sub_821AE168(ctx, base);
	// 821AE27C: 38DD00A4  addi r6, r29, 0xa4
	ctx.r[6].s64 = ctx.r[29].s64 + 164;
	// 821AE280: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821AE284: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AE288: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821AE28C: 4890D6DD  bl 0x82abb968
	ctx.lr = 0x821AE290;
	sub_82ABB968(ctx, base);
	// 821AE290: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE294: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 821AE298: 354B04C0  addic. r10, r11, 0x4c0
	ctx.xer.ca = (ctx.r[11].u32 > (!(1216 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 1216;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AE29C: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE348 size=36
    let mut pc: u32 = 0x821AE348;
    'dispatch: loop {
        match pc {
            0x821AE348 => {
    //   block [0x821AE348..0x821AE36C)
	// 821AE348: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 821AE34C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE350: 409A001C  bne cr6, 0x821ae36c
	if !ctx.cr[6].eq {
		sub_821AE36C(ctx, base);
		return;
	}
	// 821AE354: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821AE358: 816A9650  lwz r11, -0x69b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821AE35C: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821AE360: 816A9650  lwz r11, -0x69b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821AE364: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821AE368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE36C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE36C size=16
    let mut pc: u32 = 0x821AE36C;
    'dispatch: loop {
        match pc {
            0x821AE36C => {
    //   block [0x821AE36C..0x821AE37C)
	// 821AE36C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821AE370: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821AE374: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821AE378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE380 size=252
    let mut pc: u32 = 0x821AE380;
    'dispatch: loop {
        match pc {
            0x821AE380 => {
    //   block [0x821AE380..0x821AE47C)
	// 821AE380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE384: 48AFB089  bl 0x82ca940c
	ctx.lr = 0x821AE388;
	sub_82CA93D0(ctx, base);
	// 821AE388: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE38C: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821AE390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AE394: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821AE398: 812A711C  lwz r9, 0x711c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28956 as u32) ) } as u64;
	// 821AE39C: 2B090020  cmplwi cr6, r9, 0x20
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32 as u32, &mut ctx.xer);
	// 821AE3A0: 409A0010  bne cr6, 0x821ae3b0
	if !ctx.cr[6].eq {
	pc = 0x821AE3B0; continue 'dispatch;
	}
	// 821AE3A4: 812B7120  lwz r9, 0x7120(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28960 as u32) ) } as u64;
	// 821AE3A8: 2B090060  cmplwi cr6, r9, 0x60
	ctx.cr[6].compare_u32(ctx.r[9].u32, 96 as u32, &mut ctx.xer);
	// 821AE3AC: 419A002C  beq cr6, 0x821ae3d8
	if ctx.cr[6].eq {
	pc = 0x821AE3D8; continue 'dispatch;
	}
	// 821AE3B0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821AE3B4: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 821AE3B8: 912A711C  stw r9, 0x711c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28956 as u32), ctx.r[9].u32 ) };
	// 821AE3BC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821AE3C0: 910B7120  stw r8, 0x7120(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28960 as u32), ctx.r[8].u32 ) };
	// 821AE3C4: 38C00060  li r6, 0x60
	ctx.r[6].s64 = 96;
	// 821AE3C8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821AE3CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AE3D0: 806A0364  lwz r3, 0x364(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 821AE3D4: 4BFEE995  bl 0x8219cd68
	ctx.lr = 0x821AE3D8;
	sub_8219CD68(ctx, base);
	// 821AE3D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE3DC: 38A0001B  li r5, 0x1b
	ctx.r[5].s64 = 27;
	// 821AE3E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE3E4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE3E8: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821AE3EC: 48046095  bl 0x821f4480
	ctx.lr = 0x821AE3F0;
	sub_821F4480(ctx, base);
	// 821AE3F0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AE3F4: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821AE3F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AE3FC: 419A0078  beq cr6, 0x821ae474
	if ctx.cr[6].eq {
	pc = 0x821AE474; continue 'dispatch;
	}
	// 821AE400: 3FA0834C  lis r29, -0x7cb4
	ctx.r[29].s64 = -2092171264;
	// 821AE404: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 821AE408: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AE40C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AE410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE414: 419A0018  beq cr6, 0x821ae42c
	if ctx.cr[6].eq {
	pc = 0x821AE42C; continue 'dispatch;
	}
	// 821AE418: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AE41C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821AE420: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821AE424: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AE428: 41980008  blt cr6, 0x821ae430
	if ctx.cr[6].lt {
	pc = 0x821AE430; continue 'dispatch;
	}
	// 821AE42C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AE430: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AE434: 88FDEC61  lbz r7, -0x139f(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(-5023 as u32) ) } as u64;
	// 821AE438: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AE43C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE440: 993ECBD2  stb r9, -0x342e(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(-13358 as u32), ctx.r[9].u8 ) };
	// 821AE444: 7FE8582E  lwzx r31, r8, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AE448: 419A000C  beq cr6, 0x821ae454
	if ctx.cr[6].eq {
	pc = 0x821AE454; continue 'dispatch;
	}
	// 821AE44C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE450: 488BF2C1  bl 0x82a6d710
	ctx.lr = 0x821AE454;
	sub_82A6D710(ctx, base);
	// 821AE454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE458: 488C0241  bl 0x82a6e698
	ctx.lr = 0x821AE45C;
	sub_82A6E698(ctx, base);
	// 821AE45C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE460: 48051919  bl 0x821ffd78
	ctx.lr = 0x821AE464;
	sub_821FFD78(ctx, base);
	// 821AE464: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AE468: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821AE46C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AE470: 409AFF98  bne cr6, 0x821ae408
	if !ctx.cr[6].eq {
	pc = 0x821AE408; continue 'dispatch;
	}
	// 821AE474: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821AE478: 48AFAFE4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AE480 size=308
    let mut pc: u32 = 0x821AE480;
    'dispatch: loop {
        match pc {
            0x821AE480 => {
    //   block [0x821AE480..0x821AE5B4)
	// 821AE480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE484: 48AFAF89  bl 0x82ca940c
	ctx.lr = 0x821AE488;
	sub_82CA93D0(ctx, base);
	// 821AE488: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821AE48C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE490: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AE494: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AE498: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821AE49C: 38A6CC94  addi r5, r6, -0x336c
	ctx.r[5].s64 = ctx.r[6].s64 + -13164;
	// 821AE4A0: 812B6AB8  lwz r9, 0x6ab8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AE4A4: C01E00D0  lfs f0, 0xd0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE4A8: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AE4AC: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 821AE4B0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AE4B4: 7D48FE70  srawi r8, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 821AE4B8: 8089000C  lwz r4, 0xc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AE4BC: 7D075038  and r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[10].u64;
	// 821AE4C0: C046CC94  lfs f2, -0x336c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-13164 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AE4C4: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 821AE4C8: C3E5C7FC  lfs f31, -0x3804(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14340 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AE4CC: C025C7F0  lfs f1, -0x3810(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-14352 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AE4D0: 216A0005  subfic r11, r10, 5
	ctx.xer.ca = ctx.r[10].u32 <= 5 as u32;
	ctx.r[11].s64 = (5 as i64) - ctx.r[10].s64;
	// 821AE4D4: 81240058  lwz r9, 0x58(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AE4D8: 7D63FE70  srawi r3, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 821AE4DC: 7C6B5838  and r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 & ctx.r[11].u64;
	// 821AE4E0: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE4E4: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE4E8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE4EC: 480119BD  bl 0x821bfea8
	ctx.lr = 0x821AE4F0;
	sub_821BFEA8(ctx, base);
	// 821AE4F0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AE4F4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AE4F8: 419A0008  beq cr6, 0x821ae500
	if ctx.cr[6].eq {
	pc = 0x821AE500; continue 'dispatch;
	}
	// 821AE4FC: C3FE00CC  lfs f31, 0xcc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AE500: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 821AE504: 80DE00C4  lwz r6, 0xc4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE508: 394B003C  addi r10, r11, 0x3c
	ctx.r[10].s64 = ctx.r[11].s64 + 60;
	// 821AE50C: 811E0054  lwz r8, 0x54(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AE510: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AE514: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 821AE518: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE51C: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AE520: 419A0008  beq cr6, 0x821ae528
	if ctx.cr[6].eq {
	pc = 0x821AE528; continue 'dispatch;
	}
	// 821AE524: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AE528: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AE52C: 419A0048  beq cr6, 0x821ae574
	if ctx.cr[6].eq {
	pc = 0x821AE574; continue 'dispatch;
	}
	// 821AE530: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE534: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AE538: 409A0008  bne cr6, 0x821ae540
	if !ctx.cr[6].eq {
	pc = 0x821AE540; continue 'dispatch;
	}
	// 821AE53C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AE540: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE544: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821AE548: 419A0018  beq cr6, 0x821ae560
	if ctx.cr[6].eq {
	pc = 0x821AE560; continue 'dispatch;
	}
	// 821AE54C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AE550: 409A0008  bne cr6, 0x821ae558
	if !ctx.cr[6].eq {
	pc = 0x821AE558; continue 'dispatch;
	}
	// 821AE554: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AE558: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE55C: 4BFFFFC0  b 0x821ae51c
	pc = 0x821AE51C; continue 'dispatch;
	// 821AE560: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE564: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AE568: 409A0008  bne cr6, 0x821ae570
	if !ctx.cr[6].eq {
	pc = 0x821AE570; continue 'dispatch;
	}
	// 821AE56C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821AE570: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AE574: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821AE578: 395D0038  addi r10, r29, 0x38
	ctx.r[10].s64 = ctx.r[29].s64 + 56;
	// 821AE57C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AE580: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AE584: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821AE588: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE58C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821AE590: 7D69F42E  lfsx f11, r9, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AE594: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE598: ED2A07F2  fmuls f9, f10, f31
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AE59C: FD00481E  fctiwz f8, f9
	ctx.f[8].s64 = if ctx.f[9].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[9].f64.trunc() as i32 as i64 };
	// 821AE5A0: D9010050  stfd f8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[8].u64 ) };
	// 821AE5A4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AE5A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE5AC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821AE5B0: 48AFAEAC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE5B8 size=32
    let mut pc: u32 = 0x821AE5B8;
    'dispatch: loop {
        match pc {
            0x821AE5B8 => {
    //   block [0x821AE5B8..0x821AE5D8)
	// 821AE5B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE5BC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AE5C0: 409A0020  bne cr6, 0x821ae5e0
	if !ctx.cr[6].eq {
		sub_821AE5E0(ctx, base);
		return;
	}
	// 821AE5C4: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 821AE5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE5CC: 409A000C  bne cr6, 0x821ae5d8
	if !ctx.cr[6].eq {
		sub_821AE5D8(ctx, base);
		return;
	}
	// 821AE5D0: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE5D8 size=8
    let mut pc: u32 = 0x821AE5D8;
    'dispatch: loop {
        match pc {
            0x821AE5D8 => {
    //   block [0x821AE5D8..0x821AE5E0)
	// 821AE5D8: 806300B0  lwz r3, 0xb0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AE5DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE5E0 size=16
    let mut pc: u32 = 0x821AE5E0;
    'dispatch: loop {
        match pc {
            0x821AE5E0 => {
    //   block [0x821AE5E0..0x821AE5F0)
	// 821AE5E0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821AE5E4: 409A000C  bne cr6, 0x821ae5f0
	if !ctx.cr[6].eq {
		sub_821AE5F0(ctx, base);
		return;
	}
	// 821AE5E8: 80630230  lwz r3, 0x230(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(560 as u32) ) } as u64;
	// 821AE5EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE5F0 size=8
    let mut pc: u32 = 0x821AE5F0;
    'dispatch: loop {
        match pc {
            0x821AE5F0 => {
    //   block [0x821AE5F0..0x821AE5F8)
	// 821AE5F0: 80630238  lwz r3, 0x238(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(568 as u32) ) } as u64;
	// 821AE5F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE5F8 size=12
    let mut pc: u32 = 0x821AE5F8;
    'dispatch: loop {
        match pc {
            0x821AE5F8 => {
    //   block [0x821AE5F8..0x821AE604)
	// 821AE5F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821AE5FC: 386B60C0  addi r3, r11, 0x60c0
	ctx.r[3].s64 = ctx.r[11].s64 + 24768;
	// 821AE600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE608 size=160
    let mut pc: u32 = 0x821AE608;
    'dispatch: loop {
        match pc {
            0x821AE608 => {
    //   block [0x821AE608..0x821AE6A8)
	// 821AE608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE60C: 48AFADFD  bl 0x82ca9408
	ctx.lr = 0x821AE610;
	sub_82CA93D0(ctx, base);
	// 821AE610: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AE618: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE61C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821AE620: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE628: 419A0074  beq cr6, 0x821ae69c
	if ctx.cr[6].eq {
	pc = 0x821AE69C; continue 'dispatch;
	}
	// 821AE62C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE630: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 821AE634: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AE638: 409A003C  bne cr6, 0x821ae674
	if !ctx.cr[6].eq {
	pc = 0x821AE674; continue 'dispatch;
	}
	// 821AE63C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821AE640: 388BDF68  addi r4, r11, -0x2098
	ctx.r[4].s64 = ctx.r[11].s64 + -8344;
	// 821AE644: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821AE648: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821AE64C: 480B95D5  bl 0x82267c20
	ctx.lr = 0x821AE650;
	sub_82267C20(ctx, base);
	// 821AE650: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821AE654: 41820020  beq 0x821ae674
	if ctx.cr[0].eq {
	pc = 0x821AE674; continue 'dispatch;
	}
	// 821AE658: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE65C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821AE660: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE664: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AE668: 808A0010  lwz r4, 0x10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AE66C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE670: 4E800421  bctrl
	ctx.lr = 0x821AE674;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE674: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE678: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AE67C: 419A0020  beq cr6, 0x821ae69c
	if ctx.cr[6].eq {
	pc = 0x821AE69C; continue 'dispatch;
	}
	// 821AE680: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE684: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AE688: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE68C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AE690: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE694: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AE698: 48000008  b 0x821ae6a0
	pc = 0x821AE6A0; continue 'dispatch;
	// 821AE69C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AE6A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE6A4: 48AFADB4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE6A8 size=124
    let mut pc: u32 = 0x821AE6A8;
    'dispatch: loop {
        match pc {
            0x821AE6A8 => {
    //   block [0x821AE6A8..0x821AE724)
	// 821AE6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE6B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AE6B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE6B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE6BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821AE6C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AE6C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE6C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE6CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE6D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE6D4: 4E800421  bctrl
	ctx.lr = 0x821AE6D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE6D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AE6DC: 38BE0054  addi r5, r30, 0x54
	ctx.r[5].s64 = ctx.r[30].s64 + 84;
	// 821AE6E0: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 821AE6E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE6E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE6EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821AE6F0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE6F4: 7FEBF12E  stwx r31, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[31].u32) };
	// 821AE6F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE6FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE704: 4E800421  bctrl
	ctx.lr = 0x821AE708;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE708: 987E0058  stb r3, 0x58(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[3].u8 ) };
	// 821AE70C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AE710: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE714: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE718: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AE71C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AE728 size=240
    let mut pc: u32 = 0x821AE728;
    'dispatch: loop {
        match pc {
            0x821AE728 => {
    //   block [0x821AE728..0x821AE818)
	// 821AE728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE734: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE738: 816401AC  lwz r11, 0x1ac(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(428 as u32) ) } as u64;
	// 821AE73C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AE740: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AE744: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821AE748: 41820064  beq 0x821ae7ac
	if ctx.cr[0].eq {
	pc = 0x821AE7AC; continue 'dispatch;
	}
	// 821AE74C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AE750: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821AE754: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 821AE758: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AE75C: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE760: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821AE764: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821AE768: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE76C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821AE770: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE774: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821AE778: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AE77C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821AE780: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821AE784: 4200FFF8  bdnz 0x821ae77c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821AE77C; continue 'dispatch;
	}
	// 821AE788: 388401C0  addi r4, r4, 0x1c0
	ctx.r[4].s64 = ctx.r[4].s64 + 448;
	// 821AE78C: 990100A8  stb r8, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u8 ) };
	// 821AE790: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AE794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AE798: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821AE79C: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821AE7A0: 4BFFFF09  bl 0x821ae6a8
	ctx.lr = 0x821AE7A4;
	sub_821AE6A8(ctx, base);
	// 821AE7A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AE7A8: 48000050  b 0x821ae7f8
	pc = 0x821AE7F8; continue 'dispatch;
	// 821AE7AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AE7B0: 80E40008  lwz r7, 8(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE7B4: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 821AE7B8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 821AE7BC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821AE7C0: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 821AE7C4: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE7C8: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE7CC: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821AE7D0: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE7D4: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821AE7D8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE7DC: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 821AE7E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AE7E4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821AE7E8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821AE7EC: 4200FFF8  bdnz 0x821ae7e4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821AE7E4; continue 'dispatch;
	}
	// 821AE7F0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821AE7F4: 99010108  stb r8, 0x108(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[8].u8 ) };
	// 821AE7F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE7FC: 4BFFE255  bl 0x821aca50
	ctx.lr = 0x821AE800;
	sub_821ACA50(ctx, base);
	// 821AE800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AE804: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821AE808: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE80C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE818 size=260
    let mut pc: u32 = 0x821AE818;
    'dispatch: loop {
        match pc {
            0x821AE818 => {
    //   block [0x821AE818..0x821AE91C)
	// 821AE818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE81C: 48AFABF1  bl 0x82ca940c
	ctx.lr = 0x821AE820;
	sub_82CA93D0(ctx, base);
	// 821AE820: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE824: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821AE828: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE82C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AE830: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE834: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE838: 4803E1F9  bl 0x821eca30
	ctx.lr = 0x821AE83C;
	sub_821ECA30(ctx, base);
	// 821AE83C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AE840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE844: 409A0030  bne cr6, 0x821ae874
	if !ctx.cr[6].eq {
	pc = 0x821AE874; continue 'dispatch;
	}
	// 821AE848: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE84C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE850: 816A0034  lwz r11, 0x34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AE854: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AE858: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AE85C: 419A0018  beq cr6, 0x821ae874
	if ctx.cr[6].eq {
	pc = 0x821AE874; continue 'dispatch;
	}
	// 821AE860: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 821AE864: 48119475  bl 0x822c7cd8
	ctx.lr = 0x821AE868;
	sub_822C7CD8(ctx, base);
	// 821AE868: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821AE86C: 409A0008  bne cr6, 0x821ae874
	if !ctx.cr[6].eq {
	pc = 0x821AE874; continue 'dispatch;
	}
	// 821AE870: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821AE874: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE878: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AE87C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE880: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AE884: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821AE888: 409A0008  bne cr6, 0x821ae890
	if !ctx.cr[6].eq {
	pc = 0x821AE890; continue 'dispatch;
	}
	// 821AE88C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821AE890: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AE894: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AE898: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821AE89C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE8A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE8A4: 409A0028  bne cr6, 0x821ae8cc
	if !ctx.cr[6].eq {
	pc = 0x821AE8CC; continue 'dispatch;
	}
	// 821AE8A8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AE8AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE8B0: 419A0014  beq cr6, 0x821ae8c4
	if ctx.cr[6].eq {
	pc = 0x821AE8C4; continue 'dispatch;
	}
	// 821AE8B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AE8B8: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821AE8BC: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE8C0: 4082000C  bne 0x821ae8cc
	if !ctx.cr[0].eq {
	pc = 0x821AE8CC; continue 'dispatch;
	}
	// 821AE8C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AE8C8: 48000008  b 0x821ae8d0
	pc = 0x821AE8D0; continue 'dispatch;
	// 821AE8CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AE8D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AE8D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE8D8: 409A0008  bne cr6, 0x821ae8e0
	if !ctx.cr[6].eq {
	pc = 0x821AE8E0; continue 'dispatch;
	}
	// 821AE8DC: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 821AE8E0: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821AE8E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE8E8: 409A0010  bne cr6, 0x821ae8f8
	if !ctx.cr[6].eq {
	pc = 0x821AE8F8; continue 'dispatch;
	}
	// 821AE8EC: 550B063E  clrlwi r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 821AE8F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE8F4: 419A0008  beq cr6, 0x821ae8fc
	if ctx.cr[6].eq {
	pc = 0x821AE8FC; continue 'dispatch;
	}
	// 821AE8F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AE8FC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821AE900: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821AE904: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AE908: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821AE90C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AE910: 480E8879  bl 0x82297188
	ctx.lr = 0x821AE914;
	sub_82297188(ctx, base);
	// 821AE914: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE918: 48AFAB44  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE920 size=184
    let mut pc: u32 = 0x821AE920;
    'dispatch: loop {
        match pc {
            0x821AE920 => {
    //   block [0x821AE920..0x821AE9D8)
	// 821AE920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE924: 48AFAAE9  bl 0x82ca940c
	ctx.lr = 0x821AE928;
	sub_82CA93D0(ctx, base);
	// 821AE928: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE92C: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821AE930: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE934: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AE938: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE93C: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE940: 4803E0F1  bl 0x821eca30
	ctx.lr = 0x821AE944;
	sub_821ECA30(ctx, base);
	// 821AE944: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821AE948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE94C: 409A0030  bne cr6, 0x821ae97c
	if !ctx.cr[6].eq {
	pc = 0x821AE97C; continue 'dispatch;
	}
	// 821AE950: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE954: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE958: 816A0034  lwz r11, 0x34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AE95C: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821AE960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AE964: 419A0018  beq cr6, 0x821ae97c
	if ctx.cr[6].eq {
	pc = 0x821AE97C; continue 'dispatch;
	}
	// 821AE968: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 821AE96C: 4811936D  bl 0x822c7cd8
	ctx.lr = 0x821AE970;
	sub_822C7CD8(ctx, base);
	// 821AE970: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 821AE974: 409A0008  bne cr6, 0x821ae97c
	if !ctx.cr[6].eq {
	pc = 0x821AE97C; continue 'dispatch;
	}
	// 821AE978: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821AE97C: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821AE980: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AE984: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AE988: 81090028  lwz r8, 0x28(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AE98C: 2F080005  cmpwi cr6, r8, 5
	ctx.cr[6].compare_i32(ctx.r[8].s32, 5, &mut ctx.xer);
	// 821AE990: 409A0008  bne cr6, 0x821ae998
	if !ctx.cr[6].eq {
	pc = 0x821AE998; continue 'dispatch;
	}
	// 821AE994: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AE998: 57C9063E  clrlwi r9, r30, 0x18
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821AE99C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AE9A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AE9A4: 409A0010  bne cr6, 0x821ae9b4
	if !ctx.cr[6].eq {
	pc = 0x821AE9B4; continue 'dispatch;
	}
	// 821AE9A8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821AE9AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE9B0: 419A0008  beq cr6, 0x821ae9b8
	if ctx.cr[6].eq {
	pc = 0x821AE9B8; continue 'dispatch;
	}
	// 821AE9B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AE9B8: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 821AE9BC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821AE9C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AE9C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AE9C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AE9CC: 480E87BD  bl 0x82297188
	ctx.lr = 0x821AE9D0;
	sub_82297188(ctx, base);
	// 821AE9D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AE9D4: 48AFAA88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE9D8 size=8
    let mut pc: u32 = 0x821AE9D8;
    'dispatch: loop {
        match pc {
            0x821AE9D8 => {
    //   block [0x821AE9D8..0x821AE9E0)
	// 821AE9D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821AE9DC: 48029B2C  b 0x821d8508
	sub_821D8508(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE9E0 size=444
    let mut pc: u32 = 0x821AE9E0;
    'dispatch: loop {
        match pc {
            0x821AE9E0 => {
    //   block [0x821AE9E0..0x821AEB9C)
	// 821AE9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE9E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AE9EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE9F0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AEBA0 size=660
    let mut pc: u32 = 0x821AEBA0;
    'dispatch: loop {
        match pc {
            0x821AEBA0 => {
    //   block [0x821AEBA0..0x821AEE34)
	// 821AEBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AEBA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AEBAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AEBB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AEBB4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AEBB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821AEBBC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821AEBC0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AEBC4: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 821AEBC8: 480B5669  bl 0x82264230
	ctx.lr = 0x821AEBCC;
	sub_82264230(ctx, base);
	// 821AEBCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AEBD0: 419A024C  beq cr6, 0x821aee1c
	if ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AEBD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AEBD8: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821AEBDC: 480F029D  bl 0x8229ee78
	ctx.lr = 0x821AEBE0;
	sub_8229EE78(ctx, base);
	// 821AEBE0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AEBE4: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821AEBE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AEBEC: 419A00F4  beq cr6, 0x821aece0
	if ctx.cr[6].eq {
	pc = 0x821AECE0; continue 'dispatch;
	}
	// 821AEBF0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AEBF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEBF8: 419A0024  beq cr6, 0x821aec1c
	if ctx.cr[6].eq {
	pc = 0x821AEC1C; continue 'dispatch;
	}
	// 821AEBFC: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 821AEC00: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AEC04: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821AEC08: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AEC0C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AEC10: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AEC14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEC18: 480000CC  b 0x821aece4
	pc = 0x821AECE4; continue 'dispatch;
	// 821AEC1C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AEC20: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AEC24: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821AEC28: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AEC2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AEC30: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AEC34: 40810054  ble 0x821aec88
	if !ctx.cr[0].gt {
	pc = 0x821AEC88; continue 'dispatch;
	}
	// 821AEC38: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AEC3C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AEC40: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AEC44: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AEC48: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821AEC4C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AEC50: 41980008  blt cr6, 0x821aec58
	if ctx.cr[6].lt {
	pc = 0x821AEC58; continue 'dispatch;
	}
	// 821AEC54: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821AEC58: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AEC5C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AEC60: 419A0014  beq cr6, 0x821aec74
	if ctx.cr[6].eq {
	pc = 0x821AEC74; continue 'dispatch;
	}
	// 821AEC64: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AEC68: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AEC6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AEC70: 4800000C  b 0x821aec7c
	pc = 0x821AEC7C; continue 'dispatch;
	// 821AEC74: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AEC78: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821AEC7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AEC80: 4199FFB8  bgt cr6, 0x821aec38
	if ctx.cr[6].gt {
	pc = 0x821AEC38; continue 'dispatch;
	}
	// 821AEC84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AEC88: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AEC8C: 419A0040  beq cr6, 0x821aeccc
	if ctx.cr[6].eq {
	pc = 0x821AECCC; continue 'dispatch;
	}
	// 821AEC90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AEC94: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821AEC98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEC9C: 41990008  bgt cr6, 0x821aeca4
	if ctx.cr[6].gt {
	pc = 0x821AECA4; continue 'dispatch;
	}
	// 821AECA0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821AECA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AECA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AECAC: 409A0020  bne cr6, 0x821aeccc
	if !ctx.cr[6].eq {
	pc = 0x821AECCC; continue 'dispatch;
	}
	// 821AECB0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AECB4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AECB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AECBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AECC0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AECC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AECC8: 4800001C  b 0x821aece4
	pc = 0x821AECE4; continue 'dispatch;
	// 821AECCC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AECD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AECD4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821AECD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AECDC: 48000008  b 0x821aece4
	pc = 0x821AECE4; continue 'dispatch;
	// 821AECE0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821AECE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AECE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AECEC: 419A0130  beq cr6, 0x821aee1c
	if ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AECF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AECF4: 4866388D  bl 0x82812580
	ctx.lr = 0x821AECF8;
	sub_82812580(ctx, base);
	// 821AECF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AECFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AED00: 419A011C  beq cr6, 0x821aee1c
	if ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AED04: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AED08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AED0C: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821AED10: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AED14: 419A00F4  beq cr6, 0x821aee08
	if ctx.cr[6].eq {
	pc = 0x821AEE08; continue 'dispatch;
	}
	// 821AED18: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AED1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AED20: 419A0024  beq cr6, 0x821aed44
	if ctx.cr[6].eq {
	pc = 0x821AED44; continue 'dispatch;
	}
	// 821AED24: 892A00A2  lbz r9, 0xa2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(162 as u32) ) } as u64;
	// 821AED28: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AED2C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821AED30: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AED34: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AED38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821AED3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AED40: 480000CC  b 0x821aee0c
	pc = 0x821AEE0C; continue 'dispatch;
	// 821AED44: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AED48: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AED4C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821AED50: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AED54: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AED58: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AED5C: 40810054  ble 0x821aedb0
	if !ctx.cr[0].gt {
	pc = 0x821AEDB0; continue 'dispatch;
	}
	// 821AED60: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AED64: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AED68: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AED6C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AED70: 2F0700A2  cmpwi cr6, r7, 0xa2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 162, &mut ctx.xer);
	// 821AED74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AED78: 41980008  blt cr6, 0x821aed80
	if ctx.cr[6].lt {
	pc = 0x821AED80; continue 'dispatch;
	}
	// 821AED7C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821AED80: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AED84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AED88: 419A0014  beq cr6, 0x821aed9c
	if ctx.cr[6].eq {
	pc = 0x821AED9C; continue 'dispatch;
	}
	// 821AED8C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AED90: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AED94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AED98: 4800000C  b 0x821aeda4
	pc = 0x821AEDA4; continue 'dispatch;
	// 821AED9C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AEDA0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821AEDA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AEDA8: 4199FFB8  bgt cr6, 0x821aed60
	if ctx.cr[6].gt {
	pc = 0x821AED60; continue 'dispatch;
	}
	// 821AEDAC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821AEDB0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AEDB4: 419A0040  beq cr6, 0x821aedf4
	if ctx.cr[6].eq {
	pc = 0x821AEDF4; continue 'dispatch;
	}
	// 821AEDB8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AEDBC: 2F0B00A2  cmpwi cr6, r11, 0xa2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 162, &mut ctx.xer);
	// 821AEDC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEDC4: 41990008  bgt cr6, 0x821aedcc
	if ctx.cr[6].gt {
	pc = 0x821AEDCC; continue 'dispatch;
	}
	// 821AEDC8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821AEDCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AEDD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEDD4: 409A0020  bne cr6, 0x821aedf4
	if !ctx.cr[6].eq {
	pc = 0x821AEDF4; continue 'dispatch;
	}
	// 821AEDD8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AEDDC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AEDE0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AEDE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AEDE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821AEDEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEDF0: 4800001C  b 0x821aee0c
	pc = 0x821AEE0C; continue 'dispatch;
	// 821AEDF4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AEDF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AEDFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821AEE00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEE04: 48000008  b 0x821aee0c
	pc = 0x821AEE0C; continue 'dispatch;
	// 821AEE08: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821AEE0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AEE10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEE14: 419A0008  beq cr6, 0x821aee1c
	if ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AEE18: 4BFFFBC9  bl 0x821ae9e0
	ctx.lr = 0x821AEE1C;
	sub_821AE9E0(ctx, base);
	// 821AEE1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AEE20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AEE24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AEE28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AEE2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AEE30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AEE38 size=284
    let mut pc: u32 = 0x821AEE38;
    'dispatch: loop {
        match pc {
            0x821AEE38 => {
    //   block [0x821AEE38..0x821AEF54)
	// 821AEE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEE3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AEE40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AEE44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AEE48: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821AEE4C: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AEF58 size=100
    let mut pc: u32 = 0x821AEF58;
    'dispatch: loop {
        match pc {
            0x821AEF58 => {
    //   block [0x821AEF58..0x821AEFBC)
	// 821AEF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AEF60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AEF64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AEF68: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821AEF6C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821AEF70: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821AEF74: 38E99150  addi r7, r9, -0x6eb0
	ctx.r[7].s64 = ctx.r[9].s64 + -28336;
	// 821AEF78: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEF7C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821AEF80: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821AEF84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AEFC0 size=56
    let mut pc: u32 = 0x821AEFC0;
    'dispatch: loop {
        match pc {
            0x821AEFC0 => {
    //   block [0x821AEFC0..0x821AEFF8)
	// 821AEFC0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821AEFC4: 419A0018  beq cr6, 0x821aefdc
	if ctx.cr[6].eq {
	pc = 0x821AEFDC; continue 'dispatch;
	}
	// 821AEFC8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AEFCC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AEFD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEFD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AEFD8: 409A0008  bne cr6, 0x821aefe0
	if !ctx.cr[6].eq {
	pc = 0x821AEFE0; continue 'dispatch;
	}
	// 821AEFDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AEFE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AEFE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEFE8: 419A0010  beq cr6, 0x821aeff8
	if ctx.cr[6].eq {
		sub_821AEFF8(ctx, base);
		return;
	}
	// 821AEFEC: 81640038  lwz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AEFF0: 55635FFE  rlwinm r3, r11, 0xb, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 821AEFF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AEFF8 size=8
    let mut pc: u32 = 0x821AEFF8;
    'dispatch: loop {
        match pc {
            0x821AEFF8 => {
    //   block [0x821AEFF8..0x821AF000)
	// 821AEFF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AEFFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF000 size=56
    let mut pc: u32 = 0x821AF000;
    'dispatch: loop {
        match pc {
            0x821AF000 => {
    //   block [0x821AF000..0x821AF038)
	// 821AF000: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821AF004: 419A0018  beq cr6, 0x821af01c
	if ctx.cr[6].eq {
	pc = 0x821AF01C; continue 'dispatch;
	}
	// 821AF008: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AF00C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF010: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF014: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF018: 409A0008  bne cr6, 0x821af020
	if !ctx.cr[6].eq {
	pc = 0x821AF020; continue 'dispatch;
	}
	// 821AF01C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AF020: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF028: 419A0010  beq cr6, 0x821af038
	if ctx.cr[6].eq {
		sub_821AF038(ctx, base);
		return;
	}
	// 821AF02C: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AF030: 5563BFFE  rlwinm r3, r11, 0x17, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	// 821AF034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF038 size=8
    let mut pc: u32 = 0x821AF038;
    'dispatch: loop {
        match pc {
            0x821AF038 => {
    //   block [0x821AF038..0x821AF040)
	// 821AF038: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AF03C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF040 size=56
    let mut pc: u32 = 0x821AF040;
    'dispatch: loop {
        match pc {
            0x821AF040 => {
    //   block [0x821AF040..0x821AF078)
	// 821AF040: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821AF044: 419A0018  beq cr6, 0x821af05c
	if ctx.cr[6].eq {
	pc = 0x821AF05C; continue 'dispatch;
	}
	// 821AF048: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821AF04C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF050: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF054: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF058: 409A0008  bne cr6, 0x821af060
	if !ctx.cr[6].eq {
	pc = 0x821AF060; continue 'dispatch;
	}
	// 821AF05C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AF060: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF068: 419A0010  beq cr6, 0x821af078
	if ctx.cr[6].eq {
		sub_821AF078(ctx, base);
		return;
	}
	// 821AF06C: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AF070: 556327FE  rlwinm r3, r11, 4, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821AF074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF078 size=8
    let mut pc: u32 = 0x821AF078;
    'dispatch: loop {
        match pc {
            0x821AF078 => {
    //   block [0x821AF078..0x821AF080)
	// 821AF078: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AF07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AF080 size=108
    let mut pc: u32 = 0x821AF080;
    'dispatch: loop {
        match pc {
            0x821AF080 => {
    //   block [0x821AF080..0x821AF0EC)
	// 821AF080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AF084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AF088: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AF08C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AF090: C003022C  lfs f0, 0x22c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(556 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF094: ED810028  fsubs f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AF098: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AF09C: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 821AF0A0: C1AA001C  lfs f13, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF0A4: C16A0018  lfs f11, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF0A8: EC0D5828  fsubs f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 821AF0AC: C1A9FE48  lfs f13, -0x1b8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF0B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821AF0B4: 40980008  bge cr6, 0x821af0bc
	if !ctx.cr[6].lt {
	pc = 0x821AF0BC; continue 'dispatch;
	}
	// 821AF0B8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821AF0BC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 821AF0C0: 41980018  blt cr6, 0x821af0d8
	if ctx.cr[6].lt {
	pc = 0x821AF0D8; continue 'dispatch;
	}
	// 821AF0C4: 480BA255  bl 0x82269318
	ctx.lr = 0x821AF0C8;
	sub_82269318(ctx, base);
	// 821AF0C8: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF0CC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821AF0D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AF0D4: 40990008  ble cr6, 0x821af0dc
	if !ctx.cr[6].gt {
	pc = 0x821AF0DC; continue 'dispatch;
	}
	// 821AF0D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AF0DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AF0E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AF0E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AF0E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF0F0 size=80
    let mut pc: u32 = 0x821AF0F0;
    'dispatch: loop {
        match pc {
            0x821AF0F0 => {
    //   block [0x821AF0F0..0x821AF140)
	// 821AF0F0: 89630071  lbz r11, 0x71(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(113 as u32) ) } as u64;
	// 821AF0F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF0F8: 409A0144  bne cr6, 0x821af23c
	if !ctx.cr[6].eq {
		sub_821AF23C(ctx, base);
		return;
	}
	// 821AF0FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF100: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AF104: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AF108: 552867FE  rlwinm r8, r9, 0xc, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000FFFFFu64;
	// 821AF10C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AF110: 419A00F8  beq cr6, 0x821af208
	if ctx.cr[6].eq {
		sub_821AF208(ctx, base);
		return;
	}
	// 821AF114: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AF118: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF11C: 419A0024  beq cr6, 0x821af140
	if ctx.cr[6].eq {
		sub_821AF140(ctx, base);
		return;
	}
	// 821AF120: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AF124: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AF128: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821AF12C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AF130: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF134: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF138: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF13C: 480000D0  b 0x821af20c
	sub_821AF208(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF140 size=92
    let mut pc: u32 = 0x821AF140;
    'dispatch: loop {
        match pc {
            0x821AF140 => {
    //   block [0x821AF140..0x821AF19C)
	// 821AF140: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AF144: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AF148: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AF14C: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 821AF150: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821AF154: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821AF158: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AF15C: 40810054  ble 0x821af1b0
	if !ctx.cr[0].gt {
		sub_821AF19C(ctx, base);
		return;
	}
	// 821AF160: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821AF164: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF168: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AF16C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AF170: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 821AF174: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AF178: 41980008  blt cr6, 0x821af180
	if ctx.cr[6].lt {
	pc = 0x821AF180; continue 'dispatch;
	}
	// 821AF17C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF180: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821AF184: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF188: 419A0014  beq cr6, 0x821af19c
	if ctx.cr[6].eq {
		sub_821AF19C(ctx, base);
		return;
	}
	// 821AF18C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821AF190: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AF194: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AF198: 4800000C  b 0x821af1a4
	sub_821AF19C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF19C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF19C size=88
    let mut pc: u32 = 0x821AF19C;
    'dispatch: loop {
        match pc {
            0x821AF19C => {
    //   block [0x821AF19C..0x821AF1F4)
	// 821AF19C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821AF1A0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821AF1A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AF1A8: 4199FFB8  bgt cr6, 0x821af160
	if ctx.cr[6].gt {
		sub_821AF140(ctx, base);
		return;
	}
	// 821AF1AC: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821AF1B0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AF1B4: 419A0040  beq cr6, 0x821af1f4
	if ctx.cr[6].eq {
		sub_821AF1F4(ctx, base);
		return;
	}
	// 821AF1B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AF1BC: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821AF1C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF1C4: 41990008  bgt cr6, 0x821af1cc
	if ctx.cr[6].gt {
	pc = 0x821AF1CC; continue 'dispatch;
	}
	// 821AF1C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AF1CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF1D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF1D4: 409A0020  bne cr6, 0x821af1f4
	if !ctx.cr[6].eq {
		sub_821AF1F4(ctx, base);
		return;
	}
	// 821AF1D8: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AF1DC: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821AF1E0: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821AF1E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF1E8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF1EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF1F0: 4800001C  b 0x821af20c
	sub_821AF208(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF1F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF1F4 size=20
    let mut pc: u32 = 0x821AF1F4;
    'dispatch: loop {
        match pc {
            0x821AF1F4 => {
    //   block [0x821AF1F4..0x821AF208)
	// 821AF1F4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AF1F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF1FC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF200: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF204: 48000008  b 0x821af20c
	sub_821AF208(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF208 size=52
    let mut pc: u32 = 0x821AF208;
    'dispatch: loop {
        match pc {
            0x821AF208 => {
    //   block [0x821AF208..0x821AF23C)
	// 821AF208: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AF20C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF214: 419A0028  beq cr6, 0x821af23c
	if ctx.cr[6].eq {
		sub_821AF23C(ctx, base);
		return;
	}
	// 821AF218: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 821AF21C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821AF220: 419A0010  beq cr6, 0x821af230
	if ctx.cr[6].eq {
	pc = 0x821AF230; continue 'dispatch;
	}
	// 821AF224: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821AF228: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AF22C: 409A0008  bne cr6, 0x821af234
	if !ctx.cr[6].eq {
	pc = 0x821AF234; continue 'dispatch;
	}
	// 821AF230: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF234: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AF238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF23C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF23C size=8
    let mut pc: u32 = 0x821AF23C;
    'dispatch: loop {
        match pc {
            0x821AF23C => {
    //   block [0x821AF23C..0x821AF244)
	// 821AF23C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AF240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AF248 size=2980
    let mut pc: u32 = 0x821AF248;
    'dispatch: loop {
        match pc {
            0x821AF248 => {
    //   block [0x821AF248..0x821AFDEC)
	// 821AF248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AF24C: 48AFA1A9  bl 0x82ca93f4
	ctx.lr = 0x821AF250;
	sub_82CA93D0(ctx, base);
	// 821AF250: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AF254: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821AF258: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821AF25C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 821AF260: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 821AF264: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821AF268: 48012789  bl 0x821c19f0
	ctx.lr = 0x821AF26C;
	sub_821C19F0(ctx, base);
	// 821AF26C: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821AF270: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821AF274: 3BEA63A0  addi r31, r10, 0x63a0
	ctx.r[31].s64 = ctx.r[10].s64 + 25504;
	// 821AF278: 3BCB2390  addi r30, r11, 0x2390
	ctx.r[30].s64 = ctx.r[11].s64 + 9104;
	// 821AF27C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821AF280: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821AF284: 3B8B0DB8  addi r28, r11, 0xdb8
	ctx.r[28].s64 = ctx.r[11].s64 + 3512;
	// 821AF288: 817F1A5C  lwz r11, 0x1a5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821AF28C: 895F1A6D  lbz r10, 0x1a6d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6765 as u32) ) } as u64;
	// 821AF290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF294: 1D6A2008  mulli r11, r10, 0x2008
	ctx.r[11].s64 = ctx.r[10].s64 * 8200;
	// 821AF298: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF29C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF2A0: 419A0088  beq cr6, 0x821af328
	if ctx.cr[6].eq {
	pc = 0x821AF328; continue 'dispatch;
	}
	// 821AF2A4: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF2A8: 813F1A60  lwz r9, 0x1a60(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6752 as u32) ) } as u64;
	// 821AF2AC: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821AF2B0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AF2B4: 409A003C  bne cr6, 0x821af2f0
	if !ctx.cr[6].eq {
	pc = 0x821AF2F0; continue 'dispatch;
	}
	// 821AF2B8: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF2BC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821AF2C0: 38FF1A58  addi r7, r31, 0x1a58
	ctx.r[7].s64 = ctx.r[31].s64 + 6744;
	// 821AF2C4: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AF2C8: 915F1A60  stw r10, 0x1a60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6752 as u32), ctx.r[10].u32 ) };
	// 821AF2CC: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821AF2D0: 815F1A5C  lwz r10, 0x1a5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821AF2D4: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF2D8: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF2DC: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821AF2E0: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821AF2E4: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF2E8: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821AF2EC: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	// 821AF2F0: 897F1A6C  lbz r11, 0x1a6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6764 as u32) ) } as u64;
	// 821AF2F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AF2F8: 915F1A5C  stw r10, 0x1a5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6748 as u32), ctx.r[10].u32 ) };
	// 821AF2FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF300: 409A0028  bne cr6, 0x821af328
	if !ctx.cr[6].eq {
	pc = 0x821AF328; continue 'dispatch;
	}
	// 821AF304: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821AF308: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AF30C: 393F1A58  addi r9, r31, 0x1a58
	ctx.r[9].s64 = ctx.r[31].s64 + 6744;
	// 821AF310: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF314: 995F1A6C  stb r10, 0x1a6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6764 as u32), ctx.r[10].u8 ) };
	// 821AF318: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821AF31C: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF320: 7D28E12E  stwx r9, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 821AF324: 48000008  b 0x821af32c
	pc = 0x821AF32C; continue 'dispatch;
	// 821AF328: 815D0DB0  lwz r10, 0xdb0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821AF32C: 897F1A85  lbz r11, 0x1a85(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6789 as u32) ) } as u64;
	// 821AF330: 813F1A74  lwz r9, 0x1a74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821AF334: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AF338: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF33C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821AF340: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF344: 419A0080  beq cr6, 0x821af3c4
	if ctx.cr[6].eq {
	pc = 0x821AF3C4; continue 'dispatch;
	}
	// 821AF348: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF34C: 811F1A78  lwz r8, 0x1a78(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6776 as u32) ) } as u64;
	// 821AF350: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF354: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF358: 409A003C  bne cr6, 0x821af394
	if !ctx.cr[6].eq {
	pc = 0x821AF394; continue 'dispatch;
	}
	// 821AF35C: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF360: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF364: 38DF1A70  addi r6, r31, 0x1a70
	ctx.r[6].s64 = ctx.r[31].s64 + 6768;
	// 821AF368: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AF36C: 913F1A78  stw r9, 0x1a78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6776 as u32), ctx.r[9].u32 ) };
	// 821AF370: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AF374: 813F1A74  lwz r9, 0x1a74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821AF378: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF37C: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF380: 7C685A14  add r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF384: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF388: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF38C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821AF390: 912B2004  stw r9, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821AF394: 897F1A84  lbz r11, 0x1a84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6788 as u32) ) } as u64;
	// 821AF398: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF39C: 913F1A74  stw r9, 0x1a74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6772 as u32), ctx.r[9].u32 ) };
	// 821AF3A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF3A4: 409A0020  bne cr6, 0x821af3c4
	if !ctx.cr[6].eq {
	pc = 0x821AF3C4; continue 'dispatch;
	}
	// 821AF3A8: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF3AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF3B0: 391F1A70  addi r8, r31, 0x1a70
	ctx.r[8].s64 = ctx.r[31].s64 + 6768;
	// 821AF3B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF3B8: 997F1A84  stb r11, 0x1a84(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6788 as u32), ctx.r[11].u8 ) };
	// 821AF3BC: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF3C0: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF3C4: 897F1AB5  lbz r11, 0x1ab5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6837 as u32) ) } as u64;
	// 821AF3C8: 813F1AA4  lwz r9, 0x1aa4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821AF3CC: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AF3D0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF3D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF3D8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF3DC: 419A0080  beq cr6, 0x821af45c
	if ctx.cr[6].eq {
	pc = 0x821AF45C; continue 'dispatch;
	}
	// 821AF3E0: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF3E4: 811F1AA8  lwz r8, 0x1aa8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6824 as u32) ) } as u64;
	// 821AF3E8: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF3EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF3F0: 409A003C  bne cr6, 0x821af42c
	if !ctx.cr[6].eq {
	pc = 0x821AF42C; continue 'dispatch;
	}
	// 821AF3F4: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF3F8: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF3FC: 38DF1AA0  addi r6, r31, 0x1aa0
	ctx.r[6].s64 = ctx.r[31].s64 + 6816;
	// 821AF400: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AF404: 913F1AA8  stw r9, 0x1aa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6824 as u32), ctx.r[9].u32 ) };
	// 821AF408: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AF40C: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF410: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF414: 813F1AA4  lwz r9, 0x1aa4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821AF418: 7C685A14  add r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF41C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF420: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF424: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821AF428: 912B2004  stw r9, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821AF42C: 897F1AB4  lbz r11, 0x1ab4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6836 as u32) ) } as u64;
	// 821AF430: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AF434: 913F1AA4  stw r9, 0x1aa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6820 as u32), ctx.r[9].u32 ) };
	// 821AF438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF43C: 409A0020  bne cr6, 0x821af45c
	if !ctx.cr[6].eq {
	pc = 0x821AF45C; continue 'dispatch;
	}
	// 821AF440: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF444: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF448: 391F1AA0  addi r8, r31, 0x1aa0
	ctx.r[8].s64 = ctx.r[31].s64 + 6816;
	// 821AF44C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF450: 997F1AB4  stb r11, 0x1ab4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6836 as u32), ctx.r[11].u8 ) };
	// 821AF454: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF458: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF45C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821AF460: 88FF1A9D  lbz r7, 0x1a9d(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6813 as u32) ) } as u64;
	// 821AF464: 811F1A8C  lwz r8, 0x1a8c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821AF468: 38CB6FB8  addi r6, r11, 0x6fb8
	ctx.r[6].s64 = ctx.r[11].s64 + 28600;
	// 821AF46C: 1D672008  mulli r11, r7, 0x2008
	ctx.r[11].s64 = ctx.r[7].s64 * 8200;
	// 821AF470: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF474: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF478: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 821AF47C: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821AF480: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF484: 419A0080  beq cr6, 0x821af504
	if ctx.cr[6].eq {
	pc = 0x821AF504; continue 'dispatch;
	}
	// 821AF488: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF48C: 811F1A90  lwz r8, 0x1a90(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821AF490: 7D054838  and r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF494: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821AF498: 409A0040  bne cr6, 0x821af4d8
	if !ctx.cr[6].eq {
	pc = 0x821AF4D8; continue 'dispatch;
	}
	// 821AF49C: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF4A0: 38BF1A88  addi r5, r31, 0x1a88
	ctx.r[5].s64 = ctx.r[31].s64 + 6792;
	// 821AF4A4: 809F1A90  lwz r4, 0x1a90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821AF4A8: 55031838  slwi r3, r8, 3
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AF4AC: 7C894B78  or r9, r4, r9
	ctx.r[9].u64 = ctx.r[4].u64 | ctx.r[9].u64;
	// 821AF4B0: 913F1A90  stw r9, 0x1a90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6800 as u32), ctx.r[9].u32 ) };
	// 821AF4B4: 7CA3592E  stwx r5, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF4B8: 813F1A8C  lwz r9, 0x1a8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821AF4BC: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF4C0: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF4C4: 7CA85A14  add r5, r8, r11
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF4C8: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF4CC: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF4D0: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 821AF4D4: 908B2004  stw r4, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	// 821AF4D8: 893F1A9C  lbz r9, 0x1a9c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6812 as u32) ) } as u64;
	// 821AF4DC: 90FF1A8C  stw r7, 0x1a8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6796 as u32), ctx.r[7].u32 ) };
	// 821AF4E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF4E4: 409A0020  bne cr6, 0x821af504
	if !ctx.cr[6].eq {
	pc = 0x821AF504; continue 'dispatch;
	}
	// 821AF4E8: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AF4EC: 393F1A88  addi r9, r31, 0x1a88
	ctx.r[9].s64 = ctx.r[31].s64 + 6792;
	// 821AF4F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF4F4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821AF4F8: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF4FC: 991F1A9C  stb r8, 0x1a9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6812 as u32), ctx.r[8].u8 ) };
	// 821AF500: 7D2BE12E  stwx r9, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 821AF504: 897F020D  lbz r11, 0x20d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(525 as u32) ) } as u64;
	// 821AF508: 813F01FC  lwz r9, 0x1fc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 821AF50C: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AF510: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF514: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821AF518: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF51C: 419A0080  beq cr6, 0x821af59c
	if ctx.cr[6].eq {
	pc = 0x821AF59C; continue 'dispatch;
	}
	// 821AF520: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF524: 811F0200  lwz r8, 0x200(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 821AF528: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF52C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF530: 409A003C  bne cr6, 0x821af56c
	if !ctx.cr[6].eq {
	pc = 0x821AF56C; continue 'dispatch;
	}
	// 821AF534: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF538: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF53C: 38BF01F8  addi r5, r31, 0x1f8
	ctx.r[5].s64 = ctx.r[31].s64 + 504;
	// 821AF540: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF544: 913F0200  stw r9, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[9].u32 ) };
	// 821AF548: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF54C: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF550: 813F01FC  lwz r9, 0x1fc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 821AF554: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF558: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF55C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF560: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF564: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF568: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821AF56C: 897F020C  lbz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 821AF570: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF574: 913F01FC  stw r9, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[9].u32 ) };
	// 821AF578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF57C: 409A0020  bne cr6, 0x821af59c
	if !ctx.cr[6].eq {
	pc = 0x821AF59C; continue 'dispatch;
	}
	// 821AF580: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF588: 391F01F8  addi r8, r31, 0x1f8
	ctx.r[8].s64 = ctx.r[31].s64 + 504;
	// 821AF58C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF590: 997F020C  stb r11, 0x20c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u8 ) };
	// 821AF594: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF598: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF59C: 897F0285  lbz r11, 0x285(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(645 as u32) ) } as u64;
	// 821AF5A0: 813F0274  lwz r9, 0x274(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 821AF5A4: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AF5A8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF5AC: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 821AF5B0: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF5B4: 419A0080  beq cr6, 0x821af634
	if ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF5B8: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF5BC: 811F0278  lwz r8, 0x278(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 821AF5C0: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF5C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF5C8: 409A003C  bne cr6, 0x821af604
	if !ctx.cr[6].eq {
	pc = 0x821AF604; continue 'dispatch;
	}
	// 821AF5CC: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF5D0: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF5D4: 38BF0270  addi r5, r31, 0x270
	ctx.r[5].s64 = ctx.r[31].s64 + 624;
	// 821AF5D8: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF5DC: 913F0278  stw r9, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[9].u32 ) };
	// 821AF5E0: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF5E4: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF5E8: 813F0274  lwz r9, 0x274(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 821AF5EC: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF5F0: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF5F4: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF5F8: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF5FC: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF600: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821AF604: 897F0284  lbz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 821AF608: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 821AF60C: 913F0274  stw r9, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[9].u32 ) };
	// 821AF610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF614: 409A0020  bne cr6, 0x821af634
	if !ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF618: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF61C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF620: 391F0270  addi r8, r31, 0x270
	ctx.r[8].s64 = ctx.r[31].s64 + 624;
	// 821AF624: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF628: 997F0284  stb r11, 0x284(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u8 ) };
	// 821AF62C: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF630: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF634: 897F02B5  lbz r11, 0x2b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(693 as u32) ) } as u64;
	// 821AF638: 813F02A4  lwz r9, 0x2a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 821AF63C: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AF640: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF644: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 821AF648: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF64C: 419A0080  beq cr6, 0x821af6cc
	if ctx.cr[6].eq {
	pc = 0x821AF6CC; continue 'dispatch;
	}
	// 821AF650: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF654: 811F02A8  lwz r8, 0x2a8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 821AF658: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF65C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF660: 409A003C  bne cr6, 0x821af69c
	if !ctx.cr[6].eq {
	pc = 0x821AF69C; continue 'dispatch;
	}
	// 821AF664: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF668: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF66C: 38BF02A0  addi r5, r31, 0x2a0
	ctx.r[5].s64 = ctx.r[31].s64 + 672;
	// 821AF670: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF674: 913F02A8  stw r9, 0x2a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(680 as u32), ctx.r[9].u32 ) };
	// 821AF678: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF67C: 813F02A4  lwz r9, 0x2a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 821AF680: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF684: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF688: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF68C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF690: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF694: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF698: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821AF69C: 897F02B4  lbz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 821AF6A0: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 821AF6A4: 913F02A4  stw r9, 0x2a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[9].u32 ) };
	// 821AF6A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF6AC: 409A0020  bne cr6, 0x821af6cc
	if !ctx.cr[6].eq {
	pc = 0x821AF6CC; continue 'dispatch;
	}
	// 821AF6B0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF6B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF6B8: 391F02A0  addi r8, r31, 0x2a0
	ctx.r[8].s64 = ctx.r[31].s64 + 672;
	// 821AF6BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF6C0: 997F02B4  stb r11, 0x2b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u8 ) };
	// 821AF6C4: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF6C8: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF6CC: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821AF6D0: 88FF026D  lbz r7, 0x26d(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(621 as u32) ) } as u64;
	// 821AF6D4: 813F025C  lwz r9, 0x25c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 821AF6D8: 38A86F8C  addi r5, r8, 0x6f8c
	ctx.r[5].s64 = ctx.r[8].s64 + 28556;
	// 821AF6DC: 1D672008  mulli r11, r7, 0x2008
	ctx.r[11].s64 = ctx.r[7].s64 * 8200;
	// 821AF6E0: 80E5001C  lwz r7, 0x1c(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AF6E4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF6E8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AF6EC: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF6F0: 419A007C  beq cr6, 0x821af76c
	if ctx.cr[6].eq {
	pc = 0x821AF76C; continue 'dispatch;
	}
	// 821AF6F4: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF6F8: 811F0260  lwz r8, 0x260(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 821AF6FC: 7D054838  and r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF700: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821AF704: 409A003C  bne cr6, 0x821af740
	if !ctx.cr[6].eq {
	pc = 0x821AF740; continue 'dispatch;
	}
	// 821AF708: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF70C: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF710: 389F0258  addi r4, r31, 0x258
	ctx.r[4].s64 = ctx.r[31].s64 + 600;
	// 821AF714: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AF718: 913F0260  stw r9, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[9].u32 ) };
	// 821AF71C: 7C83592E  stwx r4, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 821AF720: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF724: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF728: 813F025C  lwz r9, 0x25c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 821AF72C: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF730: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF734: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF738: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821AF73C: 90AB2004  stw r5, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	// 821AF740: 897F026C  lbz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 821AF744: 90FF025C  stw r7, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[7].u32 ) };
	// 821AF748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF74C: 409A0020  bne cr6, 0x821af76c
	if !ctx.cr[6].eq {
	pc = 0x821AF76C; continue 'dispatch;
	}
	// 821AF750: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF754: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF758: 391F0258  addi r8, r31, 0x258
	ctx.r[8].s64 = ctx.r[31].s64 + 600;
	// 821AF75C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF760: 997F026C  stb r11, 0x26c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u8 ) };
	// 821AF764: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF768: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF76C: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821AF770: 88FF0255  lbz r7, 0x255(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(597 as u32) ) } as u64;
	// 821AF774: 813F0244  lwz r9, 0x244(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 821AF778: 38A86FFC  addi r5, r8, 0x6ffc
	ctx.r[5].s64 = ctx.r[8].s64 + 28668;
	// 821AF77C: 1D672008  mulli r11, r7, 0x2008
	ctx.r[11].s64 = ctx.r[7].s64 * 8200;
	// 821AF780: 80E50008  lwz r7, 8(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AF784: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF788: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AF78C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF790: 419A007C  beq cr6, 0x821af80c
	if ctx.cr[6].eq {
	pc = 0x821AF80C; continue 'dispatch;
	}
	// 821AF794: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF798: 811F0248  lwz r8, 0x248(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 821AF79C: 7D054838  and r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF7A0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821AF7A4: 409A003C  bne cr6, 0x821af7e0
	if !ctx.cr[6].eq {
	pc = 0x821AF7E0; continue 'dispatch;
	}
	// 821AF7A8: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF7AC: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF7B0: 389F0240  addi r4, r31, 0x240
	ctx.r[4].s64 = ctx.r[31].s64 + 576;
	// 821AF7B4: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AF7B8: 913F0248  stw r9, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[9].u32 ) };
	// 821AF7BC: 7C83592E  stwx r4, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 821AF7C0: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF7C4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF7C8: 813F0244  lwz r9, 0x244(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 821AF7CC: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF7D0: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF7D4: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF7D8: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821AF7DC: 90AB2004  stw r5, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	// 821AF7E0: 897F0254  lbz r11, 0x254(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 821AF7E4: 90FF0244  stw r7, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[7].u32 ) };
	// 821AF7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF7EC: 409A0020  bne cr6, 0x821af80c
	if !ctx.cr[6].eq {
	pc = 0x821AF80C; continue 'dispatch;
	}
	// 821AF7F0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF7F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF7F8: 391F0240  addi r8, r31, 0x240
	ctx.r[8].s64 = ctx.r[31].s64 + 576;
	// 821AF7FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF800: 997F0254  stb r11, 0x254(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u8 ) };
	// 821AF804: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF808: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF80C: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 821AF810: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AF814: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AF818: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF81C: 2B09000F  cmplwi cr6, r9, 0xf
	ctx.cr[6].compare_u32(ctx.r[9].u32, 15 as u32, &mut ctx.xer);
	// 821AF820: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF824: 419A0080  beq cr6, 0x821af8a4
	if ctx.cr[6].eq {
	pc = 0x821AF8A4; continue 'dispatch;
	}
	// 821AF828: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF82C: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AF830: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF834: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF838: 409A003C  bne cr6, 0x821af874
	if !ctx.cr[6].eq {
	pc = 0x821AF874; continue 'dispatch;
	}
	// 821AF83C: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF840: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF844: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 821AF848: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF84C: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 821AF850: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF854: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AF858: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF85C: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF860: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF864: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF868: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF86C: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF870: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821AF874: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821AF878: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 821AF87C: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 821AF880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF884: 409A0020  bne cr6, 0x821af8a4
	if !ctx.cr[6].eq {
	pc = 0x821AF8A4; continue 'dispatch;
	}
	// 821AF888: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF88C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF890: 391F0018  addi r8, r31, 0x18
	ctx.r[8].s64 = ctx.r[31].s64 + 24;
	// 821AF894: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF898: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 821AF89C: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF8A0: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF8A4: 897F005D  lbz r11, 0x5d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(93 as u32) ) } as u64;
	// 821AF8A8: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AF8AC: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AF8B0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF8B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF8B8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF8BC: 419A0080  beq cr6, 0x821af93c
	if ctx.cr[6].eq {
	pc = 0x821AF93C; continue 'dispatch;
	}
	// 821AF8C0: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF8C4: 811F0050  lwz r8, 0x50(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AF8C8: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821AF8CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF8D0: 409A003C  bne cr6, 0x821af90c
	if !ctx.cr[6].eq {
	pc = 0x821AF90C; continue 'dispatch;
	}
	// 821AF8D4: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF8D8: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821AF8DC: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 821AF8E0: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF8E4: 913F0050  stw r9, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821AF8E8: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF8EC: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF8F0: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AF8F4: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF8F8: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF8FC: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF900: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF904: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF908: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821AF90C: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AF910: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AF914: 913F004C  stw r9, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 821AF918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF91C: 409A0020  bne cr6, 0x821af93c
	if !ctx.cr[6].eq {
	pc = 0x821AF93C; continue 'dispatch;
	}
	// 821AF920: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF924: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF928: 391F0048  addi r8, r31, 0x48
	ctx.r[8].s64 = ctx.r[31].s64 + 72;
	// 821AF92C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF930: 997F005C  stb r11, 0x5c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u8 ) };
	// 821AF934: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF938: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF93C: 897F00D5  lbz r11, 0xd5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(213 as u32) ) } as u64;
	// 821AF940: 813F00C4  lwz r9, 0xc4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AF944: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AF948: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF94C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821AF950: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF954: 419A0080  beq cr6, 0x821af9d4
	if ctx.cr[6].eq {
	pc = 0x821AF9D4; continue 'dispatch;
	}
	// 821AF958: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF95C: 811F00C8  lwz r8, 0xc8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AF960: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821AF964: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AF968: 409A003C  bne cr6, 0x821af9a4
	if !ctx.cr[6].eq {
	pc = 0x821AF9A4; continue 'dispatch;
	}
	// 821AF96C: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF970: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AF974: 38BF00C0  addi r5, r31, 0xc0
	ctx.r[5].s64 = ctx.r[31].s64 + 192;
	// 821AF978: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AF97C: 913F00C8  stw r9, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 821AF980: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AF984: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF988: 813F00C4  lwz r9, 0xc4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AF98C: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF990: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AF994: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AF998: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AF99C: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AF9A0: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821AF9A4: 897F00D4  lbz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 821AF9A8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF9AC: 913F00C4  stw r9, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 821AF9B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF9B4: 409A0020  bne cr6, 0x821af9d4
	if !ctx.cr[6].eq {
	pc = 0x821AF9D4; continue 'dispatch;
	}
	// 821AF9B8: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF9BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AF9C0: 391F00C0  addi r8, r31, 0xc0
	ctx.r[8].s64 = ctx.r[31].s64 + 192;
	// 821AF9C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF9C8: 997F00D4  stb r11, 0xd4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u8 ) };
	// 821AF9CC: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AF9D0: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AF9D4: 897F00ED  lbz r11, 0xed(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(237 as u32) ) } as u64;
	// 821AF9D8: 813F00DC  lwz r9, 0xdc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821AF9DC: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AF9E0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AF9E4: 2B090080  cmplwi cr6, r9, 0x80
	ctx.cr[6].compare_u32(ctx.r[9].u32, 128 as u32, &mut ctx.xer);
	// 821AF9E8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AF9EC: 419A0080  beq cr6, 0x821afa6c
	if ctx.cr[6].eq {
	pc = 0x821AFA6C; continue 'dispatch;
	}
	// 821AF9F0: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AF9F4: 811F00E0  lwz r8, 0xe0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 821AF9F8: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821AF9FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AFA00: 409A003C  bne cr6, 0x821afa3c
	if !ctx.cr[6].eq {
	pc = 0x821AFA3C; continue 'dispatch;
	}
	// 821AFA04: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFA08: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AFA0C: 38BF00D8  addi r5, r31, 0xd8
	ctx.r[5].s64 = ctx.r[31].s64 + 216;
	// 821AFA10: 54E41838  slwi r4, r7, 3
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AFA14: 913F00E0  stw r9, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[9].u32 ) };
	// 821AFA18: 7CA4592E  stwx r5, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821AFA1C: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFA20: 813F00DC  lwz r9, 0xdc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821AFA24: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AFA28: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AFA2C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AFA30: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFA34: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 821AFA38: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	// 821AFA3C: 897F00EC  lbz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 821AFA40: 39200080  li r9, 0x80
	ctx.r[9].s64 = 128;
	// 821AFA44: 913F00DC  stw r9, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[9].u32 ) };
	// 821AFA48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFA4C: 409A0020  bne cr6, 0x821afa6c
	if !ctx.cr[6].eq {
	pc = 0x821AFA6C; continue 'dispatch;
	}
	// 821AFA50: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFA54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFA58: 391F00D8  addi r8, r31, 0xd8
	ctx.r[8].s64 = ctx.r[31].s64 + 216;
	// 821AFA5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFA60: 997F00EC  stb r11, 0xec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 821AFA64: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AFA68: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AFA6C: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821AFA70: 88FF00A5  lbz r7, 0xa5(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(165 as u32) ) } as u64;
	// 821AFA74: 813F0094  lwz r9, 0x94(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821AFA78: 38A86F4C  addi r5, r8, 0x6f4c
	ctx.r[5].s64 = ctx.r[8].s64 + 28492;
	// 821AFA7C: 1D672008  mulli r11, r7, 0x2008
	ctx.r[11].s64 = ctx.r[7].s64 * 8200;
	// 821AFA80: 80E50010  lwz r7, 0x10(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AFA84: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFA88: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AFA8C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFA90: 419A007C  beq cr6, 0x821afb0c
	if ctx.cr[6].eq {
	pc = 0x821AFB0C; continue 'dispatch;
	}
	// 821AFA94: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFA98: 811F0098  lwz r8, 0x98(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AFA9C: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821AFAA0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821AFAA4: 409A003C  bne cr6, 0x821afae0
	if !ctx.cr[6].eq {
	pc = 0x821AFAE0; continue 'dispatch;
	}
	// 821AFAA8: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFAAC: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AFAB0: 389F0090  addi r4, r31, 0x90
	ctx.r[4].s64 = ctx.r[31].s64 + 144;
	// 821AFAB4: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AFAB8: 913F0098  stw r9, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 821AFABC: 7C83592E  stwx r4, r3, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 821AFAC0: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFAC4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AFAC8: 813F0094  lwz r9, 0x94(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821AFACC: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AFAD0: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AFAD4: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFAD8: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821AFADC: 90AB2004  stw r5, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	// 821AFAE0: 897F00A4  lbz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 821AFAE4: 90FF0094  stw r7, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 821AFAE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFAEC: 409A0020  bne cr6, 0x821afb0c
	if !ctx.cr[6].eq {
	pc = 0x821AFB0C; continue 'dispatch;
	}
	// 821AFAF0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFAF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFAF8: 391F0090  addi r8, r31, 0x90
	ctx.r[8].s64 = ctx.r[31].s64 + 144;
	// 821AFAFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFB00: 997F00A4  stb r11, 0xa4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u8 ) };
	// 821AFB04: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AFB08: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AFB0C: 891F1A9D  lbz r8, 0x1a9d(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6813 as u32) ) } as u64;
	// 821AFB10: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFB14: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s64 = ctx.r[8].s64 * 8200;
	// 821AFB18: 813F1A8C  lwz r9, 0x1a8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821AFB1C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFB20: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 821AFB24: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821AFB28: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFB2C: 419A0080  beq cr6, 0x821afbac
	if ctx.cr[6].eq {
	pc = 0x821AFBAC; continue 'dispatch;
	}
	// 821AFB30: 812B2000  lwz r9, 0x2000(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFB34: 811F1A90  lwz r8, 0x1a90(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821AFB38: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821AFB3C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821AFB40: 409A0040  bne cr6, 0x821afb80
	if !ctx.cr[6].eq {
	pc = 0x821AFB80; continue 'dispatch;
	}
	// 821AFB44: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFB48: 38DF1A88  addi r6, r31, 0x1a88
	ctx.r[6].s64 = ctx.r[31].s64 + 6792;
	// 821AFB4C: 80BF1A90  lwz r5, 0x1a90(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821AFB50: 55041838  slwi r4, r8, 3
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AFB54: 7D292B78  or r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[5].u64;
	// 821AFB58: 913F1A90  stw r9, 0x1a90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6800 as u32), ctx.r[9].u32 ) };
	// 821AFB5C: 7CC4592E  stwx r6, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AFB60: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFB64: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AFB68: 813F1A8C  lwz r9, 0x1a8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821AFB6C: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 821AFB70: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AFB74: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFB78: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821AFB7C: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	// 821AFB80: 893F1A9C  lbz r9, 0x1a9c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6812 as u32) ) } as u64;
	// 821AFB84: 90FF1A8C  stw r7, 0x1a8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(6796 as u32), ctx.r[7].u32 ) };
	// 821AFB88: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AFB8C: 409A0020  bne cr6, 0x821afbac
	if !ctx.cr[6].eq {
	pc = 0x821AFBAC; continue 'dispatch;
	}
	// 821AFB90: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFB94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFB98: 391F1A88  addi r8, r31, 0x1a88
	ctx.r[8].s64 = ctx.r[31].s64 + 6792;
	// 821AFB9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFBA0: 997F1A9C  stb r11, 0x1a9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6812 as u32), ctx.r[11].u8 ) };
	// 821AFBA4: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AFBA8: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	// 821AFBAC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821AFBB0: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AFBB4: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821AFBB8: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFBBC: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 821AFBC0: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFBC4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AFBC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AFBCC: 808B4E2C  lwz r4, 0x4e2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20012 as u32) ) } as u64;
	// 821AFBD0: 48030819  bl 0x821e03e8
	ctx.lr = 0x821AFBD4;
	sub_821E03E8(ctx, base);
	// 821AFBD4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AFBD8: 48119619  bl 0x822c91f0
	ctx.lr = 0x821AFBDC;
	sub_822C91F0(ctx, base);
	// 821AFBDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AFBE0: 4BFD32A9  bl 0x82182e88
	ctx.lr = 0x821AFBE4;
	sub_82182E88(ctx, base);
	// 821AFBE4: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AFBE8: 895F005D  lbz r10, 0x5d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(93 as u32) ) } as u64;
	// 821AFBEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFBF0: 1D6A2008  mulli r11, r10, 0x2008
	ctx.r[11].s64 = ctx.r[10].s64 * 8200;
	// 821AFBF4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFBF8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFBFC: 419A0088  beq cr6, 0x821afc84
	if ctx.cr[6].eq {
	pc = 0x821AFC84; continue 'dispatch;
	}
	// 821AFC00: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFC04: 813F0050  lwz r9, 0x50(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AFC08: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821AFC0C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AFC10: 409A003C  bne cr6, 0x821afc4c
	if !ctx.cr[6].eq {
	pc = 0x821AFC4C; continue 'dispatch;
	}
	// 821AFC14: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFC18: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821AFC1C: 38FF0048  addi r7, r31, 0x48
	ctx.r[7].s64 = ctx.r[31].s64 + 72;
	// 821AFC20: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AFC24: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AFC28: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821AFC2C: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFC30: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFC34: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821AFC38: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821AFC3C: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821AFC40: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFC44: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821AFC48: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	// 821AFC4C: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AFC50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AFC54: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 821AFC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFC5C: 409A0028  bne cr6, 0x821afc84
	if !ctx.cr[6].eq {
	pc = 0x821AFC84; continue 'dispatch;
	}
	// 821AFC60: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821AFC64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AFC68: 393F0048  addi r9, r31, 0x48
	ctx.r[9].s64 = ctx.r[31].s64 + 72;
	// 821AFC6C: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821AFC70: 995F005C  stb r10, 0x5c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 821AFC74: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821AFC78: 911D0DB0  stw r8, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[8].u32 ) };
	// 821AFC7C: 7D27E12E  stwx r9, r7, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 821AFC80: 48000008  b 0x821afc88
	pc = 0x821AFC88; continue 'dispatch;
	// 821AFC84: 811D0DB0  lwz r8, 0xdb0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821AFC88: 897F00D5  lbz r11, 0xd5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(213 as u32) ) } as u64;
	// 821AFC8C: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AFC90: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AFC94: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFC98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AFC9C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFCA0: 419A0080  beq cr6, 0x821afd20
	if ctx.cr[6].eq {
	pc = 0x821AFD20; continue 'dispatch;
	}
	// 821AFCA4: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFCA8: 813F00C8  lwz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AFCAC: 7D474838  and r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821AFCB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AFCB4: 409A003C  bne cr6, 0x821afcf0
	if !ctx.cr[6].eq {
	pc = 0x821AFCF0; continue 'dispatch;
	}
	// 821AFCB8: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFCBC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821AFCC0: 38DF00C0  addi r6, r31, 0xc0
	ctx.r[6].s64 = ctx.r[31].s64 + 192;
	// 821AFCC4: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AFCC8: 915F00C8  stw r10, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 821AFCCC: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AFCD0: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFCD4: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AFCD8: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFCDC: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821AFCE0: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821AFCE4: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFCE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFCEC: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821AFCF0: 897F00D4  lbz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 821AFCF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AFCF8: 915F00C4  stw r10, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 821AFCFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFD00: 409A0020  bne cr6, 0x821afd20
	if !ctx.cr[6].eq {
	pc = 0x821AFD20; continue 'dispatch;
	}
	// 821AFD04: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AFD08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFD0C: 393F00C0  addi r9, r31, 0xc0
	ctx.r[9].s64 = ctx.r[31].s64 + 192;
	// 821AFD10: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821AFD14: 997F00D4  stb r11, 0xd4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u8 ) };
	// 821AFD18: 911D0DB0  stw r8, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[8].u32 ) };
	// 821AFD1C: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 821AFD20: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 821AFD24: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AFD28: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 * 8200;
	// 821AFD2C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AFD30: 2B0A000F  cmplwi cr6, r10, 0xf
	ctx.cr[6].compare_u32(ctx.r[10].u32, 15 as u32, &mut ctx.xer);
	// 821AFD34: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821AFD38: 419A0080  beq cr6, 0x821afdb8
	if ctx.cr[6].eq {
	pc = 0x821AFDB8; continue 'dispatch;
	}
	// 821AFD3C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821AFD40: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AFD44: 7D474838  and r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821AFD48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AFD4C: 409A003C  bne cr6, 0x821afd88
	if !ctx.cr[6].eq {
	pc = 0x821AFD88; continue 'dispatch;
	}
	// 821AFD50: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFD54: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821AFD58: 38DF0018  addi r6, r31, 0x18
	ctx.r[6].s64 = ctx.r[31].s64 + 24;
	// 821AFD5C: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AFD60: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AFD64: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821AFD68: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AFD6C: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFD70: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFD74: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821AFD78: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821AFD7C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821AFD80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AFD84: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821AFD88: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821AFD8C: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 821AFD90: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 821AFD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFD98: 409A0020  bne cr6, 0x821afdb8
	if !ctx.cr[6].eq {
	pc = 0x821AFDB8; continue 'dispatch;
	}
	// 821AFD9C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AFDA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AFDA4: 38FF0018  addi r7, r31, 0x18
	ctx.r[7].s64 = ctx.r[31].s64 + 24;
	// 821AFDA8: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 821AFDAC: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 821AFDB0: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821AFDB4: 7CE9E12E  stwx r7, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[7].u32) };
	// 821AFDB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821AFDBC: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFDC0: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821AFDC4: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AFDC8: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 821AFDCC: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFDD0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AFDD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AFDD8: 808B4E5C  lwz r4, 0x4e5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20060 as u32) ) } as u64;
	// 821AFDDC: 4803060D  bl 0x821e03e8
	ctx.lr = 0x821AFDE0;
	sub_821E03E8(ctx, base);
	// 821AFDE0: 48047091  bl 0x821f6e70
	ctx.lr = 0x821AFDE4;
	sub_821F6E70(ctx, base);
	// 821AFDE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AFDE8: 48AF965C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AFDF0 size=164
    let mut pc: u32 = 0x821AFDF0;
    'dispatch: loop {
        match pc {
            0x821AFDF0 => {
    //   block [0x821AFDF0..0x821AFE94)
	// 821AFDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AFDF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AFDF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AFDFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AFE00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AFE04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AFE08: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821AFE0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821AFE10: 480144D9  bl 0x821c42e8
	ctx.lr = 0x821AFE14;
	sub_821C42E8(ctx, base);
	// 821AFE14: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AFE18: 41980060  blt cr6, 0x821afe78
	if ctx.cr[6].lt {
	pc = 0x821AFE78; continue 'dispatch;
	}
	// 821AFE1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AFE20: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AFE24: 40980054  bge cr6, 0x821afe78
	if !ctx.cr[6].lt {
	pc = 0x821AFE78; continue 'dispatch;
	}
	// 821AFE28: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821AFE2C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821AFE30: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AFE34: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AFE38: 40980040  bge cr6, 0x821afe78
	if !ctx.cr[6].lt {
	pc = 0x821AFE78; continue 'dispatch;
	}
	// 821AFE3C: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AFE40: 1D63001C  mulli r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 * 28;
	// 821AFE44: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AFE48: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AFE4C: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFE50: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AFE54: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AFE58: 7DA95C2E  lfsx f13, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFE5C: 7D8A5C2E  lfsx f12, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFE60: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 821AFE64: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821AFE68: 40980010  bge cr6, 0x821afe78
	if !ctx.cr[6].lt {
	pc = 0x821AFE78; continue 'dispatch;
	}
	// 821AFE6C: 7C0A5D2E  stfsx f0, r10, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821AFE70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AFE74: 48000008  b 0x821afe7c
	pc = 0x821AFE7C; continue 'dispatch;
	// 821AFE78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AFE7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AFE80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AFE84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AFE88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AFE8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AFE90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFE98 size=288
    let mut pc: u32 = 0x821AFE98;
    'dispatch: loop {
        match pc {
            0x821AFE98 => {
    //   block [0x821AFE98..0x821AFFB8)
	// 821AFE98: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821AFE9C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821AFEA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AFEA4: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AFEA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AFEAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AFEB0: 409900FC  ble cr6, 0x821affac
	if !ctx.cr[6].gt {
	pc = 0x821AFFAC; continue 'dispatch;
	}
	// 821AFEB4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821AFEB8: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 821AFEBC: 390A9490  addi r8, r10, -0x6b70
	ctx.r[8].s64 = ctx.r[10].s64 + -27504;
	// 821AFEC0: C1AA9490  lfs f13, -0x6b70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFEC4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821AFEC8: D1A1FFA4  stfs f13, -0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-92 as u32), tmp.u32 ) };
	// 821AFECC: C008FFF4  lfs f0, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFED0: 390A91A0  addi r8, r10, -0x6e60
	ctx.r[8].s64 = ctx.r[10].s64 + -28256;
	// 821AFED4: D001FFA0  stfs f0, -0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), tmp.u32 ) };
	// 821AFED8: 3941FFB0  addi r10, r1, -0x50
	ctx.r[10].s64 = ctx.r[1].s64 + -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AFFB8 size=172
    let mut pc: u32 = 0x821AFFB8;
    'dispatch: loop {
        match pc {
            0x821AFFB8 => {
    //   block [0x821AFFB8..0x821B0064)
	// 821AFFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AFFBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AFFC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AFFC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AFFC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AFFCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821AFFD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AFFD4: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821AFFD8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821AFFDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AFFE0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821AFFE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AFFE8: 4BFE3E51  bl 0x82193e38
	ctx.lr = 0x821AFFEC;
	sub_82193E38(ctx, base);
	// 821AFFEC: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 821AFFF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821AFFF4: 48321ED5  bl 0x824d1ec8
	ctx.lr = 0x821AFFF8;
	sub_824D1EC8(ctx, base);
	// 821AFFF8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821AFFFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B0000: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 821B0004: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821B0008: 4BFE3E31  bl 0x82193e38
	ctx.lr = 0x821B000C;
	sub_82193E38(ctx, base);
	// 821B000C: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 821B0010: 38C00270  li r6, 0x270
	ctx.r[6].s64 = 624;
	// 821B0014: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 821B0018: 38A7A950  addi r5, r7, -0x56b0
	ctx.r[5].s64 = ctx.r[7].s64 + -22192;
	// 821B001C: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 821B0020: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821B0024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0028: 909F0260  stw r4, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[4].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B0068 size=236
    let mut pc: u32 = 0x821B0068;
    'dispatch: loop {
        match pc {
            0x821B0068 => {
    //   block [0x821B0068..0x821B0154)
	// 821B0068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B006C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B0070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B0074: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B0078: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B0158 size=128
    let mut pc: u32 = 0x821B0158;
    'dispatch: loop {
        match pc {
            0x821B0158 => {
    //   block [0x821B0158..0x821B01D8)
	// 821B0158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B015C: 48AF92A9  bl 0x82ca9404
	ctx.lr = 0x821B0160;
	sub_82CA93D0(ctx, base);
	// 821B0160: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B0164: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821B0168: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821B016C: 3BCB5008  addi r30, r11, 0x5008
	ctx.r[30].s64 = ctx.r[11].s64 + 20488;
	// 821B0170: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0174: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0178: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B017C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0180: 4099000C  ble cr6, 0x821b018c
	if !ctx.cr[6].gt {
	pc = 0x821B018C; continue 'dispatch;
	}
	// 821B0184: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0188: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B018C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821B0190: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B0194: 419A0034  beq cr6, 0x821b01c8
	if ctx.cr[6].eq {
	pc = 0x821B01C8; continue 'dispatch;
	}
	// 821B0198: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B019C: 41980008  blt cr6, 0x821b01a4
	if ctx.cr[6].lt {
	pc = 0x821B01A4; continue 'dispatch;
	}
	// 821B01A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B01A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B01A8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B01AC: 4897F9FD  bl 0x82b2fba8
	ctx.lr = 0x821B01B0;
	sub_82B2FBA8(ctx, base);
	// 821B01B0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B01B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B01B8: 41980008  blt cr6, 0x821b01c0
	if ctx.cr[6].lt {
	pc = 0x821B01C0; continue 'dispatch;
	}
	// 821B01BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B01C0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821B01C4: 4BFFFFCC  b 0x821b0190
	pc = 0x821B0190; continue 'dispatch;
	// 821B01C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B01CC: 480D2155  bl 0x82282320
	ctx.lr = 0x821B01D0;
	sub_82282320(ctx, base);
	// 821B01D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B01D4: 48AF9280  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B01D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B01D8 size=4436
    let mut pc: u32 = 0x821B01D8;
    'dispatch: loop {
        match pc {
            0x821B01D8 => {
    //   block [0x821B01D8..0x821B132C)
	// 821B01D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B01DC: 48AF91F5  bl 0x82ca93d0
	ctx.lr = 0x821B01E0;
	sub_82CA93D0(ctx, base);
	// 821B01E0: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821B01E4: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B01E8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B01EC: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821B01F0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B01F4: 3D20811C  lis r9, -0x7ee4
	ctx.r[9].s64 = -2128871424;
	// 821B01F8: 3E008349  lis r16, -0x7cb7
	ctx.r[16].s64 = -2092367872;
	// 821B01FC: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821B0200: 61349DC5  ori r20, r9, 0x9dc5
	ctx.r[20].u64 = ctx.r[9].u64 | 40389;
	// 821B0204: C1B60240  lfs f13, 0x240(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(576 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0208: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B020C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B0210: 91760258  stw r11, 0x258(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 821B0214: 409A0054  bne cr6, 0x821b0268
	if !ctx.cr[6].eq {
	pc = 0x821B0268; continue 'dispatch;
	}
	// 821B0218: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B021C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0220: 386B8AFC  addi r3, r11, -0x7504
	ctx.r[3].s64 = ctx.r[11].s64 + -29956;
	// 821B0224: 48043B35  bl 0x821f3d58
	ctx.lr = 0x821B0228;
	sub_821F3D58(ctx, base);
	// 821B0228: 81706DA0  lwz r11, 0x6da0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B022C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0230: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821B0234: 4884FC25  bl 0x829ffe58
	ctx.lr = 0x821B0238;
	sub_829FFE58(ctx, base);
	// 821B0238: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B023C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B0240: 419A0028  beq cr6, 0x821b0268
	if ctx.cr[6].eq {
	pc = 0x821B0268; continue 'dispatch;
	}
	// 821B0244: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0248: 388B8B14  addi r4, r11, -0x74ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29932;
	// 821B024C: 4BFE6935  bl 0x82196b80
	ctx.lr = 0x821B0250;
	sub_82196B80(ctx, base);
	// 821B0250: D036023C  stfs f1, 0x23c(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(572 as u32), tmp.u32 ) };
	// 821B0254: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B0258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B025C: 388A8B24  addi r4, r10, -0x74dc
	ctx.r[4].s64 = ctx.r[10].s64 + -29916;
	// 821B0260: 4BFE6921  bl 0x82196b80
	ctx.lr = 0x821B0264;
	sub_82196B80(ctx, base);
	// 821B0264: D0360240  stfs f1, 0x240(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 821B0268: 81760234  lwz r11, 0x234(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(564 as u32) ) } as u64;
	// 821B026C: 3BB60234  addi r29, r22, 0x234
	ctx.r[29].s64 = ctx.r[22].s64 + 564;
	// 821B0270: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 821B0274: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 821B0278: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821B027C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0280: 419A0214  beq cr6, 0x821b0494
	if ctx.cr[6].eq {
	pc = 0x821B0494; continue 'dispatch;
	}
	// 821B0284: C8099660  lfd f0, -0x69a0(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 821B0288: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B028C: C1B60240  lfs f13, 0x240(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(576 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0290: 81160258  lwz r8, 0x258(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0294: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 821B0298: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821B029C: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 821B02A0: D9410080  stfd f10, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[10].u64 ) };
	// 821B02A4: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B02A8: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821B02AC: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821B02B0: 409901E4  ble cr6, 0x821b0494
	if !ctx.cr[6].gt {
	pc = 0x821B0494; continue 'dispatch;
	}
	// 821B02B4: 83FC6AB8  lwz r31, 0x6ab8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B02B8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 821B02BC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B02C0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B02C4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B02C8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B02CC: 480B41BD  bl 0x82264488
	ctx.lr = 0x821B02D0;
	sub_82264488(ctx, base);
	// 821B02D0: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B02D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B02D8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B02DC: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 821B02E0: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B02E4: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B02E8: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B02EC: 480B419D  bl 0x82264488
	ctx.lr = 0x821B02F0;
	sub_82264488(ctx, base);
	// 821B02F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B02F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B02F8: 419A0018  beq cr6, 0x821b0310
	if ctx.cr[6].eq {
	pc = 0x821B0310; continue 'dispatch;
	}
	// 821B02FC: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B0300: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B0304: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B0308: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B030C: 409A0008  bne cr6, 0x821b0314
	if !ctx.cr[6].eq {
	pc = 0x821B0314; continue 'dispatch;
	}
	// 821B0310: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 821B0314: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B0318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B031C: 419A016C  beq cr6, 0x821b0488
	if ctx.cr[6].eq {
	pc = 0x821B0488; continue 'dispatch;
	}
	// 821B0320: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821B0324: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821B0328: 837D0000  lwz r27, 0(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B032C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0330: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B0334: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B0338: 4E800421  bctrl
	ctx.lr = 0x821B033C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B033C: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B0340: 39000065  li r8, 0x65
	ctx.r[8].s64 = 101;
	// 821B0344: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0348: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B034C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821B0350: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 821B0354: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B0358: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 821B035C: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B0360: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0364: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B0368: 480C9819  bl 0x82279b80
	ctx.lr = 0x821B036C;
	sub_82279B80(ctx, base);
	// 821B036C: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B0370: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821B0374: 55283FFE  rlwinm r8, r9, 7, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x01FFFFFFu64;
	// 821B0378: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B037C: 419A00E8  beq cr6, 0x821b0464
	if ctx.cr[6].eq {
	pc = 0x821B0464; continue 'dispatch;
	}
	// 821B0380: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B0384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0388: 419A0020  beq cr6, 0x821b03a8
	if ctx.cr[6].eq {
	pc = 0x821B03A8; continue 'dispatch;
	}
	// 821B038C: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 821B0390: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B0394: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B0398: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B039C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B03A0: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B03A4: 480000C4  b 0x821b0468
	pc = 0x821B0468; continue 'dispatch;
	// 821B03A8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B03AC: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B03B0: 92210078  stw r17, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[17].u32 ) };
	// 821B03B4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B03B8: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B03BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B03C0: 40810054  ble 0x821b0414
	if !ctx.cr[0].gt {
	pc = 0x821B0414; continue 'dispatch;
	}
	// 821B03C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B03C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B03CC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B03D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B03D4: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 821B03D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B03DC: 41980008  blt cr6, 0x821b03e4
	if ctx.cr[6].lt {
	pc = 0x821B03E4; continue 'dispatch;
	}
	// 821B03E0: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 821B03E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B03E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B03EC: 419A0014  beq cr6, 0x821b0400
	if ctx.cr[6].eq {
	pc = 0x821B0400; continue 'dispatch;
	}
	// 821B03F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B03F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B03F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B03FC: 4800000C  b 0x821b0408
	pc = 0x821B0408; continue 'dispatch;
	// 821B0400: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B0404: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B0408: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B040C: 4199FFB8  bgt cr6, 0x821b03c4
	if ctx.cr[6].gt {
	pc = 0x821B03C4; continue 'dispatch;
	}
	// 821B0410: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B0414: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B0418: 419A003C  beq cr6, 0x821b0454
	if ctx.cr[6].eq {
	pc = 0x821B0454; continue 'dispatch;
	}
	// 821B041C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0420: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 821B0424: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B0428: 41990008  bgt cr6, 0x821b0430
	if ctx.cr[6].gt {
	pc = 0x821B0430; continue 'dispatch;
	}
	// 821B042C: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 821B0430: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B0434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0438: 409A001C  bne cr6, 0x821b0454
	if !ctx.cr[6].eq {
	pc = 0x821B0454; continue 'dispatch;
	}
	// 821B043C: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821B0440: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 821B0444: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B0448: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B044C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B0450: 48000018  b 0x821b0468
	pc = 0x821B0468; continue 'dispatch;
	// 821B0454: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B0458: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B045C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B0460: 48000008  b 0x821b0468
	pc = 0x821B0468; continue 'dispatch;
	// 821B0464: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 821B0468: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B046C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0470: 419A0018  beq cr6, 0x821b0488
	if ctx.cr[6].eq {
	pc = 0x821B0488; continue 'dispatch;
	}
	// 821B0474: 816304E0  lwz r11, 0x4e0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1248 as u32) ) } as u64;
	// 821B0478: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B047C: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821B0480: 90A304E0  stw r5, 0x4e0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1248 as u32), ctx.r[5].u32 ) };
	// 821B0484: 48328A35  bl 0x824d8eb8
	ctx.lr = 0x821B0488;
	sub_824D8EB8(ctx, base);
	// 821B0488: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B048C: 4800768D  bl 0x821b7b18
	ctx.lr = 0x821B0490;
	sub_821B7B18(ctx, base);
	// 821B0490: 923D0000  stw r17, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 821B0494: 4BFC2705  bl 0x82172b98
	ctx.lr = 0x821B0498;
	sub_82172B98(ctx, base);
	// 821B0498: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B049C: 480EBF55  bl 0x8229c3f0
	ctx.lr = 0x821B04A0;
	sub_8229C3F0(ctx, base);
	// 821B04A0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B04A4: 48124DAD  bl 0x822d5250
	ctx.lr = 0x821B04A8;
	sub_822D5250(ctx, base);
	// 821B04A8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821B04AC: 92210094  stw r17, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[17].u32 ) };
	// 821B04B0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B04B4: 92210098  stw r17, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[17].u32 ) };
	// 821B04B8: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 821B04BC: 9221009C  stw r17, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[17].u32 ) };
	// 821B04C0: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 821B04C4: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B04C8: 80F6025C  lwz r7, 0x25c(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(604 as u32) ) } as u64;
	// 821B04CC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821B04D0: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 821B04D4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821B04D8: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B04DC: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B04E0: 80680058  lwz r3, 0x58(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B04E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B04E8: 81CB0010  lwz r14, 0x10(r11)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B04EC: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 821B04F0: 91C10058  stw r14, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[14].u32 ) };
	// 821B04F4: 4802717D  bl 0x821d7670
	ctx.lr = 0x821B04F8;
	sub_821D7670(ctx, base);
	// 821B04F8: 80A10094  lwz r5, 0x94(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B04FC: 80C10098  lwz r6, 0x98(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0500: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B0504: 40990008  ble cr6, 0x821b050c
	if !ctx.cr[6].gt {
	pc = 0x821B050C; continue 'dispatch;
	}
	// 821B0508: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B050C: 3C808210  lis r4, -0x7df0
	ctx.r[4].s64 = -2112880640;
	// 821B0510: 80F06DA0  lwz r7, 0x6da0(r16)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0514: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0518: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B051C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B0520: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 821B0524: CBE411A8  lfd f31, 0x11a8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(4520 as u32) ) };
	// 821B0528: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B052C: 3DE08349  lis r15, -0x7cb7
	ctx.r[15].s64 = -2092367872;
	// 821B0530: 3B4B8B60  addi r26, r11, -0x74a0
	ctx.r[26].s64 = ctx.r[11].s64 + -29856;
	// 821B0534: 3B2A8B44  addi r25, r10, -0x74bc
	ctx.r[25].s64 = ctx.r[10].s64 + -29884;
	// 821B0538: 3A698B34  addi r19, r9, -0x74cc
	ctx.r[19].s64 = ctx.r[9].s64 + -29900;
	// 821B053C: 3AA8A1C4  addi r21, r8, -0x5e3c
	ctx.r[21].s64 = ctx.r[8].s64 + -24124;
	// 821B0540: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B0544: 40990008  ble cr6, 0x821b054c
	if !ctx.cr[6].gt {
	pc = 0x821B054C; continue 'dispatch;
	}
	// 821B0548: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B054C: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B0550: 419A0270  beq cr6, 0x821b07c0
	if ctx.cr[6].eq {
	pc = 0x821B07C0; continue 'dispatch;
	}
	// 821B0554: 41980008  blt cr6, 0x821b055c
	if ctx.cr[6].lt {
	pc = 0x821B055C; continue 'dispatch;
	}
	// 821B0558: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B055C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0560: 92210074  stw r17, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[17].u32 ) };
	// 821B0564: 836B001C  lwz r27, 0x1c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B0568: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821B056C: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 821B0570: 419A0030  beq cr6, 0x821b05a0
	if ctx.cr[6].eq {
	pc = 0x821B05A0; continue 'dispatch;
	}
	// 821B0574: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B0578: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B057C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0580: 409A0010  bne cr6, 0x821b0590
	if !ctx.cr[6].eq {
	pc = 0x821B0590; continue 'dispatch;
	}
	// 821B0584: 816F6AC0  lwz r11, 0x6ac0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B0588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B058C: 419A0014  beq cr6, 0x821b05a0
	if ctx.cr[6].eq {
	pc = 0x821B05A0; continue 'dispatch;
	}
	// 821B0590: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B0594: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821B0598: 48033CB9  bl 0x821e4250
	ctx.lr = 0x821B059C;
	sub_821E4250(ctx, base);
	// 821B059C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 821B05A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B05A4: 48001F55  bl 0x821b24f8
	ctx.lr = 0x821B05A8;
	sub_821B24F8(ctx, base);
	// 821B05A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B05AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B05B0: 419A01FC  beq cr6, 0x821b07ac
	if ctx.cr[6].eq {
	pc = 0x821B07AC; continue 'dispatch;
	}
	// 821B05B4: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 821B05B8: 4806ECA1  bl 0x8221f258
	ctx.lr = 0x821B05BC;
	sub_8221F258(ctx, base);
	// 821B05BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B05C0: 419A000C  beq cr6, 0x821b05cc
	if ctx.cr[6].eq {
	pc = 0x821B05CC; continue 'dispatch;
	}
	// 821B05C4: 484697C5  bl 0x82619d88
	ctx.lr = 0x821B05C8;
	sub_82619D88(ctx, base);
	// 821B05C8: 48000008  b 0x821b05d0
	pc = 0x821B05D0; continue 'dispatch;
	// 821B05CC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821B05D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B05D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B05D8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821B05DC: 419A0014  beq cr6, 0x821b05f0
	if ctx.cr[6].eq {
	pc = 0x821B05F0; continue 'dispatch;
	}
	// 821B05E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B05E4: 4846D49D  bl 0x8261da80
	ctx.lr = 0x821B05E8;
	sub_8261DA80(ctx, base);
	// 821B05E8: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B05EC: 48000008  b 0x821b05f4
	pc = 0x821B05F4; continue 'dispatch;
	// 821B05F0: 92210064  stw r17, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[17].u32 ) };
	// 821B05F4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821B05F8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B05FC: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 821B0600: 48043759  bl 0x821f3d58
	ctx.lr = 0x821B0604;
	sub_821F3D58(ctx, base);
	// 821B0604: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B060C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B0610: 482001A9  bl 0x823b07b8
	ctx.lr = 0x821B0614;
	sub_823B07B8(ctx, base);
	// 821B0614: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B0618: 3B9F0038  addi r28, r31, 0x38
	ctx.r[28].s64 = ctx.r[31].s64 + 56;
	// 821B061C: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821B0620: FC0007F2  fmul f0, f0, f31
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 821B0624: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821B0628: D9A10080  stfd f13, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[13].u64 ) };
	// 821B062C: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B0630: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B0634: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0638: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821B063C: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 821B0640: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0644: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0648: 41980008  blt cr6, 0x821b0650
	if ctx.cr[6].lt {
	pc = 0x821B0650; continue 'dispatch;
	}
	// 821B064C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0650: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0654: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B0658: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B065C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B0660: 913C0004  stw r9, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B0664: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0668: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B066C: 41980008  blt cr6, 0x821b0674
	if ctx.cr[6].lt {
	pc = 0x821B0674; continue 'dispatch;
	}
	// 821B0670: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0674: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0678: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B067C: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821B0680: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0684: 913F0044  stw r9, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 821B0688: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B068C: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0690: 41980008  blt cr6, 0x821b0698
	if ctx.cr[6].lt {
	pc = 0x821B0698; continue 'dispatch;
	}
	// 821B0694: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0698: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B069C: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 821B06A0: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 821B06A4: 48321825  bl 0x824d1ec8
	ctx.lr = 0x821B06A8;
	sub_824D1EC8(ctx, base);
	// 821B06A8: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B06AC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B06B0: 41980008  blt cr6, 0x821b06b8
	if ctx.cr[6].lt {
	pc = 0x821B06B8; continue 'dispatch;
	}
	// 821B06B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B06B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B06BC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 821B06C0: 388B003C  addi r4, r11, 0x3c
	ctx.r[4].s64 = ctx.r[11].s64 + 60;
	// 821B06C4: 48321805  bl 0x824d1ec8
	ctx.lr = 0x821B06C8;
	sub_824D1EC8(ctx, base);
	// 821B06C8: 923F0034  stw r17, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[17].u32 ) };
	// 821B06CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821B06D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B06D4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B06D8: 4846B799  bl 0x8261be70
	ctx.lr = 0x821B06DC;
	sub_8261BE70(ctx, base);
	// 821B06DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B06E0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821B06E4: 48029C65  bl 0x821da348
	ctx.lr = 0x821B06E8;
	sub_821DA348(ctx, base);
	// 821B06E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B06EC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821B06F0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B06F4: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821B06F8: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B06FC: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B0700: 41980008  blt cr6, 0x821b0708
	if ctx.cr[6].lt {
	pc = 0x821B0708; continue 'dispatch;
	}
	// 821B0704: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0708: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B070C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 821B0710: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 821B0714: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B0718: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B071C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821B0720: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B0724: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821B0728: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B072C: 911F0030  stw r8, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 821B0730: 481FCD39  bl 0x823ad468
	ctx.lr = 0x821B0734;
	sub_823AD468(ctx, base);
	// 821B0734: 80E10098  lwz r7, 0x98(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0738: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B073C: 41980008  blt cr6, 0x821b0744
	if ctx.cr[6].lt {
	pc = 0x821B0744; continue 'dispatch;
	}
	// 821B0740: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0744: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0748: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B074C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B0750: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0754: 80AB0018  lwz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B0758: 4846B429  bl 0x8261bb80
	ctx.lr = 0x821B075C;
	sub_8261BB80(ctx, base);
	// 821B075C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B0760: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B0764: 4BFE641D  bl 0x82196b80
	ctx.lr = 0x821B0768;
	sub_82196B80(ctx, base);
	// 821B0768: D03F005C  stfs f1, 0x5c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821B076C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B0770: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B0774: 4BFE640D  bl 0x82196b80
	ctx.lr = 0x821B0778;
	sub_82196B80(ctx, base);
	// 821B0778: D03F0060  stfs f1, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B077C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B0780: 92C10078  stw r22, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[22].u32 ) };
	// 821B0784: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0788: 81560004  lwz r10, 4(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B078C: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B0790: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821B0794: 4846D355  bl 0x8261dae8
	ctx.lr = 0x821B0798;
	sub_8261DAE8(ctx, base);
	// 821B0798: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B079C: 4800737D  bl 0x821b7b18
	ctx.lr = 0x821B07A0;
	sub_821B7B18(ctx, base);
	// 821B07A0: 80C10098  lwz r6, 0x98(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B07A4: 80A10094  lwz r5, 0x94(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B07A8: 80F06DA0  lwz r7, 0x6da0(r16)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B07AC: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B07B0: 41980008  blt cr6, 0x821b07b8
	if ctx.cr[6].lt {
	pc = 0x821B07B8; continue 'dispatch;
	}
	// 821B07B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B07B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B07BC: 4BFFFD84  b 0x821b0540
	pc = 0x821B0540; continue 'dispatch;
	// 821B07C0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821B07C4: 480013E5  bl 0x821b1ba8
	ctx.lr = 0x821B07C8;
	sub_821B1BA8(ctx, base);
	// 821B07C8: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B07CC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B07D0: 80F6025C  lwz r7, 0x25c(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(604 as u32) ) } as u64;
	// 821B07D4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821B07D8: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 821B07DC: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B07E0: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 821B07E4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821B07E8: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 821B07EC: 48026E85  bl 0x821d7670
	ctx.lr = 0x821B07F0;
	sub_821D7670(ctx, base);
	// 821B07F0: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B07F4: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B07F8: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B07FC: 40990008  ble cr6, 0x821b0804
	if !ctx.cr[6].gt {
	pc = 0x821B0804; continue 'dispatch;
	}
	// 821B0800: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0804: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0808: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821B080C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B0810: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821B0814: 3E408349  lis r18, -0x7cb7
	ctx.r[18].s64 = -2092367872;
	// 821B0818: 3B2B8B90  addi r25, r11, -0x7470
	ctx.r[25].s64 = ctx.r[11].s64 + -29808;
	// 821B081C: 3B0A8E7C  addi r24, r10, -0x7184
	ctx.r[24].s64 = ctx.r[10].s64 + -29060;
	// 821B0820: 3B498B80  addi r26, r9, -0x7480
	ctx.r[26].s64 = ctx.r[9].s64 + -29824;
	// 821B0824: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 821B0828: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B082C: 40990008  ble cr6, 0x821b0834
	if !ctx.cr[6].gt {
	pc = 0x821B0834; continue 'dispatch;
	}
	// 821B0830: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0834: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0838: 419A0314  beq cr6, 0x821b0b4c
	if ctx.cr[6].eq {
	pc = 0x821B0B4C; continue 'dispatch;
	}
	// 821B083C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B0840: 83706DA0  lwz r27, 0x6da0(r16)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0844: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0848: 48043511  bl 0x821f3d58
	ctx.lr = 0x821B084C;
	sub_821F3D58(ctx, base);
	// 821B084C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0850: 5763003E  slwi r3, r27, 0
	ctx.r[3].u32 = ctx.r[27].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821B0854: 4884F605  bl 0x829ffe58
	ctx.lr = 0x821B0858;
	sub_829FFE58(ctx, base);
	// 821B0858: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B085C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B0860: 419A02D0  beq cr6, 0x821b0b30
	if ctx.cr[6].eq {
	pc = 0x821B0B30; continue 'dispatch;
	}
	// 821B0864: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0868: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B086C: 41980008  blt cr6, 0x821b0874
	if ctx.cr[6].lt {
	pc = 0x821B0874; continue 'dispatch;
	}
	// 821B0870: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0874: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B0878: 814B6AB8  lwz r10, 0x6ab8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B087C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0880: 388B0024  addi r4, r11, 0x24
	ctx.r[4].s64 = ctx.r[11].s64 + 36;
	// 821B0884: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B0888: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B088C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0890: 83C70000  lwz r30, 0(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B0898: 480B3BF1  bl 0x82264488
	ctx.lr = 0x821B089C;
	sub_82264488(ctx, base);
	// 821B089C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B08A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B08A4: 419A0018  beq cr6, 0x821b08bc
	if ctx.cr[6].eq {
	pc = 0x821B08BC; continue 'dispatch;
	}
	// 821B08A8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B08AC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B08B0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821B08B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B08B8: 409A0008  bne cr6, 0x821b08c0
	if !ctx.cr[6].eq {
	pc = 0x821B08C0; continue 'dispatch;
	}
	// 821B08BC: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 821B08C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B08C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B08C8: 419A0030  beq cr6, 0x821b08f8
	if ctx.cr[6].eq {
	pc = 0x821B08F8; continue 'dispatch;
	}
	// 821B08CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B08D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B08D4: 48081EA5  bl 0x82232778
	ctx.lr = 0x821B08D8;
	sub_82232778(ctx, base);
	// 821B08D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B08DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B08E0: 419A000C  beq cr6, 0x821b08ec
	if ctx.cr[6].eq {
	pc = 0x821B08EC; continue 'dispatch;
	}
	// 821B08E4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821B08E8: 48000014  b 0x821b08fc
	pc = 0x821B08FC; continue 'dispatch;
	// 821B08EC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B08F0: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821B08F4: 48000008  b 0x821b08fc
	pc = 0x821B08FC; continue 'dispatch;
	// 821B08F8: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 821B08FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B0900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0904: 419A022C  beq cr6, 0x821b0b30
	if ctx.cr[6].eq {
	pc = 0x821B0B30; continue 'dispatch;
	}
	// 821B0908: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 821B090C: 4806E9B5  bl 0x8221f2c0
	ctx.lr = 0x821B0910;
	sub_8221F2C0(ctx, base);
	// 821B0910: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0914: 409A0048  bne cr6, 0x821b095c
	if !ctx.cr[6].eq {
	pc = 0x821B095C; continue 'dispatch;
	}
	// 821B0918: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B091C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0920: 419A0014  beq cr6, 0x821b0934
	if ctx.cr[6].eq {
	pc = 0x821B0934; continue 'dispatch;
	}
	// 821B0924: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B0928: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B092C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B0930: 4E800421  bctrl
	ctx.lr = 0x821B0934;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B0934: 48B11A75  bl 0x82cc23a8
	ctx.lr = 0x821B0938;
	sub_82CC23A8(ctx, base);
	// 821B0938: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821B093C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B0940: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0944: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821B0948: 419A001C  beq cr6, 0x821b0964
	if ctx.cr[6].eq {
	pc = 0x821B0964; continue 'dispatch;
	}
	// 821B094C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B0950: 4846D131  bl 0x8261da80
	ctx.lr = 0x821B0954;
	sub_8261DA80(ctx, base);
	// 821B0954: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B0958: 48000010  b 0x821b0968
	pc = 0x821B0968; continue 'dispatch;
	// 821B095C: 4846942D  bl 0x82619d88
	ctx.lr = 0x821B0960;
	sub_82619D88(ctx, base);
	// 821B0960: 4BFFFFDC  b 0x821b093c
	pc = 0x821B093C; continue 'dispatch;
	// 821B0964: 92210064  stw r17, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[17].u32 ) };
	// 821B0968: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B096C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0970: 480433E9  bl 0x821f3d58
	ctx.lr = 0x821B0974;
	sub_821F3D58(ctx, base);
	// 821B0974: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0978: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B097C: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 821B0980: 4884FD49  bl 0x82a006c8
	ctx.lr = 0x821B0984;
	sub_82A006C8(ctx, base);
	// 821B0984: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B0988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B098C: 419A0020  beq cr6, 0x821b09ac
	if ctx.cr[6].eq {
	pc = 0x821B09AC; continue 'dispatch;
	}
	// 821B0990: 80706DA0  lwz r3, 0x6da0(r16)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0994: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0998: 480338B9  bl 0x821e4250
	ctx.lr = 0x821B099C;
	sub_821E4250(ctx, base);
	// 821B099C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B09A0: 419A000C  beq cr6, 0x821b09ac
	if ctx.cr[6].eq {
	pc = 0x821B09AC; continue 'dispatch;
	}
	// 821B09A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B09A8: 4803E689  bl 0x821ef030
	ctx.lr = 0x821B09AC;
	sub_821EF030(ctx, base);
	// 821B09AC: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B09B0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B09B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B09B8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821B09BC: 4820EE65  bl 0x823bf820
	ctx.lr = 0x821B09C0;
	sub_823BF820(ctx, base);
	// 821B09C0: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 821B09C4: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B09C8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B09CC: 41980008  blt cr6, 0x821b09d4
	if ctx.cr[6].lt {
	pc = 0x821B09D4; continue 'dispatch;
	}
	// 821B09D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B09D4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B09D8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B09DC: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821B09E0: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B09E4: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 821B09E8: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B09EC: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B09F0: 41980008  blt cr6, 0x821b09f8
	if ctx.cr[6].lt {
	pc = 0x821B09F8; continue 'dispatch;
	}
	// 821B09F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B09F8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B09FC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B0A00: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821B0A04: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0A08: 913F0044  stw r9, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 821B0A0C: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0A10: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0A14: 41980008  blt cr6, 0x821b0a1c
	if ctx.cr[6].lt {
	pc = 0x821B0A1C; continue 'dispatch;
	}
	// 821B0A18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0A1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A20: 3BDF0048  addi r30, r31, 0x48
	ctx.r[30].s64 = ctx.r[31].s64 + 72;
	// 821B0A24: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 821B0A28: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B0A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0A30: 419A001C  beq cr6, 0x821b0a4c
	if ctx.cr[6].eq {
	pc = 0x821B0A4C; continue 'dispatch;
	}
	// 821B0A34: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0A3C: 419A000C  beq cr6, 0x821b0a48
	if ctx.cr[6].eq {
	pc = 0x821B0A48; continue 'dispatch;
	}
	// 821B0A40: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B0A44: 4800000C  b 0x821b0a50
	pc = 0x821B0A50; continue 'dispatch;
	// 821B0A48: 4BFE33F1  bl 0x82193e38
	ctx.lr = 0x821B0A4C;
	sub_82193E38(ctx, base);
	// 821B0A4C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821B0A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B0A54: 48063E45  bl 0x82214898
	ctx.lr = 0x821B0A58;
	sub_82214898(ctx, base);
	// 821B0A58: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0A5C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0A60: 41980008  blt cr6, 0x821b0a68
	if ctx.cr[6].lt {
	pc = 0x821B0A68; continue 'dispatch;
	}
	// 821B0A64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0A68: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A6C: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 821B0A70: 386B003C  addi r3, r11, 0x3c
	ctx.r[3].s64 = ctx.r[11].s64 + 60;
	// 821B0A74: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B0A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0A7C: 419A001C  beq cr6, 0x821b0a98
	if ctx.cr[6].eq {
	pc = 0x821B0A98; continue 'dispatch;
	}
	// 821B0A80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0A88: 419A000C  beq cr6, 0x821b0a94
	if ctx.cr[6].eq {
	pc = 0x821B0A94; continue 'dispatch;
	}
	// 821B0A8C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B0A90: 4800000C  b 0x821b0a9c
	pc = 0x821B0A9C; continue 'dispatch;
	// 821B0A94: 4BFE33A5  bl 0x82193e38
	ctx.lr = 0x821B0A98;
	sub_82193E38(ctx, base);
	// 821B0A98: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821B0A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B0AA0: 48063DF9  bl 0x82214898
	ctx.lr = 0x821B0AA4;
	sub_82214898(ctx, base);
	// 821B0AA4: 92FF0034  stw r23, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[23].u32 ) };
	// 821B0AA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B0AAC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0AB0: 480432A9  bl 0x821f3d58
	ctx.lr = 0x821B0AB4;
	sub_821F3D58(ctx, base);
	// 821B0AB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0AB8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B0ABC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B0AC0: 4811CA09  bl 0x822cd4c8
	ctx.lr = 0x821B0AC4;
	sub_822CD4C8(ctx, base);
	// 821B0AC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0AC8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821B0ACC: 4802987D  bl 0x821da348
	ctx.lr = 0x821B0AD0;
	sub_821DA348(ctx, base);
	// 821B0AD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0AD4: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821B0AD8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0ADC: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821B0AE0: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0AE4: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B0AE8: 41980008  blt cr6, 0x821b0af0
	if ctx.cr[6].lt {
	pc = 0x821B0AF0; continue 'dispatch;
	}
	// 821B0AEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0AF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0AF4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B0AF8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0AFC: 92C10078  stw r22, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[22].u32 ) };
	// 821B0B00: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B0B04: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821B0B08: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B0B0C: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821B0B10: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B0B14: 911F0030  stw r8, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 821B0B18: 80F60004  lwz r7, 4(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0B1C: 90E1007C  stw r7, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 821B0B20: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821B0B24: 4846CFC5  bl 0x8261dae8
	ctx.lr = 0x821B0B28;
	sub_8261DAE8(ctx, base);
	// 821B0B28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B0B2C: 48006FED  bl 0x821b7b18
	ctx.lr = 0x821B0B30;
	sub_821B7B18(ctx, base);
	// 821B0B30: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0B34: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0B38: 41980008  blt cr6, 0x821b0b40
	if ctx.cr[6].lt {
	pc = 0x821B0B40; continue 'dispatch;
	}
	// 821B0B3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0B40: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B0B44: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B0B48: 4BFFFCE0  b 0x821b0828
	pc = 0x821B0828; continue 'dispatch;
	// 821B0B4C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0B50: 40990010  ble cr6, 0x821b0b60
	if !ctx.cr[6].gt {
	pc = 0x821B0B60; continue 'dispatch;
	}
	// 821B0B54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0B58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0B5C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0B60: 419A0008  beq cr6, 0x821b0b68
	if ctx.cr[6].eq {
	pc = 0x821B0B68; continue 'dispatch;
	}
	// 821B0B64: 90E10098  stw r7, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[7].u32 ) };
	// 821B0B68: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0B6C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B0B70: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 821B0B74: 80F6025C  lwz r7, 0x25c(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(604 as u32) ) } as u64;
	// 821B0B78: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821B0B7C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 821B0B80: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B0B84: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 821B0B88: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821B0B8C: 48026AE5  bl 0x821d7670
	ctx.lr = 0x821B0B90;
	sub_821D7670(ctx, base);
	// 821B0B90: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B0B94: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0B98: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0B9C: 40990008  ble cr6, 0x821b0ba4
	if !ctx.cr[6].gt {
	pc = 0x821B0BA4; continue 'dispatch;
	}
	// 821B0BA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0BA4: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821B0BA8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821B0BAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B0BB0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821B0BB4: 3B200003  li r25, 3
	ctx.r[25].s64 = 3;
	// 821B0BB8: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 821B0BBC: 3B09E460  addi r24, r9, -0x1ba0
	ctx.r[24].s64 = ctx.r[9].s64 + -7072;
	// 821B0BC0: 3B6AF0FC  addi r27, r10, -0xf04
	ctx.r[27].s64 = ctx.r[10].s64 + -3844;
	// 821B0BC4: 3AEBF11C  addi r23, r11, -0xee4
	ctx.r[23].s64 = ctx.r[11].s64 + -3812;
	// 821B0BC8: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0BCC: 40990008  ble cr6, 0x821b0bd4
	if !ctx.cr[6].gt {
	pc = 0x821B0BD4; continue 'dispatch;
	}
	// 821B0BD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0BD4: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0BD8: 419A03F8  beq cr6, 0x821b0fd0
	if ctx.cr[6].eq {
	pc = 0x821B0FD0; continue 'dispatch;
	}
	// 821B0BDC: 41980008  blt cr6, 0x821b0be4
	if ctx.cr[6].lt {
	pc = 0x821B0BE4; continue 'dispatch;
	}
	// 821B0BE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0BE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0BE8: 9221006C  stw r17, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[17].u32 ) };
	// 821B0BEC: 838B001C  lwz r28, 0x1c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B0BF0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B0BF4: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 821B0BF8: 419A03C4  beq cr6, 0x821b0fbc
	if ctx.cr[6].eq {
	pc = 0x821B0FBC; continue 'dispatch;
	}
	// 821B0BFC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B0C00: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B0C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0C08: 409A0010  bne cr6, 0x821b0c18
	if !ctx.cr[6].eq {
	pc = 0x821B0C18; continue 'dispatch;
	}
	// 821B0C0C: 816F6AC0  lwz r11, 0x6ac0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B0C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0C14: 419A0014  beq cr6, 0x821b0c28
	if ctx.cr[6].eq {
	pc = 0x821B0C28; continue 'dispatch;
	}
	// 821B0C18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B0C1C: 80706DA0  lwz r3, 0x6da0(r16)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0C20: 48033631  bl 0x821e4250
	ctx.lr = 0x821B0C24;
	sub_821E4250(ctx, base);
	// 821B0C24: 9061006C  stw r3, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 821B0C28: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 821B0C2C: 4806E695  bl 0x8221f2c0
	ctx.lr = 0x821B0C30;
	sub_8221F2C0(ctx, base);
	// 821B0C30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0C34: 409A01A8  bne cr6, 0x821b0ddc
	if !ctx.cr[6].eq {
	pc = 0x821B0DDC; continue 'dispatch;
	}
	// 821B0C38: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B0C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0C40: 419A0014  beq cr6, 0x821b0c54
	if ctx.cr[6].eq {
	pc = 0x821B0C54; continue 'dispatch;
	}
	// 821B0C44: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B0C48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B0C4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B0C50: 4E800421  bctrl
	ctx.lr = 0x821B0C54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B0C54: 48B11755  bl 0x82cc23a8
	ctx.lr = 0x821B0C58;
	sub_82CC23A8(ctx, base);
	// 821B0C58: 7E3E8B78  mr r30, r17
	ctx.r[30].u64 = ctx.r[17].u64;
	// 821B0C5C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821B0C60: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B0C64: 419A0034  beq cr6, 0x821b0c98
	if ctx.cr[6].eq {
	pc = 0x821B0C98; continue 'dispatch;
	}
	// 821B0C68: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 821B0C6C: 4806E655  bl 0x8221f2c0
	ctx.lr = 0x821B0C70;
	sub_8221F2C0(ctx, base);
	// 821B0C70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0C74: 409A0174  bne cr6, 0x821b0de8
	if !ctx.cr[6].eq {
	pc = 0x821B0DE8; continue 'dispatch;
	}
	// 821B0C78: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B0C7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0C80: 419A0014  beq cr6, 0x821b0c94
	if ctx.cr[6].eq {
	pc = 0x821B0C94; continue 'dispatch;
	}
	// 821B0C84: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B0C88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B0C8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B0C90: 4E800421  bctrl
	ctx.lr = 0x821B0C94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B0C94: 48B11715  bl 0x82cc23a8
	ctx.lr = 0x821B0C98;
	sub_82CC23A8(ctx, base);
	// 821B0C98: 92210074  stw r17, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[17].u32 ) };
	// 821B0C9C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821B0CA0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0CA4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821B0CA8: 480430B1  bl 0x821f3d58
	ctx.lr = 0x821B0CAC;
	sub_821F3D58(ctx, base);
	// 821B0CAC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821B0CB0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B0CB4: 48001845  bl 0x821b24f8
	ctx.lr = 0x821B0CB8;
	sub_821B24F8(ctx, base);
	// 821B0CB8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 821B0CBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B0CC0: 48034D49  bl 0x821e5a08
	ctx.lr = 0x821B0CC4;
	sub_821E5A08(ctx, base);
	// 821B0CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0CC8: 419A02E4  beq cr6, 0x821b0fac
	if ctx.cr[6].eq {
	pc = 0x821B0FAC; continue 'dispatch;
	}
	// 821B0CCC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B0CD0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B0CD4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B0CD8: 419A0020  beq cr6, 0x821b0cf8
	if ctx.cr[6].eq {
	pc = 0x821B0CF8; continue 'dispatch;
	}
	// 821B0CDC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B0CE0: 409A0018  bne cr6, 0x821b0cf8
	if !ctx.cr[6].eq {
	pc = 0x821B0CF8; continue 'dispatch;
	}
	// 821B0CE4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0CE8: 817AE454  lwz r11, -0x1bac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 821B0CEC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0CF0: 409A0008  bne cr6, 0x821b0cf8
	if !ctx.cr[6].eq {
	pc = 0x821B0CF8; continue 'dispatch;
	}
	// 821B0CF4: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821B0CF8: 80706DA0  lwz r3, 0x6da0(r16)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0CFC: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0D00: 48033551  bl 0x821e4250
	ctx.lr = 0x821B0D04;
	sub_821E4250(ctx, base);
	// 821B0D04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B0D08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B0D0C: 419A02A0  beq cr6, 0x821b0fac
	if ctx.cr[6].eq {
	pc = 0x821B0FAC; continue 'dispatch;
	}
	// 821B0D10: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821B0D14: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0D18: 39DE0010  addi r14, r30, 0x10
	ctx.r[14].s64 = ctx.r[30].s64 + 16;
	// 821B0D1C: 4804303D  bl 0x821f3d58
	ctx.lr = 0x821B0D20;
	sub_821F3D58(ctx, base);
	// 821B0D20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0D28: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 821B0D2C: 481FFA8D  bl 0x823b07b8
	ctx.lr = 0x821B0D30;
	sub_823B07B8(ctx, base);
	// 821B0D30: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B0D34: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821B0D38: FC0007F2  fmul f0, f0, f31
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 821B0D3C: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821B0D40: D9A10088  stfd f13, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.f[13].u64 ) };
	// 821B0D44: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0D48: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821B0D4C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B0D50: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B0D54: 913E0018  stw r9, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 821B0D58: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0D5C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0D60: 41980008  blt cr6, 0x821b0d68
	if ctx.cr[6].lt {
	pc = 0x821B0D68; continue 'dispatch;
	}
	// 821B0D64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0D68: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0D6C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B0D70: 915E0038  stw r10, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821B0D74: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B0D78: 913E003C  stw r9, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 821B0D7C: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0D80: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0D84: 41980008  blt cr6, 0x821b0d8c
	if ctx.cr[6].lt {
	pc = 0x821B0D8C; continue 'dispatch;
	}
	// 821B0D88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0D8C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0D90: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B0D94: 915E0040  stw r10, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821B0D98: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0D9C: 913E0044  stw r9, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 821B0DA0: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0DA4: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0DA8: 41980008  blt cr6, 0x821b0db0
	if ctx.cr[6].lt {
	pc = 0x821B0DB0; continue 'dispatch;
	}
	// 821B0DAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0DB0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0DB4: 3BFE0048  addi r31, r30, 0x48
	ctx.r[31].s64 = ctx.r[30].s64 + 72;
	// 821B0DB8: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 821B0DBC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B0DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0DC4: 419A0048  beq cr6, 0x821b0e0c
	if ctx.cr[6].eq {
	pc = 0x821B0E0C; continue 'dispatch;
	}
	// 821B0DC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0DCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0DD0: 419A0038  beq cr6, 0x821b0e08
	if ctx.cr[6].eq {
	pc = 0x821B0E08; continue 'dispatch;
	}
	// 821B0DD4: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B0DD8: 48000038  b 0x821b0e10
	pc = 0x821B0E10; continue 'dispatch;
	// 821B0DDC: 48468FAD  bl 0x82619d88
	ctx.lr = 0x821B0DE0;
	sub_82619D88(ctx, base);
	// 821B0DE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B0DE4: 4BFFFE78  b 0x821b0c5c
	pc = 0x821B0C5C; continue 'dispatch;
	// 821B0DE8: 3D608262  lis r11, -0x7d9e
	ctx.r[11].s64 = -2107506688;
	// 821B0DEC: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821B0DF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B0DF4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 821B0DF8: 392BDC58  addi r9, r11, -0x23a8
	ctx.r[9].s64 = ctx.r[11].s64 + -9128;
	// 821B0DFC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B0E00: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B0E04: 4BFFFE98  b 0x821b0c9c
	pc = 0x821B0C9C; continue 'dispatch;
	// 821B0E08: 4BFE3031  bl 0x82193e38
	ctx.lr = 0x821B0E0C;
	sub_82193E38(ctx, base);
	// 821B0E0C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821B0E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0E14: 48063A85  bl 0x82214898
	ctx.lr = 0x821B0E18;
	sub_82214898(ctx, base);
	// 821B0E18: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0E1C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0E20: 41980008  blt cr6, 0x821b0e28
	if ctx.cr[6].lt {
	pc = 0x821B0E28; continue 'dispatch;
	}
	// 821B0E24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0E28: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0E2C: 3BFE0050  addi r31, r30, 0x50
	ctx.r[31].s64 = ctx.r[30].s64 + 80;
	// 821B0E30: 386B003C  addi r3, r11, 0x3c
	ctx.r[3].s64 = ctx.r[11].s64 + 60;
	// 821B0E34: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B0E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0E3C: 419A001C  beq cr6, 0x821b0e58
	if ctx.cr[6].eq {
	pc = 0x821B0E58; continue 'dispatch;
	}
	// 821B0E40: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0E44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0E48: 419A000C  beq cr6, 0x821b0e54
	if ctx.cr[6].eq {
	pc = 0x821B0E54; continue 'dispatch;
	}
	// 821B0E4C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B0E50: 4800000C  b 0x821b0e5c
	pc = 0x821B0E5C; continue 'dispatch;
	// 821B0E54: 4BFE2FE5  bl 0x82193e38
	ctx.lr = 0x821B0E58;
	sub_82193E38(ctx, base);
	// 821B0E58: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821B0E5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0E60: 48063A39  bl 0x82214898
	ctx.lr = 0x821B0E64;
	sub_82214898(ctx, base);
	// 821B0E64: 933E0034  stw r25, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[25].u32 ) };
	// 821B0E68: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B0E6C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0E70: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 821B0E74: 48042EE5  bl 0x821f3d58
	ctx.lr = 0x821B0E78;
	sub_821F3D58(ctx, base);
	// 821B0E78: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821B0E7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B0E80: 48001679  bl 0x821b24f8
	ctx.lr = 0x821B0E84;
	sub_821B24F8(ctx, base);
	// 821B0E84: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 821B0E88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B0E8C: 48034B7D  bl 0x821e5a08
	ctx.lr = 0x821B0E90;
	sub_821E5A08(ctx, base);
	// 821B0E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0E94: 419A008C  beq cr6, 0x821b0f20
	if ctx.cr[6].eq {
	pc = 0x821B0F20; continue 'dispatch;
	}
	// 821B0E98: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B0E9C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B0EA0: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B0EA4: 419A0020  beq cr6, 0x821b0ec4
	if ctx.cr[6].eq {
	pc = 0x821B0EC4; continue 'dispatch;
	}
	// 821B0EA8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B0EAC: 409A0018  bne cr6, 0x821b0ec4
	if !ctx.cr[6].eq {
	pc = 0x821B0EC4; continue 'dispatch;
	}
	// 821B0EB0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0EB4: 817AE454  lwz r11, -0x1bac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 821B0EB8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B0EBC: 409A0008  bne cr6, 0x821b0ec4
	if !ctx.cr[6].eq {
	pc = 0x821B0EC4; continue 'dispatch;
	}
	// 821B0EC0: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821B0EC4: 80F06DA0  lwz r7, 0x6da0(r16)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0EC8: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0ECC: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821B0ED0: 48033381  bl 0x821e4250
	ctx.lr = 0x821B0ED4;
	sub_821E4250(ctx, base);
	// 821B0ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B0ED8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B0EDC: 419A0048  beq cr6, 0x821b0f24
	if ctx.cr[6].eq {
	pc = 0x821B0F24; continue 'dispatch;
	}
	// 821B0EE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B0EE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B0EE8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0EEC: 4846AF85  bl 0x8261be70
	ctx.lr = 0x821B0EF0;
	sub_8261BE70(ctx, base);
	// 821B0EF0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821B0EF4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821B0EF8: 39C10060  addi r14, r1, 0x60
	ctx.r[14].s64 = ctx.r[1].s64 + 96;
	// 821B0EFC: 48042E5D  bl 0x821f3d58
	ctx.lr = 0x821B0F00;
	sub_821F3D58(ctx, base);
	// 821B0F00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B0F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0F08: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 821B0F0C: 48034AFD  bl 0x821e5a08
	ctx.lr = 0x821B0F10;
	sub_821E5A08(ctx, base);
	// 821B0F10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B0F14: 419A000C  beq cr6, 0x821b0f20
	if ctx.cr[6].eq {
	pc = 0x821B0F20; continue 'dispatch;
	}
	// 821B0F18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0F1C: 917E001C  stw r11, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B0F20: 80F06DA0  lwz r7, 0x6da0(r16)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B0F24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B0F28: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 821B0F2C: 9221007C  stw r17, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[17].u32 ) };
	// 821B0F30: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B0F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0F38: 409A0010  bne cr6, 0x821b0f48
	if !ctx.cr[6].eq {
	pc = 0x821B0F48; continue 'dispatch;
	}
	// 821B0F3C: 816F6AC0  lwz r11, 0x6ac0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B0F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0F44: 419A0014  beq cr6, 0x821b0f58
	if ctx.cr[6].eq {
	pc = 0x821B0F58; continue 'dispatch;
	}
	// 821B0F48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B0F4C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821B0F50: 48033301  bl 0x821e4250
	ctx.lr = 0x821B0F54;
	sub_821E4250(ctx, base);
	// 821B0F54: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 821B0F58: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821B0F5C: F97E0020  std r11, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 821B0F60: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0F64: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B0F68: 41980008  blt cr6, 0x821b0f70
	if ctx.cr[6].lt {
	pc = 0x821B0F70; continue 'dispatch;
	}
	// 821B0F6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0F70: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0F74: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821B0F78: 92C10080  stw r22, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[22].u32 ) };
	// 821B0F7C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B0F80: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B0F84: 915E0028  stw r10, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821B0F88: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B0F8C: 913E002C  stw r9, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821B0F90: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B0F94: 911E0030  stw r8, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 821B0F98: 80F60004  lwz r7, 4(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0F9C: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821B0FA0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 821B0FA4: 4846CB45  bl 0x8261dae8
	ctx.lr = 0x821B0FA8;
	sub_8261DAE8(ctx, base);
	// 821B0FA8: 81C10058  lwz r14, 0x58(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B0FAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B0FB0: 48006B69  bl 0x821b7b18
	ctx.lr = 0x821B0FB4;
	sub_821B7B18(ctx, base);
	// 821B0FB4: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B0FB8: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B0FBC: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0FC0: 41980008  blt cr6, 0x821b0fc8
	if ctx.cr[6].lt {
	pc = 0x821B0FC8; continue 'dispatch;
	}
	// 821B0FC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0FC8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B0FCC: 4BFFFBFC  b 0x821b0bc8
	pc = 0x821B0BC8; continue 'dispatch;
	// 821B0FD0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0FD4: 40990010  ble cr6, 0x821b0fe4
	if !ctx.cr[6].gt {
	pc = 0x821B0FE4; continue 'dispatch;
	}
	// 821B0FD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0FDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B0FE0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B0FE4: 419A0008  beq cr6, 0x821b0fec
	if ctx.cr[6].eq {
	pc = 0x821B0FEC; continue 'dispatch;
	}
	// 821B0FE8: 90E10098  stw r7, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[7].u32 ) };
	// 821B0FEC: 81760258  lwz r11, 0x258(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B0FF0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B0FF4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821B0FF8: 80F6025C  lwz r7, 0x25c(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(604 as u32) ) } as u64;
	// 821B0FFC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821B1000: 38800032  li r4, 0x32
	ctx.r[4].s64 = 50;
	// 821B1004: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 821B1008: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 821B100C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821B1010: 48026661  bl 0x821d7670
	ctx.lr = 0x821B1014;
	sub_821D7670(ctx, base);
	// 821B1014: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B1018: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B101C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1020: 40990008  ble cr6, 0x821b1028
	if !ctx.cr[6].gt {
	pc = 0x821B1028; continue 'dispatch;
	}
	// 821B1024: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1028: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 821B102C: 3B400004  li r26, 4
	ctx.r[26].s64 = 4;
	// 821B1030: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1034: 40990008  ble cr6, 0x821b103c
	if !ctx.cr[6].gt {
	pc = 0x821B103C; continue 'dispatch;
	}
	// 821B1038: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B103C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1040: 419A02AC  beq cr6, 0x821b12ec
	if ctx.cr[6].eq {
	pc = 0x821B12EC; continue 'dispatch;
	}
	// 821B1044: 41980008  blt cr6, 0x821b104c
	if ctx.cr[6].lt {
	pc = 0x821B104C; continue 'dispatch;
	}
	// 821B1048: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B104C: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1050: 9221007C  stw r17, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[17].u32 ) };
	// 821B1054: 8369001C  lwz r27, 0x1c(r9)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B1058: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821B105C: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 821B1060: 419A0278  beq cr6, 0x821b12d8
	if ctx.cr[6].eq {
	pc = 0x821B12D8; continue 'dispatch;
	}
	// 821B1064: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B1068: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B106C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1070: 409A0010  bne cr6, 0x821b1080
	if !ctx.cr[6].eq {
	pc = 0x821B1080; continue 'dispatch;
	}
	// 821B1074: 816F6AC0  lwz r11, 0x6ac0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B1078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B107C: 419A0014  beq cr6, 0x821b1090
	if ctx.cr[6].eq {
	pc = 0x821B1090; continue 'dispatch;
	}
	// 821B1080: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B1084: 80706DA0  lwz r3, 0x6da0(r16)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B1088: 480331C9  bl 0x821e4250
	ctx.lr = 0x821B108C;
	sub_821E4250(ctx, base);
	// 821B108C: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 821B1090: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 821B1094: 4806E22D  bl 0x8221f2c0
	ctx.lr = 0x821B1098;
	sub_8221F2C0(ctx, base);
	// 821B1098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B109C: 409A0114  bne cr6, 0x821b11b0
	if !ctx.cr[6].eq {
	pc = 0x821B11B0; continue 'dispatch;
	}
	// 821B10A0: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B10A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B10A8: 419A0014  beq cr6, 0x821b10bc
	if ctx.cr[6].eq {
	pc = 0x821B10BC; continue 'dispatch;
	}
	// 821B10AC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B10B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B10B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B10B8: 4E800421  bctrl
	ctx.lr = 0x821B10BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B10BC: 48B112ED  bl 0x82cc23a8
	ctx.lr = 0x821B10C0;
	sub_82CC23A8(ctx, base);
	// 821B10C0: 7E3F8B78  mr r31, r17
	ctx.r[31].u64 = ctx.r[17].u64;
	// 821B10C4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 821B10C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B10CC: 419A0034  beq cr6, 0x821b1100
	if ctx.cr[6].eq {
	pc = 0x821B1100; continue 'dispatch;
	}
	// 821B10D0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 821B10D4: 4806E1ED  bl 0x8221f2c0
	ctx.lr = 0x821B10D8;
	sub_8221F2C0(ctx, base);
	// 821B10D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B10DC: 409A00E0  bne cr6, 0x821b11bc
	if !ctx.cr[6].eq {
	pc = 0x821B11BC; continue 'dispatch;
	}
	// 821B10E0: 81726F6C  lwz r11, 0x6f6c(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821B10E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B10E8: 419A0014  beq cr6, 0x821b10fc
	if ctx.cr[6].eq {
	pc = 0x821B10FC; continue 'dispatch;
	}
	// 821B10EC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B10F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B10F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B10F8: 4E800421  bctrl
	ctx.lr = 0x821B10FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B10FC: 48B112AD  bl 0x82cc23a8
	ctx.lr = 0x821B1100;
	sub_82CC23A8(ctx, base);
	// 821B1100: 92210074  stw r17, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[17].u32 ) };
	// 821B1104: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B1108: 81560258  lwz r10, 0x258(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(600 as u32) ) } as u64;
	// 821B110C: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821B1110: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821B1114: FC0007F2  fmul f0, f0, f31
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 821B1118: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821B111C: D9A10088  stfd f13, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.f[13].u64 ) };
	// 821B1120: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B1124: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B1128: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 821B112C: 80E10098  lwz r7, 0x98(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B1130: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B1134: 41980008  blt cr6, 0x821b113c
	if ctx.cr[6].lt {
	pc = 0x821B113C; continue 'dispatch;
	}
	// 821B1138: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B113C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1140: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B1144: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821B1148: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B114C: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 821B1150: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B1154: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B1158: 41980008  blt cr6, 0x821b1160
	if ctx.cr[6].lt {
	pc = 0x821B1160; continue 'dispatch;
	}
	// 821B115C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1160: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1164: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B1168: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821B116C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B1170: 913F0044  stw r9, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 821B1174: 81010098  lwz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B1178: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B117C: 41980008  blt cr6, 0x821b1184
	if ctx.cr[6].lt {
	pc = 0x821B1184; continue 'dispatch;
	}
	// 821B1180: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1184: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1188: 3B9F0048  addi r28, r31, 0x48
	ctx.r[28].s64 = ctx.r[31].s64 + 72;
	// 821B118C: 3BCB0034  addi r30, r11, 0x34
	ctx.r[30].s64 = ctx.r[11].s64 + 52;
	// 821B1190: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B1194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1198: 419A0074  beq cr6, 0x821b120c
	if ctx.cr[6].eq {
	pc = 0x821B120C; continue 'dispatch;
	}
	// 821B119C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B11A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B11A4: 419A0038  beq cr6, 0x821b11dc
	if ctx.cr[6].eq {
	pc = 0x821B11DC; continue 'dispatch;
	}
	// 821B11A8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B11AC: 48000064  b 0x821b1210
	pc = 0x821B1210; continue 'dispatch;
	// 821B11B0: 48468BD9  bl 0x82619d88
	ctx.lr = 0x821B11B4;
	sub_82619D88(ctx, base);
	// 821B11B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B11B8: 4BFFFF0C  b 0x821b10c4
	pc = 0x821B10C4; continue 'dispatch;
	// 821B11BC: 3D608262  lis r11, -0x7d9e
	ctx.r[11].s64 = -2107506688;
	// 821B11C0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 821B11C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B11C8: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 821B11CC: 392BDC58  addi r9, r11, -0x23a8
	ctx.r[9].s64 = ctx.r[11].s64 + -9128;
	// 821B11D0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B11D4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B11D8: 4BFFFF2C  b 0x821b1104
	pc = 0x821B1104; continue 'dispatch;
	// 821B11DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B11E0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B11E4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821B11E8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B11EC: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B11F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B11F4: 409A0014  bne cr6, 0x821b1208
	if !ctx.cr[6].eq {
	pc = 0x821B1208; continue 'dispatch;
	}
	// 821B11F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B11FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1200: 409A0008  bne cr6, 0x821b1208
	if !ctx.cr[6].eq {
	pc = 0x821B1208; continue 'dispatch;
	}
	// 821B1204: 4806AB35  bl 0x8221bd38
	ctx.lr = 0x821B1208;
	sub_8221BD38(ctx, base);
	// 821B1208: 923E0004  stw r17, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 821B120C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821B1210: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B1214: 48063685  bl 0x82214898
	ctx.lr = 0x821B1218;
	sub_82214898(ctx, base);
	// 821B1218: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B121C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1220: 41980008  blt cr6, 0x821b1228
	if ctx.cr[6].lt {
	pc = 0x821B1228; continue 'dispatch;
	}
	// 821B1224: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1228: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B122C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 821B1230: 388B003C  addi r4, r11, 0x3c
	ctx.r[4].s64 = ctx.r[11].s64 + 60;
	// 821B1234: 48320C95  bl 0x824d1ec8
	ctx.lr = 0x821B1238;
	sub_824D1EC8(ctx, base);
	// 821B1238: 935F0034  stw r26, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[26].u32 ) };
	// 821B123C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821B1240: 480012B9  bl 0x821b24f8
	ctx.lr = 0x821B1244;
	sub_821B24F8(ctx, base);
	// 821B1244: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B1248: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B124C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B1250: 4846AC21  bl 0x8261be70
	ctx.lr = 0x821B1254;
	sub_8261BE70(ctx, base);
	// 821B1254: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B1258: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B125C: 480290ED  bl 0x821da348
	ctx.lr = 0x821B1260;
	sub_821DA348(ctx, base);
	// 821B1260: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1264: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821B1268: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B126C: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821B1270: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B1274: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B1278: 41980008  blt cr6, 0x821b1280
	if ctx.cr[6].lt {
	pc = 0x821B1280; continue 'dispatch;
	}
	// 821B127C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1280: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1284: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B1288: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B128C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B1290: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821B1294: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B1298: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821B129C: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B12A0: 911F0030  stw r8, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 821B12A4: 4846A185  bl 0x8261b428
	ctx.lr = 0x821B12A8;
	sub_8261B428(ctx, base);
	// 821B12A8: 987F005A  stb r3, 0x5a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(90 as u32), ctx.r[3].u8 ) };
	// 821B12AC: 92C10080  stw r22, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[22].u32 ) };
	// 821B12B0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821B12B4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B12B8: 80F60004  lwz r7, 4(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B12BC: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821B12C0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 821B12C4: 4846C825  bl 0x8261dae8
	ctx.lr = 0x821B12C8;
	sub_8261DAE8(ctx, base);
	// 821B12C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B12CC: 4800684D  bl 0x821b7b18
	ctx.lr = 0x821B12D0;
	sub_821B7B18(ctx, base);
	// 821B12D0: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821B12D4: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B12D8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B12DC: 41980008  blt cr6, 0x821b12e4
	if ctx.cr[6].lt {
	pc = 0x821B12E4; continue 'dispatch;
	}
	// 821B12E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B12E4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B12E8: 4BFFFD48  b 0x821b1030
	pc = 0x821B1030; continue 'dispatch;
	// 821B12EC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B12F0: 4BFC19C1  bl 0x82172cb0
	ctx.lr = 0x821B12F4;
	sub_82172CB0(ctx, base);
	// 821B12F4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B12F8: 48123CB1  bl 0x822d4fa8
	ctx.lr = 0x821B12FC;
	sub_822D4FA8(ctx, base);
	// 821B12FC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B1300: 48123E41  bl 0x822d5140
	ctx.lr = 0x821B1304;
	sub_822D5140(ctx, base);
	// 821B1304: 816E0454  lwz r11, 0x454(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(1108 as u32) ) } as u64;
	// 821B1308: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821B130C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B1310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B1314: 9176025C  stw r11, 0x25c(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 821B1318: 419A0008  beq cr6, 0x821b1320
	if ctx.cr[6].eq {
	pc = 0x821B1320; continue 'dispatch;
	}
	// 821B131C: 4806AA1D  bl 0x8221bd38
	ctx.lr = 0x821B1320;
	sub_8221BD38(ctx, base);
	// 821B1320: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821B1324: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 821B1328: 48AF80F8  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1330 size=28
    let mut pc: u32 = 0x821B1330;
    'dispatch: loop {
        match pc {
            0x821B1330 => {
    //   block [0x821B1330..0x821B134C)
	// 821B1330: 8163293C  lwz r11, 0x293c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10556 as u32) ) } as u64;
	// 821B1334: 51640038  rlwimi r4, r11, 0, 0, 0x1c
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0x00000000FFFFFFF8) | (ctx.r[4].u64 & 0xFFFFFFFF00000007);
	// 821B1338: 9083293C  stw r4, 0x293c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10556 as u32), ctx.r[4].u32 ) };
	// 821B133C: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821B1340: 616B0200  ori r11, r11, 0x200
	ctx.r[11].u64 = ctx.r[11].u64 | 512;
	// 821B1344: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B1348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1350 size=20
    let mut pc: u32 = 0x821B1350;
    'dispatch: loop {
        match pc {
            0x821B1350 => {
    //   block [0x821B1350..0x821B1364)
	// 821B1350: 98832901  stb r4, 0x2901(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(10497 as u32), ctx.r[4].u8 ) };
	// 821B1354: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821B1358: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	// 821B135C: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B1360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1368 size=44
    let mut pc: u32 = 0x821B1368;
    'dispatch: loop {
        match pc {
            0x821B1368 => {
    //   block [0x821B1368..0x821B1394)
	// 821B1368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B136C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1370: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1374: 48042A3D  bl 0x821f3db0
	ctx.lr = 0x821B1378;
	sub_821F3DB0(ctx, base);
	// 821B1378: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 821B137C: C80B0ED0  lfd f0, 0xed0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3792 as u32) ) };
	// 821B1380: FC210032  fmul f1, f1, f0
	ctx.f[1].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 821B1384: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1388: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B138C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1398 size=380
    let mut pc: u32 = 0x821B1398;
    'dispatch: loop {
        match pc {
            0x821B1398 => {
    //   block [0x821B1398..0x821B1514)
	// 821B1398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B139C: 48AF8061  bl 0x82ca93fc
	ctx.lr = 0x821B13A0;
	sub_82CA93D0(ctx, base);
	// 821B13A0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 821B13A4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821B13A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B13AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B13B0: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B13B4: 48000165  bl 0x821b1518
	ctx.lr = 0x821B13B8;
	sub_821B1518(ctx, base);
	// 821B13B8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B13BC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821B13C0: 419A0144  beq cr6, 0x821b1504
	if ctx.cr[6].eq {
	pc = 0x821B1504; continue 'dispatch;
	}
	// 821B13C4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B13C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B13CC: 40990138  ble cr6, 0x821b1504
	if !ctx.cr[6].gt {
	pc = 0x821B1504; continue 'dispatch;
	}
	// 821B13D0: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B13D4: 4805641D  bl 0x822077f0
	ctx.lr = 0x821B13D8;
	sub_822077F0(ctx, base);
	// 821B13D8: 81650018  lwz r11, 0x18(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B13DC: 3B850014  addi r28, r5, 0x14
	ctx.r[28].s64 = ctx.r[5].s64 + 20;
	// 821B13E0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821B13E4: 3F40820A  lis r26, -0x7df6
	ctx.r[26].s64 = -2113273856;
	// 821B13E8: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821B13EC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B13F0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B13F4: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B13F8: 419A0008  beq cr6, 0x821b1400
	if ctx.cr[6].eq {
	pc = 0x821B1400; continue 'dispatch;
	}
	// 821B13FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1400: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1404: 419A0100  beq cr6, 0x821b1504
	if ctx.cr[6].eq {
	pc = 0x821B1504; continue 'dispatch;
	}
	// 821B1408: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B140C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1410: 409A0008  bne cr6, 0x821b1418
	if !ctx.cr[6].eq {
	pc = 0x821B1418; continue 'dispatch;
	}
	// 821B1414: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1418: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B141C: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 821B1420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1424: 409A00BC  bne cr6, 0x821b14e0
	if !ctx.cr[6].eq {
	pc = 0x821B14E0; continue 'dispatch;
	}
	// 821B1428: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B142C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1430: 419A0038  beq cr6, 0x821b1468
	if ctx.cr[6].eq {
	pc = 0x821B1468; continue 'dispatch;
	}
	// 821B1434: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1438: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B143C: 419A00BC  beq cr6, 0x821b14f8
	if ctx.cr[6].eq {
	pc = 0x821B14F8; continue 'dispatch;
	}
	// 821B1440: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1448: 419A0020  beq cr6, 0x821b1468
	if ctx.cr[6].eq {
	pc = 0x821B1468; continue 'dispatch;
	}
	// 821B144C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B1450: 4BFC29E9  bl 0x82173e38
	ctx.lr = 0x821B1454;
	sub_82173E38(ctx, base);
	// 821B1454: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B1458: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B145C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B1460: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1464: 409A0008  bne cr6, 0x821b146c
	if !ctx.cr[6].eq {
	pc = 0x821B146C; continue 'dispatch;
	}
	// 821B1468: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B146C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1474: 419A006C  beq cr6, 0x821b14e0
	if ctx.cr[6].eq {
	pc = 0x821B14E0; continue 'dispatch;
	}
	// 821B1478: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B147C: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 821B1480: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1484: 41980018  blt cr6, 0x821b149c
	if ctx.cr[6].lt {
	pc = 0x821B149C; continue 'dispatch;
	}
	// 821B1488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B148C: 480E72AD  bl 0x82298738
	ctx.lr = 0x821B1490;
	sub_82298738(ctx, base);
	// 821B1490: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B1494: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B1498: 409A0008  bne cr6, 0x821b14a0
	if !ctx.cr[6].eq {
	pc = 0x821B14A0; continue 'dispatch;
	}
	// 821B149C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B14A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B14A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B14A8: 419A0038  beq cr6, 0x821b14e0
	if ctx.cr[6].eq {
	pc = 0x821B14E0; continue 'dispatch;
	}
	// 821B14AC: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B14B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B14B4: EFC007F2  fmuls f30, f0, f31
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B14B8: 486A1D49  bl 0x82853200
	ctx.lr = 0x821B14BC;
	sub_82853200(ctx, base);
	// 821B14BC: EDA1F824  fdivs f13, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 / ctx.f[31].f64) as f32) as f64;
	// 821B14C0: C01AD5FC  lfs f0, -0x2a04(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10756 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B14C4: ED9E6828  fsubs f12, f30, f13
	ctx.f[12].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B14C8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 821B14CC: 41990014  bgt cr6, 0x821b14e0
	if ctx.cr[6].gt {
	pc = 0x821B14E0; continue 'dispatch;
	}
	// 821B14D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B14D4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821B14D8: 483F2EA9  bl 0x825a4380
	ctx.lr = 0x821B14DC;
	sub_825A4380(ctx, base);
	// 821B14DC: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821B14E0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B14E4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B14E8: 409A0008  bne cr6, 0x821b14f0
	if !ctx.cr[6].eq {
	pc = 0x821B14F0; continue 'dispatch;
	}
	// 821B14EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B14F0: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B14F4: 4BFFFEFC  b 0x821b13f0
	pc = 0x821B13F0; continue 'dispatch;
	// 821B14F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B14FC: 4BFE293D  bl 0x82193e38
	ctx.lr = 0x821B1500;
	sub_82193E38(ctx, base);
	// 821B1500: 4BFFFF68  b 0x821b1468
	pc = 0x821B1468; continue 'dispatch;
	// 821B1504: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B1508: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821B150C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821B1510: 48AF7F3C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1518 size=52
    let mut pc: u32 = 0x821B1518;
    'dispatch: loop {
        match pc {
            0x821B1518 => {
    //   block [0x821B1518..0x821B154C)
	// 821B1518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B151C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B1520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1524: 419A0018  beq cr6, 0x821b153c
	if ctx.cr[6].eq {
	pc = 0x821B153C; continue 'dispatch;
	}
	// 821B1528: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B152C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821B1530: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B1534: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B1538: 409A0008  bne cr6, 0x821b1540
	if !ctx.cr[6].eq {
	pc = 0x821B1540; continue 'dispatch;
	}
	// 821B153C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B1540: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B1544: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1548: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B154C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B154C size=64
    let mut pc: u32 = 0x821B154C;
    'dispatch: loop {
        match pc {
            0x821B154C => {
    //   block [0x821B154C..0x821B158C)
	// 821B154C: 892B0028  lbz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B1550: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B1554: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821B1558: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B155C: 419A00F4  beq cr6, 0x821b1650
	if ctx.cr[6].eq {
		sub_821B1650(ctx, base);
		return;
	}
	// 821B1560: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B1564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1568: 419A0024  beq cr6, 0x821b158c
	if ctx.cr[6].eq {
		sub_821B158C(ctx, base);
		return;
	}
	// 821B156C: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B1570: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B1574: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B1578: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B157C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1580: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B1584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1588: 480000CC  b 0x821b1654
	sub_821B1650(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B158C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B158C size=88
    let mut pc: u32 = 0x821B158C;
    'dispatch: loop {
        match pc {
            0x821B158C => {
    //   block [0x821B158C..0x821B15E4)
	// 821B158C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B1590: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B1594: 9061FFF0  stw r3, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[3].u32 ) };
	// 821B1598: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B159C: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821B15A0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B15A4: 40810054  ble 0x821b15f8
	if !ctx.cr[0].gt {
		sub_821B15E4(ctx, base);
		return;
	}
	// 821B15A8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B15AC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B15B0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B15B4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B15B8: 2F070038  cmpwi cr6, r7, 0x38
	ctx.cr[6].compare_i32(ctx.r[7].s32, 56, &mut ctx.xer);
	// 821B15BC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B15C0: 41980008  blt cr6, 0x821b15c8
	if ctx.cr[6].lt {
	pc = 0x821B15C8; continue 'dispatch;
	}
	// 821B15C4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821B15C8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B15CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B15D0: 419A0014  beq cr6, 0x821b15e4
	if ctx.cr[6].eq {
		sub_821B15E4(ctx, base);
		return;
	}
	// 821B15D4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B15D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B15DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B15E0: 4800000C  b 0x821b15ec
	sub_821B15E4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B15E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B15E4 size=88
    let mut pc: u32 = 0x821B15E4;
    'dispatch: loop {
        match pc {
            0x821B15E4 => {
    //   block [0x821B15E4..0x821B163C)
	// 821B15E4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B15E8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B15EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B15F0: 4199FFB8  bgt cr6, 0x821b15a8
	if ctx.cr[6].gt {
		sub_821B158C(ctx, base);
		return;
	}
	// 821B15F4: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821B15F8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B15FC: 419A0040  beq cr6, 0x821b163c
	if ctx.cr[6].eq {
		sub_821B163C(ctx, base);
		return;
	}
	// 821B1600: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1604: 2F0B0038  cmpwi cr6, r11, 0x38
	ctx.cr[6].compare_i32(ctx.r[11].s32, 56, &mut ctx.xer);
	// 821B1608: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B160C: 41990008  bgt cr6, 0x821b1614
	if ctx.cr[6].gt {
	pc = 0x821B1614; continue 'dispatch;
	}
	// 821B1610: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B1614: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B161C: 409A0020  bne cr6, 0x821b163c
	if !ctx.cr[6].eq {
		sub_821B163C(ctx, base);
		return;
	}
	// 821B1620: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1624: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821B1628: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821B162C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1630: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B1634: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1638: 4800001C  b 0x821b1654
	sub_821B1650(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B163C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B163C size=20
    let mut pc: u32 = 0x821B163C;
    'dispatch: loop {
        match pc {
            0x821B163C => {
    //   block [0x821B163C..0x821B1650)
	// 821B163C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B1640: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1644: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B1648: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B164C: 48000008  b 0x821b1654
	sub_821B1650(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1650 size=16
    let mut pc: u32 = 0x821B1650;
    'dispatch: loop {
        match pc {
            0x821B1650 => {
    //   block [0x821B1650..0x821B1660)
	// 821B1650: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B1654: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B165C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1660 size=12
    let mut pc: u32 = 0x821B1660;
    'dispatch: loop {
        match pc {
            0x821B1660 => {
    //   block [0x821B1660..0x821B166C)
	// 821B1660: 816A01E0  lwz r11, 0x1e0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(480 as u32) ) } as u64;
	// 821B1664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1668: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B166C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B166C size=12
    let mut pc: u32 = 0x821B166C;
    'dispatch: loop {
        match pc {
            0x821B166C => {
    //   block [0x821B166C..0x821B1678)
	// 821B166C: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821B1670: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1674: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1678 size=8
    let mut pc: u32 = 0x821B1678;
    'dispatch: loop {
        match pc {
            0x821B1678 => {
    //   block [0x821B1678..0x821B1680)
	// 821B1678: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821B167C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1680 size=120
    let mut pc: u32 = 0x821B1680;
    'dispatch: loop {
        match pc {
            0x821B1680 => {
    //   block [0x821B1680..0x821B16F8)
	// 821B1680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1688: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B168C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B1694: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B1698: 394B0624  addi r10, r11, 0x624
	ctx.r[10].s64 = ctx.r[11].s64 + 1572;
	// 821B169C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B16A0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B16A4: 55690000  rlwinm r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B16A8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B16AC: 409A002C  bne cr6, 0x821b16d8
	if !ctx.cr[6].eq {
	pc = 0x821B16D8; continue 'dispatch;
	}
	// 821B16B0: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821B16B4: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16B8: 556B087C  rlwinm r11, r11, 1, 1, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 821B16BC: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B16C0: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 821B16C4: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16C8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 821B16CC: 54E52834  slwi r5, r7, 5
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821B16D0: 7C68482E  lwzx r3, r8, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B16D4: 48BA3BF5  bl 0x82d552c8
	ctx.lr = 0x821B16D8;
	sub_82D552C8(ctx, base);
	// 821B16D8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 821B16DC: 394B2B14  addi r10, r11, 0x2b14
	ctx.r[10].s64 = ctx.r[11].s64 + 11028;
	// 821B16E0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B16E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B16E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B16EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B16F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B16F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B16F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B16F8 size=604
    let mut pc: u32 = 0x821B16F8;
    'dispatch: loop {
        match pc {
            0x821B16F8 => {
    //   block [0x821B16F8..0x821B1954)
	// 821B16F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B16FC: 48AF7D11  bl 0x82ca940c
	ctx.lr = 0x821B1700;
	sub_82CA93D0(ctx, base);
	// 821B1700: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B1708: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1958 size=144
    let mut pc: u32 = 0x821B1958;
    'dispatch: loop {
        match pc {
            0x821B1958 => {
    //   block [0x821B1958..0x821B19E8)
	// 821B1958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B195C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1960: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1964: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1968: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B196C: D0210074  stfs f1, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B1970: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B1974: 392BAD50  addi r9, r11, -0x52b0
	ctx.r[9].s64 = ctx.r[11].s64 + -21168;
	// 821B1978: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 821B197C: 3BEA91A0  addi r31, r10, -0x6e60
	ctx.r[31].s64 = ctx.r[10].s64 + -28256;
	// 821B1980: 39010074  addi r8, r1, 0x74
	ctx.r[8].s64 = ctx.r[1].s64 + 116;
	// 821B1984: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821B1988: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B19E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B19E8 size=64
    let mut pc: u32 = 0x821B19E8;
    'dispatch: loop {
        match pc {
            0x821B19E8 => {
    //   block [0x821B19E8..0x821B1A28)
	// 821B19E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B19EC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B19F0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821B19F4: 7D671670  srawi r7, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821B19F8: 790AFFE6  rldicr r10, r8, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B19FC: 7CC70194  addze r6, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[6].s64 = tmp.s64;
	// 821B1A00: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821B1A04: 7CC407B4  extsw r4, r6
	ctx.r[4].s64 = ctx.r[6].s32 as i64;
	// 821B1A08: E9291760  ld r9, 0x1760(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5984 as u32) ) };
	// 821B1A0C: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821B1A10: 7D472436  srd r7, r10, r4
	if (ctx.r[4].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[4].u8 & 0x3F) as u32);
	}
	// 821B1A14: 7CE64838  and r6, r7, r9
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[9].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B1A28 size=96
    let mut pc: u32 = 0x821B1A28;
    'dispatch: loop {
        match pc {
            0x821B1A28 => {
    //   block [0x821B1A28..0x821B1A88)
	// 821B1A28: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 821B1A2C: C001FFF0  lfs f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1A30: 5567F0BE  srwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B1A34: C1A1FFF4  lfs f13, -0xc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B1A38: 38CB0078  addi r6, r11, 0x78
	ctx.r[6].s64 = ctx.r[11].s64 + 120;
	// 821B1A3C: C181FFF8  lfs f12, -8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B1A40: 55692036  slwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B1A44: C161FFFC  lfs f11, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B1A48: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 821B1A4C: 81680364  lwz r11, 0x364(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B1A50: 54C42036  slwi r4, r6, 4
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B1A54: 7C673850  subf r3, r7, r7
	ctx.r[3].s64 = ctx.r[7].s64 - ctx.r[7].s64;
	// 821B1A58: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821B1A5C: D16A078C  stfs f11, 0x78c(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1932 as u32), tmp.u32 ) };
	// 821B1A60: D1AA0784  stfs f13, 0x784(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1924 as u32), tmp.u32 ) };
	// 821B1A64: 78690020  clrldi r9, r3, 0x20
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 821B1A68: 7C045D2E  stfsx f0, r4, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821B1A6C: 7CA84E34  srad r8, r5, r9
	tmp.u64 = (ctx.r[9].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[5].s64 < 0) && ((ctx.r[5].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[8].s64 = ctx.r[5].s64 >> tmp.u64;
	// 821B1A70: D18A0788  stfs f12, 0x788(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1928 as u32), tmp.u32 ) };
	// 821B1A74: 7D073C36  srd r7, r8, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[8].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 821B1A78: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B1A7C: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 821B1A80: F8AB0000  std r5, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 821B1A84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1A88 size=124
    let mut pc: u32 = 0x821B1A88;
    'dispatch: loop {
        match pc {
            0x821B1A88 => {
    //   block [0x821B1A88..0x821B1B04)
	// 821B1A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1A94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1A98: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B1A9C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821B1AA0: 392BAD50  addi r9, r11, -0x52b0
	ctx.r[9].s64 = ctx.r[11].s64 + -21168;
	// 821B1AA4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821B1AA8: 3BE89160  addi r31, r8, -0x6ea0
	ctx.r[31].s64 = ctx.r[8].s64 + -28320;
	// 821B1AAC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 821B1AB0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B1B08 size=64
    let mut pc: u32 = 0x821B1B08;
    'dispatch: loop {
        match pc {
            0x821B1B08 => {
    //   block [0x821B1B08..0x821B1B48)
	// 821B1B08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1B0C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B1B10: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821B1B14: 7D671670  srawi r7, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821B1B18: 790AFFE6  rldicr r10, r8, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B1B1C: 7CC70194  addze r6, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[6].s64 = tmp.s64;
	// 821B1B20: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821B1B24: 7CC407B4  extsw r4, r6
	ctx.r[4].s64 = ctx.r[6].s32 as i64;
	// 821B1B28: E9291758  ld r9, 0x1758(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5976 as u32) ) };
	// 821B1B2C: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821B1B30: 7D472436  srd r7, r10, r4
	if (ctx.r[4].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[4].u8 & 0x3F) as u32);
	}
	// 821B1B34: 7CE64838  and r6, r7, r9
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[9].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B1B48 size=96
    let mut pc: u32 = 0x821B1B48;
    'dispatch: loop {
        match pc {
            0x821B1B48 => {
    //   block [0x821B1B48..0x821B1BA8)
	// 821B1B48: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 821B1B4C: C001FFF0  lfs f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1B50: 5567F0BE  srwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B1B54: C1A1FFF4  lfs f13, -0xc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B1B58: 38CB0178  addi r6, r11, 0x178
	ctx.r[6].s64 = ctx.r[11].s64 + 376;
	// 821B1B5C: C181FFF8  lfs f12, -8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B1B60: 55692036  slwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B1B64: C161FFFC  lfs f11, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B1B68: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 821B1B6C: 81680364  lwz r11, 0x364(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B1B70: 54C42036  slwi r4, r6, 4
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B1B74: 7C673850  subf r3, r7, r7
	ctx.r[3].s64 = ctx.r[7].s64 - ctx.r[7].s64;
	// 821B1B78: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821B1B7C: D16A178C  stfs f11, 0x178c(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6028 as u32), tmp.u32 ) };
	// 821B1B80: D1AA1784  stfs f13, 0x1784(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6020 as u32), tmp.u32 ) };
	// 821B1B84: 78690020  clrldi r9, r3, 0x20
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 821B1B88: 7C045D2E  stfsx f0, r4, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821B1B8C: 7CA84E34  srad r8, r5, r9
	tmp.u64 = (ctx.r[9].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[5].s64 < 0) && ((ctx.r[5].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[8].s64 = ctx.r[5].s64 >> tmp.u64;
	// 821B1B90: D18A1788  stfs f12, 0x1788(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6024 as u32), tmp.u32 ) };
	// 821B1B94: 7D073C36  srd r7, r8, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[8].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 821B1B98: E8CB0008  ld r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B1B9C: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 821B1BA0: F8AB0008  std r5, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821B1BA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1BA8 size=112
    let mut pc: u32 = 0x821B1BA8;
    'dispatch: loop {
        match pc {
            0x821B1BA8 => {
    //   block [0x821B1BA8..0x821B1C18)
	// 821B1BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1BB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B1BB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1BB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1BBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B1BC0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1BC4: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1BC8: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821B1BCC: 40990010  ble cr6, 0x821b1bdc
	if !ctx.cr[6].gt {
	pc = 0x821B1BDC; continue 'dispatch;
	}
	// 821B1BD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1BD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1BD8: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821B1BDC: 419A0024  beq cr6, 0x821b1c00
	if ctx.cr[6].eq {
	pc = 0x821B1C00; continue 'dispatch;
	}
	// 821B1BE0: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821B1BE4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1BE8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821B1BEC: 7FE61A14  add r31, r6, r3
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821B1BF0: 4081000C  ble 0x821b1bfc
	if !ctx.cr[0].gt {
	pc = 0x821B1BFC; continue 'dispatch;
	}
	// 821B1BF4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821B1BF8: 48AF8431  bl 0x82caa028
	ctx.lr = 0x821B1BFC;
	sub_82CAA028(ctx, base);
	// 821B1BFC: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 821B1C00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B1C04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1C08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1C0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B1C10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1C14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1C18 size=208
    let mut pc: u32 = 0x821B1C18;
    'dispatch: loop {
        match pc {
            0x821B1C18 => {
    //   block [0x821B1C18..0x821B1CE8)
	// 821B1C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1C1C: 48AF77E9  bl 0x82ca9404
	ctx.lr = 0x821B1C20;
	sub_82CA93D0(ctx, base);
	// 821B1C20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1C24: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B1C28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B1C2C: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B1C30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1C34: 40990050  ble cr6, 0x821b1c84
	if !ctx.cr[6].gt {
	pc = 0x821B1C84; continue 'dispatch;
	}
	// 821B1C38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1C3C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821B1C40: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821B1C44: 797DFFE6  rldicr r29, r11, 0x3f, 0x3f
	ctx.r[29].u64 = (ctx.r[11].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B1C48: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B1C4C: 41980024  blt cr6, 0x821b1c70
	if ctx.cr[6].lt {
	pc = 0x821B1C70; continue 'dispatch;
	}
	// 821B1C50: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821B1C54: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1C58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B1C5C: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B1C60: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821B1C64: 7FA64C36  srd r6, r29, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821B1C68: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1C6C: 48005275  bl 0x821b6ee0
	ctx.lr = 0x821B1C70;
	sub_821B6EE0(ctx, base);
	// 821B1C70: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B1C74: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B1C78: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B1C7C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B1C80: 4198FFC8  blt cr6, 0x821b1c48
	if ctx.cr[6].lt {
	pc = 0x821B1C48; continue 'dispatch;
	}
	// 821B1C84: 897C0084  lbz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B1C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1C8C: 419A0028  beq cr6, 0x821b1cb4
	if ctx.cr[6].eq {
	pc = 0x821B1CB4; continue 'dispatch;
	}
	// 821B1C90: 38DC0010  addi r6, r28, 0x10
	ctx.r[6].s64 = ctx.r[28].s64 + 16;
	// 821B1C94: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B1C98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B1C9C: 38600102  li r3, 0x102
	ctx.r[3].s64 = 258;
	// 821B1CA0: 489D2949  bl 0x82b845e8
	ctx.lr = 0x821B1CA4;
	sub_82B845E8(ctx, base);
	// 821B1CA4: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 821B1CA8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1CE8 size=1272
    let mut pc: u32 = 0x821B1CE8;
    'dispatch: loop {
        match pc {
            0x821B1CE8 => {
    //   block [0x821B1CE8..0x821B21E0)
	// 821B1CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1CEC: 48AF771D  bl 0x82ca9408
	ctx.lr = 0x821B1CF0;
	sub_82CA93D0(ctx, base);
	// 821B1CF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1CF4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B1CF8: 3BFC0014  addi r31, r28, 0x14
	ctx.r[31].s64 = ctx.r[28].s64 + 20;
	// 821B1CFC: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B1D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1D04: 419A0038  beq cr6, 0x821b1d3c
	if ctx.cr[6].eq {
	pc = 0x821B1D3C; continue 'dispatch;
	}
	// 821B1D08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1D0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1D10: 419A0078  beq cr6, 0x821b1d88
	if ctx.cr[6].eq {
	pc = 0x821B1D88; continue 'dispatch;
	}
	// 821B1D14: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1D1C: 419A0020  beq cr6, 0x821b1d3c
	if ctx.cr[6].eq {
	pc = 0x821B1D3C; continue 'dispatch;
	}
	// 821B1D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B1D24: 4BFC2115  bl 0x82173e38
	ctx.lr = 0x821B1D28;
	sub_82173E38(ctx, base);
	// 821B1D28: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B1D2C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B1D30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1D34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1D38: 409A0008  bne cr6, 0x821b1d40
	if !ctx.cr[6].eq {
	pc = 0x821B1D40; continue 'dispatch;
	}
	// 821B1D3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1D40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1D48: 419A0490  beq cr6, 0x821b21d8
	if ctx.cr[6].eq {
	pc = 0x821B21D8; continue 'dispatch;
	}
	// 821B1D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B1D50: 4BFC20E9  bl 0x82173e38
	ctx.lr = 0x821B1D54;
	sub_82173E38(ctx, base);
	// 821B1D54: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B1D58: 556AB7FE  rlwinm r10, r11, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 821B1D5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1D60: 419A0478  beq cr6, 0x821b21d8
	if ctx.cr[6].eq {
	pc = 0x821B21D8; continue 'dispatch;
	}
	// 821B1D64: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B1D68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1D6C: 419A0028  beq cr6, 0x821b1d94
	if ctx.cr[6].eq {
	pc = 0x821B1D94; continue 'dispatch;
	}
	// 821B1D70: 894B00AA  lbz r10, 0xaa(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(170 as u32) ) } as u64;
	// 821B1D74: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B1D78: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B1D7C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B1D80: 83A90004  lwz r29, 4(r9)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1D84: 480000C0  b 0x821b1e44
	pc = 0x821B1E44; continue 'dispatch;
	// 821B1D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B1D8C: 4BFE20AD  bl 0x82193e38
	ctx.lr = 0x821B1D90;
	sub_82193E38(ctx, base);
	// 821B1D90: 4BFFFFAC  b 0x821b1d3c
	pc = 0x821B1D3C; continue 'dispatch;
	// 821B1D94: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B1D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1D9C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B1DA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B1DA4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B1DA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B1DAC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1DB0: 40810054  ble 0x821b1e04
	if !ctx.cr[0].gt {
	pc = 0x821B1E04; continue 'dispatch;
	}
	// 821B1DB4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B1DB8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B1DBC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B1DC0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1DC4: 2F0700AA  cmpwi cr6, r7, 0xaa
	ctx.cr[6].compare_i32(ctx.r[7].s32, 170, &mut ctx.xer);
	// 821B1DC8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B1DCC: 41980008  blt cr6, 0x821b1dd4
	if ctx.cr[6].lt {
	pc = 0x821B1DD4; continue 'dispatch;
	}
	// 821B1DD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B1DD4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B1DD8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B1DDC: 419A0014  beq cr6, 0x821b1df0
	if ctx.cr[6].eq {
	pc = 0x821B1DF0; continue 'dispatch;
	}
	// 821B1DE0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B1DE4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B1DE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B1DEC: 4800000C  b 0x821b1df8
	pc = 0x821B1DF8; continue 'dispatch;
	// 821B1DF0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B1DF4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B1DF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1DFC: 4199FFB8  bgt cr6, 0x821b1db4
	if ctx.cr[6].gt {
	pc = 0x821B1DB4; continue 'dispatch;
	}
	// 821B1E00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B1E04: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B1E08: 419A0034  beq cr6, 0x821b1e3c
	if ctx.cr[6].eq {
	pc = 0x821B1E3C; continue 'dispatch;
	}
	// 821B1E0C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1E10: 2F0B00AA  cmpwi cr6, r11, 0xaa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 170, &mut ctx.xer);
	// 821B1E14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1E18: 41990008  bgt cr6, 0x821b1e20
	if ctx.cr[6].gt {
	pc = 0x821B1E20; continue 'dispatch;
	}
	// 821B1E1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1E20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1E24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1E28: 409A0014  bne cr6, 0x821b1e3c
	if !ctx.cr[6].eq {
	pc = 0x821B1E3C; continue 'dispatch;
	}
	// 821B1E2C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1E30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B1E34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B1E38: 48000008  b 0x821b1e40
	pc = 0x821B1E40; continue 'dispatch;
	// 821B1E3C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B1E40: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1E44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B1E48: 419A0390  beq cr6, 0x821b21d8
	if ctx.cr[6].eq {
	pc = 0x821B21D8; continue 'dispatch;
	}
	// 821B1E4C: 817C00C4  lwz r11, 0xc4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(196 as u32) ) } as u64;
	// 821B1E50: 3BFC00C0  addi r31, r28, 0xc0
	ctx.r[31].s64 = ctx.r[28].s64 + 192;
	// 821B1E54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1E58: 419A00D4  beq cr6, 0x821b1f2c
	if ctx.cr[6].eq {
	pc = 0x821B1F2C; continue 'dispatch;
	}
	// 821B1E5C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1E60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B1E64: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1E68: 418200C4  beq 0x821b1f2c
	if ctx.cr[0].eq {
	pc = 0x821B1F2C; continue 'dispatch;
	}
	// 821B1E6C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1E70: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1E74: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1E78: 40990008  ble cr6, 0x821b1e80
	if !ctx.cr[6].gt {
	pc = 0x821B1E80; continue 'dispatch;
	}
	// 821B1E7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1E80: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821B1E84: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B1E88: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821B1E8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1E90: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1E94: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1E98: 40990008  ble cr6, 0x821b1ea0
	if !ctx.cr[6].gt {
	pc = 0x821B1EA0; continue 'dispatch;
	}
	// 821B1E9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1EA0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B1EA4: 419A000C  beq cr6, 0x821b1eb0
	if ctx.cr[6].eq {
	pc = 0x821B1EB0; continue 'dispatch;
	}
	// 821B1EA8: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B1EAC: 419A0008  beq cr6, 0x821b1eb4
	if ctx.cr[6].eq {
	pc = 0x821B1EB4; continue 'dispatch;
	}
	// 821B1EB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1EB4: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1EB8: 419A0074  beq cr6, 0x821b1f2c
	if ctx.cr[6].eq {
	pc = 0x821B1F2C; continue 'dispatch;
	}
	// 821B1EBC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B1EC0: 409A0008  bne cr6, 0x821b1ec8
	if !ctx.cr[6].eq {
	pc = 0x821B1EC8; continue 'dispatch;
	}
	// 821B1EC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1EC8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1ECC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1ED0: 41980008  blt cr6, 0x821b1ed8
	if ctx.cr[6].lt {
	pc = 0x821B1ED8; continue 'dispatch;
	}
	// 821B1ED4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1ED8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B1EDC: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1EE0: 48619BF1  bl 0x827cbad0
	ctx.lr = 0x821B1EE4;
	sub_827CBAD0(ctx, base);
	// 821B1EE4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B1EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1EEC: 409A0028  bne cr6, 0x821b1f14
	if !ctx.cr[6].eq {
	pc = 0x821B1F14; continue 'dispatch;
	}
	// 821B1EF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B1EF4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1EF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B1EFC: 4816F19D  bl 0x82321098
	ctx.lr = 0x821B1F00;
	sub_82321098(ctx, base);
	// 821B1F00: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B1F04: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B1F08: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B1F0C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B1F10: 4BFFFF7C  b 0x821b1e8c
	pc = 0x821B1E8C; continue 'dispatch;
	// 821B1F14: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1F18: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1F1C: 41980008  blt cr6, 0x821b1f24
	if ctx.cr[6].lt {
	pc = 0x821B1F24; continue 'dispatch;
	}
	// 821B1F20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1F24: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B1F28: 4BFFFF60  b 0x821b1e88
	pc = 0x821B1E88; continue 'dispatch;
	// 821B1F2C: 817C00D4  lwz r11, 0xd4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(212 as u32) ) } as u64;
	// 821B1F30: 3BFC00D0  addi r31, r28, 0xd0
	ctx.r[31].s64 = ctx.r[28].s64 + 208;
	// 821B1F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1F38: 419A00D4  beq cr6, 0x821b200c
	if ctx.cr[6].eq {
	pc = 0x821B200C; continue 'dispatch;
	}
	// 821B1F3C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1F40: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B1F44: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1F48: 418200C4  beq 0x821b200c
	if ctx.cr[0].eq {
	pc = 0x821B200C; continue 'dispatch;
	}
	// 821B1F4C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1F50: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1F54: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1F58: 40990008  ble cr6, 0x821b1f60
	if !ctx.cr[6].gt {
	pc = 0x821B1F60; continue 'dispatch;
	}
	// 821B1F5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1F60: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821B1F64: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B1F68: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821B1F6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1F70: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1F74: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1F78: 40990008  ble cr6, 0x821b1f80
	if !ctx.cr[6].gt {
	pc = 0x821B1F80; continue 'dispatch;
	}
	// 821B1F7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1F80: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B1F84: 419A000C  beq cr6, 0x821b1f90
	if ctx.cr[6].eq {
	pc = 0x821B1F90; continue 'dispatch;
	}
	// 821B1F88: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B1F8C: 419A0008  beq cr6, 0x821b1f94
	if ctx.cr[6].eq {
	pc = 0x821B1F94; continue 'dispatch;
	}
	// 821B1F90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1F94: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1F98: 419A0074  beq cr6, 0x821b200c
	if ctx.cr[6].eq {
	pc = 0x821B200C; continue 'dispatch;
	}
	// 821B1F9C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B1FA0: 409A0008  bne cr6, 0x821b1fa8
	if !ctx.cr[6].eq {
	pc = 0x821B1FA8; continue 'dispatch;
	}
	// 821B1FA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1FA8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1FAC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1FB0: 41980008  blt cr6, 0x821b1fb8
	if ctx.cr[6].lt {
	pc = 0x821B1FB8; continue 'dispatch;
	}
	// 821B1FB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B1FB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B1FBC: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1FC0: 48619B11  bl 0x827cbad0
	ctx.lr = 0x821B1FC4;
	sub_827CBAD0(ctx, base);
	// 821B1FC4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B1FC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1FCC: 409A0028  bne cr6, 0x821b1ff4
	if !ctx.cr[6].eq {
	pc = 0x821B1FF4; continue 'dispatch;
	}
	// 821B1FD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B1FD4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1FD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B1FDC: 4816F0BD  bl 0x82321098
	ctx.lr = 0x821B1FE0;
	sub_82321098(ctx, base);
	// 821B1FE0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B1FE4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B1FE8: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B1FEC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B1FF0: 4BFFFF7C  b 0x821b1f6c
	pc = 0x821B1F6C; continue 'dispatch;
	// 821B1FF4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1FF8: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B1FFC: 41980008  blt cr6, 0x821b2004
	if ctx.cr[6].lt {
	pc = 0x821B2004; continue 'dispatch;
	}
	// 821B2000: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2004: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B2008: 4BFFFF60  b 0x821b1f68
	pc = 0x821B1F68; continue 'dispatch;
	// 821B200C: 817C00E4  lwz r11, 0xe4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 821B2010: 3BFC00E0  addi r31, r28, 0xe0
	ctx.r[31].s64 = ctx.r[28].s64 + 224;
	// 821B2014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B2018: 419A00D4  beq cr6, 0x821b20ec
	if ctx.cr[6].eq {
	pc = 0x821B20EC; continue 'dispatch;
	}
	// 821B201C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2020: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B2024: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B2028: 418200C4  beq 0x821b20ec
	if ctx.cr[0].eq {
	pc = 0x821B20EC; continue 'dispatch;
	}
	// 821B202C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2030: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B2034: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2038: 40990008  ble cr6, 0x821b2040
	if !ctx.cr[6].gt {
	pc = 0x821B2040; continue 'dispatch;
	}
	// 821B203C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2040: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821B2044: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B2048: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821B204C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2050: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2054: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2058: 40990008  ble cr6, 0x821b2060
	if !ctx.cr[6].gt {
	pc = 0x821B2060; continue 'dispatch;
	}
	// 821B205C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2060: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B2064: 419A000C  beq cr6, 0x821b2070
	if ctx.cr[6].eq {
	pc = 0x821B2070; continue 'dispatch;
	}
	// 821B2068: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B206C: 419A0008  beq cr6, 0x821b2074
	if ctx.cr[6].eq {
	pc = 0x821B2074; continue 'dispatch;
	}
	// 821B2070: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2074: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2078: 419A0074  beq cr6, 0x821b20ec
	if ctx.cr[6].eq {
	pc = 0x821B20EC; continue 'dispatch;
	}
	// 821B207C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B2080: 409A0008  bne cr6, 0x821b2088
	if !ctx.cr[6].eq {
	pc = 0x821B2088; continue 'dispatch;
	}
	// 821B2084: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2088: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B208C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2090: 41980008  blt cr6, 0x821b2098
	if ctx.cr[6].lt {
	pc = 0x821B2098; continue 'dispatch;
	}
	// 821B2094: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2098: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B209C: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B20A0: 48619A31  bl 0x827cbad0
	ctx.lr = 0x821B20A4;
	sub_827CBAD0(ctx, base);
	// 821B20A4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B20A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B20AC: 409A0028  bne cr6, 0x821b20d4
	if !ctx.cr[6].eq {
	pc = 0x821B20D4; continue 'dispatch;
	}
	// 821B20B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B20B4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B20B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B20BC: 4816EFDD  bl 0x82321098
	ctx.lr = 0x821B20C0;
	sub_82321098(ctx, base);
	// 821B20C0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B20C4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B20C8: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B20CC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B20D0: 4BFFFF7C  b 0x821b204c
	pc = 0x821B204C; continue 'dispatch;
	// 821B20D4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B20D8: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B20DC: 41980008  blt cr6, 0x821b20e4
	if ctx.cr[6].lt {
	pc = 0x821B20E4; continue 'dispatch;
	}
	// 821B20E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B20E4: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B20E8: 4BFFFF60  b 0x821b2048
	pc = 0x821B2048; continue 'dispatch;
	// 821B20EC: 817C00F4  lwz r11, 0xf4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(244 as u32) ) } as u64;
	// 821B20F0: 3BFC00F0  addi r31, r28, 0xf0
	ctx.r[31].s64 = ctx.r[28].s64 + 240;
	// 821B20F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B20F8: 419A00D4  beq cr6, 0x821b21cc
	if ctx.cr[6].eq {
	pc = 0x821B21CC; continue 'dispatch;
	}
	// 821B20FC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2100: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B2104: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B2108: 418200C4  beq 0x821b21cc
	if ctx.cr[0].eq {
	pc = 0x821B21CC; continue 'dispatch;
	}
	// 821B210C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2110: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B2114: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2118: 40990008  ble cr6, 0x821b2120
	if !ctx.cr[6].gt {
	pc = 0x821B2120; continue 'dispatch;
	}
	// 821B211C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2120: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821B2124: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B2128: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821B212C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2130: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2134: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2138: 40990008  ble cr6, 0x821b2140
	if !ctx.cr[6].gt {
	pc = 0x821B2140; continue 'dispatch;
	}
	// 821B213C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2140: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B2144: 419A000C  beq cr6, 0x821b2150
	if ctx.cr[6].eq {
	pc = 0x821B2150; continue 'dispatch;
	}
	// 821B2148: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B214C: 419A0008  beq cr6, 0x821b2154
	if ctx.cr[6].eq {
	pc = 0x821B2154; continue 'dispatch;
	}
	// 821B2150: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2154: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2158: 419A0074  beq cr6, 0x821b21cc
	if ctx.cr[6].eq {
	pc = 0x821B21CC; continue 'dispatch;
	}
	// 821B215C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B2160: 409A0008  bne cr6, 0x821b2168
	if !ctx.cr[6].eq {
	pc = 0x821B2168; continue 'dispatch;
	}
	// 821B2164: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2168: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B216C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B2170: 41980008  blt cr6, 0x821b2178
	if ctx.cr[6].lt {
	pc = 0x821B2178; continue 'dispatch;
	}
	// 821B2174: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2178: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B217C: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2180: 48619951  bl 0x827cbad0
	ctx.lr = 0x821B2184;
	sub_827CBAD0(ctx, base);
	// 821B2184: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B2188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B218C: 409A0028  bne cr6, 0x821b21b4
	if !ctx.cr[6].eq {
	pc = 0x821B21B4; continue 'dispatch;
	}
	// 821B2190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B2194: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B2198: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B219C: 4816EEFD  bl 0x82321098
	ctx.lr = 0x821B21A0;
	sub_82321098(ctx, base);
	// 821B21A0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B21A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B21A8: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B21AC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B21B0: 4BFFFF7C  b 0x821b212c
	pc = 0x821B212C; continue 'dispatch;
	// 821B21B4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B21B8: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B21BC: 41980008  blt cr6, 0x821b21c4
	if ctx.cr[6].lt {
	pc = 0x821B21C4; continue 'dispatch;
	}
	// 821B21C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B21C4: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B21C8: 4BFFFF60  b 0x821b2128
	pc = 0x821B2128; continue 'dispatch;
	// 821B21CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B21D0: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B21D4: 4BFE1675  bl 0x82193848
	ctx.lr = 0x821B21D8;
	sub_82193848(ctx, base);
	// 821B21D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B21DC: 48AF727C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B21E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B21E0 size=156
    let mut pc: u32 = 0x821B21E0;
    'dispatch: loop {
        match pc {
            0x821B21E0 => {
    //   block [0x821B21E0..0x821B227C)
	// 821B21E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B21E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B21E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B21EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B21F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B21F4: 897F0085  lbz r11, 0x85(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(133 as u32) ) } as u64;
	// 821B21F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B21FC: 419A0068  beq cr6, 0x821b2264
	if ctx.cr[6].eq {
	pc = 0x821B2264; continue 'dispatch;
	}
	// 821B2200: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B2208: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821B220C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2210: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B2214: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821B2218: 4E800421  bctrl
	ctx.lr = 0x821B221C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B221C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821B2220: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 821B2224: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B2228: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821B222C: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B2230: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B2234: 388690F0  addi r4, r6, -0x6f10
	ctx.r[4].s64 = ctx.r[6].s64 + -28432;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B2280 size=272
    let mut pc: u32 = 0x821B2280;
    'dispatch: loop {
        match pc {
            0x821B2280 => {
    //   block [0x821B2280..0x821B2390)
	// 821B2280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B2284: 48AF7189  bl 0x82ca940c
	ctx.lr = 0x821B2288;
	sub_82CA93D0(ctx, base);
	// 821B2288: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B228C: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821B2290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B2294: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B2298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B229C: 419A0074  beq cr6, 0x821b2310
	if ctx.cr[6].eq {
	pc = 0x821B2310; continue 'dispatch;
	}
	// 821B22A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B22A4: 481FE795  bl 0x823b0a38
	ctx.lr = 0x821B22A8;
	sub_823B0A38(ctx, base);
	// 821B22A8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821B22AC: 3BDF0070  addi r30, r31, 0x70
	ctx.r[30].s64 = ctx.r[31].s64 + 112;
	// 821B22B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B22B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B22B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B22BC: 481C31C5  bl 0x82375480
	ctx.lr = 0x821B22C0;
	sub_82375480(ctx, base);
	// 821B22C0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B22C4: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B22C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B22CC: 419A000C  beq cr6, 0x821b22d8
	if ctx.cr[6].eq {
	pc = 0x821B22D8; continue 'dispatch;
	}
	// 821B22D0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B22D4: 419A0008  beq cr6, 0x821b22dc
	if ctx.cr[6].eq {
	pc = 0x821B22DC; continue 'dispatch;
	}
	// 821B22D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B22DC: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B22E0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B22E4: 419A002C  beq cr6, 0x821b2310
	if ctx.cr[6].eq {
	pc = 0x821B2310; continue 'dispatch;
	}
	// 821B22E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B22EC: 409A0008  bne cr6, 0x821b22f4
	if !ctx.cr[6].eq {
	pc = 0x821B22F4; continue 'dispatch;
	}
	// 821B22F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B22F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B22F8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B22FC: 409A0008  bne cr6, 0x821b2304
	if !ctx.cr[6].eq {
	pc = 0x821B2304; continue 'dispatch;
	}
	// 821B2300: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2304: C0290010  lfs f1, 0x10(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B2308: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B230C: 48AF7150  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821B2310: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B2314: 481FE725  bl 0x823b0a38
	ctx.lr = 0x821B2318;
	sub_823B0A38(ctx, base);
	// 821B2318: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821B231C: 3BDF0064  addi r30, r31, 0x64
	ctx.r[30].s64 = ctx.r[31].s64 + 100;
	// 821B2320: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B2324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B2328: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B232C: 481C3155  bl 0x82375480
	ctx.lr = 0x821B2330;
	sub_82375480(ctx, base);
	// 821B2330: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B2334: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 821B2338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B233C: 419A000C  beq cr6, 0x821b2348
	if ctx.cr[6].eq {
	pc = 0x821B2348; continue 'dispatch;
	}
	// 821B2340: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B2344: 419A0008  beq cr6, 0x821b234c
	if ctx.cr[6].eq {
	pc = 0x821B234C; continue 'dispatch;
	}
	// 821B2348: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B234C: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B2350: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B2354: 419A002C  beq cr6, 0x821b2380
	if ctx.cr[6].eq {
	pc = 0x821B2380; continue 'dispatch;
	}
	// 821B2358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B235C: 409A0008  bne cr6, 0x821b2364
	if !ctx.cr[6].eq {
	pc = 0x821B2364; continue 'dispatch;
	}
	// 821B2360: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2364: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2368: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B236C: 409AFF98  bne cr6, 0x821b2304
	if !ctx.cr[6].eq {
	pc = 0x821B2304; continue 'dispatch;
	}
	// 821B2370: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B2374: C0290010  lfs f1, 0x10(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B2378: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B237C: 48AF70E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821B2380: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B2384: C02B9490  lfs f1, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B2388: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B238C: 48AF70D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B2390 size=116
    let mut pc: u32 = 0x821B2390;
    'dispatch: loop {
        match pc {
            0x821B2390 => {
    //   block [0x821B2390..0x821B2404)
	// 821B2390: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B2394: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B2398: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B239C: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B23A0: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B23A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B23A8: 419A0014  beq cr6, 0x821b23bc
	if ctx.cr[6].eq {
	pc = 0x821B23BC; continue 'dispatch;
	}
	// 821B23AC: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 821B23B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B23B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B23B8: 409A0008  bne cr6, 0x821b23c0
	if !ctx.cr[6].eq {
	pc = 0x821B23C0; continue 'dispatch;
	}
	// 821B23BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B23C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B23C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B23C8: 409A0118  bne cr6, 0x821b24e0
	if !ctx.cr[6].eq {
		sub_821B24E0(ctx, base);
		return;
	}
	// 821B23CC: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B23D0: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821B23D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B23D8: 419A00EC  beq cr6, 0x821b24c4
	if ctx.cr[6].eq {
		sub_821B24C4(ctx, base);
		return;
	}
	// 821B23DC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B23E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B23E4: 419A0020  beq cr6, 0x821b2404
	if ctx.cr[6].eq {
		sub_821B2404(ctx, base);
		return;
	}
	// 821B23E8: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 821B23EC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B23F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B23F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B23F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B23FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2400: 480000CC  b 0x821b24cc
	sub_821B24C4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2404(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B2404 size=92
    let mut pc: u32 = 0x821B2404;
    'dispatch: loop {
        match pc {
            0x821B2404 => {
    //   block [0x821B2404..0x821B2460)
	// 821B2404: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B2408: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B240C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B2410: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 821B2414: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B2418: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821B241C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B2420: 40810054  ble 0x821b2474
	if !ctx.cr[0].gt {
		sub_821B2460(ctx, base);
		return;
	}
	// 821B2424: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B2428: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B242C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B2430: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2434: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 821B2438: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B243C: 41980008  blt cr6, 0x821b2444
	if ctx.cr[6].lt {
	pc = 0x821B2444; continue 'dispatch;
	}
	// 821B2440: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B2444: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B2448: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B244C: 419A0014  beq cr6, 0x821b2460
	if ctx.cr[6].eq {
		sub_821B2460(ctx, base);
		return;
	}
	// 821B2450: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B2454: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B2458: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B245C: 4800000C  b 0x821b2468
	sub_821B2460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B2460 size=84
    let mut pc: u32 = 0x821B2460;
    'dispatch: loop {
        match pc {
            0x821B2460 => {
    //   block [0x821B2460..0x821B24B4)
	// 821B2460: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B2464: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B2468: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B246C: 4199FFB8  bgt cr6, 0x821b2424
	if ctx.cr[6].gt {
		sub_821B2404(ctx, base);
		return;
	}
	// 821B2470: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 821B2474: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B2478: 419A003C  beq cr6, 0x821b24b4
	if ctx.cr[6].eq {
		sub_821B24B4(ctx, base);
		return;
	}
	// 821B247C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2480: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 821B2484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B2488: 41990008  bgt cr6, 0x821b2490
	if ctx.cr[6].gt {
	pc = 0x821B2490; continue 'dispatch;
	}
	// 821B248C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B2490: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B2494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B2498: 409A001C  bne cr6, 0x821b24b4
	if !ctx.cr[6].eq {
		sub_821B24B4(ctx, base);
		return;
	}
	// 821B249C: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B24A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B24A4: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821B24A8: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821B24AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B24B0: 4800001C  b 0x821b24cc
	sub_821B24C4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B24B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B24B4 size=16
    let mut pc: u32 = 0x821B24B4;
    'dispatch: loop {
        match pc {
            0x821B24B4 => {
    //   block [0x821B24B4..0x821B24C4)
	// 821B24B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B24B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B24BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B24C0: 4800000C  b 0x821b24cc
	sub_821B24C4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B24C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B24C4 size=28
    let mut pc: u32 = 0x821B24C4;
    'dispatch: loop {
        match pc {
            0x821B24C4 => {
    //   block [0x821B24C4..0x821B24E0)
	// 821B24C4: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821B24C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B24CC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B24D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B24D4: 419A000C  beq cr6, 0x821b24e0
	if ctx.cr[6].eq {
		sub_821B24E0(ctx, base);
		return;
	}
	// 821B24D8: E86B0078  ld r3, 0x78(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	// 821B24DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B24E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B24E0 size=20
    let mut pc: u32 = 0x821B24E0;
    'dispatch: loop {
        match pc {
            0x821B24E0 => {
    //   block [0x821B24E0..0x821B24F4)
	// 821B24E0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B24E4: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B24E8: 796907E6  rldicr r9, r11, 0x20, 0x3f
	ctx.r[9].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 821B24EC: 7D235378  or r3, r9, r10
	ctx.r[3].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821B24F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B24F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B24F8 size=120
    let mut pc: u32 = 0x821B24F8;
    'dispatch: loop {
        match pc {
            0x821B24F8 => {
    //   block [0x821B24F8..0x821B2570)
	// 821B24F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B24FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B2500: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2504: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2508: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B250C: 419A0050  beq cr6, 0x821b255c
	if ctx.cr[6].eq {
	pc = 0x821B255C; continue 'dispatch;
	}
	// 821B2510: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B2518: 409A0044  bne cr6, 0x821b255c
	if !ctx.cr[6].eq {
	pc = 0x821B255C; continue 'dispatch;
	}
	// 821B251C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B2520: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B2524: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B2528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B252C: 409A0014  bne cr6, 0x821b2540
	if !ctx.cr[6].eq {
	pc = 0x821B2540; continue 'dispatch;
	}
	// 821B2530: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B2534: 816B6AC0  lwz r11, 0x6ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821B2538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B253C: 419A0024  beq cr6, 0x821b2560
	if ctx.cr[6].eq {
	pc = 0x821B2560; continue 'dispatch;
	}
	// 821B2540: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B2544: 806B6DA0  lwz r3, 0x6da0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821B2548: 48031D09  bl 0x821e4250
	ctx.lr = 0x821B254C;
	sub_821E4250(ctx, base);
	// 821B254C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B2550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B2554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B2558: 4E800020  blr
	return;
	// 821B255C: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2560: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B2564: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B2568: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B256C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B2570 size=136
    let mut pc: u32 = 0x821B2570;
    'dispatch: loop {
        match pc {
            0x821B2570 => {
    //   block [0x821B2570..0x821B25F8)
	// 821B2570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B2574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B2578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B257C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B2580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2584: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B2588: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B258C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2590: 7F1E2840  cmplw cr6, r30, r5
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821B2594: 40990048  ble cr6, 0x821b25dc
	if !ctx.cr[6].gt {
	pc = 0x821B25DC; continue 'dispatch;
	}
	// 821B2598: 2B1E0020  cmplwi cr6, r30, 0x20
	ctx.cr[6].compare_u32(ctx.r[30].u32, 32 as u32, &mut ctx.xer);
	// 821B259C: 40980008  bge cr6, 0x821b25a4
	if !ctx.cr[6].lt {
	pc = 0x821B25A4; continue 'dispatch;
	}
	// 821B25A0: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 821B25A4: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 821B25A8: 3940FFFD  li r10, -3
	ctx.r[10].s64 = -3;
	// 821B25AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B25B0: 41990014  bgt cr6, 0x821b25c4
	if ctx.cr[6].gt {
	pc = 0x821B25C4; continue 'dispatch;
	}
	// 821B25B4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821B25B8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B25BC: 48075265  bl 0x82227820
	ctx.lr = 0x821B25C0;
	sub_82227820(ctx, base);
	// 821B25C0: 48000014  b 0x821b25d4
	pc = 0x821B25D4; continue 'dispatch;
	// 821B25C4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821B25C8: 388B3AB8  addi r4, r11, 0x3ab8
	ctx.r[4].s64 = ctx.r[11].s64 + 15032;
	// 821B25CC: 4887F8DD  bl 0x82a31ea8
	ctx.lr = 0x821B25D0;
	sub_82A31EA8(ctx, base);
	// 821B25D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B25D4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B25D8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821B25DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B25E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B25E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B25E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B25EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B25F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B25F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B25F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B25F8 size=2628
    let mut pc: u32 = 0x821B25F8;
    'dispatch: loop {
        match pc {
            0x821B25F8 => {
    //   block [0x821B25F8..0x821B303C)
	// 821B25F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B25FC: 48AF6DE5  bl 0x82ca93e0
	ctx.lr = 0x821B2600;
	sub_82CA93D0(ctx, base);
	// 821B2600: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2604: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 821B2608: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B260C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B2610: 3AEB9490  addi r23, r11, -0x6b70
	ctx.r[23].s64 = ctx.r[11].s64 + -27504;
	// 821B2614: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 821B2618: 81740040  lwz r11, 0x40(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B261C: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 821B2620: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 821B2624: 3ACB0024  addi r22, r11, 0x24
	ctx.r[22].s64 = ctx.r[11].s64 + 36;
	// 821B2628: C017FFF4  lfs f0, -0xc(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B262C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 821B2630: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2634: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B2638: 41990008  bgt cr6, 0x821b2640
	if ctx.cr[6].gt {
	pc = 0x821B2640; continue 'dispatch;
	}
	// 821B263C: 7E589378  mr r24, r18
	ctx.r[24].u64 = ctx.r[18].u64;
	// 821B2640: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 821B2644: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 821B2648: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 821B264C: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 821B2650: 39010120  addi r8, r1, 0x120
	ctx.r[8].s64 = ctx.r[1].s64 + 288;
	// 821B2654: 92410130  stw r18, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[18].u32 ) };
	// 821B2658: 9A410134  stb r18, 0x134(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[18].u8 ) };
	// 821B265C: 388B0050  addi r4, r11, 0x50
	ctx.r[4].s64 = ctx.r[11].s64 + 80;
	// 821B2660: 1180030A  vcfux v12, v0, 0
	// vcfux/vcuxwfp128: ctx.v[12].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[12].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 821B2664: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3040 size=8
    let mut pc: u32 = 0x821B3040;
    'dispatch: loop {
        match pc {
            0x821B3040 => {
    //   block [0x821B3040..0x821B3048)
	// 821B3040: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821B3044: 480BFE34  b 0x82272e78
	sub_82272E78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3048 size=256
    let mut pc: u32 = 0x821B3048;
    'dispatch: loop {
        match pc {
            0x821B3048 => {
    //   block [0x821B3048..0x821B3148)
	// 821B3048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B304C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B3050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B3054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B3058: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B305C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3060: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B3064: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 821B3068: 3BDF018C  addi r30, r31, 0x18c
	ctx.r[30].s64 = ctx.r[31].s64 + 396;
	// 821B306C: C01F0188  lfs f0, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3070: C1BF018C  lfs f13, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3074: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B3078: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B307C: 4199000C  bgt cr6, 0x821b3088
	if ctx.cr[6].gt {
	pc = 0x821B3088; continue 'dispatch;
	}
	// 821B3080: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B3084: 48000010  b 0x821b3094
	pc = 0x821B3094; continue 'dispatch;
	// 821B3088: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B308C: EDAC0024  fdivs f13, f12, f0
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B3090: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B3094: C01F0184  lfs f0, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3098: 397F0184  addi r11, r31, 0x184
	ctx.r[11].s64 = ctx.r[31].s64 + 388;
	// 821B309C: C1BF0180  lfs f13, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B30A0: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B30A4: 395F0180  addi r10, r31, 0x180
	ctx.r[10].s64 = ctx.r[31].s64 + 384;
	// 821B30A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B30AC: 4199000C  bgt cr6, 0x821b30b8
	if ctx.cr[6].gt {
	pc = 0x821B30B8; continue 'dispatch;
	}
	// 821B30B0: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B30B4: 48000010  b 0x821b30c4
	pc = 0x821B30C4; continue 'dispatch;
	// 821B30B8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B30BC: EDAC0024  fdivs f13, f12, f0
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B30C0: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B30C4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B3148 size=3688
    let mut pc: u32 = 0x821B3148;
    'dispatch: loop {
        match pc {
            0x821B3148 => {
    //   block [0x821B3148..0x821B3520)
	// 821B3148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B314C: 48AF62A5  bl 0x82ca93f0
	ctx.lr = 0x821B3150;
	sub_82CA93D0(ctx, base);
	// 821B3150: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3154: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B3158: F8810120  std r4, 0x120(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[4].u64 ) };
	// 821B315C: F8A10128  std r5, 0x128(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[5].u64 ) };
	// 821B3160: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B3164: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821B3168: 419A0E3C  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B316C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B3170: 419A0E34  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B3174: 817D0100  lwz r11, 0x100(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(256 as u32) ) } as u64;
	// 821B3178: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821B317C: 419A0E28  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B3180: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 821B3184: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3188: 419A0E1C  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B318C: 81610120  lwz r11, 0x120(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) } as u64;
	// 821B3190: 81410124  lwz r10, 0x124(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 821B3194: 81210128  lwz r9, 0x128(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) } as u64;
	// 821B3198: 811D009C  lwz r8, 0x9c(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B319C: 917D0054  stw r11, 0x54(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B31A0: 2F08000A  cmpwi cr6, r8, 0xa
	ctx.cr[6].compare_i32(ctx.r[8].s32, 10, &mut ctx.xer);
	// 821B31A4: 915D0058  stw r10, 0x58(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821B31A8: 913D005C  stw r9, 0x5c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821B31AC: 419A0008  beq cr6, 0x821b31b4
	if ctx.cr[6].eq {
	pc = 0x821B31B4; continue 'dispatch;
	}
	// 821B31B0: 481469C1  bl 0x822f9b70
	ctx.lr = 0x821B31B4;
	sub_822F9B70(ctx, base);
	// 821B31B4: 897D006E  lbz r11, 0x6e(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(110 as u32) ) } as u64;
	// 821B31B8: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821B31BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B31C0: 419A0010  beq cr6, 0x821b31d0
	if ctx.cr[6].eq {
	pc = 0x821B31D0; continue 'dispatch;
	}
	// 821B31C4: 480B2EED  bl 0x822660b0
	ctx.lr = 0x821B31C8;
	sub_822660B0(ctx, base);
	// 821B31C8: 9AFD006E  stb r23, 0x6e(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(110 as u32), ctx.r[23].u8 ) };
	// 821B31CC: 48000008  b 0x821b31d4
	pc = 0x821B31D4; continue 'dispatch;
	// 821B31D0: 480B2EE1  bl 0x822660b0
	ctx.lr = 0x821B31D4;
	sub_822660B0(ctx, base);
	// 821B31D4: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 821B31D8: 907D0070  stw r3, 0x70(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 821B31DC: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 821B31E0: 81596AB8  lwz r10, 0x6ab8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B31E4: 89386A5E  lbz r9, 0x6a5e(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821B31E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B31EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B31F0: 409A0008  bne cr6, 0x821b31f8
	if !ctx.cr[6].eq {
	pc = 0x821B31F8; continue 'dispatch;
	}
	// 821B31F4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821B31F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B31FC: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 821B3200: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 821B3204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3208: 419A02CC  beq cr6, 0x821b34d4
	if ctx.cr[6].eq {
	pc = 0x821B34D4; continue 'dispatch;
	}
	// 821B320C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B3210: 890B0104  lbz r8, 0x104(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821B3214: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B3218: 409A02BC  bne cr6, 0x821b34d4
	if !ctx.cr[6].eq {
	pc = 0x821B34D4; continue 'dispatch;
	}
	// 821B321C: 92E10084  stw r23, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[23].u32 ) };
	// 821B3220: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821B3224: 92E10088  stw r23, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[23].u32 ) };
	// 821B3228: 38800058  li r4, 0x58
	ctx.r[4].s64 = 88;
	// 821B322C: 92E1008C  stw r23, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[23].u32 ) };
	// 821B3230: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B3234: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B3238: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B323C: 80DD01D8  lwz r6, 0x1d8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 821B3240: 80690010  lwz r3, 0x10(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3244: 48015FBD  bl 0x821c9200
	ctx.lr = 0x821B3248;
	sub_821C9200(ctx, base);
	// 821B3248: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B324C: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B3250: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3254: 40990008  ble cr6, 0x821b325c
	if !ctx.cr[6].gt {
	pc = 0x821B325C; continue 'dispatch;
	}
	// 821B3258: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B325C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B3260: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 821B3264: 3B8B72DC  addi r28, r11, 0x72dc
	ctx.r[28].s64 = ctx.r[11].s64 + 29404;
	// 821B3268: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B326C: 40990008  ble cr6, 0x821b3274
	if !ctx.cr[6].gt {
	pc = 0x821B3274; continue 'dispatch;
	}
	// 821B3270: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3274: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3278: 419A00F8  beq cr6, 0x821b3370
	if ctx.cr[6].eq {
	pc = 0x821B3370; continue 'dispatch;
	}
	// 821B327C: 41980008  blt cr6, 0x821b3284
	if ctx.cr[6].lt {
	pc = 0x821B3284; continue 'dispatch;
	}
	// 821B3280: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3284: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3288: 811D01D8  lwz r8, 0x1d8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 821B328C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B3290: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B3294: 409900C8  ble cr6, 0x821b335c
	if !ctx.cr[6].gt {
	pc = 0x821B335C; continue 'dispatch;
	}
	// 821B3298: 917D01D8  stw r11, 0x1d8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 821B329C: 3BDD0170  addi r30, r29, 0x170
	ctx.r[30].s64 = ctx.r[29].s64 + 368;
	// 821B32A0: 9AFD0221  stb r23, 0x221(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(545 as u32), ctx.r[23].u8 ) };
	// 821B32A4: 815D0174  lwz r10, 0x174(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(372 as u32) ) } as u64;
	// 821B32A8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B32AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B32B0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B32B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B32B8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B32BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B32C0: 419A000C  beq cr6, 0x821b32cc
	if ctx.cr[6].eq {
	pc = 0x821B32CC; continue 'dispatch;
	}
	// 821B32C4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B32C8: 419A0008  beq cr6, 0x821b32d0
	if ctx.cr[6].eq {
	pc = 0x821B32D0; continue 'dispatch;
	}
	// 821B32CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B32D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B32D4: 419A0080  beq cr6, 0x821b3354
	if ctx.cr[6].eq {
	pc = 0x821B3354; continue 'dispatch;
	}
	// 821B32D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B32DC: 409A0008  bne cr6, 0x821b32e4
	if !ctx.cr[6].eq {
	pc = 0x821B32E4; continue 'dispatch;
	}
	// 821B32E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B32E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B32E8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B32EC: 409A0008  bne cr6, 0x821b32f4
	if !ctx.cr[6].eq {
	pc = 0x821B32F4; continue 'dispatch;
	}
	// 821B32F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B32F4: 83EA0018  lwz r31, 0x18(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B32F8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B32FC: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 821B3300: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3304: E97F0078  ld r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	// 821B3308: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821B330C: 4814BB85  bl 0x822fee90
	ctx.lr = 0x821B3310;
	sub_822FEE90(ctx, base);
	// 821B3310: 3BFF006C  addi r31, r31, 0x6c
	ctx.r[31].s64 = ctx.r[31].s64 + 108;
	// 821B3314: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3318: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 821B331C: 419A0024  beq cr6, 0x821b3340
	if ctx.cr[6].eq {
	pc = 0x821B3340; continue 'dispatch;
	}
	// 821B3320: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3324: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B3328: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821B332C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B3330: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821B3334: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B3338: 488E4031  bl 0x82a97368
	ctx.lr = 0x821B333C;
	sub_82A97368(ctx, base);
	// 821B333C: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 821B3340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3344: 481617E5  bl 0x82314b28
	ctx.lr = 0x821B3348;
	sub_82314B28(ctx, base);
	// 821B3348: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B334C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B3350: 4BFFFF68  b 0x821b32b8
	pc = 0x821B32B8; continue 'dispatch;
	// 821B3354: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B3358: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B335C: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3360: 41980008  blt cr6, 0x821b3368
	if ctx.cr[6].lt {
	pc = 0x821B3368; continue 'dispatch;
	}
	// 821B3364: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3368: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821B336C: 4BFFFEFC  b 0x821b3268
	pc = 0x821B3268; continue 'dispatch;
	// 821B3370: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B3374: 4BFFE835  bl 0x821b1ba8
	ctx.lr = 0x821B3378;
	sub_821B1BA8(ctx, base);
	// 821B3378: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B337C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821B3380: 80DD01D8  lwz r6, 0x1d8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 821B3384: 38800059  li r4, 0x59
	ctx.r[4].s64 = 89;
	// 821B3388: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B338C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B3390: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3394: 80690010  lwz r3, 0x10(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3398: 48015E69  bl 0x821c9200
	ctx.lr = 0x821B339C;
	sub_821C9200(ctx, base);
	// 821B339C: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B33A0: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B33A4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B33A8: 40990008  ble cr6, 0x821b33b0
	if !ctx.cr[6].gt {
	pc = 0x821B33B0; continue 'dispatch;
	}
	// 821B33AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B33B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B33B4: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 821B33B8: 3B8B72E8  addi r28, r11, 0x72e8
	ctx.r[28].s64 = ctx.r[11].s64 + 29416;
	// 821B33BC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B33C0: 40990008  ble cr6, 0x821b33c8
	if !ctx.cr[6].gt {
	pc = 0x821B33C8; continue 'dispatch;
	}
	// 821B33C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B33C8: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B33CC: 419A00F8  beq cr6, 0x821b34c4
	if ctx.cr[6].eq {
	pc = 0x821B34C4; continue 'dispatch;
	}
	// 821B33D0: 41980008  blt cr6, 0x821b33d8
	if ctx.cr[6].lt {
	pc = 0x821B33D8; continue 'dispatch;
	}
	// 821B33D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B33D8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B33DC: 811D01D8  lwz r8, 0x1d8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) } as u64;
	// 821B33E0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B33E4: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B33E8: 409900C8  ble cr6, 0x821b34b0
	if !ctx.cr[6].gt {
	pc = 0x821B34B0; continue 'dispatch;
	}
	// 821B33EC: 917D01D8  stw r11, 0x1d8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 821B33F0: 3BDD0170  addi r30, r29, 0x170
	ctx.r[30].s64 = ctx.r[29].s64 + 368;
	// 821B33F4: 9ADD0221  stb r22, 0x221(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(545 as u32), ctx.r[22].u8 ) };
	// 821B33F8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B33FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B3400: 815D0174  lwz r10, 0x174(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(372 as u32) ) } as u64;
	// 821B3404: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3408: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B340C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3414: 419A000C  beq cr6, 0x821b3420
	if ctx.cr[6].eq {
	pc = 0x821B3420; continue 'dispatch;
	}
	// 821B3418: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B341C: 419A0008  beq cr6, 0x821b3424
	if ctx.cr[6].eq {
	pc = 0x821B3424; continue 'dispatch;
	}
	// 821B3420: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3424: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B3428: 419A0080  beq cr6, 0x821b34a8
	if ctx.cr[6].eq {
	pc = 0x821B34A8; continue 'dispatch;
	}
	// 821B342C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3430: 409A0008  bne cr6, 0x821b3438
	if !ctx.cr[6].eq {
	pc = 0x821B3438; continue 'dispatch;
	}
	// 821B3434: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3438: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B343C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3440: 409A0008  bne cr6, 0x821b3448
	if !ctx.cr[6].eq {
	pc = 0x821B3448; continue 'dispatch;
	}
	// 821B3444: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3448: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B344C: 815D0020  lwz r10, 0x20(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B3450: 812B0060  lwz r9, 0x60(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B3454: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3458: 409A003C  bne cr6, 0x821b3494
	if !ctx.cr[6].eq {
	pc = 0x821B3494; continue 'dispatch;
	}
	// 821B345C: E94B0078  ld r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	// 821B3460: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B3464: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 821B3468: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B346C: 3BEB0078  addi r31, r11, 0x78
	ctx.r[31].s64 = ctx.r[11].s64 + 120;
	// 821B3470: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 821B3474: 4814BA1D  bl 0x822fee90
	ctx.lr = 0x821B3478;
	sub_822FEE90(ctx, base);
	// 821B3478: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B347C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821B3480: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B3484: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B3488: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821B348C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B3490: 4814D689  bl 0x82300b18
	ctx.lr = 0x821B3494;
	sub_82300B18(ctx, base);
	// 821B3494: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3498: 48161691  bl 0x82314b28
	ctx.lr = 0x821B349C;
	sub_82314B28(ctx, base);
	// 821B349C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B34A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B34A4: 4BFFFF68  b 0x821b340c
	pc = 0x821B340C; continue 'dispatch;
	// 821B34A8: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B34AC: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B34B0: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B34B4: 41980008  blt cr6, 0x821b34bc
	if ctx.cr[6].lt {
	pc = 0x821B34BC; continue 'dispatch;
	}
	// 821B34B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B34BC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821B34C0: 4BFFFEFC  b 0x821b33bc
	pc = 0x821B33BC; continue 'dispatch;
	// 821B34C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B34C8: 48406A99  bl 0x825b9f60
	ctx.lr = 0x821B34CC;
	sub_825B9F60(ctx, base);
	// 821B34CC: 89386A5E  lbz r9, 0x6a5e(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821B34D0: 81596AB8  lwz r10, 0x6ab8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B34D4: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B34D8: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 821B34DC: 41990AAC  bgt cr6, 0x821b3f88
	if ctx.cr[6].gt {
	pc = 0x821B3F88; continue 'dispatch;
	}
	// 821B34E0: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821B34E4: 398C34F8  addi r12, r12, 0x34f8
	ctx.r[12].s64 = ctx.r[12].s64 + 13560;
	// 821B34E8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B34EC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B34F0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B34F4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821B3520; continue 'dispatch;
		},
		1 => {
	pc = 0x821B3678; continue 'dispatch;
		},
		2 => {
	pc = 0x821B3734; continue 'dispatch;
		},
		3 => {
	pc = 0x821B3598; continue 'dispatch;
		},
		4 => {
	pc = 0x821B37C8; continue 'dispatch;
		},
		5 => {
	pc = 0x821B39F8; continue 'dispatch;
		},
		6 => {
	pc = 0x821B3AC4; continue 'dispatch;
		},
		7 => {
	pc = 0x821B3B44; continue 'dispatch;
		},
		8 => {
	pc = 0x821B3D64; continue 'dispatch;
		},
		9 => {
	pc = 0x821B3F24; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B34F8: 821B3520  lwz r16, 0x3520(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13600 as u32) ) } as u64;
	// 821B34FC: 821B3678  lwz r16, 0x3678(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13944 as u32) ) } as u64;
	// 821B3500: 821B3734  lwz r16, 0x3734(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14132 as u32) ) } as u64;
	// 821B3504: 821B3598  lwz r16, 0x3598(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13720 as u32) ) } as u64;
	// 821B3508: 821B37C8  lwz r16, 0x37c8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14280 as u32) ) } as u64;
	// 821B350C: 821B39F8  lwz r16, 0x39f8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14840 as u32) ) } as u64;
	// 821B3510: 821B3AC4  lwz r16, 0x3ac4(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(15044 as u32) ) } as u64;
	// 821B3514: 821B3B44  lwz r16, 0x3b44(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(15172 as u32) ) } as u64;
	// 821B3518: 821B3D64  lwz r16, 0x3d64(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(15716 as u32) ) } as u64;
	// 821B351C: 821B3F24  lwz r16, 0x3f24(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16164 as u32) ) } as u64;
            }
            0x821B3520 => {
    //   block [0x821B3520..0x821B3598)
	// 821B3520: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3524: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3528: 419A0014  beq cr6, 0x821b353c
	if ctx.cr[6].eq {
	pc = 0x821B353C; continue 'dispatch;
	}
	// 821B352C: 92FD00A0  stw r23, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[23].u32 ) };
	// 821B3530: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3534: 386B1D08  addi r3, r11, 0x1d08
	ctx.r[3].s64 = ctx.r[11].s64 + 7432;
	// 821B3538: 4BFBFB39  bl 0x82173070
	ctx.lr = 0x821B353C;
	sub_82173070(ctx, base);
	// 821B353C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3540: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3544: 4814AA7D  bl 0x822fdfc0
	ctx.lr = 0x821B3548;
	sub_822FDFC0(ctx, base);
	// 821B3548: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B354C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3550: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3554: 419A015C  beq cr6, 0x821b36b0
	if ctx.cr[6].eq {
	pc = 0x821B36B0; continue 'dispatch;
	}
	// 821B3558: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B355C: 419A0030  beq cr6, 0x821b358c
	if ctx.cr[6].eq {
	pc = 0x821B358C; continue 'dispatch;
	}
	// 821B3560: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3564: 409A0020  bne cr6, 0x821b3584
	if !ctx.cr[6].eq {
	pc = 0x821B3584; continue 'dispatch;
	}
	// 821B3568: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B356C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3570: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3574: 48149C3D  bl 0x822fd1b0
	ctx.lr = 0x821B3578;
	sub_822FD1B0(ctx, base);
	// 821B3578: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B357C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3580: 48AF5EC0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3584: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821B3588: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821B358C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3590: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3594: 48AF5EAC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3598 => {
    //   block [0x821B3598..0x821B3678)
	// 821B3598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B359C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B35A0: 409A0008  bne cr6, 0x821b35a8
	if !ctx.cr[6].eq {
	pc = 0x821B35A8; continue 'dispatch;
	}
	// 821B35A4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821B35A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B35AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B35B0: 419A00BC  beq cr6, 0x821b366c
	if ctx.cr[6].eq {
	pc = 0x821B366C; continue 'dispatch;
	}
	// 821B35B4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B35B8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B35BC: 814B0138  lwz r10, 0x138(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(312 as u32) ) } as u64;
	// 821B35C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B35C4: 409900A8  ble cr6, 0x821b366c
	if !ctx.cr[6].gt {
	pc = 0x821B366C; continue 'dispatch;
	}
	// 821B35C8: 814B0134  lwz r10, 0x134(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(308 as u32) ) } as u64;
	// 821B35CC: 816B0130  lwz r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) } as u64;
	// 821B35D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B35D4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B35D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B35DC: 419A0020  beq cr6, 0x821b35fc
	if ctx.cr[6].eq {
	pc = 0x821B35FC; continue 'dispatch;
	}
	// 821B35E0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 821B35E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B35E8: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 821B35EC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821B35F0: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B35F4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B35F8: 4082FFE8  bne 0x821b35e0
	if !ctx.cr[0].eq {
	pc = 0x821B35E0; continue 'dispatch;
	}
	// 821B35FC: 894B504D  lbz r10, 0x504d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20557 as u32) ) } as u64;
	// 821B3600: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3604: 419A001C  beq cr6, 0x821b3620
	if ctx.cr[6].eq {
	pc = 0x821B3620; continue 'dispatch;
	}
	// 821B3608: 80AB5050  lwz r5, 0x5050(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20560 as u32) ) } as u64;
	// 821B360C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B3610: 419A0010  beq cr6, 0x821b3620
	if ctx.cr[6].eq {
	pc = 0x821B3620; continue 'dispatch;
	}
	// 821B3614: 388B4C4C  addi r4, r11, 0x4c4c
	ctx.r[4].s64 = ctx.r[11].s64 + 19532;
	// 821B3618: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B361C: 4814B345  bl 0x822fe960
	ctx.lr = 0x821B3620;
	sub_822FE960(ctx, base);
	// 821B3620: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3624: 48146FF5  bl 0x822fa618
	ctx.lr = 0x821B3628;
	sub_822FA618(ctx, base);
	// 821B3628: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B362C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B3630: 419A0034  beq cr6, 0x821b3664
	if ctx.cr[6].eq {
	pc = 0x821B3664; continue 'dispatch;
	}
	// 821B3634: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3638: 409A0028  bne cr6, 0x821b3660
	if !ctx.cr[6].eq {
	pc = 0x821B3660; continue 'dispatch;
	}
	// 821B363C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3640: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3644: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3648: 48149B69  bl 0x822fd1b0
	ctx.lr = 0x821B364C;
	sub_822FD1B0(ctx, base);
	// 821B364C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B3650: 480044C9  bl 0x821b7b18
	ctx.lr = 0x821B3654;
	sub_821B7B18(ctx, base);
	// 821B3654: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3658: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B365C: 48AF5DE4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3660: 92DD009C  stw r22, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[22].u32 ) };
	// 821B3664: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B3668: 480044B1  bl 0x821b7b18
	ctx.lr = 0x821B366C;
	sub_821B7B18(ctx, base);
	// 821B366C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3670: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3674: 48AF5DCC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3678 => {
    //   block [0x821B3678..0x821B3734)
	// 821B3678: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B367C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B3680: 419A0014  beq cr6, 0x821b3694
	if ctx.cr[6].eq {
	pc = 0x821B3694; continue 'dispatch;
	}
	// 821B3684: 92DD00A0  stw r22, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[22].u32 ) };
	// 821B3688: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B368C: 386B1D30  addi r3, r11, 0x1d30
	ctx.r[3].s64 = ctx.r[11].s64 + 7472;
	// 821B3690: 4BFBF9E1  bl 0x82173070
	ctx.lr = 0x821B3694;
	sub_82173070(ctx, base);
	// 821B3694: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3698: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B369C: 4814A925  bl 0x822fdfc0
	ctx.lr = 0x821B36A0;
	sub_822FDFC0(ctx, base);
	// 821B36A0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B36A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B36A8: 409A0020  bne cr6, 0x821b36c8
	if !ctx.cr[6].eq {
	pc = 0x821B36C8; continue 'dispatch;
	}
	// 821B36AC: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B36B0: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B36B4: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821B36B8: 419A08F0  beq cr6, 0x821b3fa8
	if ctx.cr[6].eq {
	pc = 0x821B3FA8; continue 'dispatch;
	}
	// 821B36BC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821B36C0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B36C4: 48AF5D7C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B36C8: 481201A1  bl 0x822d3868
	ctx.lr = 0x821B36CC;
	sub_822D3868(ctx, base);
	// 821B36CC: 89630007  lbz r11, 7(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(7 as u32) ) } as u64;
	// 821B36D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B36D4: 409A001C  bne cr6, 0x821b36f0
	if !ctx.cr[6].eq {
	pc = 0x821B36F0; continue 'dispatch;
	}
	// 821B36D8: 48120191  bl 0x822d3868
	ctx.lr = 0x821B36DC;
	sub_822D3868(ctx, base);
	// 821B36DC: 816300B4  lwz r11, 0xb4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B36E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B36E4: 4198000C  blt cr6, 0x821b36f0
	if ctx.cr[6].lt {
	pc = 0x821B36F0; continue 'dispatch;
	}
	// 821B36E8: 48120181  bl 0x822d3868
	ctx.lr = 0x821B36EC;
	sub_822D3868(ctx, base);
	// 821B36EC: 481A8F55  bl 0x8235c640
	ctx.lr = 0x821B36F0;
	sub_8235C640(ctx, base);
	// 821B36F0: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B36F4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B36F8: 419A0030  beq cr6, 0x821b3728
	if ctx.cr[6].eq {
	pc = 0x821B3728; continue 'dispatch;
	}
	// 821B36FC: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3700: 409A0020  bne cr6, 0x821b3720
	if !ctx.cr[6].eq {
	pc = 0x821B3720; continue 'dispatch;
	}
	// 821B3704: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3708: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B370C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3710: 48149AA1  bl 0x822fd1b0
	ctx.lr = 0x821B3714;
	sub_822FD1B0(ctx, base);
	// 821B3714: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3718: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B371C: 48AF5D24  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3720: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821B3724: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821B3728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B372C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3730: 48AF5D10  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3734 => {
    //   block [0x821B3734..0x821B37C8)
	// 821B3734: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3738: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B373C: 419A0018  beq cr6, 0x821b3754
	if ctx.cr[6].eq {
	pc = 0x821B3754; continue 'dispatch;
	}
	// 821B3740: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821B3744: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3748: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B374C: 386A1D5C  addi r3, r10, 0x1d5c
	ctx.r[3].s64 = ctx.r[10].s64 + 7516;
	// 821B3750: 4BFBF921  bl 0x82173070
	ctx.lr = 0x821B3754;
	sub_82173070(ctx, base);
	// 821B3754: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3758: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B375C: 4814A865  bl 0x822fdfc0
	ctx.lr = 0x821B3760;
	sub_822FDFC0(ctx, base);
	// 821B3760: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B3764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3768: 419AFF44  beq cr6, 0x821b36ac
	if ctx.cr[6].eq {
	pc = 0x821B36AC; continue 'dispatch;
	}
	// 821B376C: 481200FD  bl 0x822d3868
	ctx.lr = 0x821B3770;
	sub_822D3868(ctx, base);
	// 821B3770: 896300BA  lbz r11, 0xba(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(186 as u32) ) } as u64;
	// 821B3774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3778: 409A0028  bne cr6, 0x821b37a0
	if !ctx.cr[6].eq {
	pc = 0x821B37A0; continue 'dispatch;
	}
	// 821B377C: 481200ED  bl 0x822d3868
	ctx.lr = 0x821B3780;
	sub_822D3868(ctx, base);
	// 821B3780: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3784: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821B3788: 419A000C  beq cr6, 0x821b3794
	if ctx.cr[6].eq {
	pc = 0x821B3794; continue 'dispatch;
	}
	// 821B378C: 481200DD  bl 0x822d3868
	ctx.lr = 0x821B3790;
	sub_822D3868(ctx, base);
	// 821B3790: 481A8F99  bl 0x8235c728
	ctx.lr = 0x821B3794;
	sub_8235C728(ctx, base);
	// 821B3794: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3798: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B379C: 48AF5CA4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B37A0: 817D0144  lwz r11, 0x144(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(324 as u32) ) } as u64;
	// 821B37A4: 815D0070  lwz r10, 0x70(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 821B37A8: 392B4E20  addi r9, r11, 0x4e20
	ctx.r[9].s64 = ctx.r[11].s64 + 20000;
	// 821B37AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B37B0: 4198FDDC  blt cr6, 0x821b358c
	if ctx.cr[6].lt {
	pc = 0x821B358C; continue 'dispatch;
	}
	// 821B37B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B37B8: 48147051  bl 0x822fa808
	ctx.lr = 0x821B37BC;
	sub_822FA808(ctx, base);
	// 821B37BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B37C0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B37C4: 48AF5C7C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B37C8 => {
    //   block [0x821B37C8..0x821B39F8)
	// 821B37C8: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B37CC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B37D0: 419A0018  beq cr6, 0x821b37e8
	if ctx.cr[6].eq {
	pc = 0x821B37E8; continue 'dispatch;
	}
	// 821B37D4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 821B37D8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B37DC: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B37E0: 386A1D88  addi r3, r10, 0x1d88
	ctx.r[3].s64 = ctx.r[10].s64 + 7560;
	// 821B37E4: 4BFBF88D  bl 0x82173070
	ctx.lr = 0x821B37E8;
	sub_82173070(ctx, base);
	// 821B37E8: 817D0124  lwz r11, 0x124(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(292 as u32) ) } as u64;
	// 821B37EC: 3B7D0124  addi r27, r29, 0x124
	ctx.r[27].s64 = ctx.r[29].s64 + 292;
	// 821B37F0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821B37F4: 409A0088  bne cr6, 0x821b387c
	if !ctx.cr[6].eq {
	pc = 0x821B387C; continue 'dispatch;
	}
	// 821B37F8: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B37FC: 387D0080  addi r3, r29, 0x80
	ctx.r[3].s64 = ctx.r[29].s64 + 128;
	// 821B3800: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 821B3804: 419A0078  beq cr6, 0x821b387c
	if ctx.cr[6].eq {
	pc = 0x821B387C; continue 'dispatch;
	}
	// 821B3808: 48B0F619  bl 0x82cc2e20
	ctx.lr = 0x821B380C;
	sub_82CC2E20(ctx, base);
	// 821B380C: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 821B3810: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 821B3814: 409A0068  bne cr6, 0x821b387c
	if !ctx.cr[6].eq {
	pc = 0x821B387C; continue 'dispatch;
	}
	// 821B3818: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B381C: 386B1DB8  addi r3, r11, 0x1db8
	ctx.r[3].s64 = ctx.r[11].s64 + 7608;
	// 821B3820: 4BFBF851  bl 0x82173070
	ctx.lr = 0x821B3824;
	sub_82173070(ctx, base);
	// 821B3824: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 821B3828: 807F9684  lwz r3, -0x697c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-27004 as u32) ) } as u64;
	// 821B382C: 48B0EF85  bl 0x82cc27b0
	ctx.lr = 0x821B3830;
	sub_82CC27B0(ctx, base);
	// 821B3830: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B3834: 917F9684  stw r11, -0x697c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-27004 as u32), ctx.r[11].u32 ) };
	// 821B3838: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B383C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B3840: 419A0030  beq cr6, 0x821b3870
	if ctx.cr[6].eq {
	pc = 0x821B3870; continue 'dispatch;
	}
	// 821B3844: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3848: 409A0020  bne cr6, 0x821b3868
	if !ctx.cr[6].eq {
	pc = 0x821B3868; continue 'dispatch;
	}
	// 821B384C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3850: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3854: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3858: 48149959  bl 0x822fd1b0
	ctx.lr = 0x821B385C;
	sub_822FD1B0(ctx, base);
	// 821B385C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3860: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3864: 48AF5BDC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3868: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 821B386C: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821B3870: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3874: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3878: 48AF5BC8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B387C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3880: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3884: 4814A73D  bl 0x822fdfc0
	ctx.lr = 0x821B3888;
	sub_822FDFC0(ctx, base);
	// 821B3888: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B388C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3890: 419AFE1C  beq cr6, 0x821b36ac
	if ctx.cr[6].eq {
	pc = 0x821B36AC; continue 'dispatch;
	}
	// 821B3894: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B3898: 3BDD0080  addi r30, r29, 0x80
	ctx.r[30].s64 = ctx.r[29].s64 + 128;
	// 821B389C: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 821B38A0: 409A0010  bne cr6, 0x821b38b0
	if !ctx.cr[6].eq {
	pc = 0x821B38B0; continue 'dispatch;
	}
	// 821B38A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B38A8: 386B1E00  addi r3, r11, 0x1e00
	ctx.r[3].s64 = ctx.r[11].s64 + 7680;
	// 821B38AC: 4BFBF7C5  bl 0x82173070
	ctx.lr = 0x821B38B0;
	sub_82173070(ctx, base);
	// 821B38B0: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 821B38B4: 807F9684  lwz r3, -0x697c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-27004 as u32) ) } as u64;
	// 821B38B8: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821B38BC: 419A0010  beq cr6, 0x821b38cc
	if ctx.cr[6].eq {
	pc = 0x821B38CC; continue 'dispatch;
	}
	// 821B38C0: 48B0EEF1  bl 0x82cc27b0
	ctx.lr = 0x821B38C4;
	sub_82CC27B0(ctx, base);
	// 821B38C4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B38C8: 917F9684  stw r11, -0x697c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-27004 as u32), ctx.r[11].u32 ) };
	// 821B38CC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B38D0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821B38D4: 409A0034  bne cr6, 0x821b3908
	if !ctx.cr[6].eq {
	pc = 0x821B3908; continue 'dispatch;
	}
	// 821B38D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B38DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B38E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B38E4: 48B0F49D  bl 0x82cc2d80
	ctx.lr = 0x821B38E8;
	sub_82CC2D80(ctx, base);
	// 821B38E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B38EC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B38F0: 419A0018  beq cr6, 0x821b3908
	if ctx.cr[6].eq {
	pc = 0x821B3908; continue 'dispatch;
	}
	// 821B38F4: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 821B38F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B38FC: 481498B5  bl 0x822fd1b0
	ctx.lr = 0x821B3900;
	sub_822FD1B0(ctx, base);
	// 821B3900: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3904: 48AF5B3C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3908: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B390C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3910: 386B1E10  addi r3, r11, 0x1e10
	ctx.r[3].s64 = ctx.r[11].s64 + 7696;
	// 821B3914: 4BFBF75D  bl 0x82173070
	ctx.lr = 0x821B3918;
	sub_82173070(ctx, base);
	// 821B3918: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B391C: 386A1E24  addi r3, r10, 0x1e24
	ctx.r[3].s64 = ctx.r[10].s64 + 7716;
	// 821B3920: 4BFBF751  bl 0x82173070
	ctx.lr = 0x821B3924;
	sub_82173070(ctx, base);
	// 821B3924: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3928: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 821B392C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B3930: 40990044  ble cr6, 0x821b3974
	if !ctx.cr[6].gt {
	pc = 0x821B3974; continue 'dispatch;
	}
	// 821B3934: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3938: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 821B393C: 3B8B1E38  addi r28, r11, 0x1e38
	ctx.r[28].s64 = ctx.r[11].s64 + 7736;
	// 821B3940: 817D0120  lwz r11, 0x120(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(288 as u32) ) } as u64;
	// 821B3944: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B3948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B394C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821B3950: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 821B3954: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B3958: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B395C: 4BFBF715  bl 0x82173070
	ctx.lr = 0x821B3960;
	sub_82173070(ctx, base);
	// 821B3960: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3964: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B3968: 3BDE00C4  addi r30, r30, 0xc4
	ctx.r[30].s64 = ctx.r[30].s64 + 196;
	// 821B396C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3970: 4198FFD0  blt cr6, 0x821b3940
	if ctx.cr[6].lt {
	pc = 0x821B3940; continue 'dispatch;
	}
	// 821B3974: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B3978: 386B0C88  addi r3, r11, 0xc88
	ctx.r[3].s64 = ctx.r[11].s64 + 3208;
	// 821B397C: 4BFBF6F5  bl 0x82173070
	ctx.lr = 0x821B3980;
	sub_82173070(ctx, base);
	// 821B3980: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3984: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3988: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B398C: 4099001C  ble cr6, 0x821b39a8
	if !ctx.cr[6].gt {
	pc = 0x821B39A8; continue 'dispatch;
	}
	// 821B3990: 48146FF9  bl 0x822fa988
	ctx.lr = 0x821B3994;
	sub_822FA988(ctx, base);
	// 821B3994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3998: 48147909  bl 0x822fb2a0
	ctx.lr = 0x821B399C;
	sub_822FB2A0(ctx, base);
	// 821B399C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B39A0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B39A4: 48AF5A9C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B39A8: 48146FE1  bl 0x822fa988
	ctx.lr = 0x821B39AC;
	sub_822FA988(ctx, base);
	// 821B39AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B39B0: 481478F1  bl 0x822fb2a0
	ctx.lr = 0x821B39B4;
	sub_822FB2A0(ctx, base);
	// 821B39B4: 807D0120  lwz r3, 0x120(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(288 as u32) ) } as u64;
	// 821B39B8: 48068381  bl 0x8221bd38
	ctx.lr = 0x821B39BC;
	sub_8221BD38(ctx, base);
	// 821B39BC: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B39C0: 92FD0120  stw r23, 0x120(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(288 as u32), ctx.r[23].u32 ) };
	// 821B39C4: 9AFD0128  stb r23, 0x128(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(296 as u32), ctx.r[23].u8 ) };
	// 821B39C8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B39CC: 9ADD01A1  stb r22, 0x1a1(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(417 as u32), ctx.r[22].u8 ) };
	// 821B39D0: 419AFEA0  beq cr6, 0x821b3870
	if ctx.cr[6].eq {
	pc = 0x821B3870; continue 'dispatch;
	}
	// 821B39D4: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B39D8: 409AFE90  bne cr6, 0x821b3868
	if !ctx.cr[6].eq {
	pc = 0x821B3868; continue 'dispatch;
	}
	// 821B39DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B39E0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B39E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B39E8: 481497C9  bl 0x822fd1b0
	ctx.lr = 0x821B39EC;
	sub_822FD1B0(ctx, base);
	// 821B39EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B39F0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B39F4: 48AF5A4C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B39F8 => {
    //   block [0x821B39F8..0x821B3AC4)
	// 821B39F8: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B39FC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821B3A00: 419A0018  beq cr6, 0x821b3a18
	if ctx.cr[6].eq {
	pc = 0x821B3A18; continue 'dispatch;
	}
	// 821B3A04: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821B3A08: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3A0C: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3A10: 386A1E60  addi r3, r10, 0x1e60
	ctx.r[3].s64 = ctx.r[10].s64 + 7776;
	// 821B3A14: 4BFBF65D  bl 0x82173070
	ctx.lr = 0x821B3A18;
	sub_82173070(ctx, base);
	// 821B3A18: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B3A1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3A20: 409A0054  bne cr6, 0x821b3a74
	if !ctx.cr[6].eq {
	pc = 0x821B3A74; continue 'dispatch;
	}
	// 821B3A24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3A28: 386B1E8C  addi r3, r11, 0x1e8c
	ctx.r[3].s64 = ctx.r[11].s64 + 7820;
	// 821B3A2C: 4BFBF645  bl 0x82173070
	ctx.lr = 0x821B3A30;
	sub_82173070(ctx, base);
	// 821B3A30: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3A34: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B3A38: 419A0030  beq cr6, 0x821b3a68
	if ctx.cr[6].eq {
	pc = 0x821B3A68; continue 'dispatch;
	}
	// 821B3A3C: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3A40: 409A0020  bne cr6, 0x821b3a60
	if !ctx.cr[6].eq {
	pc = 0x821B3A60; continue 'dispatch;
	}
	// 821B3A44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3A48: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3A50: 48149761  bl 0x822fd1b0
	ctx.lr = 0x821B3A54;
	sub_822FD1B0(ctx, base);
	// 821B3A54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3A58: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3A5C: 48AF59E4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3A60: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 821B3A64: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821B3A68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3A6C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3A70: 48AF59D0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3A74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3A78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3A7C: 4814A545  bl 0x822fdfc0
	ctx.lr = 0x821B3A80;
	sub_822FDFC0(ctx, base);
	// 821B3A80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B3A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3A88: 419AFC24  beq cr6, 0x821b36ac
	if ctx.cr[6].eq {
	pc = 0x821B36AC; continue 'dispatch;
	}
	// 821B3A8C: 897D0129  lbz r11, 0x129(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(297 as u32) ) } as u64;
	// 821B3A90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3A94: 895D0128  lbz r10, 0x128(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(296 as u32) ) } as u64;
	// 821B3A98: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3A9C: 40980018  bge cr6, 0x821b3ab4
	if !ctx.cr[6].lt {
	pc = 0x821B3AB4; continue 'dispatch;
	}
	// 821B3AA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3AA4: 481470BD  bl 0x822fab60
	ctx.lr = 0x821B3AA8;
	sub_822FAB60(ctx, base);
	// 821B3AA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3AAC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3AB0: 48AF5990  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3AB4: 481474E5  bl 0x822faf98
	ctx.lr = 0x821B3AB8;
	sub_822FAF98(ctx, base);
	// 821B3AB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B3ABC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3AC0: 48AF5980  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3AC4 => {
    //   block [0x821B3AC4..0x821B3B44)
	// 821B3AC4: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3AC8: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B3ACC: 419A0018  beq cr6, 0x821b3ae4
	if ctx.cr[6].eq {
	pc = 0x821B3AE4; continue 'dispatch;
	}
	// 821B3AD0: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 821B3AD4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3AD8: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3ADC: 386A1E9C  addi r3, r10, 0x1e9c
	ctx.r[3].s64 = ctx.r[10].s64 + 7836;
	// 821B3AE0: 4BFBF591  bl 0x82173070
	ctx.lr = 0x821B3AE4;
	sub_82173070(ctx, base);
	// 821B3AE4: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 821B3AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3AEC: 419A0048  beq cr6, 0x821b3b34
	if ctx.cr[6].eq {
	pc = 0x821B3B34; continue 'dispatch;
	}
	// 821B3AF0: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3AF4: 39400022  li r10, 0x22
	ctx.r[10].s64 = 34;
	// 821B3AF8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B3AFC: 915D00A4  stw r10, 0xa4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 821B3B00: 419A0034  beq cr6, 0x821b3b34
	if ctx.cr[6].eq {
	pc = 0x821B3B34; continue 'dispatch;
	}
	// 821B3B04: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3B08: 409A0024  bne cr6, 0x821b3b2c
	if !ctx.cr[6].eq {
	pc = 0x821B3B2C; continue 'dispatch;
	}
	// 821B3B0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3B10: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3B14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3B18: 48149699  bl 0x822fd1b0
	ctx.lr = 0x821B3B1C;
	sub_822FD1B0(ctx, base);
	// 821B3B1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3B20: 48146529  bl 0x822fa048
	ctx.lr = 0x821B3B24;
	sub_822FA048(ctx, base);
	// 821B3B24: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3B28: 48AF5918  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3B2C: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 821B3B30: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821B3B34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3B38: 48146511  bl 0x822fa048
	ctx.lr = 0x821B3B3C;
	sub_822FA048(ctx, base);
	// 821B3B3C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3B40: 48AF5900  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3B44 => {
    //   block [0x821B3B44..0x821B3D64)
	// 821B3B44: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3B48: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821B3B4C: 419A0018  beq cr6, 0x821b3b64
	if ctx.cr[6].eq {
	pc = 0x821B3B64; continue 'dispatch;
	}
	// 821B3B50: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 821B3B54: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3B58: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3B5C: 386A1EC8  addi r3, r10, 0x1ec8
	ctx.r[3].s64 = ctx.r[10].s64 + 7880;
	// 821B3B60: 4BFBF511  bl 0x82173070
	ctx.lr = 0x821B3B64;
	sub_82173070(ctx, base);
	// 821B3B64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3B68: 48148F31  bl 0x822fca98
	ctx.lr = 0x821B3B6C;
	sub_822FCA98(ctx, base);
	// 821B3B6C: 817D0068  lwz r11, 0x68(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 821B3B70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3B74: 419801B4  blt cr6, 0x821b3d28
	if ctx.cr[6].lt {
	pc = 0x821B3D28; continue 'dispatch;
	}
	// 821B3B78: 92E10074  stw r23, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[23].u32 ) };
	// 821B3B7C: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 821B3B80: 92E1007C  stw r23, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[23].u32 ) };
	// 821B3B84: 480B252D  bl 0x822660b0
	ctx.lr = 0x821B3B88;
	sub_822660B0(ctx, base);
	// 821B3B88: 817D0174  lwz r11, 0x174(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(372 as u32) ) } as u64;
	// 821B3B8C: 3BFD0170  addi r31, r29, 0x170
	ctx.r[31].s64 = ctx.r[29].s64 + 368;
	// 821B3B90: 813D0068  lwz r9, 0x68(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 821B3B94: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 821B3B98: 7FC91850  subf r30, r9, r3
	ctx.r[30].s64 = ctx.r[3].s64 - ctx.r[9].s64;
	// 821B3B9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3BA0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B3BA4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B3BA8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3BAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3BB0: 419A000C  beq cr6, 0x821b3bbc
	if ctx.cr[6].eq {
	pc = 0x821B3BBC; continue 'dispatch;
	}
	// 821B3BB4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B3BB8: 419A0008  beq cr6, 0x821b3bc0
	if ctx.cr[6].eq {
	pc = 0x821B3BC0; continue 'dispatch;
	}
	// 821B3BBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3BC0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B3BC4: 419A00F0  beq cr6, 0x821b3cb4
	if ctx.cr[6].eq {
	pc = 0x821B3CB4; continue 'dispatch;
	}
	// 821B3BC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3BCC: 409A0008  bne cr6, 0x821b3bd4
	if !ctx.cr[6].eq {
	pc = 0x821B3BD4; continue 'dispatch;
	}
	// 821B3BD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3BD4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3BD8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3BDC: 409A0008  bne cr6, 0x821b3be4
	if !ctx.cr[6].eq {
	pc = 0x821B3BE4; continue 'dispatch;
	}
	// 821B3BE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3BE4: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B3BE8: 810902E8  lwz r8, 0x2e8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(744 as u32) ) } as u64;
	// 821B3BEC: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B3BF0: 419900B0  bgt cr6, 0x821b3ca0
	if ctx.cr[6].gt {
	pc = 0x821B3CA0; continue 'dispatch;
	}
	// 821B3BF4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3BF8: 92C10090  stw r22, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[22].u32 ) };
	// 821B3BFC: 409A0008  bne cr6, 0x821b3c04
	if !ctx.cr[6].eq {
	pc = 0x821B3C04; continue 'dispatch;
	}
	// 821B3C00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3C04: E96B0010  ld r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B3C08: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 821B3C0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3C10: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 821B3C14: 4814B27D  bl 0x822fee90
	ctx.lr = 0x821B3C18;
	sub_822FEE90(ctx, base);
	// 821B3C18: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B3C1C: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821B3C20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3C24: 419A005C  beq cr6, 0x821b3c80
	if ctx.cr[6].eq {
	pc = 0x821B3C80; continue 'dispatch;
	}
	// 821B3C28: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821B3C2C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821B3C30: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821B3C34: 7D091E70  srawi r9, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821B3C38: 7CE81E70  srawi r8, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 821B3C3C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B3C40: 40980034  bge cr6, 0x821b3c74
	if !ctx.cr[6].lt {
	pc = 0x821B3C74; continue 'dispatch;
	}
	// 821B3C44: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821B3C48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3C4C: 419A000C  beq cr6, 0x821b3c58
	if ctx.cr[6].eq {
	pc = 0x821B3C58; continue 'dispatch;
	}
	// 821B3C50: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B3C54: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B3C58: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B3C5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3C60: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821B3C64: 48160EC5  bl 0x82314b28
	ctx.lr = 0x821B3C68;
	sub_82314B28(ctx, base);
	// 821B3C68: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B3C6C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B3C70: 4BFFFF38  b 0x821b3ba8
	pc = 0x821B3BA8; continue 'dispatch;
	// 821B3C74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3C78: 40990008  ble cr6, 0x821b3c80
	if !ctx.cr[6].gt {
	pc = 0x821B3C80; continue 'dispatch;
	}
	// 821B3C7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3C80: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 821B3C84: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B3C88: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B3C8C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B3C90: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821B3C94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B3C98: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B3C9C: 482E9F1D  bl 0x8249dbb8
	ctx.lr = 0x821B3CA0;
	sub_8249DBB8(ctx, base);
	// 821B3CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3CA4: 48160E85  bl 0x82314b28
	ctx.lr = 0x821B3CA8;
	sub_82314B28(ctx, base);
	// 821B3CA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B3CAC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B3CB0: 4BFFFEF8  b 0x821b3ba8
	pc = 0x821B3BA8; continue 'dispatch;
	// 821B3CB4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B3CB8: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821B3CBC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3CC0: 40990008  ble cr6, 0x821b3cc8
	if !ctx.cr[6].gt {
	pc = 0x821B3CC8; continue 'dispatch;
	}
	// 821B3CC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3CC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B3CCC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3CD0: 40990008  ble cr6, 0x821b3cd8
	if !ctx.cr[6].gt {
	pc = 0x821B3CD8; continue 'dispatch;
	}
	// 821B3CD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3CD8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3CDC: 419A0034  beq cr6, 0x821b3d10
	if ctx.cr[6].eq {
	pc = 0x821B3D10; continue 'dispatch;
	}
	// 821B3CE0: 41980008  blt cr6, 0x821b3ce8
	if ctx.cr[6].lt {
	pc = 0x821B3CE8; continue 'dispatch;
	}
	// 821B3CE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3CE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3CEC: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 821B3CF0: 4814AFF1  bl 0x822fece0
	ctx.lr = 0x821B3CF4;
	sub_822FECE0(ctx, base);
	// 821B3CF4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821B3CF8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3CFC: 41980008  blt cr6, 0x821b3d04
	if ctx.cr[6].lt {
	pc = 0x821B3D04; continue 'dispatch;
	}
	// 821B3D00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3D04: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B3D08: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821B3D0C: 4BFFFFC0  b 0x821b3ccc
	pc = 0x821B3CCC; continue 'dispatch;
	// 821B3D10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B3D14: 419A0008  beq cr6, 0x821b3d1c
	if ctx.cr[6].eq {
	pc = 0x821B3D1C; continue 'dispatch;
	}
	// 821B3D18: 48068021  bl 0x8221bd38
	ctx.lr = 0x821B3D1C;
	sub_8221BD38(ctx, base);
	// 821B3D1C: 92E10074  stw r23, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[23].u32 ) };
	// 821B3D20: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 821B3D24: 92E1007C  stw r23, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[23].u32 ) };
	// 821B3D28: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B3D2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3D30: 41980028  blt cr6, 0x821b3d58
	if ctx.cr[6].lt {
	pc = 0x821B3D58; continue 'dispatch;
	}
	// 821B3D34: 480B237D  bl 0x822660b0
	ctx.lr = 0x821B3D38;
	sub_822660B0(ctx, base);
	// 821B3D38: 817D0074  lwz r11, 0x74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B3D3C: 815D0060  lwz r10, 0x60(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B3D40: 7D2B1850  subf r9, r11, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821B3D44: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B3D48: 41980010  blt cr6, 0x821b3d58
	if ctx.cr[6].lt {
	pc = 0x821B3D58; continue 'dispatch;
	}
	// 821B3D4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3D50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3D54: 48149035  bl 0x822fcd88
	ctx.lr = 0x821B3D58;
	sub_822FCD88(ctx, base);
	// 821B3D58: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821B3D5C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3D60: 48AF56E0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3D64 => {
    //   block [0x821B3D64..0x821B3F24)
	// 821B3D64: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3D68: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B3D6C: 419A0018  beq cr6, 0x821b3d84
	if ctx.cr[6].eq {
	pc = 0x821B3D84; continue 'dispatch;
	}
	// 821B3D70: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 821B3D74: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B3D78: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3D7C: 386A1E9C  addi r3, r10, 0x1e9c
	ctx.r[3].s64 = ctx.r[10].s64 + 7836;
	// 821B3D80: 4BFBF2F1  bl 0x82173070
	ctx.lr = 0x821B3D84;
	sub_82173070(ctx, base);
	// 821B3D84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3D88: 481462C1  bl 0x822fa048
	ctx.lr = 0x821B3D8C;
	sub_822FA048(ctx, base);
	// 821B3D8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B3D90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3D94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3D98: 4814A229  bl 0x822fdfc0
	ctx.lr = 0x821B3D9C;
	sub_822FDFC0(ctx, base);
	// 821B3D9C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B3DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3DA4: 419A0164  beq cr6, 0x821b3f08
	if ctx.cr[6].eq {
	pc = 0x821B3F08; continue 'dispatch;
	}
	// 821B3DA8: 81596AB8  lwz r10, 0x6ab8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B3DAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3DB0: 419A000C  beq cr6, 0x821b3dbc
	if ctx.cr[6].eq {
	pc = 0x821B3DBC; continue 'dispatch;
	}
	// 821B3DB4: 89786A5E  lbz r11, 0x6a5e(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821B3DB8: 48000008  b 0x821b3dc0
	pc = 0x821B3DC0; continue 'dispatch;
	// 821B3DBC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821B3DC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B3DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3DC8: 419A0140  beq cr6, 0x821b3f08
	if ctx.cr[6].eq {
	pc = 0x821B3F08; continue 'dispatch;
	}
	// 821B3DCC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B3DD0: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821B3DD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B3DD8: 409A0130  bne cr6, 0x821b3f08
	if !ctx.cr[6].eq {
	pc = 0x821B3F08; continue 'dispatch;
	}
	// 821B3DDC: 897D01C8  lbz r11, 0x1c8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(456 as u32) ) } as u64;
	// 821B3DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3DE4: 409A00F0  bne cr6, 0x821b3ed4
	if !ctx.cr[6].eq {
	pc = 0x821B3ED4; continue 'dispatch;
	}
	// 821B3DE8: 897D01C9  lbz r11, 0x1c9(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(457 as u32) ) } as u64;
	// 821B3DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3DF0: 409A00E4  bne cr6, 0x821b3ed4
	if !ctx.cr[6].eq {
	pc = 0x821B3ED4; continue 'dispatch;
	}
	// 821B3DF4: 815D0174  lwz r10, 0x174(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(372 as u32) ) } as u64;
	// 821B3DF8: 3BFD0170  addi r31, r29, 0x170
	ctx.r[31].s64 = ctx.r[29].s64 + 368;
	// 821B3DFC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821B3E00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B3E04: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3E08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B3E0C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3E14: 419A000C  beq cr6, 0x821b3e20
	if ctx.cr[6].eq {
	pc = 0x821B3E20; continue 'dispatch;
	}
	// 821B3E18: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B3E1C: 419A0008  beq cr6, 0x821b3e24
	if ctx.cr[6].eq {
	pc = 0x821B3E24; continue 'dispatch;
	}
	// 821B3E20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3E24: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B3E28: 419A0080  beq cr6, 0x821b3ea8
	if ctx.cr[6].eq {
	pc = 0x821B3EA8; continue 'dispatch;
	}
	// 821B3E2C: 893D01C8  lbz r9, 0x1c8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(456 as u32) ) } as u64;
	// 821B3E30: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B3E34: 409A0074  bne cr6, 0x821b3ea8
	if !ctx.cr[6].eq {
	pc = 0x821B3EA8; continue 'dispatch;
	}
	// 821B3E38: 893D01C9  lbz r9, 0x1c9(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(457 as u32) ) } as u64;
	// 821B3E3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B3E40: 409A0068  bne cr6, 0x821b3ea8
	if !ctx.cr[6].eq {
	pc = 0x821B3EA8; continue 'dispatch;
	}
	// 821B3E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3E48: 409A0008  bne cr6, 0x821b3e50
	if !ctx.cr[6].eq {
	pc = 0x821B3E50; continue 'dispatch;
	}
	// 821B3E4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3E50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3E54: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3E58: 409A0008  bne cr6, 0x821b3e60
	if !ctx.cr[6].eq {
	pc = 0x821B3E60; continue 'dispatch;
	}
	// 821B3E5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3E60: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B3E64: 89090068  lbz r8, 0x68(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(104 as u32) ) } as u64;
	// 821B3E68: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B3E6C: 409A0028  bne cr6, 0x821b3e94
	if !ctx.cr[6].eq {
	pc = 0x821B3E94; continue 'dispatch;
	}
	// 821B3E70: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B3E74: 409A0008  bne cr6, 0x821b3e7c
	if !ctx.cr[6].eq {
	pc = 0x821B3E7C; continue 'dispatch;
	}
	// 821B3E78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3E7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3E80: 808A0018  lwz r4, 0x18(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B3E84: 4814A795  bl 0x822fe618
	ctx.lr = 0x821B3E88;
	sub_822FE618(ctx, base);
	// 821B3E88: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B3E8C: 41980008  blt cr6, 0x821b3e94
	if ctx.cr[6].lt {
	pc = 0x821B3E94; continue 'dispatch;
	}
	// 821B3E90: 9ADD01C8  stb r22, 0x1c8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(456 as u32), ctx.r[22].u8 ) };
	// 821B3E94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B3E98: 48160C91  bl 0x82314b28
	ctx.lr = 0x821B3E9C;
	sub_82314B28(ctx, base);
	// 821B3E9C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B3EA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B3EA4: 4BFFFF68  b 0x821b3e0c
	pc = 0x821B3E0C; continue 'dispatch;
	// 821B3EA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B3EAC: 409A0008  bne cr6, 0x821b3eb4
	if !ctx.cr[6].eq {
	pc = 0x821B3EB4; continue 'dispatch;
	}
	// 821B3EB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3EB8: 419A000C  beq cr6, 0x821b3ec4
	if ctx.cr[6].eq {
	pc = 0x821B3EC4; continue 'dispatch;
	}
	// 821B3EBC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B3EC0: 419A003C  beq cr6, 0x821b3efc
	if ctx.cr[6].eq {
	pc = 0x821B3EFC; continue 'dispatch;
	}
	// 821B3EC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B3EC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B3ECC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3ED0: 48AF5570  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3ED4: 897D01C9  lbz r11, 0x1c9(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(457 as u32) ) } as u64;
	// 821B3ED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3EDC: 409A0020  bne cr6, 0x821b3efc
	if !ctx.cr[6].eq {
	pc = 0x821B3EFC; continue 'dispatch;
	}
	// 821B3EE0: 9AFD01C8  stb r23, 0x1c8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(456 as u32), ctx.r[23].u8 ) };
	// 821B3EE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3EE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3EEC: 4814A84D  bl 0x822fe738
	ctx.lr = 0x821B3EF0;
	sub_822FE738(ctx, base);
	// 821B3EF0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B3EF4: 41980008  blt cr6, 0x821b3efc
	if ctx.cr[6].lt {
	pc = 0x821B3EFC; continue 'dispatch;
	}
	// 821B3EF8: 9ADD01C9  stb r22, 0x1c9(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(457 as u32), ctx.r[22].u8 ) };
	// 821B3EFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B3F00: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3F04: 48AF553C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3F08: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3F0C: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821B3F10: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3F14: 419A0094  beq cr6, 0x821b3fa8
	if ctx.cr[6].eq {
	pc = 0x821B3FA8; continue 'dispatch;
	}
	// 821B3F18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B3F1C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3F20: 48AF5520  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B3F24 => {
    //   block [0x821B3F24..0x821B3FB0)
	// 821B3F24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3F2C: 4814A095  bl 0x822fdfc0
	ctx.lr = 0x821B3F30;
	sub_822FDFC0(ctx, base);
	// 821B3F30: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B3F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3F38: 419A0040  beq cr6, 0x821b3f78
	if ctx.cr[6].eq {
	pc = 0x821B3F78; continue 'dispatch;
	}
	// 821B3F3C: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 821B3F40: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821B3F44: 419A0034  beq cr6, 0x821b3f78
	if ctx.cr[6].eq {
	pc = 0x821B3F78; continue 'dispatch;
	}
	// 821B3F48: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821B3F4C: 409A0024  bne cr6, 0x821b3f70
	if !ctx.cr[6].eq {
	pc = 0x821B3F70; continue 'dispatch;
	}
	// 821B3F50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B3F54: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B3F58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3F5C: 48149255  bl 0x822fd1b0
	ctx.lr = 0x821B3F60;
	sub_822FD1B0(ctx, base);
	// 821B3F60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3F64: 481460E5  bl 0x822fa048
	ctx.lr = 0x821B3F68;
	sub_822FA048(ctx, base);
	// 821B3F68: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3F6C: 48AF54D4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3F70: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 821B3F74: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821B3F78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3F7C: 481460CD  bl 0x822fa048
	ctx.lr = 0x821B3F80;
	sub_822FA048(ctx, base);
	// 821B3F80: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3F84: 48AF54BC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
	// 821B3F88: 815D00A0  lwz r10, 0xa0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B3F8C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B3F90: 419A0014  beq cr6, 0x821b3fa4
	if ctx.cr[6].eq {
	pc = 0x821B3FA4; continue 'dispatch;
	}
	// 821B3F94: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821B3F98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3F9C: 386B1EF0  addi r3, r11, 0x1ef0
	ctx.r[3].s64 = ctx.r[11].s64 + 7920;
	// 821B3FA0: 4BFBF0D1  bl 0x82173070
	ctx.lr = 0x821B3FA4;
	sub_82173070(ctx, base);
	// 821B3FA4: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821B3FA8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B3FAC: 48AF5494  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B3FB0 size=108
    let mut pc: u32 = 0x821B3FB0;
    'dispatch: loop {
        match pc {
            0x821B3FB0 => {
    //   block [0x821B3FB0..0x821B401C)
	// 821B3FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B3FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B3FB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3FBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B3FC0: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3FC4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821B3FC8: 419A001C  beq cr6, 0x821b3fe4
	if ctx.cr[6].eq {
	pc = 0x821B3FE4; continue 'dispatch;
	}
	// 821B3FCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B3FD0: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821B3FD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B3FD8: 394B113C  addi r10, r11, 0x113c
	ctx.r[10].s64 = ctx.r[11].s64 + 4412;
	// 821B3FDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B3FE0: 48000024  b 0x821b4004
	pc = 0x821B4004; continue 'dispatch;
	// 821B3FE4: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B3FE8: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821B3FEC: 419A0020  beq cr6, 0x821b400c
	if ctx.cr[6].eq {
	pc = 0x821B400C; continue 'dispatch;
	}
	// 821B3FF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B3FF4: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821B3FF8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821B3FFC: 394B113C  addi r10, r11, 0x113c
	ctx.r[10].s64 = ctx.r[11].s64 + 4412;
	// 821B4000: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821B4004: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B4008: 48076AC1  bl 0x8222aac8
	ctx.lr = 0x821B400C;
	sub_8222AAC8(ctx, base);
	// 821B400C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B4010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B4014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B4018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4020 size=240
    let mut pc: u32 = 0x821B4020;
    'dispatch: loop {
        match pc {
            0x821B4020 => {
    //   block [0x821B4020..0x821B4110)
	// 821B4020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4024: 48AF53E5  bl 0x82ca9408
	ctx.lr = 0x821B4028;
	sub_82CA93D0(ctx, base);
	// 821B4028: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B402C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4030: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B4034: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 821B4038: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B403C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B4040: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 821B4044: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B4048: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B404C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 821B4050: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B4054: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821B4058: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B405C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B4060: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4064: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821B4068: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B406C: 482983BD  bl 0x8244c428
	ctx.lr = 0x821B4070;
	sub_8244C428(ctx, base);
	// 821B4070: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4078: 419A000C  beq cr6, 0x821b4084
	if ctx.cr[6].eq {
	pc = 0x821B4084; continue 'dispatch;
	}
	// 821B407C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B4080: 419A0008  beq cr6, 0x821b4088
	if ctx.cr[6].eq {
	pc = 0x821B4088; continue 'dispatch;
	}
	// 821B4084: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B4088: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B408C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B4090: 419A0010  beq cr6, 0x821b40a0
	if ctx.cr[6].eq {
	pc = 0x821B40A0; continue 'dispatch;
	}
	// 821B4094: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B4098: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B409C: 48AF53BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821B40A0: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B40A4: 3BDF003C  addi r30, r31, 0x3c
	ctx.r[30].s64 = ctx.r[31].s64 + 60;
	// 821B40A8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B40AC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B40B0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B40B4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 821B40B8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 821B40BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B40C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B40C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B40C8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821B40CC: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821B40D0: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B40D4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B40D8: 48298351  bl 0x8244c428
	ctx.lr = 0x821B40DC;
	sub_8244C428(ctx, base);
	// 821B40DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B40E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B40E4: 419A000C  beq cr6, 0x821b40f0
	if ctx.cr[6].eq {
	pc = 0x821B40F0; continue 'dispatch;
	}
	// 821B40E8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B40EC: 419A0008  beq cr6, 0x821b40f4
	if ctx.cr[6].eq {
	pc = 0x821B40F4; continue 'dispatch;
	}
	// 821B40F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B40F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B40F8: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 821B40FC: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821B4100: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821B4104: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 821B4108: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B410C: 48AF534C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B4110 size=44
    let mut pc: u32 = 0x821B4110;
    'dispatch: loop {
        match pc {
            0x821B4110 => {
    //   block [0x821B4110..0x821B413C)
	// 821B4110: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4140 size=836
    let mut pc: u32 = 0x821B4140;
    'dispatch: loop {
        match pc {
            0x821B4140 => {
    //   block [0x821B4140..0x821B4484)
	// 821B4140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4144: 48AF5291  bl 0x82ca93d4
	ctx.lr = 0x821B4148;
	sub_82CA93D0(ctx, base);
	// 821B4148: DBC1FF60  stfd f30, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[30].u64 ) };
	// 821B414C: DBE1FF68  stfd f31, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 821B4150: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4154: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 821B4158: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B415C: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 821B4160: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821B4164: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821B4168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B416C: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4170: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B4174: 4804C16D  bl 0x822002e0
	ctx.lr = 0x821B4178;
	sub_822002E0(ctx, base);
	// 821B4178: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B417C: 81E10054  lwz r15, 0x54(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B4180: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4184: 419A02A8  beq cr6, 0x821b442c
	if ctx.cr[6].eq {
	pc = 0x821B442C; continue 'dispatch;
	}
	// 821B4188: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 821B418C: 388F0024  addi r4, r15, 0x24
	ctx.r[4].s64 = ctx.r[15].s64 + 36;
	// 821B4190: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 821B4194: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B4198: 9381008C  stw r28, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 821B419C: 4803C155  bl 0x821f02f0
	ctx.lr = 0x821B41A0;
	sub_821F02F0(ctx, base);
	// 821B41A0: 816F0038  lwz r11, 0x38(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B41A4: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 821B41A8: C16F0034  lfs f11, 0x34(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B41AC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 821B41B0: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 821B41B4: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 821B41B8: 82C10084  lwz r22, 0x84(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B41BC: 82A10088  lwz r21, 0x88(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B41C0: 7CF6A850  subf r7, r22, r21
	ctx.r[7].s64 = ctx.r[21].s64 - ctx.r[22].s64;
	// 821B41C4: 7D6753D7  divw. r11, r7, r10
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B41C8: C8010068  lfd f0, 0x68(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821B41CC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821B41D0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B41D4: EFEC5824  fdivs f31, f12, f11
	ctx.f[31].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 821B41D8: 41820234  beq 0x821b440c
	if ctx.cr[0].eq {
	pc = 0x821B440C; continue 'dispatch;
	}
	// 821B41DC: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821B41E0: 7D745B78  mr r20, r11
	ctx.r[20].u64 = ctx.r[11].u64;
	// 821B41E4: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821B41E8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 821B41EC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821B41F0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821B41F4: C3C79490  lfs f30, -0x6b70(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B41F8: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	// 821B41FC: 3E40834A  lis r18, -0x7cb6
	ctx.r[18].s64 = -2092302336;
	// 821B4200: 3E60834A  lis r19, -0x7cb6
	ctx.r[19].s64 = -2092302336;
	// 821B4204: 3AE87088  addi r23, r8, 0x7088
	ctx.r[23].s64 = ctx.r[8].s64 + 28808;
	// 821B4208: 3B49FFDF  addi r26, r9, -0x21
	ctx.r[26].s64 = ctx.r[9].s64 + -33;
	// 821B420C: 3B2AB748  addi r25, r10, -0x48b8
	ctx.r[25].s64 = ctx.r[10].s64 + -18616;
	// 821B4210: 3B0BB74C  addi r24, r11, -0x48b4
	ctx.r[24].s64 = ctx.r[11].s64 + -18612;
	// 821B4214: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 821B4218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B421C: 4803C025  bl 0x821f0240
	ctx.lr = 0x821B4220;
	sub_821F0240(ctx, base);
	// 821B4220: 8173B760  lwz r11, -0x48a0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-18592 as u32) ) } as u64;
	// 821B4224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4228: 409A0010  bne cr6, 0x821b4238
	if !ctx.cr[6].eq {
	pc = 0x821B4238; continue 'dispatch;
	}
	// 821B422C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B4230: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B4234: 4800000C  b 0x821b4240
	pc = 0x821B4240; continue 'dispatch;
	// 821B4238: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B423C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4240: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B4244: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B4248: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B424C: 419A0008  beq cr6, 0x821b4254
	if ctx.cr[6].eq {
	pc = 0x821B4254; continue 'dispatch;
	}
	// 821B4250: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4254: 48AF5E9D  bl 0x82caa0f0
	ctx.lr = 0x821B4258;
	sub_82CAA0F0(ctx, base);
	// 821B4258: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B425C: 409A0178  bne cr6, 0x821b43d4
	if !ctx.cr[6].eq {
	pc = 0x821B43D4; continue 'dispatch;
	}
	// 821B4260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B4264: 4855FCAD  bl 0x82713f10
	ctx.lr = 0x821B4268;
	sub_82713F10(ctx, base);
	// 821B4268: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821B426C: 409A0168  bne cr6, 0x821b43d4
	if !ctx.cr[6].eq {
	pc = 0x821B43D4; continue 'dispatch;
	}
	// 821B4270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B4274: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821B4278: 4803BFC9  bl 0x821f0240
	ctx.lr = 0x821B427C;
	sub_821F0240(ctx, base);
	// 821B427C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821B4280: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B4284: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821B4288: 480325C1  bl 0x821e6848
	ctx.lr = 0x821B428C;
	sub_821E6848(ctx, base);
	// 821B428C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821B4290: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B4294: 4803BFAD  bl 0x821f0240
	ctx.lr = 0x821B4298;
	sub_821F0240(ctx, base);
	// 821B4298: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821B429C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B42A0: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 821B42A4: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 821B42A8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 821B42AC: 92C1006C  stw r22, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[22].u32 ) };
	// 821B42B0: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B42B4: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821B42B8: 48565179  bl 0x82719430
	ctx.lr = 0x821B42BC;
	sub_82719430(ctx, base);
	// 821B42BC: 83E10074  lwz r31, 0x74(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B42C0: 7F1FA840  cmplw cr6, r31, r21
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[21].u32, &mut ctx.xer);
	// 821B42C4: 419A0108  beq cr6, 0x821b43cc
	if ctx.cr[6].eq {
	pc = 0x821B43CC; continue 'dispatch;
	}
	// 821B42C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B42CC: 4855FD9D  bl 0x82714068
	ctx.lr = 0x821B42D0;
	sub_82714068(ctx, base);
	// 821B42D0: 8172B758  lwz r11, -0x48a8(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-18600 as u32) ) } as u64;
	// 821B42D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B42D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B42DC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B42E0: 419A0008  beq cr6, 0x821b42e8
	if ctx.cr[6].eq {
	pc = 0x821B42E8; continue 'dispatch;
	}
	// 821B42E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B42E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B42EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B42F0: 419A0008  beq cr6, 0x821b42f8
	if ctx.cr[6].eq {
	pc = 0x821B42F8; continue 'dispatch;
	}
	// 821B42F4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B42F8: 480324D1  bl 0x821e67c8
	ctx.lr = 0x821B42FC;
	sub_821E67C8(ctx, base);
	// 821B42FC: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821B4300: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4304: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B4308: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B430C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B4310: 694B0001  xori r11, r10, 1
	ctx.r[11].u64 = ctx.r[10].u64 ^ 1;
	// 821B4314: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B4318: 40980008  bge cr6, 0x821b4320
	if !ctx.cr[6].lt {
	pc = 0x821B4320; continue 'dispatch;
	}
	// 821B431C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821B4320: ED9EF824  fdivs f12, f30, f31
	ctx.f[12].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 821B4324: 81100000  lwz r8, 0(r16)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4328: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821B432C: D3E100A0  stfs f31, 0xa0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 821B4330: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 821B4334: 394100B4  addi r10, r1, 0xb4
	ctx.r[10].s64 = ctx.r[1].s64 + 180;
	// 821B4338: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 821B433C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 821B4340: 910100B0  stw r8, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[8].u32 ) };
	// 821B4344: ED6D0332  fmuls f11, f13, f12
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B4348: D1610098  stfs f11, 0x98(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821B434C: ED4C0032  fmuls f10, f12, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B4350: D141009C  stfs f10, 0x9c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821B4354: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821B4358: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B435C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B4360: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B4364: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B4368: 4200FFF0  bdnz 0x821b4358
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B4358; continue 'dispatch;
	}
	// 821B436C: 81710004  lwz r11, 4(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4370: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B4374: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821B4378: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B437C: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 821B4380: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4384: 409A0038  bne cr6, 0x821b43bc
	if !ctx.cr[6].eq {
	pc = 0x821B43BC; continue 'dispatch;
	}
	// 821B4388: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B438C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821B4390: 7D2A4010  subfc r9, r10, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[10].u32;
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 821B4394: 7CE94910  subfe r7, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821B4398: 54E507FE  clrlwi r5, r7, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821B439C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B43A0: 419A000C  beq cr6, 0x821b43ac
	if ctx.cr[6].eq {
	pc = 0x821B43AC; continue 'dispatch;
	}
	// 821B43A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B43A8: 48000008  b 0x821b43b0
	pc = 0x821B43B0; continue 'dispatch;
	// 821B43AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B43B0: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 821B43B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B43B8: 419AFFD0  beq cr6, 0x821b4388
	if ctx.cr[6].eq {
	pc = 0x821B4388; continue 'dispatch;
	}
	// 821B43BC: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 821B43C0: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821B43C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B43C8: 48563891  bl 0x82717c58
	ctx.lr = 0x821B43CC;
	sub_82717C58(ctx, base);
	// 821B43CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821B43D0: 48060A09  bl 0x82214dd8
	ctx.lr = 0x821B43D4;
	sub_82214DD8(ctx, base);
	// 821B43D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B43D8: 48012391  bl 0x821c6768
	ctx.lr = 0x821B43DC;
	sub_821C6768(ctx, base);
	// 821B43DC: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 821B43E0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B43E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B43E8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B43EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B43F0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B43F4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B43F8: 4082FFE8  bne 0x821b43e0
	if !ctx.cr[0].eq {
	pc = 0x821B43E0; continue 'dispatch;
	}
	// 821B43FC: 3694FFFF  addic. r20, r20, -1
	ctx.xer.ca = (ctx.r[20].u32 > (!(-1 as u32)));
	ctx.r[20].s64 = ctx.r[20].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 821B4400: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B4404: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 821B4408: 4082FE0C  bne 0x821b4214
	if !ctx.cr[0].eq {
	pc = 0x821B4214; continue 'dispatch;
	}
	// 821B440C: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 821B4410: 419A001C  beq cr6, 0x821b442c
	if ctx.cr[6].eq {
	pc = 0x821B442C; continue 'dispatch;
	}
	// 821B4414: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821B4418: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 821B441C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B4420: 483B25F1  bl 0x82566a10
	ctx.lr = 0x821B4424;
	sub_82566A10(ctx, base);
	// 821B4424: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821B4428: 48067911  bl 0x8221bd38
	ctx.lr = 0x821B442C;
	sub_8221BD38(ctx, base);
	// 821B442C: 2B0F0000  cmplwi cr6, r15, 0
	ctx.cr[6].compare_u32(ctx.r[15].u32, 0 as u32, &mut ctx.xer);
	// 821B4430: 419A0044  beq cr6, 0x821b4474
	if ctx.cr[6].eq {
	pc = 0x821B4474; continue 'dispatch;
	}
	// 821B4434: 396F0004  addi r11, r15, 4
	ctx.r[11].s64 = ctx.r[15].s64 + 4;
	// 821B4438: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821B443C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4440: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821B4444: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B4448: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B444C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4450: 4082FFE8  bne 0x821b4438
	if !ctx.cr[0].eq {
	pc = 0x821B4438; continue 'dispatch;
	}
	// 821B4454: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821B4458: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B445C: 409A0018  bne cr6, 0x821b4474
	if !ctx.cr[6].eq {
	pc = 0x821B4474; continue 'dispatch;
	}
	// 821B4460: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4464: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 821B4468: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B446C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4470: 4E800421  bctrl
	ctx.lr = 0x821B4474;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4474: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 821B4478: CBC1FF60  lfd f30, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 821B447C: CBE1FF68  lfd f31, -0x98(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821B4480: 48AF4FA4  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4488 size=188
    let mut pc: u32 = 0x821B4488;
    'dispatch: loop {
        match pc {
            0x821B4488 => {
    //   block [0x821B4488..0x821B4544)
	// 821B4488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B448C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B4490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B4494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B4498: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821B449C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B44A0: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 821B44A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B44A8: 397E9484  addi r11, r30, -0x6b7c
	ctx.r[11].s64 = ctx.r[30].s64 + -27516;
	// 821B44AC: C00BFE50  lfs f0, -0x1b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B44B0: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B44B4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B44B8: 48085AD9  bl 0x82239f90
	ctx.lr = 0x821B44BC;
	sub_82239F90(ctx, base);
	// 821B44BC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B44C0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B44C4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B44C8: 480859E9  bl 0x82239eb0
	ctx.lr = 0x821B44CC;
	sub_82239EB0(ctx, base);
	// 821B44CC: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 821B44D0: C01E9484  lfs f0, -0x6b7c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B44D4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821B44D8: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821B44DC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821B44E0: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B44E4: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 821B44E8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B44EC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B44F0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4548 size=308
    let mut pc: u32 = 0x821B4548;
    'dispatch: loop {
        match pc {
            0x821B4548 => {
    //   block [0x821B4548..0x821B467C)
	// 821B4548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B454C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B4550: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B4554: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 821B4558: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821B455C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4560: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4564: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821B4568: 48085A29  bl 0x82239f90
	ctx.lr = 0x821B456C;
	sub_82239F90(ctx, base);
	// 821B456C: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4570: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B4574: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821B4578: 48085939  bl 0x82239eb0
	ctx.lr = 0x821B457C;
	sub_82239EB0(ctx, base);
	// 821B457C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4580: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821B4584: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4588: FDA0F850  fneg f13, f31
	ctx.f[13].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B458C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B4590: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 821B4594: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B4598: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821B459C: C1AB9490  lfs f13, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B45A0: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4680 size=436
    let mut pc: u32 = 0x821B4680;
    'dispatch: loop {
        match pc {
            0x821B4680 => {
    //   block [0x821B4680..0x821B4834)
	// 821B4680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4684: 48AF4D89  bl 0x82ca940c
	ctx.lr = 0x821B4688;
	sub_82CA93D0(ctx, base);
	// 821B4688: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B468C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4690: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821B4694: 38EB9484  addi r7, r11, -0x6b7c
	ctx.r[7].s64 = ctx.r[11].s64 + -27516;
	// 821B4698: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821B469C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B46A0: 38A99160  addi r5, r9, -0x6ea0
	ctx.r[5].s64 = ctx.r[9].s64 + -28320;
	// 821B46A4: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 821B46A8: C007000C  lfs f0, 0xc(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B46AC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821B46B0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B46B4: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4838 size=228
    let mut pc: u32 = 0x821B4838;
    'dispatch: loop {
        match pc {
            0x821B4838 => {
    //   block [0x821B4838..0x821B491C)
	// 821B4838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B483C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B4840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B4844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B4848: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B484C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4850: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 821B4854: 390BB480  addi r8, r11, -0x4b80
	ctx.r[8].s64 = ctx.r[11].s64 + -19328;
	// 821B4858: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B485C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821B4860: C00BB480  lfs f0, -0x4b80(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4864: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B4868: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B486C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 821B4870: C1A8E010  lfs f13, -0x1ff0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4874: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B4878: C008E004  lfs f0, -0x1ffc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B487C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B4880: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4920 size=552
    let mut pc: u32 = 0x821B4920;
    'dispatch: loop {
        match pc {
            0x821B4920 => {
    //   block [0x821B4920..0x821B4B48)
	// 821B4920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4924: 48AF4AE1  bl 0x82ca9404
	ctx.lr = 0x821B4928;
	sub_82CA93D0(ctx, base);
	// 821B4928: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821B492C: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821B4930: 48E520A5  bl 0x830069d4
	ctx.lr = 0x821B4934;
	sub_83006760(ctx, base);
	// 821B4934: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4B48 size=236
    let mut pc: u32 = 0x821B4B48;
    'dispatch: loop {
        match pc {
            0x821B4B48 => {
    //   block [0x821B4B48..0x821B4C34)
	// 821B4B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4B4C: 48AF48C1  bl 0x82ca940c
	ctx.lr = 0x821B4B50;
	sub_82CA93D0(ctx, base);
	// 821B4B50: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821B4B54: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821B4B58: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4B5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4B60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B4B64: C01F0288  lfs f0, 0x288(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4B68: C1BF0208  lfs f13, 0x208(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4B6C: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B4B70: C17F028C  lfs f11, 0x28c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B4B74: C15F020C  lfs f10, 0x20c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B4B78: CBEB0D30  lfd f31, 0xd30(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3376 as u32) ) };
	// 821B4B7C: ED2A5828  fsubs f9, f10, f11
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821B4B80: ED0C007A  fmadds f8, f12, f1, f0
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B4B84: EFC9587A  fmadds f30, f9, f1, f11
	ctx.f[30].f64 = (((ctx.f[9].f64 * ctx.f[1].f64 + ctx.f[11].f64) as f32) as f64);
	// 821B4B88: FCE807F2  fmul f7, f8, f31
	ctx.f[7].f64 = ctx.f[8].f64 * ctx.f[31].f64;
	// 821B4B8C: FC203818  frsp f1, f7
	ctx.f[1].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821B4B90: 480DF589  bl 0x82294118
	ctx.lr = 0x821B4B94;
	sub_82294118(ctx, base);
	// 821B4B94: FCC00818  frsp f6, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4B98: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 821B4B9C: FCBE07F2  fmul f5, f30, f31
	ctx.f[5].f64 = ctx.f[30].f64 * ctx.f[31].f64;
	// 821B4BA0: 3BBE9490  addi r29, r30, -0x6b70
	ctx.r[29].s64 = ctx.r[30].s64 + -27504;
	// 821B4BA4: C3FD1FF0  lfs f31, 0x1ff0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8176 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B4BA8: EC8607F2  fmuls f4, f6, f31
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B4BAC: D09F00B8  stfs f4, 0xb8(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821B4BB0: FC202818  frsp f1, f5
	ctx.f[1].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821B4BB4: 480DF565  bl 0x82294118
	ctx.lr = 0x821B4BB8;
	sub_82294118(ctx, base);
	// 821B4BB8: C07F0204  lfs f3, 0x204(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B4BBC: C01F0200  lfs f0, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4BC0: FD600818  frsp f11, f1
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4BC4: ED430028  fsubs f10, f3, f0
	ctx.f[10].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B4BC8: C13F00B8  lfs f9, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B4BCC: C1BDFFF4  lfs f13, -0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4BD0: 387F0110  addi r3, r31, 0x110
	ctx.r[3].s64 = ctx.r[31].s64 + 272;
	// 821B4BD4: EC3F4824  fdivs f1, f31, f9
	ctx.f[1].f64 = ((ctx.f[31].f64 / ctx.f[9].f64) as f32) as f64;
	// 821B4BD8: C19E9490  lfs f12, -0x6b70(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B4BDC: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821B4BE0: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	// 821B4BE4: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821B4BE8: FD006890  fmr f8, f13
	ctx.f[8].f64 = ctx.f[13].f64;
	// 821B4BEC: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	// 821B4BF0: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 821B4BF4: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	// 821B4BF8: FC406890  fmr f2, f13
	ctx.f[2].f64 = ctx.f[13].f64;
	// 821B4BFC: ECCB07F2  fmuls f6, f11, f31
	ctx.f[6].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B4C00: D0DF00BC  stfs f6, 0xbc(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 821B4C04: ED635024  fdivs f11, f3, f10
	ctx.f[11].f64 = ((ctx.f[3].f64 / ctx.f[10].f64) as f32) as f64;
	// 821B4C08: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 821B4C0C: FC606890  fmr f3, f13
	ctx.f[3].f64 = ctx.f[13].f64;
	// 821B4C10: ECDF3024  fdivs f6, f31, f6
	ctx.f[6].f64 = ((ctx.f[31].f64 / ctx.f[6].f64) as f32) as f64;
	// 821B4C14: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B4C18: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B4C1C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821B4C20: 4BFE8A71  bl 0x8219d690
	ctx.lr = 0x821B4C24;
	sub_8219D690(ctx, base);
	// 821B4C24: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821B4C28: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B4C2C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B4C30: 48AF482C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4C38 size=904
    let mut pc: u32 = 0x821B4C38;
    'dispatch: loop {
        match pc {
            0x821B4C38 => {
    //   block [0x821B4C38..0x821B4FC0)
	// 821B4C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4C3C: 48AF47D1  bl 0x82ca940c
	ctx.lr = 0x821B4C40;
	sub_82CA93D0(ctx, base);
	// 821B4C40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B4C48: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B4C4C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821B4C50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4C54: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B4C58: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 821B4C5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B4C60: 419A00F4  beq cr6, 0x821b4d54
	if ctx.cr[6].eq {
	pc = 0x821B4D54; continue 'dispatch;
	}
	// 821B4C64: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B4C68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4C6C: 419A0024  beq cr6, 0x821b4c90
	if ctx.cr[6].eq {
	pc = 0x821B4C90; continue 'dispatch;
	}
	// 821B4C70: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 821B4C74: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B4C78: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821B4C7C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B4C80: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4C84: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B4C88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B4C8C: 480000CC  b 0x821b4d58
	pc = 0x821B4D58; continue 'dispatch;
	// 821B4C90: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B4C94: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B4C98: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B4C9C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B4CA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B4CA4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4CA8: 40810054  ble 0x821b4cfc
	if !ctx.cr[0].gt {
	pc = 0x821B4CFC; continue 'dispatch;
	}
	// 821B4CAC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B4CB0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B4CB4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B4CB8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4CBC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821B4CC0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B4CC4: 41980008  blt cr6, 0x821b4ccc
	if ctx.cr[6].lt {
	pc = 0x821B4CCC; continue 'dispatch;
	}
	// 821B4CC8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821B4CCC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B4CD0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B4CD4: 419A0014  beq cr6, 0x821b4ce8
	if ctx.cr[6].eq {
	pc = 0x821B4CE8; continue 'dispatch;
	}
	// 821B4CD8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B4CDC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B4CE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B4CE4: 4800000C  b 0x821b4cf0
	pc = 0x821B4CF0; continue 'dispatch;
	// 821B4CE8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B4CEC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B4CF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4CF4: 4199FFB8  bgt cr6, 0x821b4cac
	if ctx.cr[6].gt {
	pc = 0x821B4CAC; continue 'dispatch;
	}
	// 821B4CF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B4CFC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B4D00: 419A0040  beq cr6, 0x821b4d40
	if ctx.cr[6].eq {
	pc = 0x821B4D40; continue 'dispatch;
	}
	// 821B4D04: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4D08: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821B4D0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B4D10: 41990008  bgt cr6, 0x821b4d18
	if ctx.cr[6].gt {
	pc = 0x821B4D18; continue 'dispatch;
	}
	// 821B4D14: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B4D18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B4D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4D20: 409A0020  bne cr6, 0x821b4d40
	if !ctx.cr[6].eq {
	pc = 0x821B4D40; continue 'dispatch;
	}
	// 821B4D24: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B4D28: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B4D2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B4D30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4D34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B4D38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B4D3C: 4800001C  b 0x821b4d58
	pc = 0x821B4D58; continue 'dispatch;
	// 821B4D40: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B4D44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4D48: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B4D4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B4D50: 48000008  b 0x821b4d58
	pc = 0x821B4D58; continue 'dispatch;
	// 821B4D54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B4D58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B4D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4D60: 419A0188  beq cr6, 0x821b4ee8
	if ctx.cr[6].eq {
	pc = 0x821B4EE8; continue 'dispatch;
	}
	// 821B4D64: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B4D68: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B4D6C: 419A005C  beq cr6, 0x821b4dc8
	if ctx.cr[6].eq {
	pc = 0x821B4DC8; continue 'dispatch;
	}
	// 821B4D70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4D78: 480F92A9  bl 0x822ae020
	ctx.lr = 0x821B4D7C;
	sub_822AE020(ctx, base);
	// 821B4D7C: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B4D80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4D84: 419A0040  beq cr6, 0x821b4dc4
	if ctx.cr[6].eq {
	pc = 0x821B4DC4; continue 'dispatch;
	}
	// 821B4D88: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821B4D8C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B4D90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4D94: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B4D98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B4D9C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B4DA0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4DA4: 4082FFE8  bne 0x821b4d8c
	if !ctx.cr[0].eq {
	pc = 0x821B4D8C; continue 'dispatch;
	}
	// 821B4DA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4DAC: 409A0014  bne cr6, 0x821b4dc0
	if !ctx.cr[6].eq {
	pc = 0x821B4DC0; continue 'dispatch;
	}
	// 821B4DB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4DB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4DB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4DBC: 4E800421  bctrl
	ctx.lr = 0x821B4DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4DC0: 93BE0018  stw r29, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 821B4DC4: 93BE0018  stw r29, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 821B4DC8: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B4DCC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B4DD0: 419A005C  beq cr6, 0x821b4e2c
	if ctx.cr[6].eq {
	pc = 0x821B4E2C; continue 'dispatch;
	}
	// 821B4DD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4DDC: 480F9245  bl 0x822ae020
	ctx.lr = 0x821B4DE0;
	sub_822AE020(ctx, base);
	// 821B4DE0: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B4DE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4DE8: 419A0040  beq cr6, 0x821b4e28
	if ctx.cr[6].eq {
	pc = 0x821B4E28; continue 'dispatch;
	}
	// 821B4DEC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821B4DF0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B4DF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4DF8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B4DFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B4E00: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B4E04: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4E08: 4082FFE8  bne 0x821b4df0
	if !ctx.cr[0].eq {
	pc = 0x821B4DF0; continue 'dispatch;
	}
	// 821B4E0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4E10: 409A0014  bne cr6, 0x821b4e24
	if !ctx.cr[6].eq {
	pc = 0x821B4E24; continue 'dispatch;
	}
	// 821B4E14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4E18: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4E1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4E20: 4E800421  bctrl
	ctx.lr = 0x821B4E24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4E24: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 821B4E28: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 821B4E2C: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B4E30: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B4E34: 419A005C  beq cr6, 0x821b4e90
	if ctx.cr[6].eq {
	pc = 0x821B4E90; continue 'dispatch;
	}
	// 821B4E38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4E40: 480F91E1  bl 0x822ae020
	ctx.lr = 0x821B4E44;
	sub_822AE020(ctx, base);
	// 821B4E44: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B4E48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4E4C: 419A0040  beq cr6, 0x821b4e8c
	if ctx.cr[6].eq {
	pc = 0x821B4E8C; continue 'dispatch;
	}
	// 821B4E50: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821B4E54: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B4E58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4E5C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B4E60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B4E64: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B4E68: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B4E6C: 4082FFE8  bne 0x821b4e54
	if !ctx.cr[0].eq {
	pc = 0x821B4E54; continue 'dispatch;
	}
	// 821B4E70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4E74: 409A0014  bne cr6, 0x821b4e88
	if !ctx.cr[6].eq {
	pc = 0x821B4E88; continue 'dispatch;
	}
	// 821B4E78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4E7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4E80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4E84: 4E800421  bctrl
	ctx.lr = 0x821B4E88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4E88: 93BE0020  stw r29, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 821B4E8C: 93BE0020  stw r29, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 821B4E90: 807E0044  lwz r3, 0x44(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 821B4E94: 3BFE0044  addi r31, r30, 0x44
	ctx.r[31].s64 = ctx.r[30].s64 + 68;
	// 821B4E98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4E9C: 419A0020  beq cr6, 0x821b4ebc
	if ctx.cr[6].eq {
	pc = 0x821B4EBC; continue 'dispatch;
	}
	// 821B4EA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4EA4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4EA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4EAC: 4E800421  bctrl
	ctx.lr = 0x821B4EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4EB4: 48002C65  bl 0x821b7b18
	ctx.lr = 0x821B4EB8;
	sub_821B7B18(ctx, base);
	// 821B4EB8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B4EBC: 807E004C  lwz r3, 0x4c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B4EC0: 3BFE004C  addi r31, r30, 0x4c
	ctx.r[31].s64 = ctx.r[30].s64 + 76;
	// 821B4EC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4EC8: 419A0020  beq cr6, 0x821b4ee8
	if ctx.cr[6].eq {
	pc = 0x821B4EE8; continue 'dispatch;
	}
	// 821B4ECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4ED0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4ED4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4ED8: 4E800421  bctrl
	ctx.lr = 0x821B4EDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4EE0: 48002C39  bl 0x821b7b18
	ctx.lr = 0x821B4EE4;
	sub_821B7B18(ctx, base);
	// 821B4EE4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B4EE8: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B4EEC: 3BFE002C  addi r31, r30, 0x2c
	ctx.r[31].s64 = ctx.r[30].s64 + 44;
	// 821B4EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4EF4: 419A0020  beq cr6, 0x821b4f14
	if ctx.cr[6].eq {
	pc = 0x821B4F14; continue 'dispatch;
	}
	// 821B4EF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4EFC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4F00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4F04: 4E800421  bctrl
	ctx.lr = 0x821B4F08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4F0C: 48002C0D  bl 0x821b7b18
	ctx.lr = 0x821B4F10;
	sub_821B7B18(ctx, base);
	// 821B4F10: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B4F14: 807E0034  lwz r3, 0x34(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B4F18: 3BFE0034  addi r31, r30, 0x34
	ctx.r[31].s64 = ctx.r[30].s64 + 52;
	// 821B4F1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4F20: 419A0020  beq cr6, 0x821b4f40
	if ctx.cr[6].eq {
	pc = 0x821B4F40; continue 'dispatch;
	}
	// 821B4F24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4F28: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4F2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4F30: 4E800421  bctrl
	ctx.lr = 0x821B4F34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4F38: 48002BE1  bl 0x821b7b18
	ctx.lr = 0x821B4F3C;
	sub_821B7B18(ctx, base);
	// 821B4F3C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B4F40: 807E0024  lwz r3, 0x24(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B4F44: 3BFE0024  addi r31, r30, 0x24
	ctx.r[31].s64 = ctx.r[30].s64 + 36;
	// 821B4F48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4F4C: 419A0020  beq cr6, 0x821b4f6c
	if ctx.cr[6].eq {
	pc = 0x821B4F6C; continue 'dispatch;
	}
	// 821B4F50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4F54: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4F58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4F5C: 4E800421  bctrl
	ctx.lr = 0x821B4F60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4F64: 48002BB5  bl 0x821b7b18
	ctx.lr = 0x821B4F68;
	sub_821B7B18(ctx, base);
	// 821B4F68: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B4F6C: 807E003C  lwz r3, 0x3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B4F70: 3BFE003C  addi r31, r30, 0x3c
	ctx.r[31].s64 = ctx.r[30].s64 + 60;
	// 821B4F74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4F78: 419A0020  beq cr6, 0x821b4f98
	if ctx.cr[6].eq {
	pc = 0x821B4F98; continue 'dispatch;
	}
	// 821B4F7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4F80: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4F84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4F88: 4E800421  bctrl
	ctx.lr = 0x821B4F8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4F90: 48002B89  bl 0x821b7b18
	ctx.lr = 0x821B4F94;
	sub_821B7B18(ctx, base);
	// 821B4F94: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B4F98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4FA0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B4FA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B4FA8: 4E800421  bctrl
	ctx.lr = 0x821B4FAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4FAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B4FB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4FB4: 480D3735  bl 0x822886e8
	ctx.lr = 0x821B4FB8;
	sub_822886E8(ctx, base);
	// 821B4FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B4FBC: 48AF44A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4FC0 size=380
    let mut pc: u32 = 0x821B4FC0;
    'dispatch: loop {
        match pc {
            0x821B4FC0 => {
    //   block [0x821B4FC0..0x821B513C)
	// 821B4FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4FC4: 48AF4449  bl 0x82ca940c
	ctx.lr = 0x821B4FC8;
	sub_82CA93D0(ctx, base);
	// 821B4FC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4FCC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B4FD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B4FD4: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 821B4FD8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B4FDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B4FE0: 419A0014  beq cr6, 0x821b4ff4
	if ctx.cr[6].eq {
	pc = 0x821B4FF4; continue 'dispatch;
	}
	// 821B4FE4: 480E2355  bl 0x82297338
	ctx.lr = 0x821B4FE8;
	sub_82297338(ctx, base);
	// 821B4FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4FEC: 48002B2D  bl 0x821b7b18
	ctx.lr = 0x821B4FF0;
	sub_821B7B18(ctx, base);
	// 821B4FF0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B4FF4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B4FF8: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821B4FFC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B5000: 55289FFE  rlwinm r8, r9, 0x13, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00001FFFu64;
	// 821B5004: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B5008: 419A00F4  beq cr6, 0x821b50fc
	if ctx.cr[6].eq {
	pc = 0x821B50FC; continue 'dispatch;
	}
	// 821B500C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B5010: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B5014: 419A0024  beq cr6, 0x821b5038
	if ctx.cr[6].eq {
	pc = 0x821B5038; continue 'dispatch;
	}
	// 821B5018: 892A006D  lbz r9, 0x6d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(109 as u32) ) } as u64;
	// 821B501C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B5020: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821B5024: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B5028: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B502C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B5030: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B5034: 480000CC  b 0x821b5100
	pc = 0x821B5100; continue 'dispatch;
	// 821B5038: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B503C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B5040: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B5044: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B5048: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B504C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B5050: 40810054  ble 0x821b50a4
	if !ctx.cr[0].gt {
	pc = 0x821B50A4; continue 'dispatch;
	}
	// 821B5054: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B5058: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B505C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B5060: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5064: 2F07006D  cmpwi cr6, r7, 0x6d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 109, &mut ctx.xer);
	// 821B5068: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B506C: 41980008  blt cr6, 0x821b5074
	if ctx.cr[6].lt {
	pc = 0x821B5074; continue 'dispatch;
	}
	// 821B5070: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B5074: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B5078: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B507C: 419A0014  beq cr6, 0x821b5090
	if ctx.cr[6].eq {
	pc = 0x821B5090; continue 'dispatch;
	}
	// 821B5080: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B5084: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B5088: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B508C: 4800000C  b 0x821b5098
	pc = 0x821B5098; continue 'dispatch;
	// 821B5090: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B5094: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B5098: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B509C: 4199FFB8  bgt cr6, 0x821b5054
	if ctx.cr[6].gt {
	pc = 0x821B5054; continue 'dispatch;
	}
	// 821B50A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B50A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B50A8: 419A0040  beq cr6, 0x821b50e8
	if ctx.cr[6].eq {
	pc = 0x821B50E8; continue 'dispatch;
	}
	// 821B50AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B50B0: 2F0B006D  cmpwi cr6, r11, 0x6d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 109, &mut ctx.xer);
	// 821B50B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B50B8: 41990008  bgt cr6, 0x821b50c0
	if ctx.cr[6].gt {
	pc = 0x821B50C0; continue 'dispatch;
	}
	// 821B50BC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B50C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B50C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B50C8: 409A0020  bne cr6, 0x821b50e8
	if !ctx.cr[6].eq {
	pc = 0x821B50E8; continue 'dispatch;
	}
	// 821B50CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B50D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B50D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B50D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B50DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B50E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B50E4: 4800001C  b 0x821b5100
	pc = 0x821B5100; continue 'dispatch;
	// 821B50E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B50EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B50F0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B50F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B50F8: 48000008  b 0x821b5100
	pc = 0x821B5100; continue 'dispatch;
	// 821B50FC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B5100: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5108: 419A0018  beq cr6, 0x821b5120
	if ctx.cr[6].eq {
	pc = 0x821B5120; continue 'dispatch;
	}
	// 821B510C: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B5110: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B5114: 419A000C  beq cr6, 0x821b5120
	if ctx.cr[6].eq {
	pc = 0x821B5120; continue 'dispatch;
	}
	// 821B5118: 93CA0050  stw r30, 0x50(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B511C: 93CA005C  stw r30, 0x5c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821B5120: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5124: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B5128: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B512C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B5130: 4E800421  bctrl
	ctx.lr = 0x821B5134;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B5134: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B5138: 48AF4324  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5140 size=204
    let mut pc: u32 = 0x821B5140;
    'dispatch: loop {
        match pc {
            0x821B5140 => {
    //   block [0x821B5140..0x821B520C)
	// 821B5140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5144: 48AF42B1  bl 0x82ca93f4
	ctx.lr = 0x821B5148;
	sub_82CA93D0(ctx, base);
	// 821B5148: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B514C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B5150: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821B5154: 3B0B02B0  addi r24, r11, 0x2b0
	ctx.r[24].s64 = ctx.r[11].s64 + 688;
	// 821B5158: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 821B515C: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 821B5160: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5168: 419A000C  beq cr6, 0x821b5174
	if ctx.cr[6].eq {
	pc = 0x821B5174; continue 'dispatch;
	}
	// 821B516C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B5170: 489B13C1  bl 0x82b66530
	ctx.lr = 0x821B5174;
	sub_82B66530(ctx, base);
	// 821B5174: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821B5178: 39780050  addi r11, r24, 0x50
	ctx.r[11].s64 = ctx.r[24].s64 + 80;
	// 821B517C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821B5180: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B5184: 4198FFDC  blt cr6, 0x821b5160
	if ctx.cr[6].lt {
	pc = 0x821B5160; continue 'dispatch;
	}
	// 821B5188: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B518C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821B5190: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B5194: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 821B5198: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 821B519C: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 821B51A0: 793DFFE6  rldicr r29, r9, 0x3f, 0x3f
	ctx.r[29].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B51A4: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821B51A8: 3B4A02A0  addi r26, r10, 0x2a0
	ctx.r[26].s64 = ctx.r[10].s64 + 672;
	// 821B51AC: 3B8BB0BC  addi r28, r11, -0x4f44
	ctx.r[28].s64 = ctx.r[11].s64 + -20292;
	// 821B51B0: 7D7ED02E  lwzx r11, r30, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 821B51B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B51B8: 419A003C  beq cr6, 0x821b51f4
	if ctx.cr[6].eq {
	pc = 0x821B51F4; continue 'dispatch;
	}
	// 821B51BC: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 821B51C0: 39780040  addi r11, r24, 0x40
	ctx.r[11].s64 = ctx.r[24].s64 + 64;
	// 821B51C4: 41980008  blt cr6, 0x821b51cc
	if ctx.cr[6].lt {
	pc = 0x821B51CC; continue 'dispatch;
	}
	// 821B51C8: 397A0040  addi r11, r26, 0x40
	ctx.r[11].s64 = ctx.r[26].s64 + 64;
	// 821B51CC: 7EFE592E  stwx r23, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[23].u32) };
	// 821B51D0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B51D4: 41980020  blt cr6, 0x821b51f4
	if ctx.cr[6].lt {
	pc = 0x821B51F4; continue 'dispatch;
	}
	// 821B51D8: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821B51DC: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B51E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B51E4: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B51E8: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821B51EC: 7FA65436  srd r6, r29, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821B51F0: 48001CF1  bl 0x821b6ee0
	ctx.lr = 0x821B51F4;
	sub_821B6EE0(ctx, base);
	// 821B51F4: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821B51F8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B51FC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B5200: 4082FFB0  bne 0x821b51b0
	if !ctx.cr[0].eq {
	pc = 0x821B51B0; continue 'dispatch;
	}
	// 821B5204: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B5208: 48AF423C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5210 size=76
    let mut pc: u32 = 0x821B5210;
    'dispatch: loop {
        match pc {
            0x821B5210 => {
    //   block [0x821B5210..0x821B525C)
	// 821B5210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B521C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B5224: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5228: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B522C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B5230: 4E800421  bctrl
	ctx.lr = 0x821B5234;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B5234: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B523C: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B5240: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821B5244: 4E800421  bctrl
	ctx.lr = 0x821B5248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B5248: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B524C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B5250: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5254: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B5258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5260 size=236
    let mut pc: u32 = 0x821B5260;
    'dispatch: loop {
        match pc {
            0x821B5260 => {
    //   block [0x821B5260..0x821B534C)
	// 821B5260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B526C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B5270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5274: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B5278: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B527C: 48298F4D  bl 0x8244e1c8
	ctx.lr = 0x821B5280;
	sub_8244E1C8(ctx, base);
	// 821B5280: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B5284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5288: 419A00A8  beq cr6, 0x821b5330
	if ctx.cr[6].eq {
	pc = 0x821B5330; continue 'dispatch;
	}
	// 821B528C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B5290: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B5294: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5298: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B529C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B52A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B52A4: 419A0014  beq cr6, 0x821b52b8
	if ctx.cr[6].eq {
	pc = 0x821B52B8; continue 'dispatch;
	}
	// 821B52A8: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 821B52AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B52B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B52B4: 409A0008  bne cr6, 0x821b52bc
	if !ctx.cr[6].eq {
	pc = 0x821B52BC; continue 'dispatch;
	}
	// 821B52B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B52BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B52C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B52C4: 419A006C  beq cr6, 0x821b5330
	if ctx.cr[6].eq {
	pc = 0x821B5330; continue 'dispatch;
	}
	// 821B52C8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B52CC: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B52D0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B52D4: 419A0020  beq cr6, 0x821b52f4
	if ctx.cr[6].eq {
	pc = 0x821B52F4; continue 'dispatch;
	}
	// 821B52D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B52DC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B52E0: 7F08F800  cmpw cr6, r8, r31
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[31].s32, &mut ctx.xer);
	// 821B52E4: 419A0044  beq cr6, 0x821b5328
	if ctx.cr[6].eq {
	pc = 0x821B5328; continue 'dispatch;
	}
	// 821B52E8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B52EC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B52F0: 409AFFE8  bne cr6, 0x821b52d8
	if !ctx.cr[6].eq {
	pc = 0x821B52D8; continue 'dispatch;
	}
	// 821B52F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B52F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B52FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5300: 409A0030  bne cr6, 0x821b5330
	if !ctx.cr[6].eq {
	pc = 0x821B5330; continue 'dispatch;
	}
	// 821B5304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B5308: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B530C: 480F4145  bl 0x822a9450
	ctx.lr = 0x821B5310;
	sub_822A9450(ctx, base);
	// 821B5310: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B5314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5318: 409A0018  bne cr6, 0x821b5330
	if !ctx.cr[6].eq {
	pc = 0x821B5330; continue 'dispatch;
	}
	// 821B531C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B5320: 4BFE5B71  bl 0x8219ae90
	ctx.lr = 0x821B5324;
	sub_8219AE90(ctx, base);
	// 821B5324: 48000010  b 0x821b5334
	pc = 0x821B5334; continue 'dispatch;
	// 821B5328: 896A002C  lbz r11, 0x2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B532C: 4BFFFFCC  b 0x821b52f8
	pc = 0x821B52F8; continue 'dispatch;
	// 821B5330: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5334: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B5338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B533C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5340: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B5344: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B5348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5350 size=320
    let mut pc: u32 = 0x821B5350;
    'dispatch: loop {
        match pc {
            0x821B5350 => {
    //   block [0x821B5350..0x821B5490)
	// 821B5350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5354: 48AF40A9  bl 0x82ca93fc
	ctx.lr = 0x821B5358;
	sub_82CA93D0(ctx, base);
	// 821B5358: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B535C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B5360: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B5364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5368: 409A0120  bne cr6, 0x821b5488
	if !ctx.cr[6].eq {
	pc = 0x821B5488; continue 'dispatch;
	}
	// 821B536C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821B5370: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 821B5374: 3B6B6EC8  addi r27, r11, 0x6ec8
	ctx.r[27].s64 = ctx.r[11].s64 + 28360;
	// 821B5378: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B537C: 9B3F0039  stb r25, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[25].u8 ) };
	// 821B5380: 3BDF003C  addi r30, r31, 0x3c
	ctx.r[30].s64 = ctx.r[31].s64 + 60;
	// 821B5384: 9B3F003A  stb r25, 0x3a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[25].u8 ) };
	// 821B5388: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 821B538C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B5390: 3B4B7088  addi r26, r11, 0x7088
	ctx.r[26].s64 = ctx.r[11].s64 + 28808;
	// 821B5394: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B5398: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B539C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B53A0: 48077B31  bl 0x8222ced0
	ctx.lr = 0x821B53A4;
	sub_8222CED0(ctx, base);
	// 821B53A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B53A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B53AC: 4800015D  bl 0x821b5508
	ctx.lr = 0x821B53B0;
	sub_821B5508(ctx, base);
	// 821B53B0: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B53B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B53B8: 480113B1  bl 0x821c6768
	ctx.lr = 0x821B53BC;
	sub_821C6768(ctx, base);
	// 821B53BC: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821B53C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B53C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B53C8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B53CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B53D0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B53D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B53D8: 4082FFE8  bne 0x821b53c0
	if !ctx.cr[0].eq {
	pc = 0x821B53C0; continue 'dispatch;
	}
	// 821B53DC: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B53E0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B53E4: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821B53E8: 409A0008  bne cr6, 0x821b53f0
	if !ctx.cr[6].eq {
	pc = 0x821B53F0; continue 'dispatch;
	}
	// 821B53EC: 9B9F0039  stb r28, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[28].u8 ) };
	// 821B53F0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B53F4: 397B0014  addi r11, r27, 0x14
	ctx.r[11].s64 = ctx.r[27].s64 + 20;
	// 821B53F8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B53FC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B5400: 4198FF94  blt cr6, 0x821b5394
	if ctx.cr[6].lt {
	pc = 0x821B5394; continue 'dispatch;
	}
	// 821B5404: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821B5408: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 821B540C: 3B6B6EDC  addi r27, r11, 0x6edc
	ctx.r[27].s64 = ctx.r[11].s64 + 28380;
	// 821B5410: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 821B5414: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B5418: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B541C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B5420: 48077AB1  bl 0x8222ced0
	ctx.lr = 0x821B5424;
	sub_8222CED0(ctx, base);
	// 821B5424: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B5428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B542C: 480000DD  bl 0x821b5508
	ctx.lr = 0x821B5430;
	sub_821B5508(ctx, base);
	// 821B5430: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B5434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B5438: 48011331  bl 0x821c6768
	ctx.lr = 0x821B543C;
	sub_821C6768(ctx, base);
	// 821B543C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821B5440: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B5444: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B5448: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B544C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B5450: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B5454: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B5458: 4082FFE8  bne 0x821b5440
	if !ctx.cr[0].eq {
	pc = 0x821B5440; continue 'dispatch;
	}
	// 821B545C: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5460: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B5464: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821B5468: 409A0008  bne cr6, 0x821b5470
	if !ctx.cr[6].eq {
	pc = 0x821B5470; continue 'dispatch;
	}
	// 821B546C: 9B9F003A  stb r28, 0x3a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[28].u8 ) };
	// 821B5470: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B5474: 397B0018  addi r11, r27, 0x18
	ctx.r[11].s64 = ctx.r[27].s64 + 24;
	// 821B5478: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B547C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B5480: 4198FF94  blt cr6, 0x821b5414
	if ctx.cr[6].lt {
	pc = 0x821B5414; continue 'dispatch;
	}
	// 821B5484: 9B3F0038  stb r25, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[25].u8 ) };
	// 821B5488: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B548C: 48AF3FC0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5490 size=120
    let mut pc: u32 = 0x821B5490;
    'dispatch: loop {
        match pc {
            0x821B5490 => {
    //   block [0x821B5490..0x821B5508)
	// 821B5490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5498: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B549C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B54A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B54A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B54A8: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B54AC: 4811E19D  bl 0x822d3648
	ctx.lr = 0x821B54B0;
	sub_822D3648(ctx, base);
	// 821B54B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B54B4: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 821B54B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B54BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B54C0: C02B9484  lfs f1, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B54C4: 4803F8D5  bl 0x821f4d98
	ctx.lr = 0x821B54C8;
	sub_821F4D98(ctx, base);
	// 821B54C8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B54CC: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 821B54D0: 390A90F0  addi r8, r10, -0x6f10
	ctx.r[8].s64 = ctx.r[10].s64 + -28432;
	// 821B54D4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5508 size=152
    let mut pc: u32 = 0x821B5508;
    'dispatch: loop {
        match pc {
            0x821B5508 => {
    //   block [0x821B5508..0x821B55A0)
	// 821B5508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B550C: 48AF3EFD  bl 0x82ca9408
	ctx.lr = 0x821B5510;
	sub_82CA93D0(ctx, base);
	// 821B5510: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5514: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B5518: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B551C: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B5520: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B5524: 7D3C1E71  srawi. r28, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821B5528: 41820060  beq 0x821b5588
	if ctx.cr[0].eq {
	pc = 0x821B5588; continue 'dispatch;
	}
	// 821B552C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B5530: 83C40000  lwz r30, 0(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5534: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 821B5538: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B553C: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B5540: 409A000C  bne cr6, 0x821b554c
	if !ctx.cr[6].eq {
	pc = 0x821B554C; continue 'dispatch;
	}
	// 821B5544: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B5548: 48000024  b 0x821b556c
	pc = 0x821B556C; continue 'dispatch;
	// 821B554C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B5550: 419A0018  beq cr6, 0x821b5568
	if ctx.cr[6].eq {
	pc = 0x821B5568; continue 'dispatch;
	}
	// 821B5554: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B5558: 419A0010  beq cr6, 0x821b5568
	if ctx.cr[6].eq {
	pc = 0x821B5568; continue 'dispatch;
	}
	// 821B555C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B5560: 480B8231  bl 0x8226d790
	ctx.lr = 0x821B5564;
	sub_8226D790(ctx, base);
	// 821B5564: 48000008  b 0x821b556c
	pc = 0x821B556C; continue 'dispatch;
	// 821B5568: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B556C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B5570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5574: 409A0020  bne cr6, 0x821b5594
	if !ctx.cr[6].eq {
	pc = 0x821B5594; continue 'dispatch;
	}
	// 821B5578: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821B557C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821B5580: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B5584: 409AFFB4  bne cr6, 0x821b5538
	if !ctx.cr[6].eq {
	pc = 0x821B5538; continue 'dispatch;
	}
	// 821B5588: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821B558C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B5590: 48AF3EC8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821B5594: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B5598: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B559C: 48AF3EBC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B55A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B55A0 size=140
    let mut pc: u32 = 0x821B55A0;
    'dispatch: loop {
        match pc {
            0x821B55A0 => {
    //   block [0x821B55A0..0x821B562C)
	// 821B55A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B55A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B55A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B55AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B55B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B55B4: 83C30024  lwz r30, 0x24(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B55B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B55BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B55C0: 419A0050  beq cr6, 0x821b5610
	if ctx.cr[6].eq {
	pc = 0x821B5610; continue 'dispatch;
	}
	// 821B55C4: 38830014  addi r4, r3, 0x14
	ctx.r[4].s64 = ctx.r[3].s64 + 20;
	// 821B55C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B55CC: 4803956D  bl 0x821eeb38
	ctx.lr = 0x821B55D0;
	sub_821EEB38(ctx, base);
	// 821B55D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B55D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B55D8: 481FB4D1  bl 0x823b0aa8
	ctx.lr = 0x821B55DC;
	sub_823B0AA8(ctx, base);
	// 821B55DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B55E0: 4805F7F9  bl 0x82214dd8
	ctx.lr = 0x821B55E4;
	sub_82214DD8(ctx, base);
	// 821B55E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B55E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B55EC: 388B00AC  addi r4, r11, 0xac
	ctx.r[4].s64 = ctx.r[11].s64 + 172;
	// 821B55F0: 48039549  bl 0x821eeb38
	ctx.lr = 0x821B55F4;
	sub_821EEB38(ctx, base);
	// 821B55F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B55F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B55FC: 481FB4AD  bl 0x823b0aa8
	ctx.lr = 0x821B5600;
	sub_823B0AA8(ctx, base);
	// 821B5600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B5604: 4805F7D5  bl 0x82214dd8
	ctx.lr = 0x821B5608;
	sub_82214DD8(ctx, base);
	// 821B5608: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821B560C: 48000008  b 0x821b5614
	pc = 0x821B5614; continue 'dispatch;
	// 821B5610: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5614: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B5618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B561C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5620: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B5624: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B5628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5630 size=8
    let mut pc: u32 = 0x821B5630;
    'dispatch: loop {
        match pc {
            0x821B5630 => {
    //   block [0x821B5630..0x821B5638)
	// 821B5630: 806300FC  lwz r3, 0xfc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) } as u64;
	// 821B5634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5638 size=2812
    let mut pc: u32 = 0x821B5638;
    'dispatch: loop {
        match pc {
            0x821B5638 => {
    //   block [0x821B5638..0x821B6134)
	// 821B5638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B563C: 48AF3D95  bl 0x82ca93d0
	ctx.lr = 0x821B5640;
	sub_82CA93D0(ctx, base);
	// 821B5640: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821B5644: 48AF868D  bl 0x82cadcd0
	ctx.lr = 0x821B5648;
	sub_82CADCA0(ctx, base);
	// 821B5648: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6138 size=796
    let mut pc: u32 = 0x821B6138;
    'dispatch: loop {
        match pc {
            0x821B6138 => {
    //   block [0x821B6138..0x821B6454)
	// 821B6138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B613C: 48AF32C9  bl 0x82ca9404
	ctx.lr = 0x821B6140;
	sub_82CA93D0(ctx, base);
	// 821B6140: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6144: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B6148: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B614C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 821B6150: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821B6154: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B615C: 419A0020  beq cr6, 0x821b617c
	if ctx.cr[6].eq {
	pc = 0x821B617C; continue 'dispatch;
	}
	// 821B6160: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6164: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6168: 419A000C  beq cr6, 0x821b6174
	if ctx.cr[6].eq {
	pc = 0x821B6174; continue 'dispatch;
	}
	// 821B616C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B6170: 48000010  b 0x821b6180
	pc = 0x821B6180; continue 'dispatch;
	// 821B6174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B6178: 4BFDDCC1  bl 0x82193e38
	ctx.lr = 0x821B617C;
	sub_82193E38(ctx, base);
	// 821B617C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B6180: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B6184: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821B6188: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 821B618C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B6190: 419A00F4  beq cr6, 0x821b6284
	if ctx.cr[6].eq {
	pc = 0x821B6284; continue 'dispatch;
	}
	// 821B6194: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B6198: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B619C: 419A0024  beq cr6, 0x821b61c0
	if ctx.cr[6].eq {
	pc = 0x821B61C0; continue 'dispatch;
	}
	// 821B61A0: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 821B61A4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B61A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B61AC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B61B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B61B4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B61B8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B61BC: 480000CC  b 0x821b6288
	pc = 0x821B6288; continue 'dispatch;
	// 821B61C0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B61C4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B61C8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B61CC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B61D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B61D4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B61D8: 40810054  ble 0x821b622c
	if !ctx.cr[0].gt {
	pc = 0x821B622C; continue 'dispatch;
	}
	// 821B61DC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B61E0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B61E4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B61E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B61EC: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821B61F0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B61F4: 41980008  blt cr6, 0x821b61fc
	if ctx.cr[6].lt {
	pc = 0x821B61FC; continue 'dispatch;
	}
	// 821B61F8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821B61FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B6200: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B6204: 419A0014  beq cr6, 0x821b6218
	if ctx.cr[6].eq {
	pc = 0x821B6218; continue 'dispatch;
	}
	// 821B6208: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B620C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B6210: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6214: 4800000C  b 0x821b6220
	pc = 0x821B6220; continue 'dispatch;
	// 821B6218: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B621C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B6220: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6224: 4199FFB8  bgt cr6, 0x821b61dc
	if ctx.cr[6].gt {
	pc = 0x821B61DC; continue 'dispatch;
	}
	// 821B6228: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B622C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B6230: 419A0040  beq cr6, 0x821b6270
	if ctx.cr[6].eq {
	pc = 0x821B6270; continue 'dispatch;
	}
	// 821B6234: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6238: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821B623C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B6240: 41990008  bgt cr6, 0x821b6248
	if ctx.cr[6].gt {
	pc = 0x821B6248; continue 'dispatch;
	}
	// 821B6244: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B6248: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B624C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6250: 409A0020  bne cr6, 0x821b6270
	if !ctx.cr[6].eq {
	pc = 0x821B6270; continue 'dispatch;
	}
	// 821B6254: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6258: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B625C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B6260: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6264: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B6268: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B626C: 4800001C  b 0x821b6288
	pc = 0x821B6288; continue 'dispatch;
	// 821B6270: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B6274: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6278: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B627C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B6280: 48000008  b 0x821b6288
	pc = 0x821B6288; continue 'dispatch;
	// 821B6284: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B6288: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B628C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6290: 419A0034  beq cr6, 0x821b62c4
	if ctx.cr[6].eq {
	pc = 0x821B62C4; continue 'dispatch;
	}
	// 821B6294: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B6298: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B629C: 388B0E58  addi r4, r11, 0xe58
	ctx.r[4].s64 = ctx.r[11].s64 + 3672;
	// 821B62A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B62A4: 48076C2D  bl 0x8222ced0
	ctx.lr = 0x821B62A8;
	sub_8222CED0(ctx, base);
	// 821B62A8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B62AC: 38BC0028  addi r5, r28, 0x28
	ctx.r[5].s64 = ctx.r[28].s64 + 40;
	// 821B62B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B62B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B62B8: 48088171  bl 0x8223e428
	ctx.lr = 0x821B62BC;
	sub_8223E428(ctx, base);
	// 821B62BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B62C0: 4805EB19  bl 0x82214dd8
	ctx.lr = 0x821B62C4;
	sub_82214DD8(ctx, base);
	// 821B62C4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B62C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B62CC: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B62D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B62D4: 4E800421  bctrl
	ctx.lr = 0x821B62D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B62D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B62DC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821B62E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B62E4: 419A0030  beq cr6, 0x821b6314
	if ctx.cr[6].eq {
	pc = 0x821B6314; continue 'dispatch;
	}
	// 821B62E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B62EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B62F0: 419A0078  beq cr6, 0x821b6368
	if ctx.cr[6].eq {
	pc = 0x821B6368; continue 'dispatch;
	}
	// 821B62F4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B62F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B62FC: 419A0018  beq cr6, 0x821b6314
	if ctx.cr[6].eq {
	pc = 0x821B6314; continue 'dispatch;
	}
	// 821B6300: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B6304: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6308: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B630C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6310: 409A0008  bne cr6, 0x821b6318
	if !ctx.cr[6].eq {
	pc = 0x821B6318; continue 'dispatch;
	}
	// 821B6314: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B6318: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B631C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6320: 419A0128  beq cr6, 0x821b6448
	if ctx.cr[6].eq {
	pc = 0x821B6448; continue 'dispatch;
	}
	// 821B6324: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B6328: 4BFBE141  bl 0x82174468
	ctx.lr = 0x821B632C;
	sub_82174468(ctx, base);
	// 821B632C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B6330: 556A97FE  rlwinm r10, r11, 0x12, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 821B6334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6338: 419A00FC  beq cr6, 0x821b6434
	if ctx.cr[6].eq {
	pc = 0x821B6434; continue 'dispatch;
	}
	// 821B633C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B6340: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B6344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6348: 419A002C  beq cr6, 0x821b6374
	if ctx.cr[6].eq {
	pc = 0x821B6374; continue 'dispatch;
	}
	// 821B634C: 896B006E  lbz r11, 0x6e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(110 as u32) ) } as u64;
	// 821B6350: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821B6354: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B6358: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B635C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B6360: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B6364: 480000D4  b 0x821b6438
	pc = 0x821B6438; continue 'dispatch;
	// 821B6368: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B636C: 4BFDDACD  bl 0x82193e38
	ctx.lr = 0x821B6370;
	sub_82193E38(ctx, base);
	// 821B6370: 4BFFFFA4  b 0x821b6314
	pc = 0x821B6314; continue 'dispatch;
	// 821B6374: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B6378: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B637C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B6380: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B6384: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6388: 40810054  ble 0x821b63dc
	if !ctx.cr[0].gt {
	pc = 0x821B63DC; continue 'dispatch;
	}
	// 821B638C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B6390: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B6394: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B6398: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B639C: 2F07006E  cmpwi cr6, r7, 0x6e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 110, &mut ctx.xer);
	// 821B63A0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B63A4: 41980008  blt cr6, 0x821b63ac
	if ctx.cr[6].lt {
	pc = 0x821B63AC; continue 'dispatch;
	}
	// 821B63A8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821B63AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B63B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B63B4: 419A0014  beq cr6, 0x821b63c8
	if ctx.cr[6].eq {
	pc = 0x821B63C8; continue 'dispatch;
	}
	// 821B63B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B63BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B63C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B63C4: 4800000C  b 0x821b63d0
	pc = 0x821B63D0; continue 'dispatch;
	// 821B63C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B63CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B63D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B63D4: 4199FFB8  bgt cr6, 0x821b638c
	if ctx.cr[6].gt {
	pc = 0x821B638C; continue 'dispatch;
	}
	// 821B63D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B63DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B63E0: 419A0040  beq cr6, 0x821b6420
	if ctx.cr[6].eq {
	pc = 0x821B6420; continue 'dispatch;
	}
	// 821B63E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B63E8: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 821B63EC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B63F0: 41990008  bgt cr6, 0x821b63f8
	if ctx.cr[6].gt {
	pc = 0x821B63F8; continue 'dispatch;
	}
	// 821B63F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B63F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B63FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6400: 409A0020  bne cr6, 0x821b6420
	if !ctx.cr[6].eq {
	pc = 0x821B6420; continue 'dispatch;
	}
	// 821B6404: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6408: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B640C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B6410: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6414: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B6418: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B641C: 4800001C  b 0x821b6438
	pc = 0x821B6438; continue 'dispatch;
	// 821B6420: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B6424: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6428: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B642C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B6430: 48000008  b 0x821b6438
	pc = 0x821B6438; continue 'dispatch;
	// 821B6434: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B6438: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B643C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6440: 419A0008  beq cr6, 0x821b6448
	if ctx.cr[6].eq {
	pc = 0x821B6448; continue 'dispatch;
	}
	// 821B6444: 9BBF00C0  stb r29, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[29].u8 ) };
	// 821B6448: 9B7C0048  stb r27, 0x48(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(72 as u32), ctx.r[27].u8 ) };
	// 821B644C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B6450: 48AF3004  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6458 size=444
    let mut pc: u32 = 0x821B6458;
    'dispatch: loop {
        match pc {
            0x821B6458 => {
    //   block [0x821B6458..0x821B6614)
	// 821B6458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B645C: 48AF2FAD  bl 0x82ca9408
	ctx.lr = 0x821B6460;
	sub_82CA93D0(ctx, base);
	// 821B6460: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6464: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B6468: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B646C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821B6470: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821B6474: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B6478: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B647C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B6480: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B6484: 4805E415  bl 0x82214898
	ctx.lr = 0x821B6488;
	sub_82214898(ctx, base);
	// 821B6488: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 821B648C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B6490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6494: 4831BA35  bl 0x824d1ec8
	ctx.lr = 0x821B6498;
	sub_824D1EC8(ctx, base);
	// 821B6498: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821B649C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B64A0: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 821B64A4: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821B64A8: 4BFDD991  bl 0x82193e38
	ctx.lr = 0x821B64AC;
	sub_82193E38(ctx, base);
	// 821B64AC: 80FD0038  lwz r7, 0x38(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B64B0: 939D003C  stw r28, 0x3c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 821B64B4: 54E6F7FE  rlwinm r6, r7, 0x1e, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 821B64B8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821B64BC: 419A0134  beq cr6, 0x821b65f0
	if ctx.cr[6].eq {
	pc = 0x821B65F0; continue 'dispatch;
	}
	// 821B64C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B64C4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821B64C8: 4BFBD971  bl 0x82173e38
	ctx.lr = 0x821B64CC;
	sub_82173E38(ctx, base);
	// 821B64CC: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B64D0: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 821B64D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B64D8: 419A00F4  beq cr6, 0x821b65cc
	if ctx.cr[6].eq {
	pc = 0x821B65CC; continue 'dispatch;
	}
	// 821B64DC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B64E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B64E4: 419A0024  beq cr6, 0x821b6508
	if ctx.cr[6].eq {
	pc = 0x821B6508; continue 'dispatch;
	}
	// 821B64E8: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 821B64EC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B64F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B64F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B64F8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B64FC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B6500: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B6504: 480000CC  b 0x821b65d0
	pc = 0x821B65D0; continue 'dispatch;
	// 821B6508: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B650C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B6510: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B6514: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B6518: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B651C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6520: 40810054  ble 0x821b6574
	if !ctx.cr[0].gt {
	pc = 0x821B6574; continue 'dispatch;
	}
	// 821B6524: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B6528: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B652C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B6530: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6534: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 821B6538: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B653C: 41980008  blt cr6, 0x821b6544
	if ctx.cr[6].lt {
	pc = 0x821B6544; continue 'dispatch;
	}
	// 821B6540: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B6544: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B6548: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B654C: 419A0014  beq cr6, 0x821b6560
	if ctx.cr[6].eq {
	pc = 0x821B6560; continue 'dispatch;
	}
	// 821B6550: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B6554: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B6558: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B655C: 4800000C  b 0x821b6568
	pc = 0x821B6568; continue 'dispatch;
	// 821B6560: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B6564: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B6568: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B656C: 4199FFB8  bgt cr6, 0x821b6524
	if ctx.cr[6].gt {
	pc = 0x821B6524; continue 'dispatch;
	}
	// 821B6570: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B6574: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B6578: 419A0040  beq cr6, 0x821b65b8
	if ctx.cr[6].eq {
	pc = 0x821B65B8; continue 'dispatch;
	}
	// 821B657C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6580: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B6584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B6588: 41990008  bgt cr6, 0x821b6590
	if ctx.cr[6].gt {
	pc = 0x821B6590; continue 'dispatch;
	}
	// 821B658C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B6590: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B6594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6598: 409A0020  bne cr6, 0x821b65b8
	if !ctx.cr[6].eq {
	pc = 0x821B65B8; continue 'dispatch;
	}
	// 821B659C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B65A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B65A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B65A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B65AC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B65B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B65B4: 4800001C  b 0x821b65d0
	pc = 0x821B65D0; continue 'dispatch;
	// 821B65B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B65BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B65C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B65C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B65C8: 48000008  b 0x821b65d0
	pc = 0x821B65D0; continue 'dispatch;
	// 821B65CC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B65D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B65D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B65D8: 419A0018  beq cr6, 0x821b65f0
	if ctx.cr[6].eq {
	pc = 0x821B65F0; continue 'dispatch;
	}
	// 821B65DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B65E0: 483BF139  bl 0x82575718
	ctx.lr = 0x821B65E4;
	sub_82575718(ctx, base);
	// 821B65E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B65E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B65EC: 483BBFBD  bl 0x825725a8
	ctx.lr = 0x821B65F0;
	sub_825725A8(ctx, base);
	// 821B65F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B65F4: 4855381D  bl 0x82709e10
	ctx.lr = 0x821B65F8;
	sub_82709E10(ctx, base);
	// 821B65F8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B65FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6600: 419A000C  beq cr6, 0x821b660c
	if ctx.cr[6].eq {
	pc = 0x821B660C; continue 'dispatch;
	}
	// 821B6604: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B6608: 4BFFFB31  bl 0x821b6138
	ctx.lr = 0x821B660C;
	sub_821B6138(ctx, base);
	// 821B660C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B6610: 48AF2E48  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6618 size=68
    let mut pc: u32 = 0x821B6618;
    'dispatch: loop {
        match pc {
            0x821B6618 => {
    //   block [0x821B6618..0x821B665C)
	// 821B6618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B661C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6620: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6624: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 821B6628: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821B662C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6660 size=204
    let mut pc: u32 = 0x821B6660;
    'dispatch: loop {
        match pc {
            0x821B6660 => {
    //   block [0x821B6660..0x821B672C)
	// 821B6660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6668: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B666C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6670: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821B6674: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 821B6678: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B667C: 409A000C  bne cr6, 0x821b6688
	if !ctx.cr[6].eq {
	pc = 0x821B6688; continue 'dispatch;
	}
	// 821B6680: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B6684: 48000010  b 0x821b6694
	pc = 0x821B6694; continue 'dispatch;
	// 821B6688: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B668C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B6690: 7D2943D6  divw r9, r9, r8
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 821B6694: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6698: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B669C: 7D0A43D6  divw r8, r10, r8
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 821B66A0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B66A4: 40980060  bge cr6, 0x821b6704
	if !ctx.cr[6].lt {
	pc = 0x821B6704; continue 'dispatch;
	}
	// 821B66A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B66AC: 419A0040  beq cr6, 0x821b66ec
	if ctx.cr[6].eq {
	pc = 0x821B66EC; continue 'dispatch;
	}
	// 821B66B0: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B66B4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B66B8: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B66BC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B66C0: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B66C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B66C8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821B66CC: 419A0020  beq cr6, 0x821b66ec
	if ctx.cr[6].eq {
	pc = 0x821B66EC; continue 'dispatch;
	}
	// 821B66D0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 821B66D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B66D8: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 821B66DC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821B66E0: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B66E4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B66E8: 4082FFE8  bne 0x821b66d0
	if !ctx.cr[0].eq {
	pc = 0x821B66D0; continue 'dispatch;
	}
	// 821B66EC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821B66F0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B66F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B66F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B66FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6700: 4E800020  blr
	return;
	// 821B6704: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B6708: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B670C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B6710: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B6714: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6718: 48014A89  bl 0x821cb1a0
	ctx.lr = 0x821B671C;
	sub_821CB1A0(ctx, base);
	// 821B671C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B6720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B6730 size=400
    let mut pc: u32 = 0x821B6730;
    'dispatch: loop {
        match pc {
            0x821B6730 => {
    //   block [0x821B6730..0x821B68C0)
	// 821B6730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6734: 48AF2CC5  bl 0x82ca93f8
	ctx.lr = 0x821B6738;
	sub_82CA93D0(ctx, base);
	// 821B6738: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 821B673C: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 821B6740: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821B6744: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6748: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B674C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821B6750: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821B6754: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821B6758: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 821B675C: C1BF0054  lfs f13, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6760: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B6764: C01F41A0  lfs f0, 0x41a0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6768: C19F419C  lfs f12, 0x419c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16796 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B676C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B6770: C17F0050  lfs f11, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B6774: EDAC02F2  fmuls f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B6778: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B677C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B6780: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B6784: 41980008  blt cr6, 0x821b678c
	if ctx.cr[6].lt {
	pc = 0x821B678C; continue 'dispatch;
	}
	// 821B6788: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 821B678C: C3CB0000  lfs f30, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B6790: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B6794: D3DF00D0  stfs f30, 0xd0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821B6798: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821B679C: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 821B67A0: C01F41A8  lfs f0, 0x41a8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B67A4: 388A15FC  addi r4, r10, 0x15fc
	ctx.r[4].s64 = ctx.r[10].s64 + 5628;
	// 821B67A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B67AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B67B0: C3FE000C  lfs f31, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B67B4: EFBF0024  fdivs f29, f31, f0
	ctx.f[29].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B67B8: 48076719  bl 0x8222ced0
	ctx.lr = 0x821B67BC;
	sub_8222CED0(ctx, base);
	// 821B67BC: 481FA27D  bl 0x823b0a38
	ctx.lr = 0x821B67C0;
	sub_823B0A38(ctx, base);
	// 821B67C0: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 821B67C4: 80FF00F8  lwz r7, 0xf8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 821B67C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B67CC: 7D2A3850  subf r9, r10, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 821B67D0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821B67D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B67D8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B67DC: 40810040  ble 0x821b681c
	if !ctx.cr[0].gt {
	pc = 0x821B681C; continue 'dispatch;
	}
	// 821B67E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B67E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B67E8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B67EC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B67F0: 7F061840  cmplw cr6, r6, r3
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821B67F4: 40980014  bge cr6, 0x821b6808
	if !ctx.cr[6].lt {
	pc = 0x821B6808; continue 'dispatch;
	}
	// 821B67F8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B67FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B6800: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6804: 4800000C  b 0x821b6810
	pc = 0x821B6810; continue 'dispatch;
	// 821B6808: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B680C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B6810: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6814: 4199FFCC  bgt cr6, 0x821b67e0
	if ctx.cr[6].gt {
	pc = 0x821B67E0; continue 'dispatch;
	}
	// 821B6818: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B681C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B6820: 419A0020  beq cr6, 0x821b6840
	if ctx.cr[6].eq {
	pc = 0x821B6840; continue 'dispatch;
	}
	// 821B6824: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6828: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B682C: 41980014  blt cr6, 0x821b6840
	if ctx.cr[6].lt {
	pc = 0x821B6840; continue 'dispatch;
	}
	// 821B6830: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6834: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B6838: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B683C: 48000008  b 0x821b6844
	pc = 0x821B6844; continue 'dispatch;
	// 821B6840: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 821B6844: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B6848: 830B0004  lwz r24, 4(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B684C: 4805E58D  bl 0x82214dd8
	ctx.lr = 0x821B6850;
	sub_82214DD8(ctx, base);
	// 821B6850: D3C10050  stfs f30, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B6854: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B6858: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B685C: F9780014  std r11, 0x14(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(20 as u32), ctx.r[11].u64 ) };
	// 821B6860: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6864: 9378000C  stw r27, 0xc(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 821B6868: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821B686C: 93580010  stw r26, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 821B6870: C1BF004C  lfs f13, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6874: D1B8001C  stfs f13, 0x1c(r24)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B6878: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B687C: C19F006C  lfs f12, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B6880: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821B6884: D1980020  stfs f12, 0x20(r24)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B6888: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B688C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B6890: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B6894: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B6898: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821B689C: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B68A0: 4808B869  bl 0x82242108
	ctx.lr = 0x821B68A4;
	sub_82242108(ctx, base);
	// 821B68A4: 93B8000C  stw r29, 0xc(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821B68A8: 93B80010  stw r29, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 821B68AC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821B68B0: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821B68B4: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821B68B8: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821B68BC: 48AF2B8C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B68C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B68C0 size=200
    let mut pc: u32 = 0x821B68C0;
    'dispatch: loop {
        match pc {
            0x821B68C0 => {
    //   block [0x821B68C0..0x821B6988)
	// 821B68C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B68C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B68C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B68CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B68D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B68D4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821B68D8: 481FA161  bl 0x823b0a38
	ctx.lr = 0x821B68DC;
	sub_823B0A38(ctx, base);
	// 821B68DC: 813F00F4  lwz r9, 0xf4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 821B68E0: 80FF00F8  lwz r7, 0xf8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 821B68E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B68E8: 7D493850  subf r10, r9, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 821B68EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B68F0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B68F4: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B68F8: 40810040  ble 0x821b6938
	if !ctx.cr[0].gt {
	pc = 0x821B6938; continue 'dispatch;
	}
	// 821B68FC: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B6900: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B6904: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821B6908: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B690C: 7F061840  cmplw cr6, r6, r3
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821B6910: 40980014  bge cr6, 0x821b6924
	if !ctx.cr[6].lt {
	pc = 0x821B6924; continue 'dispatch;
	}
	// 821B6914: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B6918: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821B691C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6920: 4800000C  b 0x821b692c
	pc = 0x821B692C; continue 'dispatch;
	// 821B6924: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821B6928: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821B692C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6930: 4199FFCC  bgt cr6, 0x821b68fc
	if ctx.cr[6].gt {
	pc = 0x821B68FC; continue 'dispatch;
	}
	// 821B6934: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B6938: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B693C: 419A0034  beq cr6, 0x821b6970
	if ctx.cr[6].eq {
	pc = 0x821B6970; continue 'dispatch;
	}
	// 821B6940: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6944: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B6948: 41980028  blt cr6, 0x821b6970
	if ctx.cr[6].lt {
	pc = 0x821B6970; continue 'dispatch;
	}
	// 821B694C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6950: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B6954: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B6958: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B695C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B6960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6968: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B696C: 4E800020  blr
	return;
	// 821B6970: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6974: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B6978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B697C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B6988 size=276
    let mut pc: u32 = 0x821B6988;
    'dispatch: loop {
        match pc {
            0x821B6988 => {
    //   block [0x821B6988..0x821B6A9C)
	// 821B6988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B698C: 48AF2A75  bl 0x82ca9400
	ctx.lr = 0x821B6990;
	sub_82CA93D0(ctx, base);
	// 821B6990: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821B6994: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821B6998: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B699C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B69A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B69A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B69A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821B69AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B69B0: 388B1094  addi r4, r11, 0x1094
	ctx.r[4].s64 = ctx.r[11].s64 + 4244;
	// 821B69B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B69B8: 48076519  bl 0x8222ced0
	ctx.lr = 0x821B69BC;
	sub_8222CED0(ctx, base);
	// 821B69BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B69C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B69C4: 4BFFFEFD  bl 0x821b68c0
	ctx.lr = 0x821B69C8;
	sub_821B68C0(ctx, base);
	// 821B69C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B69CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B69D0: 4805E409  bl 0x82214dd8
	ctx.lr = 0x821B69D4;
	sub_82214DD8(ctx, base);
	// 821B69D4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821B69D8: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 821B69DC: 38E89490  addi r7, r8, -0x6b70
	ctx.r[7].s64 = ctx.r[8].s64 + -27504;
	// 821B69E0: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 821B69E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B69E8: 3B610054  addi r27, r1, 0x54
	ctx.r[27].s64 = ctx.r[1].s64 + 84;
	// 821B69EC: C3C89490  lfs f30, -0x6b70(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6AA0 size=104
    let mut pc: u32 = 0x821B6AA0;
    'dispatch: loop {
        match pc {
            0x821B6AA0 => {
    //   block [0x821B6AA0..0x821B6B08)
	// 821B6AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B6AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B6AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B6AB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B6ABC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821B6AC0: 392B0B5C  addi r9, r11, 0xb5c
	ctx.r[9].s64 = ctx.r[11].s64 + 2908;
	// 821B6AC4: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 821B6AC8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B6ACC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B6AD0: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 821B6AD4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 821B6AD8: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 821B6ADC: 4805DDBD  bl 0x82214898
	ctx.lr = 0x821B6AE0;
	sub_82214898(ctx, base);
	// 821B6AE0: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 821B6AE4: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821B6AE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6AEC: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 821B6AF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B6AF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6AF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6AFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B6B00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6B04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6B08 size=104
    let mut pc: u32 = 0x821B6B08;
    'dispatch: loop {
        match pc {
            0x821B6B08 => {
    //   block [0x821B6B08..0x821B6B70)
	// 821B6B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6B10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B6B14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6B18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B6B1C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 821B6B20: 48068739  bl 0x8221f258
	ctx.lr = 0x821B6B24;
	sub_8221F258(ctx, base);
	// 821B6B24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B6B28: 419A0014  beq cr6, 0x821b6b3c
	if ctx.cr[6].eq {
	pc = 0x821B6B3C; continue 'dispatch;
	}
	// 821B6B2C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6B30: 4BFFFF71  bl 0x821b6aa0
	ctx.lr = 0x821B6B34;
	sub_821B6AA0(ctx, base);
	// 821B6B34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B6B38: 48000008  b 0x821b6b40
	pc = 0x821B6B40; continue 'dispatch;
	// 821B6B3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B6B40: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 821B6B44: 480BC515  bl 0x82273058
	ctx.lr = 0x821B6B48;
	sub_82273058(ctx, base);
	// 821B6B48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6B50: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B6B54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B6B58: 4E800421  bctrl
	ctx.lr = 0x821B6B5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B6B5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B6B60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6B64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6B68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6B6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6B70 size=240
    let mut pc: u32 = 0x821B6B70;
    'dispatch: loop {
        match pc {
            0x821B6B70 => {
    //   block [0x821B6B70..0x821B6C60)
	// 821B6B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6B78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B6B7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B6B80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6B84: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821B6B88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B6B8C: 394B0FF0  addi r10, r11, 0xff0
	ctx.r[10].s64 = ctx.r[11].s64 + 4080;
	// 821B6B90: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B98: 419A00B0  beq cr6, 0x821b6c48
	if ctx.cr[6].eq {
	pc = 0x821B6C48; continue 'dispatch;
	}
	// 821B6B9C: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821B6BA0: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821B6BA4: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 821B6BA8: 38EA7E70  addi r7, r10, 0x7e70
	ctx.r[7].s64 = ctx.r[10].s64 + 32368;
	// 821B6BAC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B6BB0: 38CB2008  addi r6, r11, 0x2008
	ctx.r[6].s64 = ctx.r[11].s64 + 8200;
	// 821B6BB4: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 821B6BB8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 821B6BBC: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821B6BC0: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 821B6BC4: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B6BC8: 38640FFC  addi r3, r4, 0xffc
	ctx.r[3].s64 = ctx.r[4].s64 + 4092;
	// 821B6BCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6BD0: 7CE8592E  stwx r7, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821B6BD4: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821B6BD8: 810B2000  lwz r8, 0x2000(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821B6BDC: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821B6BE0: 555E1838  slwi r30, r10, 3
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B6BE4: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 821B6BE8: 5509083C  slwi r9, r8, 1
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B6BEC: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821B6BF0: 912B2000  stw r9, 0x2000(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8192 as u32), ctx.r[9].u32 ) };
	// 821B6BF4: 7CFE312E  stwx r7, r30, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[6].u32), ctx.r[7].u32) };
	// 821B6BF8: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821B6BFC: 812B4008  lwz r9, 0x4008(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821B6C00: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B6C04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B6C08: 912B4008  stw r9, 0x4008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16392 as u32), ctx.r[9].u32 ) };
	// 821B6C0C: 914B400C  stw r10, 0x400c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16396 as u32), ctx.r[10].u32 ) };
	// 821B6C10: 83DF06FC  lwz r30, 0x6fc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821B6C14: 90BF06FC  stw r5, 0x6fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1788 as u32), ctx.r[5].u32 ) };
	// 821B6C18: 48086389  bl 0x8223cfa0
	ctx.lr = 0x821B6C1C;
	sub_8223CFA0(ctx, base);
	// 821B6C1C: 93DF06FC  stw r30, 0x6fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1788 as u32), ctx.r[30].u32 ) };
	// 821B6C20: 488B4369  bl 0x82a6af88
	ctx.lr = 0x821B6C24;
	sub_82A6AF88(ctx, base);
	// 821B6C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6C28: 488B4F79  bl 0x82a6bba0
	ctx.lr = 0x821B6C2C;
	sub_82A6BBA0(ctx, base);
	// 821B6C2C: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 821B6C30: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821B6C34: 3886AB2C  addi r4, r6, -0x54d4
	ctx.r[4].s64 = ctx.r[6].s64 + -21716;
	// 821B6C38: 8067F9C0  lwz r3, -0x640(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821B6C3C: 480803E5  bl 0x82237020
	ctx.lr = 0x821B6C40;
	sub_82237020(ctx, base);
	// 821B6C40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B6C44: 4806869D  bl 0x8221f2e0
	ctx.lr = 0x821B6C48;
	sub_8221F2E0(ctx, base);
	// 821B6C48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B6C4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6C50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6C54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B6C58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6C5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6C60 size=288
    let mut pc: u32 = 0x821B6C60;
    'dispatch: loop {
        match pc {
            0x821B6C60 => {
    //   block [0x821B6C60..0x821B6D80)
	// 821B6C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6C64: 48AF279D  bl 0x82ca9400
	ctx.lr = 0x821B6C68;
	sub_82CA93D0(ctx, base);
	// 821B6C68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6C6C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B6C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B6C74: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B6C78: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821B6C7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B6C80: 419A0050  beq cr6, 0x821b6cd0
	if ctx.cr[6].eq {
	pc = 0x821B6CD0; continue 'dispatch;
	}
	// 821B6C84: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B6C88: 217D0011  subfic r11, r29, 0x11
	ctx.xer.ca = ctx.r[29].u32 <= 17 as u32;
	ctx.r[11].s64 = (17 as i64) - ctx.r[29].s64;
	// 821B6C8C: 80BE001C  lwz r5, 0x1c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B6C90: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 821B6C94: 388B00DE  addi r4, r11, 0xde
	ctx.r[4].s64 = ctx.r[11].s64 + 222;
	// 821B6C98: 5547653E  srwi r7, r10, 0x14
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shr(20);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B6C9C: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B6CA0: 39670200  addi r11, r7, 0x200
	ctx.r[11].s64 = ctx.r[7].s64 + 512;
	// 821B6CA4: 554A00FE  clrlwi r10, r10, 3
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 821B6CA8: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6CAC: 54871838  slwi r7, r4, 3
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B6CB0: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 821B6CB4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B6CB8: 7CC62850  subf r6, r6, r5
	ctx.r[6].s64 = ctx.r[5].s64 - ctx.r[6].s64;
	// 821B6CBC: 7D67F92E  stwx r11, r7, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 821B6CC0: 90C906F4  stw r6, 0x6f4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(1780 as u32), ctx.r[6].u32 ) };
	// 821B6CC4: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 821B6CC8: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 821B6CCC: F97F0018  std r11, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 821B6CD0: 397D0C2B  addi r11, r29, 0xc2b
	ctx.r[11].s64 = ctx.r[29].s64 + 3115;
	// 821B6CD4: 557B103A  slwi r27, r11, 2
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 821B6CD8: 7F9BF82E  lwzx r28, r27, r31
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821B6CDC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B6CE0: 419A0068  beq cr6, 0x821b6d48
	if ctx.cr[6].eq {
	pc = 0x821B6D48; continue 'dispatch;
	}
	// 821B6CE4: 817F2A9C  lwz r11, 0x2a9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10908 as u32) ) } as u64;
	// 821B6CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6CEC: 419A000C  beq cr6, 0x821b6cf8
	if ctx.cr[6].eq {
	pc = 0x821B6CF8; continue 'dispatch;
	}
	// 821B6CF0: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B6CF4: 48000054  b 0x821b6d48
	pc = 0x821B6D48; continue 'dispatch;
	// 821B6CF8: 817F2AA0  lwz r11, 0x2aa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10912 as u32) ) } as u64;
	// 821B6CFC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6D00: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6D04: 41820044  beq 0x821b6d48
	if ctx.cr[0].eq {
	pc = 0x821B6D48; continue 'dispatch;
	}
	// 821B6D08: 817F34D8  lwz r11, 0x34d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13528 as u32) ) } as u64;
	// 821B6D0C: 807F34D4  lwz r3, 0x34d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13524 as u32) ) } as u64;
	// 821B6D10: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B6D14: 4198000C  blt cr6, 0x821b6d20
	if ctx.cr[6].lt {
	pc = 0x821B6D20; continue 'dispatch;
	}
	// 821B6D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6D1C: 489EAD95  bl 0x82ba1ab0
	ctx.lr = 0x821B6D20;
	sub_82BA1AB0(ctx, base);
	// 821B6D20: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B6D24: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821B6D28: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 821B6D2C: 538BF0BE  rlwimi r11, r28, 0x1e, 2, 0x1f
	ctx.r[11].u64 = (((ctx.r[28].u32).rotate_left(30) as u64) & 0x000000003FFFFFFF) | (ctx.r[11].u64 & 0xFFFFFFFFC0000000);
	// 821B6D30: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B6D34: 556B0080  rlwinm r11, r11, 0, 2, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6D38: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B6D3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B6D40: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B6D44: 913F34D4  stw r9, 0x34d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13524 as u32), ctx.r[9].u32 ) };
	// 821B6D48: 7D7FEA14  add r11, r31, r29
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[29].u64;
	// 821B6D4C: 7FDBF92E  stwx r30, r27, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	// 821B6D50: 5749F63E  rlwinm r9, r26, 0x1e, 0x18, 0x1f
	ctx.r[9].u64 = ctx.r[26].u32 as u64 & 0x00000003u64;
	// 821B6D54: 574AF0BF  rlwinm. r10, r26, 0x1e, 2, 0x1f
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B6D58: 992B30F0  stb r9, 0x30f0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12528 as u32), ctx.r[9].u8 ) };
	// 821B6D5C: 4182001C  beq 0x821b6d78
	if ctx.cr[0].eq {
	pc = 0x821B6D78; continue 'dispatch;
	}
	// 821B6D60: 896B2E38  lbz r11, 0x2e38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(11832 as u32) ) } as u64;
	// 821B6D64: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B6D68: 419A0010  beq cr6, 0x821b6d78
	if ctx.cr[6].eq {
	pc = 0x821B6D78; continue 'dispatch;
	}
	// 821B6D6C: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B6D70: 656B0008  oris r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 524288;
	// 821B6D74: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B6D78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B6D7C: 48AF26D4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6D80 size=172
    let mut pc: u32 = 0x821B6D80;
    'dispatch: loop {
        match pc {
            0x821B6D80 => {
    //   block [0x821B6D80..0x821B6E2C)
	// 821B6D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B6D88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B6D8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6D90: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821B6D94: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B6D98: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6D9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B6DA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6DA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B6DA8: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6DAC: 4BFFFEB5  bl 0x821b6c60
	ctx.lr = 0x821B6DB0;
	sub_821B6C60(ctx, base);
	// 821B6DB0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B6DB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6DB8: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6DBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B6DC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6DC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B6DC8: 4BFFFE99  bl 0x821b6c60
	ctx.lr = 0x821B6DCC;
	sub_821B6C60(ctx, base);
	// 821B6DCC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B6DD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6DD4: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6DD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B6DDC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6DE0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B6DE4: 4BFFFE7D  bl 0x821b6c60
	ctx.lr = 0x821B6DE8;
	sub_821B6C60(ctx, base);
	// 821B6DE8: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 821B6DEC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6DF0: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6DF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B6DF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6DFC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821B6E00: 4BFFFE61  bl 0x821b6c60
	ctx.lr = 0x821B6E04;
	sub_821B6C60(ctx, base);
	// 821B6E04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B6E08: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6E0C: 4BFE5E25  bl 0x8219cc30
	ctx.lr = 0x821B6E10;
	sub_8219CC30(ctx, base);
	// 821B6E10: 48000021  bl 0x821b6e30
	ctx.lr = 0x821B6E14;
	sub_821B6E30(ctx, base);
	// 821B6E14: 4BFFE32D  bl 0x821b5140
	ctx.lr = 0x821B6E18;
	sub_821B5140(ctx, base);
	// 821B6E18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B6E1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B6E20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B6E24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B6E28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6E30 size=176
    let mut pc: u32 = 0x821B6E30;
    'dispatch: loop {
        match pc {
            0x821B6E30 => {
    //   block [0x821B6E30..0x821B6EE0)
	// 821B6E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6E34: 48AF25D1  bl 0x82ca9404
	ctx.lr = 0x821B6E38;
	sub_82CA93D0(ctx, base);
	// 821B6E38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6E3C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B6E40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B6E44: 3B6B02B0  addi r27, r11, 0x2b0
	ctx.r[27].s64 = ctx.r[11].s64 + 688;
	// 821B6E48: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821B6E4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B6E50: 795EFFE6  rldicr r30, r10, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B6E54: 3F808336  lis r28, -0x7cca
	ctx.r[28].s64 = -2093613056;
	// 821B6E58: 3BABB0BC  addi r29, r11, -0x4f44
	ctx.r[29].s64 = ctx.r[11].s64 + -20292;
	// 821B6E5C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6E64: 409A0020  bne cr6, 0x821b6e84
	if !ctx.cr[6].eq {
	pc = 0x821B6E84; continue 'dispatch;
	}
	// 821B6E68: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821B6E6C: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6E70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6E74: 807C0364  lwz r3, 0x364(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6E78: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821B6E7C: 7FC65436  srd r6, r30, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821B6E80: 48000061  bl 0x821b6ee0
	ctx.lr = 0x821B6E84;
	sub_821B6EE0(ctx, base);
	// 821B6E84: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B6E88: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821B6E8C: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 821B6E90: 4198FFCC  blt cr6, 0x821b6e5c
	if ctx.cr[6].lt {
	pc = 0x821B6E5C; continue 'dispatch;
	}
	// 821B6E94: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B6E98: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 821B6E9C: 3B6B02A0  addi r27, r11, 0x2a0
	ctx.r[27].s64 = ctx.r[11].s64 + 672;
	// 821B6EA0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6EA8: 409A0020  bne cr6, 0x821b6ec8
	if !ctx.cr[6].eq {
	pc = 0x821B6EC8; continue 'dispatch;
	}
	// 821B6EAC: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821B6EB0: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6EB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6EB8: 807C0364  lwz r3, 0x364(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B6EBC: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821B6EC0: 7FC65436  srd r6, r30, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821B6EC4: 4800001D  bl 0x821b6ee0
	ctx.lr = 0x821B6EC8;
	sub_821B6EE0(ctx, base);
	// 821B6EC8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B6ECC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821B6ED0: 2B1F0014  cmplwi cr6, r31, 0x14
	ctx.cr[6].compare_u32(ctx.r[31].u32, 20 as u32, &mut ctx.xer);
	// 821B6ED4: 4198FFCC  blt cr6, 0x821b6ea0
	if ctx.cr[6].lt {
	pc = 0x821B6EA0; continue 'dispatch;
	}
	// 821B6ED8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B6EDC: 48AF2578  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B6EE0 size=380
    let mut pc: u32 = 0x821B6EE0;
    'dispatch: loop {
        match pc {
            0x821B6EE0 => {
    //   block [0x821B6EE0..0x821B705C)
	// 821B6EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6EE4: 48AF2505  bl 0x82ca93e8
	ctx.lr = 0x821B6EE8;
	sub_82CA93D0(ctx, base);
	// 821B6EE8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6EEC: 39640C40  addi r11, r4, 0xc40
	ctx.r[11].s64 = ctx.r[4].s64 + 3136;
	// 821B6EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B6EF4: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821B6EF8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B6EFC: 7F9DF82E  lwzx r28, r29, r31
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821B6F00: 419A00E4  beq cr6, 0x821b6fe4
	if ctx.cr[6].eq {
	pc = 0x821B6FE4; continue 'dispatch;
	}
	// 821B6F04: 83650030  lwz r27, 0x30(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B6F08: 39640030  addi r11, r4, 0x30
	ctx.r[11].s64 = ctx.r[4].s64 + 48;
	// 821B6F0C: 80E50020  lwz r7, 0x20(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B6F10: 5769653E  srwi r9, r27, 0x14
	ctx.r[9].u32 = ctx.r[27].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B6F14: 8345002C  lwz r26, 0x2c(r5)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B6F18: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 * 24;
	// 821B6F1C: 8325001C  lwz r25, 0x1c(r5)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B6F20: 83050024  lwz r24, 0x24(r5)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B6F24: 82E50028  lwz r23, 0x28(r5)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B6F28: 54EA653E  srwi r10, r7, 0x14
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(20);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B6F2C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821B6F30: 39290200  addi r9, r9, 0x200
	ctx.r[9].s64 = ctx.r[9].s64 + 512;
	// 821B6F34: 394A0200  addi r10, r10, 0x200
	ctx.r[10].s64 = ctx.r[10].s64 + 512;
	// 821B6F38: 54FE00FE  clrlwi r30, r7, 3
	ctx.r[30].u64 = ctx.r[7].u32 as u64 & 0x1FFFFFFFu64;
	// 821B6F3C: 552804E6  rlwinm r8, r9, 0, 0x13, 0x13
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6F40: 554304E6  rlwinm r3, r10, 0, 0x13, 0x13
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6F44: 82CB0000  lwz r22, 0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6F48: 7D3F2214  add r9, r31, r4
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[4].u64;
	// 821B6F4C: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B6F50: 576700EC  rlwinm r7, r27, 0, 3, 0x16
	ctx.r[7].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 821B6F54: 836B0004  lwz r27, 4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B6F58: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821B6F5C: 82AB000C  lwz r21, 0xc(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B6F60: 828B0014  lwz r20, 0x14(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B6F64: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 821B6F68: 7C63F214  add r3, r3, r30
	ctx.r[3].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 821B6F6C: 930B0008  stw r24, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 821B6F70: 508A07AA  rlwimi r10, r4, 0, 0x1e, 0x15
	ctx.r[10].u64 = (((ctx.r[4].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFFC03) | (ctx.r[10].u64 & 0x00000000000003FC);
	// 821B6F74: 89092EAE  lbz r8, 0x2eae(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(11950 as u32) ) } as u64;
	// 821B6F78: 52D902AA  rlwimi r25, r22, 0, 0xa, 0x15
	ctx.r[25].u64 = (((ctx.r[22].u32).rotate_left(0) as u64) & 0x00000000003FFC00) | (ctx.r[25].u64 & 0xFFFFFFFFFFC003FF);
	// 821B6F7C: 53630528  rlwimi r3, r27, 0, 0x14, 0x14
	ctx.r[3].u64 = (((ctx.r[27].u32).rotate_left(0) as u64) & 0x0000000000000800) | (ctx.r[3].u64 & 0xFFFFFFFFFFFFF7FF);
	// 821B6F80: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821B6F84: 52B70058  rlwimi r23, r21, 0, 1, 0xc
	ctx.r[23].u64 = (((ctx.r[21].u32).rotate_left(0) as u64) & 0x000000007FF80000) | (ctx.r[23].u64 & 0xFFFFFFFF8007FFFF);
	// 821B6F88: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 821B6F8C: 528705FE  rlwimi r7, r20, 0, 0x17, 0x1f
	ctx.r[7].u64 = (((ctx.r[20].u32).rotate_left(0) as u64) & 0x00000000000001FF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFFFE00);
	// 821B6F90: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821B6F94: 5744F73E  rlwinm r4, r26, 0x1e, 0x1c, 0x1f
	ctx.r[4].u64 = ctx.r[26].u32 as u64 & 0x00000003u64;
	// 821B6F98: 92EB000C  stw r23, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 821B6F9C: 90EB0014  stw r7, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 821B6FA0: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B6FA4: 4099000C  ble cr6, 0x821b6fb0
	if !ctx.cr[6].gt {
	pc = 0x821B6FB0; continue 'dispatch;
	}
	// 821B6FA8: 5748003E  slwi r8, r26, 0
	ctx.r[8].u32 = ctx.r[26].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B6FAC: 5508F73E  rlwinm r8, r8, 0x1e, 0x1c, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 821B6FB0: 80E5002C  lwz r7, 0x2c(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B6FB4: 510A16BA  rlwimi r10, r8, 2, 0x1a, 0x1d
	ctx.r[10].u64 = (((ctx.r[8].u32).rotate_left(2) as u64) & 0x000000000000003C) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFC3);
	// 821B6FB8: 89292EC8  lbz r9, 0x2ec8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(11976 as u32) ) } as u64;
	// 821B6FBC: 54E8D73E  rlwinm r8, r7, 0x1a, 0x1c, 0x1f
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000003Fu64;
	// 821B6FC0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821B6FC4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B6FC8: 40980008  bge cr6, 0x821b6fd0
	if !ctx.cr[6].lt {
	pc = 0x821B6FD0; continue 'dispatch;
	}
	// 821B6FCC: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 821B6FD0: E91F0018  ld r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 821B6FD4: 512A35B2  rlwimi r10, r9, 6, 0x16, 0x19
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(6) as u64) & 0x00000000000003C0) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFC3F);
	// 821B6FD8: 7D093378  or r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[6].u64;
	// 821B6FDC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821B6FE0: F93F0018  std r9, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u64 ) };
	// 821B6FE4: 7CBDF92E  stwx r5, r29, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32), ctx.r[5].u32) };
	// 821B6FE8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B6FEC: 419A0068  beq cr6, 0x821b7054
	if ctx.cr[6].eq {
	pc = 0x821B7054; continue 'dispatch;
	}
	// 821B6FF0: 817F2A9C  lwz r11, 0x2a9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10908 as u32) ) } as u64;
	// 821B6FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6FF8: 419A000C  beq cr6, 0x821b7004
	if ctx.cr[6].eq {
	pc = 0x821B7004; continue 'dispatch;
	}
	// 821B6FFC: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B7000: 48000054  b 0x821b7054
	pc = 0x821B7054; continue 'dispatch;
	// 821B7004: 817F2AA0  lwz r11, 0x2aa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10912 as u32) ) } as u64;
	// 821B7008: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B700C: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7010: 41820044  beq 0x821b7054
	if ctx.cr[0].eq {
	pc = 0x821B7054; continue 'dispatch;
	}
	// 821B7014: 817F34D8  lwz r11, 0x34d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13528 as u32) ) } as u64;
	// 821B7018: 807F34D4  lwz r3, 0x34d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13524 as u32) ) } as u64;
	// 821B701C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B7020: 4198000C  blt cr6, 0x821b702c
	if ctx.cr[6].lt {
	pc = 0x821B702C; continue 'dispatch;
	}
	// 821B7024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B7028: 489EAA89  bl 0x82ba1ab0
	ctx.lr = 0x821B702C;
	sub_82BA1AB0(ctx, base);
	// 821B702C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B7030: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821B7034: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 821B7038: 538BF0BE  rlwimi r11, r28, 0x1e, 2, 0x1f
	ctx.r[11].u64 = (((ctx.r[28].u32).rotate_left(30) as u64) & 0x000000003FFFFFFF) | (ctx.r[11].u64 & 0xFFFFFFFFC0000000);
	// 821B703C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B7040: 556B0080  rlwinm r11, r11, 0, 2, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B7044: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B7048: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B704C: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B7050: 913F34D4  stw r9, 0x34d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13524 as u32), ctx.r[9].u32 ) };
	// 821B7054: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B7058: 48AF23E0  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7060 size=196
    let mut pc: u32 = 0x821B7060;
    'dispatch: loop {
        match pc {
            0x821B7060 => {
    //   block [0x821B7060..0x821B7124)
	// 821B7060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7064: 48AF23A1  bl 0x82ca9404
	ctx.lr = 0x821B7068;
	sub_82CA93D0(ctx, base);
	// 821B7068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B706C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B7070: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B7074: 3B8B02B0  addi r28, r11, 0x2b0
	ctx.r[28].s64 = ctx.r[11].s64 + 688;
	// 821B7078: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B707C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821B7080: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821B7084: 797DFFE6  rldicr r29, r11, 0x3f, 0x3f
	ctx.r[29].u64 = (ctx.r[11].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821B7088: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B708C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7090: 419A0028  beq cr6, 0x821b70b8
	if ctx.cr[6].eq {
	pc = 0x821B70B8; continue 'dispatch;
	}
	// 821B7094: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B7098: 41980020  blt cr6, 0x821b70b8
	if ctx.cr[6].lt {
	pc = 0x821B70B8; continue 'dispatch;
	}
	// 821B709C: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 821B70A0: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B70A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B70A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B70AC: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 821B70B0: 7FA64C36  srd r6, r29, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821B70B4: 4BFFFE2D  bl 0x821b6ee0
	ctx.lr = 0x821B70B8;
	sub_821B6EE0(ctx, base);
	// 821B70B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B70BC: 397C0050  addi r11, r28, 0x50
	ctx.r[11].s64 = ctx.r[28].s64 + 80;
	// 821B70C0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B70C4: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B70C8: 4198FFC0  blt cr6, 0x821b7088
	if ctx.cr[6].lt {
	pc = 0x821B7088; continue 'dispatch;
	}
	// 821B70CC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B70D0: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 821B70D4: 3BCB02A0  addi r30, r11, 0x2a0
	ctx.r[30].s64 = ctx.r[11].s64 + 672;
	// 821B70D8: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 821B70DC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B70E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B70E4: 419A0028  beq cr6, 0x821b710c
	if ctx.cr[6].eq {
	pc = 0x821B710C; continue 'dispatch;
	}
	// 821B70E8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B70EC: 41980020  blt cr6, 0x821b710c
	if ctx.cr[6].lt {
	pc = 0x821B710C; continue 'dispatch;
	}
	// 821B70F0: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 821B70F4: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B70F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B70FC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7100: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 821B7104: 7FA64C36  srd r6, r29, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821B7108: 4BFFFDD9  bl 0x821b6ee0
	ctx.lr = 0x821B710C;
	sub_821B6EE0(ctx, base);
	// 821B710C: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821B7110: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B7114: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B7118: 4082FFC4  bne 0x821b70dc
	if !ctx.cr[0].eq {
	pc = 0x821B70DC; continue 'dispatch;
	}
	// 821B711C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B7120: 48AF2334  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7128 size=128
    let mut pc: u32 = 0x821B7128;
    'dispatch: loop {
        match pc {
            0x821B7128 => {
    //   block [0x821B7128..0x821B71A8)
	// 821B7128: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 821B712C: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821B7130: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 821B7134: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7138: 38C1FFE0  addi r6, r1, -0x20
	ctx.r[6].s64 = ctx.r[1].s64 + -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B71A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B71A8 size=68
    let mut pc: u32 = 0x821B71A8;
    'dispatch: loop {
        match pc {
            0x821B71A8 => {
    //   block [0x821B71A8..0x821B71EC)
	// 821B71A8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821B71AC: C1A1FFF8  lfs f13, -8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B71B0: C161FFFC  lfs f11, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B71B4: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821B71B8: C001FFF0  lfs f0, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B71BC: C181FFF4  lfs f12, -0xc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B71C0: 798CE7E6  rldicr r12, r12, 0x3c, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(60) & 0xFFFFFFFFFFFFFFFF;
	// 821B71C4: 816B0364  lwz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 821B71C8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B71CC: D00B1840  stfs f0, 0x1840(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6208 as u32), tmp.u32 ) };
	// 821B71D0: D1AA1848  stfs f13, 0x1848(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6216 as u32), tmp.u32 ) };
	// 821B71D4: D16A184C  stfs f11, 0x184c(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6220 as u32), tmp.u32 ) };
	// 821B71D8: D18A1844  stfs f12, 0x1844(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6212 as u32), tmp.u32 ) };
	// 821B71DC: E92A0008  ld r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821B71E0: 7D286378  or r8, r9, r12
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[12].u64;
	// 821B71E4: F90A0008  std r8, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 821B71E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B71F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B71F0 size=160
    let mut pc: u32 = 0x821B71F0;
    'dispatch: loop {
        match pc {
            0x821B71F0 => {
    //   block [0x821B71F0..0x821B7290)
	// 821B71F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B71F4: 48AF2211  bl 0x82ca9404
	ctx.lr = 0x821B71F8;
	sub_82CA93D0(ctx, base);
	// 821B71F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B71FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B7200: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B7204: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7208: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B720C: 4098007C  bge cr6, 0x821b7288
	if !ctx.cr[6].lt {
	pc = 0x821B7288; continue 'dispatch;
	}
	// 821B7210: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 821B7214: 557C003A  rlwinm r28, r11, 0, 0, 0x1d
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B7218: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B721C: 4806803D  bl 0x8221f258
	ctx.lr = 0x821B7220;
	sub_8221F258(ctx, base);
	// 821B7220: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B7224: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7228: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B722C: 4805126D  bl 0x82208498
	ctx.lr = 0x821B7230;
	sub_82208498(ctx, base);
	// 821B7230: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821B7234: 7F7DF1AE  stbx r27, r29, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32), ctx.r[27].u8) };
	// 821B7238: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B723C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7240: 419A000C  beq cr6, 0x821b724c
	if ctx.cr[6].eq {
	pc = 0x821B724C; continue 'dispatch;
	}
	// 821B7244: 48064AF5  bl 0x8221bd38
	ctx.lr = 0x821B7248;
	sub_8221BD38(ctx, base);
	// 821B7248: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821B724C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7250: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B7254: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B7258: 538B083C  rlwimi r11, r28, 1, 0, 0x1e
	ctx.r[11].u64 = (((ctx.r[28].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[11].u64 & 0xFFFFFFFF00000001);
	// 821B725C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821B7260: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B7264: 7F7DF1AE  stbx r27, r29, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32), ctx.r[27].u8) };
	// 821B7268: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B726C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7270: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7274: 392B0003  addi r9, r11, 3
	ctx.r[9].s64 = ctx.r[11].s64 + 3;
	// 821B7278: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B727C: 5528003A  rlwinm r8, r9, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821B7280: 7CAB4050  subf r5, r11, r8
	ctx.r[5].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821B7284: 48AF272D  bl 0x82ca99b0
	ctx.lr = 0x821B7288;
	sub_82CA99B0(ctx, base);
	// 821B7288: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B728C: 48AF21C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7290 size=180
    let mut pc: u32 = 0x821B7290;
    'dispatch: loop {
        match pc {
            0x821B7290 => {
    //   block [0x821B7290..0x821B7344)
	// 821B7290: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 821B7294: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 821B7298: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B729C: 81010014  lwz r8, 0x14(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B72A0: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 821B72A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72A8: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72AC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B72B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B72B4: 41980008  blt cr6, 0x821b72bc
	if ctx.cr[6].lt {
	pc = 0x821B72BC; continue 'dispatch;
	}
	// 821B72B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B72BC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B72C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B72C4: 419A001C  beq cr6, 0x821b72e0
	if ctx.cr[6].eq {
	pc = 0x821B72E0; continue 'dispatch;
	}
	// 821B72C8: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72CC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B72D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B72D4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B72D8: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821B72DC: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B72E0: 81210024  lwz r9, 0x24(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B72E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72E8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B72EC: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B72F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B72F4: 41980008  blt cr6, 0x821b72fc
	if ctx.cr[6].lt {
	pc = 0x821B72FC; continue 'dispatch;
	}
	// 821B72F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B72FC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B7300: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7304: 419A001C  beq cr6, 0x821b7320
	if ctx.cr[6].eq {
	pc = 0x821B7320; continue 'dispatch;
	}
	// 821B7308: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B730C: E8E90000  ld r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821B7310: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7314: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7318: 90C90004  stw r6, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821B731C: F8EB0000  std r7, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 821B7320: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7324: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7328: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B732C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B7330: 41980008  blt cr6, 0x821b7338
	if ctx.cr[6].lt {
	pc = 0x821B7338; continue 'dispatch;
	}
	// 821B7334: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B7338: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B733C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7340: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7344(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7344 size=28
    let mut pc: u32 = 0x821B7344;
    'dispatch: loop {
        match pc {
            0x821B7344 => {
    //   block [0x821B7344..0x821B7360)
	// 821B7344: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7348: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B734C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7350: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7354: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821B7358: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B735C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7360 size=260
    let mut pc: u32 = 0x821B7360;
    'dispatch: loop {
        match pc {
            0x821B7360 => {
    //   block [0x821B7360..0x821B7464)
	// 821B7360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7364: 48AF2099  bl 0x82ca93fc
	ctx.lr = 0x821B7368;
	sub_82CA93D0(ctx, base);
	// 821B7368: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B736C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B7370: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B7374: FBC100B0  std r30, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u64 ) };
	// 821B7378: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B737C: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 821B7380: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B7384: 832100C4  lwz r25, 0xc4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 821B7388: 7D6AC850  subf r11, r10, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[10].s64;
	// 821B738C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B7390: FBA100B8  std r29, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u64 ) };
	// 821B7394: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 821B7398: 409900B8  ble cr6, 0x821b7450
	if !ctx.cr[6].gt {
	pc = 0x821B7450; continue 'dispatch;
	}
	// 821B739C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B73A0: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 821B73A4: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 821B73A8: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B73AC: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821B73B0: 557F1838  slwi r31, r11, 3
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821B73B4: 557A2036  slwi r26, r11, 4
	ctx.r[26].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 821B73B8: 7F7F5214  add r27, r31, r10
	ctx.r[27].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 821B73BC: 7D1A5214  add r8, r26, r10
	ctx.r[8].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 821B73C0: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 821B73C4: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821B73C8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B73CC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B73D0: 4BFFFEC1  bl 0x821b7290
	ctx.lr = 0x821B73D4;
	sub_821B7290(ctx, base);
	// 821B73D4: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821B73D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B73DC: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 821B73E0: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821B73E4: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 821B73E8: 7CDF5850  subf r6, r31, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 821B73EC: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 821B73F0: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 821B73F4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B73F8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B73FC: 4BFFFE95  bl 0x821b7290
	ctx.lr = 0x821B7400;
	sub_821B7290(ctx, base);
	// 821B7400: 7C9AC850  subf r4, r26, r25
	ctx.r[4].s64 = ctx.r[25].s64 - ctx.r[26].s64;
	// 821B7404: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 821B7408: 7FFFC850  subf r31, r31, r25
	ctx.r[31].s64 = ctx.r[25].s64 - ctx.r[31].s64;
	// 821B740C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 821B7410: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B7414: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821B7418: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821B741C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7420: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B7424: 4BFFFE6D  bl 0x821b7290
	ctx.lr = 0x821B7428;
	sub_821B7290(ctx, base);
	// 821B7428: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 821B742C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B7430: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 821B7434: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821B7438: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 821B743C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7440: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B7444: 4BFFFE4D  bl 0x821b7290
	ctx.lr = 0x821B7448;
	sub_821B7290(ctx, base);
	// 821B7448: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B744C: 48AF2000  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 821B7450: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B7454: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B7458: 4BFFFE39  bl 0x821b7290
	ctx.lr = 0x821B745C;
	sub_821B7290(ctx, base);
	// 821B745C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B7460: 48AF1FEC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7468 size=880
    let mut pc: u32 = 0x821B7468;
    'dispatch: loop {
        match pc {
            0x821B7468 => {
    //   block [0x821B7468..0x821B77D8)
	// 821B7468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B746C: 48AF1F99  bl 0x82ca9404
	ctx.lr = 0x821B7470;
	sub_82CA93D0(ctx, base);
	// 821B7470: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7474: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 821B7478: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B747C: F8A100D0  std r5, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[5].u64 ) };
	// 821B7480: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821B7484: 838100D4  lwz r28, 0xd4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 821B7488: 397CFFF8  addi r11, r28, -8
	ctx.r[11].s64 = ctx.r[28].s64 + -8;
	// 821B748C: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 821B7490: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821B7494: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B7498: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 821B749C: 7D5DE050  subf r10, r29, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 821B74A0: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 821B74A4: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 821B74A8: 7D280E70  srawi r8, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 821B74AC: 7CE80194  addze r7, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[7].s64 = tmp.s64;
	// 821B74B0: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B74B4: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821B74B8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821B74BC: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B74C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B74C4: 4BFFFE9D  bl 0x821b7360
	ctx.lr = 0x821B74C8;
	sub_821B7360(ctx, base);
	// 821B74C8: 393F0008  addi r9, r31, 8
	ctx.r[9].s64 = ctx.r[31].s64 + 8;
	// 821B74CC: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 821B74D0: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B74D4: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821B74D8: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B74DC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 821B74E0: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B74E4: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 821B74E8: 40980058  bge cr6, 0x821b7540
	if !ctx.cr[6].lt {
	pc = 0x821B7540; continue 'dispatch;
	}
	// 821B74EC: 8167FFF8  lwz r11, -8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B74F0: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B74F4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B74F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B74FC: 41980008  blt cr6, 0x821b7504
	if ctx.cr[6].lt {
	pc = 0x821B7504; continue 'dispatch;
	}
	// 821B7500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7504: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B750C: 409A0034  bne cr6, 0x821b7540
	if !ctx.cr[6].eq {
	pc = 0x821B7540; continue 'dispatch;
	}
	// 821B7510: 8167FFF8  lwz r11, -8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7514: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B7518: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B751C: 41980008  blt cr6, 0x821b7524
	if ctx.cr[6].lt {
	pc = 0x821B7524; continue 'dispatch;
	}
	// 821B7520: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7524: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B752C: 409A0014  bne cr6, 0x821b7540
	if !ctx.cr[6].eq {
	pc = 0x821B7540; continue 'dispatch;
	}
	// 821B7530: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 821B7534: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B7538: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B753C: 4198FFB0  blt cr6, 0x821b74ec
	if ctx.cr[6].lt {
	pc = 0x821B74EC; continue 'dispatch;
	}
	// 821B7540: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B7544: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B7548: 40980054  bge cr6, 0x821b759c
	if !ctx.cr[6].lt {
	pc = 0x821B759C; continue 'dispatch;
	}
	// 821B754C: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7550: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7554: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7558: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B755C: 41980008  blt cr6, 0x821b7564
	if ctx.cr[6].lt {
	pc = 0x821B7564; continue 'dispatch;
	}
	// 821B7560: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7564: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B756C: 409A0030  bne cr6, 0x821b759c
	if !ctx.cr[6].eq {
	pc = 0x821B759C; continue 'dispatch;
	}
	// 821B7570: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B7574: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7578: 41980008  blt cr6, 0x821b7580
	if ctx.cr[6].lt {
	pc = 0x821B7580; continue 'dispatch;
	}
	// 821B757C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7580: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7588: 409A0014  bne cr6, 0x821b759c
	if !ctx.cr[6].eq {
	pc = 0x821B759C; continue 'dispatch;
	}
	// 821B758C: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 821B7590: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821B7594: 7F05E040  cmplw cr6, r5, r28
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B7598: 4198FFB8  blt cr6, 0x821b7550
	if ctx.cr[6].lt {
	pc = 0x821B7550; continue 'dispatch;
	}
	// 821B759C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B75A0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B75A4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821B75A8: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 821B75AC: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821B75B0: 80C1006C  lwz r6, 0x6c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821B75B4: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B75B8: 40980080  bge cr6, 0x821b7638
	if !ctx.cr[6].lt {
	pc = 0x821B7638; continue 'dispatch;
	}
	// 821B75BC: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B75C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B75C4: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B75C8: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B75CC: 41980008  blt cr6, 0x821b75d4
	if ctx.cr[6].lt {
	pc = 0x821B75D4; continue 'dispatch;
	}
	// 821B75D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B75D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B75D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B75DC: 409A004C  bne cr6, 0x821b7628
	if !ctx.cr[6].eq {
	pc = 0x821B7628; continue 'dispatch;
	}
	// 821B75E0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B75E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B75E8: 41980008  blt cr6, 0x821b75f0
	if ctx.cr[6].lt {
	pc = 0x821B75F0; continue 'dispatch;
	}
	// 821B75EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B75F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B75F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B75F8: 409A0040  bne cr6, 0x821b7638
	if !ctx.cr[6].eq {
	pc = 0x821B7638; continue 'dispatch;
	}
	// 821B75FC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7600: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 821B7604: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7608: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821B760C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821B7610: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821B7614: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B7618: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B761C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7620: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821B7624: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B7628: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821B762C: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 821B7630: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B7634: 4198FF88  blt cr6, 0x821b75bc
	if ctx.cr[6].lt {
	pc = 0x821B75BC; continue 'dispatch;
	}
	// 821B7638: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821B763C: 40990080  ble cr6, 0x821b76bc
	if !ctx.cr[6].gt {
	pc = 0x821B76BC; continue 'dispatch;
	}
	// 821B7640: 8146FFF8  lwz r10, -8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7644: 3966FFF8  addi r11, r6, -8
	ctx.r[11].s64 = ctx.r[6].s64 + -8;
	// 821B7648: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B764C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B7650: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B7654: 41980008  blt cr6, 0x821b765c
	if ctx.cr[6].lt {
	pc = 0x821B765C; continue 'dispatch;
	}
	// 821B7658: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B765C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B7660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7664: 409A0048  bne cr6, 0x821b76ac
	if !ctx.cr[6].eq {
	pc = 0x821B76AC; continue 'dispatch;
	}
	// 821B7668: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B766C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B7670: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B7674: 41980008  blt cr6, 0x821b767c
	if ctx.cr[6].lt {
	pc = 0x821B767C; continue 'dispatch;
	}
	// 821B7678: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B767C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B7680: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7684: 409A0034  bne cr6, 0x821b76b8
	if !ctx.cr[6].eq {
	pc = 0x821B76B8; continue 'dispatch;
	}
	// 821B7688: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B768C: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 821B7690: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B7694: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7698: E8C70000  ld r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B769C: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B76A0: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B76A4: 90870004  stw r4, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821B76A8: F8CA0000  std r6, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821B76AC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821B76B0: 7F1D3040  cmplw cr6, r29, r6
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B76B4: 4198FF8C  blt cr6, 0x821b7640
	if ctx.cr[6].lt {
	pc = 0x821B7640; continue 'dispatch;
	}
	// 821B76B8: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821B76BC: 409A0078  bne cr6, 0x821b7734
	if !ctx.cr[6].eq {
	pc = 0x821B7734; continue 'dispatch;
	}
	// 821B76C0: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B76C4: 419A00F8  beq cr6, 0x821b77bc
	if ctx.cr[6].eq {
	pc = 0x821B77BC; continue 'dispatch;
	}
	// 821B76C8: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B76CC: 419A001C  beq cr6, 0x821b76e8
	if ctx.cr[6].eq {
	pc = 0x821B76E8; continue 'dispatch;
	}
	// 821B76D0: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B76D4: E9470000  ld r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B76D8: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B76DC: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B76E0: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B76E4: F9450000  std r10, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821B76E8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B76EC: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 821B76F0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B76F4: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821B76F8: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 821B76FC: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821B7700: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 821B7704: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B7708: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 821B770C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B7710: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 821B7714: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821B7718: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B771C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7720: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821B7724: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7728: 906A0004  stw r3, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821B772C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B7730: 4BFFFE84  b 0x821b75b4
	pc = 0x821B75B4; continue 'dispatch;
	// 821B7734: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B7738: 38C6FFF8  addi r6, r6, -8
	ctx.r[6].s64 = ctx.r[6].s64 + -8;
	// 821B773C: 409A0050  bne cr6, 0x821b778c
	if !ctx.cr[6].eq {
	pc = 0x821B778C; continue 'dispatch;
	}
	// 821B7740: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 821B7744: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B7748: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B774C: 419A001C  beq cr6, 0x821b7768
	if ctx.cr[6].eq {
	pc = 0x821B7768; continue 'dispatch;
	}
	// 821B7750: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7754: E9460000  ld r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 821B7758: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B775C: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7760: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B7764: F9470000  std r10, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821B7768: 38A5FFF8  addi r5, r5, -8
	ctx.r[5].s64 = ctx.r[5].s64 + -8;
	// 821B776C: E9670000  ld r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B7770: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821B7774: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7778: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B777C: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7780: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B7784: F9650000  std r11, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B7788: 4BFFFE2C  b 0x821b75b4
	pc = 0x821B75B4; continue 'dispatch;
	// 821B778C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B7790: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821B7794: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7798: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 821B779C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 821B77A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B77A4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B77A8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B77AC: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B77B0: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821B77B4: F9260000  std r9, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B77B8: 4BFFFDFC  b 0x821b75b4
	pc = 0x821B75B4; continue 'dispatch;
	// 821B77BC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B77C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B77C4: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B77C8: F97B0000  std r11, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B77CC: F95B0008  std r10, 8(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B77D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821B77D4: 48AF1C80  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B77D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B77D8 size=408
    let mut pc: u32 = 0x821B77D8;
    'dispatch: loop {
        match pc {
            0x821B77D8 => {
    //   block [0x821B77D8..0x821B7970)
	// 821B77D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B77DC: 48AF1C25  bl 0x82ca9400
	ctx.lr = 0x821B77E0;
	sub_82CA93D0(ctx, base);
	// 821B77E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B77E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B77E8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821B77EC: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 821B77F0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B77F4: FB4100B8  std r26, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u64 ) };
	// 821B77F8: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B77FC: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821B7800: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 821B7804: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B7808: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B780C: 40990098  ble cr6, 0x821b78a4
	if !ctx.cr[6].gt {
	pc = 0x821B78A4; continue 'dispatch;
	}
	// 821B7810: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B7814: 409900B0  ble cr6, 0x821b78c4
	if !ctx.cr[6].gt {
	pc = 0x821B78C4; continue 'dispatch;
	}
	// 821B7818: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821B781C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B7820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B7824: 4BFFFC45  bl 0x821b7468
	ctx.lr = 0x821B7828;
	sub_821B7468(ctx, base);
	// 821B7828: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 821B782C: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B7830: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821B7834: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B7838: 7CE9E850  subf r7, r9, r29
	ctx.r[7].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	// 821B783C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B7840: 7CDE4050  subf r6, r30, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[30].s64;
	// 821B7844: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821B7848: 54E50038  rlwinm r5, r7, 0, 0, 0x1c
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821B784C: 54C40038  rlwinm r4, r6, 0, 0, 0x1c
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821B7850: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B7854: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821B7858: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B785C: 40980020  bge cr6, 0x821b787c
	if !ctx.cr[6].lt {
	pc = 0x821B787C; continue 'dispatch;
	}
	// 821B7860: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B7864: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B7868: 4BFFFF71  bl 0x821b77d8
	ctx.lr = 0x821B786C;
	sub_821B77D8(ctx, base);
	// 821B786C: EB610058  ld r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7870: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 821B7874: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B7878: 4800001C  b 0x821b7894
	pc = 0x821B7894; continue 'dispatch;
	// 821B787C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B7880: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7884: 4BFFFF55  bl 0x821b77d8
	ctx.lr = 0x821B7888;
	sub_821B77D8(ctx, base);
	// 821B7888: EB410050  ld r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B788C: FB4100B8  std r26, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u64 ) };
	// 821B7890: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821B7894: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 821B7898: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B789C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B78A0: 4199FF70  bgt cr6, 0x821b7810
	if ctx.cr[6].gt {
	pc = 0x821B7810; continue 'dispatch;
	}
	// 821B78A4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B78A8: 40990014  ble cr6, 0x821b78bc
	if !ctx.cr[6].gt {
	pc = 0x821B78BC; continue 'dispatch;
	}
	// 821B78AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B78B0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B78B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B78B8: 480000B9  bl 0x821b7970
	ctx.lr = 0x821B78BC;
	sub_821B7970(ctx, base);
	// 821B78BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B78C0: 48AF1B90  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 821B78C4: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B78C8: 4099FFDC  ble cr6, 0x821b78a4
	if !ctx.cr[6].gt {
	pc = 0x821B78A4; continue 'dispatch;
	}
	// 821B78CC: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 821B78D0: 7D7C1E70  srawi r28, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B78D4: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821B78D8: 4099003C  ble cr6, 0x821b7914
	if !ctx.cr[6].gt {
	pc = 0x821B7914; continue 'dispatch;
	}
	// 821B78DC: 7F8B0E70  srawi r11, r28, 1
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 1) as i64;
	// 821B78E0: 7FEB0195  addze. r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B78E4: 40810030  ble 0x821b7914
	if !ctx.cr[0].gt {
	pc = 0x821B7914; continue 'dispatch;
	}
	// 821B78E8: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B78EC: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821B78F0: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 821B78F4: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 821B78F8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B78FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B7900: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B7904: E8DD0000  ld r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821B7908: 488F1811  bl 0x82aa9118
	ctx.lr = 0x821B790C;
	sub_82AA9118(ctx, base);
	// 821B790C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B7910: 4199FFE0  bgt cr6, 0x821b78f0
	if ctx.cr[6].gt {
	pc = 0x821B78F0; continue 'dispatch;
	}
	// 821B7914: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 821B7918: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821B791C: 4099FFA0  ble cr6, 0x821b78bc
	if !ctx.cr[6].gt {
	pc = 0x821B78BC; continue 'dispatch;
	}
	// 821B7920: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B7924: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 821B7928: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B792C: E8DFFFF8  ld r6, -8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	// 821B7930: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B7934: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821B7938: 7D1E5850  subf r8, r30, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821B793C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B7940: 7D051E70  srawi r5, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821B7944: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7948: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B794C: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821B7950: 488F17C9  bl 0x82aa9118
	ctx.lr = 0x821B7954;
	sub_82AA9118(ctx, base);
	// 821B7954: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 821B7958: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 821B795C: 7D7C1E70  srawi r28, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B7960: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821B7964: 4199FFC0  bgt cr6, 0x821b7924
	if ctx.cr[6].gt {
	pc = 0x821B7924; continue 'dispatch;
	}
	// 821B7968: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B796C: 48AF1AE4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7970 size=252
    let mut pc: u32 = 0x821B7970;
    'dispatch: loop {
        match pc {
            0x821B7970 => {
    //   block [0x821B7970..0x821B7A6C)
	// 821B7970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7974: 48AF1A91  bl 0x82ca9404
	ctx.lr = 0x821B7978;
	sub_82CA93D0(ctx, base);
	// 821B7978: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B797C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B7980: FB8100B0  std r28, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u64 ) };
	// 821B7984: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 821B7988: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B798C: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821B7990: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821B7994: 419A00D0  beq cr6, 0x821b7a64
	if ctx.cr[6].eq {
	pc = 0x821B7A64; continue 'dispatch;
	}
	// 821B7998: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 821B799C: FB810060  std r28, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u64 ) };
	// 821B79A0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 821B79A4: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821B79A8: 419A00BC  beq cr6, 0x821b7a64
	if ctx.cr[6].eq {
	pc = 0x821B7A64; continue 'dispatch;
	}
	// 821B79AC: EBDF0000  ld r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 821B79B0: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B79B4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B79B8: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 821B79BC: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 821B79C0: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B79C4: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B79C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B79CC: 41980008  blt cr6, 0x821b79d4
	if ctx.cr[6].lt {
	pc = 0x821B79D4; continue 'dispatch;
	}
	// 821B79D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B79D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B79D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B79DC: 419A0024  beq cr6, 0x821b7a00
	if ctx.cr[6].eq {
	pc = 0x821B7A00; continue 'dispatch;
	}
	// 821B79E0: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 821B79E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B79E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B79EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B79F0: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B79F4: 488F186D  bl 0x82aa9260
	ctx.lr = 0x821B79F8;
	sub_82AA9260(ctx, base);
	// 821B79F8: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821B79FC: 48000058  b 0x821b7a54
	pc = 0x821B7A54; continue 'dispatch;
	// 821B7A00: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 821B7A04: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B7A08: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 821B7A0C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B7A10: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7A14: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B7A18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7A1C: 41980008  blt cr6, 0x821b7a24
	if ctx.cr[6].lt {
	pc = 0x821B7A24; continue 'dispatch;
	}
	// 821B7A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7A24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7A2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B7A30: 419A0020  beq cr6, 0x821b7a50
	if ctx.cr[6].eq {
	pc = 0x821B7A50; continue 'dispatch;
	}
	// 821B7A34: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7A38: E8E10058  ld r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7A3C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B7A40: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7A44: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 821B7A48: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821B7A4C: 4BFFFFBC  b 0x821b7a08
	pc = 0x821B7A08; continue 'dispatch;
	// 821B7A50: FBCB0000  std r30, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821B7A54: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821B7A58: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 821B7A5C: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821B7A60: 409AFF4C  bne cr6, 0x821b79ac
	if !ctx.cr[6].eq {
	pc = 0x821B79AC; continue 'dispatch;
	}
	// 821B7A64: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B7A68: 48AF19EC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7A70 size=136
    let mut pc: u32 = 0x821B7A70;
    'dispatch: loop {
        match pc {
            0x821B7A70 => {
    //   block [0x821B7A70..0x821B7AF8)
	// 821B7A70: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B7A74: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 821B7A78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B7A7C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821B7A80: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821B7A84: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7A88: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 821B7A8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7A90: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B7A94: 419A0008  beq cr6, 0x821b7a9c
	if ctx.cr[6].eq {
	pc = 0x821B7A9C; continue 'dispatch;
	}
	// 821B7A98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B7A9C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B7AA0: 419A006C  beq cr6, 0x821b7b0c
	if ctx.cr[6].eq {
		sub_821B7B0C(ctx, base);
		return;
	}
	// 821B7AA4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7AA8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B7AAC: 409A0008  bne cr6, 0x821b7ab4
	if !ctx.cr[6].eq {
	pc = 0x821B7AB4; continue 'dispatch;
	}
	// 821B7AB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B7AB4: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B7AB8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 821B7ABC: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821B7AC0: 4099004C  ble cr6, 0x821b7b0c
	if !ctx.cr[6].gt {
		sub_821B7B0C(ctx, base);
		return;
	}
	// 821B7AC4: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7AC8: 80830024  lwz r4, 0x24(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B7ACC: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B7AD0: 409A0018  bne cr6, 0x821b7ae8
	if !ctx.cr[6].eq {
	pc = 0x821B7AE8; continue 'dispatch;
	}
	// 821B7AD4: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B7AD8: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7ADC: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821B7AE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B7AE4: 419A0008  beq cr6, 0x821b7aec
	if ctx.cr[6].eq {
	pc = 0x821B7AEC; continue 'dispatch;
	}
	// 821B7AE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B7AEC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B7AF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7AF4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7AF8 size=20
    let mut pc: u32 = 0x821B7AF8;
    'dispatch: loop {
        match pc {
            0x821B7AF8 => {
    //   block [0x821B7AF8..0x821B7B0C)
	// 821B7AF8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B7AFC: 409A0008  bne cr6, 0x821b7b04
	if !ctx.cr[6].eq {
	pc = 0x821B7B04; continue 'dispatch;
	}
	// 821B7B00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821B7B04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7B08: 4BFFFF88  b 0x821b7a90
	sub_821B7A70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7B0C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7B0C size=8
    let mut pc: u32 = 0x821B7B0C;
    'dispatch: loop {
        match pc {
            0x821B7B0C => {
    //   block [0x821B7B0C..0x821B7B14)
	// 821B7B0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B7B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7B18 size=132
    let mut pc: u32 = 0x821B7B18;
    'dispatch: loop {
        match pc {
            0x821B7B18 => {
    //   block [0x821B7B18..0x821B7B9C)
	// 821B7B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7B20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B7B24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7B28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B7B2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7B30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7B34: 419A0048  beq cr6, 0x821b7b7c
	if ctx.cr[6].eq {
	pc = 0x821B7B7C; continue 'dispatch;
	}
	// 821B7B38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821B7B3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7B40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821B7B44: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B7B48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B7B4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7B50: 4082FFE8  bne 0x821b7b38
	if !ctx.cr[0].eq {
	pc = 0x821B7B38; continue 'dispatch;
	}
	// 821B7B54: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821B7B58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7B5C: 409A0020  bne cr6, 0x821b7b7c
	if !ctx.cr[6].eq {
	pc = 0x821B7B7C; continue 'dispatch;
	}
	// 821B7B60: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7B64: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7B68: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7B6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B7B70: 4E800421  bctrl
	ctx.lr = 0x821B7B74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7B74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7B78: 480641C1  bl 0x8221bd38
	ctx.lr = 0x821B7B7C;
	sub_8221BD38(ctx, base);
	// 821B7B7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7B80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B7B84: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821B7B88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B7B8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7B90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7B94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B7B98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7BA0 size=492
    let mut pc: u32 = 0x821B7BA0;
    'dispatch: loop {
        match pc {
            0x821B7BA0 => {
    //   block [0x821B7BA0..0x821B7D8C)
	// 821B7BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7BA4: 48AF1859  bl 0x82ca93fc
	ctx.lr = 0x821B7BA8;
	sub_82CA93D0(ctx, base);
	// 821B7BA8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821B7BAC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7BB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B7BB4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7BB8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821B7BBC: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 821B7BC0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B7BC4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 821B7BC8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B7BCC: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7BD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B7BD4: 390A303C  addi r8, r10, 0x303c
	ctx.r[8].s64 = ctx.r[10].s64 + 12348;
	// 821B7BD8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B7BDC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821B7BE0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B7BE4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B7BE8: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B7BEC: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821B7BF0: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 821B7BF4: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 821B7BF8: 3B7F0030  addi r27, r31, 0x30
	ctx.r[27].s64 = ctx.r[31].s64 + 48;
	// 821B7BFC: 90FF0010  stw r7, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 821B7C00: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821B7C04: 909F0020  stw r4, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 821B7C08: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 821B7C0C: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 821B7C10: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 821B7C14: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 821B7C18: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 821B7C1C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B7C20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7C24: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B7C28: 419A0078  beq cr6, 0x821b7ca0
	if ctx.cr[6].eq {
	pc = 0x821B7CA0; continue 'dispatch;
	}
	// 821B7C2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7C30: 419A0040  beq cr6, 0x821b7c70
	if ctx.cr[6].eq {
	pc = 0x821B7C70; continue 'dispatch;
	}
	// 821B7C34: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821B7C38: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B7C3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7C40: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B7C44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B7C48: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B7C4C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7C50: 4082FFE8  bne 0x821b7c38
	if !ctx.cr[0].eq {
	pc = 0x821B7C38; continue 'dispatch;
	}
	// 821B7C54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7C58: 409A0014  bne cr6, 0x821b7c6c
	if !ctx.cr[6].eq {
	pc = 0x821B7C6C; continue 'dispatch;
	}
	// 821B7C5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7C60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7C64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B7C68: 4E800421  bctrl
	ctx.lr = 0x821B7C6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7C6C: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 821B7C70: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7C78: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821B7C7C: 419A0024  beq cr6, 0x821b7ca0
	if ctx.cr[6].eq {
	pc = 0x821B7CA0; continue 'dispatch;
	}
	// 821B7C80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B7C84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821B7C88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7C8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821B7C90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B7C94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B7C98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7C9C: 4082FFE8  bne 0x821b7c84
	if !ctx.cr[0].eq {
	pc = 0x821B7C84; continue 'dispatch;
	}
	// 821B7CA0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B7CA4: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 821B7CA8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821B7CAC: C3EB6B9C  lfs f31, 0x6b9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27548 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B7CB0: 409A0058  bne cr6, 0x821b7d08
	if !ctx.cr[6].eq {
	pc = 0x821B7D08; continue 'dispatch;
	}
	// 821B7CB4: C01D9A80  lfs f0, -0x6580(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7CB8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821B7CBC: 40980028  bge cr6, 0x821b7ce4
	if !ctx.cr[6].lt {
	pc = 0x821B7CE4; continue 'dispatch;
	}
	// 821B7CC0: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 821B7CC4: 48067595  bl 0x8221f258
	ctx.lr = 0x821B7CC8;
	sub_8221F258(ctx, base);
	// 821B7CC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7CCC: 419A0038  beq cr6, 0x821b7d04
	if ctx.cr[6].eq {
	pc = 0x821B7D04; continue 'dispatch;
	}
	// 821B7CD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B7CD4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B7CD8: 394B18C0  addi r10, r11, 0x18c0
	ctx.r[10].s64 = ctx.r[11].s64 + 6336;
	// 821B7CDC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7CE0: 48000028  b 0x821b7d08
	pc = 0x821B7D08; continue 'dispatch;
	// 821B7CE4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821B7CE8: 48067571  bl 0x8221f258
	ctx.lr = 0x821B7CEC;
	sub_8221F258(ctx, base);
	// 821B7CEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7CF0: 419A0014  beq cr6, 0x821b7d04
	if ctx.cr[6].eq {
	pc = 0x821B7D04; continue 'dispatch;
	}
	// 821B7CF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B7CF8: 480D3E49  bl 0x8228bb40
	ctx.lr = 0x821B7CFC;
	sub_8228BB40(ctx, base);
	// 821B7CFC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B7D00: 48000008  b 0x821b7d08
	pc = 0x821B7D08; continue 'dispatch;
	// 821B7D04: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 821B7D08: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821B7D0C: 409A0058  bne cr6, 0x821b7d64
	if !ctx.cr[6].eq {
	pc = 0x821B7D64; continue 'dispatch;
	}
	// 821B7D10: C01D9A80  lfs f0, -0x6580(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7D14: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821B7D18: 40980028  bge cr6, 0x821b7d40
	if !ctx.cr[6].lt {
	pc = 0x821B7D40; continue 'dispatch;
	}
	// 821B7D1C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 821B7D20: 48067539  bl 0x8221f258
	ctx.lr = 0x821B7D24;
	sub_8221F258(ctx, base);
	// 821B7D24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7D28: 419A0038  beq cr6, 0x821b7d60
	if ctx.cr[6].eq {
	pc = 0x821B7D60; continue 'dispatch;
	}
	// 821B7D2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B7D30: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B7D34: 394B1770  addi r10, r11, 0x1770
	ctx.r[10].s64 = ctx.r[11].s64 + 6000;
	// 821B7D38: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7D3C: 48000028  b 0x821b7d64
	pc = 0x821B7D64; continue 'dispatch;
	// 821B7D40: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821B7D44: 48067515  bl 0x8221f258
	ctx.lr = 0x821B7D48;
	sub_8221F258(ctx, base);
	// 821B7D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7D4C: 419A0014  beq cr6, 0x821b7d60
	if ctx.cr[6].eq {
	pc = 0x821B7D60; continue 'dispatch;
	}
	// 821B7D50: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B7D54: 480719E5  bl 0x82229738
	ctx.lr = 0x821B7D58;
	sub_82229738(ctx, base);
	// 821B7D58: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B7D5C: 48000008  b 0x821b7d64
	pc = 0x821B7D64; continue 'dispatch;
	// 821B7D60: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 821B7D64: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B7D68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B7D6C: 483ADEFD  bl 0x82565c68
	ctx.lr = 0x821B7D70;
	sub_82565C68(ctx, base);
	// 821B7D70: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B7D74: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B7D78: 483ADEF1  bl 0x82565c68
	ctx.lr = 0x821B7D7C;
	sub_82565C68(ctx, base);
	// 821B7D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B7D80: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B7D84: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821B7D88: 48AF16C4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7D90 size=2088
    let mut pc: u32 = 0x821B7D90;
    'dispatch: loop {
        match pc {
            0x821B7D90 => {
    //   block [0x821B7D90..0x821B85B8)
	// 821B7D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7D94: 48AF1661  bl 0x82ca93f4
	ctx.lr = 0x821B7D98;
	sub_82CA93D0(ctx, base);
	// 821B7D98: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821B7D9C: 48AF5F35  bl 0x82cadcd0
	ctx.lr = 0x821B7DA0;
	sub_82CADCA0(ctx, base);
	// 821B7DA0: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B85B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B85B8 size=40
    let mut pc: u32 = 0x821B85B8;
    'dispatch: loop {
        match pc {
            0x821B85B8 => {
    //   block [0x821B85B8..0x821B85E0)
	// 821B85B8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821B85BC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821B85C0: 81686D04  lwz r11, 0x6d04(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27908 as u32) ) } as u64;
	// 821B85C4: 812A6D08  lwz r9, 0x6d08(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27912 as u32) ) } as u64;
	// 821B85C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B85CC: 91686D04  stw r11, 0x6d04(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27908 as u32), ctx.r[11].u32 ) };
	// 821B85D0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B85D4: 41980008  blt cr6, 0x821b85dc
	if ctx.cr[6].lt {
	pc = 0x821B85DC; continue 'dispatch;
	}
	// 821B85D8: 916A6D08  stw r11, 0x6d08(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(27912 as u32), ctx.r[11].u32 ) };
	// 821B85DC: 4801C4F4  b 0x821d4ad0
	sub_821D4AD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B85E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B85E0 size=128
    let mut pc: u32 = 0x821B85E0;
    'dispatch: loop {
        match pc {
            0x821B85E0 => {
    //   block [0x821B85E0..0x821B8660)
	// 821B85E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B85E4: 48AF0E25  bl 0x82ca9408
	ctx.lr = 0x821B85E8;
	sub_82CA93D0(ctx, base);
	// 821B85E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B85EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B85F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B85F4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B85F8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821B85FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8604: 409A0010  bne cr6, 0x821b8614
	if !ctx.cr[6].eq {
	pc = 0x821B8614; continue 'dispatch;
	}
	// 821B8608: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821B860C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821B8610: 48000008  b 0x821b8618
	pc = 0x821B8618; continue 'dispatch;
	// 821B8614: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8618: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B861C: 480F13CD  bl 0x822a99e8
	ctx.lr = 0x821B8620;
	sub_822A99E8(ctx, base);
	// 821B8620: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B8624: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B8628: 419A001C  beq cr6, 0x821b8644
	if ctx.cr[6].eq {
	pc = 0x821B8644; continue 'dispatch;
	}
	// 821B862C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B8630: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B8634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B8638: 48029831  bl 0x821e1e68
	ctx.lr = 0x821B863C;
	sub_821E1E68(ctx, base);
	// 821B863C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8640: 409A0018  bne cr6, 0x821b8658
	if !ctx.cr[6].eq {
	pc = 0x821B8658; continue 'dispatch;
	}
	// 821B8644: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B8648: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B864C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B8650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B8654: 48029815  bl 0x821e1e68
	ctx.lr = 0x821B8658;
	sub_821E1E68(ctx, base);
	// 821B8658: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B865C: 48AF0DFC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B8660 size=568
    let mut pc: u32 = 0x821B8660;
    'dispatch: loop {
        match pc {
            0x821B8660 => {
    //   block [0x821B8660..0x821B8898)
	// 821B8660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8664: 48AF0DA5  bl 0x82ca9408
	ctx.lr = 0x821B8668;
	sub_82CA93D0(ctx, base);
	// 821B8668: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821B866C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B8898 size=100
    let mut pc: u32 = 0x821B8898;
    'dispatch: loop {
        match pc {
            0x821B8898 => {
    //   block [0x821B8898..0x821B88FC)
	// 821B8898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B889C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B88A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B88A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B88A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B88AC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B88B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B88B4: 419A0030  beq cr6, 0x821b88e4
	if ctx.cr[6].eq {
	pc = 0x821B88E4; continue 'dispatch;
	}
	// 821B88B8: 4800F561  bl 0x821c7e18
	ctx.lr = 0x821B88BC;
	sub_821C7E18(ctx, base);
	// 821B88BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B88C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B88C4: 419A0020  beq cr6, 0x821b88e4
	if ctx.cr[6].eq {
	pc = 0x821B88E4; continue 'dispatch;
	}
	// 821B88C8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B88CC: 4800F395  bl 0x821c7c60
	ctx.lr = 0x821B88D0;
	sub_821C7C60(ctx, base);
	// 821B88D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B88D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B88D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B88DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B88E0: 4E800020  blr
	return;
	// 821B88E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B88E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B88EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B88F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B88F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B88F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B8900 size=1560
    let mut pc: u32 = 0x821B8900;
    'dispatch: loop {
        match pc {
            0x821B8900 => {
    //   block [0x821B8900..0x821B8F18)
	// 821B8900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8904: 48AF0AF9  bl 0x82ca93fc
	ctx.lr = 0x821B8908;
	sub_82CA93D0(ctx, base);
	// 821B8908: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821B890C: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B8910: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B8914: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B8918: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821B891C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B8920: 4802AE19  bl 0x821e3738
	ctx.lr = 0x821B8924;
	sub_821E3738(ctx, base);
	// 821B8924: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8928: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 821B892C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821B8930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8934: 419A001C  beq cr6, 0x821b8950
	if ctx.cr[6].eq {
	pc = 0x821B8950; continue 'dispatch;
	}
	// 821B8938: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B893C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8940: 419A000C  beq cr6, 0x821b894c
	if ctx.cr[6].eq {
	pc = 0x821B894C; continue 'dispatch;
	}
	// 821B8944: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B8948: 4800000C  b 0x821b8954
	pc = 0x821B8954; continue 'dispatch;
	// 821B894C: 4BFDB4ED  bl 0x82193e38
	ctx.lr = 0x821B8950;
	sub_82193E38(ctx, base);
	// 821B8950: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B8954: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B8958: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821B895C: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 821B8960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B8964: 419A00F4  beq cr6, 0x821b8a58
	if ctx.cr[6].eq {
	pc = 0x821B8A58; continue 'dispatch;
	}
	// 821B8968: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B896C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8970: 419A0024  beq cr6, 0x821b8994
	if ctx.cr[6].eq {
	pc = 0x821B8994; continue 'dispatch;
	}
	// 821B8974: 894A005B  lbz r10, 0x5b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(91 as u32) ) } as u64;
	// 821B8978: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B897C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B8980: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B8984: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8988: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B898C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8990: 480000CC  b 0x821b8a5c
	pc = 0x821B8A5C; continue 'dispatch;
	// 821B8994: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B8998: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B899C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B89A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B89A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B89A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B89AC: 40810054  ble 0x821b8a00
	if !ctx.cr[0].gt {
	pc = 0x821B8A00; continue 'dispatch;
	}
	// 821B89B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B89B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B89B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B89BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B89C0: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 821B89C4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821B89C8: 41980008  blt cr6, 0x821b89d0
	if ctx.cr[6].lt {
	pc = 0x821B89D0; continue 'dispatch;
	}
	// 821B89CC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821B89D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B89D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B89D8: 419A0014  beq cr6, 0x821b89ec
	if ctx.cr[6].eq {
	pc = 0x821B89EC; continue 'dispatch;
	}
	// 821B89DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B89E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B89E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B89E8: 4800000C  b 0x821b89f4
	pc = 0x821B89F4; continue 'dispatch;
	// 821B89EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B89F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B89F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B89F8: 4199FFB8  bgt cr6, 0x821b89b0
	if ctx.cr[6].gt {
	pc = 0x821B89B0; continue 'dispatch;
	}
	// 821B89FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B8A00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B8A04: 419A0040  beq cr6, 0x821b8a44
	if ctx.cr[6].eq {
	pc = 0x821B8A44; continue 'dispatch;
	}
	// 821B8A08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8A0C: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 821B8A10: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8A14: 41990008  bgt cr6, 0x821b8a1c
	if ctx.cr[6].gt {
	pc = 0x821B8A1C; continue 'dispatch;
	}
	// 821B8A18: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B8A1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8A24: 409A0020  bne cr6, 0x821b8a44
	if !ctx.cr[6].eq {
	pc = 0x821B8A44; continue 'dispatch;
	}
	// 821B8A28: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B8A2C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B8A30: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B8A34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8A38: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B8A3C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8A40: 4800001C  b 0x821b8a5c
	pc = 0x821B8A5C; continue 'dispatch;
	// 821B8A44: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B8A48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8A4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B8A50: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8A54: 48000008  b 0x821b8a5c
	pc = 0x821B8A5C; continue 'dispatch;
	// 821B8A58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B8A5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8A60: 3BA0000C  li r29, 0xc
	ctx.r[29].s64 = 12;
	// 821B8A64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8A68: 419A01C8  beq cr6, 0x821b8c30
	if ctx.cr[6].eq {
	pc = 0x821B8C30; continue 'dispatch;
	}
	// 821B8A6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B8A70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B8A74: 4805C085  bl 0x82214af8
	ctx.lr = 0x821B8A78;
	sub_82214AF8(ctx, base);
	// 821B8A78: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B8A7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8A80: 419A01AC  beq cr6, 0x821b8c2c
	if ctx.cr[6].eq {
	pc = 0x821B8C2C; continue 'dispatch;
	}
	// 821B8A84: 813B0018  lwz r9, 0x18(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B8A88: 80DB001C  lwz r6, 0x1c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8A8C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B8A90: 7D693050  subf r11, r9, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 821B8A94: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B8A98: 7D6BEBD7  divw. r11, r11, r29
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8A9C: 4081005C  ble 0x821b8af8
	if !ctx.cr[0].gt {
	pc = 0x821B8AF8; continue 'dispatch;
	}
	// 821B8AA0: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B8AA4: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B8AA8: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B8AAC: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B8AB0: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821B8AB4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8AB8: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821B8ABC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821B8AC0: 41980008  blt cr6, 0x821b8ac8
	if ctx.cr[6].lt {
	pc = 0x821B8AC8; continue 'dispatch;
	}
	// 821B8AC4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821B8AC8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B8ACC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B8AD0: 419A0014  beq cr6, 0x821b8ae4
	if ctx.cr[6].eq {
	pc = 0x821B8AE4; continue 'dispatch;
	}
	// 821B8AD4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B8AD8: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821B8ADC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B8AE0: 4800000C  b 0x821b8aec
	pc = 0x821B8AEC; continue 'dispatch;
	// 821B8AE4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821B8AE8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821B8AEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8AF0: 4199FFB0  bgt cr6, 0x821b8aa0
	if ctx.cr[6].gt {
	pc = 0x821B8AA0; continue 'dispatch;
	}
	// 821B8AF4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B8AF8: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B8AFC: 419A0034  beq cr6, 0x821b8b30
	if ctx.cr[6].eq {
	pc = 0x821B8B30; continue 'dispatch;
	}
	// 821B8B00: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8B04: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B8B08: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8B0C: 41990008  bgt cr6, 0x821b8b14
	if ctx.cr[6].gt {
	pc = 0x821B8B14; continue 'dispatch;
	}
	// 821B8B10: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B8B14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8B1C: 409A0014  bne cr6, 0x821b8b30
	if !ctx.cr[6].eq {
	pc = 0x821B8B30; continue 'dispatch;
	}
	// 821B8B20: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B8B24: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B8B28: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B8B2C: 48000008  b 0x821b8b34
	pc = 0x821B8B34; continue 'dispatch;
	// 821B8B30: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B8B34: 815B001C  lwz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8B38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B8B3C: 419A0010  beq cr6, 0x821b8b4c
	if ctx.cr[6].eq {
	pc = 0x821B8B4C; continue 'dispatch;
	}
	// 821B8B40: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8B44: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8B48: 48000008  b 0x821b8b50
	pc = 0x821B8B50; continue 'dispatch;
	// 821B8B4C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B8B50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8B54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8B58: 419A00D4  beq cr6, 0x821b8c2c
	if ctx.cr[6].eq {
	pc = 0x821B8C2C; continue 'dispatch;
	}
	// 821B8B5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B8B60: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 821B8B64: FB8100F8  std r28, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	// 821B8B68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B8B6C: 394B5F1C  addi r10, r11, 0x5f1c
	ctx.r[10].s64 = ctx.r[11].s64 + 24348;
	// 821B8B70: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 821B8B74: 4BFD8B9D  bl 0x82191710
	ctx.lr = 0x821B8B78;
	sub_82191710(ctx, base);
	// 821B8B78: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8B7C: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B8B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8B84: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821B8B88: 409A0010  bne cr6, 0x821b8b98
	if !ctx.cr[6].eq {
	pc = 0x821B8B98; continue 'dispatch;
	}
	// 821B8B8C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821B8B90: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821B8B94: 48000008  b 0x821b8b9c
	pc = 0x821B8B9C; continue 'dispatch;
	// 821B8B98: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8B9C: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 821B8BA0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821B8BA4: 48114505  bl 0x822cd0a8
	ctx.lr = 0x821B8BA8;
	sub_822CD0A8(ctx, base);
	// 821B8BA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8BAC: 480E62CD  bl 0x8229ee78
	ctx.lr = 0x821B8BB0;
	sub_8229EE78(ctx, base);
	// 821B8BB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8BB4: 419A0018  beq cr6, 0x821b8bcc
	if ctx.cr[6].eq {
	pc = 0x821B8BCC; continue 'dispatch;
	}
	// 821B8BB8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B8BBC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B8BC0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8BC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8BC8: 409A0008  bne cr6, 0x821b8bd0
	if !ctx.cr[6].eq {
	pc = 0x821B8BD0; continue 'dispatch;
	}
	// 821B8BCC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B8BD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8BD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8BD8: 419A0018  beq cr6, 0x821b8bf0
	if ctx.cr[6].eq {
	pc = 0x821B8BF0; continue 'dispatch;
	}
	// 821B8BDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8BE0: 480E6299  bl 0x8229ee78
	ctx.lr = 0x821B8BE4;
	sub_8229EE78(ctx, base);
	// 821B8BE4: 4BFF97AD  bl 0x821b2390
	ctx.lr = 0x821B8BE8;
	sub_821B2390(ctx, base);
	// 821B8BE8: F86100F8  std r3, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[3].u64 ) };
	// 821B8BEC: 48000008  b 0x821b8bf4
	pc = 0x821B8BF4; continue 'dispatch;
	// 821B8BF0: FB8100F8  std r28, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	// 821B8BF4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B8BF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8BFC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B8C00: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B8C04: 832A008C  lwz r25, 0x8c(r10)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B8C08: 4BFBB861  bl 0x82174468
	ctx.lr = 0x821B8C0C;
	sub_82174468(ctx, base);
	// 821B8C0C: 4BFF9785  bl 0x821b2390
	ctx.lr = 0x821B8C10;
	sub_821B2390(ctx, base);
	// 821B8C10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B8C14: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821B8C18: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821B8C1C: 4811D9BD  bl 0x822d65d8
	ctx.lr = 0x821B8C20;
	sub_822D65D8(ctx, base);
	// 821B8C20: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821B8C24: 39092DC8  addi r8, r9, 0x2dc8
	ctx.r[8].s64 = ctx.r[9].s64 + 11720;
	// 821B8C28: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 821B8C2C: 9B9F006C  stb r28, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[28].u8 ) };
	// 821B8C30: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 821B8C34: 48066625  bl 0x8221f258
	ctx.lr = 0x821B8C38;
	sub_8221F258(ctx, base);
	// 821B8C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8C3C: 419A0014  beq cr6, 0x821b8c50
	if ctx.cr[6].eq {
	pc = 0x821B8C50; continue 'dispatch;
	}
	// 821B8C40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B8C44: 4BFD51CD  bl 0x8218de10
	ctx.lr = 0x821B8C48;
	sub_8218DE10(ctx, base);
	// 821B8C48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8C4C: 48000008  b 0x821b8c54
	pc = 0x821B8C54; continue 'dispatch;
	// 821B8C50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B8C54: 897B0081  lbz r11, 0x81(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(129 as u32) ) } as u64;
	// 821B8C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C5C: 419A0008  beq cr6, 0x821b8c64
	if ctx.cr[6].eq {
	pc = 0x821B8C64; continue 'dispatch;
	}
	// 821B8C60: 9B440031  stb r26, 0x31(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(49 as u32), ctx.r[26].u8 ) };
	// 821B8C64: 897B0083  lbz r11, 0x83(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(131 as u32) ) } as u64;
	// 821B8C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C6C: 419A0008  beq cr6, 0x821b8c74
	if ctx.cr[6].eq {
	pc = 0x821B8C74; continue 'dispatch;
	}
	// 821B8C70: 9B440032  stb r26, 0x32(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(50 as u32), ctx.r[26].u8 ) };
	// 821B8C74: 897B0082  lbz r11, 0x82(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(130 as u32) ) } as u64;
	// 821B8C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C7C: 419A0008  beq cr6, 0x821b8c84
	if ctx.cr[6].eq {
	pc = 0x821B8C84; continue 'dispatch;
	}
	// 821B8C80: 9B440033  stb r26, 0x33(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(51 as u32), ctx.r[26].u8 ) };
	// 821B8C84: 897B0085  lbz r11, 0x85(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(133 as u32) ) } as u64;
	// 821B8C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C8C: 419A0008  beq cr6, 0x821b8c94
	if ctx.cr[6].eq {
	pc = 0x821B8C94; continue 'dispatch;
	}
	// 821B8C90: 9B44006E  stb r26, 0x6e(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(110 as u32), ctx.r[26].u8 ) };
	// 821B8C94: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B8C98: 48002E19  bl 0x821bbab0
	ctx.lr = 0x821B8C9C;
	sub_821BBAB0(ctx, base);
	// 821B8C9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8CA0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8CA4: 480B31C5  bl 0x8226be68
	ctx.lr = 0x821B8CA8;
	sub_8226BE68(ctx, base);
	// 821B8CA8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B8CAC: 4BFFEE6D  bl 0x821b7b18
	ctx.lr = 0x821B8CB0;
	sub_821B7B18(ctx, base);
	// 821B8CB0: 897B0084  lbz r11, 0x84(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B8CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8CB8: 419A0080  beq cr6, 0x821b8d38
	if ctx.cr[6].eq {
	pc = 0x821B8D38; continue 'dispatch;
	}
	// 821B8CBC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 821B8CC0: 48066599  bl 0x8221f258
	ctx.lr = 0x821B8CC4;
	sub_8221F258(ctx, base);
	// 821B8CC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B8CC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B8CCC: 419A0038  beq cr6, 0x821b8d04
	if ctx.cr[6].eq {
	pc = 0x821B8D04; continue 'dispatch;
	}
	// 821B8CD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B8CD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B8CD8: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 821B8CDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B8CE0: 480741F1  bl 0x8222ced0
	ctx.lr = 0x821B8CE4;
	sub_8222CED0(ctx, base);
	// 821B8CE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B8CE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B8CEC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B8CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B8CF4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 821B8CF8: 48811B89  bl 0x829ca880
	ctx.lr = 0x821B8CFC;
	sub_829CA880(ctx, base);
	// 821B8CFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8D00: 48000008  b 0x821b8d08
	pc = 0x821B8D08; continue 'dispatch;
	// 821B8D04: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B8D08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B8D0C: 48002DA5  bl 0x821bbab0
	ctx.lr = 0x821B8D10;
	sub_821BBAB0(ctx, base);
	// 821B8D10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8D14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8D18: 480B3151  bl 0x8226be68
	ctx.lr = 0x821B8D1C;
	sub_8226BE68(ctx, base);
	// 821B8D1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B8D20: 4BFFEDF9  bl 0x821b7b18
	ctx.lr = 0x821B8D24;
	sub_821B7B18(ctx, base);
	// 821B8D24: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 821B8D28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8D2C: 419A000C  beq cr6, 0x821b8d38
	if ctx.cr[6].eq {
	pc = 0x821B8D38; continue 'dispatch;
	}
	// 821B8D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B8D34: 4805C0A5  bl 0x82214dd8
	ctx.lr = 0x821B8D38;
	sub_82214DD8(ctx, base);
	// 821B8D38: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 821B8D3C: 4806651D  bl 0x8221f258
	ctx.lr = 0x821B8D40;
	sub_8221F258(ctx, base);
	// 821B8D40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B8D44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8D48: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 821B8D4C: C3EBFFF4  lfs f31, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B8D50: 419A0084  beq cr6, 0x821b8dd4
	if ctx.cr[6].eq {
	pc = 0x821B8DD4; continue 'dispatch;
	}
	// 821B8D54: 895B0080  lbz r10, 0x80(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B8D58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8D5C: 419A000C  beq cr6, 0x821b8d68
	if ctx.cr[6].eq {
	pc = 0x821B8D68; continue 'dispatch;
	}
	// 821B8D60: C1BB0078  lfs f13, 0x78(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B8D64: 48000008  b 0x821b8d6c
	pc = 0x821B8D6C; continue 'dispatch;
	// 821B8D68: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 821B8D6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821B8D70: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B8D74: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B8D78: 93630004  stw r27, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 821B8D7C: 392A1DEC  addi r9, r10, 0x1dec
	ctx.r[9].s64 = ctx.r[10].s64 + 7660;
	// 821B8D80: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B8D84: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821B8D88: 9B43000C  stb r26, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[26].u8 ) };
	// 821B8D8C: D3E3002C  stfs f31, 0x2c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821B8D90: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B8D94: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821B8D98: 9B83000D  stb r28, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[28].u8 ) };
	// 821B8D9C: D3E30034  stfs f31, 0x34(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B8DA0: 9B83000E  stb r28, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[28].u8 ) };
	// 821B8DA4: D3E30038  stfs f31, 0x38(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B8DA8: 9B830020  stb r28, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[28].u8 ) };
	// 821B8DAC: D3E3003C  stfs f31, 0x3c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B8DB0: 9B430040  stb r26, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[26].u8 ) };
	// 821B8DB4: 9B830041  stb r28, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[28].u8 ) };
	// 821B8DB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B8DBC: 9B830042  stb r28, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[28].u8 ) };
	// 821B8DC0: 9B830043  stb r28, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[28].u8 ) };
	// 821B8DC4: 93830048  stw r28, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 821B8DC8: 9383004C  stw r28, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 821B8DCC: 9B430054  stb r26, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[26].u8 ) };
	// 821B8DD0: 48000008  b 0x821b8dd8
	pc = 0x821B8DD8; continue 'dispatch;
	// 821B8DD4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821B8DD8: 817B0088  lwz r11, 0x88(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B8DDC: 3BFB0088  addi r31, r27, 0x88
	ctx.r[31].s64 = ctx.r[27].s64 + 136;
	// 821B8DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8DE4: 419A00F8  beq cr6, 0x821b8edc
	if ctx.cr[6].eq {
	pc = 0x821B8EDC; continue 'dispatch;
	}
	// 821B8DE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8DEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8DF0: 419A00EC  beq cr6, 0x821b8edc
	if ctx.cr[6].eq {
	pc = 0x821B8EDC; continue 'dispatch;
	}
	// 821B8DF4: 813B0018  lwz r9, 0x18(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B8DF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B8DFC: 80DB001C  lwz r6, 0x1c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8E00: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B8E04: 7D693050  subf r11, r9, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 821B8E08: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B8E0C: 7D6BEBD7  divw. r11, r11, r29
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8E10: 4081005C  ble 0x821b8e6c
	if !ctx.cr[0].gt {
	pc = 0x821B8E6C; continue 'dispatch;
	}
	// 821B8E14: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B8E18: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B8E1C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B8E20: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B8E24: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821B8E28: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8E2C: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821B8E30: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821B8E34: 41980008  blt cr6, 0x821b8e3c
	if ctx.cr[6].lt {
	pc = 0x821B8E3C; continue 'dispatch;
	}
	// 821B8E38: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821B8E3C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B8E40: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B8E44: 419A0014  beq cr6, 0x821b8e58
	if ctx.cr[6].eq {
	pc = 0x821B8E58; continue 'dispatch;
	}
	// 821B8E48: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B8E4C: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821B8E50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B8E54: 4800000C  b 0x821b8e60
	pc = 0x821B8E60; continue 'dispatch;
	// 821B8E58: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821B8E5C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821B8E60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8E64: 4199FFB0  bgt cr6, 0x821b8e14
	if ctx.cr[6].gt {
	pc = 0x821B8E14; continue 'dispatch;
	}
	// 821B8E68: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B8E6C: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B8E70: 419A0034  beq cr6, 0x821b8ea4
	if ctx.cr[6].eq {
	pc = 0x821B8EA4; continue 'dispatch;
	}
	// 821B8E74: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8E78: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B8E7C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8E80: 41990008  bgt cr6, 0x821b8e88
	if ctx.cr[6].gt {
	pc = 0x821B8E88; continue 'dispatch;
	}
	// 821B8E84: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B8E88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8E90: 409A0014  bne cr6, 0x821b8ea4
	if !ctx.cr[6].eq {
	pc = 0x821B8EA4; continue 'dispatch;
	}
	// 821B8E94: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B8E98: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B8E9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B8EA0: 48000008  b 0x821b8ea8
	pc = 0x821B8EA8; continue 'dispatch;
	// 821B8EA4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B8EA8: 815B001C  lwz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8EAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B8EB0: 419A0008  beq cr6, 0x821b8eb8
	if ctx.cr[6].eq {
	pc = 0x821B8EB8; continue 'dispatch;
	}
	// 821B8EB4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8EB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8EBC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B8EC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B8EC4: 4E800421  bctrl
	ctx.lr = 0x821B8EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B8EC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B8ECC: 48021F45  bl 0x821dae10
	ctx.lr = 0x821B8ED0;
	sub_821DAE10(ctx, base);
	// 821B8ED0: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 821B8ED4: 40990008  ble cr6, 0x821b8edc
	if !ctx.cr[6].gt {
	pc = 0x821B8EDC; continue 'dispatch;
	}
	// 821B8ED8: D03E0034  stfs f1, 0x34(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B8EDC: C01B007C  lfs f0, 0x7c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B8EE0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B8EE4: 40990008  ble cr6, 0x821b8eec
	if !ctx.cr[6].gt {
	pc = 0x821B8EEC; continue 'dispatch;
	}
	// 821B8EE8: D01E0038  stfs f0, 0x38(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B8EEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B8EF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B8EF4: 48002BBD  bl 0x821bbab0
	ctx.lr = 0x821B8EF8;
	sub_821BBAB0(ctx, base);
	// 821B8EF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8EFC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8F00: 480B2F69  bl 0x8226be68
	ctx.lr = 0x821B8F04;
	sub_8226BE68(ctx, base);
	// 821B8F04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B8F08: 4BFFEC11  bl 0x821b7b18
	ctx.lr = 0x821B8F0C;
	sub_821B7B18(ctx, base);
	// 821B8F0C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821B8F10: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821B8F14: 48AF0538  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B8F18 size=192
    let mut pc: u32 = 0x821B8F18;
    'dispatch: loop {
        match pc {
            0x821B8F18 => {
    //   block [0x821B8F18..0x821B8FD8)
	// 821B8F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B8F20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B8F24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B8F28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B8F2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B8F30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B8F34: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8F38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F3C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B8F40: 419A0080  beq cr6, 0x821b8fc0
	if ctx.cr[6].eq {
	pc = 0x821B8FC0; continue 'dispatch;
	}
	// 821B8F44: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821B8F48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8F4C: 419A0044  beq cr6, 0x821b8f90
	if ctx.cr[6].eq {
	pc = 0x821B8F90; continue 'dispatch;
	}
	// 821B8F50: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 821B8F54: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B8F58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B8F5C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B8F60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B8F64: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B8F68: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B8F6C: 4082FFE8  bne 0x821b8f54
	if !ctx.cr[0].eq {
	pc = 0x821B8F54; continue 'dispatch;
	}
	// 821B8F70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8F74: 409A0014  bne cr6, 0x821b8f88
	if !ctx.cr[6].eq {
	pc = 0x821B8F88; continue 'dispatch;
	}
	// 821B8F78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8F80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B8F84: 4E800421  bctrl
	ctx.lr = 0x821B8F88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B8F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B8F8C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B8F90: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8F98: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B8F9C: 419A0024  beq cr6, 0x821b8fc0
	if ctx.cr[6].eq {
	pc = 0x821B8FC0; continue 'dispatch;
	}
	// 821B8FA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B8FA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821B8FA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B8FAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821B8FB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B8FB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B8FB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B8FBC: 4082FFE8  bne 0x821b8fa4
	if !ctx.cr[0].eq {
	pc = 0x821B8FA4; continue 'dispatch;
	}
	// 821B8FC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B8FC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B8FC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B8FCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B8FD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B8FD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B8FD8 size=636
    let mut pc: u32 = 0x821B8FD8;
    'dispatch: loop {
        match pc {
            0x821B8FD8 => {
    //   block [0x821B8FD8..0x821B9254)
	// 821B8FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8FDC: 48AF0425  bl 0x82ca9400
	ctx.lr = 0x821B8FE0;
	sub_82CA93D0(ctx, base);
	// 821B8FE0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821B8FE4: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B8FE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B8FEC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821B8FF0: 480ACFA1  bl 0x82265f90
	ctx.lr = 0x821B8FF4;
	sub_82265F90(ctx, base);
	// 821B8FF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B8FF8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 821B8FFC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821B9000: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821B9004: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B9008: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B900C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B9010: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B9014: 4200FFF0  bdnz 0x821b9004
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B9004; continue 'dispatch;
	}
	// 821B9018: C3E100E0  lfs f31, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B901C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821B9020: C01E0110  lfs f0, 0x110(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B9024: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821B9028: 419A0008  beq cr6, 0x821b9030
	if ctx.cr[6].eq {
	pc = 0x821B9030; continue 'dispatch;
	}
	// 821B902C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B9030: 8B6100E4  lbz r27, 0xe4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 821B9034: 897E0114  lbz r11, 0x114(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 821B9038: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821B903C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9040: 419A0008  beq cr6, 0x821b9048
	if ctx.cr[6].eq {
	pc = 0x821B9048; continue 'dispatch;
	}
	// 821B9044: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B9048: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 821B904C: 3BBE00F0  addi r29, r30, 0xf0
	ctx.r[29].s64 = ctx.r[30].s64 + 240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9258 size=1480
    let mut pc: u32 = 0x821B9258;
    'dispatch: loop {
        match pc {
            0x821B9258 => {
    //   block [0x821B9258..0x821B9820)
	// 821B9258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B925C: 48AF01A5  bl 0x82ca9400
	ctx.lr = 0x821B9260;
	sub_82CA93D0(ctx, base);
	// 821B9260: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9264: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B9268: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B926C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B9270: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821B9274: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B9278: 995A0044  stb r10, 0x44(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 821B927C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B9280: 8169008C  lwz r11, 0x8c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B9284: 890B0034  lbz r8, 0x34(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B9288: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B928C: 419A0014  beq cr6, 0x821b92a0
	if ctx.cr[6].eq {
	pc = 0x821B92A0; continue 'dispatch;
	}
	// 821B9290: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 821B9294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9298: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B929C: 409A0008  bne cr6, 0x821b92a4
	if !ctx.cr[6].eq {
	pc = 0x821B92A4; continue 'dispatch;
	}
	// 821B92A0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B92A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B92A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B92AC: 419A0060  beq cr6, 0x821b930c
	if ctx.cr[6].eq {
	pc = 0x821B930C; continue 'dispatch;
	}
	// 821B92B0: 817A002C  lwz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B92B4: 3BFA002C  addi r31, r26, 0x2c
	ctx.r[31].s64 = ctx.r[26].s64 + 44;
	// 821B92B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B92BC: 409A0040  bne cr6, 0x821b92fc
	if !ctx.cr[6].eq {
	pc = 0x821B92FC; continue 'dispatch;
	}
	// 821B92C0: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 821B92C4: 48065F95  bl 0x8221f258
	ctx.lr = 0x821B92C8;
	sub_8221F258(ctx, base);
	// 821B92C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B92CC: 419A0014  beq cr6, 0x821b92e0
	if ctx.cr[6].eq {
	pc = 0x821B92E0; continue 'dispatch;
	}
	// 821B92D0: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B92D4: 483F4295  bl 0x825ad568
	ctx.lr = 0x821B92D8;
	sub_825AD568(ctx, base);
	// 821B92D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B92DC: 48000008  b 0x821b92e4
	pc = 0x821B92E4; continue 'dispatch;
	// 821B92E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B92E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B92E8: 480B9D71  bl 0x82273058
	ctx.lr = 0x821B92EC;
	sub_82273058(ctx, base);
	// 821B92EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B92F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B92F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B92F8: 483F44F1  bl 0x825ad7e8
	ctx.lr = 0x821B92FC;
	sub_825AD7E8(ctx, base);
	// 821B92FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B9300: 482C99B1  bl 0x82482cb0
	ctx.lr = 0x821B9304;
	sub_82482CB0(ctx, base);
	// 821B9304: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821B9308: 48AF0148  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 821B930C: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9310: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821B9314: 480E5B65  bl 0x8229ee78
	ctx.lr = 0x821B9318;
	sub_8229EE78(ctx, base);
	// 821B9318: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B931C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B9320: 419A0018  beq cr6, 0x821b9338
	if ctx.cr[6].eq {
	pc = 0x821B9338; continue 'dispatch;
	}
	// 821B9324: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B9328: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B932C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9330: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9334: 409A0008  bne cr6, 0x821b933c
	if !ctx.cr[6].eq {
	pc = 0x821B933C; continue 'dispatch;
	}
	// 821B9338: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B933C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B9340: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821B9344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9348: 419A0128  beq cr6, 0x821b9470
	if ctx.cr[6].eq {
	pc = 0x821B9470; continue 'dispatch;
	}
	// 821B934C: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9350: 480E5B29  bl 0x8229ee78
	ctx.lr = 0x821B9354;
	sub_8229EE78(ctx, base);
	// 821B9354: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B9358: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 821B935C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9360: 419A00F4  beq cr6, 0x821b9454
	if ctx.cr[6].eq {
	pc = 0x821B9454; continue 'dispatch;
	}
	// 821B9364: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B9368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B936C: 419A0024  beq cr6, 0x821b9390
	if ctx.cr[6].eq {
	pc = 0x821B9390; continue 'dispatch;
	}
	// 821B9370: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B9374: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B9378: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B937C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B9380: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9384: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B9388: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B938C: 480000CC  b 0x821b9458
	pc = 0x821B9458; continue 'dispatch;
	// 821B9390: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B9394: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B9398: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821B939C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B93A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B93A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B93A8: 40810054  ble 0x821b93fc
	if !ctx.cr[0].gt {
	pc = 0x821B93FC; continue 'dispatch;
	}
	// 821B93AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B93B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B93B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B93B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B93BC: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 821B93C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B93C4: 41980008  blt cr6, 0x821b93cc
	if ctx.cr[6].lt {
	pc = 0x821B93CC; continue 'dispatch;
	}
	// 821B93C8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B93CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B93D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B93D4: 419A0014  beq cr6, 0x821b93e8
	if ctx.cr[6].eq {
	pc = 0x821B93E8; continue 'dispatch;
	}
	// 821B93D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B93DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B93E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B93E4: 4800000C  b 0x821b93f0
	pc = 0x821B93F0; continue 'dispatch;
	// 821B93E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B93EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B93F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B93F4: 4199FFB8  bgt cr6, 0x821b93ac
	if ctx.cr[6].gt {
	pc = 0x821B93AC; continue 'dispatch;
	}
	// 821B93F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B93FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B9400: 419A0040  beq cr6, 0x821b9440
	if ctx.cr[6].eq {
	pc = 0x821B9440; continue 'dispatch;
	}
	// 821B9404: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9408: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821B940C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9410: 41990008  bgt cr6, 0x821b9418
	if ctx.cr[6].gt {
	pc = 0x821B9418; continue 'dispatch;
	}
	// 821B9414: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B9418: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B941C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9420: 409A0020  bne cr6, 0x821b9440
	if !ctx.cr[6].eq {
	pc = 0x821B9440; continue 'dispatch;
	}
	// 821B9424: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B9428: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B942C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B9430: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9434: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B9438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B943C: 4800001C  b 0x821b9458
	pc = 0x821B9458; continue 'dispatch;
	// 821B9440: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B9444: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9448: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B944C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9450: 48000008  b 0x821b9458
	pc = 0x821B9458; continue 'dispatch;
	// 821B9454: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B9458: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B945C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9460: 419A0010  beq cr6, 0x821b9470
	if ctx.cr[6].eq {
	pc = 0x821B9470; continue 'dispatch;
	}
	// 821B9464: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B9468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B946C: 409A000C  bne cr6, 0x821b9478
	if !ctx.cr[6].eq {
	pc = 0x821B9478; continue 'dispatch;
	}
	// 821B9470: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9474: 997C6BE9  stb r11, 0x6be9(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(27625 as u32), ctx.r[11].u8 ) };
	// 821B9478: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 821B947C: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821B9480: 895E6BEA  lbz r10, 0x6bea(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(27626 as u32) ) } as u64;
	// 821B9484: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9488: 419A0030  beq cr6, 0x821b94b8
	if ctx.cr[6].eq {
	pc = 0x821B94B8; continue 'dispatch;
	}
	// 821B948C: 809D007C  lwz r4, 0x7c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821B9490: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B9494: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9498: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B949C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B94A0: 4E800421  bctrl
	ctx.lr = 0x821B94A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B94A4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821B94A8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9820 size=184
    let mut pc: u32 = 0x821B9820;
    'dispatch: loop {
        match pc {
            0x821B9820 => {
    //   block [0x821B9820..0x821B98D8)
	// 821B9820: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821B9824: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821B9828: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B98D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B98D8 size=144
    let mut pc: u32 = 0x821B98D8;
    'dispatch: loop {
        match pc {
            0x821B98D8 => {
    //   block [0x821B98D8..0x821B9968)
	// 821B98D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B98DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B98E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B98E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B98E8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821B98EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B98F0: 396B4DE4  addi r11, r11, 0x4de4
	ctx.r[11].s64 = ctx.r[11].s64 + 19940;
	// 821B98F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B98F8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B98FC: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821B9900: 7D071671  srawi. r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821B9904: 41820010  beq 0x821b9914
	if ctx.cr[0].eq {
	pc = 0x821B9914; continue 'dispatch;
	}
	// 821B9908: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B990C: 419A0008  beq cr6, 0x821b9914
	if ctx.cr[6].eq {
	pc = 0x821B9914; continue 'dispatch;
	}
	// 821B9910: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821B9914: 4BFFD51D  bl 0x821b6e30
	ctx.lr = 0x821B9918;
	sub_821B6E30(ctx, base);
	// 821B9918: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B991C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B9920: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821B9924: 917F06F0  stw r11, 0x6f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1776 as u32), ctx.r[11].u32 ) };
	// 821B9928: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821B992C: 392AA978  addi r9, r10, -0x5688
	ctx.r[9].s64 = ctx.r[10].s64 + -22152;
	// 821B9930: 38A0007F  li r5, 0x7f
	ctx.r[5].s64 = 127;
	// 821B9934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B9938: 816803B8  lwz r11, 0x3b8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(952 as u32) ) } as u64;
	// 821B993C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 821B9940: 90E803B8  stw r7, 0x3b8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(952 as u32), ctx.r[7].u32 ) };
	// 821B9944: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821B9948: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B994C: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B9950: 480E1601  bl 0x8229af50
	ctx.lr = 0x821B9954;
	sub_8229AF50(ctx, base);
	// 821B9954: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B995C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9960: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9968 size=160
    let mut pc: u32 = 0x821B9968;
    'dispatch: loop {
        match pc {
            0x821B9968 => {
    //   block [0x821B9968..0x821B9A08)
	// 821B9968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B996C: 48AEFAA1  bl 0x82ca940c
	ctx.lr = 0x821B9970;
	sub_82CA93D0(ctx, base);
	// 821B9970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9974: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B9978: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B997C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9980: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B9984: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821B9988: 48071259  bl 0x8222abe0
	ctx.lr = 0x821B998C;
	sub_8222ABE0(ctx, base);
	// 821B998C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B9990: 3D60F0F0  lis r11, -0xf10
	ctx.r[11].s64 = -252706816;
	// 821B9994: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B9998: 616AF0F0  ori r10, r11, 0xf0f0
	ctx.r[10].u64 = ctx.r[11].u64 | 61680;
	// 821B999C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821B99A0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B99A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B99A8: 48071239  bl 0x8222abe0
	ctx.lr = 0x821B99AC;
	sub_8222ABE0(ctx, base);
	// 821B99AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B99B0: 419A000C  beq cr6, 0x821b99bc
	if ctx.cr[6].eq {
	pc = 0x821B99BC; continue 'dispatch;
	}
	// 821B99B4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 821B99B8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B99BC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B99C0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 821B99C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B99C8: 48071219  bl 0x8222abe0
	ctx.lr = 0x821B99CC;
	sub_8222ABE0(ctx, base);
	// 821B99CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B99D0: 419A0028  beq cr6, 0x821b99f8
	if ctx.cr[6].eq {
	pc = 0x821B99F8; continue 'dispatch;
	}
	// 821B99D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B99D8: 394B113C  addi r10, r11, 0x113c
	ctx.r[10].s64 = ctx.r[11].s64 + 4412;
	// 821B99DC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B99E0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B99E4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B99E8: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B99EC: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B99F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B99F4: 48AEFA68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821B99F8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B99FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B9A00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B9A04: 48AEFA58  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9A08 size=720
    let mut pc: u32 = 0x821B9A08;
    'dispatch: loop {
        match pc {
            0x821B9A08 => {
    //   block [0x821B9A08..0x821B9CD8)
	// 821B9A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9A0C: 48AEF9E9  bl 0x82ca93f4
	ctx.lr = 0x821B9A10;
	sub_82CA93D0(ctx, base);
	// 821B9A10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9A14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B9A18: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821B9A1C: 817F2A90  lwz r11, 0x2a90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10896 as u32) ) } as u64;
	// 821B9A20: 895F2ABC  lbz r10, 0x2abc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821B9A24: 554A06B5  rlwinm. r10, r10, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B9A28: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9A2C: 418201C0  beq 0x821b9bec
	if ctx.cr[0].eq {
	pc = 0x821B9BEC; continue 'dispatch;
	}
	// 821B9A30: 3B7F33C0  addi r27, r31, 0x33c0
	ctx.r[27].s64 = ctx.r[31].s64 + 13248;
	// 821B9A34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B9A38: 480002A1  bl 0x821b9cd8
	ctx.lr = 0x821B9A3C;
	sub_821B9CD8(ctx, base);
	// 821B9A3C: 3B9F3424  addi r28, r31, 0x3424
	ctx.r[28].s64 = ctx.r[31].s64 + 13348;
	// 821B9A40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B9A44: 48000295  bl 0x821b9cd8
	ctx.lr = 0x821B9A48;
	sub_821B9CD8(ctx, base);
	// 821B9A48: 817F3384  lwz r11, 0x3384(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13188 as u32) ) } as u64;
	// 821B9A4C: 813F2C38  lwz r9, 0x2c38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(11320 as u32) ) } as u64;
	// 821B9A50: 3D400100  lis r10, 0x100
	ctx.r[10].s64 = 16777216;
	// 821B9A54: 556B008F  rlwinm. r11, r11, 0, 2, 7
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9A58: 7D5A4830  slw r26, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[26].u64 = 0;
	} else {
		ctx.r[26].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 821B9A5C: 41820008  beq 0x821b9a64
	if ctx.cr[0].eq {
	pc = 0x821B9A64; continue 'dispatch;
	}
	// 821B9A60: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 821B9A64: 3F208000  lis r25, -0x8000
	ctx.r[25].s64 = -2147483648;
	// 821B9A68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9A6C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B9A70: 480ABB81  bl 0x822655f0
	ctx.lr = 0x821B9A74;
	sub_822655F0(ctx, base);
	// 821B9A74: 817F3438  lwz r11, 0x3438(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13368 as u32) ) } as u64;
	// 821B9A78: 3BDF3438  addi r30, r31, 0x3438
	ctx.r[30].s64 = ctx.r[31].s64 + 13368;
	// 821B9A7C: 3EE04000  lis r23, 0x4000
	ctx.r[23].s64 = 1073741824;
	// 821B9A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9A84: 409A000C  bne cr6, 0x821b9a90
	if !ctx.cr[6].eq {
	pc = 0x821B9A90; continue 'dispatch;
	}
	// 821B9A88: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 821B9A8C: 4800001C  b 0x821b9aa8
	pc = 0x821B9AA8; continue 'dispatch;
	// 821B9A90: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B9A94: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821B9A98: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821B9A9C: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B9AA0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9AA4: 7FB75850  subf r29, r23, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[23].s64;
	// 821B9AA8: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B9AAC: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B9AB0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9AB4: 40990010  ble cr6, 0x821b9ac4
	if !ctx.cr[6].gt {
	pc = 0x821B9AC4; continue 'dispatch;
	}
	// 821B9AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9ABC: 4802F405  bl 0x821e8ec0
	ctx.lr = 0x821B9AC0;
	sub_821E8EC0(ctx, base);
	// 821B9AC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B9AC4: 3D6082BA  lis r11, -0x7d46
	ctx.r[11].s64 = -2101739520;
	// 821B9AC8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821B9ACC: 38CB5EA0  addi r6, r11, 0x5ea0
	ctx.r[6].s64 = ctx.r[11].s64 + 24224;
	// 821B9AD0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821B9AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9AD8: 4803C579  bl 0x821f6050
	ctx.lr = 0x821B9ADC;
	sub_821F6050(ctx, base);
	// 821B9ADC: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821B9AE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B9AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9AE8: 480ABB09  bl 0x822655f0
	ctx.lr = 0x821B9AEC;
	sub_822655F0(ctx, base);
	// 821B9AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9AF0: 4802F3D1  bl 0x821e8ec0
	ctx.lr = 0x821B9AF4;
	sub_821E8EC0(ctx, base);
	// 821B9AF4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9AF8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B9AFC: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 821B9B00: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B9B04: 4099000C  ble cr6, 0x821b9b10
	if !ctx.cr[6].gt {
	pc = 0x821B9B10; continue 'dispatch;
	}
	// 821B9B08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B9B0C: 48017AA5  bl 0x821d15b0
	ctx.lr = 0x821B9B10;
	sub_821D15B0(ctx, base);
	// 821B9B10: 3D608800  lis r11, -0x7800
	ctx.r[11].s64 = -2013265920;
	// 821B9B14: 93230004  stw r25, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 821B9B18: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 821B9B1C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B9B20: 915F3440  stw r10, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[10].u32 ) };
	// 821B9B24: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B9B28: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9B2C: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 821B9B30: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9B34: 4099000C  ble cr6, 0x821b9b40
	if !ctx.cr[6].gt {
	pc = 0x821B9B40; continue 'dispatch;
	}
	// 821B9B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B9B3C: 48017A75  bl 0x821d15b0
	ctx.lr = 0x821B9B40;
	sub_821D15B0(ctx, base);
	// 821B9B40: 3D608900  lis r11, -0x7700
	ctx.r[11].s64 = -1996488704;
	// 821B9B44: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B9B48: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9B50: 409A000C  bne cr6, 0x821b9b5c
	if !ctx.cr[6].eq {
	pc = 0x821B9B5C; continue 'dispatch;
	}
	// 821B9B54: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821B9B58: 4800001C  b 0x821b9b74
	pc = 0x821B9B74; continue 'dispatch;
	// 821B9B5C: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B9B60: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821B9B64: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821B9B68: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B9B6C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9B70: 7D775850  subf r11, r23, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[23].s64;
	// 821B9B74: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821B9B78: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9B7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9B80: 409A000C  bne cr6, 0x821b9b8c
	if !ctx.cr[6].eq {
	pc = 0x821B9B8C; continue 'dispatch;
	}
	// 821B9B84: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821B9B88: 4800001C  b 0x821b9ba4
	pc = 0x821B9BA4; continue 'dispatch;
	// 821B9B8C: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B9B90: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821B9B94: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821B9B98: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B9B9C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9BA0: 7D775850  subf r11, r23, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[23].s64;
	// 821B9BA4: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 821B9BA8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B9BAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B9BB0: 915F3440  stw r10, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[10].u32 ) };
	// 821B9BB4: 93FB0010  stw r31, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 821B9BB8: 931B0004  stw r24, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 821B9BBC: 931B0008  stw r24, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 821B9BC0: 931B000C  stw r24, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 821B9BC4: 931B0000  stw r24, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 821B9BC8: 480179E9  bl 0x821d15b0
	ctx.lr = 0x821B9BCC;
	sub_821D15B0(ctx, base);
	// 821B9BCC: 93FC0010  stw r31, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 821B9BD0: 931C0004  stw r24, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 821B9BD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B9BD8: 931C0008  stw r24, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 821B9BDC: 931C000C  stw r24, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 821B9BE0: 931C0000  stw r24, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 821B9BE4: 480179CD  bl 0x821d15b0
	ctx.lr = 0x821B9BE8;
	sub_821D15B0(ctx, base);
	// 821B9BE8: 4800000C  b 0x821b9bf4
	pc = 0x821B9BF4; continue 'dispatch;
	// 821B9BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9BF0: 4802F2D1  bl 0x821e8ec0
	ctx.lr = 0x821B9BF4;
	sub_821E8EC0(ctx, base);
	// 821B9BF4: 817F3440  lwz r11, 0x3440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13376 as u32) ) } as u64;
	// 821B9BF8: 387F3438  addi r3, r31, 0x3438
	ctx.r[3].s64 = ctx.r[31].s64 + 13368;
	// 821B9BFC: 815F3444  lwz r10, 0x3444(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13380 as u32) ) } as u64;
	// 821B9C00: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821B9C04: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B9C08: 4099000C  ble cr6, 0x821b9c14
	if !ctx.cr[6].gt {
	pc = 0x821B9C14; continue 'dispatch;
	}
	// 821B9C0C: 480179A5  bl 0x821d15b0
	ctx.lr = 0x821B9C10;
	sub_821D15B0(ctx, base);
	// 821B9C10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B9C14: 3D408400  lis r10, -0x7c00
	ctx.r[10].s64 = -2080374784;
	// 821B9C18: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821B9C1C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B9C20: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821B9C24: 913F3440  stw r9, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[9].u32 ) };
	// 821B9C28: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821B9C2C: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 821B9C30: 895F2ABC  lbz r10, 0x2abc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821B9C34: 798CC7E6  rldicr r12, r12, 0x38, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(56) & 0xFFFFFFFFFFFFFFFF;
	// 821B9C38: 997F2ABD  stb r11, 0x2abd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10941 as u32), ctx.r[11].u8 ) };
	// 821B9C3C: 714A00BF  andi. r10, r10, 0xbf
	ctx.r[10].u64 = ctx.r[10].u64 & 191;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B9C40: 995F2ABC  stb r10, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[10].u8 ) };
	// 821B9C44: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B9C48: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 821B9C4C: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9C50: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821B9C54: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9C58: 897F2ABF  lbz r11, 0x2abf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10943 as u32) ) } as u64;
	// 821B9C5C: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9C60: 41820054  beq 0x821b9cb4
	if ctx.cr[0].eq {
	pc = 0x821B9CB4; continue 'dispatch;
	}
	// 821B9C64: 389F3184  addi r4, r31, 0x3184
	ctx.r[4].s64 = ctx.r[31].s64 + 12676;
	// 821B9C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9C6C: 4803FF9D  bl 0x821f9c08
	ctx.lr = 0x821B9C70;
	sub_821F9C08(ctx, base);
	// 821B9C70: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B9C74: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821B9C78: 616B0100  ori r11, r11, 0x100
	ctx.r[11].u64 = ctx.r[11].u64 | 256;
	// 821B9C7C: 798C2FE6  rldicr r12, r12, 0x25, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(37) & 0xFFFFFFFFFFFFFFFF;
	// 821B9C80: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9C84: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821B9C88: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821B9C8C: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9C90: 798CCFE6  rldicr r12, r12, 0x39, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(57) & 0xFFFFFFFFFFFFFFFF;
	// 821B9C94: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821B9C98: 3D80FFEF  lis r12, -0x11
	ctx.r[12].s64 = -1114112;
	// 821B9C9C: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9CA0: 618CFFFE  ori r12, r12, 0xfffe
	ctx.r[12].u64 = ctx.r[12].u64 | 65534;
	// 821B9CA4: 798C2FE6  rldicr r12, r12, 0x25, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(37) & 0xFFFFFFFFFFFFFFFF;
	// 821B9CA8: E97F0028  ld r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 821B9CAC: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 821B9CB0: F97F0028  std r11, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	// 821B9CB4: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821B9CB8: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9CBC: 41820010  beq 0x821b9ccc
	if ctx.cr[0].eq {
	pc = 0x821B9CCC; continue 'dispatch;
	}
	// 821B9CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9CC4: 4BFD9345  bl 0x82193008
	ctx.lr = 0x821B9CC8;
	sub_82193008(ctx, base);
	// 821B9CC8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821B9CCC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B9CD0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B9CD4: 48AEF770  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9CD8 size=68
    let mut pc: u32 = 0x821B9CD8;
    'dispatch: loop {
        match pc {
            0x821B9CD8 => {
    //   block [0x821B9CD8..0x821B9D1C)
	// 821B9CD8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9CDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B9CE0: 419A0030  beq cr6, 0x821b9d10
	if ctx.cr[6].eq {
	pc = 0x821B9D10; continue 'dispatch;
	}
	// 821B9CE4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9CE8: 3D00C000  lis r8, -0x4000
	ctx.r[8].s64 = -1073741824;
	// 821B9CEC: 554B653E  srwi r11, r10, 0x14
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B9CF0: 554A00FE  clrlwi r10, r10, 3
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 821B9CF4: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821B9CF8: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B9CFC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9D00: 3D6BC000  addis r11, r11, -0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + -1073741824;
	// 821B9D04: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B9D08: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9D0C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B9D10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B9D14: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821B9D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9D20 size=72
    let mut pc: u32 = 0x821B9D20;
    'dispatch: loop {
        match pc {
            0x821B9D20 => {
    //   block [0x821B9D20..0x821B9D68)
	// 821B9D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9D28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9D2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9D30: 81640074  lwz r11, 0x74(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B9D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B9D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9D3C: 419A0010  beq cr6, 0x821b9d4c
	if ctx.cr[6].eq {
	pc = 0x821B9D4C; continue 'dispatch;
	}
	// 821B9D40: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821B9D44: 4869247D  bl 0x8284c1c0
	ctx.lr = 0x821B9D48;
	sub_8284C1C0(ctx, base);
	// 821B9D48: 48000008  b 0x821b9d50
	pc = 0x821B9D50; continue 'dispatch;
	// 821B9D4C: 480388E5  bl 0x821f2630
	ctx.lr = 0x821B9D50;
	sub_821F2630(ctx, base);
	// 821B9D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9D54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9D68 size=132
    let mut pc: u32 = 0x821B9D68;
    'dispatch: loop {
        match pc {
            0x821B9D68 => {
    //   block [0x821B9D68..0x821B9DEC)
	// 821B9D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9D70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9D74: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B9D78: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B9D7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9D80: 41990008  bgt cr6, 0x821b9d88
	if ctx.cr[6].gt {
	pc = 0x821B9D88; continue 'dispatch;
	}
	// 821B9D84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B9D88: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B9D8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9D90: 419A0048  beq cr6, 0x821b9dd8
	if ctx.cr[6].eq {
	pc = 0x821B9DD8; continue 'dispatch;
	}
	// 821B9D94: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B9D98: 40980040  bge cr6, 0x821b9dd8
	if !ctx.cr[6].lt {
	pc = 0x821B9DD8; continue 'dispatch;
	}
	// 821B9D9C: 81630334  lwz r11, 0x334(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(820 as u32) ) } as u64;
	// 821B9DA0: 548A2036  slwi r10, r4, 4
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B9DA4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9DA8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9DB0: 419A0028  beq cr6, 0x821b9dd8
	if ctx.cr[6].eq {
	pc = 0x821B9DD8; continue 'dispatch;
	}
	// 821B9DB4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9DB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9DBC: 419A0018  beq cr6, 0x821b9dd4
	if ctx.cr[6].eq {
	pc = 0x821B9DD4; continue 'dispatch;
	}
	// 821B9DC0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821B9DC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9DC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9DCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9DD0: 4E800020  blr
	return;
	// 821B9DD4: 4BFDA065  bl 0x82193e38
	ctx.lr = 0x821B9DD8;
	sub_82193E38(ctx, base);
	// 821B9DD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B9DDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9DF0 size=768
    let mut pc: u32 = 0x821B9DF0;
    'dispatch: loop {
        match pc {
            0x821B9DF0 => {
    //   block [0x821B9DF0..0x821BA0F0)
	// 821B9DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9DF4: 48AEF609  bl 0x82ca93fc
	ctx.lr = 0x821B9DF8;
	sub_82CA93D0(ctx, base);
	// 821B9DF8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 821B9DFC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821B9E00: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA0F0 size=252
    let mut pc: u32 = 0x821BA0F0;
    'dispatch: loop {
        match pc {
            0x821BA0F0 => {
    //   block [0x821BA0F0..0x821BA1EC)
	// 821BA0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA0F4: 48AEF315  bl 0x82ca9408
	ctx.lr = 0x821BA0F8;
	sub_82CA93D0(ctx, base);
	// 821BA0F8: 9421F450  stwu r1, -0xbb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2992 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA0FC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821BA100: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BA104: 390BF7A8  addi r8, r11, -0x858
	ctx.r[8].s64 = ctx.r[11].s64 + -2136;
	// 821BA108: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821BA10C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA110: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA114: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA118: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BA11C: 81490050  lwz r10, 0x50(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BA120: 7CE61670  srawi r6, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 821BA124: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BA128: 409800BC  bge cr6, 0x821ba1e4
	if !ctx.cr[6].lt {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA12C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA130: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BA134: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BA138: 419A00AC  beq cr6, 0x821ba1e4
	if ctx.cr[6].eq {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA13C: 553F003E  slwi r31, r9, 0
	ctx.r[31].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821BA140: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA144: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821BA148: 409A009C  bne cr6, 0x821ba1e4
	if !ctx.cr[6].eq {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA14C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BA150: 419A0094  beq cr6, 0x821ba1e4
	if ctx.cr[6].eq {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA154: 897F0048  lbz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BA158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA15C: 419A0088  beq cr6, 0x821ba1e4
	if ctx.cr[6].eq {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA160: 83DF0014  lwz r30, 0x14(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BA164: 807E0E5C  lwz r3, 0xe5c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3676 as u32) ) } as u64;
	// 821BA168: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821BA16C: 419A0008  beq cr6, 0x821ba174
	if ctx.cr[6].eq {
	pc = 0x821BA174; continue 'dispatch;
	}
	// 821BA170: 4801AFD9  bl 0x821d5148
	ctx.lr = 0x821BA174;
	sub_821D5148(ctx, base);
	// 821BA174: 807E0E64  lwz r3, 0xe64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3684 as u32) ) } as u64;
	// 821BA178: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821BA17C: 419A000C  beq cr6, 0x821ba188
	if ctx.cr[6].eq {
	pc = 0x821BA188; continue 'dispatch;
	}
	// 821BA180: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BA184: 48086B65  bl 0x82240ce8
	ctx.lr = 0x821BA188;
	sub_82240CE8(ctx, base);
	// 821BA188: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA190: C82B02E8  lfd f1, 0x2e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(744 as u32) ) };
	// 821BA194: 480D134D  bl 0x8228b4e0
	ctx.lr = 0x821BA198;
	sub_8228B4E0(ctx, base);
	// 821BA198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA19C: 48017B05  bl 0x821d1ca0
	ctx.lr = 0x821BA1A0;
	sub_821D1CA0(ctx, base);
	// 821BA1A0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA1A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BA1A8: 83CA0048  lwz r30, 0x48(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BA1AC: 480D1BAD  bl 0x8228bd58
	ctx.lr = 0x821BA1B0;
	sub_8228BD58(ctx, base);
	// 821BA1B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821BA1B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821BA1B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BA1BC: 38610410  addi r3, r1, 0x410
	ctx.r[3].s64 = ctx.r[1].s64 + 1040;
	// 821BA1C0: 480B3351  bl 0x8226d510
	ctx.lr = 0x821BA1C4;
	sub_8226D510(ctx, base);
	// 821BA1C4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA1C8: 38810410  addi r4, r1, 0x410
	ctx.r[4].s64 = ctx.r[1].s64 + 1040;
	// 821BA1CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BA1D0: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA1D4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821BA1D8: 4E800421  bctrl
	ctx.lr = 0x821BA1DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BA1DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BA1E0: 480BB129  bl 0x82275308
	ctx.lr = 0x821BA1E4;
	sub_82275308(ctx, base);
	// 821BA1E4: 38210BB0  addi r1, r1, 0xbb0
	ctx.r[1].s64 = ctx.r[1].s64 + 2992;
	// 821BA1E8: 48AEF270  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA1F0 size=328
    let mut pc: u32 = 0x821BA1F0;
    'dispatch: loop {
        match pc {
            0x821BA1F0 => {
    //   block [0x821BA1F0..0x821BA338)
	// 821BA1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA1FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA200: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BA204: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821BA208: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821BA20C: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 821BA210: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 821BA214: 88AB6E61  lbz r5, 0x6e61(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28257 as u32) ) } as u64;
	// 821BA218: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821BA21C: 91486E5C  stw r10, 0x6e5c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28252 as u32), ctx.r[10].u32 ) };
	// 821BA220: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821BA224: 7CA30034  cntlzw r3, r5
	ctx.r[3].u64 = if ctx.r[5].u32 == 0 { 32 } else { ctx.r[5].u32.leading_zeros() as u64 };
	// 821BA228: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821BA22C: 99271624  stb r9, 0x1624(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(5668 as u32), ctx.r[9].u8 ) };
	// 821BA230: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821BA234: 546ADFFE  rlwinm r10, r3, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 821BA238: 99061625  stb r8, 0x1625(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(5669 as u32), ctx.r[8].u8 ) };
	// 821BA23C: 3BEBFB30  addi r31, r11, -0x4d0
	ctx.r[31].s64 = ctx.r[11].s64 + -1232;
	// 821BA240: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BA244: 419A00BC  beq cr6, 0x821ba300
	if ctx.cr[6].eq {
	pc = 0x821BA300; continue 'dispatch;
	}
	// 821BA248: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821BA24C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821BA250: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821BA254: 38E96E50  addi r7, r9, 0x6e50
	ctx.r[7].s64 = ctx.r[9].s64 + 28240;
	// 821BA258: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821BA25C: 816A8570  lwz r11, -0x7a90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31376 as u32) ) } as u64;
	// 821BA260: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821BA264: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BA268: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821BA26C: 916A8570  stw r11, -0x7a90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-31376 as u32), ctx.r[11].u32 ) };
	// 821BA270: 7D43382E  lwzx r10, r3, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821BA274: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BA278: 91486E58  stw r10, 0x6e58(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28248 as u32), ctx.r[10].u32 ) };
	// 821BA27C: 69690001  xori r9, r11, 1
	ctx.r[9].u64 = ctx.r[11].u64 ^ 1;
	// 821BA280: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BA284: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 821BA288: 7CE8502E  lwzx r7, r8, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821BA28C: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821BA290: 908A0014  stw r4, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 821BA294: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA298: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BA29C: 419A0060  beq cr6, 0x821ba2fc
	if ctx.cr[6].eq {
	pc = 0x821BA2FC; continue 'dispatch;
	}
	// 821BA2A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA2A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BA2A8: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821BA2AC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BA2B0: 4098004C  bge cr6, 0x821ba2fc
	if !ctx.cr[6].lt {
	pc = 0x821BA2FC; continue 'dispatch;
	}
	// 821BA2B4: 7D06482E  lwzx r8, r6, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821BA2B8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BA2BC: 806A000C  lwz r3, 0xc(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BA2C0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA2C4: 812700F8  lwz r9, 0xf8(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(248 as u32) ) } as u64;
	// 821BA2C8: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821BA2CC: 7F091840  cmplw cr6, r9, r3
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821BA2D0: 4198000C  blt cr6, 0x821ba2dc
	if ctx.cr[6].lt {
	pc = 0x821BA2DC; continue 'dispatch;
	}
	// 821BA2D4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821BA2D8: 48000008  b 0x821ba2e0
	pc = 0x821BA2E0; continue 'dispatch;
	// 821BA2DC: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 821BA2E0: 9168001C  stw r11, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821BA2E4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821BA2E8: 409A0008  bne cr6, 0x821ba2f0
	if !ctx.cr[6].eq {
	pc = 0x821BA2F0; continue 'dispatch;
	}
	// 821BA2EC: 908700B0  stw r4, 0xb0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(176 as u32), ctx.r[4].u32 ) };
	// 821BA2F0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821BA2F4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 821BA2F8: 4BFFFF9C  b 0x821ba294
	pc = 0x821BA294; continue 'dispatch;
	// 821BA2FC: 480EFDA5  bl 0x822aa0a0
	ctx.lr = 0x821BA300;
	sub_822AA0A0(ctx, base);
	// 821BA300: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA304: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA308: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BA30C: 40990010  ble cr6, 0x821ba31c
	if !ctx.cr[6].gt {
	pc = 0x821BA31C; continue 'dispatch;
	}
	// 821BA310: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BA314: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BA318: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BA31C: 419A0008  beq cr6, 0x821ba324
	if ctx.cr[6].eq {
	pc = 0x821BA324; continue 'dispatch;
	}
	// 821BA320: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821BA324: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BA328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA32C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA330: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BA334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BA338 size=288
    let mut pc: u32 = 0x821BA338;
    'dispatch: loop {
        match pc {
            0x821BA338 => {
    //   block [0x821BA338..0x821BA458)
	// 821BA338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA340: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA344: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA348: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821BA34C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821BA350: 392B4D60  addi r9, r11, 0x4d60
	ctx.r[9].s64 = ctx.r[11].s64 + 19808;
	// 821BA354: C02A9484  lfs f1, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BA358: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA35C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BA360: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821BA364: 5507003A  rlwinm r7, r8, 0, 0, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821BA368: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821BA36C: 419A0034  beq cr6, 0x821ba3a0
	if ctx.cr[6].eq {
	pc = 0x821BA3A0; continue 'dispatch;
	}
	// 821BA370: 83EBFFFC  lwz r31, -4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821BA374: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 821BA378: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821BA37C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BA380: 419A0020  beq cr6, 0x821ba3a0
	if ctx.cr[6].eq {
	pc = 0x821BA3A0; continue 'dispatch;
	}
	// 821BA384: 39600130  li r11, 0x130
	ctx.r[11].s64 = 304;
	// 821BA388: 3860007E  li r3, 0x7e
	ctx.r[3].s64 = 126;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA458 size=64
    let mut pc: u32 = 0x821BA458;
    'dispatch: loop {
        match pc {
            0x821BA458 => {
    //   block [0x821BA458..0x821BA498)
	// 821BA458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA464: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BA46C: 989F002C  stb r4, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[4].u8 ) };
	// 821BA470: 485A64B9  bl 0x82760928
	ctx.lr = 0x821BA474;
	sub_82760928(ctx, base);
	// 821BA474: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA478: 419A000C  beq cr6, 0x821ba484
	if ctx.cr[6].eq {
	pc = 0x821BA484; continue 'dispatch;
	}
	// 821BA47C: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BA480: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 821BA484: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BA488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA48C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BA494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BA498 size=340
    let mut pc: u32 = 0x821BA498;
    'dispatch: loop {
        match pc {
            0x821BA498 => {
    //   block [0x821BA498..0x821BA5EC)
	// 821BA498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA4A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA4A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA4A8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821BA4AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BA4B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BA4B4: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821BA4B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821BA4BC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821BA4C0: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BA4C4: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 821BA4C8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821BA4CC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BA4D0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 821BA4D4: 4801672D  bl 0x821d0c00
	ctx.lr = 0x821BA4D8;
	sub_821D0C00(ctx, base);
	// 821BA4D8: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821BA4DC: 3BFF0048  addi r31, r31, 0x48
	ctx.r[31].s64 = ctx.r[31].s64 + 72;
	// 821BA4E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BA4E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA4E8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821BA4EC: 480C5D55  bl 0x82280240
	ctx.lr = 0x821BA4F0;
	sub_82280240(ctx, base);
	// 821BA4F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821BA4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA4F8: 480089A1  bl 0x821c2e98
	ctx.lr = 0x821BA4FC;
	sub_821C2E98(ctx, base);
	// 821BA4FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821BA500: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 821BA504: 3CC02000  lis r6, 0x2000
	ctx.r[6].s64 = 536870912;
	// 821BA508: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821BA50C: 80A50004  lwz r5, 4(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA510: 80670364  lwz r3, 0x364(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(868 as u32) ) } as u64;
	// 821BA514: 4BFFC9CD  bl 0x821b6ee0
	ctx.lr = 0x821BA518;
	sub_821B6EE0(ctx, base);
	// 821BA518: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821BA51C: 3C808331  lis r4, -0x7ccf
	ctx.r[4].s64 = -2093940736;
	// 821BA520: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821BA524: 38646FCC  addi r3, r4, 0x6fcc
	ctx.r[3].s64 = ctx.r[4].s64 + 28620;
	// 821BA528: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821BA52C: 392A2390  addi r9, r10, 0x2390
	ctx.r[9].s64 = ctx.r[10].s64 + 9104;
	// 821BA530: 890B0915  lbz r8, 0x915(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2325 as u32) ) } as u64;
	// 821BA534: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA538: 1D082008  mulli r8, r8, 0x2008
	ctx.r[8].s64 = ctx.r[8].s64 * 8200;
	// 821BA53C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821BA540: 814B0904  lwz r10, 0x904(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2308 as u32) ) } as u64;
	// 821BA544: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821BA548: 3949DFF8  addi r10, r9, -0x2008
	ctx.r[10].s64 = ctx.r[9].s64 + -8200;
	// 821BA54C: 419A008C  beq cr6, 0x821ba5d8
	if ctx.cr[6].eq {
	pc = 0x821BA5D8; continue 'dispatch;
	}
	// 821BA550: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821BA554: 810B0908  lwz r8, 0x908(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2312 as u32) ) } as u64;
	// 821BA558: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821BA55C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821BA560: 409A003C  bne cr6, 0x821ba59c
	if !ctx.cr[6].eq {
	pc = 0x821BA59C; continue 'dispatch;
	}
	// 821BA564: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BA568: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821BA56C: 38AB0900  addi r5, r11, 0x900
	ctx.r[5].s64 = ctx.r[11].s64 + 2304;
	// 821BA570: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821BA574: 912B0908  stw r9, 0x908(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2312 as u32), ctx.r[9].u32 ) };
	// 821BA578: 7CA4512E  stwx r5, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821BA57C: 812B0904  lwz r9, 0x904(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2308 as u32) ) } as u64;
	// 821BA580: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BA584: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BA588: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821BA58C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821BA590: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BA594: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821BA598: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	// 821BA59C: 894B0914  lbz r10, 0x914(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2324 as u32) ) } as u64;
	// 821BA5A0: 90EB0904  stw r7, 0x904(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2308 as u32), ctx.r[7].u32 ) };
	// 821BA5A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BA5A8: 409A0030  bne cr6, 0x821ba5d8
	if !ctx.cr[6].eq {
	pc = 0x821BA5D8; continue 'dispatch;
	}
	// 821BA5AC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821BA5B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BA5B4: 390B0900  addi r8, r11, 0x900
	ctx.r[8].s64 = ctx.r[11].s64 + 2304;
	// 821BA5B8: 994B0914  stb r10, 0x914(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2324 as u32), ctx.r[10].u8 ) };
	// 821BA5BC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821BA5C0: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821BA5C4: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 821BA5C8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821BA5CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BA5D0: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821BA5D4: 7D05312E  stwx r8, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	// 821BA5D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BA5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA5E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BA5E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA5F0 size=784
    let mut pc: u32 = 0x821BA5F0;
    'dispatch: loop {
        match pc {
            0x821BA5F0 => {
    //   block [0x821BA5F0..0x821BA900)
	// 821BA5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA5F4: 48AEEE05  bl 0x82ca93f8
	ctx.lr = 0x821BA5F8;
	sub_82CA93D0(ctx, base);
	// 821BA5F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA5FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BA600: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 821BA604: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821BA608: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 821BA60C: FB2100C0  std r25, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u64 ) };
	// 821BA610: 3B400018  li r26, 0x18
	ctx.r[26].s64 = 24;
	// 821BA614: FB0100C8  std r24, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[24].u64 ) };
	// 821BA618: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 821BA61C: 814100CC  lwz r10, 0xcc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 821BA620: 7D235050  subf r9, r3, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 821BA624: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA628: 7F69D3D6  divw r27, r9, r26
	ctx.r[27].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 821BA62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA630: 409A000C  bne cr6, 0x821ba63c
	if !ctx.cr[6].eq {
	pc = 0x821BA63C; continue 'dispatch;
	}
	// 821BA634: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BA638: 48000010  b 0x821ba648
	pc = 0x821BA648; continue 'dispatch;
	// 821BA63C: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BA640: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BA644: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 821BA648: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821BA64C: 419A02AC  beq cr6, 0x821ba8f8
	if ctx.cr[6].eq {
	pc = 0x821BA8F8; continue 'dispatch;
	}
	// 821BA650: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA654: 3D400AAA  lis r10, 0xaaa
	ctx.r[10].s64 = 178913280;
	// 821BA658: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821BA65C: 614AAAAA  ori r10, r10, 0xaaaa
	ctx.r[10].u64 = ctx.r[10].u64 | 43690;
	// 821BA660: 7D68D3D6  divw r11, r8, r26
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[26].s32;
	// 821BA664: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BA668: 7F07D840  cmplw cr6, r7, r27
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BA66C: 40980010  bge cr6, 0x821ba67c
	if !ctx.cr[6].lt {
	pc = 0x821BA67C; continue 'dispatch;
	}
	// 821BA670: 4888CE59  bl 0x82a474c8
	ctx.lr = 0x821BA674;
	sub_82A474C8(ctx, base);
	// 821BA674: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BA678: 48AEEDD0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 821BA67C: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821BA680: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BA684: 4098013C  bge cr6, 0x821ba7c0
	if !ctx.cr[6].lt {
	pc = 0x821BA7C0; continue 'dispatch;
	}
	// 821BA688: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA68C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821BA690: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BA694: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BA698: 41980008  blt cr6, 0x821ba6a0
	if ctx.cr[6].lt {
	pc = 0x821BA6A0; continue 'dispatch;
	}
	// 821BA69C: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821BA6A0: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BA6A4: 40980008  bge cr6, 0x821ba6ac
	if !ctx.cr[6].lt {
	pc = 0x821BA6AC; continue 'dispatch;
	}
	// 821BA6A8: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 821BA6AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BA6B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BA6B4: 488C9A45  bl 0x82a840f8
	ctx.lr = 0x821BA6B8;
	sub_82A840F8(ctx, base);
	// 821BA6B8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA6BC: 83E100BC  lwz r31, 0xbc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821BA6C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BA6C4: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821BA6C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821BA6CC: 419A0040  beq cr6, 0x821ba70c
	if ctx.cr[6].eq {
	pc = 0x821BA70C; continue 'dispatch;
	}
	// 821BA6D0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821BA6D4: 419A0028  beq cr6, 0x821ba6fc
	if ctx.cr[6].eq {
	pc = 0x821BA6FC; continue 'dispatch;
	}
	// 821BA6D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821BA6DC: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 821BA6E0: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 821BA6E4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821BA6E8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA6EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821BA6F0: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BA6F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BA6F8: 4200FFF0  bdnz 0x821ba6e8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA6E8; continue 'dispatch;
	}
	// 821BA6FC: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 821BA700: 38A50018  addi r5, r5, 0x18
	ctx.r[5].s64 = ctx.r[5].s64 + 24;
	// 821BA704: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821BA708: 409AFFC8  bne cr6, 0x821ba6d0
	if !ctx.cr[6].eq {
	pc = 0x821BA6D0; continue 'dispatch;
	}
	// 821BA70C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821BA710: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821BA714: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821BA718: 488CA281  bl 0x82a84998
	ctx.lr = 0x821BA71C;
	sub_82A84998(ctx, base);
	// 821BA71C: 80DD0008  lwz r6, 8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA720: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821BA724: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BA728: 419A0044  beq cr6, 0x821ba76c
	if ctx.cr[6].eq {
	pc = 0x821BA76C; continue 'dispatch;
	}
	// 821BA72C: 7CEBF850  subf r7, r11, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 821BA730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA734: 419A0028  beq cr6, 0x821ba75c
	if ctx.cr[6].eq {
	pc = 0x821BA75C; continue 'dispatch;
	}
	// 821BA738: 7D475A14  add r10, r7, r11
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 821BA73C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821BA740: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 821BA744: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821BA748: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA74C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BA750: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BA754: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821BA758: 4200FFF0  bdnz 0x821ba748
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA748; continue 'dispatch;
	}
	// 821BA75C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 821BA760: 7D475A14  add r10, r7, r11
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 821BA764: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BA768: 409AFFC8  bne cr6, 0x821ba730
	if !ctx.cr[6].eq {
	pc = 0x821BA730; continue 'dispatch;
	}
	// 821BA76C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA770: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA778: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 821BA77C: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 821BA780: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821BA784: 419A0008  beq cr6, 0x821ba78c
	if ctx.cr[6].eq {
	pc = 0x821BA78C; continue 'dispatch;
	}
	// 821BA788: 480615B1  bl 0x8221bd38
	ctx.lr = 0x821BA78C;
	sub_8221BD38(ctx, base);
	// 821BA78C: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA790: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821BA794: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA798: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821BA79C: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821BA7A0: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA7A4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA7A8: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821BA7AC: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821BA7B0: 90FD0008  stw r7, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821BA7B4: 911D000C  stw r8, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 821BA7B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BA7BC: 48AEEC8C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 821BA7C0: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821BA7C4: 7D7C2850  subf r11, r28, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 821BA7C8: 7D4BD3D6  divw r10, r11, r26
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 821BA7CC: 576B083C  slwi r11, r27, 1
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA7D0: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BA7D4: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 821BA7D8: 409800B0  bge cr6, 0x821ba888
	if !ctx.cr[6].lt {
	pc = 0x821BA888; continue 'dispatch;
	}
	// 821BA7DC: 557E1838  slwi r30, r11, 3
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821BA7E0: 7F1C2840  cmplw cr6, r28, r5
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821BA7E4: 7D3EE214  add r9, r30, r28
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[28].u64;
	// 821BA7E8: 419A0044  beq cr6, 0x821ba82c
	if ctx.cr[6].eq {
	pc = 0x821BA82C; continue 'dispatch;
	}
	// 821BA7EC: 7CFE4850  subf r7, r30, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[30].s64;
	// 821BA7F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BA7F4: 419A0028  beq cr6, 0x821ba81c
	if ctx.cr[6].eq {
	pc = 0x821BA81C; continue 'dispatch;
	}
	// 821BA7F8: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 821BA7FC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821BA800: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 821BA804: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821BA808: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA80C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821BA810: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BA814: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BA818: 4200FFF0  bdnz 0x821ba808
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA808; continue 'dispatch;
	}
	// 821BA81C: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 821BA820: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 821BA824: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821BA828: 409AFFC8  bne cr6, 0x821ba7f0
	if !ctx.cr[6].eq {
	pc = 0x821BA7F0; continue 'dispatch;
	}
	// 821BA82C: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA830: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821BA834: FB210050  std r25, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u64 ) };
	// 821BA838: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821BA83C: 7D7C2850  subf r11, r28, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 821BA840: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 821BA844: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA848: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BA84C: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA850: 7D2B1A14  add r9, r11, r3
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821BA854: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821BA858: EBE10050  ld r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821BA85C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA860: 488CA139  bl 0x82a84998
	ctx.lr = 0x821BA864;
	sub_82A84998(ctx, base);
	// 821BA864: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA868: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BA86C: 7D1E5A14  add r8, r30, r11
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821BA870: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821BA874: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821BA878: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821BA87C: 488C9F8D  bl 0x82a84808
	ctx.lr = 0x821BA880;
	sub_82A84808(ctx, base);
	// 821BA880: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BA884: 48AEEBC4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 821BA888: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA88C: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 821BA890: 7C8A2850  subf r4, r10, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821BA894: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 821BA898: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821BA89C: 419A0040  beq cr6, 0x821ba8dc
	if ctx.cr[6].eq {
	pc = 0x821BA8DC; continue 'dispatch;
	}
	// 821BA8A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BA8A4: 419A0028  beq cr6, 0x821ba8cc
	if ctx.cr[6].eq {
	pc = 0x821BA8CC; continue 'dispatch;
	}
	// 821BA8A8: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821BA8AC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821BA8B0: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821BA8B4: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821BA8B8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA8BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821BA8C0: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821BA8C4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BA8C8: 4200FFF0  bdnz 0x821ba8b8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA8B8; continue 'dispatch;
	}
	// 821BA8CC: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 821BA8D0: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 821BA8D4: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821BA8D8: 409AFFC8  bne cr6, 0x821ba8a0
	if !ctx.cr[6].eq {
	pc = 0x821BA8A0; continue 'dispatch;
	}
	// 821BA8DC: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821BA8E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821BA8E4: 488C98F5  bl 0x82a841d8
	ctx.lr = 0x821BA8E8;
	sub_82A841D8(ctx, base);
	// 821BA8E8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821BA8EC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821BA8F0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821BA8F4: 488C9F15  bl 0x82a84808
	ctx.lr = 0x821BA8F8;
	sub_82A84808(ctx, base);
	// 821BA8F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BA8FC: 48AEEB4C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA900 size=212
    let mut pc: u32 = 0x821BA900;
    'dispatch: loop {
        match pc {
            0x821BA900 => {
    //   block [0x821BA900..0x821BA9D4)
	// 821BA900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA904: 48AEEB05  bl 0x82ca9408
	ctx.lr = 0x821BA908;
	sub_82CA93D0(ctx, base);
	// 821BA908: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BA9D8 size=640
    let mut pc: u32 = 0x821BA9D8;
    'dispatch: loop {
        match pc {
            0x821BA9D8 => {
    //   block [0x821BA9D8..0x821BAC58)
	// 821BA9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA9DC: 48AEEA25  bl 0x82ca9400
	ctx.lr = 0x821BA9E0;
	sub_82CA93D0(ctx, base);
	// 821BA9E0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821BA9E4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA9E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BA9EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BA9F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BA9F4: 3B6B9490  addi r27, r11, -0x6b70
	ctx.r[27].s64 = ctx.r[11].s64 + -27504;
	// 821BA9F8: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 821BA9FC: 815D0058  lwz r10, 0x58(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BAA00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BAA04: C3FBFFF4  lfs f31, -0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821BAA08: 40990090  ble cr6, 0x821baa98
	if !ctx.cr[6].gt {
	pc = 0x821BAA98; continue 'dispatch;
	}
	// 821BAA0C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 821BAA10: 48064849  bl 0x8221f258
	ctx.lr = 0x821BAA14;
	sub_8221F258(ctx, base);
	// 821BAA14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BAA18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821BAA1C: 419A0178  beq cr6, 0x821bab94
	if ctx.cr[6].eq {
	pc = 0x821BAB94; continue 'dispatch;
	}
	// 821BAA20: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821BAA24: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821BAA28: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821BAA2C: 390B9260  addi r8, r11, -0x6da0
	ctx.r[8].s64 = ctx.r[11].s64 + -28064;
	// 821BAA30: 38C77088  addi r6, r7, 0x7088
	ctx.r[6].s64 = ctx.r[7].s64 + 28808;
	// 821BAA34: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BAA38: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821BAA3C: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821BAA40: 80BD0058  lwz r5, 0x58(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BAA44: 90A30010  stw r5, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 821BAA48: 93C30014  stw r30, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 821BAA4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BAA50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BAA54: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BAA58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BAA5C: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BAA60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BAA64: 4082FFE8  bne 0x821baa4c
	if !ctx.cr[0].eq {
	pc = 0x821BAA4C; continue 'dispatch;
	}
	// 821BAA68: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821BAA6C: 93C30018  stw r30, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 821BAA70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BAA74: 93C3001C  stw r30, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821BAA78: 39442BF4  addi r10, r4, 0x2bf4
	ctx.r[10].s64 = ctx.r[4].s64 + 11252;
	// 821BAA7C: 93430020  stw r26, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 821BAA80: D3E30028  stfs f31, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821BAA84: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 821BAA88: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821BAA8C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821BAA90: 93C3002C  stw r30, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 821BAA94: 48000104  b 0x821bab98
	pc = 0x821BAB98; continue 'dispatch;
	// 821BAA98: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 821BAA9C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821BAAA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BAAA4: 419A0020  beq cr6, 0x821baac4
	if ctx.cr[6].eq {
	pc = 0x821BAAC4; continue 'dispatch;
	}
	// 821BAAA8: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 821BAAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BAAB0: 419A0014  beq cr6, 0x821baac4
	if ctx.cr[6].eq {
	pc = 0x821BAAC4; continue 'dispatch;
	}
	// 821BAAB4: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BAAB8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821BAABC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BAAC0: 409A0008  bne cr6, 0x821baac8
	if !ctx.cr[6].eq {
	pc = 0x821BAAC8; continue 'dispatch;
	}
	// 821BAAC4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821BAAC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BAACC: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 821BAAD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BAAD4: 419A0090  beq cr6, 0x821bab64
	if ctx.cr[6].eq {
	pc = 0x821BAB64; continue 'dispatch;
	}
	// 821BAAD8: 48064781  bl 0x8221f258
	ctx.lr = 0x821BAADC;
	sub_8221F258(ctx, base);
	// 821BAADC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BAAE0: 419A00B4  beq cr6, 0x821bab94
	if ctx.cr[6].eq {
	pc = 0x821BAB94; continue 'dispatch;
	}
	// 821BAAE4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821BAAE8: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821BAAEC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821BAAF0: 38EB9260  addi r7, r11, -0x6da0
	ctx.r[7].s64 = ctx.r[11].s64 + -28064;
	// 821BAAF4: 38C97088  addi r6, r9, 0x7088
	ctx.r[6].s64 = ctx.r[9].s64 + 28808;
	// 821BAAF8: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821BAAFC: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821BAB00: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821BAB04: 93C30010  stw r30, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 821BAB08: 93C30014  stw r30, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 821BAB0C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 821BAB10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BAB14: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BAB18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BAB1C: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BAB20: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BAB24: 4082FFE8  bne 0x821bab0c
	if !ctx.cr[0].eq {
	pc = 0x821BAB0C; continue 'dispatch;
	}
	// 821BAB28: 809D005C  lwz r4, 0x5c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 821BAB2C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 821BAB30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BAB34: 39452BF4  addi r10, r5, 0x2bf4
	ctx.r[10].s64 = ctx.r[5].s64 + 11252;
	// 821BAB38: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821BAB3C: 90830018  stw r4, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 821BAB40: 813D0060  lwz r9, 0x60(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 821BAB44: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 821BAB48: 811D0064  lwz r8, 0x64(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BAB4C: D3E30028  stfs f31, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821BAB50: 91030020  stw r8, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 821BAB54: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 821BAB58: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821BAB5C: 93C3002C  stw r30, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 821BAB60: 48000038  b 0x821bab98
	pc = 0x821BAB98; continue 'dispatch;
	// 821BAB64: 480646F5  bl 0x8221f258
	ctx.lr = 0x821BAB68;
	sub_8221F258(ctx, base);
	// 821BAB68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821BAB6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821BAB70: 419A0024  beq cr6, 0x821bab94
	if ctx.cr[6].eq {
	pc = 0x821BAB94; continue 'dispatch;
	}
	// 821BAB74: 38BD0054  addi r5, r29, 0x54
	ctx.r[5].s64 = ctx.r[29].s64 + 84;
	// 821BAB78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BAB7C: 487B7035  bl 0x82971bb0
	ctx.lr = 0x821BAB80;
	sub_82971BB0(ctx, base);
	// 821BAB80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BAB84: 394B2BF4  addi r10, r11, 0x2bf4
	ctx.r[10].s64 = ctx.r[11].s64 + 11252;
	// 821BAB88: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821BAB8C: 93DC002C  stw r30, 0x2c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 821BAB90: 48000008  b 0x821bab98
	pc = 0x821BAB98; continue 'dispatch;
	// 821BAB94: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 821BAB98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BAB9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BABA0: 48000F11  bl 0x821bbab0
	ctx.lr = 0x821BABA4;
	sub_821BBAB0(ctx, base);
	// 821BABA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BABA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BABAC: 480B12BD  bl 0x8226be68
	ctx.lr = 0x821BABB0;
	sub_8226BE68(ctx, base);
	// 821BABB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BABB4: 4BFFCF65  bl 0x821b7b18
	ctx.lr = 0x821BABB8;
	sub_821B7B18(ctx, base);
	// 821BABB8: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821BABBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BABC0: 419A0088  beq cr6, 0x821bac48
	if ctx.cr[6].eq {
	pc = 0x821BAC48; continue 'dispatch;
	}
	// 821BABC4: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 821BABC8: 48064691  bl 0x8221f258
	ctx.lr = 0x821BABCC;
	sub_8221F258(ctx, base);
	// 821BABCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BABD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BABD4: 419A0054  beq cr6, 0x821bac28
	if ctx.cr[6].eq {
	pc = 0x821BAC28; continue 'dispatch;
	}
	// 821BABD8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BABDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821BABE0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BABE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BABE8: 4E800421  bctrl
	ctx.lr = 0x821BABEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BABEC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821BABF0: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BABF4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821BABF8: 390921E0  addi r8, r9, 0x21e0
	ctx.r[8].s64 = ctx.r[9].s64 + 8672;
	// 821BABFC: D3FF0008  stfs f31, 8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821BAC00: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821BAC04: 935F0018  stw r26, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 821BAC08: D03F0010  stfs f1, 0x10(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821BAC0C: 9BDF001C  stb r30, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 821BAC10: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821BAC14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BAC18: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821BAC1C: 9BDF001D  stb r30, 0x1d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(29 as u32), ctx.r[30].u8 ) };
	// 821BAC20: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BAC24: 48000008  b 0x821bac2c
	pc = 0x821BAC2C; continue 'dispatch;
	// 821BAC28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BAC2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BAC30: 48000E81  bl 0x821bbab0
	ctx.lr = 0x821BAC34;
	sub_821BBAB0(ctx, base);
	// 821BAC34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BAC38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BAC3C: 480B122D  bl 0x8226be68
	ctx.lr = 0x821BAC40;
	sub_8226BE68(ctx, base);
	// 821BAC40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BAC44: 4BFFCED5  bl 0x821b7b18
	ctx.lr = 0x821BAC48;
	sub_821B7B18(ctx, base);
	// 821BAC48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821BAC4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BAC50: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821BAC54: 48AEE7FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BAC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BAC58 size=2556
    let mut pc: u32 = 0x821BAC58;
    'dispatch: loop {
        match pc {
            0x821BAC58 => {
    //   block [0x821BAC58..0x821BB654)
	// 821BAC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BAC5C: 48AEE795  bl 0x82ca93f0
	ctx.lr = 0x821BAC60;
	sub_82CA93D0(ctx, base);
	// 821BAC60: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 821BAC64: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 821BAC68: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 821BAC6C: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BB658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BB658 size=548
    let mut pc: u32 = 0x821BB658;
    'dispatch: loop {
        match pc {
            0x821BB658 => {
    //   block [0x821BB658..0x821BB87C)
	// 821BB658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BB65C: 48AEDDAD  bl 0x82ca9408
	ctx.lr = 0x821BB660;
	sub_82CA93D0(ctx, base);
	// 821BB660: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BB664: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BB668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BB66C: 3B8B9484  addi r28, r11, -0x6b7c
	ctx.r[28].s64 = ctx.r[11].s64 + -27516;
	// 821BB670: C03C0054  lfs f1, 0x54(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BB674: 480349CD  bl 0x821f0040
	ctx.lr = 0x821BB678;
	sub_821F0040(ctx, base);
	// 821BB678: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BB67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BB680: 419A01F4  beq cr6, 0x821bb874
	if ctx.cr[6].eq {
	pc = 0x821BB874; continue 'dispatch;
	}
	// 821BB684: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB688: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821BB68C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BB690: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB694: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821BB698: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BB69C: 4E800421  bctrl
	ctx.lr = 0x821BB6A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB6A0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB6A4: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 821BB6A8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821BB6AC: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821BB6B0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821BB6B4: 8085007C  lwz r4, 0x7c(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(124 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BB880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BB880 size=560
    let mut pc: u32 = 0x821BB880;
    'dispatch: loop {
        match pc {
            0x821BB880 => {
    //   block [0x821BB880..0x821BBAB0)
	// 821BB880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BB884: 48AEDB4D  bl 0x82ca93d0
	ctx.lr = 0x821BB888;
	sub_82CA93D0(ctx, base);
	// 821BB888: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BB88C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB890: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821BB894: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821BB898: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 821BB89C: 3DE08349  lis r15, -0x7cb7
	ctx.r[15].s64 = -2092367872;
	// 821BB8A0: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	// 821BB8A4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB8A8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821BB8AC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 821BB8B0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821BB8B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BB8B8: 812F6C10  lwz r9, 0x6c10(r15)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27664 as u32) ) } as u64;
	// 821BB8BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821BB8C0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BB8C4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 821BB8C8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 821BB8CC: 93EF6C10  stw r31, 0x6c10(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 821BB8D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BB8D4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB8D8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 821BB8DC: 82690064  lwz r19, 0x64(r9)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BB8E0: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 821BB8E4: 480AA145  bl 0x82265a28
	ctx.lr = 0x821BB8E8;
	sub_82265A28(ctx, base);
	// 821BB8E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BB8EC: 92410050  stw r18, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[18].u32 ) };
	// 821BB8F0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 821BB8F4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BB8F8: 409901B0  ble cr6, 0x821bbaa8
	if !ctx.cr[6].gt {
	pc = 0x821BBAA8; continue 'dispatch;
	}
	// 821BB8FC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821BB900: 7E549378  mr r20, r18
	ctx.r[20].u64 = ctx.r[18].u64;
	// 821BB904: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821BB908: 3A200001  li r17, 1
	ctx.r[17].s64 = 1;
	// 821BB90C: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 821BB910: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 821BB914: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BB918: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821BB91C: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 821BB920: 39CBA2F8  addi r14, r11, -0x5d08
	ctx.r[14].s64 = ctx.r[11].s64 + -23816;
	// 821BB924: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 821BB928: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821BB92C: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BB930: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821BB934: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BB938: 7CB4582E  lwzx r5, r20, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BB93C: 7D592E30  sraw r25, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[25].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 821BB940: 7D0A2E30  sraw r10, r8, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 821BB944: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 821BB948: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 821BB94C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 821BB950: 7C99B051  subf. r4, r25, r22
	ctx.r[4].s64 = ctx.r[22].s64 - ctx.r[25].s64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821BB954: 3A0B0001  addi r16, r11, 1
	ctx.r[16].s64 = ctx.r[11].s64 + 1;
	// 821BB958: 41820134  beq 0x821bba8c
	if ctx.cr[0].eq {
	pc = 0x821BBA8C; continue 'dispatch;
	}
	// 821BB95C: 7D6A8051  subf. r11, r10, r16
	ctx.r[11].s64 = ctx.r[16].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BB960: 4182012C  beq 0x821bba8c
	if ctx.cr[0].eq {
	pc = 0x821BBA8C; continue 'dispatch;
	}
	// 821BB964: 7D555378  mr r21, r10
	ctx.r[21].u64 = ctx.r[10].u64;
	// 821BB968: 7F0A8000  cmpw cr6, r10, r16
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[16].s32, &mut ctx.xer);
	// 821BB96C: 40980120  bge cr6, 0x821bba8c
	if !ctx.cr[6].lt {
	pc = 0x821BBA8C; continue 'dispatch;
	}
	// 821BB970: 81730008  lwz r11, 8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BB974: 7F37CB78  mr r23, r25
	ctx.r[23].u64 = ctx.r[25].u64;
	// 821BB978: 81530018  lwz r10, 0x18(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BB97C: 7F19B000  cmpw cr6, r25, r22
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[22].s32, &mut ctx.xer);
	// 821BB980: 7D725A14  add r11, r18, r11
	ctx.r[11].u64 = ctx.r[18].u64 + ctx.r[11].u64;
	// 821BB984: 7D4AA214  add r10, r10, r20
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[20].u64;
	// 821BB988: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB98C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB990: 7D69A9D6  mullw r11, r9, r21
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[21].s32 as i64);
	// 821BB994: 7D0BCA14  add r8, r11, r25
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 821BB998: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BB99C: 7F0B5214  add r24, r11, r10
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BB9A0: 409800D8  bge cr6, 0x821bba78
	if !ctx.cr[6].lt {
	pc = 0x821BBA78; continue 'dispatch;
	}
	// 821BB9A4: 83580000  lwz r26, 0(r24)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9A8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821BB9AC: 419A00BC  beq cr6, 0x821bba68
	if ctx.cr[6].eq {
	pc = 0x821BBA68; continue 'dispatch;
	}
	// 821BB9B0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9B4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BB9B8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821BB9BC: 409800A0  bge cr6, 0x821bba5c
	if !ctx.cr[6].lt {
	pc = 0x821BBA5C; continue 'dispatch;
	}
	// 821BB9C0: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 821BB9C4: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB9C8: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821BB9D0: 48047C11  bl 0x822035e0
	ctx.lr = 0x821BB9D4;
	sub_822035E0(ctx, base);
	// 821BB9D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BB9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BB9DC: 419A0070  beq cr6, 0x821bba4c
	if ctx.cr[6].eq {
	pc = 0x821BBA4C; continue 'dispatch;
	}
	// 821BB9E0: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB9E4: 3BDC0024  addi r30, r28, 0x24
	ctx.r[30].s64 = ctx.r[28].s64 + 36;
	// 821BB9E8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9EC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9F0: 2B1F00FE  cmplwi cr6, r31, 0xfe
	ctx.cr[6].compare_u32(ctx.r[31].u32, 254 as u32, &mut ctx.xer);
	// 821BB9F4: 4198000C  blt cr6, 0x821bba00
	if ctx.cr[6].lt {
	pc = 0x821BBA00; continue 'dispatch;
	}
	// 821BB9F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BB9FC: 48135255  bl 0x822f0c50
	ctx.lr = 0x821BBA00;
	sub_822F0C50(ctx, base);
	// 821BBA00: 57EBE8FA  rlwinm r11, r31, 0x1d, 3, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000007u64;
	// 821BBA04: 57EA06FE  clrlwi r10, r31, 0x1b
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x0000001Fu64;
	// 821BBA08: 7E295030  slw r9, r17, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[17].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 821BBA0C: 7D0BF02E  lwzx r8, r11, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821BBA10: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821BBA14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BBA18: 409A0020  bne cr6, 0x821bba38
	if !ctx.cr[6].eq {
	pc = 0x821BBA38; continue 'dispatch;
	}
	// 821BBA1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BBA20: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBA24: 480446C5  bl 0x822000e8
	ctx.lr = 0x821BBA28;
	sub_822000E8(ctx, base);
	// 821BBA28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BBA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBA30: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 821BBA34: 409A0008  bne cr6, 0x821bba3c
	if !ctx.cr[6].eq {
	pc = 0x821BBA3C; continue 'dispatch;
	}
	// 821BBA38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BBA3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BBA40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBA44: 419A0008  beq cr6, 0x821bba4c
	if ctx.cr[6].eq {
	pc = 0x821BBA4C; continue 'dispatch;
	}
	// 821BBA48: 939B0008  stw r28, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 821BBA4C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BBA50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBA54: 409A0054  bne cr6, 0x821bbaa8
	if !ctx.cr[6].eq {
	pc = 0x821BBAA8; continue 'dispatch;
	}
	// 821BBA58: 83EF6C10  lwz r31, 0x6c10(r15)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27664 as u32) ) } as u64;
	// 821BBA5C: 835A0004  lwz r26, 4(r26)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBA60: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821BBA64: 409AFF4C  bne cr6, 0x821bb9b0
	if !ctx.cr[6].eq {
	pc = 0x821BB9B0; continue 'dispatch;
	}
	// 821BBA68: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 821BBA6C: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 821BBA70: 7F17B000  cmpw cr6, r23, r22
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[22].s32, &mut ctx.xer);
	// 821BBA74: 4198FF30  blt cr6, 0x821bb9a4
	if ctx.cr[6].lt {
	pc = 0x821BB9A4; continue 'dispatch;
	}
	// 821BBA78: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 821BBA7C: 7F158000  cmpw cr6, r21, r16
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[16].s32, &mut ctx.xer);
	// 821BBA80: 4198FEF0  blt cr6, 0x821bb970
	if ctx.cr[6].lt {
	pc = 0x821BB970; continue 'dispatch;
	}
	// 821BBA84: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BBA88: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 821BBA8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BBA90: 3A520014  addi r18, r18, 0x14
	ctx.r[18].s64 = ctx.r[18].s64 + 20;
	// 821BBA94: 3A940010  addi r20, r20, 0x10
	ctx.r[20].s64 = ctx.r[20].s64 + 16;
	// 821BBA98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BBA9C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821BBAA0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821BBAA4: 4198FE80  blt cr6, 0x821bb924
	if ctx.cr[6].lt {
	pc = 0x821BB924; continue 'dispatch;
	}
	// 821BBAA8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821BBAAC: 48AED974  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BBAB0 size=116
    let mut pc: u32 = 0x821BBAB0;
    'dispatch: loop {
        match pc {
            0x821BBAB0 => {
    //   block [0x821BBAB0..0x821BBB24)
	// 821BBAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBAB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BBAB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BBABC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBAC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BBAC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821BBAC8: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821BBACC: 419A0038  beq cr6, 0x821bbb04
	if ctx.cr[6].eq {
	pc = 0x821BBB04; continue 'dispatch;
	}
	// 821BBAD0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 821BBAD4: 48063785  bl 0x8221f258
	ctx.lr = 0x821BBAD8;
	sub_8221F258(ctx, base);
	// 821BBAD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BBADC: 419A0028  beq cr6, 0x821bbb04
	if ctx.cr[6].eq {
	pc = 0x821BBB04; continue 'dispatch;
	}
	// 821BBAE0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBAE4: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 821BBAE8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821BBAEC: 38E95FA0  addi r7, r9, 0x5fa0
	ctx.r[7].s64 = ctx.r[9].s64 + 24480;
	// 821BBAF0: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BBAF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821BBAF8: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821BBAFC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821BBB00: 48000008  b 0x821bbb08
	pc = 0x821BBB08; continue 'dispatch;
	// 821BBB04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BBB08: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821BBB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BBB10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BBB14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BBB18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BBB1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BBB20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BBB28 size=164
    let mut pc: u32 = 0x821BBB28;
    'dispatch: loop {
        match pc {
            0x821BBB28 => {
    //   block [0x821BBB28..0x821BBBCC)
	// 821BBB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBB2C: 48AED8D5  bl 0x82ca9400
	ctx.lr = 0x821BBB30;
	sub_82CA93D0(ctx, base);
	// 821BBB30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBB34: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821BBB38: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821BBB3C: 3BBA1028  addi r29, r26, 0x1028
	ctx.r[29].s64 = ctx.r[26].s64 + 4136;
	// 821BBB40: 3BDA0F38  addi r30, r26, 0xf38
	ctx.r[30].s64 = ctx.r[26].s64 + 3896;
	// 821BBB44: 7FFAD850  subf r31, r26, r27
	ctx.r[31].s64 = ctx.r[27].s64 - ctx.r[26].s64;
	// 821BBB48: 3B80000F  li r28, 0xf
	ctx.r[28].s64 = 15;
	// 821BBB4C: 7C9FF214  add r4, r31, r30
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 821BBB50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BBB54: 4802BBB5  bl 0x821e7708
	ctx.lr = 0x821BBB58;
	sub_821E7708(ctx, base);
	// 821BBB58: 7C1FEC2E  lfsx f0, r31, r29
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BBB5C: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821BBB60: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821BBB64: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821BBB68: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821BBB6C: 4082FFE0  bne 0x821bbb4c
	if !ctx.cr[0].eq {
	pc = 0x821BBB4C; continue 'dispatch;
	}
	// 821BBB70: 38FB0C34  addi r7, r27, 0xc34
	ctx.r[7].s64 = ctx.r[27].s64 + 3124;
	// 821BBB74: 391B0020  addi r8, r27, 0x20
	ctx.r[8].s64 = ctx.r[27].s64 + 32;
	// 821BBB78: 395A0C30  addi r10, r26, 0xc30
	ctx.r[10].s64 = ctx.r[26].s64 + 3120;
	// 821BBB7C: 397A0010  addi r11, r26, 0x10
	ctx.r[11].s64 = ctx.r[26].s64 + 16;
	// 821BBB80: 39200061  li r9, 0x61
	ctx.r[9].s64 = 97;
	// 821BBB84: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BBBD0 size=572
    let mut pc: u32 = 0x821BBBD0;
    'dispatch: loop {
        match pc {
            0x821BBBD0 => {
    //   block [0x821BBBD0..0x821BBE0C)
	// 821BBBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBBD4: 48AED835  bl 0x82ca9408
	ctx.lr = 0x821BBBD8;
	sub_82CA93D0(ctx, base);
	// 821BBBD8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBBDC: 806300F0  lwz r3, 0xf0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) } as u64;
	// 821BBBE0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821BBBE4: 4806A715  bl 0x822262f8
	ctx.lr = 0x821BBBE8;
	sub_822262F8(ctx, base);
	// 821BBBE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BBBEC: 39400058  li r10, 0x58
	ctx.r[10].s64 = 88;
	// 821BBBF0: 3BEBB480  addi r31, r11, -0x4b80
	ctx.r[31].s64 = ctx.r[11].s64 + -19328;
	// 821BBBF4: 39200054  li r9, 0x54
	ctx.r[9].s64 = 84;
	// 821BBBF8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821BBBFC: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BBE10 size=292
    let mut pc: u32 = 0x821BBE10;
    'dispatch: loop {
        match pc {
            0x821BBE10 => {
    //   block [0x821BBE10..0x821BBF34)
	// 821BBE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBE14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BBE18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBE1C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821BBE20: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BBE24: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821BBE28: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BBE2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBE30: 419A0030  beq cr6, 0x821bbe60
	if ctx.cr[6].eq {
	pc = 0x821BBE60; continue 'dispatch;
	}
	// 821BBE34: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBE38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BBE3C: 409A00E8  bne cr6, 0x821bbf24
	if !ctx.cr[6].eq {
	pc = 0x821BBF24; continue 'dispatch;
	}
	// 821BBE40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBE44: 419A001C  beq cr6, 0x821bbe60
	if ctx.cr[6].eq {
	pc = 0x821BBE60; continue 'dispatch;
	}
	// 821BBE48: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821BBE4C: 810B0070  lwz r8, 0x70(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 821BBE50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BBE54: 38E96B20  addi r7, r9, 0x6b20
	ctx.r[7].s64 = ctx.r[9].s64 + 27424;
	// 821BBE58: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821BBE5C: 419A0008  beq cr6, 0x821bbe64
	if ctx.cr[6].eq {
	pc = 0x821BBE64; continue 'dispatch;
	}
	// 821BBE60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BBE64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BBE68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBE6C: 419A00B4  beq cr6, 0x821bbf20
	if ctx.cr[6].eq {
	pc = 0x821BBF20; continue 'dispatch;
	}
	// 821BBE70: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 821BBE74: 419A00AC  beq cr6, 0x821bbf20
	if ctx.cr[6].eq {
	pc = 0x821BBF20; continue 'dispatch;
	}
	// 821BBE78: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBE7C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821BBE80: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBE84: 2F09000F  cmpwi cr6, r9, 0xf
	ctx.cr[6].compare_i32(ctx.r[9].s32, 15, &mut ctx.xer);
	// 821BBE88: 409A0098  bne cr6, 0x821bbf20
	if !ctx.cr[6].eq {
	pc = 0x821BBF20; continue 'dispatch;
	}
	// 821BBE8C: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BBE90: 5489007E  clrlwi r9, r4, 1
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 821BBE94: 54880000  rlwinm r8, r4, 0, 0, 0
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 821BBE98: 20EB0020  subfic r7, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[7].s64 = (32 as i64) - ctx.r[11].s64;
	// 821BBE9C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BBEA0: 7D2B3C30  srw r11, r9, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) >> ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 821BBEA4: 409A0010  bne cr6, 0x821bbeb4
	if !ctx.cr[6].eq {
	pc = 0x821BBEB4; continue 'dispatch;
	}
	// 821BBEA8: 814A0050  lwz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BBEAC: 556B3830  slwi r11, r11, 7
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BBEB0: 48000014  b 0x821bbec4
	pc = 0x821BBEC4; continue 'dispatch;
	// 821BBEB4: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BBEB8: 814A0058  lwz r10, 0x58(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BBEBC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821BBEC0: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BBEC4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BBEC8: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BBECC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BBED0: 419A0050  beq cr6, 0x821bbf20
	if ctx.cr[6].eq {
	pc = 0x821BBF20; continue 'dispatch;
	}
	// 821BBED4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BBED8: 894B6C68  lbz r10, 0x6c68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27752 as u32) ) } as u64;
	// 821BBEDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BBEE0: 409A0044  bne cr6, 0x821bbf24
	if !ctx.cr[6].eq {
	pc = 0x821BBF24; continue 'dispatch;
	}
	// 821BBEE4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BBEE8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821BBEEC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BBEF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BBEF4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821BBEF8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821BBEFC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBF00: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BBF04: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBF08: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBF0C: 480A857D  bl 0x82264488
	ctx.lr = 0x821BBF10;
	sub_82264488(ctx, base);
	// 821BBF10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BBF14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BBF18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BBF1C: 4E800020  blr
	return;
	// 821BBF20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BBF24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BBF28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BBF2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BBF30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BBF38 size=328
    let mut pc: u32 = 0x821BBF38;
    'dispatch: loop {
        match pc {
            0x821BBF38 => {
    //   block [0x821BBF38..0x821BC080)
	// 821BBF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBF3C: 48AED4C5  bl 0x82ca9400
	ctx.lr = 0x821BBF40;
	sub_82CA93D0(ctx, base);
	// 821BBF40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBF44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BBF48: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821BBF4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BBF50: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821BBF54: 48C8A5ED  bl 0x82e46540
	ctx.lr = 0x821BBF58;
	sub_82E46540(ctx, base);
	// 821BBF58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821BBF5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BBF60: 838B002C  lwz r28, 0x2c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BBF64: 48C8A5DD  bl 0x82e46540
	ctx.lr = 0x821BBF68;
	sub_82E46540(ctx, base);
	// 821BBF68: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821BBF6C: 8363002C  lwz r27, 0x2c(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BBF70: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821BBF74: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBF78: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BBF7C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBF80: 80670018  lwz r3, 0x18(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BBF84: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBF88: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BBF8C: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 821BBF90: 4E800421  bctrl
	ctx.lr = 0x821BBF94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BBF94: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821BBF98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BBF9C: 48C8A5A5  bl 0x82e46540
	ctx.lr = 0x821BBFA0;
	sub_82E46540(ctx, base);
	// 821BBFA0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBFA4: 38C30010  addi r6, r3, 0x10
	ctx.r[6].s64 = ctx.r[3].s64 + 16;
	// 821BBFA8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821BBFAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BBFB0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BBFB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBFB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BBFBC: 4E800421  bctrl
	ctx.lr = 0x821BBFC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BBFC0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BBFC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BBFC8: 419A00B0  beq cr6, 0x821bc078
	if ctx.cr[6].eq {
	pc = 0x821BC078; continue 'dispatch;
	}
	// 821BBFCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BBFD0: 48C8A571  bl 0x82e46540
	ctx.lr = 0x821BBFD4;
	sub_82E46540(ctx, base);
	// 821BBFD4: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 821BBFD8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BBFDC: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821BBFE0: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BBFE4: 41820014  beq 0x821bbff8
	if ctx.cr[0].eq {
	pc = 0x821BBFF8; continue 'dispatch;
	}
	// 821BBFE8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBFEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBFF0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821BBFF4: 409A0008  bne cr6, 0x821bbffc
	if !ctx.cr[6].eq {
	pc = 0x821BBFFC; continue 'dispatch;
	}
	// 821BBFF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821BBFFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BC000: 48C8A541  bl 0x82e46540
	ctx.lr = 0x821BC004;
	sub_82E46540(ctx, base);
	// 821BC004: 89430020  lbz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BC008: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 821BC00C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821BC010: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC014: 41820064  beq 0x821bc078
	if ctx.cr[0].eq {
	pc = 0x821BC078; continue 'dispatch;
	}
	// 821BC018: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BC01C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821BC020: 419A0058  beq cr6, 0x821bc078
	if ctx.cr[6].eq {
	pc = 0x821BC078; continue 'dispatch;
	}
	// 821BC024: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BC028: 419A0050  beq cr6, 0x821bc078
	if ctx.cr[6].eq {
	pc = 0x821BC078; continue 'dispatch;
	}
	// 821BC02C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BC080 size=236
    let mut pc: u32 = 0x821BC080;
    'dispatch: loop {
        match pc {
            0x821BC080 => {
    //   block [0x821BC080..0x821BC16C)
	// 821BC080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC084: 48AED381  bl 0x82ca9404
	ctx.lr = 0x821BC088;
	sub_82CA93D0(ctx, base);
	// 821BC088: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC08C: 3D600AAA  lis r11, 0xaaa
	ctx.r[11].s64 = 178913280;
	// 821BC090: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821BC094: 616AAAAA  ori r10, r11, 0xaaaa
	ctx.r[10].u64 = ctx.r[11].u64 | 43690;
	// 821BC098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BC09C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BC0A0: 40990010  ble cr6, 0x821bc0b0
	if !ctx.cr[6].gt {
	pc = 0x821BC0B0; continue 'dispatch;
	}
	// 821BC0A4: 4888B425  bl 0x82a474c8
	ctx.lr = 0x821BC0A8;
	sub_82A474C8(ctx, base);
	// 821BC0A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BC0AC: 48AED3A8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 821BC0B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC0B4: 3B600018  li r27, 0x18
	ctx.r[27].s64 = 24;
	// 821BC0B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821BC0BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC0C0: 409A000C  bne cr6, 0x821bc0cc
	if !ctx.cr[6].eq {
	pc = 0x821BC0CC; continue 'dispatch;
	}
	// 821BC0C4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821BC0C8: 48000010  b 0x821bc0d8
	pc = 0x821BC0D8; continue 'dispatch;
	// 821BC0CC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BC0D0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BC0D4: 7D69DBD6  divw r11, r9, r27
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 821BC0D8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821BC0DC: 40980088  bge cr6, 0x821bc164
	if !ctx.cr[6].lt {
	pc = 0x821BC164; continue 'dispatch;
	}
	// 821BC0E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BC0E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BC0E8: 488C8011  bl 0x82a840f8
	ctx.lr = 0x821BC0EC;
	sub_82A840F8(ctx, base);
	// 821BC0EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC0F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BC0F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BC0F8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821BC0FC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 821BC100: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821BC104: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821BC108: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821BC10C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821BC110: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821BC114: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821BC118: 488C8881  bl 0x82a84998
	ctx.lr = 0x821BC11C;
	sub_82A84998(ctx, base);
	// 821BC11C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC120: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BC124: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC128: 7D034850  subf r8, r3, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 821BC12C: 7FA8DBD6  divw r29, r8, r27
	ctx.r[29].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 821BC130: 419A0008  beq cr6, 0x821bc138
	if ctx.cr[6].eq {
	pc = 0x821BC138; continue 'dispatch;
	}
	// 821BC134: 4805FC05  bl 0x8221bd38
	ctx.lr = 0x821BC138;
	sub_8221BD38(ctx, base);
	// 821BC138: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BC13C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821BC140: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BC144: 7D3D5A14  add r9, r29, r11
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821BC148: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821BC14C: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BC150: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BC154: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821BC158: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821BC15C: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821BC160: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 821BC164: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BC168: 48AED2EC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BC170 size=284
    let mut pc: u32 = 0x821BC170;
    'dispatch: loop {
        match pc {
            0x821BC170 => {
    //   block [0x821BC170..0x821BC28C)
	// 821BC170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BC178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BC17C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BC180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC184: 3BE30018  addi r31, r3, 0x18
	ctx.r[31].s64 = ctx.r[3].s64 + 24;
	// 821BC188: 3BC00017  li r30, 0x17
	ctx.r[30].s64 = 23;
	// 821BC18C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC190: 80BFFFFC  lwz r5, -4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821BC194: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821BC198: 419A0010  beq cr6, 0x821bc1a8
	if ctx.cr[6].eq {
	pc = 0x821BC1A8; continue 'dispatch;
	}
	// 821BC19C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821BC1A0: 488C7FD1  bl 0x82a84170
	ctx.lr = 0x821BC1A4;
	sub_82A84170(ctx, base);
	// 821BC1A4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821BC1A8: 387FFFF8  addi r3, r31, -8
	ctx.r[3].s64 = ctx.r[31].s64 + -8;
	// 821BC1AC: 480000E5  bl 0x821bc290
	ctx.lr = 0x821BC1B0;
	sub_821BC290(ctx, base);
	// 821BC1B0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821BC1B4: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821BC1B8: 4082FFD4  bne 0x821bc18c
	if !ctx.cr[0].eq {
	pc = 0x821BC18C; continue 'dispatch;
	}
	// 821BC1BC: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821BC1C0: 897F05A1  lbz r11, 0x5a1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1441 as u32) ) } as u64;
	// 821BC1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC1C8: 419A00AC  beq cr6, 0x821bc274
	if ctx.cr[6].eq {
	pc = 0x821BC274; continue 'dispatch;
	}
	// 821BC1CC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821BC1D0: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821BC1D4: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821BC1D8: 38EA6FAC  addi r7, r10, 0x6fac
	ctx.r[7].s64 = ctx.r[10].s64 + 28588;
	// 821BC1DC: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821BC1E0: 39092390  addi r8, r9, 0x2390
	ctx.r[8].s64 = ctx.r[9].s64 + 9104;
	// 821BC1E4: 88CB1A25  lbz r6, 0x1a25(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6693 as u32) ) } as u64;
	// 821BC1E8: 812B1A14  lwz r9, 0x1a14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6676 as u32) ) } as u64;
	// 821BC1EC: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s64 = ctx.r[6].s64 * 8200;
	// 821BC1F0: 80E70008  lwz r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BC1F4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821BC1F8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821BC1FC: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821BC200: 419A006C  beq cr6, 0x821bc26c
	if ctx.cr[6].eq {
	pc = 0x821BC26C; continue 'dispatch;
	}
	// 821BC204: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821BC208: 810B1A18  lwz r8, 0x1a18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6680 as u32) ) } as u64;
	// 821BC20C: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821BC210: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821BC214: 409A003C  bne cr6, 0x821bc250
	if !ctx.cr[6].eq {
	pc = 0x821BC250; continue 'dispatch;
	}
	// 821BC218: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BC21C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821BC220: 38AB1A10  addi r5, r11, 0x1a10
	ctx.r[5].s64 = ctx.r[11].s64 + 6672;
	// 821BC224: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821BC228: 912B1A18  stw r9, 0x1a18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6680 as u32), ctx.r[9].u32 ) };
	// 821BC22C: 7CA4512E  stwx r5, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821BC230: 812B1A14  lwz r9, 0x1a14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6676 as u32) ) } as u64;
	// 821BC234: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BC238: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC23C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821BC240: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821BC244: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BC248: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821BC24C: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	// 821BC250: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BC254: 90EB1A14  stw r7, 0x1a14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6676 as u32), ctx.r[7].u32 ) };
	// 821BC258: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821BC25C: 994B1A24  stb r10, 0x1a24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6692 as u32), ctx.r[10].u8 ) };
	// 821BC260: 386B1A10  addi r3, r11, 0x1a10
	ctx.r[3].s64 = ctx.r[11].s64 + 6672;
	// 821BC264: 992B1A1C  stb r9, 0x1a1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6684 as u32), ctx.r[9].u8 ) };
	// 821BC268: 480622E9  bl 0x8221e550
	ctx.lr = 0x821BC26C;
	sub_8221E550(ctx, base);
	// 821BC26C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BC270: 997F05A1  stb r11, 0x5a1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1441 as u32), ctx.r[11].u8 ) };
	// 821BC274: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BC278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BC27C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BC280: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BC284: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BC288: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BC290 size=268
    let mut pc: u32 = 0x821BC290;
    'dispatch: loop {
        match pc {
            0x821BC290 => {
    //   block [0x821BC290..0x821BC39C)
	// 821BC290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC294: 48AED175  bl 0x82ca9408
	ctx.lr = 0x821BC298;
	sub_82CA93D0(ctx, base);
	// 821BC298: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC29C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BC2A0: 39200018  li r9, 0x18
	ctx.r[9].s64 = 24;
	// 821BC2A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821BC2A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC2AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC2B0: 409A000C  bne cr6, 0x821bc2bc
	if !ctx.cr[6].eq {
	pc = 0x821BC2BC; continue 'dispatch;
	}
	// 821BC2B4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821BC2B8: 48000010  b 0x821bc2c8
	pc = 0x821BC2C8; continue 'dispatch;
	// 821BC2BC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BC2C0: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BC2C4: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 821BC2C8: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BC2CC: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 821BC2D0: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821BC2D4: 7C874BD6  divw r4, r7, r9
	ctx.r[4].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 821BC2D8: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821BC2DC: 409900B8  ble cr6, 0x821bc394
	if !ctx.cr[6].gt {
	pc = 0x821BC394; continue 'dispatch;
	}
	// 821BC2E0: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 821BC2E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821BC2E8: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 821BC2EC: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 821BC2F0: 4BFFFD91  bl 0x821bc080
	ctx.lr = 0x821BC2F4;
	sub_821BC080(ctx, base);
	// 821BC2F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC2F8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821BC2FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821BC300: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC304: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 821BC308: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 821BC30C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821BC310: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821BC314: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821BC318: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 821BC31C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BC320: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821BC324: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BC328: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821BC32C: 4BFFE2C5  bl 0x821ba5f0
	ctx.lr = 0x821BC330;
	sub_821BA5F0(ctx, base);
	// 821BC330: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC334: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC338: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821BC33C: 419A0010  beq cr6, 0x821bc34c
	if ctx.cr[6].eq {
	pc = 0x821BC34C; continue 'dispatch;
	}
	// 821BC340: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821BC344: 488C7E2D  bl 0x82a84170
	ctx.lr = 0x821BC348;
	sub_82A84170(ctx, base);
	// 821BC348: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821BC34C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC350: 3B9F000C  addi r28, r31, 0xc
	ctx.r[28].s64 = ctx.r[31].s64 + 12;
	// 821BC354: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821BC358: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821BC35C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC360: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821BC364: 419A0008  beq cr6, 0x821bc36c
	if ctx.cr[6].eq {
	pc = 0x821BC36C; continue 'dispatch;
	}
	// 821BC368: 4805F9D1  bl 0x8221bd38
	ctx.lr = 0x821BC36C;
	sub_8221BD38(ctx, base);
	// 821BC36C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821BC370: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821BC374: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BC378: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC37C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821BC380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC384: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821BC388: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821BC38C: 419A0008  beq cr6, 0x821bc394
	if ctx.cr[6].eq {
	pc = 0x821BC394; continue 'dispatch;
	}
	// 821BC390: 4805F9A9  bl 0x8221bd38
	ctx.lr = 0x821BC394;
	sub_8221BD38(ctx, base);
	// 821BC394: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821BC398: 48AED0C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BC3A0 size=404
    let mut pc: u32 = 0x821BC3A0;
    'dispatch: loop {
        match pc {
            0x821BC3A0 => {
    //   block [0x821BC3A0..0x821BC534)
	// 821BC3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BC3A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC3AC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BC3B0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821BC3B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC3B8: 419A0168  beq cr6, 0x821bc520
	if ctx.cr[6].eq {
	pc = 0x821BC520; continue 'dispatch;
	}
	// 821BC3BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BC3C0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BC3C4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC3C8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC3CC: 4806FDED  bl 0x8222c1b8
	ctx.lr = 0x821BC3D0;
	sub_8222C1B8(ctx, base);
	// 821BC3D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC3D4: 419A0018  beq cr6, 0x821bc3ec
	if ctx.cr[6].eq {
	pc = 0x821BC3EC; continue 'dispatch;
	}
	// 821BC3D8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821BC3DC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821BC3E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BC3E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC3E8: 409A0008  bne cr6, 0x821bc3f0
	if !ctx.cr[6].eq {
	pc = 0x821BC3F0; continue 'dispatch;
	}
	// 821BC3EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BC3F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC3F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC3F8: 419A0128  beq cr6, 0x821bc520
	if ctx.cr[6].eq {
	pc = 0x821BC520; continue 'dispatch;
	}
	// 821BC3FC: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BC400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BC404: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821BC408: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BC40C: 419A00EC  beq cr6, 0x821bc4f8
	if ctx.cr[6].eq {
	pc = 0x821BC4F8; continue 'dispatch;
	}
	// 821BC410: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BC414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC418: 419A0020  beq cr6, 0x821bc438
	if ctx.cr[6].eq {
	pc = 0x821BC438; continue 'dispatch;
	}
	// 821BC41C: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 821BC420: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC424: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821BC428: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821BC42C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BC430: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC434: 480000C8  b 0x821bc4fc
	pc = 0x821BC4FC; continue 'dispatch;
	// 821BC438: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC43C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BC440: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BC444: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821BC448: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821BC44C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821BC450: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC454: 40810054  ble 0x821bc4a8
	if !ctx.cr[0].gt {
	pc = 0x821BC4A8; continue 'dispatch;
	}
	// 821BC458: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821BC45C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC460: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821BC464: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC468: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821BC46C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821BC470: 41980008  blt cr6, 0x821bc478
	if ctx.cr[6].lt {
	pc = 0x821BC478; continue 'dispatch;
	}
	// 821BC474: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821BC478: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821BC47C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BC480: 419A0014  beq cr6, 0x821bc494
	if ctx.cr[6].eq {
	pc = 0x821BC494; continue 'dispatch;
	}
	// 821BC484: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BC488: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821BC48C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BC490: 4800000C  b 0x821bc49c
	pc = 0x821BC49C; continue 'dispatch;
	// 821BC494: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821BC498: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821BC49C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC4A0: 4199FFB8  bgt cr6, 0x821bc458
	if ctx.cr[6].gt {
	pc = 0x821BC458; continue 'dispatch;
	}
	// 821BC4A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821BC4A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BC4AC: 419A003C  beq cr6, 0x821bc4e8
	if ctx.cr[6].eq {
	pc = 0x821BC4E8; continue 'dispatch;
	}
	// 821BC4B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC4B4: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821BC4B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BC4BC: 41990008  bgt cr6, 0x821bc4c4
	if ctx.cr[6].gt {
	pc = 0x821BC4C4; continue 'dispatch;
	}
	// 821BC4C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BC4C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC4C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC4CC: 409A001C  bne cr6, 0x821bc4e8
	if !ctx.cr[6].eq {
	pc = 0x821BC4E8; continue 'dispatch;
	}
	// 821BC4D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821BC4D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BC4D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821BC4DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821BC4E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC4E4: 48000018  b 0x821bc4fc
	pc = 0x821BC4FC; continue 'dispatch;
	// 821BC4E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821BC4EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BC4F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC4F4: 48000008  b 0x821bc4fc
	pc = 0x821BC4FC; continue 'dispatch;
	// 821BC4F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821BC4FC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821BC500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC504: 419A001C  beq cr6, 0x821bc520
	if ctx.cr[6].eq {
	pc = 0x821BC520; continue 'dispatch;
	}
	// 821BC508: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821BC50C: C1AB0088  lfs f13, 0x88(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821BC510: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BC514: C00A9A80  lfs f0, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BC518: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821BC51C: 41990008  bgt cr6, 0x821bc524
	if ctx.cr[6].gt {
	pc = 0x821BC524; continue 'dispatch;
	}
	// 821BC520: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BC524: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BC528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BC52C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BC530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BC538 size=172
    let mut pc: u32 = 0x821BC538;
    'dispatch: loop {
        match pc {
            0x821BC538 => {
    //   block [0x821BC538..0x821BC5E4)
	// 821BC538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BC540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BC544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BC548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC54C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BC550: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC554: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821BC558: 485A43D1  bl 0x82760928
	ctx.lr = 0x821BC55C;
	sub_82760928(ctx, base);
	// 821BC55C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BC560: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821BC564: 419A0068  beq cr6, 0x821bc5cc
	if ctx.cr[6].eq {
	pc = 0x821BC5CC; continue 'dispatch;
	}
	// 821BC568: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BC56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BC570: 480A35F1  bl 0x8225fb60
	ctx.lr = 0x821BC574;
	sub_8225FB60(ctx, base);
	// 821BC574: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BC578: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BC57C: 419A0050  beq cr6, 0x821bc5cc
	if ctx.cr[6].eq {
	pc = 0x821BC5CC; continue 'dispatch;
	}
	// 821BC580: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BC584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BC588: 4BFFC991  bl 0x821b8f18
	ctx.lr = 0x821BC58C;
	sub_821B8F18(ctx, base);
	// 821BC58C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821BC590: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BC594: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BC598: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BC59C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821BC5A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BC5A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BC5A8: 4082FFE8  bne 0x821bc590
	if !ctx.cr[0].eq {
	pc = 0x821BC590; continue 'dispatch;
	}
	// 821BC5AC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821BC5B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC5B4: 409A0018  bne cr6, 0x821bc5cc
	if !ctx.cr[6].eq {
	pc = 0x821BC5CC; continue 'dispatch;
	}
	// 821BC5B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BC5C0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC5C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BC5C8: 4E800421  bctrl
	ctx.lr = 0x821BC5CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BC5CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BC5D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BC5D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BC5D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BC5DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BC5E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BC5E8 size=2780
    let mut pc: u32 = 0x821BC5E8;
    'dispatch: loop {
        match pc {
            0x821BC5E8 => {
    //   block [0x821BC5E8..0x821BD0C4)
	// 821BC5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC5EC: 48AECDE5  bl 0x82ca93d0
	ctx.lr = 0x821BC5F0;
	sub_82CA93D0(ctx, base);
	// 821BC5F0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821BC5F4: 48AF16DD  bl 0x82cadcd0
	ctx.lr = 0x821BC5F8;
	sub_82CADCA0(ctx, base);
	// 821BC5F8: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC5FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BC600: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821BC604: 93A101D4  stw r29, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[29].u32 ) };
	// 821BC608: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821BC60C: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 821BC610: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC614: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BC618: 5528A7FE  rlwinm r8, r9, 0x14, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 821BC61C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BC620: 419A00F4  beq cr6, 0x821bc714
	if ctx.cr[6].eq {
	pc = 0x821BC714; continue 'dispatch;
	}
	// 821BC624: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BC628: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC62C: 419A0024  beq cr6, 0x821bc650
	if ctx.cr[6].eq {
	pc = 0x821BC650; continue 'dispatch;
	}
	// 821BC630: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BC634: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC638: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821BC63C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821BC640: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC644: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC648: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC64C: 480000CC  b 0x821bc718
	pc = 0x821BC718; continue 'dispatch;
	// 821BC650: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC654: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BC658: 92E100B8  stw r23, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[23].u32 ) };
	// 821BC65C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821BC660: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 821BC664: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC668: 40810054  ble 0x821bc6bc
	if !ctx.cr[0].gt {
	pc = 0x821BC6BC; continue 'dispatch;
	}
	// 821BC66C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821BC670: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC674: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821BC678: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC67C: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 821BC680: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821BC684: 41980008  blt cr6, 0x821bc68c
	if ctx.cr[6].lt {
	pc = 0x821BC68C; continue 'dispatch;
	}
	// 821BC688: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821BC68C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821BC690: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BC694: 419A0014  beq cr6, 0x821bc6a8
	if ctx.cr[6].eq {
	pc = 0x821BC6A8; continue 'dispatch;
	}
	// 821BC698: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BC69C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821BC6A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BC6A4: 4800000C  b 0x821bc6b0
	pc = 0x821BC6B0; continue 'dispatch;
	// 821BC6A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821BC6AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821BC6B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC6B4: 4199FFB8  bgt cr6, 0x821bc66c
	if ctx.cr[6].gt {
	pc = 0x821BC66C; continue 'dispatch;
	}
	// 821BC6B8: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 821BC6BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BC6C0: 419A0040  beq cr6, 0x821bc700
	if ctx.cr[6].eq {
	pc = 0x821BC700; continue 'dispatch;
	}
	// 821BC6C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC6C8: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 821BC6CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC6D0: 41990008  bgt cr6, 0x821bc6d8
	if ctx.cr[6].gt {
	pc = 0x821BC6D8; continue 'dispatch;
	}
	// 821BC6D4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821BC6D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC6E0: 409A0020  bne cr6, 0x821bc700
	if !ctx.cr[6].eq {
	pc = 0x821BC700; continue 'dispatch;
	}
	// 821BC6E4: E96100B8  ld r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 821BC6E8: F96100B8  std r11, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u64 ) };
	// 821BC6EC: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821BC6F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC6F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC6F8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC6FC: 4800001C  b 0x821bc718
	pc = 0x821BC718; continue 'dispatch;
	// 821BC700: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821BC704: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC708: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC70C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC710: 48000008  b 0x821bc718
	pc = 0x821BC718; continue 'dispatch;
	// 821BC714: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821BC718: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC71C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC720: 419A0008  beq cr6, 0x821bc728
	if ctx.cr[6].eq {
	pc = 0x821BC728; continue 'dispatch;
	}
	// 821BC724: 9BEA0060  stb r31, 0x60(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(96 as u32), ctx.r[31].u8 ) };
	// 821BC728: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BC72C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC730: C96B9660  lfd f11, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821BC734: 4804B0BD  bl 0x822077f0
	ctx.lr = 0x821BC738;
	sub_822077F0(ctx, base);
	// 821BC738: FC015824  fdiv f0, f1, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[11].f64;
	// 821BC73C: 895D00B4  lbz r10, 0xb4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 821BC740: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC744: FF400018  frsp f26, f0
	ctx.f[26].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821BC748: 409A0130  bne cr6, 0x821bc878
	if !ctx.cr[6].eq {
	pc = 0x821BC878; continue 'dispatch;
	}
	// 821BC74C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BC750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC754: 419A0014  beq cr6, 0x821bc768
	if ctx.cr[6].eq {
	pc = 0x821BC768; continue 'dispatch;
	}
	// 821BC758: 815D0024  lwz r10, 0x24(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BC75C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BC760: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC764: 408200DC  bne 0x821bc840
	if !ctx.cr[0].eq {
	pc = 0x821BC840; continue 'dispatch;
	}
	// 821BC768: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BC76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC770: 419A0014  beq cr6, 0x821bc784
	if ctx.cr[6].eq {
	pc = 0x821BC784; continue 'dispatch;
	}
	// 821BC774: 815D0034  lwz r10, 0x34(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 821BC778: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BC77C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC780: 408200C0  bne 0x821bc840
	if !ctx.cr[0].eq {
	pc = 0x821BC840; continue 'dispatch;
	}
	// 821BC784: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC788: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BC78C: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 821BC790: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BC794: 419A0078  beq cr6, 0x821bc80c
	if ctx.cr[6].eq {
	pc = 0x821BC80C; continue 'dispatch;
	}
	// 821BC798: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BC79C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC7A0: 409A0064  bne cr6, 0x821bc804
	if !ctx.cr[6].eq {
	pc = 0x821BC804; continue 'dispatch;
	}
	// 821BC7A4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC7A8: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BC7AC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821BC7B0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC7B4: 40810050  ble 0x821bc804
	if !ctx.cr[0].gt {
	pc = 0x821BC804; continue 'dispatch;
	}
	// 821BC7B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821BC7BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC7C0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821BC7C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC7C8: 2F070019  cmpwi cr6, r7, 0x19
	ctx.cr[6].compare_i32(ctx.r[7].s32, 25, &mut ctx.xer);
	// 821BC7CC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821BC7D0: 41980008  blt cr6, 0x821bc7d8
	if ctx.cr[6].lt {
	pc = 0x821BC7D8; continue 'dispatch;
	}
	// 821BC7D4: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821BC7D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821BC7DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BC7E0: 419A0014  beq cr6, 0x821bc7f4
	if ctx.cr[6].eq {
	pc = 0x821BC7F4; continue 'dispatch;
	}
	// 821BC7E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BC7E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821BC7EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BC7F0: 4800000C  b 0x821bc7fc
	pc = 0x821BC7FC; continue 'dispatch;
	// 821BC7F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821BC7F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821BC7FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC800: 4199FFB8  bgt cr6, 0x821bc7b8
	if ctx.cr[6].gt {
	pc = 0x821BC7B8; continue 'dispatch;
	}
	// 821BC804: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC808: 48000008  b 0x821bc810
	pc = 0x821BC810; continue 'dispatch;
	// 821BC80C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821BC810: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC818: 409A0028  bne cr6, 0x821bc840
	if !ctx.cr[6].eq {
	pc = 0x821BC840; continue 'dispatch;
	}
	// 821BC81C: 897D003D  lbz r11, 0x3d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(61 as u32) ) } as u64;
	// 821BC820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC824: 419A003C  beq cr6, 0x821bc860
	if ctx.cr[6].eq {
	pc = 0x821BC860; continue 'dispatch;
	}
	// 821BC828: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC82C: 486AE03D  bl 0x8286a868
	ctx.lr = 0x821BC830;
	sub_8286A868(ctx, base);
	// 821BC830: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC834: 486AD02D  bl 0x82869860
	ctx.lr = 0x821BC838;
	sub_82869860(ctx, base);
	// 821BC838: 9AFD003D  stb r23, 0x3d(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(61 as u32), ctx.r[23].u8 ) };
	// 821BC83C: 48000024  b 0x821bc860
	pc = 0x821BC860; continue 'dispatch;
	// 821BC840: 897D003D  lbz r11, 0x3d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(61 as u32) ) } as u64;
	// 821BC844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC848: 409A0018  bne cr6, 0x821bc860
	if !ctx.cr[6].eq {
	pc = 0x821BC860; continue 'dispatch;
	}
	// 821BC84C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC850: 486AE019  bl 0x8286a868
	ctx.lr = 0x821BC854;
	sub_8286A868(ctx, base);
	// 821BC854: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC858: 486AD009  bl 0x82869860
	ctx.lr = 0x821BC85C;
	sub_82869860(ctx, base);
	// 821BC85C: 9BFD003D  stb r31, 0x3d(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(61 as u32), ctx.r[31].u8 ) };
	// 821BC860: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC864: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC868: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821BC86C: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 821BC870: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BC874: 4E800421  bctrl
	ctx.lr = 0x821BC878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BC878: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BC87C: 894B940F  lbz r10, -0x6bf1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-27633 as u32) ) } as u64;
	// 821BC880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC884: 419A0220  beq cr6, 0x821bcaa4
	if ctx.cr[6].eq {
	pc = 0x821BCAA4; continue 'dispatch;
	}
	// 821BC888: 897D007C  lbz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BC88C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC890: 409A01F0  bne cr6, 0x821bca80
	if !ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC894: 817D0068  lwz r11, 0x68(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 821BC898: 3BDD0068  addi r30, r29, 0x68
	ctx.r[30].s64 = ctx.r[29].s64 + 104;
	// 821BC89C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC8A0: 409A01E0  bne cr6, 0x821bca80
	if !ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC8A4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC8A8: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 821BC8AC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BC8B0: 5528E7FE  rlwinm r8, r9, 0x1c, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 821BC8B4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BC8B8: 419A00F4  beq cr6, 0x821bc9ac
	if ctx.cr[6].eq {
	pc = 0x821BC9AC; continue 'dispatch;
	}
	// 821BC8BC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BC8C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC8C4: 419A0024  beq cr6, 0x821bc8e8
	if ctx.cr[6].eq {
	pc = 0x821BC8E8; continue 'dispatch;
	}
	// 821BC8C8: 894A0064  lbz r10, 0x64(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BC8CC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC8D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821BC8D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821BC8D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC8DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC8E0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC8E4: 480000CC  b 0x821bc9b0
	pc = 0x821BC9B0; continue 'dispatch;
	// 821BC8E8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC8EC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BC8F0: 92E100B8  stw r23, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[23].u32 ) };
	// 821BC8F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821BC8F8: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 821BC8FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC900: 40810054  ble 0x821bc954
	if !ctx.cr[0].gt {
	pc = 0x821BC954; continue 'dispatch;
	}
	// 821BC904: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821BC908: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC90C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821BC910: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC914: 2F070064  cmpwi cr6, r7, 0x64
	ctx.cr[6].compare_i32(ctx.r[7].s32, 100, &mut ctx.xer);
	// 821BC918: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821BC91C: 41980008  blt cr6, 0x821bc924
	if ctx.cr[6].lt {
	pc = 0x821BC924; continue 'dispatch;
	}
	// 821BC920: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821BC924: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821BC928: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BC92C: 419A0014  beq cr6, 0x821bc940
	if ctx.cr[6].eq {
	pc = 0x821BC940; continue 'dispatch;
	}
	// 821BC930: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BC934: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821BC938: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BC93C: 4800000C  b 0x821bc948
	pc = 0x821BC948; continue 'dispatch;
	// 821BC940: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821BC944: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821BC948: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC94C: 4199FFB8  bgt cr6, 0x821bc904
	if ctx.cr[6].gt {
	pc = 0x821BC904; continue 'dispatch;
	}
	// 821BC950: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 821BC954: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BC958: 419A0040  beq cr6, 0x821bc998
	if ctx.cr[6].eq {
	pc = 0x821BC998; continue 'dispatch;
	}
	// 821BC95C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC960: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 821BC964: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC968: 41990008  bgt cr6, 0x821bc970
	if ctx.cr[6].gt {
	pc = 0x821BC970; continue 'dispatch;
	}
	// 821BC96C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821BC970: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC978: 409A0020  bne cr6, 0x821bc998
	if !ctx.cr[6].eq {
	pc = 0x821BC998; continue 'dispatch;
	}
	// 821BC97C: E96100B8  ld r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 821BC980: F96100B8  std r11, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u64 ) };
	// 821BC984: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821BC988: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC98C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC990: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC994: 4800001C  b 0x821bc9b0
	pc = 0x821BC9B0; continue 'dispatch;
	// 821BC998: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821BC99C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC9A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC9A4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC9A8: 48000008  b 0x821bc9b0
	pc = 0x821BC9B0; continue 'dispatch;
	// 821BC9AC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821BC9B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC9B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC9B8: 419A00C8  beq cr6, 0x821bca80
	if ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC9BC: 806A0038  lwz r3, 0x38(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 821BC9C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC9C4: 419A00BC  beq cr6, 0x821bca80
	if ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC9C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC9CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC9D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BC9D4: 4E800421  bctrl
	ctx.lr = 0x821BC9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BC9D8: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 821BC9DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BC9E0: 38696798  addi r3, r9, 0x6798
	ctx.r[3].s64 = ctx.r[9].s64 + 26520;
	// 821BC9E4: 4841A17D  bl 0x825d6b60
	ctx.lr = 0x821BC9E8;
	sub_825D6B60(ctx, base);
	// 821BC9E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BC9EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BC9F0: 419A0090  beq cr6, 0x821bca80
	if ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC9F4: 92E1009C  stw r23, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 821BC9F8: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 821BC9FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821BCA00: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 821BCA04: 480F0675  bl 0x822ad078
	ctx.lr = 0x821BCA08;
	sub_822AD078(ctx, base);
	// 821BCA08: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821BCA0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821BCA10: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821BCA14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821BCA18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BCA1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BCA20: 48AAC431  bl 0x82c68e50
	ctx.lr = 0x821BCA24;
	sub_82C68E50(ctx, base);
	// 821BCA24: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BCA28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BCA2C: 419A002C  beq cr6, 0x821bca58
	if ctx.cr[6].eq {
	pc = 0x821BCA58; continue 'dispatch;
	}
	// 821BCA30: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821BCA34: 894BEBAD  lbz r10, -0x1453(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5203 as u32) ) } as u64;
	// 821BCA38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BCA3C: 419A0044  beq cr6, 0x821bca80
	if ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BCA40: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCA44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCA48: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BCA4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BCA50: 4E800421  bctrl
	ctx.lr = 0x821BCA54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BCA54: 4800002C  b 0x821bca80
	pc = 0x821BCA80; continue 'dispatch;
	// 821BCA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BCA5C: 486AE3AD  bl 0x8286ae08
	ctx.lr = 0x821BCA60;
	sub_8286AE08(ctx, base);
	// 821BCA60: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCA64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BCA68: 419A0014  beq cr6, 0x821bca7c
	if ctx.cr[6].eq {
	pc = 0x821BCA7C; continue 'dispatch;
	}
	// 821BCA6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCA70: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCA74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BCA78: 4E800421  bctrl
	ctx.lr = 0x821BCA7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BCA7C: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 821BCA80: 897D007C  lbz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BCA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BCA88: 409A0010  bne cr6, 0x821bca98
	if !ctx.cr[6].eq {
	pc = 0x821BCA98; continue 'dispatch;
	}
	// 821BCA8C: 897D003C  lbz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 821BCA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BCA94: 419A0010  beq cr6, 0x821bcaa4
	if ctx.cr[6].eq {
	pc = 0x821BCAA4; continue 'dispatch;
	}
	// 821BCA98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BCA9C: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821BCAA0: 480F3B79  bl 0x822b0618
	ctx.lr = 0x821BCAA4;
	sub_822B0618(ctx, base);
	// 821BCAA4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821BCAA8: 894BEBAE  lbz r10, -0x1452(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5202 as u32) ) } as u64;
	// 821BCAAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BCAB0: 419A05E0  beq cr6, 0x821bd090
	if ctx.cr[6].eq {
	pc = 0x821BD090; continue 'dispatch;
	}
	// 821BCAB4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BCAB8: 92E1009C  stw r23, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 821BCABC: 3B0B7088  addi r24, r11, 0x7088
	ctx.r[24].s64 = ctx.r[11].s64 + 28808;
	// 821BCAC0: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 821BCAC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BCAC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCACC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BCAD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BCAD4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BCAD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCADC: 4082FFE8  bne 0x821bcac4
	if !ctx.cr[0].eq {
	pc = 0x821BCAC4; continue 'dispatch;
	}
	// 821BCAE0: 83FD0030  lwz r31, 0x30(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BCAE4: 3B3D002C  addi r25, r29, 0x2c
	ctx.r[25].s64 = ctx.r[29].s64 + 44;
	// 821BCAE8: 80FD0034  lwz r7, 0x34(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 821BCAEC: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821BCAF0: 40990008  ble cr6, 0x821bcaf8
	if !ctx.cr[6].gt {
	pc = 0x821BCAF8; continue 'dispatch;
	}
	// 821BCAF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCAF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BCAFC: 3F80820E  lis r28, -0x7df2
	ctx.r[28].s64 = -2113011712;
	// 821BCB00: 394BB480  addi r10, r11, -0x4b80
	ctx.r[10].s64 = ctx.r[11].s64 + -19328;
	// 821BCB04: 3F60820B  lis r27, -0x7df5
	ctx.r[27].s64 = -2113208320;
	// 821BCB08: 38DCFDD8  addi r6, r28, -0x228
	ctx.r[6].s64 = ctx.r[28].s64 + -552;
	// 821BCB0C: 38BBF298  addi r5, r27, -0xd68
	ctx.r[5].s64 = ctx.r[27].s64 + -3432;
	// 821BCB10: C36BB480  lfs f27, -0x4b80(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19328 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821BCB14: 3FA0820B  lis r29, -0x7df5
	ctx.r[29].s64 = -2113208320;
	// 821BCB18: 90C100A4  stw r6, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	// 821BCB1C: C3AA01D0  lfs f29, 0x1d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(464 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821BCB20: 3F40820C  lis r26, -0x7df4
	ctx.r[26].s64 = -2113142784;
	// 821BCB24: C3CAE004  lfs f30, -0x1ffc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821BCB28: 90A100A0  stw r5, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u32 ) };
	// 821BCB2C: C38ADE4C  lfs f28, -0x21b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8628 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821BCB30: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 821BCB34: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 821BCB38: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 821BCB3C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 821BCB40: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 821BCB44: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 821BCB48: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 821BCB4C: 3FC0820E  lis r30, -0x7df2
	ctx.r[30].s64 = -2113011712;
	// 821BCB50: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 821BCB54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BCB58: 39DDF290  addi r14, r29, -0xd70
	ctx.r[14].s64 = ctx.r[29].s64 + -3440;
	// 821BCB5C: 3B9AB9F4  addi r28, r26, -0x460c
	ctx.r[28].s64 = ctx.r[26].s64 + -17932;
	// 821BCB60: 3A89FFDF  addi r20, r9, -0x21
	ctx.r[20].s64 = ctx.r[9].s64 + -33;
	// 821BCB64: 3AC8FE20  addi r22, r8, -0x1e0
	ctx.r[22].s64 = ctx.r[8].s64 + -480;
	// 821BCB68: 3A47FE18  addi r18, r7, -0x1e8
	ctx.r[18].s64 = ctx.r[7].s64 + -488;
	// 821BCB6C: 3AA6FDEC  addi r21, r6, -0x214
	ctx.r[21].s64 = ctx.r[6].s64 + -532;
	// 821BCB70: 3A25FDE8  addi r17, r5, -0x218
	ctx.r[17].s64 = ctx.r[5].s64 + -536;
	// 821BCB74: 3A04FDE4  addi r16, r4, -0x21c
	ctx.r[16].s64 = ctx.r[4].s64 + -540;
	// 821BCB78: 3A63FDE0  addi r19, r3, -0x220
	ctx.r[19].s64 = ctx.r[3].s64 + -544;
	// 821BCB7C: 39FEFDDC  addi r15, r30, -0x224
	ctx.r[15].s64 = ctx.r[30].s64 + -548;
	// 821BCB80: 3B6AFDD4  addi r27, r10, -0x22c
	ctx.r[27].s64 = ctx.r[10].s64 + -556;
	// 821BCB84: 3BAB0B70  addi r29, r11, 0xb70
	ctx.r[29].s64 = ctx.r[11].s64 + 2928;
	// 821BCB88: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821BCB8C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCB90: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BCB94: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCB98: 40990008  ble cr6, 0x821bcba0
	if !ctx.cr[6].gt {
	pc = 0x821BCBA0; continue 'dispatch;
	}
	// 821BCB9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCBA0: 7F19C840  cmplw cr6, r25, r25
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[25].u32, &mut ctx.xer);
	// 821BCBA4: 419A0008  beq cr6, 0x821bcbac
	if ctx.cr[6].eq {
	pc = 0x821BCBAC; continue 'dispatch;
	}
	// 821BCBA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCBAC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCBB0: 419A04B8  beq cr6, 0x821bd068
	if ctx.cr[6].eq {
	pc = 0x821BD068; continue 'dispatch;
	}
	// 821BCBB4: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821BCBB8: 93410090  stw r26, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[26].u32 ) };
	// 821BCBBC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821BCBC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCBC4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821BCBC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BCBCC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BCBD0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCBD4: 4082FFE8  bne 0x821bcbbc
	if !ctx.cr[0].eq {
	pc = 0x821BCBBC; continue 'dispatch;
	}
	// 821BCBD8: 81190008  lwz r8, 8(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCBDC: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BCBE0: 41980008  blt cr6, 0x821bcbe8
	if ctx.cr[6].lt {
	pc = 0x821BCBE8; continue 'dispatch;
	}
	// 821BCBE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCBE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCBEC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCBF0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCBF4: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BCBF8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BCBFC: 4E800421  bctrl
	ctx.lr = 0x821BCC00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BCC00: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821BCC04: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 821BCC08: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 821BCC0C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCC10: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 821BCC14: C80100C0  lfd f0, 0xc0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 821BCC18: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821BCC1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BCC20: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821BCC24: ED6C0772  fmuls f11, f12, f29
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 821BCC28: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 821BCC2C: 40990008  ble cr6, 0x821bcc34
	if !ctx.cr[6].gt {
	pc = 0x821BCC34; continue 'dispatch;
	}
	// 821BCC30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821BCC34: 4801DD8D  bl 0x821da9c0
	ctx.lr = 0x821BCC38;
	sub_821DA9C0(ctx, base);
	// 821BCC38: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821BCC3C: 2F1E000A  cmpwi cr6, r30, 0xa
	ctx.cr[6].compare_i32(ctx.r[30].s32, 10, &mut ctx.xer);
	// 821BCC40: 4198FFC8  blt cr6, 0x821bcc08
	if ctx.cr[6].lt {
	pc = 0x821BCC08; continue 'dispatch;
	}
	// 821BCC44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BCC48: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCC4C: 4801DD75  bl 0x821da9c0
	ctx.lr = 0x821BCC50;
	sub_821DA9C0(ctx, base);
	// 821BCC50: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCC54: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCC58: 41980008  blt cr6, 0x821bcc60
	if ctx.cr[6].lt {
	pc = 0x821BCC60; continue 'dispatch;
	}
	// 821BCC5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCC60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCC64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCC68: 808100A0  lwz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 821BCC6C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCC70: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCC74: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821BCC78: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCC7C: 409A0008  bne cr6, 0x821bcc84
	if !ctx.cr[6].eq {
	pc = 0x821BCC84; continue 'dispatch;
	}
	// 821BCC80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BCC84: 4801DD3D  bl 0x821da9c0
	ctx.lr = 0x821BCC88;
	sub_821DA9C0(ctx, base);
	// 821BCC88: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCC8C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCC90: 41980008  blt cr6, 0x821bcc98
	if ctx.cr[6].lt {
	pc = 0x821BCC98; continue 'dispatch;
	}
	// 821BCC94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCC98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCC9C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCCA0: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 821BCCA4: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCCA8: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCCAC: 552807BC  rlwinm r8, r9, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCCB0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCCB4: 409A0008  bne cr6, 0x821bccbc
	if !ctx.cr[6].eq {
	pc = 0x821BCCBC; continue 'dispatch;
	}
	// 821BCCB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BCCBC: 4801DD05  bl 0x821da9c0
	ctx.lr = 0x821BCCC0;
	sub_821DA9C0(ctx, base);
	// 821BCCC0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCCC4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCCC8: 41980008  blt cr6, 0x821bccd0
	if ctx.cr[6].lt {
	pc = 0x821BCCD0; continue 'dispatch;
	}
	// 821BCCCC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCCD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCCD4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCCD8: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 821BCCDC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCCE0: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCCE4: 5528077A  rlwinm r8, r9, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCCE8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCCEC: 409A0008  bne cr6, 0x821bccf4
	if !ctx.cr[6].eq {
	pc = 0x821BCCF4; continue 'dispatch;
	}
	// 821BCCF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BCCF4: 4801DCCD  bl 0x821da9c0
	ctx.lr = 0x821BCCF8;
	sub_821DA9C0(ctx, base);
	// 821BCCF8: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCCFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCD00: 41980008  blt cr6, 0x821bcd08
	if ctx.cr[6].lt {
	pc = 0x821BCD08; continue 'dispatch;
	}
	// 821BCD04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCD08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCD0C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCD10: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 821BCD14: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCD18: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCD1C: 55280738  rlwinm r8, r9, 0, 0x1c, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCD20: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCD24: 409A0008  bne cr6, 0x821bcd2c
	if !ctx.cr[6].eq {
	pc = 0x821BCD2C; continue 'dispatch;
	}
	// 821BCD28: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 821BCD2C: 4801DC95  bl 0x821da9c0
	ctx.lr = 0x821BCD30;
	sub_821DA9C0(ctx, base);
	// 821BCD30: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCD34: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCD38: 41980008  blt cr6, 0x821bcd40
	if ctx.cr[6].lt {
	pc = 0x821BCD40; continue 'dispatch;
	}
	// 821BCD3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCD40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCD44: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCD48: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 821BCD4C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCD50: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCD54: 552806F6  rlwinm r8, r9, 0, 0x1b, 0x1b
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCD58: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCD5C: 409A0008  bne cr6, 0x821bcd64
	if !ctx.cr[6].eq {
	pc = 0x821BCD64; continue 'dispatch;
	}
	// 821BCD60: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 821BCD64: 4801DC5D  bl 0x821da9c0
	ctx.lr = 0x821BCD68;
	sub_821DA9C0(ctx, base);
	// 821BCD68: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCD6C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCD70: 41980008  blt cr6, 0x821bcd78
	if ctx.cr[6].lt {
	pc = 0x821BCD78; continue 'dispatch;
	}
	// 821BCD74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCD78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCD7C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCD80: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821BCD84: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCD88: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCD8C: 552806B4  rlwinm r8, r9, 0, 0x1a, 0x1a
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCD90: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCD94: 409A0008  bne cr6, 0x821bcd9c
	if !ctx.cr[6].eq {
	pc = 0x821BCD9C; continue 'dispatch;
	}
	// 821BCD98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BCD9C: 4801DC25  bl 0x821da9c0
	ctx.lr = 0x821BCDA0;
	sub_821DA9C0(ctx, base);
	// 821BCDA0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCDA4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCDA8: 41980008  blt cr6, 0x821bcdb0
	if ctx.cr[6].lt {
	pc = 0x821BCDB0; continue 'dispatch;
	}
	// 821BCDAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCDB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCDB4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCDB8: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BCDBC: 4811688D  bl 0x822d3648
	ctx.lr = 0x821BCDC0;
	sub_822D3648(ctx, base);
	// 821BCDC0: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCDC4: FC600890  fmr f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[1].f64;
	// 821BCDC8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BCDCC: 41980008  blt cr6, 0x821bcdd4
	if ctx.cr[6].lt {
	pc = 0x821BCDD4; continue 'dispatch;
	}
	// 821BCDD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCDD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCDD8: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCDDC: C04A000C  lfs f2, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821BCDE0: FF02F000  fcmpu cr6, f2, f30
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[30].f64);
	// 821BCDE4: 409A0014  bne cr6, 0x821bcdf8
	if !ctx.cr[6].eq {
	pc = 0x821BCDF8; continue 'dispatch;
	}
	// 821BCDE8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCDEC: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BCDF0: 48116859  bl 0x822d3648
	ctx.lr = 0x821BCDF4;
	sub_822D3648(ctx, base);
	// 821BCDF4: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 821BCDF8: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCDFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCE00: 41980008  blt cr6, 0x821bce08
	if ctx.cr[6].lt {
	pc = 0x821BCE08; continue 'dispatch;
	}
	// 821BCE04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCE08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCE0C: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 821BCE10: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCE14: C0270020  lfs f1, 0x20(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BCE18: 93410094  stw r26, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	// 821BCE1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BCE20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCE24: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BCE28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BCE2C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BCE30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCE34: 4082FFE8  bne 0x821bce1c
	if !ctx.cr[0].eq {
	pc = 0x821BCE1C; continue 'dispatch;
	}
	// 821BCE38: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 821BCE3C: D8810040  stfd f4, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.f[4].u64 ) };
	// 821BCE40: D8610038  stfd f3, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[3].u64 ) };
	// 821BCE44: E9210040  ld r9, 0x40(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(64 as u32) ) };
	// 821BCE48: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 821BCE4C: D8410030  stfd f2, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[2].u64 ) };
	// 821BCE50: D8210028  stfd f1, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[1].u64 ) };
	// 821BCE54: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 821BCE58: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821BCE5C: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 821BCE60: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 821BCE64: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 821BCE68: 48026FE9  bl 0x821e3e50
	ctx.lr = 0x821BCE6C;
	sub_821E3E50(ctx, base);
	// 821BCE6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BCE70: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCE74: 4802F985  bl 0x821ec7f8
	ctx.lr = 0x821BCE78;
	sub_821EC7F8(ctx, base);
	// 821BCE78: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 821BCE7C: 480098ED  bl 0x821c6768
	ctx.lr = 0x821BCE80;
	sub_821C6768(ctx, base);
	// 821BCE80: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821BCE84: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 821BCE88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCE8C: 7CC02028  lwarx r6, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 821BCE90: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 821BCE94: 7CC0212D  stwcx. r6, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BCE98: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCE9C: 4082FFE8  bne 0x821bce84
	if !ctx.cr[0].eq {
	pc = 0x821BCE84; continue 'dispatch;
	}
	// 821BCEA0: 80790008  lwz r3, 8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCEA4: 93410094  stw r26, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	// 821BCEA8: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821BCEAC: 41980008  blt cr6, 0x821bceb4
	if ctx.cr[6].lt {
	pc = 0x821BCEB4; continue 'dispatch;
	}
	// 821BCEB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BCEB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCEB8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BCEBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BCEC0: 409A0010  bne cr6, 0x821bced0
	if !ctx.cr[6].eq {
	pc = 0x821BCED0; continue 'dispatch;
	}
	// 821BCEC4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 821BCEC8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCECC: 4801DAF5  bl 0x821da9c0
	ctx.lr = 0x821BCED0;
	sub_821DA9C0(ctx, base);
	// 821BCED0: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 821BCED4: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 821BCED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BCEDC: 419A0008  beq cr6, 0x821bcee4
	if ctx.cr[6].eq {
	pc = 0x821BCEE4; continue 'dispatch;
	}
	// 821BCEE0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCEE4: 7AEB0020  clrldi r11, r23, 0x20
	ctx.r[11].u64 = ctx.r[23].u64 & 0x00000000FFFFFFFFu64;
	// 821BCEE8: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 821BCEEC: D3C100B0  stfs f30, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821BCEF0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821BCEF4: F96100C8  std r11, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u64 ) };
	// 821BCEF8: C80100C8  lfd f0, 0xc8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 821BCEFC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821BCF00: D3C100A8  stfs f30, 0xa8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821BCF04: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BCF08: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821BCF0C: D3C100AC  stfs f30, 0xac(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821BCF10: 8089007C  lwz r4, 0x7c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BCF14: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCF18: ED6CDF3A  fmadds f11, f12, f28, f27
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[28].f64 + ctx.f[27].f64) as f32) as f64);
	// 821BCF1C: D16100B8  stfs f11, 0xb8(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821BCF20: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 821BCF24: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821BCF28: 4E800421  bctrl
	ctx.lr = 0x821BCF2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BCF2C: 38C100A8  addi r6, r1, 0xa8
	ctx.r[6].s64 = ctx.r[1].s64 + 168;
	// 821BCF30: 38A100AC  addi r5, r1, 0xac
	ctx.r[5].s64 = ctx.r[1].s64 + 172;
	// 821BCF34: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821BCF38: 396100B8  addi r11, r1, 0xb8
	ctx.r[11].s64 = ctx.r[1].s64 + 184;
	// 821BCF3C: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BD0C8 size=412
    let mut pc: u32 = 0x821BD0C8;
    'dispatch: loop {
        match pc {
            0x821BD0C8 => {
    //   block [0x821BD0C8..0x821BD264)
	// 821BD0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD0CC: 48AEC331  bl 0x82ca93fc
	ctx.lr = 0x821BD0D0;
	sub_82CA93D0(ctx, base);
	// 821BD0D0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821BD0D4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD0D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821BD0DC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821BD0E0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821BD0E4: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 821BD0E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821BD0EC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821BD0F0: 48037391  bl 0x821f4480
	ctx.lr = 0x821BD0F4;
	sub_821F4480(ctx, base);
	// 821BD0F4: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BD0F8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821BD0FC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BD100: 419A0154  beq cr6, 0x821bd254
	if ctx.cr[6].eq {
	pc = 0x821BD254; continue 'dispatch;
	}
	// 821BD104: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BD108: 3D207FFF  lis r9, 0x7fff
	ctx.r[9].s64 = 2147418112;
	// 821BD10C: 3B2000D0  li r25, 0xd0
	ctx.r[25].s64 = 208;
	// 821BD110: 613BFFFF  ori r27, r9, 0xffff
	ctx.r[27].u64 = ctx.r[9].u64 | 65535;
	// 821BD114: C3EB9A80  lfs f31, -0x6580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821BD118: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BD11C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821BD120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD124: 419A0018  beq cr6, 0x821bd13c
	if ctx.cr[6].eq {
	pc = 0x821BD13C; continue 'dispatch;
	}
	// 821BD128: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BD12C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BD130: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821BD134: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BD138: 41980008  blt cr6, 0x821bd140
	if ctx.cr[6].lt {
	pc = 0x821BD140; continue 'dispatch;
	}
	// 821BD13C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BD140: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BD144: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821BD148: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BD14C: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BD150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BD154: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD158: 81090068  lwz r8, 0x68(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(104 as u32) ) } as u64;
	// 821BD15C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821BD160: 4E800421  bctrl
	ctx.lr = 0x821BD164;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BD164: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BD168: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BD16C: 419A00D0  beq cr6, 0x821bd23c
	if ctx.cr[6].eq {
	pc = 0x821BD23C; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD268 size=488
    let mut pc: u32 = 0x821BD268;
    'dispatch: loop {
        match pc {
            0x821BD268 => {
    //   block [0x821BD268..0x821BD450)
	// 821BD268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD26C: 48AEC199  bl 0x82ca9404
	ctx.lr = 0x821BD270;
	sub_82CA93D0(ctx, base);
	// 821BD270: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD274: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821BD278: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821BD27C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821BD280: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD284: 808BE50C  lwz r4, -0x1af4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6900 as u32) ) } as u64;
	// 821BD288: 480C7659  bl 0x822848e0
	ctx.lr = 0x821BD28C;
	sub_822848E0(ctx, base);
	// 821BD28C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BD290: 419A0010  beq cr6, 0x821bd2a0
	if ctx.cr[6].eq {
	pc = 0x821BD2A0; continue 'dispatch;
	}
	// 821BD294: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD298: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BD29C: 4800000C  b 0x821bd2a8
	pc = 0x821BD2A8; continue 'dispatch;
	// 821BD2A0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BD2A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BD2A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD2AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD2B0: 419A0198  beq cr6, 0x821bd448
	if ctx.cr[6].eq {
	pc = 0x821BD448; continue 'dispatch;
	}
	// 821BD2B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BD2B8: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD2BC: 3BCB0CA0  addi r30, r11, 0xca0
	ctx.r[30].s64 = ctx.r[11].s64 + 3232;
	// 821BD2C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821BD2C4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821BD2C8: 419A0008  beq cr6, 0x821bd2d0
	if ctx.cr[6].eq {
	pc = 0x821BD2D0; continue 'dispatch;
	}
	// 821BD2CC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821BD2D0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821BD2D4: 814AB2AC  lwz r10, -0x4d54(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19796 as u32) ) } as u64;
	// 821BD2D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD2DC: 409A0034  bne cr6, 0x821bd310
	if !ctx.cr[6].eq {
	pc = 0x821BD310; continue 'dispatch;
	}
	// 821BD2E0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821BD2E4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD2E8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD2EC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD2F0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821BD2F4: 419A0014  beq cr6, 0x821bd308
	if ctx.cr[6].eq {
	pc = 0x821BD308; continue 'dispatch;
	}
	// 821BD2F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BD2FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BD300: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD304: 419AFFE0  beq cr6, 0x821bd2e4
	if ctx.cr[6].eq {
	pc = 0x821BD2E4; continue 'dispatch;
	}
	// 821BD308: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821BD30C: 48000014  b 0x821bd320
	pc = 0x821BD320; continue 'dispatch;
	// 821BD310: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821BD314: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD318: 480B04E1  bl 0x8226d7f8
	ctx.lr = 0x821BD31C;
	sub_8226D7F8(ctx, base);
	// 821BD31C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821BD320: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BD324: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD32C: 409A0078  bne cr6, 0x821bd3a4
	if !ctx.cr[6].eq {
	pc = 0x821BD3A4; continue 'dispatch;
	}
	// 821BD330: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821BD334: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821BD338: 419A0008  beq cr6, 0x821bd340
	if ctx.cr[6].eq {
	pc = 0x821BD340; continue 'dispatch;
	}
	// 821BD33C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821BD340: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821BD344: 814AB2F0  lwz r10, -0x4d10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19728 as u32) ) } as u64;
	// 821BD348: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD34C: 409A0034  bne cr6, 0x821bd380
	if !ctx.cr[6].eq {
	pc = 0x821BD380; continue 'dispatch;
	}
	// 821BD350: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821BD354: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD358: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD35C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD360: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821BD364: 419A0014  beq cr6, 0x821bd378
	if ctx.cr[6].eq {
	pc = 0x821BD378; continue 'dispatch;
	}
	// 821BD368: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BD36C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BD370: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD374: 419AFFE0  beq cr6, 0x821bd354
	if ctx.cr[6].eq {
	pc = 0x821BD354; continue 'dispatch;
	}
	// 821BD378: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821BD37C: 48000014  b 0x821bd390
	pc = 0x821BD390; continue 'dispatch;
	// 821BD380: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821BD384: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD388: 480B0471  bl 0x8226d7f8
	ctx.lr = 0x821BD38C;
	sub_8226D7F8(ctx, base);
	// 821BD38C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821BD390: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BD394: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD39C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BD3A0: 419A0008  beq cr6, 0x821bd3a8
	if ctx.cr[6].eq {
	pc = 0x821BD3A8; continue 'dispatch;
	}
	// 821BD3A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BD3A8: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD3AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821BD3B0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821BD3B4: 419A0008  beq cr6, 0x821bd3bc
	if ctx.cr[6].eq {
	pc = 0x821BD3BC; continue 'dispatch;
	}
	// 821BD3B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821BD3BC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821BD3C0: 814AB2F4  lwz r10, -0x4d0c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19724 as u32) ) } as u64;
	// 821BD3C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD3C8: 409A0034  bne cr6, 0x821bd3fc
	if !ctx.cr[6].eq {
	pc = 0x821BD3FC; continue 'dispatch;
	}
	// 821BD3CC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821BD3D0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD3D4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD3D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD3DC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821BD3E0: 419A0014  beq cr6, 0x821bd3f4
	if ctx.cr[6].eq {
	pc = 0x821BD3F4; continue 'dispatch;
	}
	// 821BD3E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BD3E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BD3EC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD3F0: 419AFFE0  beq cr6, 0x821bd3d0
	if ctx.cr[6].eq {
	pc = 0x821BD3D0; continue 'dispatch;
	}
	// 821BD3F4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821BD3F8: 48000014  b 0x821bd40c
	pc = 0x821BD40C; continue 'dispatch;
	// 821BD3FC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821BD400: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD404: 480B03F5  bl 0x8226d7f8
	ctx.lr = 0x821BD408;
	sub_8226D7F8(ctx, base);
	// 821BD408: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821BD40C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BD410: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD418: 419A000C  beq cr6, 0x821bd424
	if ctx.cr[6].eq {
	pc = 0x821BD424; continue 'dispatch;
	}
	// 821BD41C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821BD420: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 821BD424: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821BD428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD42C: 419A001C  beq cr6, 0x821bd448
	if ctx.cr[6].eq {
	pc = 0x821BD448; continue 'dispatch;
	}
	// 821BD430: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BD434: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821BD438: 389B007C  addi r4, r27, 0x7c
	ctx.r[4].s64 = ctx.r[27].s64 + 124;
	// 821BD43C: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821BD440: 806B002C  lwz r3, 0x2c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BD444: 480F6135  bl 0x822b3578
	ctx.lr = 0x821BD448;
	sub_822B3578(ctx, base);
	// 821BD448: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BD44C: 48AEC008  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD450 size=116
    let mut pc: u32 = 0x821BD450;
    'dispatch: loop {
        match pc {
            0x821BD450 => {
    //   block [0x821BD450..0x821BD4C4)
	// 821BD450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BD458: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BD45C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BD460: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD464: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BD468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BD46C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821BD470: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821BD474: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BD478: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BD47C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD480: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BD484: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD488: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BD48C: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 821BD490: 4E800421  bctrl
	ctx.lr = 0x821BD494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BD494: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD498: 80BF0038  lwz r5, 0x38(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821BD49C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BD4A0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BD4A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BD4A8: 4E800421  bctrl
	ctx.lr = 0x821BD4AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BD4AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BD4B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BD4B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BD4B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BD4BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BD4C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD4C8 size=164
    let mut pc: u32 = 0x821BD4C8;
    'dispatch: loop {
        match pc {
            0x821BD4C8 => {
    //   block [0x821BD4C8..0x821BD56C)
	// 821BD4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD4CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BD4D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BD4D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BD4D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD4DC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821BD4E0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821BD4E4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 821BD4E8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821BD4EC: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 821BD4F0: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 821BD4F4: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BD4F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821BD4FC: 4805C3BD  bl 0x822198b8
	ctx.lr = 0x821BD500;
	sub_822198B8(ctx, base);
	// 821BD500: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821BD504: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BD508: 93E30034  stw r31, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 821BD50C: 390A1638  addi r8, r10, 0x1638
	ctx.r[8].s64 = ctx.r[10].s64 + 5688;
	// 821BD510: 93C30038  stw r30, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 821BD514: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 821BD518: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BD51C: 80FF0128  lwz r7, 0x128(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 821BD520: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821BD524: 40990030  ble cr6, 0x821bd554
	if !ctx.cr[6].gt {
	pc = 0x821BD554; continue 'dispatch;
	}
	// 821BD528: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD52C: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 821BD530: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BD534: 81690D50  lwz r11, 0xd50(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3408 as u32) ) } as u64;
	// 821BD538: 810B004C  lwz r8, 0x4c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BD53C: 80EB0048  lwz r7, 0x48(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BD540: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 821BD544: 7CA653D7  divw. r5, r6, r10
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821BD548: 4182000C  beq 0x821bd554
	if ctx.cr[0].eq {
	pc = 0x821BD554; continue 'dispatch;
	}
	// 821BD54C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821BD550: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821BD554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BD558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BD55C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BD560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BD564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BD568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BD570 size=240
    let mut pc: u32 = 0x821BD570;
    'dispatch: loop {
        match pc {
            0x821BD570 => {
    //   block [0x821BD570..0x821BD660)
	// 821BD570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD574: 48AEBE8D  bl 0x82ca9400
	ctx.lr = 0x821BD578;
	sub_82CA93D0(ctx, base);
	// 821BD578: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD57C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BD580: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821BD584: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821BD588: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD58C: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BD590: 4804B581  bl 0x82208b10
	ctx.lr = 0x821BD594;
	sub_82208B10(ctx, base);
	// 821BD594: 3F80820A  lis r28, -0x7df6
	ctx.r[28].s64 = -2113273856;
	// 821BD598: 38600015  li r3, 0x15
	ctx.r[3].s64 = 21;
	// 821BD59C: 3B7C9490  addi r27, r28, -0x6b70
	ctx.r[27].s64 = ctx.r[28].s64 + -27504;
	// 821BD5A0: C03B1FF0  lfs f1, 0x1ff0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8176 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BD5A4: 4802B6D5  bl 0x821e8c78
	ctx.lr = 0x821BD5A8;
	sub_821E8C78(ctx, base);
	// 821BD5A8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821BD5AC: C03F001C  lfs f1, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BD5B0: 4802B6C9  bl 0x821e8c78
	ctx.lr = 0x821BD5B4;
	sub_821E8C78(ctx, base);
	// 821BD5B4: 386000B2  li r3, 0xb2
	ctx.r[3].s64 = 178;
	// 821BD5B8: C03F0020  lfs f1, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BD5BC: 4802B6BD  bl 0x821e8c78
	ctx.lr = 0x821BD5C0;
	sub_821E8C78(ctx, base);
	// 821BD5C0: 38600019  li r3, 0x19
	ctx.r[3].s64 = 25;
	// 821BD5C4: E89F0014  ld r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	// 821BD5C8: 48048351  bl 0x82205918
	ctx.lr = 0x821BD5CC;
	sub_82205918(ctx, base);
	// 821BD5CC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821BD5D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821BD5D4: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BD5D8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821BD5DC: 3D20834C  lis r9, -0x7cb4
	ctx.r[9].s64 = -2092171264;
	// 821BD5E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821BD5E4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821BD5E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821BD5EC: 3B49DED4  addi r26, r9, -0x212c
	ctx.r[26].s64 = ctx.r[9].s64 + -8492;
	// 821BD5F0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821BD5F4: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821BD5F8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821BD5FC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821BD600: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD604: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD608: 80AB0870  lwz r5, 0x870(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2160 as u32) ) } as u64;
	// 821BD60C: 480AADF5  bl 0x82268400
	ctx.lr = 0x821BD610;
	sub_82268400(ctx, base);
	// 821BD610: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD614: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821BD618: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BD61C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821BD620: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD624: 80AB0054  lwz r5, 0x54(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 821BD628: 480AADD9  bl 0x82268400
	ctx.lr = 0x821BD62C;
	sub_82268400(ctx, base);
	// 821BD62C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821BD630: C01BFFF4  lfs f0, -0xc(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BD634: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821BD638: C1BC9490  lfs f13, -0x6b70(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821BD63C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BD640: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821BD644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BD648: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821BD64C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821BD650: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821BD654: 4802F97D  bl 0x821ecfd0
	ctx.lr = 0x821BD658;
	sub_821ECFD0(ctx, base);
	// 821BD658: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BD65C: 48AEBDF4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD660 size=312
    let mut pc: u32 = 0x821BD660;
    'dispatch: loop {
        match pc {
            0x821BD660 => {
    //   block [0x821BD660..0x821BD798)
	// 821BD660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD664: 48AEBDA9  bl 0x82ca940c
	ctx.lr = 0x821BD668;
	sub_82CA93D0(ctx, base);
	// 821BD668: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD66C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BD670: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BD674: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821BD678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD680: 419A0010  beq cr6, 0x821bd690
	if ctx.cr[6].eq {
	pc = 0x821BD690; continue 'dispatch;
	}
	// 821BD684: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD688: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BD68C: 409A0024  bne cr6, 0x821bd6b0
	if !ctx.cr[6].eq {
	pc = 0x821BD6B0; continue 'dispatch;
	}
	// 821BD690: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BD694: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821BD698: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 821BD69C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD6A0: 4806F831  bl 0x8222ced0
	ctx.lr = 0x821BD6A4;
	sub_8222CED0(ctx, base);
	// 821BD6A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD6A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821BD6AC: 48AEBDB0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821BD6B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BD6B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BD6B8: 388B0C08  addi r4, r11, 0xc08
	ctx.r[4].s64 = ctx.r[11].s64 + 3080;
	// 821BD6BC: 4802908D  bl 0x821e6748
	ctx.lr = 0x821BD6C0;
	sub_821E6748(ctx, base);
	// 821BD6C0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821BD6C4: 409800BC  bge cr6, 0x821bd780
	if !ctx.cr[6].lt {
	pc = 0x821BD780; continue 'dispatch;
	}
	// 821BD6C8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821BD6CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD6D0: 392AFFDF  addi r9, r10, -0x21
	ctx.r[9].s64 = ctx.r[10].s64 + -33;
	// 821BD6D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD6D8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821BD6DC: 419A0008  beq cr6, 0x821bd6e4
	if ctx.cr[6].eq {
	pc = 0x821BD6E4; continue 'dispatch;
	}
	// 821BD6E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD6E4: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD6E8: 2B0A002E  cmplwi cr6, r10, 0x2e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 46 as u32, &mut ctx.xer);
	// 821BD6EC: 419A0094  beq cr6, 0x821bd780
	if ctx.cr[6].eq {
	pc = 0x821BD780; continue 'dispatch;
	}
	// 821BD6F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD6F4: 409A000C  bne cr6, 0x821bd700
	if !ctx.cr[6].eq {
	pc = 0x821BD700; continue 'dispatch;
	}
	// 821BD6F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821BD6FC: 48000008  b 0x821bd704
	pc = 0x821BD704; continue 'dispatch;
	// 821BD700: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD704: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD708: 2B0B005C  cmplwi cr6, r11, 0x5c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 92 as u32, &mut ctx.xer);
	// 821BD70C: 419A0074  beq cr6, 0x821bd780
	if ctx.cr[6].eq {
	pc = 0x821BD780; continue 'dispatch;
	}
	// 821BD710: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BD714: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD718: 48032B29  bl 0x821f0240
	ctx.lr = 0x821BD71C;
	sub_821F0240(ctx, base);
	// 821BD71C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BD720: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD724: 419A0030  beq cr6, 0x821bd754
	if ctx.cr[6].eq {
	pc = 0x821BD754; continue 'dispatch;
	}
	// 821BD728: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD72C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BD730: 40990024  ble cr6, 0x821bd754
	if !ctx.cr[6].gt {
	pc = 0x821BD754; continue 'dispatch;
	}
	// 821BD734: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD738: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BD73C: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 821BD740: 2B0A005C  cmplwi cr6, r10, 0x5c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 92 as u32, &mut ctx.xer);
	// 821BD744: 419A0010  beq cr6, 0x821bd754
	if ctx.cr[6].eq {
	pc = 0x821BD754; continue 'dispatch;
	}
	// 821BD748: 3880005C  li r4, 0x5c
	ctx.r[4].s64 = 92;
	// 821BD74C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD750: 4BFD9B21  bl 0x82197270
	ctx.lr = 0x821BD754;
	sub_82197270(ctx, base);
	// 821BD754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BD758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD75C: 4802F09D  bl 0x821ec7f8
	ctx.lr = 0x821BD760;
	sub_821EC7F8(ctx, base);
	// 821BD760: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BD764: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD768: 48032AD9  bl 0x821f0240
	ctx.lr = 0x821BD76C;
	sub_821F0240(ctx, base);
	// 821BD76C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD770: 48057669  bl 0x82214dd8
	ctx.lr = 0x821BD774;
	sub_82214DD8(ctx, base);
	// 821BD774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD778: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821BD77C: 48AEBCE0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821BD780: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BD784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD788: 48032AB9  bl 0x821f0240
	ctx.lr = 0x821BD78C;
	sub_821F0240(ctx, base);
	// 821BD78C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD790: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821BD794: 48AEBCC8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD798 size=320
    let mut pc: u32 = 0x821BD798;
    'dispatch: loop {
        match pc {
            0x821BD798 => {
    //   block [0x821BD798..0x821BD8D8)
	// 821BD798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD79C: 48AEBC71  bl 0x82ca940c
	ctx.lr = 0x821BD7A0;
	sub_82CA93D0(ctx, base);
	// 821BD7A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD7A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821BD7A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821BD7AC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821BD7B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BD7B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BD7B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821BD7BC: 48032A85  bl 0x821f0240
	ctx.lr = 0x821BD7C0;
	sub_821F0240(ctx, base);
	// 821BD7C0: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BD7C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BD7C8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821BD7CC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821BD7D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821BD7D4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821BD7D8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821BD7DC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BD7E0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BD7E4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821BD7E8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821BD7EC: 48221A85  bl 0x823df270
	ctx.lr = 0x821BD7F0;
	sub_823DF270(ctx, base);
	// 821BD7F0: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BD7F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821BD7F8: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BD7FC: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BD800: 419A001C  beq cr6, 0x821bd81c
	if ctx.cr[6].eq {
	pc = 0x821BD81C; continue 'dispatch;
	}
	// 821BD804: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 821BD808: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BD80C: 482212D5  bl 0x823deae0
	ctx.lr = 0x821BD810;
	sub_823DEAE0(ctx, base);
	// 821BD810: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BD814: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BD818: 48AEBC44  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821BD81C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821BD820: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821BD824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BD828: 480B4201  bl 0x82271a28
	ctx.lr = 0x821BD82C;
	sub_82271A28(ctx, base);
	// 821BD82C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BD830: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD834: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BD838: 419A0048  beq cr6, 0x821bd880
	if ctx.cr[6].eq {
	pc = 0x821BD880; continue 'dispatch;
	}
	// 821BD83C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD840: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD844: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD848: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821BD84C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821BD850: 419A0020  beq cr6, 0x821bd870
	if ctx.cr[6].eq {
	pc = 0x821BD870; continue 'dispatch;
	}
	// 821BD854: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BD858: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BD85C: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821BD860: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BD864: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BD868: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BD86C: 4082FFE8  bne 0x821bd854
	if !ctx.cr[0].eq {
	pc = 0x821BD854; continue 'dispatch;
	}
	// 821BD870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BD874: 409A0018  bne cr6, 0x821bd88c
	if !ctx.cr[6].eq {
	pc = 0x821BD88C; continue 'dispatch;
	}
	// 821BD878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD87C: 4BFFA29D  bl 0x821b7b18
	ctx.lr = 0x821BD880;
	sub_821B7B18(ctx, base);
	// 821BD880: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BD884: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BD888: 48AEBBD4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821BD88C: 89630064  lbz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BD890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD894: 409A0030  bne cr6, 0x821bd8c4
	if !ctx.cr[6].eq {
	pc = 0x821BD8C4; continue 'dispatch;
	}
	// 821BD898: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD89C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BD8A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BD8A4: 4E800421  bctrl
	ctx.lr = 0x821BD8A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BD8A8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BD8AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BD8B0: 419A0014  beq cr6, 0x821bd8c4
	if ctx.cr[6].eq {
	pc = 0x821BD8C4; continue 'dispatch;
	}
	// 821BD8B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BD8B8: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BD8BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821BD8C0: 48220519  bl 0x823dddd8
	ctx.lr = 0x821BD8C4;
	sub_823DDDD8(ctx, base);
	// 821BD8C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD8C8: 4BFFA251  bl 0x821b7b18
	ctx.lr = 0x821BD8CC;
	sub_821B7B18(ctx, base);
	// 821BD8CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BD8D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BD8D4: 48AEBB88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BD8D8 size=20
    let mut pc: u32 = 0x821BD8D8;
    'dispatch: loop {
        match pc {
            0x821BD8D8 => {
    //   block [0x821BD8D8..0x821BD8EC)
	// 821BD8D8: 8963001D  lbz r11, 0x1d(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(29 as u32) ) } as u64;
	// 821BD8DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD8E0: 419A000C  beq cr6, 0x821bd8ec
	if ctx.cr[6].eq {
		sub_821BD8EC(ctx, base);
		return;
	}
	// 821BD8E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BD8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD8EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821BD8EC size=32
    let mut pc: u32 = 0x821BD8EC;
    'dispatch: loop {
        match pc {
            0x821BD8EC => {
    //   block [0x821BD8EC..0x821BD90C)
	// 821BD8EC: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BD8F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD8F4: 409AFFF0  bne cr6, 0x821bd8e4
	if !ctx.cr[6].eq {
		sub_821BD8D8(ctx, base);
		return;
	}
	// 821BD8F8: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BD8FC: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821BD900: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BD904: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821BD908: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD90C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BD90C size=8
    let mut pc: u32 = 0x821BD90C;
    'dispatch: loop {
        match pc {
            0x821BD90C => {
    //   block [0x821BD90C..0x821BD914)
	// 821BD90C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BD910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD918 size=868
    let mut pc: u32 = 0x821BD918;
    'dispatch: loop {
        match pc {
            0x821BD918 => {
    //   block [0x821BD918..0x821BDC7C)
	// 821BD918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD91C: 48AEBADD  bl 0x82ca93f8
	ctx.lr = 0x821BD920;
	sub_82CA93D0(ctx, base);
	// 821BD920: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD924: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821BD928: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 821BD92C: 3B590024  addi r26, r25, 0x24
	ctx.r[26].s64 = ctx.r[25].s64 + 36;
	// 821BD930: 8179002C  lwz r11, 0x2c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BD934: 81590028  lwz r10, 0x28(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BD938: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821BD93C: 7D09DBD6  divw r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 821BD940: 3788FFFF  addic. r28, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821BD944: 4180008C  blt 0x821bd9d0
	if ctx.cr[0].lt {
	pc = 0x821BD9D0; continue 'dispatch;
	}
	// 821BD948: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BD94C: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821BD950: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821BD954: 81790028  lwz r11, 0x28(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BD958: 7FFD5A14  add r31, r29, r11
	ctx.r[31].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821BD95C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD964: 419A000C  beq cr6, 0x821bd970
	if ctx.cr[6].eq {
	pc = 0x821BD970; continue 'dispatch;
	}
	// 821BD968: 386B0244  addi r3, r11, 0x244
	ctx.r[3].s64 = ctx.r[11].s64 + 580;
	// 821BD96C: 4803E69D  bl 0x821fc008
	ctx.lr = 0x821BD970;
	sub_821FC008(ctx, base);
	// 821BD970: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD974: 83D90000  lwz r30, 0(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD978: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BD97C: 419A0048  beq cr6, 0x821bd9c4
	if ctx.cr[6].eq {
	pc = 0x821BD9C4; continue 'dispatch;
	}
	// 821BD980: 4803E871  bl 0x821fc1f0
	ctx.lr = 0x821BD984;
	sub_821FC1F0(ctx, base);
	// 821BD984: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 821BD988: 831F0004  lwz r24, 4(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD98C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821BD990: 4802B279  bl 0x821e8c08
	ctx.lr = 0x821BD994;
	sub_821E8C08(ctx, base);
	// 821BD994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BD998: 4803E671  bl 0x821fc008
	ctx.lr = 0x821BD99C;
	sub_821FC008(ctx, base);
	// 821BD99C: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 821BD9A0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821BD9A4: 419A0020  beq cr6, 0x821bd9c4
	if ctx.cr[6].eq {
	pc = 0x821BD9C4; continue 'dispatch;
	}
	// 821BD9A8: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821BD9AC: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 821BD9B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821BD9B4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821BD9B8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821BD9BC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821BD9C0: 488D99A9  bl 0x82a97368
	ctx.lr = 0x821BD9C4;
	sub_82A97368(ctx, base);
	// 821BD9C4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821BD9C8: 3BBDFFF4  addi r29, r29, -0xc
	ctx.r[29].s64 = ctx.r[29].s64 + -12;
	// 821BD9CC: 4080FF88  bge 0x821bd954
	if !ctx.cr[0].lt {
	pc = 0x821BD954; continue 'dispatch;
	}
	// 821BD9D0: 83BA0004  lwz r29, 4(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD9D4: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD9D8: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821BD9DC: 419A0084  beq cr6, 0x821bda60
	if ctx.cr[6].eq {
	pc = 0x821BDA60; continue 'dispatch;
	}
	// 821BD9E0: 7D7EF050  subf r11, r30, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[30].s64;
	// 821BD9E4: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821BD9E8: 7D6BDBD6  divw r11, r11, r27
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 821BD9EC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BD9F0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BD9F4: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BD9F8: 7F6BEA14  add r27, r11, r29
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821BD9FC: 419A0050  beq cr6, 0x821bda4c
	if ctx.cr[6].eq {
	pc = 0x821BDA4C; continue 'dispatch;
	}
	// 821BDA00: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 821BDA04: 7F9EE850  subf r28, r30, r29
	ctx.r[28].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 821BDA08: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 821BDA0C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821BDA10: 419A0020  beq cr6, 0x821bda30
	if ctx.cr[6].eq {
	pc = 0x821BDA30; continue 'dispatch;
	}
	// 821BDA14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BDA18: 4803E5F1  bl 0x821fc008
	ctx.lr = 0x821BDA1C;
	sub_821FC008(ctx, base);
	// 821BDA1C: 807FFFFC  lwz r3, -4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821BDA20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BDA24: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821BDA28: 419A0008  beq cr6, 0x821bda30
	if ctx.cr[6].eq {
	pc = 0x821BDA30; continue 'dispatch;
	}
	// 821BDA2C: 4803E74D  bl 0x821fc178
	ctx.lr = 0x821BDA30;
	sub_821FC178(ctx, base);
	// 821BDA30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDA34: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 821BDA38: 7D7CF92E  stwx r11, r28, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 821BDA3C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 821BDA40: 395FFFF8  addi r10, r31, -8
	ctx.r[10].s64 = ctx.r[31].s64 + -8;
	// 821BDA44: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821BDA48: 409AFFC0  bne cr6, 0x821bda08
	if !ctx.cr[6].eq {
	pc = 0x821BDA08; continue 'dispatch;
	}
	// 821BDA4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821BDA50: 80BA0008  lwz r5, 8(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDA54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BDA58: 488E3FB1  bl 0x82aa1a08
	ctx.lr = 0x821BDA5C;
	sub_82AA1A08(ctx, base);
	// 821BDA5C: 937A0008  stw r27, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 821BDA60: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BDA64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDA68: 419A020C  beq cr6, 0x821bdc74
	if ctx.cr[6].eq {
	pc = 0x821BDC74; continue 'dispatch;
	}
	// 821BDA6C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 821BDA70: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821BDA74: 3BB90010  addi r29, r25, 0x10
	ctx.r[29].s64 = ctx.r[25].s64 + 16;
	// 821BDA78: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821BDA7C: 3B6A2A40  addi r27, r10, 0x2a40
	ctx.r[27].s64 = ctx.r[10].s64 + 10816;
	// 821BDA80: 3B8B2A30  addi r28, r11, 0x2a30
	ctx.r[28].s64 = ctx.r[11].s64 + 10800;
	// 821BDA84: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BDA88: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BDA8C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821BDA90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDA94: 40990008  ble cr6, 0x821bda9c
	if !ctx.cr[6].gt {
	pc = 0x821BDA9C; continue 'dispatch;
	}
	// 821BDA98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BDA9C: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 821BDAA0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDAA4: 4199000C  bgt cr6, 0x821bdab0
	if ctx.cr[6].gt {
	pc = 0x821BDAB0; continue 'dispatch;
	}
	// 821BDAA8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BDAAC: 40980008  bge cr6, 0x821bdab4
	if !ctx.cr[6].lt {
	pc = 0x821BDAB4; continue 'dispatch;
	}
	// 821BDAB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BDAB4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 821BDAB8: 550BF0BE  srwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BDABC: 550907BE  clrlwi r9, r8, 0x1e
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 821BDAC0: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDAC4: 41980008  blt cr6, 0x821bdacc
	if ctx.cr[6].lt {
	pc = 0x821BDACC; continue 'dispatch;
	}
	// 821BDAC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BDACC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDAD0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BDAD4: 41990008  bgt cr6, 0x821bdadc
	if ctx.cr[6].gt {
	pc = 0x821BDADC; continue 'dispatch;
	}
	// 821BDAD8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821BDADC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDAE0: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BDAE4: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821BDAE8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BDAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDAF0: 7CC8502E  lwzx r6, r8, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821BDAF4: 7D06382E  lwzx r8, r6, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821BDAF8: 419A0014  beq cr6, 0x821bdb0c
	if ctx.cr[6].eq {
	pc = 0x821BDB0C; continue 'dispatch;
	}
	// 821BDAFC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BDB00: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821BDB04: 40820008  bne 0x821bdb0c
	if !ctx.cr[0].eq {
	pc = 0x821BDB0C; continue 'dispatch;
	}
	// 821BDB08: 935D000C  stw r26, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 821BDB0C: 83E80248  lwz r31, 0x248(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(584 as u32) ) } as u64;
	// 821BDB10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BDB14: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821BDB18: 419A0054  beq cr6, 0x821bdb6c
	if ctx.cr[6].eq {
	pc = 0x821BDB6C; continue 'dispatch;
	}
	// 821BDB1C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821BDB20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BDB24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BDB28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BDB2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BDB30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BDB34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BDB38: 4082FFE8  bne 0x821bdb20
	if !ctx.cr[0].eq {
	pc = 0x821BDB20; continue 'dispatch;
	}
	// 821BDB3C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821BDB40: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821BDB44: 409A0028  bne cr6, 0x821bdb6c
	if !ctx.cr[6].eq {
	pc = 0x821BDB6C; continue 'dispatch;
	}
	// 821BDB48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDB4C: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821BDB50: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 821BDB54: 409A0018  bne cr6, 0x821bdb6c
	if !ctx.cr[6].eq {
	pc = 0x821BDB6C; continue 'dispatch;
	}
	// 821BDB58: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821BDB5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDB60: 419A000C  beq cr6, 0x821bdb6c
	if ctx.cr[6].eq {
	pc = 0x821BDB6C; continue 'dispatch;
	}
	// 821BDB64: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BDB68: 4803E611  bl 0x821fc178
	ctx.lr = 0x821BDB6C;
	sub_821FC178(ctx, base);
	// 821BDB6C: 38680244  addi r3, r8, 0x244
	ctx.r[3].s64 = ctx.r[8].s64 + 580;
	// 821BDB70: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821BDB74: 4803E495  bl 0x821fc008
	ctx.lr = 0x821BDB78;
	sub_821FC008(ctx, base);
	// 821BDB78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BDB7C: 83D90000  lwz r30, 0(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDB80: 419A00D0  beq cr6, 0x821bdc50
	if ctx.cr[6].eq {
	pc = 0x821BDC50; continue 'dispatch;
	}
	// 821BDB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BDB88: 4803E669  bl 0x821fc1f0
	ctx.lr = 0x821BDB8C;
	sub_821FC1F0(ctx, base);
	// 821BDB8C: 80FE0030  lwz r7, 0x30(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BDB90: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 821BDB94: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BDB98: 419A0088  beq cr6, 0x821bdc20
	if ctx.cr[6].eq {
	pc = 0x821BDC20; continue 'dispatch;
	}
	// 821BDB9C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BDBA0: 7D493A14  add r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 821BDBA4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDBA8: 40990008  ble cr6, 0x821bdbb0
	if !ctx.cr[6].gt {
	pc = 0x821BDBB0; continue 'dispatch;
	}
	// 821BDBAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BDBB0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BDBB4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821BDBB8: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BDBBC: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821BDBC0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BDBC4: 4199000C  bgt cr6, 0x821bdbd0
	if ctx.cr[6].gt {
	pc = 0x821BDBD0; continue 'dispatch;
	}
	// 821BDBC8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BDBCC: 40980008  bge cr6, 0x821bdbd4
	if !ctx.cr[6].lt {
	pc = 0x821BDBD4; continue 'dispatch;
	}
	// 821BDBD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BDBD4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BDBD8: 41980008  blt cr6, 0x821bdbe0
	if ctx.cr[6].lt {
	pc = 0x821BDBE0; continue 'dispatch;
	}
	// 821BDBDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BDBE0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDBE4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDBE8: 41990008  bgt cr6, 0x821bdbf0
	if ctx.cr[6].gt {
	pc = 0x821BDBF0; continue 'dispatch;
	}
	// 821BDBEC: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821BDBF0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDBF4: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BDBF8: 7D48482E  lwzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821BDBFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BDC00: 419A0020  beq cr6, 0x821bdc20
	if ctx.cr[6].eq {
	pc = 0x821BDC20; continue 'dispatch;
	}
	// 821BDC04: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDC08: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821BDC0C: 409A0014  bne cr6, 0x821bdc20
	if !ctx.cr[6].eq {
	pc = 0x821BDC20; continue 'dispatch;
	}
	// 821BDC10: 3547FFFF  addic. r10, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821BDC14: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821BDC18: 40820008  bne 0x821bdc20
	if !ctx.cr[0].eq {
	pc = 0x821BDC20; continue 'dispatch;
	}
	// 821BDC1C: 934B000C  stw r26, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 821BDC20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BDC24: 4803E3E5  bl 0x821fc008
	ctx.lr = 0x821BDC28;
	sub_821FC008(ctx, base);
	// 821BDC28: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821BDC2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BDC30: 419A0020  beq cr6, 0x821bdc50
	if ctx.cr[6].eq {
	pc = 0x821BDC50; continue 'dispatch;
	}
	// 821BDC34: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821BDC38: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 821BDC3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821BDC40: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 821BDC44: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821BDC48: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BDC4C: 488D971D  bl 0x82a97368
	ctx.lr = 0x821BDC50;
	sub_82A97368(ctx, base);
	// 821BDC50: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821BDC54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BDC58: 4803E3B1  bl 0x821fc008
	ctx.lr = 0x821BDC5C;
	sub_821FC008(ctx, base);
	// 821BDC5C: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 821BDC60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BDC64: 4803E3A5  bl 0x821fc008
	ctx.lr = 0x821BDC68;
	sub_821FC008(ctx, base);
	// 821BDC68: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BDC6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDC70: 409AFE14  bne cr6, 0x821bda84
	if !ctx.cr[6].eq {
	pc = 0x821BDA84; continue 'dispatch;
	}
	// 821BDC74: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821BDC78: 48AEB7D0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BDC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BDC80 size=484
    let mut pc: u32 = 0x821BDC80;
    'dispatch: loop {
        match pc {
            0x821BDC80 => {
    //   block [0x821BDC80..0x821BDE64)
	// 821BDC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BDC84: 48AEB779  bl 0x82ca93fc
	ctx.lr = 0x821BDC88;
	sub_82CA93D0(ctx, base);
	// 821BDC88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BDC8C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821BDC90: 4BFF93D1  bl 0x821b7060
	ctx.lr = 0x821BDC94;
	sub_821B7060(ctx, base);
	// 821BDC94: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BDC98: 394BA978  addi r10, r11, -0x5688
	ctx.r[10].s64 = ctx.r[11].s64 + -22152;
	// 821BDC9C: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDCA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BDCA4: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821BDCA8: 419A0008  beq cr6, 0x821bdcb0
	if ctx.cr[6].eq {
	pc = 0x821BDCB0; continue 'dispatch;
	}
	// 821BDCAC: 4803E4CD  bl 0x821fc178
	ctx.lr = 0x821BDCB0;
	sub_821FC178(ctx, base);
	// 821BDCB0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821BDCB4: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 821BDCB8: 394B2A30  addi r10, r11, 0x2a30
	ctx.r[10].s64 = ctx.r[11].s64 + 10800;
	// 821BDCBC: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821BDCC0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821BDCC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821BDCC8: 3889F820  addi r4, r9, -0x7e0
	ctx.r[4].s64 = ctx.r[9].s64 + -2016;
	// 821BDCCC: 807FF7E0  lwz r3, -0x820(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-2080 as u32) ) } as u64;
	// 821BDCD0: 4BFE74A1  bl 0x821a5170
	ctx.lr = 0x821BDCD4;
	sub_821A5170(ctx, base);
	// 821BDCD4: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 821BDCD8: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDCDC: 480E325D  bl 0x822a0f38
	ctx.lr = 0x821BDCE0;
	sub_822A0F38(ctx, base);
	// 821BDCE0: 807FF7E0  lwz r3, -0x820(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-2080 as u32) ) } as u64;
	// 821BDCE4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821BDCE8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDCEC: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDCF0: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821BDCF4: 4E800421  bctrl
	ctx.lr = 0x821BDCF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BDCF8: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDCFC: 480DDD95  bl 0x8229ba90
	ctx.lr = 0x821BDD00;
	sub_8229BA90(ctx, base);
	// 821BDD00: 4BFF9361  bl 0x821b7060
	ctx.lr = 0x821BDD04;
	sub_821B7060(ctx, base);
	// 821BDD04: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821BDD08: 3B8B4DE4  addi r28, r11, 0x4de4
	ctx.r[28].s64 = ctx.r[11].s64 + 19940;
	// 821BDD0C: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDD10: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDD14: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BDD18: 7CC51670  srawi r5, r6, 2
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 2) as i64;
	// 821BDD1C: 37A5FFFF  addic. r29, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821BDD20: 41800040  blt 0x821bdd60
	if ctx.cr[0].lt {
	pc = 0x821BDD60; continue 'dispatch;
	}
	// 821BDD24: 57BB103A  slwi r27, r29, 2
	ctx.r[27].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 821BDD28: 48000008  b 0x821bdd30
	pc = 0x821BDD30; continue 'dispatch;
	// 821BDD2C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDD30: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BDD34: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821BDD38: 3BCB0064  addi r30, r11, 0x64
	ctx.r[30].s64 = ctx.r[11].s64 + 100;
	// 821BDD3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BDD40: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDD44: 480792DD  bl 0x82237020
	ctx.lr = 0x821BDD48;
	sub_82237020(ctx, base);
	// 821BDD48: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821BDD4C: 3BDEFFDC  addi r30, r30, -0x24
	ctx.r[30].s64 = ctx.r[30].s64 + -36;
	// 821BDD50: 4080FFEC  bge 0x821bdd3c
	if !ctx.cr[0].lt {
	pc = 0x821BDD3C; continue 'dispatch;
	}
	// 821BDD54: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821BDD58: 3B7BFFFC  addi r27, r27, -4
	ctx.r[27].s64 = ctx.r[27].s64 + -4;
	// 821BDD5C: 4080FFD0  bge 0x821bdd2c
	if !ctx.cr[0].lt {
	pc = 0x821BDD2C; continue 'dispatch;
	}
	// 821BDD60: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDD64: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 821BDD68: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BDD6C: 386B0D54  addi r3, r11, 0xd54
	ctx.r[3].s64 = ctx.r[11].s64 + 3412;
	// 821BDD70: 480D1721  bl 0x8228f490
	ctx.lr = 0x821BDD74;
	sub_8228F490(ctx, base);
	// 821BDD74: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDD78: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 821BDD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDD80: 419A0010  beq cr6, 0x821bdd90
	if ctx.cr[6].eq {
	pc = 0x821BDD90; continue 'dispatch;
	}
	// 821BDD84: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDD88: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BDD8C: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821BDD90: 37EBFFFF  addic. r31, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821BDD94: 41800054  blt 0x821bdde8
	if ctx.cr[0].lt {
	pc = 0x821BDDE8; continue 'dispatch;
	}
	// 821BDD98: 57FD103A  slwi r29, r31, 2
	ctx.r[29].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821BDD9C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDDA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDDA4: 419A0018  beq cr6, 0x821bddbc
	if ctx.cr[6].eq {
	pc = 0x821BDDBC; continue 'dispatch;
	}
	// 821BDDA8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDDAC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BDDB0: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821BDDB4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDDB8: 41980008  blt cr6, 0x821bddc0
	if ctx.cr[6].lt {
	pc = 0x821BDDC0; continue 'dispatch;
	}
	// 821BDDBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821BDDC0: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BDDC4: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821BDDC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BDDCC: 419A0010  beq cr6, 0x821bdddc
	if ctx.cr[6].eq {
	pc = 0x821BDDDC; continue 'dispatch;
	}
	// 821BDDD0: 388B0118  addi r4, r11, 0x118
	ctx.r[4].s64 = ctx.r[11].s64 + 280;
	// 821BDDD4: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDDD8: 48079249  bl 0x82237020
	ctx.lr = 0x821BDDDC;
	sub_82237020(ctx, base);
	// 821BDDDC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821BDDE0: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 821BDDE4: 4080FFB8  bge 0x821bdd9c
	if !ctx.cr[0].lt {
	pc = 0x821BDD9C; continue 'dispatch;
	}
	// 821BDDE8: 4BFF9049  bl 0x821b6e30
	ctx.lr = 0x821BDDEC;
	sub_821B6E30(ctx, base);
	// 821BDDEC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821BDDF0: 816A6E98  lwz r11, 0x6e98(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28312 as u32) ) } as u64;
	// 821BDDF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDDF8: 419A0014  beq cr6, 0x821bde0c
	if ctx.cr[6].eq {
	pc = 0x821BDE0C; continue 'dispatch;
	}
	// 821BDDFC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BDE00: 992B01E4  stb r9, 0x1e4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(484 as u32), ctx.r[9].u8 ) };
	// 821BDE04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BDE08: 916A6E98  stw r11, 0x6e98(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28312 as u32), ctx.r[11].u32 ) };
	// 821BDE0C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BDE10: 386BAC10  addi r3, r11, -0x53f0
	ctx.r[3].s64 = ctx.r[11].s64 + -21488;
	// 821BDE14: 4803E1F5  bl 0x821fc008
	ctx.lr = 0x821BDE18;
	sub_821FC008(ctx, base);
	// 821BDE18: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDE1C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821BDE20: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BDE24: 806AF9C4  lwz r3, -0x63c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-1596 as u32) ) } as u64;
	// 821BDE28: 80880008  lwz r4, 8(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDE2C: 4BFFFAED  bl 0x821bd918
	ctx.lr = 0x821BDE30;
	sub_821BD918(ctx, base);
	// 821BDE30: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 821BDE34: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDE38: 3887AC08  addi r4, r7, -0x53f8
	ctx.r[4].s64 = ctx.r[7].s64 + -21496;
	// 821BDE3C: 4801BDB5  bl 0x821d9bf0
	ctx.lr = 0x821BDE40;
	sub_821D9BF0(ctx, base);
	// 821BDE40: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BDE44: 388BAA5C  addi r4, r11, -0x55a4
	ctx.r[4].s64 = ctx.r[11].s64 + -21924;
	// 821BDE48: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDE4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDE50: 419A000C  beq cr6, 0x821bde5c
	if ctx.cr[6].eq {
	pc = 0x821BDE5C; continue 'dispatch;
	}
	// 821BDE54: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDE58: 480791C9  bl 0x82237020
	ctx.lr = 0x821BDE5C;
	sub_82237020(ctx, base);
	// 821BDE5C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BDE60: 48AEB5EC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BDE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BDE68 size=7824
    let mut pc: u32 = 0x821BDE68;
    'dispatch: loop {
        match pc {
            0x821BDE68 => {
    //   block [0x821BDE68..0x821BFCF8)
	// 821BDE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BDE6C: 48AEB565  bl 0x82ca93d0
	ctx.lr = 0x821BDE70;
	sub_82CA93D0(ctx, base);
	// 821BDE70: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821BDE74: 48AEFE3D  bl 0x82cadcb0
	ctx.lr = 0x821BDE78;
	sub_82CADCA0(ctx, base);
	// 821BDE78: 3981FEF0  addi r12, r1, -0x110
	ctx.r[12].s64 = ctx.r[1].s64 + -272;
	// 821BDE7C: 48E48B49  bl 0x830069c4
	ctx.lr = 0x821BDE80;
	sub_83006760(ctx, base);
	// 821BDE80: 9421FBC0  stwu r1, -0x440(r1)
	ea = ctx.r[1].u32.wrapping_add(-1088 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BDE84: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 821BDE88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BDE8C: 39000480  li r8, 0x480
	ctx.r[8].s64 = 1152;
	// 821BDE90: 9221045C  stw r17, 0x45c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1116 as u32), ctx.r[17].u32 ) };
	// 821BDE94: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 821BDE98: 3D20834C  lis r9, -0x7cb4
	ctx.r[9].s64 = -2092171264;
	// 821BDE9C: 81510004  lwz r10, 4(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDEA0: 39EB9410  addi r15, r11, -0x6bf0
	ctx.r[15].s64 = ctx.r[11].s64 + -27632;
	// 821BDEA4: 38A00490  li r5, 0x490
	ctx.r[5].s64 = 1168;
	// 821BDEA8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821BDEAC: 91E100DC  stw r15, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[15].u32 ) };
	// 821BDEB0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821BDEB4: 8869EC7B  lbz r3, -0x1385(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-4997 as u32) ) } as u64;
	// 821BDEB8: 39C00001  li r14, 1
	ctx.r[14].s64 = 1;
	// 821BDEBC: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BDEC0: C00FFEC8  lfs f0, -0x138(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BDEC4: 7DCA7378  mr r10, r14
	ctx.r[10].u64 = ctx.r[14].u64;
	// 821BDEC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BFCF8 size=180
    let mut pc: u32 = 0x821BFCF8;
    'dispatch: loop {
        match pc {
            0x821BFCF8 => {
    //   block [0x821BFCF8..0x821BFDAC)
	// 821BFCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BFCFC: 48AE970D  bl 0x82ca9408
	ctx.lr = 0x821BFD00;
	sub_82CA93D0(ctx, base);
	// 821BFD00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BFD04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BFD08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821BFD0C: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 821BFD10: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821BFD14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BFD18: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821BFD1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BFD20: 4BFD4119  bl 0x82193e38
	ctx.lr = 0x821BFD24;
	sub_82193E38(ctx, base);
	// 821BFD24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BFD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BFD2C: 4831219D  bl 0x824d1ec8
	ctx.lr = 0x821BFD30;
	sub_824D1EC8(ctx, base);
	// 821BFD30: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821BFD34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BFD38: 3B8A0B7C  addi r28, r10, 0xb7c
	ctx.r[28].s64 = ctx.r[10].s64 + 2940;
	// 821BFD3C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821BFD40: 4BFD40F9  bl 0x82193e38
	ctx.lr = 0x821BFD44;
	sub_82193E38(ctx, base);
	// 821BFD44: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821BFD48: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821BFD4C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 821BFD50: 3BA9A950  addi r29, r9, -0x56b0
	ctx.r[29].s64 = ctx.r[9].s64 + -22192;
	// 821BFD54: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821BFD58: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 821BFD5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BFDB0 size=12
    let mut pc: u32 = 0x821BFDB0;
    'dispatch: loop {
        match pc {
            0x821BFDB0 => {
    //   block [0x821BFDB0..0x821BFDBC)
	// 821BFDB0: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 821BFDB4: 908B002C  stw r4, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 821BFDB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821BFDC0 size=40
    let mut pc: u32 = 0x821BFDC0;
    'dispatch: loop {
        match pc {
            0x821BFDC0 => {
    //   block [0x821BFDC0..0x821BFDE8)
	// 821BFDC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BFDC4: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFDC8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821BFDCC: 41980014  blt cr6, 0x821bfde0
	if ctx.cr[6].lt {
	pc = 0x821BFDE0; continue 'dispatch;
	}
	// 821BFDD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BFDD4: C00B0A44  lfs f0, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFDD8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821BFDDC: 4099000C  ble cr6, 0x821bfde8
	if !ctx.cr[6].gt {
		sub_821BFDE8(ctx, base);
		return;
	}
	// 821BFDE0: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821BFDE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821BFDE8 size=8
    let mut pc: u32 = 0x821BFDE8;
    'dispatch: loop {
        match pc {
            0x821BFDE8 => {
    //   block [0x821BFDE8..0x821BFDF0)
	// 821BFDE8: D0230008  stfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821BFDEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BFDF0 size=36
    let mut pc: u32 = 0x821BFDF0;
    'dispatch: loop {
        match pc {
            0x821BFDF0 => {
    //   block [0x821BFDF0..0x821BFE14)
	// 821BFDF0: 81632934  lwz r11, 0x2934(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10548 as u32) ) } as u64;
	// 821BFDF4: 508B2676  rlwimi r11, r4, 4, 0x19, 0x1b
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(4) as u64) & 0x0000000000000070) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFF8F);
	// 821BFDF8: 91632934  stw r11, 0x2934(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10548 as u32), ctx.r[11].u32 ) };
	// 821BFDFC: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821BFE00: 616B0800  ori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 2048;
	// 821BFE04: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821BFE08: 656B0002  oris r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 131072;
	// 821BFE0C: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821BFE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821BFE18 size=140
    let mut pc: u32 = 0x821BFE18;
    'dispatch: loop {
        match pc {
            0x821BFE18 => {
    //   block [0x821BFE18..0x821BFEA4)
	// 821BFE18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BFE1C: 3D4051EB  lis r10, 0x51eb
	ctx.r[10].s64 = 1374355456;
	// 821BFE20: 392BD9BC  addi r9, r11, -0x2644
	ctx.r[9].s64 = ctx.r[11].s64 + -9796;
	// 821BFE24: 6148851F  ori r8, r10, 0x851f
	ctx.r[8].u64 = ctx.r[10].u64 | 34079;
	// 821BFE28: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 821BFE2C: C1ABD9BC  lfs f13, -0x2644(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9796 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821BFE30: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 821BFE34: C009E2AC  lfs f0, -0x1d54(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-7508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFE38: ED810032  fmuls f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821BFE3C: C0060AA8  lfs f0, 0xaa8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2728 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFE40: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 821BFE44: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 821BFE48: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821BFE4C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821BFE50: 7C854096  mulhw r4, r5, r8
	ctx.r[4].s64 = ((ctx.r[5].s32 as i64 * ctx.r[8].s32 as i64) >> 32);
	// 821BFE54: 7C6B3BD6  divw r3, r11, r7
	ctx.r[3].s32 = ctx.r[11].s32 / ctx.r[7].s32;
	// 821BFE58: 7C8B2E70  srawi r11, r4, 5
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 5) as i64;
	// 821BFE5C: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 821BFE60: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BFE64: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 821BFE68: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BFE6C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BFE70: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 821BFE74: 1CE80064  mulli r7, r8, 0x64
	ctx.r[7].s64 = ctx.r[8].s64 * 100;
	// 821BFE78: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821BFE7C: 7CC72850  subf r6, r7, r5
	ctx.r[6].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 821BFE80: 7CC507B4  extsw r5, r6
	ctx.r[5].s64 = ctx.r[6].s32 as i64;
	// 821BFE84: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 821BFE88: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 821BFE8C: C8C1FFF0  lfd f6, -0x10(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BFE90: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 821BFE94: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821BFE98: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 821BFE9C: EC23383A  fmadds f1, f3, f0, f7
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 821BFEA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BFEA8 size=176
    let mut pc: u32 = 0x821BFEA8;
    'dispatch: loop {
        match pc {
            0x821BFEA8 => {
    //   block [0x821BFEA8..0x821BFF58)
	// 821BFEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BFEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BFEB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BFEB4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821BFEB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BFEBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BFEC0: FF011000  fcmpu cr6, f1, f2
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[2].f64);
	// 821BFEC4: C3FF0004  lfs f31, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821BFEC8: 4098002C  bge cr6, 0x821bfef4
	if !ctx.cr[6].lt {
	pc = 0x821BFEF4; continue 'dispatch;
	}
	// 821BFECC: 4BFFFF4D  bl 0x821bfe18
	ctx.lr = 0x821BFED0;
	sub_821BFE18(ctx, base);
	// 821BFED0: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821BFED4: 41980068  blt cr6, 0x821bff3c
	if ctx.cr[6].lt {
	pc = 0x821BFF3C; continue 'dispatch;
	}
	// 821BFED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BFEDC: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821BFEE0: 4BFFFF39  bl 0x821bfe18
	ctx.lr = 0x821BFEE4;
	sub_821BFE18(ctx, base);
	// 821BFEE4: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821BFEE8: 40980054  bge cr6, 0x821bff3c
	if !ctx.cr[6].lt {
	pc = 0x821BFF3C; continue 'dispatch;
	}
	// 821BFEEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BFEF0: 48000050  b 0x821bff40
	pc = 0x821BFF40; continue 'dispatch;
	// 821BFEF4: 4BFFFF25  bl 0x821bfe18
	ctx.lr = 0x821BFEF8;
	sub_821BFE18(ctx, base);
	// 821BFEF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BFEFC: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821BFF00: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 821BFF04: 41980010  blt cr6, 0x821bff14
	if ctx.cr[6].lt {
	pc = 0x821BFF14; continue 'dispatch;
	}
	// 821BFF08: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFF0C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821BFF10: 41980024  blt cr6, 0x821bff34
	if ctx.cr[6].lt {
	pc = 0x821BFF34; continue 'dispatch;
	}
	// 821BFF14: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFF18: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821BFF1C: 41980020  blt cr6, 0x821bff3c
	if ctx.cr[6].lt {
	pc = 0x821BFF3C; continue 'dispatch;
	}
	// 821BFF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BFF24: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821BFF28: 4BFFFEF1  bl 0x821bfe18
	ctx.lr = 0x821BFF2C;
	sub_821BFE18(ctx, base);
	// 821BFF2C: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821BFF30: 4098000C  bge cr6, 0x821bff3c
	if !ctx.cr[6].lt {
	pc = 0x821BFF3C; continue 'dispatch;
	}
	// 821BFF34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BFF38: 48000008  b 0x821bff40
	pc = 0x821BFF40; continue 'dispatch;
	// 821BFF3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BFF40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BFF44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BFF48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BFF4C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BFF50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BFF54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BFF58 size=184
    let mut pc: u32 = 0x821BFF58;
    'dispatch: loop {
        match pc {
            0x821BFF58 => {
    //   block [0x821BFF58..0x821C0010)
	// 821BFF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BFF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BFF60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BFF64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BFF68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BFF6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BFF70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821BFF74: 4BFD6DFD  bl 0x82196d70
	ctx.lr = 0x821BFF78;
	sub_82196D70(ctx, base);
	// 821BFF78: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821BFF7C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 821BFF80: 389E0030  addi r4, r30, 0x30
	ctx.r[4].s64 = ctx.r[30].s64 + 48;
	// 821BFF84: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0010 size=260
    let mut pc: u32 = 0x821C0010;
    'dispatch: loop {
        match pc {
            0x821C0010 => {
    //   block [0x821C0010..0x821C0114)
	// 821C0010: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C0118 size=1028
    let mut pc: u32 = 0x821C0118;
    'dispatch: loop {
        match pc {
            0x821C0118 => {
    //   block [0x821C0118..0x821C051C)
	// 821C0118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C011C: 48AE92E1  bl 0x82ca93fc
	ctx.lr = 0x821C0120;
	sub_82CA93D0(ctx, base);
	// 821C0120: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821C0124: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C0128: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821C012C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821C0130: 3BFB0050  addi r31, r27, 0x50
	ctx.r[31].s64 = ctx.r[27].s64 + 80;
	// 821C0134: 3BDB0060  addi r30, r27, 0x60
	ctx.r[30].s64 = ctx.r[27].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C0520 size=12
    let mut pc: u32 = 0x821C0520;
    'dispatch: loop {
        match pc {
            0x821C0520 => {
    //   block [0x821C0520..0x821C052C)
	// 821C0520: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C0524: C02BBAB4  lfs f1, -0x454c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17740 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C0528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0530 size=56
    let mut pc: u32 = 0x821C0530;
    'dispatch: loop {
        match pc {
            0x821C0530 => {
    //   block [0x821C0530..0x821C0568)
	// 821C0530: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C0534: 419A0018  beq cr6, 0x821c054c
	if ctx.cr[6].eq {
	pc = 0x821C054C; continue 'dispatch;
	}
	// 821C0538: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C053C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C0540: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C0544: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C0548: 409A0008  bne cr6, 0x821c0550
	if !ctx.cr[6].eq {
	pc = 0x821C0550; continue 'dispatch;
	}
	// 821C054C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C0550: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C0554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C0558: 419A0010  beq cr6, 0x821c0568
	if ctx.cr[6].eq {
		sub_821C0568(ctx, base);
		return;
	}
	// 821C055C: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C0560: 556337FE  rlwinm r3, r11, 6, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 821C0564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0568 size=8
    let mut pc: u32 = 0x821C0568;
    'dispatch: loop {
        match pc {
            0x821C0568 => {
    //   block [0x821C0568..0x821C0570)
	// 821C0568: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C056C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0570 size=168
    let mut pc: u32 = 0x821C0570;
    'dispatch: loop {
        match pc {
            0x821C0570 => {
    //   block [0x821C0570..0x821C0618)
	// 821C0570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C0574: 48AE8E95  bl 0x82ca9408
	ctx.lr = 0x821C0578;
	sub_82CA93D0(ctx, base);
	// 821C0578: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C0618 size=48
    let mut pc: u32 = 0x821C0618;
    'dispatch: loop {
        match pc {
            0x821C0618 => {
    //   block [0x821C0618..0x821C0648)
	// 821C0618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C061C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C0620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C0624: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821C0628: 8063002C  lwz r3, 0x2c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821C062C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C0648 size=304
    let mut pc: u32 = 0x821C0648;
    'dispatch: loop {
        match pc {
            0x821C0648 => {
    //   block [0x821C0648..0x821C0778)
	// 821C0648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C064C: 48AE8DAD  bl 0x82ca93f8
	ctx.lr = 0x821C0650;
	sub_82CA93D0(ctx, base);
	// 821C0650: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C0654: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C0658: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821C065C: 894B6B50  lbz r10, 0x6b50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27472 as u32) ) } as u64;
	// 821C0660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C0664: 419A010C  beq cr6, 0x821c0770
	if ctx.cr[6].eq {
	pc = 0x821C0770; continue 'dispatch;
	}
	// 821C0668: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C066C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C0670: 3B4B801C  addi r26, r11, -0x7fe4
	ctx.r[26].s64 = ctx.r[11].s64 + -32740;
	// 821C0674: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821C0678: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C067C: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C0680: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C0684: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C0688: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C068C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821C0690: 419A00E0  beq cr6, 0x821c0770
	if ctx.cr[6].eq {
	pc = 0x821C0770; continue 'dispatch;
	}
	// 821C0694: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821C0698: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C069C: 3B6BFFDF  addi r27, r11, -0x21
	ctx.r[27].s64 = ctx.r[11].s64 + -33;
	// 821C06A0: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06A4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821C06A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C06AC: 419A0008  beq cr6, 0x821c06b4
	if ctx.cr[6].eq {
	pc = 0x821C06B4; continue 'dispatch;
	}
	// 821C06B0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06B8: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 821C06BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C06C0: 419A0008  beq cr6, 0x821c06c8
	if ctx.cr[6].eq {
	pc = 0x821C06C8; continue 'dispatch;
	}
	// 821C06C4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06C8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821C06CC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C06D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C06D8: 409AFFF4  bne cr6, 0x821c06cc
	if !ctx.cr[6].eq {
	pc = 0x821C06CC; continue 'dispatch;
	}
	// 821C06DC: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821C06E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C06E4: 557D003E  slwi r29, r11, 0
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821C06E8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821C06EC: 409A000C  bne cr6, 0x821c06f8
	if !ctx.cr[6].eq {
	pc = 0x821C06F8; continue 'dispatch;
	}
	// 821C06F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C06F4: 48000060  b 0x821c0754
	pc = 0x821C0754; continue 'dispatch;
	// 821C06F8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C0700: 419A0050  beq cr6, 0x821c0750
	if ctx.cr[6].eq {
	pc = 0x821C0750; continue 'dispatch;
	}
	// 821C0704: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C0708: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 821C070C: 4802E53D  bl 0x821eec48
	ctx.lr = 0x821C0710;
	sub_821EEC48(ctx, base);
	// 821C0710: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C0714: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821C0718: 7D430774  extsb r3, r10
	ctx.r[3].s64 = ctx.r[10].s8 as i64;
	// 821C071C: 4802E52D  bl 0x821eec48
	ctx.lr = 0x821C0720;
	sub_821EEC48(ctx, base);
	// 821C0720: 7F181800  cmpw cr6, r24, r3
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[3].s32, &mut ctx.xer);
	// 821C0724: 409A001C  bne cr6, 0x821c0740
	if !ctx.cr[6].eq {
	pc = 0x821C0740; continue 'dispatch;
	}
	// 821C0728: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821C072C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C0730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C0734: 48AF1555  bl 0x82cb1c88
	ctx.lr = 0x821C0738;
	sub_82CB1C88(ctx, base);
	// 821C0738: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C073C: 419AFFB4  beq cr6, 0x821c06f0
	if ctx.cr[6].eq {
	pc = 0x821C06F0; continue 'dispatch;
	}
	// 821C0740: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821C0744: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C0748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C074C: 409AFFB8  bne cr6, 0x821c0704
	if !ctx.cr[6].eq {
	pc = 0x821C0704; continue 'dispatch;
	}
	// 821C0750: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C0754: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C0758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C075C: 409A0014  bne cr6, 0x821c0770
	if !ctx.cr[6].eq {
	pc = 0x821C0770; continue 'dispatch;
	}
	// 821C0760: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C0764: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821C0768: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C076C: 409AFF34  bne cr6, 0x821c06a0
	if !ctx.cr[6].eq {
	pc = 0x821C06A0; continue 'dispatch;
	}
	// 821C0770: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821C0774: 48AE8CD4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0778 size=548
    let mut pc: u32 = 0x821C0778;
    'dispatch: loop {
        match pc {
            0x821C0778 => {
    //   block [0x821C0778..0x821C099C)
	// 821C0778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C077C: 48AE8C91  bl 0x82ca940c
	ctx.lr = 0x821C0780;
	sub_82CA93D0(ctx, base);
	// 821C0780: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C09A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C09A0 size=3812
    let mut pc: u32 = 0x821C09A0;
    'dispatch: loop {
        match pc {
            0x821C09A0 => {
    //   block [0x821C09A0..0x821C1884)
	// 821C09A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C09A4: 48AE8A2D  bl 0x82ca93d0
	ctx.lr = 0x821C09A8;
	sub_82CA93D0(ctx, base);
	// 821C09A8: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 821C09AC: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 821C09B0: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821C09B4: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C1888 size=356
    let mut pc: u32 = 0x821C1888;
    'dispatch: loop {
        match pc {
            0x821C1888 => {
    //   block [0x821C1888..0x821C19EC)
	// 821C1888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C188C: 48AE7B79  bl 0x82ca9404
	ctx.lr = 0x821C1890;
	sub_82CA93D0(ctx, base);
	// 821C1890: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1894: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C1898: 48117211  bl 0x822d8aa8
	ctx.lr = 0x821C189C;
	sub_822D8AA8(ctx, base);
	// 821C189C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C18A0: 3B9B000C  addi r28, r27, 0xc
	ctx.r[28].s64 = ctx.r[27].s64 + 12;
	// 821C18A4: 997B00C7  stb r11, 0xc7(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(199 as u32), ctx.r[11].u8 ) };
	// 821C18A8: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C18AC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C18B0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C18B4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821C18B8: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C18BC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821C18C0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C18C4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C18C8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C18CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C18D0: 419A000C  beq cr6, 0x821c18dc
	if ctx.cr[6].eq {
	pc = 0x821C18DC; continue 'dispatch;
	}
	// 821C18D4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821C18D8: 419A0008  beq cr6, 0x821c18e0
	if ctx.cr[6].eq {
	pc = 0x821C18E0; continue 'dispatch;
	}
	// 821C18DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C18E0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C18E4: 419A007C  beq cr6, 0x821c1960
	if ctx.cr[6].eq {
	pc = 0x821C1960; continue 'dispatch;
	}
	// 821C18E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C18EC: 409A0008  bne cr6, 0x821c18f4
	if !ctx.cr[6].eq {
	pc = 0x821C18F4; continue 'dispatch;
	}
	// 821C18F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C18F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C18F8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C18FC: 409A0008  bne cr6, 0x821c1904
	if !ctx.cr[6].eq {
	pc = 0x821C1904; continue 'dispatch;
	}
	// 821C1900: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C1904: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C1908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C190C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C1910: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821C1914: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C1918: 4E800421  bctrl
	ctx.lr = 0x821C191C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C191C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C1920: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C1924: 409A001C  bne cr6, 0x821c1940
	if !ctx.cr[6].eq {
	pc = 0x821C1940; continue 'dispatch;
	}
	// 821C1928: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C192C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C1930: 409A0008  bne cr6, 0x821c1938
	if !ctx.cr[6].eq {
	pc = 0x821C1938; continue 'dispatch;
	}
	// 821C1934: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C1938: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C193C: 4BFFFF8C  b 0x821c18c8
	pc = 0x821C18C8; continue 'dispatch;
	// 821C1940: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C1944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C1948: 809B00D0  lwz r4, 0xd0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 821C194C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C1950: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C1954: 4E800421  bctrl
	ctx.lr = 0x821C1958;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C1958: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C195C: 48AE7AF8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 821C1960: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C1964: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C1968: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C196C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C1970: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C1974: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821C1978: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C197C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C1980: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C1984: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C1988: 419A000C  beq cr6, 0x821c1994
	if ctx.cr[6].eq {
	pc = 0x821C1994; continue 'dispatch;
	}
	// 821C198C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821C1990: 419A0008  beq cr6, 0x821c1998
	if ctx.cr[6].eq {
	pc = 0x821C1998; continue 'dispatch;
	}
	// 821C1994: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C1998: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C199C: 419AFFBC  beq cr6, 0x821c1958
	if ctx.cr[6].eq {
	pc = 0x821C1958; continue 'dispatch;
	}
	// 821C19A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C19A4: 409A0008  bne cr6, 0x821c19ac
	if !ctx.cr[6].eq {
	pc = 0x821C19AC; continue 'dispatch;
	}
	// 821C19A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C19AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C19B0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C19B4: 409A0008  bne cr6, 0x821c19bc
	if !ctx.cr[6].eq {
	pc = 0x821C19BC; continue 'dispatch;
	}
	// 821C19B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C19BC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C19C0: 809B00D0  lwz r4, 0xd0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 821C19C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C19C8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C19CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C19D0: 4E800421  bctrl
	ctx.lr = 0x821C19D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C19D4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C19D8: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C19DC: 409A0008  bne cr6, 0x821c19e4
	if !ctx.cr[6].eq {
	pc = 0x821C19E4; continue 'dispatch;
	}
	// 821C19E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C19E4: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C19E8: 4BFFFF98  b 0x821c1980
	pc = 0x821C1980; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C19F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C19F0 size=972
    let mut pc: u32 = 0x821C19F0;
    'dispatch: loop {
        match pc {
            0x821C19F0 => {
    //   block [0x821C19F0..0x821C1DBC)
	// 821C19F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C19F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C19F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C19FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C1A00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1A04: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C1A08: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 821C1A0C: 394B2390  addi r10, r11, 0x2390
	ctx.r[10].s64 = ctx.r[11].s64 + 9104;
	// 821C1A10: 3D00834B  lis r8, -0x7cb5
	ctx.r[8].s64 = -2092236800;
	// 821C1A14: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C1A18: 38687E70  addi r3, r8, 0x7e70
	ctx.r[3].s64 = ctx.r[8].s64 + 32368;
	// 821C1A1C: 83E90364  lwz r31, 0x364(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C1A20: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821C1A24: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1A28: 38CA2008  addi r6, r10, 0x2008
	ctx.r[6].s64 = ctx.r[10].s64 + 8200;
	// 821C1A2C: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 821C1A30: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821C1A34: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1A38: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C1A3C: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 821C1A40: 38890DB8  addi r4, r9, 0xdb8
	ctx.r[4].s64 = ctx.r[9].s64 + 3512;
	// 821C1A44: 7C67512E  stwx r3, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 821C1A48: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1A4C: 80EA2000  lwz r7, 0x2000(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1A50: 812A400C  lwz r9, 0x400c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821C1A54: 553E1838  slwi r30, r9, 3
	ctx.r[30].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821C1A58: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 821C1A5C: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1A60: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C1A64: 910A2000  stw r8, 0x2000(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8192 as u32), ctx.r[8].u32 ) };
	// 821C1A68: 7C7E312E  stwx r3, r30, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[6].u32), ctx.r[3].u32) };
	// 821C1A6C: 886B1A6D  lbz r3, 0x1a6d(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6765 as u32) ) } as u64;
	// 821C1A70: 80EA4008  lwz r7, 0x4008(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821C1A74: 80CB1A5C  lwz r6, 0x1a5c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821C1A78: 810A400C  lwz r8, 0x400c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821C1A7C: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 821C1A80: 1D032008  mulli r8, r3, 0x2008
	ctx.r[8].s64 = ctx.r[3].s64 * 8200;
	// 821C1A84: 912A400C  stw r9, 0x400c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16396 as u32), ctx.r[9].u32 ) };
	// 821C1A88: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C1A8C: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1A90: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821C1A94: 910A4008  stw r8, 0x4008(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16392 as u32), ctx.r[8].u32 ) };
	// 821C1A98: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C1A9C: 419A0088  beq cr6, 0x821c1b24
	if ctx.cr[6].eq {
	pc = 0x821C1B24; continue 'dispatch;
	}
	// 821C1AA0: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1AA4: 80EB1A60  lwz r7, 0x1a60(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6752 as u32) ) } as u64;
	// 821C1AA8: 7D063838  and r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821C1AAC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C1AB0: 409A003C  bne cr6, 0x821c1aec
	if !ctx.cr[6].eq {
	pc = 0x821C1AEC; continue 'dispatch;
	}
	// 821C1AB4: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1AB8: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821C1ABC: 386B1A58  addi r3, r11, 0x1a58
	ctx.r[3].s64 = ctx.r[11].s64 + 6744;
	// 821C1AC0: 54C71838  slwi r7, r6, 3
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1AC4: 910B1A60  stw r8, 0x1a60(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6752 as u32), ctx.r[8].u32 ) };
	// 821C1AC8: 7C67492E  stwx r3, r7, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), ctx.r[3].u32) };
	// 821C1ACC: 810B1A5C  lwz r8, 0x1a5c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821C1AD0: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1AD4: 54C71838  slwi r7, r6, 3
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1AD8: 7C674A14  add r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821C1ADC: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821C1AE0: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1AE4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821C1AE8: 91092004  stw r8, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821C1AEC: 892B1A6C  lbz r9, 0x1a6c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6764 as u32) ) } as u64;
	// 821C1AF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821C1AF4: 910B1A5C  stw r8, 0x1a5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6748 as u32), ctx.r[8].u32 ) };
	// 821C1AF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C1AFC: 409A0028  bne cr6, 0x821c1b24
	if !ctx.cr[6].eq {
	pc = 0x821C1B24; continue 'dispatch;
	}
	// 821C1B00: 81250DB0  lwz r9, 0xdb0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C1B04: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821C1B08: 38EB1A58  addi r7, r11, 0x1a58
	ctx.r[7].s64 = ctx.r[11].s64 + 6744;
	// 821C1B0C: 5523103A  slwi r3, r9, 2
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C1B10: 990B1A6C  stb r8, 0x1a6c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6764 as u32), ctx.r[8].u8 ) };
	// 821C1B14: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821C1B18: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C1B1C: 7CE3212E  stwx r7, r3, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821C1B20: 48000008  b 0x821c1b28
	pc = 0x821C1B28; continue 'dispatch;
	// 821C1B24: 80C50DB0  lwz r6, 0xdb0(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C1B28: 892B1A85  lbz r9, 0x1a85(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6789 as u32) ) } as u64;
	// 821C1B2C: 810B1A74  lwz r8, 0x1a74(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821C1B30: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s64 = ctx.r[9].s64 * 8200;
	// 821C1B34: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C1B38: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821C1B3C: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821C1B40: 419A0080  beq cr6, 0x821c1bc0
	if ctx.cr[6].eq {
	pc = 0x821C1BC0; continue 'dispatch;
	}
	// 821C1B44: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1B48: 80EB1A78  lwz r7, 0x1a78(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6776 as u32) ) } as u64;
	// 821C1B4C: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821C1B50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C1B54: 409A003C  bne cr6, 0x821c1b90
	if !ctx.cr[6].eq {
	pc = 0x821C1B90; continue 'dispatch;
	}
	// 821C1B58: 80692004  lwz r3, 0x2004(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1B5C: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821C1B60: 38EB1A70  addi r7, r11, 0x1a70
	ctx.r[7].s64 = ctx.r[11].s64 + 6768;
	// 821C1B64: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C1B68: 910B1A78  stw r8, 0x1a78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6776 as u32), ctx.r[8].u32 ) };
	// 821C1B6C: 7CE3492E  stwx r7, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821C1B70: 810B1A74  lwz r8, 0x1a74(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821C1B74: 80E92004  lwz r7, 0x2004(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1B78: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1B7C: 7C674A14  add r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821C1B80: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821C1B84: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1B88: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821C1B8C: 91092004  stw r8, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821C1B90: 892B1A84  lbz r9, 0x1a84(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6788 as u32) ) } as u64;
	// 821C1B94: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821C1B98: 910B1A74  stw r8, 0x1a74(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6772 as u32), ctx.r[8].u32 ) };
	// 821C1B9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C1BA0: 409A0020  bne cr6, 0x821c1bc0
	if !ctx.cr[6].eq {
	pc = 0x821C1BC0; continue 'dispatch;
	}
	// 821C1BA4: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1BA8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C1BAC: 38EB1A70  addi r7, r11, 0x1a70
	ctx.r[7].s64 = ctx.r[11].s64 + 6768;
	// 821C1BB0: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C1BB4: 992B1A84  stb r9, 0x1a84(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6788 as u32), ctx.r[9].u8 ) };
	// 821C1BB8: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C1BBC: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821C1BC0: 892B1AB5  lbz r9, 0x1ab5(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6837 as u32) ) } as u64;
	// 821C1BC4: 810B1AA4  lwz r8, 0x1aa4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821C1BC8: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s64 = ctx.r[9].s64 * 8200;
	// 821C1BCC: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C1BD0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C1BD4: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821C1BD8: 419A0080  beq cr6, 0x821c1c58
	if ctx.cr[6].eq {
	pc = 0x821C1C58; continue 'dispatch;
	}
	// 821C1BDC: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1BE0: 80EB1AA8  lwz r7, 0x1aa8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6824 as u32) ) } as u64;
	// 821C1BE4: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821C1BE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C1BEC: 409A003C  bne cr6, 0x821c1c28
	if !ctx.cr[6].eq {
	pc = 0x821C1C28; continue 'dispatch;
	}
	// 821C1BF0: 80692004  lwz r3, 0x2004(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1BF4: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821C1BF8: 38EB1AA0  addi r7, r11, 0x1aa0
	ctx.r[7].s64 = ctx.r[11].s64 + 6816;
	// 821C1BFC: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C1C00: 910B1AA8  stw r8, 0x1aa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6824 as u32), ctx.r[8].u32 ) };
	// 821C1C04: 7CE3492E  stwx r7, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821C1C08: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1C0C: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1C10: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821C1C14: 810B1AA4  lwz r8, 0x1aa4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821C1C18: 91070004  stw r8, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821C1C1C: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1C20: 38680001  addi r3, r8, 1
	ctx.r[3].s64 = ctx.r[8].s64 + 1;
	// 821C1C24: 90692004  stw r3, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	// 821C1C28: 892B1AB4  lbz r9, 0x1ab4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6836 as u32) ) } as u64;
	// 821C1C2C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821C1C30: 910B1AA4  stw r8, 0x1aa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6820 as u32), ctx.r[8].u32 ) };
	// 821C1C34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C1C38: 409A0020  bne cr6, 0x821c1c58
	if !ctx.cr[6].eq {
	pc = 0x821C1C58; continue 'dispatch;
	}
	// 821C1C3C: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1C40: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C1C44: 38EB1AA0  addi r7, r11, 0x1aa0
	ctx.r[7].s64 = ctx.r[11].s64 + 6816;
	// 821C1C48: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C1C4C: 992B1AB4  stb r9, 0x1ab4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6836 as u32), ctx.r[9].u8 ) };
	// 821C1C50: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C1C54: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821C1C58: 3CE08331  lis r7, -0x7ccf
	ctx.r[7].s64 = -2093940736;
	// 821C1C5C: 886B1A9D  lbz r3, 0x1a9d(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6813 as u32) ) } as u64;
	// 821C1C60: 810B1A8C  lwz r8, 0x1a8c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821C1C64: 38E76FB8  addi r7, r7, 0x6fb8
	ctx.r[7].s64 = ctx.r[7].s64 + 28600;
	// 821C1C68: 1D232008  mulli r9, r3, 0x2008
	ctx.r[9].s64 = ctx.r[3].s64 * 8200;
	// 821C1C6C: 80E70004  lwz r7, 4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C1C70: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C1C74: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C1C78: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C1C7C: 419A007C  beq cr6, 0x821c1cf8
	if ctx.cr[6].eq {
	pc = 0x821C1CF8; continue 'dispatch;
	}
	// 821C1C80: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1C84: 810B1A90  lwz r8, 0x1a90(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821C1C88: 7D234038  and r3, r9, r8
	ctx.r[3].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C1C8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C1C90: 409A003C  bne cr6, 0x821c1ccc
	if !ctx.cr[6].eq {
	pc = 0x821C1CCC; continue 'dispatch;
	}
	// 821C1C94: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1C98: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C1C9C: 390B1A88  addi r8, r11, 0x1a88
	ctx.r[8].s64 = ctx.r[11].s64 + 6792;
	// 821C1CA0: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C1CA4: 912B1A90  stw r9, 0x1a90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6800 as u32), ctx.r[9].u32 ) };
	// 821C1CA8: 7D03512E  stwx r8, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C1CAC: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1CB0: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1CB4: 812B1A8C  lwz r9, 0x1a8c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821C1CB8: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C1CBC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C1CC0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1CC4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C1CC8: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C1CCC: 894B1A9C  lbz r10, 0x1a9c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6812 as u32) ) } as u64;
	// 821C1CD0: 90EB1A8C  stw r7, 0x1a8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6796 as u32), ctx.r[7].u32 ) };
	// 821C1CD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C1CD8: 409A0020  bne cr6, 0x821c1cf8
	if !ctx.cr[6].eq {
	pc = 0x821C1CF8; continue 'dispatch;
	}
	// 821C1CDC: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1CE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C1CE4: 38EB1A88  addi r7, r11, 0x1a88
	ctx.r[7].s64 = ctx.r[11].s64 + 6792;
	// 821C1CE8: 39260001  addi r9, r6, 1
	ctx.r[9].s64 = ctx.r[6].s64 + 1;
	// 821C1CEC: 994B1A9C  stb r10, 0x1a9c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6812 as u32), ctx.r[10].u8 ) };
	// 821C1CF0: 91250DB0  stw r9, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 821C1CF4: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821C1CF8: 4805C7A9  bl 0x8221e4a0
	ctx.lr = 0x821C1CFC;
	sub_8221E4A0(ctx, base);
	// 821C1CFC: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C1D00: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C1D04: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C1D08: 4099000C  ble cr6, 0x821c1d14
	if !ctx.cr[6].gt {
	pc = 0x821C1D14; continue 'dispatch;
	}
	// 821C1D0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C1D10: 480271B1  bl 0x821e8ec0
	ctx.lr = 0x821C1D14;
	sub_821E8EC0(ctx, base);
	// 821C1D14: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821C1D18: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821C1D1C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821C1D20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C1D24: 3CC0C000  lis r6, -0x4000
	ctx.r[6].s64 = -1073741824;
	// 821C1D28: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C1DC0 size=120
    let mut pc: u32 = 0x821C1DC0;
    'dispatch: loop {
        match pc {
            0x821C1DC0 => {
    //   block [0x821C1DC0..0x821C1E38)
	// 821C1DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C1DC4: 48AE7649  bl 0x82ca940c
	ctx.lr = 0x821C1DC8;
	sub_82CA93D0(ctx, base);
	// 821C1DC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1DCC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C1DD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C1DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C1DD8: 409A0010  bne cr6, 0x821c1de8
	if !ctx.cr[6].eq {
	pc = 0x821C1DE8; continue 'dispatch;
	}
	// 821C1DDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821C1DE0: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821C1DE4: 48000008  b 0x821c1dec
	pc = 0x821C1DEC; continue 'dispatch;
	// 821C1DE8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C1DEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C1DF0: 48130151  bl 0x822f1f40
	ctx.lr = 0x821C1DF4;
	sub_822F1F40(ctx, base);
	// 821C1DF4: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821C1DF8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C1DFC: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 821C1E00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C1E04: 40980008  bge cr6, 0x821c1e0c
	if !ctx.cr[6].lt {
	pc = 0x821C1E0C; continue 'dispatch;
	}
	// 821C1E08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821C1E0C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 821C1E10: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 821C1E14: 48031F45  bl 0x821f3d58
	ctx.lr = 0x821C1E18;
	sub_821F3D58(ctx, base);
	// 821C1E18: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821C1E1C: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 821C1E20: 4198000C  blt cr6, 0x821c1e2c
	if ctx.cr[6].lt {
	pc = 0x821C1E2C; continue 'dispatch;
	}
	// 821C1E24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C1E28: 48059F11  bl 0x8221bd38
	ctx.lr = 0x821C1E2C;
	sub_8221BD38(ctx, base);
	// 821C1E2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C1E30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C1E34: 48AE7628  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C1E38 size=372
    let mut pc: u32 = 0x821C1E38;
    'dispatch: loop {
        match pc {
            0x821C1E38 => {
    //   block [0x821C1E38..0x821C1FAC)
	// 821C1E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C1E3C: 48AE75CD  bl 0x82ca9408
	ctx.lr = 0x821C1E40;
	sub_82CA93D0(ctx, base);
	// 821C1E40: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821C1E44: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1E48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C1E4C: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 821C1E50: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 821C1E54: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 821C1E58: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C1FB0 size=68
    let mut pc: u32 = 0x821C1FB0;
    'dispatch: loop {
        match pc {
            0x821C1FB0 => {
    //   block [0x821C1FB0..0x821C1FF4)
	// 821C1FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C1FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C1FB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C1FBC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1FC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C1FC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C1FC8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C1FCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C1FD0: 480C1D61  bl 0x82283d30
	ctx.lr = 0x821C1FD4;
	sub_82283D30(ctx, base);
	// 821C1FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C1FD8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C1FDC: 480B107D  bl 0x82273058
	ctx.lr = 0x821C1FE0;
	sub_82273058(ctx, base);
	// 821C1FE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C1FE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C1FE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C1FEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C1FF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C1FF8 size=136
    let mut pc: u32 = 0x821C1FF8;
    'dispatch: loop {
        match pc {
            0x821C1FF8 => {
    //   block [0x821C1FF8..0x821C2080)
	// 821C1FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C1FFC: 48AE7411  bl 0x82ca940c
	ctx.lr = 0x821C2000;
	sub_82CA93D0(ctx, base);
	// 821C2000: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2004: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821C2008: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C200C: 480660ED  bl 0x822280f8
	ctx.lr = 0x821C2010;
	sub_822280F8(ctx, base);
	// 821C2010: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821C2014: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C2018: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C201C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821C2020: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C2028: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821C202C: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C2030: 48630641  bl 0x827f2670
	ctx.lr = 0x821C2034;
	sub_827F2670(ctx, base);
	// 821C2034: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821C2038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C203C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821C2040: 4E800421  bctrl
	ctx.lr = 0x821C2044;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C2044: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 821C2048: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C204C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821C2050: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 821C2054: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C2058: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821C205C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C2060: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821C2064: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821C2068: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821C206C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2070: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 821C2074: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821C2078: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C207C: 48AE73E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C2080 size=2076
    let mut pc: u32 = 0x821C2080;
    'dispatch: loop {
        match pc {
            0x821C2080 => {
    //   block [0x821C2080..0x821C289C)
	// 821C2080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2084: 48AE7385  bl 0x82ca9408
	ctx.lr = 0x821C2088;
	sub_82CA93D0(ctx, base);
	// 821C2088: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821C208C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821C2090: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2094: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821C2098: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821C209C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821C20A0: 419A0018  beq cr6, 0x821c20b8
	if ctx.cr[6].eq {
	pc = 0x821C20B8; continue 'dispatch;
	}
	// 821C20A4: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C20A8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C20AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C20B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C20B4: 409A0008  bne cr6, 0x821c20bc
	if !ctx.cr[6].eq {
	pc = 0x821C20BC; continue 'dispatch;
	}
	// 821C20B8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C20BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C20C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C20C4: 419A07BC  beq cr6, 0x821c2880
	if ctx.cr[6].eq {
	pc = 0x821C2880; continue 'dispatch;
	}
	// 821C20C8: 80BD002C  lwz r5, 0x2c(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 821C20CC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C20D0: 54AA8FFE  rlwinm r10, r5, 0x11, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x00007FFFu64;
	// 821C20D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C20D8: 419A00E8  beq cr6, 0x821c21c0
	if ctx.cr[6].eq {
	pc = 0x821C21C0; continue 'dispatch;
	}
	// 821C20DC: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C20E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C20E4: 419A0020  beq cr6, 0x821c2104
	if ctx.cr[6].eq {
	pc = 0x821C2104; continue 'dispatch;
	}
	// 821C20E8: 894B004F  lbz r10, 0x4f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(79 as u32) ) } as u64;
	// 821C20EC: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C20F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C20F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C20F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C20FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2100: 480000C4  b 0x821c21c4
	pc = 0x821C21C4; continue 'dispatch;
	// 821C2104: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2108: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C210C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C2110: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C2114: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2118: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C211C: 40810054  ble 0x821c2170
	if !ctx.cr[0].gt {
	pc = 0x821C2170; continue 'dispatch;
	}
	// 821C2120: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C2124: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C2128: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C212C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2130: 2F07004F  cmpwi cr6, r7, 0x4f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 79, &mut ctx.xer);
	// 821C2134: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C2138: 41980008  blt cr6, 0x821c2140
	if ctx.cr[6].lt {
	pc = 0x821C2140; continue 'dispatch;
	}
	// 821C213C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821C2140: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C2144: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C2148: 419A0014  beq cr6, 0x821c215c
	if ctx.cr[6].eq {
	pc = 0x821C215C; continue 'dispatch;
	}
	// 821C214C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C2150: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C2154: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C2158: 4800000C  b 0x821c2164
	pc = 0x821C2164; continue 'dispatch;
	// 821C215C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C2160: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C2164: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2168: 4199FFB8  bgt cr6, 0x821c2120
	if ctx.cr[6].gt {
	pc = 0x821C2120; continue 'dispatch;
	}
	// 821C216C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2170: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C2174: 419A003C  beq cr6, 0x821c21b0
	if ctx.cr[6].eq {
	pc = 0x821C21B0; continue 'dispatch;
	}
	// 821C2178: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C217C: 2F0B004F  cmpwi cr6, r11, 0x4f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 79, &mut ctx.xer);
	// 821C2180: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2184: 41990008  bgt cr6, 0x821c218c
	if ctx.cr[6].gt {
	pc = 0x821C218C; continue 'dispatch;
	}
	// 821C2188: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C218C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C2190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2194: 409A001C  bne cr6, 0x821c21b0
	if !ctx.cr[6].eq {
	pc = 0x821C21B0; continue 'dispatch;
	}
	// 821C2198: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C219C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C21A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C21A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C21A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C21AC: 48000018  b 0x821c21c4
	pc = 0x821C21C4; continue 'dispatch;
	// 821C21B0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C21B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C21B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C21BC: 48000008  b 0x821c21c4
	pc = 0x821C21C4; continue 'dispatch;
	// 821C21C0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821C21C4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C21C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C21CC: 419A0010  beq cr6, 0x821c21dc
	if ctx.cr[6].eq {
	pc = 0x821C21DC; continue 'dispatch;
	}
	// 821C21D0: 896B003B  lbz r11, 0x3b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 821C21D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C21D8: 409A0014  bne cr6, 0x821c21ec
	if !ctx.cr[6].eq {
	pc = 0x821C21EC; continue 'dispatch;
	}
	// 821C21DC: 83DD0030  lwz r30, 0x30(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C21E0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 821C21E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C21E8: 419A00F4  beq cr6, 0x821c22dc
	if ctx.cr[6].eq {
	pc = 0x821C22DC; continue 'dispatch;
	}
	// 821C21EC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C21F0: 809D007C  lwz r4, 0x7c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C21F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C21F8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C21FC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2200: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C2204: 810A0040  lwz r8, 0x40(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C2208: 80E90058  lwz r7, 0x58(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C220C: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2210: 83E60008  lwz r31, 8(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2214: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821C2218: 4E800421  bctrl
	ctx.lr = 0x821C221C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C221C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2220: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C2224: 3BCBB730  addi r30, r11, -0x48d0
	ctx.r[30].s64 = ctx.r[11].s64 + -18640;
	// 821C2228: C3FEDD54  lfs f31, -0x22ac(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8876 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C222C: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C2230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2234: 419A001C  beq cr6, 0x821c2250
	if ctx.cr[6].eq {
	pc = 0x821C2250; continue 'dispatch;
	}
	// 821C2238: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C223C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C28A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C28A0 size=372
    let mut pc: u32 = 0x821C28A0;
    'dispatch: loop {
        match pc {
            0x821C28A0 => {
    //   block [0x821C28A0..0x821C2A14)
	// 821C28A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C28A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C28A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C28AC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C28B0: 419A0018  beq cr6, 0x821c28c8
	if ctx.cr[6].eq {
	pc = 0x821C28C8; continue 'dispatch;
	}
	// 821C28B4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C28B8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C28BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C28C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C28C4: 409A0008  bne cr6, 0x821c28cc
	if !ctx.cr[6].eq {
	pc = 0x821C28CC; continue 'dispatch;
	}
	// 821C28C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C28CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C28D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C28D4: 419A012C  beq cr6, 0x821c2a00
	if ctx.cr[6].eq {
	pc = 0x821C2A00; continue 'dispatch;
	}
	// 821C28D8: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C28DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C28E0: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 821C28E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C28E8: 419A00E8  beq cr6, 0x821c29d0
	if ctx.cr[6].eq {
	pc = 0x821C29D0; continue 'dispatch;
	}
	// 821C28EC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C28F0: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C28F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C28F8: 419A001C  beq cr6, 0x821c2914
	if ctx.cr[6].eq {
	pc = 0x821C2914; continue 'dispatch;
	}
	// 821C28FC: 896B007A  lbz r11, 0x7a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 821C2900: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821C2904: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C2908: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C290C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2910: 480000C4  b 0x821c29d4
	pc = 0x821C29D4; continue 'dispatch;
	// 821C2914: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C2918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C291C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2920: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C2924: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C2928: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C292C: 40810054  ble 0x821c2980
	if !ctx.cr[0].gt {
	pc = 0x821C2980; continue 'dispatch;
	}
	// 821C2930: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C2934: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C2938: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C293C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2940: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 821C2944: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C2948: 41980008  blt cr6, 0x821c2950
	if ctx.cr[6].lt {
	pc = 0x821C2950; continue 'dispatch;
	}
	// 821C294C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821C2950: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C2954: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C2958: 419A0014  beq cr6, 0x821c296c
	if ctx.cr[6].eq {
	pc = 0x821C296C; continue 'dispatch;
	}
	// 821C295C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C2960: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C2964: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C2968: 4800000C  b 0x821c2974
	pc = 0x821C2974; continue 'dispatch;
	// 821C296C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C2970: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C2974: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2978: 4199FFB8  bgt cr6, 0x821c2930
	if ctx.cr[6].gt {
	pc = 0x821C2930; continue 'dispatch;
	}
	// 821C297C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2980: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C2984: 419A003C  beq cr6, 0x821c29c0
	if ctx.cr[6].eq {
	pc = 0x821C29C0; continue 'dispatch;
	}
	// 821C2988: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C298C: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 821C2990: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2994: 41990008  bgt cr6, 0x821c299c
	if ctx.cr[6].gt {
	pc = 0x821C299C; continue 'dispatch;
	}
	// 821C2998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C299C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C29A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C29A4: 409A001C  bne cr6, 0x821c29c0
	if !ctx.cr[6].eq {
	pc = 0x821C29C0; continue 'dispatch;
	}
	// 821C29A8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C29AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C29B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C29B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C29B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C29BC: 48000018  b 0x821c29d4
	pc = 0x821C29D4; continue 'dispatch;
	// 821C29C0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C29C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C29C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C29CC: 48000008  b 0x821c29d4
	pc = 0x821C29D4; continue 'dispatch;
	// 821C29D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C29D4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C29D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C29DC: 419A0024  beq cr6, 0x821c2a00
	if ctx.cr[6].eq {
	pc = 0x821C2A00; continue 'dispatch;
	}
	// 821C29E0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C29E4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C29E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C29EC: 4E800421  bctrl
	ctx.lr = 0x821C29F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C29F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C29F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C29F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C29FC: 4E800020  blr
	return;
	// 821C2A00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C2A04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C2A08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C2A0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C2A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C2A18 size=32
    let mut pc: u32 = 0x821C2A18;
    'dispatch: loop {
        match pc {
            0x821C2A18 => {
    //   block [0x821C2A18..0x821C2A38)
	// 821C2A18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C2A1C: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2A20: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 821C2A24: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C2A28: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821C2A2C: 4098000C  bge cr6, 0x821c2a38
	if !ctx.cr[6].lt {
		sub_821C2A38(ctx, base);
		return;
	}
	// 821C2A30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C2A34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C2A38 size=20
    let mut pc: u32 = 0x821C2A38;
    'dispatch: loop {
        match pc {
            0x821C2A38 => {
    //   block [0x821C2A38..0x821C2A4C)
	// 821C2A38: C1AB4C4C  lfs f13, 0x4c4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C2A3C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821C2A40: 4098000C  bge cr6, 0x821c2a4c
	if !ctx.cr[6].lt {
		sub_821C2A4C(ctx, base);
		return;
	}
	// 821C2A44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C2A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2A4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C2A4C size=16
    let mut pc: u32 = 0x821C2A4C;
    'dispatch: loop {
        match pc {
            0x821C2A4C => {
    //   block [0x821C2A4C..0x821C2A5C)
	// 821C2A4C: C1AB4C50  lfs f13, 0x4c50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19536 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C2A50: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821C2A54: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821C2A58: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2A5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C2A5C size=8
    let mut pc: u32 = 0x821C2A5C;
    'dispatch: loop {
        match pc {
            0x821C2A5C => {
    //   block [0x821C2A5C..0x821C2A64)
	// 821C2A5C: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821C2A60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C2A68 size=700
    let mut pc: u32 = 0x821C2A68;
    'dispatch: loop {
        match pc {
            0x821C2A68 => {
    //   block [0x821C2A68..0x821C2D24)
	// 821C2A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2A6C: 48AE6991  bl 0x82ca93fc
	ctx.lr = 0x821C2A70;
	sub_82CA93D0(ctx, base);
	// 821C2A70: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C2A78: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821C2A7C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 821C2A80: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821C2A84: 933F0040  stw r25, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[25].u32 ) };
	// 821C2A88: 48852309  bl 0x82a14d90
	ctx.lr = 0x821C2A8C;
	sub_82A14D90(ctx, base);
	// 821C2A8C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C2A90: 3B80001C  li r28, 0x1c
	ctx.r[28].s64 = 28;
	// 821C2A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2A98: 409A01AC  bne cr6, 0x821c2c44
	if !ctx.cr[6].eq {
	pc = 0x821C2C44; continue 'dispatch;
	}
	// 821C2A9C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C2AA0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C2AA4: 811F0038  lwz r8, 0x38(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C2AA8: 7CE95050  subf r7, r9, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C2AAC: 7CC7E3D6  divw r6, r7, r28
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[28].s32;
	// 821C2AB0: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C2AB4: 4198002C  blt cr6, 0x821c2ae0
	if ctx.cr[6].lt {
	pc = 0x821C2AE0; continue 'dispatch;
	}
	// 821C2AB8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821C2ABC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C2AC0: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 821C2AC4: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2AC8: 932A0004  stw r25, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 821C2ACC: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2AD0: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821C2AD4: 913A0008  stw r9, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C2AD8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821C2ADC: 48AE6970  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 821C2AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2AE4: 409A0160  bne cr6, 0x821c2c44
	if !ctx.cr[6].eq {
	pc = 0x821C2C44; continue 'dispatch;
	}
	// 821C2AE8: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C2AEC: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 821C2AF0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C2AF4: 3BDF0038  addi r30, r31, 0x38
	ctx.r[30].s64 = ctx.r[31].s64 + 56;
	// 821C2AF8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C2AFC: 1D0B001C  mulli r8, r11, 0x1c
	ctx.r[8].s64 = ctx.r[11].s64 * 28;
	// 821C2B00: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 821C2B04: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C2B08: 7CA6E3D6  divw r5, r6, r28
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[28].s32;
	// 821C2B0C: 7F68382E  lwzx r27, r8, r7
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821C2B10: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821C2B14: 40980060  bge cr6, 0x821c2b74
	if !ctx.cr[6].lt {
	pc = 0x821C2B74; continue 'dispatch;
	}
	// 821C2B18: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2B1C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C2B20: 1D2B001C  mulli r9, r11, 0x1c
	ctx.r[9].s64 = ctx.r[11].s64 * 28;
	// 821C2B24: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821C2B28: 7F08D800  cmpw cr6, r8, r27
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[27].s32, &mut ctx.xer);
	// 821C2B2C: 409A0048  bne cr6, 0x821c2b74
	if !ctx.cr[6].eq {
	pc = 0x821C2B74; continue 'dispatch;
	}
	// 821C2B30: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 821C2B34: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C2B38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821C2B3C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821C2B40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C2B44: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2B48: 488D4821  bl 0x82a97368
	ctx.lr = 0x821C2B4C;
	sub_82A97368(ctx, base);
	// 821C2B4C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2B50: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821C2B54: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821C2B58: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C2B5C: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2B60: 80FD0004  lwz r7, 4(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2B64: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 821C2B68: 7CA6E3D6  divw r5, r6, r28
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[28].s32;
	// 821C2B6C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821C2B70: 4198FFA8  blt cr6, 0x821c2b18
	if ctx.cr[6].lt {
	pc = 0x821C2B18; continue 'dispatch;
	}
	// 821C2B74: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C2B78: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 821C2B7C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C2B80: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 821C2B84: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 821C2B88: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2B8C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821C2B90: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C2B94: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C2B98: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2B9C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821C2BA0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821C2BA4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821C2BA8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C2BAC: 419A001C  beq cr6, 0x821c2bc8
	if ctx.cr[6].eq {
	pc = 0x821C2BC8; continue 'dispatch;
	}
	// 821C2BB0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2BB4: 811F0034  lwz r8, 0x34(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C2BB8: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821C2BBC: 419A000C  beq cr6, 0x821c2bc8
	if ctx.cr[6].eq {
	pc = 0x821C2BC8; continue 'dispatch;
	}
	// 821C2BC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2BC4: 4BFFFFE4  b 0x821c2ba8
	pc = 0x821C2BA8; continue 'dispatch;
	// 821C2BC8: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821C2BCC: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C2BD0: 419A0008  beq cr6, 0x821c2bd8
	if ctx.cr[6].eq {
	pc = 0x821C2BD8; continue 'dispatch;
	}
	// 821C2BD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C2BD8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C2BDC: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2BE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C2BE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2BE8: 419A000C  beq cr6, 0x821c2bf4
	if ctx.cr[6].eq {
	pc = 0x821C2BF4; continue 'dispatch;
	}
	// 821C2BEC: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821C2BF0: 419A0008  beq cr6, 0x821c2bf8
	if ctx.cr[6].eq {
	pc = 0x821C2BF8; continue 'dispatch;
	}
	// 821C2BF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C2BF8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C2BFC: 419A0048  beq cr6, 0x821c2c44
	if ctx.cr[6].eq {
	pc = 0x821C2C44; continue 'dispatch;
	}
	// 821C2C00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2C04: 409A0008  bne cr6, 0x821c2c0c
	if !ctx.cr[6].eq {
	pc = 0x821C2C0C; continue 'dispatch;
	}
	// 821C2C08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C2C0C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2C10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C2C14: 409A0008  bne cr6, 0x821c2c1c
	if !ctx.cr[6].eq {
	pc = 0x821C2C1C; continue 'dispatch;
	}
	// 821C2C18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C2C1C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2C20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C2C24: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2C28: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 821C2C2C: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 821C2C30: 480172B9  bl 0x821d9ee8
	ctx.lr = 0x821C2C34;
	sub_821D9EE8(ctx, base);
	// 821C2C34: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 821C2C38: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821C2C3C: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821C2C40: 480000B4  b 0x821c2cf4
	pc = 0x821C2CF4; continue 'dispatch;
	// 821C2C44: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C2C48: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C2C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2C50: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C2C54: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C2C58: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C2C5C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2C60: 80E90078  lwz r7, 0x78(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(120 as u32) ) } as u64;
	// 821C2C64: 1D4724A1  mulli r10, r7, 0x24a1
	ctx.r[10].s64 = ctx.r[7].s64 * 9377;
	// 821C2C68: 38CA24DF  addi r6, r10, 0x24df
	ctx.r[6].s64 = ctx.r[10].s64 + 9439;
	// 821C2C6C: 54CA983E  rotlwi r10, r6, 0x13
	ctx.r[10].u64 = ((ctx.r[6].u32).rotate_left(19)) as u64;
	// 821C2C70: 91490078  stw r10, 0x78(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 821C2C74: 419A0014  beq cr6, 0x821c2c88
	if ctx.cr[6].eq {
	pc = 0x821C2C88; continue 'dispatch;
	}
	// 821C2C78: 7D2A5B96  divwu r9, r10, r11
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 821C2C7C: 7D0959D6  mullw r8, r9, r11
	ctx.r[8].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821C2C80: 7C885050  subf r4, r8, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C2C84: 48000008  b 0x821c2c8c
	pc = 0x821C2C8C; continue 'dispatch;
	// 821C2C88: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821C2C8C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C2C90: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 821C2C94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C2C98: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821C2C9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2CA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2CA4: 486CF5B5  bl 0x82892258
	ctx.lr = 0x821C2CA8;
	sub_82892258(ctx, base);
	// 821C2CA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C2CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2CB0: 409A0008  bne cr6, 0x821c2cb8
	if !ctx.cr[6].eq {
	pc = 0x821C2CB8; continue 'dispatch;
	}
	// 821C2CB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C2CB8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2CBC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C2CC0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C2CC4: 409A0008  bne cr6, 0x821c2ccc
	if !ctx.cr[6].eq {
	pc = 0x821C2CCC; continue 'dispatch;
	}
	// 821C2CC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C2CCC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2CD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C2CD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C2CD8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2CDC: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 821C2CE0: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 821C2CE4: 48017205  bl 0x821d9ee8
	ctx.lr = 0x821C2CE8;
	sub_821D9EE8(ctx, base);
	// 821C2CE8: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 821C2CEC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821C2CF0: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821C2CF4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821C2CF8: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2CFC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821C2D00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C2D04: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821C2D08: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821C2D0C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C2D10: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2D14: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821C2D18: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821C2D1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821C2D20: 48AE672C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C2D28 size=68
    let mut pc: u32 = 0x821C2D28;
    'dispatch: loop {
        match pc {
            0x821C2D28 => {
    //   block [0x821C2D28..0x821C2D6C)
	// 821C2D28: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C2D2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C2D30: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C2D34: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C2D38: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C2D3C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2D40: 810A0078  lwz r8, 0x78(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 821C2D44: 1D6824A1  mulli r11, r8, 0x24a1
	ctx.r[11].s64 = ctx.r[8].s64 * 9377;
	// 821C2D48: 38EB24DF  addi r7, r11, 0x24df
	ctx.r[7].s64 = ctx.r[11].s64 + 9439;
	// 821C2D4C: 54EB983E  rotlwi r11, r7, 0x13
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(19)) as u64;
	// 821C2D50: 916A0078  stw r11, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821C2D54: 419A0018  beq cr6, 0x821c2d6c
	if ctx.cr[6].eq {
		sub_821C2D6C(ctx, base);
		return;
	}
	// 821C2D58: 7D4B2396  divwu r10, r11, r4
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[4].u32;
	// 821C2D5C: 7D2A21D6  mullw r9, r10, r4
	ctx.r[9].s64 = (ctx.r[10].s32 as i64) * (ctx.r[4].s32 as i64);
	// 821C2D60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C2D64: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 821C2D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2D6C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C2D6C size=12
    let mut pc: u32 = 0x821C2D6C;
    'dispatch: loop {
        match pc {
            0x821C2D6C => {
    //   block [0x821C2D6C..0x821C2D78)
	// 821C2D6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C2D70: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 821C2D74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C2D78 size=284
    let mut pc: u32 = 0x821C2D78;
    'dispatch: loop {
        match pc {
            0x821C2D78 => {
    //   block [0x821C2D78..0x821C2E94)
	// 821C2D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C2D80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C2D84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C2D88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2D8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C2D90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C2D94: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2D98: 556A05AC  rlwinm r10, r11, 0, 0x16, 0x16
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C2D9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2DA0: 419A00B8  beq cr6, 0x821c2e58
	if ctx.cr[6].eq {
	pc = 0x821C2E58; continue 'dispatch;
	}
	// 821C2DA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C2DA8: 4801BDA1  bl 0x821deb48
	ctx.lr = 0x821C2DAC;
	sub_821DEB48(ctx, base);
	// 821C2DAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C2DB0: C1810068  lfs f12, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C2DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C2DB8: 394B92D4  addi r10, r11, -0x6d2c
	ctx.r[10].s64 = ctx.r[11].s64 + -27948;
	// 821C2DBC: C1410064  lfs f10, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821C2DC0: C12B92D4  lfs f9, -0x6d2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821C2DC4: C00A01B0  lfs f0, 0x1b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2DC8: EDA00272  fmuls f13, f0, f9
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 821C2DCC: ED0D502A  fadds f8, f13, f10
	ctx.f[8].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 821C2DD0: D1010054  stfs f8, 0x54(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821C2DD4: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2DD8: ED6C0028  fsubs f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 821C2DDC: ECEB0272  fmuls f7, f11, f9
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[9].f64) as f32) as f64);
	// 821C2DE0: ECC7002A  fadds f6, f7, f0
	ctx.f[6].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 821C2DE4: 4BFE7975  bl 0x821aa758
	ctx.lr = 0x821C2DE8;
	sub_821AA758(ctx, base);
	// 821C2DE8: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 821C2DEC: D101006C  stfs f8, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821C2DF0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821C2DF4: 80DF0048  lwz r6, 0x48(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2DF8: 38E9A63C  addi r7, r9, -0x59c4
	ctx.r[7].s64 = ctx.r[9].s64 + -22980;
	// 821C2DFC: 54C505EA  rlwinm r5, r6, 0, 0x17, 0x15
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821C2E00: C009A63C  lfs f0, -0x59c4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2E04: ECA10032  fmuls f5, f1, f0
	ctx.f[5].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821C2E08: C1A70004  lfs f13, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C2E0C: 90BF0048  stw r5, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[5].u32 ) };
	// 821C2E10: EC05327A  fmadds f0, f5, f9, f6
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[9].f64 + ctx.f[6].f64) as f32) as f64);
	// 821C2E14: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821C2E18: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2E1C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821C2E20: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 821C2E24: C0810054  lfs f4, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821C2E28: EC602828  fsubs f3, f0, f5
	ctx.f[3].f64 = (((ctx.f[0].f64 - ctx.f[5].f64) as f32) as f64);
	// 821C2E2C: EC41237C  fnmsubs f2, f1, f13, f4
	ctx.f[2].f64 = -(((ctx.f[1].f64 * ctx.f[13].f64 - ctx.f[4].f64) as f32) as f64);
	// 821C2E30: D0610060  stfs f3, 0x60(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821C2E34: D0410064  stfs f2, 0x64(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821C2E38: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C2E3C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2E40: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2E44: 80680008  lwz r3, 8(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2E48: 907F0134  stw r3, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[3].u32 ) };
	// 821C2E4C: 913F0130  stw r9, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[9].u32 ) };
	// 821C2E50: 915F012C  stw r10, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[10].u32 ) };
	// 821C2E54: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 821C2E58: C01F012C  lfs f0, 0x12c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2E5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C2E60: C1BF0130  lfs f13, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C2E64: C19F0134  lfs f12, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C2E68: C17F0138  lfs f11, 0x138(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821C2E6C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821C2E70: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821C2E74: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821C2E78: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821C2E7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C2E80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C2E84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C2E88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C2E8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C2E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C2E98 size=196
    let mut pc: u32 = 0x821C2E98;
    'dispatch: loop {
        match pc {
            0x821C2E98 => {
    //   block [0x821C2E98..0x821C2F5C)
	// 821C2E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C2EA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C2EA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2EA8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2EAC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C2EB0: 409A0088  bne cr6, 0x821c2f38
	if !ctx.cr[6].eq {
	pc = 0x821C2F38; continue 'dispatch;
	}
	// 821C2EB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C2EB8: 480DEAE1  bl 0x822a1998
	ctx.lr = 0x821C2EBC;
	sub_822A1998(ctx, base);
	// 821C2EBC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821C2EC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C2EC4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2EC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C2ECC: 4805BC25  bl 0x8221eaf0
	ctx.lr = 0x821C2ED0;
	sub_8221EAF0(ctx, base);
	// 821C2ED0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C2ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C2ED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2EDC: 419A0044  beq cr6, 0x821c2f20
	if ctx.cr[6].eq {
	pc = 0x821C2F20; continue 'dispatch;
	}
	// 821C2EE0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C2EE4: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821C2EE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C2EEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C2EF0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C2EF4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821C2EF8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C2EFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C2F00: 4082FFE8  bne 0x821c2ee8
	if !ctx.cr[0].eq {
	pc = 0x821C2EE8; continue 'dispatch;
	}
	// 821C2F04: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821C2F08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2F0C: 409A0014  bne cr6, 0x821c2f20
	if !ctx.cr[6].eq {
	pc = 0x821C2F20; continue 'dispatch;
	}
	// 821C2F10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2F14: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2F18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C2F1C: 4E800421  bctrl
	ctx.lr = 0x821C2F20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C2F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C2F24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C2F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C2F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C2F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C2F34: 4E800020  blr
	return;
	// 821C2F38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821C2F3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C2F40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C2F44: 4805BBAD  bl 0x8221eaf0
	ctx.lr = 0x821C2F48;
	sub_8221EAF0(ctx, base);
	// 821C2F48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C2F4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C2F50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C2F54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C2F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C2F60 size=396
    let mut pc: u32 = 0x821C2F60;
    'dispatch: loop {
        match pc {
            0x821C2F60 => {
    //   block [0x821C2F60..0x821C30EC)
	// 821C2F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2F64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C2F68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2F6C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821C2F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2F74: 419A0018  beq cr6, 0x821c2f8c
	if ctx.cr[6].eq {
	pc = 0x821C2F8C; continue 'dispatch;
	}
	// 821C2F78: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C2F7C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821C2F80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2F84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C2F88: 409A0008  bne cr6, 0x821c2f90
	if !ctx.cr[6].eq {
	pc = 0x821C2F90; continue 'dispatch;
	}
	// 821C2F8C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C2F90: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C2F94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2F98: 419A0140  beq cr6, 0x821c30d8
	if ctx.cr[6].eq {
	pc = 0x821C30D8; continue 'dispatch;
	}
	// 821C2F9C: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C2FA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C2FA4: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821C2FA8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C2FAC: 419A00F8  beq cr6, 0x821c30a4
	if ctx.cr[6].eq {
	pc = 0x821C30A4; continue 'dispatch;
	}
	// 821C2FB0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C2FB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2FB8: 419A0024  beq cr6, 0x821c2fdc
	if ctx.cr[6].eq {
	pc = 0x821C2FDC; continue 'dispatch;
	}
	// 821C2FBC: 892A0085  lbz r9, 0x85(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(133 as u32) ) } as u64;
	// 821C2FC0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2FC4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821C2FC8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C2FCC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2FD0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C2FD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2FD8: 480000D0  b 0x821c30a8
	pc = 0x821C30A8; continue 'dispatch;
	// 821C2FDC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2FE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C2FE4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C2FE8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821C2FEC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C2FF0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2FF4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2FF8: 40810054  ble 0x821c304c
	if !ctx.cr[0].gt {
	pc = 0x821C304C; continue 'dispatch;
	}
	// 821C2FFC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C3000: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C3004: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C3008: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C300C: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 821C3010: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C3014: 41980008  blt cr6, 0x821c301c
	if ctx.cr[6].lt {
	pc = 0x821C301C; continue 'dispatch;
	}
	// 821C3018: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821C301C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C3020: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C3024: 419A0014  beq cr6, 0x821c3038
	if ctx.cr[6].eq {
	pc = 0x821C3038; continue 'dispatch;
	}
	// 821C3028: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C302C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C3030: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C3034: 4800000C  b 0x821c3040
	pc = 0x821C3040; continue 'dispatch;
	// 821C3038: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C303C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C3040: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3044: 4199FFB8  bgt cr6, 0x821c2ffc
	if ctx.cr[6].gt {
	pc = 0x821C2FFC; continue 'dispatch;
	}
	// 821C3048: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C304C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C3050: 419A0040  beq cr6, 0x821c3090
	if ctx.cr[6].eq {
	pc = 0x821C3090; continue 'dispatch;
	}
	// 821C3054: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3058: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 821C305C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3060: 41990008  bgt cr6, 0x821c3068
	if ctx.cr[6].gt {
	pc = 0x821C3068; continue 'dispatch;
	}
	// 821C3064: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C3068: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C306C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3070: 409A0020  bne cr6, 0x821c3090
	if !ctx.cr[6].eq {
	pc = 0x821C3090; continue 'dispatch;
	}
	// 821C3074: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C3078: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C307C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C3080: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3084: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C3088: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C308C: 4800001C  b 0x821c30a8
	pc = 0x821C30A8; continue 'dispatch;
	// 821C3090: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C3094: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3098: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C309C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C30A0: 48000008  b 0x821c30a8
	pc = 0x821C30A8; continue 'dispatch;
	// 821C30A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C30A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C30AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C30B0: 419A0028  beq cr6, 0x821c30d8
	if ctx.cr[6].eq {
	pc = 0x821C30D8; continue 'dispatch;
	}
	// 821C30B4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C30B8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821C30BC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821C30C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821C30C4: 4E800421  bctrl
	ctx.lr = 0x821C30C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C30C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C30CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C30D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C30D4: 4E800020  blr
	return;
	// 821C30D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C30DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C30E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C30E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C30E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C30F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C30F0 size=44
    let mut pc: u32 = 0x821C30F0;
    'dispatch: loop {
        match pc {
            0x821C30F0 => {
    //   block [0x821C30F0..0x821C311C)
	// 821C30F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C30F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C30F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C30FC: 48040E9D  bl 0x82203f98
	ctx.lr = 0x821C3100;
	sub_82203F98(ctx, base);
	// 821C3100: 3963FFFE  addi r11, r3, -2
	ctx.r[11].s64 = ctx.r[3].s64 + -2;
	// 821C3104: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C3108: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C310C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C3110: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C3114: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C3118: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3120 size=252
    let mut pc: u32 = 0x821C3120;
    'dispatch: loop {
        match pc {
            0x821C3120 => {
    //   block [0x821C3120..0x821C321C)
	// 821C3120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C3128: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C312C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C3130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C3134: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C3138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C313C: 409A0030  bne cr6, 0x821c316c
	if !ctx.cr[6].eq {
	pc = 0x821C316C; continue 'dispatch;
	}
	// 821C3140: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C3144: C1BF0030  lfs f13, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C3148: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C314C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821C3150: 4098001C  bge cr6, 0x821c316c
	if !ctx.cr[6].lt {
	pc = 0x821C316C; continue 'dispatch;
	}
	// 821C3154: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C3158: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C315C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C3160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C3164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C3168: 4E800020  blr
	return;
	// 821C316C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3170: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 821C3174: 409A0054  bne cr6, 0x821c31c8
	if !ctx.cr[6].eq {
	pc = 0x821C31C8; continue 'dispatch;
	}
	// 821C3178: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C317C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 821C3180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3184: 419A0034  beq cr6, 0x821c31b8
	if ctx.cr[6].eq {
	pc = 0x821C31B8; continue 'dispatch;
	}
	// 821C3188: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C318C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3190: 419A0084  beq cr6, 0x821c3214
	if ctx.cr[6].eq {
	pc = 0x821C3214; continue 'dispatch;
	}
	// 821C3194: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C319C: 419A001C  beq cr6, 0x821c31b8
	if ctx.cr[6].eq {
	pc = 0x821C31B8; continue 'dispatch;
	}
	// 821C31A0: 4BFB0C99  bl 0x82173e38
	ctx.lr = 0x821C31A4;
	sub_82173E38(ctx, base);
	// 821C31A4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C31A8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C31AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C31B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C31B4: 409A0008  bne cr6, 0x821c31bc
	if !ctx.cr[6].eq {
	pc = 0x821C31BC; continue 'dispatch;
	}
	// 821C31B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C31BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C31C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C31C4: 419AFF90  beq cr6, 0x821c3154
	if ctx.cr[6].eq {
	pc = 0x821C3154; continue 'dispatch;
	}
	// 821C31C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C31CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C31D0: 4801BBD1  bl 0x821deda0
	ctx.lr = 0x821C31D4;
	sub_821DEDA0(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C3220 size=400
    let mut pc: u32 = 0x821C3220;
    'dispatch: loop {
        match pc {
            0x821C3220 => {
    //   block [0x821C3220..0x821C33B0)
	// 821C3220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C3228: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C322C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821C3230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3234: 419A0018  beq cr6, 0x821c324c
	if ctx.cr[6].eq {
	pc = 0x821C324C; continue 'dispatch;
	}
	// 821C3238: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C323C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821C3240: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C3244: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C3248: 409A0008  bne cr6, 0x821c3250
	if !ctx.cr[6].eq {
	pc = 0x821C3250; continue 'dispatch;
	}
	// 821C324C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C3250: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C3254: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3258: 419A0144  beq cr6, 0x821c339c
	if ctx.cr[6].eq {
	pc = 0x821C339C; continue 'dispatch;
	}
	// 821C325C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C3260: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C3264: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 821C3268: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C326C: 419A00F8  beq cr6, 0x821c3364
	if ctx.cr[6].eq {
	pc = 0x821C3364; continue 'dispatch;
	}
	// 821C3270: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C3274: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3278: 419A0024  beq cr6, 0x821c329c
	if ctx.cr[6].eq {
	pc = 0x821C329C; continue 'dispatch;
	}
	// 821C327C: 892A0022  lbz r9, 0x22(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 821C3280: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C3284: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821C3288: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C328C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3290: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C3294: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3298: 480000D0  b 0x821c3368
	pc = 0x821C3368; continue 'dispatch;
	// 821C329C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C32A0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C32A4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C32A8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821C32AC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C32B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C32B4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C32B8: 40810054  ble 0x821c330c
	if !ctx.cr[0].gt {
	pc = 0x821C330C; continue 'dispatch;
	}
	// 821C32BC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C32C0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C32C4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C32C8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C32CC: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 821C32D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C32D4: 41980008  blt cr6, 0x821c32dc
	if ctx.cr[6].lt {
	pc = 0x821C32DC; continue 'dispatch;
	}
	// 821C32D8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821C32DC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C32E0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C32E4: 419A0014  beq cr6, 0x821c32f8
	if ctx.cr[6].eq {
	pc = 0x821C32F8; continue 'dispatch;
	}
	// 821C32E8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C32EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C32F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C32F4: 4800000C  b 0x821c3300
	pc = 0x821C3300; continue 'dispatch;
	// 821C32F8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C32FC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C3300: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3304: 4199FFB8  bgt cr6, 0x821c32bc
	if ctx.cr[6].gt {
	pc = 0x821C32BC; continue 'dispatch;
	}
	// 821C3308: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C330C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C3310: 419A0040  beq cr6, 0x821c3350
	if ctx.cr[6].eq {
	pc = 0x821C3350; continue 'dispatch;
	}
	// 821C3314: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3318: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821C331C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3320: 41990008  bgt cr6, 0x821c3328
	if ctx.cr[6].gt {
	pc = 0x821C3328; continue 'dispatch;
	}
	// 821C3324: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C3328: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C332C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3330: 409A0020  bne cr6, 0x821c3350
	if !ctx.cr[6].eq {
	pc = 0x821C3350; continue 'dispatch;
	}
	// 821C3334: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C3338: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C333C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C3340: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3344: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C3348: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C334C: 4800001C  b 0x821c3368
	pc = 0x821C3368; continue 'dispatch;
	// 821C3350: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C3354: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3358: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C335C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3360: 48000008  b 0x821c3368
	pc = 0x821C3368; continue 'dispatch;
	// 821C3364: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C3368: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C336C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3370: 419A002C  beq cr6, 0x821c339c
	if ctx.cr[6].eq {
	pc = 0x821C339C; continue 'dispatch;
	}
	// 821C3374: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3378: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821C337C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C3380: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C3384: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C3388: 4E800421  bctrl
	ctx.lr = 0x821C338C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C338C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C3390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C3394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C3398: 4E800020  blr
	return;
	// 821C339C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C33A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C33A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C33A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C33AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C33B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C33B0 size=516
    let mut pc: u32 = 0x821C33B0;
    'dispatch: loop {
        match pc {
            0x821C33B0 => {
    //   block [0x821C33B0..0x821C35B4)
	// 821C33B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C33B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C33B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C33BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C33C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C33C4: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C33C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821C33CC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821C33D0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821C33D4: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C33D8: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821C33DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C33E0: 419A00D8  beq cr6, 0x821c34b8
	if ctx.cr[6].eq {
	pc = 0x821C34B8; continue 'dispatch;
	}
	// 821C33E4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C33E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C33EC: 419A001C  beq cr6, 0x821c3408
	if ctx.cr[6].eq {
	pc = 0x821C3408; continue 'dispatch;
	}
	// 821C33F0: 894B0085  lbz r10, 0x85(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(133 as u32) ) } as u64;
	// 821C33F4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C33F8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C33FC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C3400: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3404: 480000B0  b 0x821c34b4
	pc = 0x821C34B4; continue 'dispatch;
	// 821C3408: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C340C: 80BF004C  lwz r5, 0x4c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C3410: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821C3414: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821C3418: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C341C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3420: 40810054  ble 0x821c3474
	if !ctx.cr[0].gt {
	pc = 0x821C3474; continue 'dispatch;
	}
	// 821C3424: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C3428: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C342C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C3430: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3434: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 821C3438: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C343C: 41980008  blt cr6, 0x821c3444
	if ctx.cr[6].lt {
	pc = 0x821C3444; continue 'dispatch;
	}
	// 821C3440: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821C3444: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C3448: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C344C: 419A0014  beq cr6, 0x821c3460
	if ctx.cr[6].eq {
	pc = 0x821C3460; continue 'dispatch;
	}
	// 821C3450: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C3454: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C3458: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C345C: 4800000C  b 0x821c3468
	pc = 0x821C3468; continue 'dispatch;
	// 821C3460: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C3464: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C3468: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C346C: 4199FFB8  bgt cr6, 0x821c3424
	if ctx.cr[6].gt {
	pc = 0x821C3424; continue 'dispatch;
	}
	// 821C3470: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C3474: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821C3478: 419A0034  beq cr6, 0x821c34ac
	if ctx.cr[6].eq {
	pc = 0x821C34AC; continue 'dispatch;
	}
	// 821C347C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3480: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 821C3484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3488: 41990008  bgt cr6, 0x821c3490
	if ctx.cr[6].gt {
	pc = 0x821C3490; continue 'dispatch;
	}
	// 821C348C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821C3490: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C3494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3498: 409A0014  bne cr6, 0x821c34ac
	if !ctx.cr[6].eq {
	pc = 0x821C34AC; continue 'dispatch;
	}
	// 821C349C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C34A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C34A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C34A8: 48000008  b 0x821c34b0
	pc = 0x821C34B0; continue 'dispatch;
	// 821C34AC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821C34B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C34B4: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821C34B8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C34BC: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821C34C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C34C4: 419A00D4  beq cr6, 0x821c3598
	if ctx.cr[6].eq {
	pc = 0x821C3598; continue 'dispatch;
	}
	// 821C34C8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C34CC: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C34D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C34D4: 419A0018  beq cr6, 0x821c34ec
	if ctx.cr[6].eq {
	pc = 0x821C34EC; continue 'dispatch;
	}
	// 821C34D8: 896B0061  lbz r11, 0x61(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(97 as u32) ) } as u64;
	// 821C34DC: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821C34E0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C34E4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C34E8: 480000AC  b 0x821c3594
	pc = 0x821C3594; continue 'dispatch;
	// 821C34EC: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C34F0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821C34F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C34F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C34FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3500: 40810054  ble 0x821c3554
	if !ctx.cr[0].gt {
	pc = 0x821C3554; continue 'dispatch;
	}
	// 821C3504: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C3508: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C350C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C3510: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3514: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 821C3518: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C351C: 41980008  blt cr6, 0x821c3524
	if ctx.cr[6].lt {
	pc = 0x821C3524; continue 'dispatch;
	}
	// 821C3520: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821C3524: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C3528: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C352C: 419A0014  beq cr6, 0x821c3540
	if ctx.cr[6].eq {
	pc = 0x821C3540; continue 'dispatch;
	}
	// 821C3530: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C3534: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C3538: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C353C: 4800000C  b 0x821c3548
	pc = 0x821C3548; continue 'dispatch;
	// 821C3540: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C3544: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C3548: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C354C: 4199FFB8  bgt cr6, 0x821c3504
	if ctx.cr[6].gt {
	pc = 0x821C3504; continue 'dispatch;
	}
	// 821C3550: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C3554: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C3558: 419A0034  beq cr6, 0x821c358c
	if ctx.cr[6].eq {
	pc = 0x821C358C; continue 'dispatch;
	}
	// 821C355C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3560: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 821C3564: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3568: 41990008  bgt cr6, 0x821c3570
	if ctx.cr[6].gt {
	pc = 0x821C3570; continue 'dispatch;
	}
	// 821C356C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821C3570: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C3574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3578: 409A0014  bne cr6, 0x821c358c
	if !ctx.cr[6].eq {
	pc = 0x821C358C; continue 'dispatch;
	}
	// 821C357C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C3580: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C3584: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C3588: 48000008  b 0x821c3590
	pc = 0x821C3590; continue 'dispatch;
	// 821C358C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C3590: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3594: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821C3598: 480ADDD1  bl 0x82271368
	ctx.lr = 0x821C359C;
	sub_82271368(ctx, base);
	// 821C359C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C35A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C35A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C35A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C35AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C35B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C35B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C35B8 size=68
    let mut pc: u32 = 0x821C35B8;
    'dispatch: loop {
        match pc {
            0x821C35B8 => {
    //   block [0x821C35B8..0x821C35FC)
	// 821C35B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C35BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C35C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C35C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C35C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C35CC: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C35D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C35D4: 419A0014  beq cr6, 0x821c35e8
	if ctx.cr[6].eq {
	pc = 0x821C35E8; continue 'dispatch;
	}
	// 821C35D8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C35DC: 490F6379  bl 0x832b9954
	ctx.lr = 0x821C35E0;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821C35E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C35E4: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 821C35E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C35EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C35F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C35F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C35F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C3600 size=112
    let mut pc: u32 = 0x821C3600;
    'dispatch: loop {
        match pc {
            0x821C3600 => {
    //   block [0x821C3600..0x821C3670)
	// 821C3600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3604: 48AE5E01  bl 0x82ca9404
	ctx.lr = 0x821C3608;
	sub_82CA93D0(ctx, base);
	// 821C3608: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C360C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3610: 547D2036  slwi r29, r3, 4
	ctx.r[29].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821C3614: 396BF970  addi r11, r11, -0x690
	ctx.r[11].s64 = ctx.r[11].s64 + -1680;
	// 821C3618: 7F7D5A14  add r27, r29, r11
	ctx.r[27].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821C361C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3620: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3624: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C3628: 7D1F1671  srawi. r31, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821C362C: 40810024  ble 0x821c3650
	if !ctx.cr[0].gt {
	pc = 0x821C3650; continue 'dispatch;
	}
	// 821C3630: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 821C3634: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821C3638: 7D7DE02E  lwzx r11, r29, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C363C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821C3640: 4888B5A1  bl 0x82a4ebe0
	ctx.lr = 0x821C3644;
	sub_82A4EBE0(ctx, base);
	// 821C3644: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821C3648: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821C364C: 4082FFEC  bne 0x821c3638
	if !ctx.cr[0].eq {
	pc = 0x821C3638; continue 'dispatch;
	}
	// 821C3650: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C3654: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C3658: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C365C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C3660: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821C3664: 480E9A15  bl 0x822ad078
	ctx.lr = 0x821C3668;
	sub_822AD078(ctx, base);
	// 821C3668: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C366C: 48AE5DE8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3670 size=488
    let mut pc: u32 = 0x821C3670;
    'dispatch: loop {
        match pc {
            0x821C3670 => {
    //   block [0x821C3670..0x821C3858)
	// 821C3670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3674: 48AE5D89  bl 0x82ca93fc
	ctx.lr = 0x821C3678;
	sub_82CA93D0(ctx, base);
	// 821C3678: 9421F030  stwu r1, -0xfd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-4048 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C367C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C3680: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3684: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821C3688: 83DB0014  lwz r30, 0x14(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C368C: 480BA485  bl 0x8227db10
	ctx.lr = 0x821C3690;
	sub_8227DB10(ctx, base);
	// 821C3690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C3694: 4BFBDC05  bl 0x82181298
	ctx.lr = 0x821C3698;
	sub_82181298(ctx, base);
	// 821C3698: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C369C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C36A0: 806BF7F4  lwz r3, -0x80c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2060 as u32) ) } as u64;
	// 821C36A4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C36A8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C36AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C36B0: 4E800421  bctrl
	ctx.lr = 0x821C36B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C36B4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821C36B8: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 821C36BC: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821C36C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C36C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C36C8: 88A76E61  lbz r5, 0x6e61(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(28257 as u32) ) } as u64;
	// 821C36CC: 99681624  stb r11, 0x1624(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(5668 as u32), ctx.r[11].u8 ) };
	// 821C36D0: 7CA40034  cntlzw r4, r5
	ctx.r[4].u64 = if ctx.r[5].u32 == 0 { 32 } else { ctx.r[5].u32.leading_zeros() as u64 };
	// 821C36D4: 99461625  stb r10, 0x1625(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(5669 as u32), ctx.r[10].u8 ) };
	// 821C36D8: 5483DFFE  rlwinm r3, r4, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821C36DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C36E0: 419A0010  beq cr6, 0x821c36f0
	if ctx.cr[6].eq {
	pc = 0x821C36F0; continue 'dispatch;
	}
	// 821C36E4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821C36E8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821C36EC: 916A8570  stw r11, -0x7a90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-31376 as u32), ctx.r[11].u32 ) };
	// 821C36F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C36F4: 4BFF61E5  bl 0x821b98d8
	ctx.lr = 0x821C36F8;
	sub_821B98D8(ctx, base);
	// 821C36F8: 4BFF6AF9  bl 0x821ba1f0
	ctx.lr = 0x821C36FC;
	sub_821BA1F0(ctx, base);
	// 821C36FC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821C3700: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821C3704: 392AA978  addi r9, r10, -0x5688
	ctx.r[9].s64 = ctx.r[10].s64 + -22152;
	// 821C3708: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821C370C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821C3710: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C3714: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C3718: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 821C371C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 821C3720: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3724: 480374AD  bl 0x821fabd0
	ctx.lr = 0x821C3728;
	sub_821FABD0(ctx, base);
	// 821C3728: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821C372C: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 821C3730: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C3734: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C3738: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821C373C: 80DC0000  lwz r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3740: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821C3744: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3748: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821C374C: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821C3750: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C3754: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C3758: 7D6A0194  addze r11, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821C375C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821C3760: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C3764: 8084F9C0  lwz r4, -0x640(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821C3768: 48038629  bl 0x821fbd90
	ctx.lr = 0x821C376C;
	sub_821FBD90(ctx, base);
	// 821C376C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821C3770: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821C3774: 3B4BAA5C  addi r26, r11, -0x55a4
	ctx.r[26].s64 = ctx.r[11].s64 + -21924;
	// 821C3778: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821C377C: 4803846D  bl 0x821fbbe8
	ctx.lr = 0x821C3780;
	sub_821FBBE8(ctx, base);
	// 821C3780: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821C3784: 4803880D  bl 0x821fbf90
	ctx.lr = 0x821C3788;
	sub_821FBF90(ctx, base);
	// 821C3788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C378C: 809E0E60  lwz r4, 0xe60(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3680 as u32) ) } as u64;
	// 821C3790: 4BFE9829  bl 0x821acfb8
	ctx.lr = 0x821C3794;
	sub_821ACFB8(ctx, base);
	// 821C3794: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3798: 480BF4A1  bl 0x82282c38
	ctx.lr = 0x821C379C;
	sub_82282C38(ctx, base);
	// 821C379C: 480D2E45  bl 0x822965e0
	ctx.lr = 0x821C37A0;
	sub_822965E0(ctx, base);
	// 821C37A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C37A4: 4BFEABDD  bl 0x821ae380
	ctx.lr = 0x821C37A8;
	sub_821AE380(ctx, base);
	// 821C37A8: 3F20834A  lis r25, -0x7cb6
	ctx.r[25].s64 = -2092302336;
	// 821C37AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821C37B0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821C37B4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821C37B8: 8099F7DC  lwz r4, -0x824(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-2084 as u32) ) } as u64;
	// 821C37BC: 480A9D55  bl 0x8226d510
	ctx.lr = 0x821C37C0;
	sub_8226D510(ctx, base);
	// 821C37C0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C37C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821C37C8: 3BCB4DE4  addi r30, r11, 0x4de4
	ctx.r[30].s64 = ctx.r[11].s64 + 19940;
	// 821C37CC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C37D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C37D4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C37D8: 7D491671  srawi. r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C37DC: 41820040  beq 0x821c381c
	if ctx.cr[0].eq {
	pc = 0x821C381C; continue 'dispatch;
	}
	// 821C37E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821C37E4: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821C37E8: 480B7D61  bl 0x8227b548
	ctx.lr = 0x821C37EC;
	sub_8227B548(ctx, base);
	// 821C37EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C37F0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821C37F4: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821C37F8: 480A5479  bl 0x82268c70
	ctx.lr = 0x821C37FC;
	sub_82268C70(ctx, base);
	// 821C37FC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3800: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821C3804: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3808: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821C380C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C3810: 7D491670  srawi r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821C3814: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C3818: 4198FFCC  blt cr6, 0x821c37e4
	if ctx.cr[6].lt {
	pc = 0x821C37E4; continue 'dispatch;
	}
	// 821C381C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3820: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821C3824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C3828: 806BF7EC  lwz r3, -0x814(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2068 as u32) ) } as u64;
	// 821C382C: 480C7345  bl 0x8228ab70
	ctx.lr = 0x821C3830;
	sub_8228AB70(ctx, base);
	// 821C3830: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821C3834: 8099F7DC  lwz r4, -0x824(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-2084 as u32) ) } as u64;
	// 821C3838: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821C383C: 38610820  addi r3, r1, 0x820
	ctx.r[3].s64 = ctx.r[1].s64 + 2080;
	// 821C3840: 480A9CD1  bl 0x8226d510
	ctx.lr = 0x821C3844;
	sub_8226D510(ctx, base);
	// 821C3844: 38610820  addi r3, r1, 0x820
	ctx.r[3].s64 = ctx.r[1].s64 + 2080;
	// 821C3848: 809B0014  lwz r4, 0x14(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C384C: 4BFD429D  bl 0x82197ae8
	ctx.lr = 0x821C3850;
	sub_82197AE8(ctx, base);
	// 821C3850: 38210FD0  addi r1, r1, 0xfd0
	ctx.r[1].s64 = ctx.r[1].s64 + 4048;
	// 821C3854: 48AE5BF8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3858 size=1028
    let mut pc: u32 = 0x821C3858;
    'dispatch: loop {
        match pc {
            0x821C3858 => {
    //   block [0x821C3858..0x821C3C5C)
	// 821C3858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C385C: 48AE5BA5  bl 0x82ca9400
	ctx.lr = 0x821C3860;
	sub_82CA93D0(ctx, base);
	// 821C3860: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821C3864: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C3868: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C386C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821C3870: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821C3874: 4805B495  bl 0x8221ed08
	ctx.lr = 0x821C3878;
	sub_8221ED08(ctx, base);
	// 821C3878: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C387C: 906BF808  stw r3, -0x7f8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-2040 as u32), ctx.r[3].u32 ) };
	// 821C3880: 48073AB9  bl 0x82237338
	ctx.lr = 0x821C3884;
	sub_82237338(ctx, base);
	// 821C3884: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C3888: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821C388C: 3F408336  lis r26, -0x7cca
	ctx.r[26].s64 = -2093613056;
	// 821C3890: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C3894: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821C3898: 81496E10  lwz r10, 0x6e10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28176 as u32) ) } as u64;
	// 821C389C: 817D70C4  lwz r11, 0x70c4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28868 as u32) ) } as u64;
	// 821C38A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C38A4: DBFAF7F8  stfd f31, -0x808(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(-2056 as u32), ctx.f[31].u64 ) };
	// 821C38A8: 93E86E14  stw r31, 0x6e14(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28180 as u32), ctx.r[31].u32 ) };
	// 821C38AC: 2B0B1800  cmplwi cr6, r11, 0x1800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6144 as u32, &mut ctx.xer);
	// 821C38B0: DBE76E18  stfd f31, 0x6e18(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(28184 as u32), ctx.f[31].u64 ) };
	// 821C38B4: 91496E10  stw r10, 0x6e10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28176 as u32), ctx.r[10].u32 ) };
	// 821C38B8: 419A00A0  beq cr6, 0x821c3958
	if ctx.cr[6].eq {
	pc = 0x821C3958; continue 'dispatch;
	}
	// 821C38BC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C38C0: 3BEB0308  addi r31, r11, 0x308
	ctx.r[31].s64 = ctx.r[11].s64 + 776;
	// 821C38C4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C38C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C38CC: 419A0008  beq cr6, 0x821c38d4
	if ctx.cr[6].eq {
	pc = 0x821C38D4; continue 'dispatch;
	}
	// 821C38D0: 48979EF9  bl 0x82b3d7c8
	ctx.lr = 0x821C38D4;
	sub_82B3D7C8(ctx, base);
	// 821C38D4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C38D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C38DC: 419A0008  beq cr6, 0x821c38e4
	if ctx.cr[6].eq {
	pc = 0x821C38E4; continue 'dispatch;
	}
	// 821C38E0: 48979EE9  bl 0x82b3d7c8
	ctx.lr = 0x821C38E4;
	sub_82B3D7C8(ctx, base);
	// 821C38E4: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 821C38E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C38EC: 807E0364  lwz r3, 0x364(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C38F0: 489DEF41  bl 0x82ba2830
	ctx.lr = 0x821C38F4;
	sub_82BA2830(ctx, base);
	// 821C38F4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821C38F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C38FC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 821C3900: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C3904: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821C3908: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821C390C: 4200FFF8  bdnz 0x821c3904
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C3904; continue 'dispatch;
	}
	// 821C3910: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821C3914: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C3918: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 821C391C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C3920: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821C3924: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821C3928: 4200FFF8  bdnz 0x821c3920
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C3920; continue 'dispatch;
	}
	// 821C392C: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 821C3930: 807E0364  lwz r3, 0x364(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C3934: 3D400060  lis r10, 0x60
	ctx.r[10].s64 = 6291456;
	// 821C3938: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821C393C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C3940: 39601800  li r11, 0x1800
	ctx.r[11].s64 = 6144;
	// 821C3944: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821C3948: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 821C394C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C3950: 917D70C4  stw r11, 0x70c4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28868 as u32), ctx.r[11].u32 ) };
	// 821C3954: 489DEEDD  bl 0x82ba2830
	ctx.lr = 0x821C3958;
	sub_82BA2830(ctx, base);
	// 821C3958: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821C395C: 897FCBD1  lbz r11, -0x342f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-13359 as u32) ) } as u64;
	// 821C3960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3964: 419A0018  beq cr6, 0x821c397c
	if ctx.cr[6].eq {
	pc = 0x821C397C; continue 'dispatch;
	}
	// 821C3968: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821C396C: 386BDEE4  addi r3, r11, -0x211c
	ctx.r[3].s64 = ctx.r[11].s64 + -8476;
	// 821C3970: 489BFA09  bl 0x82b83378
	ctx.lr = 0x821C3974;
	sub_82B83378(ctx, base);
	// 821C3974: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C3978: 997FCBD1  stb r11, -0x342f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(-13359 as u32), ctx.r[11].u8 ) };
	// 821C397C: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C3980: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C3984: 3BEB2390  addi r31, r11, 0x2390
	ctx.r[31].s64 = ctx.r[11].s64 + 9104;
	// 821C3988: 390A7E70  addi r8, r10, 0x7e70
	ctx.r[8].s64 = ctx.r[10].s64 + 32368;
	// 821C398C: 38FF2008  addi r7, r31, 0x2008
	ctx.r[7].s64 = ctx.r[31].s64 + 8200;
	// 821C3990: 817F2004  lwz r11, 0x2004(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C3994: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C3998: 7D06F92E  stwx r8, r6, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32), ctx.r[8].u32) };
	// 821C399C: 815F2004  lwz r10, 0x2004(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C39A0: 813F2000  lwz r9, 0x2000(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C39A4: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821C39A8: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C39AC: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 821C39B0: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C39B4: 917F2004  stw r11, 0x2004(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8196 as u32), ctx.r[11].u32 ) };
	// 821C39B8: 915F2000  stw r10, 0x2000(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 821C39BC: 7D05392E  stwx r8, r5, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 821C39C0: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821C39C4: 815F4008  lwz r10, 0x4008(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821C39C8: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C39CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C39D0: 915F4008  stw r10, 0x4008(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16392 as u32), ctx.r[10].u32 ) };
	// 821C39D4: 917F400C  stw r11, 0x400c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16396 as u32), ctx.r[11].u32 ) };
	// 821C39D8: 480FF289  bl 0x822c2c60
	ctx.lr = 0x821C39DC;
	sub_822C2C60(ctx, base);
	// 821C39DC: 3C60834A  lis r3, -0x7cb6
	ctx.r[3].s64 = -2092302336;
	// 821C39E0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C39E4: 390360B8  addi r8, r3, 0x60b8
	ctx.r[8].s64 = ctx.r[3].s64 + 24760;
	// 821C39E8: 388BF838  addi r4, r11, -0x7c8
	ctx.r[4].s64 = ctx.r[11].s64 + -1992;
	// 821C39EC: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 821C39F0: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C39F4: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C39F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C39FC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821C3A00: 816360B8  lwz r11, 0x60b8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24760 as u32) ) } as u64;
	// 821C3A04: 3867F820  addi r3, r7, -0x7e0
	ctx.r[3].s64 = ctx.r[7].s64 + -2016;
	// 821C3A08: 8108000C  lwz r8, 0xc(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C3A0C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C3A10: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821C3A14: 4BFB7985  bl 0x8217b398
	ctx.lr = 0x821C3A18;
	sub_8217B398(ctx, base);
	// 821C3A18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3A1C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821C3A20: 3BCBF9B0  addi r30, r11, -0x650
	ctx.r[30].s64 = ctx.r[11].s64 + -1616;
	// 821C3A24: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 821C3A28: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3A2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3A30: 419A0014  beq cr6, 0x821c3a44
	if ctx.cr[6].eq {
	pc = 0x821C3A44; continue 'dispatch;
	}
	// 821C3A34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C3A38: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821C3A3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821C3A40: 4811C3C9  bl 0x822dfe08
	ctx.lr = 0x821C3A44;
	sub_822DFE08(ctx, base);
	// 821C3A44: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821C3A48: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 821C3A4C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821C3A50: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821C3A54: 4198FFD4  blt cr6, 0x821c3a28
	if ctx.cr[6].lt {
	pc = 0x821C3A28; continue 'dispatch;
	}
	// 821C3A58: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 821C3A5C: 419A00F8  beq cr6, 0x821c3b54
	if ctx.cr[6].eq {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3A60: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3A64: 394BF7A8  addi r10, r11, -0x858
	ctx.r[10].s64 = ctx.r[11].s64 + -2136;
	// 821C3A68: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3A6C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3A70: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C3A74: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821C3A78: 7F1B4040  cmplw cr6, r27, r8
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C3A7C: 409800D8  bge cr6, 0x821c3b54
	if !ctx.cr[6].lt {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3A80: 576A103A  slwi r10, r27, 2
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C3A84: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821C3A88: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C3A8C: 419A00C8  beq cr6, 0x821c3b54
	if ctx.cr[6].eq {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3A90: 553E003E  slwi r30, r9, 0
	ctx.r[30].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821C3A94: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3A98: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821C3A9C: 409A00B8  bne cr6, 0x821c3b54
	if !ctx.cr[6].eq {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3AA0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C3AA4: 419A00B0  beq cr6, 0x821c3b54
	if ctx.cr[6].eq {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3AA8: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3AAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821C3AB0: 4BFBE0B9  bl 0x82181b68
	ctx.lr = 0x821C3AB4;
	sub_82181B68(ctx, base);
	// 821C3AB4: 897E0048  lbz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C3AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3ABC: 419A008C  beq cr6, 0x821c3b48
	if ctx.cr[6].eq {
	pc = 0x821C3B48; continue 'dispatch;
	}
	// 821C3AC0: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3AC4: 48030AB5  bl 0x821f4578
	ctx.lr = 0x821C3AC8;
	sub_821F4578(ctx, base);
	// 821C3AC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3ACC: 4800E1D5  bl 0x821d1ca0
	ctx.lr = 0x821C3AD0;
	sub_821D1CA0(ctx, base);
	// 821C3AD0: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3AD4: 807D0E5C  lwz r3, 0xe5c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3676 as u32) ) } as u64;
	// 821C3AD8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C3ADC: 419A0008  beq cr6, 0x821c3ae4
	if ctx.cr[6].eq {
	pc = 0x821C3AE4; continue 'dispatch;
	}
	// 821C3AE0: 48011669  bl 0x821d5148
	ctx.lr = 0x821C3AE4;
	sub_821D5148(ctx, base);
	// 821C3AE4: 807D0E64  lwz r3, 0xe64(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3684 as u32) ) } as u64;
	// 821C3AE8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C3AEC: 419A000C  beq cr6, 0x821c3af8
	if ctx.cr[6].eq {
	pc = 0x821C3AF8; continue 'dispatch;
	}
	// 821C3AF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C3AF4: 4807D1F5  bl 0x82240ce8
	ctx.lr = 0x821C3AF8;
	sub_82240CE8(ctx, base);
	// 821C3AF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C3AFC: 480FCEED  bl 0x822c09e8
	ctx.lr = 0x821C3B00;
	sub_822C09E8(ctx, base);
	// 821C3B00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3B04: C83AF7F8  lfd f1, -0x808(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(-2056 as u32) ) };
	// 821C3B08: 480C79D9  bl 0x8228b4e0
	ctx.lr = 0x821C3B0C;
	sub_8228B4E0(ctx, base);
	// 821C3B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3B10: 4801F671  bl 0x821e3180
	ctx.lr = 0x821C3B14;
	sub_821E3180(ctx, base);
	// 821C3B14: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3B18: 480CBA39  bl 0x8228f550
	ctx.lr = 0x821C3B1C;
	sub_8228F550(ctx, base);
	// 821C3B1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C3B20: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C3B24: 419A001C  beq cr6, 0x821c3b40
	if ctx.cr[6].eq {
	pc = 0x821C3B40; continue 'dispatch;
	}
	// 821C3B28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3B2C: 996A6E70  stb r11, 0x6e70(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28272 as u32), ctx.r[11].u8 ) };
	// 821C3B30: 4809FA41  bl 0x82263570
	ctx.lr = 0x821C3B34;
	sub_82263570(ctx, base);
	// 821C3B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3B38: 48000129  bl 0x821c3c60
	ctx.lr = 0x821C3B3C;
	sub_821C3C60(ctx, base);
	// 821C3B3C: 48000050  b 0x821c3b8c
	pc = 0x821C3B8C; continue 'dispatch;
	// 821C3B40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C3B44: 996A6E70  stb r11, 0x6e70(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28272 as u32), ctx.r[11].u8 ) };
	// 821C3B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3B4C: 48000115  bl 0x821c3c60
	ctx.lr = 0x821C3B50;
	sub_821C3C60(ctx, base);
	// 821C3B50: 4800003C  b 0x821c3b8c
	pc = 0x821C3B8C; continue 'dispatch;
	// 821C3B54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C3B58: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821C3B5C: 386AF9CC  addi r3, r10, -0x634
	ctx.r[3].s64 = ctx.r[10].s64 + -1588;
	// 821C3B60: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C3B64: 4801F0A5  bl 0x821e2c08
	ctx.lr = 0x821C3B68;
	sub_821E2C08(ctx, base);
	// 821C3B68: 4BFF3219  bl 0x821b6d80
	ctx.lr = 0x821C3B6C;
	sub_821B6D80(ctx, base);
	// 821C3B6C: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821C3B70: 8069FA0C  lwz r3, -0x5f4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 821C3B74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C3B78: 419A000C  beq cr6, 0x821c3b84
	if ctx.cr[6].eq {
	pc = 0x821C3B84; continue 'dispatch;
	}
	// 821C3B7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C3B80: 480F1451  bl 0x822b4fd0
	ctx.lr = 0x821C3B84;
	sub_822B4FD0(ctx, base);
	// 821C3B84: 4BFCE3CD  bl 0x82191f50
	ctx.lr = 0x821C3B88;
	sub_82191F50(ctx, base);
	// 821C3B88: 480F13B1  bl 0x822b4f38
	ctx.lr = 0x821C3B8C;
	sub_822B4F38(ctx, base);
	// 821C3B8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C3B90: 48036449  bl 0x821f9fd8
	ctx.lr = 0x821C3B94;
	sub_821F9FD8(ctx, base);
	// 821C3B94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C3B98: 4BFFFA69  bl 0x821c3600
	ctx.lr = 0x821C3B9C;
	sub_821C3600(ctx, base);
	// 821C3B9C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3BA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C3BA4: 806BF84C  lwz r3, -0x7b4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1972 as u32) ) } as u64;
	// 821C3BA8: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821C3BAC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3BB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3BB4: 419A0038  beq cr6, 0x821c3bec
	if ctx.cr[6].eq {
	pc = 0x821C3BEC; continue 'dispatch;
	}
	// 821C3BB8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3BBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3BC0: 409A002C  bne cr6, 0x821c3bec
	if !ctx.cr[6].eq {
	pc = 0x821C3BEC; continue 'dispatch;
	}
	// 821C3BC4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C3BC8: 39200061  li r9, 0x61
	ctx.r[9].s64 = 97;
	// 821C3BCC: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3BD0: 38EAFFF0  addi r7, r10, -0x10
	ctx.r[7].s64 = ctx.r[10].s64 + -16;
	// 821C3BD4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821C3BD8: 91280008  stw r9, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C3BDC: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3BE0: 90C80004  stw r6, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821C3BE4: 91030014  stw r8, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 821C3BE8: 48000008  b 0x821c3bf0
	pc = 0x821C3BF0; continue 'dispatch;
	// 821C3BEC: 48A2774D  bl 0x82beb338
	ctx.lr = 0x821C3BF0;
	sub_82BEB338(ctx, base);
	// 821C3BF0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 821C3BF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3BF8: 4805B751  bl 0x8221f348
	ctx.lr = 0x821C3BFC;
	sub_8221F348(ctx, base);
	// 821C3BFC: 3BDE2008  addi r30, r30, 0x2008
	ctx.r[30].s64 = ctx.r[30].s64 + 8200;
	// 821C3C00: 397F4010  addi r11, r31, 0x4010
	ctx.r[11].s64 = ctx.r[31].s64 + 16400;
	// 821C3C04: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821C3C08: 4198FFEC  blt cr6, 0x821c3bf4
	if ctx.cr[6].lt {
	pc = 0x821C3BF4; continue 'dispatch;
	}
	// 821C3C0C: 4806E6BD  bl 0x822322c8
	ctx.lr = 0x821C3C10;
	sub_822322C8(ctx, base);
	// 821C3C10: 4805A891  bl 0x8221e4a0
	ctx.lr = 0x821C3C14;
	sub_8221E4A0(ctx, base);
	// 821C3C14: 4BFF316D  bl 0x821b6d80
	ctx.lr = 0x821C3C18;
	sub_821B6D80(ctx, base);
	// 821C3C18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3C1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C3C20: 388B6338  addi r4, r11, 0x6338
	ctx.r[4].s64 = ctx.r[11].s64 + 25400;
	// 821C3C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C3C28: 4803CB49  bl 0x82200770
	ctx.lr = 0x821C3C2C;
	sub_82200770(ctx, base);
	// 821C3C2C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821C3C30: 386A632C  addi r3, r10, 0x632c
	ctx.r[3].s64 = ctx.r[10].s64 + 25388;
	// 821C3C34: 489AE23D  bl 0x82b71e70
	ctx.lr = 0x821C3C38;
	sub_82B71E70(ctx, base);
	// 821C3C38: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C3C3C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C3C40: 419A000C  beq cr6, 0x821c3c4c
	if ctx.cr[6].eq {
	pc = 0x821C3C4C; continue 'dispatch;
	}
	// 821C3C44: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C3C48: 490F5D0D  bl 0x832b9954
	ctx.lr = 0x821C3C4C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821C3C4C: 4BFE220D  bl 0x821a5e58
	ctx.lr = 0x821C3C50;
	sub_821A5E58(ctx, base);
	// 821C3C50: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821C3C54: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821C3C58: 48AE57F8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3C60 size=496
    let mut pc: u32 = 0x821C3C60;
    'dispatch: loop {
        match pc {
            0x821C3C60 => {
    //   block [0x821C3C60..0x821C3E50)
	// 821C3C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3C64: 48AE579D  bl 0x82ca9400
	ctx.lr = 0x821C3C68;
	sub_82CA93D0(ctx, base);
	// 821C3C68: 9421F7A0  stwu r1, -0x860(r1)
	ea = ctx.r[1].u32.wrapping_add(-2144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C3C6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C3C70: 897D0048  lbz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C3C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3C78: 409A0020  bne cr6, 0x821c3c98
	if !ctx.cr[6].eq {
	pc = 0x821C3C98; continue 'dispatch;
	}
	// 821C3C7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C3C80: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821C3C84: 386AF9CC  addi r3, r10, -0x634
	ctx.r[3].s64 = ctx.r[10].s64 + -1588;
	// 821C3C88: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C3C8C: 4801EF7D  bl 0x821e2c08
	ctx.lr = 0x821C3C90;
	sub_821E2C08(ctx, base);
	// 821C3C90: 38210860  addi r1, r1, 0x860
	ctx.r[1].s64 = ctx.r[1].s64 + 2144;
	// 821C3C94: 48AE57BC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 821C3C98: 817D05D0  lwz r11, 0x5d0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1488 as u32) ) } as u64;
	// 821C3C9C: 815D05D4  lwz r10, 0x5d4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1492 as u32) ) } as u64;
	// 821C3CA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3CA4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821C3CA8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821C3CAC: 409A002C  bne cr6, 0x821c3cd8
	if !ctx.cr[6].eq {
	pc = 0x821C3CD8; continue 'dispatch;
	}
	// 821C3CB0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821C3CB4: 409A0024  bne cr6, 0x821c3cd8
	if !ctx.cr[6].eq {
	pc = 0x821C3CD8; continue 'dispatch;
	}
	// 821C3CB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3CBC: 394B5FE8  addi r10, r11, 0x5fe8
	ctx.r[10].s64 = ctx.r[11].s64 + 24552;
	// 821C3CC0: 816B5FE8  lwz r11, 0x5fe8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24552 as u32) ) } as u64;
	// 821C3CC4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3CC8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821C3CCC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821C3CD0: E9210060  ld r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821C3CD4: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821C3CD8: 817D05D8  lwz r11, 0x5d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1496 as u32) ) } as u64;
	// 821C3CDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C3CE0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821C3CE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3CE8: 419A0024  beq cr6, 0x821c3d0c
	if ctx.cr[6].eq {
	pc = 0x821C3D0C; continue 'dispatch;
	}
	// 821C3CEC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821C3CF0: 419A0024  beq cr6, 0x821c3d14
	if ctx.cr[6].eq {
	pc = 0x821C3D14; continue 'dispatch;
	}
	// 821C3CF4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821C3CF8: 419A0014  beq cr6, 0x821c3d0c
	if ctx.cr[6].eq {
	pc = 0x821C3D0C; continue 'dispatch;
	}
	// 821C3CFC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821C3D00: 409A0018  bne cr6, 0x821c3d18
	if !ctx.cr[6].eq {
	pc = 0x821C3D18; continue 'dispatch;
	}
	// 821C3D04: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821C3D08: 48000010  b 0x821c3d18
	pc = 0x821C3D18; continue 'dispatch;
	// 821C3D0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C3D10: 48000008  b 0x821c3d18
	pc = 0x821C3D18; continue 'dispatch;
	// 821C3D14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821C3D18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C3D1C: 480C6D15  bl 0x8228aa30
	ctx.lr = 0x821C3D20;
	sub_8228AA30(ctx, base);
	// 821C3D20: 4BFF3111  bl 0x821b6e30
	ctx.lr = 0x821C3D24;
	sub_821B6E30(ctx, base);
	// 821C3D24: 4BFD7BE5  bl 0x8219b908
	ctx.lr = 0x821C3D28;
	sub_8219B908(ctx, base);
	// 821C3D28: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C3D2C: 894B6E21  lbz r10, 0x6e21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28193 as u32) ) } as u64;
	// 821C3D30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3D34: 419A0038  beq cr6, 0x821c3d6c
	if ctx.cr[6].eq {
	pc = 0x821C3D6C; continue 'dispatch;
	}
	// 821C3D38: 488C7BD1  bl 0x82a8b908
	ctx.lr = 0x821C3D3C;
	sub_82A8B908(ctx, base);
	// 821C3D3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C3D40: 419A002C  beq cr6, 0x821c3d6c
	if ctx.cr[6].eq {
	pc = 0x821C3D6C; continue 'dispatch;
	}
	// 821C3D44: 488C7BC5  bl 0x82a8b908
	ctx.lr = 0x821C3D48;
	sub_82A8B908(ctx, base);
	// 821C3D48: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C3D4C: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 821C3D50: 394B02B0  addi r10, r11, 0x2b0
	ctx.r[10].s64 = ctx.r[11].s64 + 688;
	// 821C3D54: 3CC00020  lis r6, 0x20
	ctx.r[6].s64 = 2097152;
	// 821C3D58: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 821C3D5C: 906A0028  stw r3, 0x28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 821C3D60: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3D64: 80690364  lwz r3, 0x364(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C3D68: 4BFF3179  bl 0x821b6ee0
	ctx.lr = 0x821C3D6C;
	sub_821B6EE0(ctx, base);
	// 821C3D6C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3D70: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821C3D74: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821C3D78: 806BF820  lwz r3, -0x7e0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2016 as u32) ) } as u64;
	// 821C3D7C: 836AF7F8  lwz r27, -0x808(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2056 as u32) ) } as u64;
	// 821C3D80: 83E9F7DC  lwz r31, -0x824(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-2084 as u32) ) } as u64;
	// 821C3D84: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3D88: 80E80024  lwz r7, 0x24(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C3D8C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821C3D90: 4E800421  bctrl
	ctx.lr = 0x821C3D94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C3D94: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 821C3D98: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821C3D9C: 93A100B4  stw r29, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 821C3DA0: 3BE101E0  addi r31, r1, 0x1e0
	ctx.r[31].s64 = ctx.r[1].s64 + 480;
	// 821C3DA4: 938101D0  stw r28, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[28].u32 ) };
	// 821C3DA8: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 821C3DAC: 3D6082B9  lis r11, -0x7d47
	ctx.r[11].s64 = -2101805056;
	// 821C3DB0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821C3DB4: 38CB6E78  addi r6, r11, 0x6e78
	ctx.r[6].s64 = ctx.r[11].s64 + 28280;
	// 821C3DB8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 821C3DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C3DC0: 4805BD49  bl 0x8221fb08
	ctx.lr = 0x821C3DC4;
	sub_8221FB08(ctx, base);
	// 821C3DC4: 939F0100  stw r28, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[28].u32 ) };
	// 821C3DC8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821C3DCC: 3BFF0110  addi r31, r31, 0x110
	ctx.r[31].s64 = ctx.r[31].s64 + 272;
	// 821C3DD0: 4080FFDC  bge 0x821c3dac
	if !ctx.cr[0].lt {
	pc = 0x821C3DAC; continue 'dispatch;
	}
	// 821C3DD4: 397D0190  addi r11, r29, 0x190
	ctx.r[11].s64 = ctx.r[29].s64 + 400;
	// 821C3DD8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821C3DDC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C3DE0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C3DE4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C3DE8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C3DEC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C3DF0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C3DF4: 4200FFF0  bdnz 0x821c3de4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C3DE4; continue 'dispatch;
	}
	// 821C3DF8: 39600060  li r11, 0x60
	ctx.r[11].s64 = 96;
	// 821C3DFC: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 821C3E00: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821C3E04: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821C3E08: 38BD02F0  addi r5, r29, 0x2f0
	ctx.r[5].s64 = ctx.r[29].s64 + 752;
	// 821C3E0C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C3E50 size=24
    let mut pc: u32 = 0x821C3E50;
    'dispatch: loop {
        match pc {
            0x821C3E50 => {
    //   block [0x821C3E50..0x821C3E68)
	// 821C3E50: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3E54: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3E58: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821C3E5C: 4098000C  bge cr6, 0x821c3e68
	if !ctx.cr[6].lt {
		sub_821C3E68(ctx, base);
		return;
	}
	// 821C3E60: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821C3E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C3E68 size=12
    let mut pc: u32 = 0x821C3E68;
    'dispatch: loop {
        match pc {
            0x821C3E68 => {
    //   block [0x821C3E68..0x821C3E74)
	// 821C3E68: 4099000C  ble cr6, 0x821c3e74
	if !ctx.cr[6].gt {
		sub_821C3E74(ctx, base);
		return;
	}
	// 821C3E6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C3E70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3E74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C3E74 size=52
    let mut pc: u32 = 0x821C3E74;
    'dispatch: loop {
        match pc {
            0x821C3E74 => {
    //   block [0x821C3E74..0x821C3EA8)
	// 821C3E74: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C3E78: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C3E7C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821C3E80: 4198FFE0  blt cr6, 0x821c3e60
	if ctx.cr[6].lt {
		sub_821C3E50(ctx, base);
		return;
	}
	// 821C3E84: 4199FFE8  bgt cr6, 0x821c3e6c
	if ctx.cr[6].gt {
		sub_821C3E68(ctx, base);
		return;
	}
	// 821C3E88: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C3E8C: 8144001C  lwz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C3E90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C3E94: 4198FFCC  blt cr6, 0x821c3e60
	if ctx.cr[6].lt {
		sub_821C3E50(ctx, base);
		return;
	}
	// 821C3E98: 7D6B5010  subfc r11, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C3E9C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821C3EA0: 556307FE  clrlwi r3, r11, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821C3EA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3EA8 size=548
    let mut pc: u32 = 0x821C3EA8;
    'dispatch: loop {
        match pc {
            0x821C3EA8 => {
    //   block [0x821C3EA8..0x821C40CC)
	// 821C3EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3EAC: 48AE5545  bl 0x82ca93f0
	ctx.lr = 0x821C3EB0;
	sub_82CA93D0(ctx, base);
	// 821C3EB0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C3EB4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821C3EB8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821C3EBC: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 821C3EC0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821C3EC4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821C3EC8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821C3ECC: 8158000C  lwz r10, 0xc(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C3ED0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C3ED4: 7EEB51D6  mullw r23, r11, r10
	ctx.r[23].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 821C3ED8: 3B57FFFF  addi r26, r23, -1
	ctx.r[26].s64 = ctx.r[23].s64 + -1;
	// 821C3EDC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821C3EE0: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 821C3EE4: 4099005C  ble cr6, 0x821c3f40
	if !ctx.cr[6].gt {
	pc = 0x821C3F40; continue 'dispatch;
	}
	// 821C3EE8: 83980008  lwz r28, 8(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3EEC: 83780004  lwz r27, 4(r24)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3EF0: 7D7DFA14  add r11, r29, r31
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821C3EF4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821C3EF8: 557EF87E  srwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821C3EFC: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F00: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C3F04: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F08: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821C3F0C: 4BFFFF45  bl 0x821c3e50
	ctx.lr = 0x821C3F10;
	sub_821C3E50(ctx, base);
	// 821C3F10: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821C3F14: 41820028  beq 0x821c3f3c
	if ctx.cr[0].eq {
	pc = 0x821C3F3C; continue 'dispatch;
	}
	// 821C3F18: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C3F1C: 4099000C  ble cr6, 0x821c3f28
	if !ctx.cr[6].gt {
	pc = 0x821C3F28; continue 'dispatch;
	}
	// 821C3F20: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821C3F24: 48000008  b 0x821c3f2c
	pc = 0x821C3F2C; continue 'dispatch;
	// 821C3F28: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 821C3F2C: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 821C3F30: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821C3F34: 4199FFBC  bgt cr6, 0x821c3ef0
	if ctx.cr[6].gt {
	pc = 0x821C3EF0; continue 'dispatch;
	}
	// 821C3F38: 48000008  b 0x821c3f40
	pc = 0x821C3F40; continue 'dispatch;
	// 821C3F3C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821C3F40: 83980008  lwz r28, 8(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3F44: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F48: 83780004  lwz r27, 4(r24)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3F4C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821C3F50: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C3F54: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F58: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821C3F5C: 4BFFFEF5  bl 0x821c3e50
	ctx.lr = 0x821C3F60;
	sub_821C3E50(ctx, base);
	// 821C3F60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821C3F64: 40810008  ble 0x821c3f6c
	if !ctx.cr[0].gt {
	pc = 0x821C3F6C; continue 'dispatch;
	}
	// 821C3F68: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821C3F6C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821C3F70: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 821C3F74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821C3F78: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 821C3F7C: 40990054  ble cr6, 0x821c3fd0
	if !ctx.cr[6].gt {
	pc = 0x821C3FD0; continue 'dispatch;
	}
	// 821C3F80: 7D7DFA14  add r11, r29, r31
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821C3F84: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821C3F88: 557EF87E  srwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821C3F8C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F90: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C3F94: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F98: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821C3F9C: 4BFFFEB5  bl 0x821c3e50
	ctx.lr = 0x821C3FA0;
	sub_821C3E50(ctx, base);
	// 821C3FA0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821C3FA4: 41820028  beq 0x821c3fcc
	if ctx.cr[0].eq {
	pc = 0x821C3FCC; continue 'dispatch;
	}
	// 821C3FA8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C3FAC: 4099000C  ble cr6, 0x821c3fb8
	if !ctx.cr[6].gt {
	pc = 0x821C3FB8; continue 'dispatch;
	}
	// 821C3FB0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821C3FB4: 48000008  b 0x821c3fbc
	pc = 0x821C3FBC; continue 'dispatch;
	// 821C3FB8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 821C3FBC: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 821C3FC0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821C3FC4: 4199FFBC  bgt cr6, 0x821c3f80
	if ctx.cr[6].gt {
	pc = 0x821C3F80; continue 'dispatch;
	}
	// 821C3FC8: 48000008  b 0x821c3fd0
	pc = 0x821C3FD0; continue 'dispatch;
	// 821C3FCC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821C3FD0: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3FD4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821C3FD8: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C3FDC: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3FE0: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821C3FE4: 4BFFFE6D  bl 0x821c3e50
	ctx.lr = 0x821C3FE8;
	sub_821C3E50(ctx, base);
	// 821C3FE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821C3FEC: 40810008  ble 0x821c3ff4
	if !ctx.cr[0].gt {
	pc = 0x821C3FF4; continue 'dispatch;
	}
	// 821C3FF0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821C3FF4: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821C3FF8: 40980048  bge cr6, 0x821c4040
	if !ctx.cr[6].lt {
	pc = 0x821C4040; continue 'dispatch;
	}
	// 821C3FFC: 8119001C  lwz r8, 0x1c(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C4000: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821C4004: 7F1FB840  cmplw cr6, r31, r23
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[23].u32, &mut ctx.xer);
	// 821C4008: 4098007C  bge cr6, 0x821c4084
	if !ctx.cr[6].lt {
	pc = 0x821C4084; continue 'dispatch;
	}
	// 821C400C: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C4010: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4014: 7D4B482E  lwzx r10, r11, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821C4018: 7D0B492E  stwx r8, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 821C401C: 8139001C  lwz r9, 0x1c(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C4020: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821C4024: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C4028: 419A005C  beq cr6, 0x821c4084
	if ctx.cr[6].eq {
	pc = 0x821C4084; continue 'dispatch;
	}
	// 821C402C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821C4030: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821C4034: 7F07B840  cmplw cr6, r7, r23
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[23].u32, &mut ctx.xer);
	// 821C4038: 4198FFD8  blt cr6, 0x821c4010
	if ctx.cr[6].lt {
	pc = 0x821C4010; continue 'dispatch;
	}
	// 821C403C: 48000048  b 0x821c4084
	pc = 0x821C4084; continue 'dispatch;
	// 821C4040: 40990044  ble cr6, 0x821c4084
	if !ctx.cr[6].gt {
	pc = 0x821C4084; continue 'dispatch;
	}
	// 821C4044: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821C4048: 40980028  bge cr6, 0x821c4070
	if !ctx.cr[6].lt {
	pc = 0x821C4070; continue 'dispatch;
	}
	// 821C404C: 574A103A  slwi r10, r26, 2
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C4050: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 821C4054: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4058: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C405C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821C4060: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821C4064: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4068: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821C406C: 4082FFE8  bne 0x821c4054
	if !ctx.cr[0].eq {
	pc = 0x821C4054; continue 'dispatch;
	}
	// 821C4070: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4074: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C4078: 8139001C  lwz r9, 0x1c(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C407C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C4080: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 821C4084: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C4088: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821C408C: C0160004  lfs f0, 4(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4090: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821C4094: C0160008  lfs f0, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4098: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821C409C: C016000C  lfs f0, 0xc(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C40A0: D019000C  stfs f0, 0xc(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821C40A4: C0160010  lfs f0, 0x10(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C40A8: D0190010  stfs f0, 0x10(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821C40AC: 81760014  lwz r11, 0x14(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C40B0: 91790014  stw r11, 0x14(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821C40B4: 81760018  lwz r11, 0x18(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C40B8: 91790018  stw r11, 0x18(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821C40BC: 8176001C  lwz r11, 0x1c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C40C0: 9179001C  stw r11, 0x1c(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821C40C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821C40C8: 48AE5378  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C40D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C40D0 size=532
    let mut pc: u32 = 0x821C40D0;
    'dispatch: loop {
        match pc {
            0x821C40D0 => {
    //   block [0x821C40D0..0x821C42E4)
	// 821C40D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C40D4: 48AE5331  bl 0x82ca9404
	ctx.lr = 0x821C40D8;
	sub_82CA93D0(ctx, base);
	// 821C40D8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821C40DC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821C40E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C40E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C40E8: 4809C8D1  bl 0x822609b8
	ctx.lr = 0x821C40EC;
	sub_822609B8(ctx, base);
	// 821C40EC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821C40F0: C3C3004C  lfs f30, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821C40F4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821C40F8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C40FC: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4100: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C4104: 418201D0  beq 0x821c42d4
	if ctx.cr[0].eq {
	pc = 0x821C42D4; continue 'dispatch;
	}
	// 821C4108: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821C410C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821C4110: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C4114: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C411C: 480001CD  bl 0x821c42e8
	ctx.lr = 0x821C4120;
	sub_821C42E8(ctx, base);
	// 821C4120: 897E0020  lbz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C4124: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C4128: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C412C: 41820148  beq 0x821c4274
	if ctx.cr[0].eq {
	pc = 0x821C4274; continue 'dispatch;
	}
	// 821C4130: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C4134: C01F003C  lfs f0, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4138: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C413C: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C4140: 7D6BE9D6  mullw r11, r11, r29
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[29].s32 as i64);
	// 821C4144: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C4148: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C414C: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C4150: C145000C  lfs f10, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821C4154: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 821C4158: C1650010  lfs f11, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821C415C: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821C4160: FF0BF800  fcmpu cr6, f11, f31
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[31].f64);
	// 821C4164: C1450008  lfs f10, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821C4168: EDAD4828  fsubs f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 821C416C: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 821C4170: 419A00D0  beq cr6, 0x821c4240
	if ctx.cr[6].eq {
	pc = 0x821C4240; continue 'dispatch;
	}
	// 821C4174: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821C4178: C15E0018  lfs f10, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821C417C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821C4180: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821C4184: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 821C4188: 419900B8  bgt cr6, 0x821c4240
	if ctx.cr[6].gt {
	pc = 0x821C4240; continue 'dispatch;
	}
	// 821C418C: FF0BF000  fcmpu cr6, f11, f30
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[30].f64);
	// 821C4190: 409800E4  bge cr6, 0x821c4274
	if !ctx.cr[6].lt {
	pc = 0x821C4274; continue 'dispatch;
	}
	// 821C4194: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 821C4198: C1BE001C  lfs f13, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C419C: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C41A0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821C41A4: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821C41A8: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C41AC: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821C41B0: C19F003C  lfs f12, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C41B4: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821C41B8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821C41BC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821C41C0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821C41C4: 41980010  blt cr6, 0x821c41d4
	if ctx.cr[6].lt {
	pc = 0x821C41D4; continue 'dispatch;
	}
	// 821C41C8: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 821C41CC: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821C41D0: 48000018  b 0x821c41e8
	pc = 0x821C41E8; continue 'dispatch;
	// 821C41D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821C41D8: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821C41DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C41E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C41E4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821C41E8: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C41EC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821C41F0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821C41F4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821C41F8: 41980010  blt cr6, 0x821c4208
	if ctx.cr[6].lt {
	pc = 0x821C4208; continue 'dispatch;
	}
	// 821C41FC: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 821C4200: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821C4204: 48000018  b 0x821c421c
	pc = 0x821C421C; continue 'dispatch;
	// 821C4208: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 821C420C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821C4210: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C4214: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C4218: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821C421C: 8165001C  lwz r11, 0x1c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C4220: C01E0010  lfs f0, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4224: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821C4228: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 821C422C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C4230: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821C4234: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821C4238: 4BFFFC71  bl 0x821c3ea8
	ctx.lr = 0x821C423C;
	sub_821C3EA8(ctx, base);
	// 821C423C: 48000038  b 0x821c4274
	pc = 0x821C4274; continue 'dispatch;
	// 821C4240: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C4244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C4248: 419A0008  beq cr6, 0x821c4250
	if ctx.cr[6].eq {
	pc = 0x821C4250; continue 'dispatch;
	}
	// 821C424C: 93650000  stw r27, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821C4250: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4254: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821C4258: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C425C: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821C4260: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4264: D005000C  stfs f0, 0xc(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821C4268: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C426C: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 821C4270: D0050010  stfs f0, 0x10(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821C4274: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C4278: 393D0001  addi r9, r29, 1
	ctx.r[9].s64 = ctx.r[29].s64 + 1;
	// 821C427C: 7D6AE9D6  mullw r11, r10, r29
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[29].s32 as i64);
	// 821C4280: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C4284: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 821C4288: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C428C: 4098003C  bge cr6, 0x821c42c8
	if !ctx.cr[6].lt {
	pc = 0x821C42C8; continue 'dispatch;
	}
	// 821C4290: 55692834  slwi r9, r11, 5
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C4294: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C4298: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C429C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821C42A0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C42A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C42A8: 419A0014  beq cr6, 0x821c42bc
	if ctx.cr[6].eq {
	pc = 0x821C42BC; continue 'dispatch;
	}
	// 821C42AC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C42B0: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821C42B4: 40980008  bge cr6, 0x821c42bc
	if !ctx.cr[6].lt {
	pc = 0x821C42BC; continue 'dispatch;
	}
	// 821C42B8: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821C42BC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821C42C0: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 821C42C4: 4082FFD4  bne 0x821c4298
	if !ctx.cr[0].eq {
	pc = 0x821C4298; continue 'dispatch;
	}
	// 821C42C8: 839C000C  lwz r28, 0xc(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C42CC: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C42D0: 4082FE44  bne 0x821c4114
	if !ctx.cr[0].eq {
	pc = 0x821C4114; continue 'dispatch;
	}
	// 821C42D4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821C42D8: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821C42DC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821C42E0: 48AE5174  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C42E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C42E8 size=20
    let mut pc: u32 = 0x821C42E8;
    'dispatch: loop {
        match pc {
            0x821C42E8 => {
    //   block [0x821C42E8..0x821C42FC)
	// 821C42E8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C42EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C42F0: 4082000C  bne 0x821c42fc
	if !ctx.cr[0].eq {
		sub_821C42FC(ctx, base);
		return;
	}
	// 821C42F4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821C42F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C42FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C42FC size=32
    let mut pc: u32 = 0x821C42FC;
    'dispatch: loop {
        match pc {
            0x821C42FC => {
    //   block [0x821C42FC..0x821C431C)
	// 821C42FC: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 821C4300: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 821C4304: 814A0718  lwz r10, 0x718(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821C4308: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C430C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4310: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821C4314: 7C6B4B96  divwu r3, r11, r9
	ctx.r[3].u32 = ctx.r[11].u32 / ctx.r[9].u32;
	// 821C4318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C4320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C4320 size=88
    let mut pc: u32 = 0x821C4320;
    'dispatch: loop {
        match pc {
            0x821C4320 => {
    //   block [0x821C4320..0x821C4378)
	// 821C4320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C4324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C4328: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 821C432C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C4330: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821C4334: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821C4338: 4BFFFFB1  bl 0x821c42e8
	ctx.lr = 0x821C433C;
	sub_821C42E8(ctx, base);
	// 821C433C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821C4340: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821C4344: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C4348: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C434C: 40980018  bge cr6, 0x821c4364
	if !ctx.cr[6].lt {
	pc = 0x821C4364; continue 'dispatch;
	}
	// 821C4350: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C4354: 1D43001C  mulli r10, r3, 0x1c
	ctx.r[10].s64 = ctx.r[3].s64 * 28;
	// 821C4358: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C435C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C4360: D3EB000C  stfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821C4364: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C4368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C436C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C4370: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C4374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C4378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C4378 size=1732
    let mut pc: u32 = 0x821C4378;
    'dispatch: loop {
        match pc {
            0x821C4378 => {
    //   block [0x821C4378..0x821C4A3C)
	// 821C4378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C437C: 48AE5075  bl 0x82ca93f0
	ctx.lr = 0x821C4380;
	sub_82CA93D0(ctx, base);
	// 821C4380: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 821C4384: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 821C4388: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C438C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C4390: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C4394: 3860007A  li r3, 0x7a
	ctx.r[3].s64 = 122;
	// 821C4398: 897B00D8  lbz r11, 0xd8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(216 as u32) ) } as u64;
	// 821C439C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C43A0: 419A0010  beq cr6, 0x821c43b0
	if ctx.cr[6].eq {
	pc = 0x821C43B0; continue 'dispatch;
	}
	// 821C43A4: 48067E6D  bl 0x8222c210
	ctx.lr = 0x821C43A8;
	sub_8222C210(ctx, base);
	// 821C43A8: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 821C43AC: 4800000C  b 0x821c43b8
	pc = 0x821C43B8; continue 'dispatch;
	// 821C43B0: 48067E61  bl 0x8222c210
	ctx.lr = 0x821C43B4;
	sub_8222C210(ctx, base);
	// 821C43B4: 3860007B  li r3, 0x7b
	ctx.r[3].s64 = 123;
	// 821C43B8: 48044759  bl 0x82208b10
	ctx.lr = 0x821C43BC;
	sub_82208B10(ctx, base);
	// 821C43BC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C43C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C43C4: 3EE08336  lis r23, -0x7cca
	ctx.r[23].s64 = -2093613056;
	// 821C43C8: 7958FFE6  rldicr r24, r10, 0x3f, 0x3f
	ctx.r[24].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821C43CC: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 821C43D0: 79690004  rldicr r9, r11, 0, 0
	ctx.r[9].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821C43D4: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821C43D8: 419A001C  beq cr6, 0x821c43f4
	if ctx.cr[6].eq {
	pc = 0x821C43F4; continue 'dispatch;
	}
	// 821C43DC: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 821C43E0: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C43E4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821C43E8: 38BF06B0  addi r5, r31, 0x6b0
	ctx.r[5].s64 = ctx.r[31].s64 + 1712;
	// 821C43EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C43F0: 48056491  bl 0x8221a880
	ctx.lr = 0x821C43F4;
	sub_8221A880(ctx, base);
	// 821C43F4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C43F8: 815B0284  lwz r10, 0x284(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(644 as u32) ) } as u64;
	// 821C43FC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821C4400: 390B60B8  addi r8, r11, 0x60b8
	ctx.r[8].s64 = ctx.r[11].s64 + 24760;
	// 821C4404: 38E99484  addi r7, r9, -0x6b7c
	ctx.r[7].s64 = ctx.r[9].s64 + -27516;
	// 821C4408: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 821C440C: 83EB60B8  lwz r31, 0x60b8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24760 as u32) ) } as u64;
	// 821C4410: C3E99484  lfs f31, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C4414: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4418: 83A80008  lwz r29, 8(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C441C: C3C7000C  lfs f30, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821C4420: 8388000C  lwz r28, 0xc(r8)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C4424: 419A000C  beq cr6, 0x821c4430
	if ctx.cr[6].eq {
	pc = 0x821C4430; continue 'dispatch;
	}
	// 821C4428: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821C442C: 48000008  b 0x821c4434
	pc = 0x821C4434; continue 'dispatch;
	// 821C4430: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821C4434: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821C4438: 48024841  bl 0x821e8c78
	ctx.lr = 0x821C443C;
	sub_821E8C78(ctx, base);
	// 821C443C: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 821C4440: 7D5EE050  subf r10, r30, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821C4444: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821C4448: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 821C444C: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821C4450: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 821C4454: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821C4458: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821C445C: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 821C4460: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821C4464: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 821C4468: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821C446C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 821C4470: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C4474: 38600073  li r3, 0x73
	ctx.r[3].s64 = 115;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C4A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C4A40 size=1284
    let mut pc: u32 = 0x821C4A40;
    'dispatch: loop {
        match pc {
            0x821C4A40 => {
    //   block [0x821C4A40..0x821C4F44)
	// 821C4A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C4A44: 48AE49C9  bl 0x82ca940c
	ctx.lr = 0x821C4A48;
	sub_82CA93D0(ctx, base);
	// 821C4A48: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C4A4C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821C4A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C4A54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821C4A58: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C4A5C: 3860006E  li r3, 0x6e
	ctx.r[3].s64 = 110;
	// 821C4A60: 996A05A1  stb r11, 0x5a1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(1441 as u32), ctx.r[11].u8 ) };
	// 821C4A64: 4805C89D  bl 0x82221300
	ctx.lr = 0x821C4A68;
	sub_82221300(ctx, base);
	// 821C4A68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C4A6C: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 821C4A70: 4805CAF1  bl 0x82221560
	ctx.lr = 0x821C4A74;
	sub_82221560(ctx, base);
	// 821C4A74: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821C4A78: 38E00071  li r7, 0x71
	ctx.r[7].s64 = 113;
	// 821C4A7C: 386943D8  addi r3, r9, 0x43d8
	ctx.r[3].s64 = ctx.r[9].s64 + 17368;
	// 821C4A80: 38C0006F  li r6, 0x6f
	ctx.r[6].s64 = 111;
	// 821C4A84: 38A00070  li r5, 0x70
	ctx.r[5].s64 = 112;
	// 821C4A88: 3880006E  li r4, 0x6e
	ctx.r[4].s64 = 110;
	// 821C4A8C: 4805BE6D  bl 0x822208f8
	ctx.lr = 0x821C4A90;
	sub_822208F8(ctx, base);
	// 821C4A90: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C4A94: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C4A98: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821C4A9C: 38AA2390  addi r5, r10, 0x2390
	ctx.r[5].s64 = ctx.r[10].s64 + 9104;
	// 821C4AA0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C4AA4: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 821C4AA8: 386A0DB8  addi r3, r10, 0xdb8
	ctx.r[3].s64 = ctx.r[10].s64 + 3512;
	// 821C4AAC: 890B00D5  lbz r8, 0xd5(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(213 as u32) ) } as u64;
	// 821C4AB0: 814B00C4  lwz r10, 0xc4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821C4AB4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821C4AB8: 1D482008  mulli r10, r8, 0x2008
	ctx.r[10].s64 = ctx.r[8].s64 * 8200;
	// 821C4ABC: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4AC0: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4AC4: 419A0084  beq cr6, 0x821c4b48
	if ctx.cr[6].eq {
	pc = 0x821C4B48; continue 'dispatch;
	}
	// 821C4AC8: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4ACC: 810B00C8  lwz r8, 0xc8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 821C4AD0: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4AD4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C4AD8: 409A003C  bne cr6, 0x821c4b14
	if !ctx.cr[6].eq {
	pc = 0x821C4B14; continue 'dispatch;
	}
	// 821C4ADC: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4AE0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4AE4: 38CB00C0  addi r6, r11, 0xc0
	ctx.r[6].s64 = ctx.r[11].s64 + 192;
	// 821C4AE8: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4AEC: 912B00C8  stw r9, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 821C4AF0: 7CC8512E  stwx r6, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 821C4AF4: 812B00C4  lwz r9, 0xc4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821C4AF8: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4AFC: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4B00: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4B04: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4B08: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4B0C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C4B10: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C4B14: 894B00D4  lbz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 821C4B18: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C4B1C: 912B00C4  stw r9, 0xc4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 821C4B20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4B24: 409A0024  bne cr6, 0x821c4b48
	if !ctx.cr[6].eq {
	pc = 0x821C4B48; continue 'dispatch;
	}
	// 821C4B28: 81440DB0  lwz r10, 0xdb0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C4B2C: 390B00C0  addi r8, r11, 0xc0
	ctx.r[8].s64 = ctx.r[11].s64 + 192;
	// 821C4B30: 992B00D4  stb r9, 0xd4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[9].u8 ) };
	// 821C4B34: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C4B38: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 821C4B3C: 90E40DB0  stw r7, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 821C4B40: 7D06192E  stwx r8, r6, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[3].u32), ctx.r[8].u32) };
	// 821C4B44: 48000008  b 0x821c4b4c
	pc = 0x821C4B4C; continue 'dispatch;
	// 821C4B48: 80E40DB0  lwz r7, 0xdb0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C4B4C: 894B00BD  lbz r10, 0xbd(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(189 as u32) ) } as u64;
	// 821C4B50: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C4B54: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C4B58: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4B5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C4B60: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4B64: 419A0080  beq cr6, 0x821c4be4
	if ctx.cr[6].eq {
	pc = 0x821C4BE4; continue 'dispatch;
	}
	// 821C4B68: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4B6C: 810B00B0  lwz r8, 0xb0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 821C4B70: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4B74: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C4B78: 409A003C  bne cr6, 0x821c4bb4
	if !ctx.cr[6].eq {
	pc = 0x821C4BB4; continue 'dispatch;
	}
	// 821C4B7C: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4B80: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4B84: 390B00A8  addi r8, r11, 0xa8
	ctx.r[8].s64 = ctx.r[11].s64 + 168;
	// 821C4B88: 54C61838  slwi r6, r6, 3
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C4B8C: 912B00B0  stw r9, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[9].u32 ) };
	// 821C4B90: 7D06512E  stwx r8, r6, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C4B94: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C4B98: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4B9C: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4BA0: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4BA4: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4BA8: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4BAC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C4BB0: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C4BB4: 894B00BC  lbz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821C4BB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C4BBC: 912B00AC  stw r9, 0xac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 821C4BC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4BC4: 409A0020  bne cr6, 0x821c4be4
	if !ctx.cr[6].eq {
	pc = 0x821C4BE4; continue 'dispatch;
	}
	// 821C4BC8: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C4BCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C4BD0: 390B00A8  addi r8, r11, 0xa8
	ctx.r[8].s64 = ctx.r[11].s64 + 168;
	// 821C4BD4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821C4BD8: 994B00BC  stb r10, 0xbc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 821C4BDC: 90E40DB0  stw r7, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 821C4BE0: 7D09192E  stwx r8, r9, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), ctx.r[8].u32) };
	// 821C4BE4: 894B19F5  lbz r10, 0x19f5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6645 as u32) ) } as u64;
	// 821C4BE8: 812B19E4  lwz r9, 0x19e4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6628 as u32) ) } as u64;
	// 821C4BEC: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C4BF0: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4BF4: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821C4BF8: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4BFC: 419A0080  beq cr6, 0x821c4c7c
	if ctx.cr[6].eq {
	pc = 0x821C4C7C; continue 'dispatch;
	}
	// 821C4C00: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4C04: 810B19E8  lwz r8, 0x19e8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6632 as u32) ) } as u64;
	// 821C4C08: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4C0C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C4C10: 409A003C  bne cr6, 0x821c4c4c
	if !ctx.cr[6].eq {
	pc = 0x821C4C4C; continue 'dispatch;
	}
	// 821C4C14: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4C18: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4C1C: 390B19E0  addi r8, r11, 0x19e0
	ctx.r[8].s64 = ctx.r[11].s64 + 6624;
	// 821C4C20: 54C61838  slwi r6, r6, 3
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C4C24: 912B19E8  stw r9, 0x19e8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6632 as u32), ctx.r[9].u32 ) };
	// 821C4C28: 7D06512E  stwx r8, r6, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C4C2C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4C30: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4C34: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4C38: 812B19E4  lwz r9, 0x19e4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6628 as u32) ) } as u64;
	// 821C4C3C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4C40: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4C44: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821C4C48: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	// 821C4C4C: 894B19F4  lbz r10, 0x19f4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6644 as u32) ) } as u64;
	// 821C4C50: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C4C54: 912B19E4  stw r9, 0x19e4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6628 as u32), ctx.r[9].u32 ) };
	// 821C4C58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4C5C: 409A0020  bne cr6, 0x821c4c7c
	if !ctx.cr[6].eq {
	pc = 0x821C4C7C; continue 'dispatch;
	}
	// 821C4C60: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C4C64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C4C68: 390B19E0  addi r8, r11, 0x19e0
	ctx.r[8].s64 = ctx.r[11].s64 + 6624;
	// 821C4C6C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821C4C70: 994B19F4  stb r10, 0x19f4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6644 as u32), ctx.r[10].u8 ) };
	// 821C4C74: 90E40DB0  stw r7, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 821C4C78: 7D09192E  stwx r8, r9, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), ctx.r[8].u32) };
	// 821C4C7C: 894B1A0D  lbz r10, 0x1a0d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6669 as u32) ) } as u64;
	// 821C4C80: 812B19FC  lwz r9, 0x19fc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6652 as u32) ) } as u64;
	// 821C4C84: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s64 = ctx.r[10].s64 * 8200;
	// 821C4C88: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4C8C: 2B0900AA  cmplwi cr6, r9, 0xaa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 170 as u32, &mut ctx.xer);
	// 821C4C90: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4C94: 419A0080  beq cr6, 0x821c4d14
	if ctx.cr[6].eq {
	pc = 0x821C4D14; continue 'dispatch;
	}
	// 821C4C98: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4C9C: 810B1A00  lwz r8, 0x1a00(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6656 as u32) ) } as u64;
	// 821C4CA0: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4CA4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C4CA8: 409A003C  bne cr6, 0x821c4ce4
	if !ctx.cr[6].eq {
	pc = 0x821C4CE4; continue 'dispatch;
	}
	// 821C4CAC: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4CB0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4CB4: 390B19F8  addi r8, r11, 0x19f8
	ctx.r[8].s64 = ctx.r[11].s64 + 6648;
	// 821C4CB8: 54C61838  slwi r6, r6, 3
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C4CBC: 912B1A00  stw r9, 0x1a00(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6656 as u32), ctx.r[9].u32 ) };
	// 821C4CC0: 7D06512E  stwx r8, r6, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C4CC4: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4CC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4CCC: 812B19FC  lwz r9, 0x19fc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6652 as u32) ) } as u64;
	// 821C4CD0: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4CD4: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4CD8: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4CDC: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821C4CE0: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	// 821C4CE4: 894B1A0C  lbz r10, 0x1a0c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6668 as u32) ) } as u64;
	// 821C4CE8: 392000AA  li r9, 0xaa
	ctx.r[9].s64 = 170;
	// 821C4CEC: 912B19FC  stw r9, 0x19fc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6652 as u32), ctx.r[9].u32 ) };
	// 821C4CF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4CF4: 409A0020  bne cr6, 0x821c4d14
	if !ctx.cr[6].eq {
	pc = 0x821C4D14; continue 'dispatch;
	}
	// 821C4CF8: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C4CFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C4D00: 390B19F8  addi r8, r11, 0x19f8
	ctx.r[8].s64 = ctx.r[11].s64 + 6648;
	// 821C4D04: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821C4D08: 994B1A0C  stb r10, 0x1a0c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6668 as u32), ctx.r[10].u8 ) };
	// 821C4D0C: 90E40DB0  stw r7, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 821C4D10: 7D09192E  stwx r8, r9, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), ctx.r[8].u32) };
	// 821C4D14: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821C4D18: 88CB008D  lbz r6, 0x8d(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(141 as u32) ) } as u64;
	// 821C4D1C: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C4D20: 39087064  addi r8, r8, 0x7064
	ctx.r[8].s64 = ctx.r[8].s64 + 28772;
	// 821C4D24: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s64 = ctx.r[6].s64 * 8200;
	// 821C4D28: 80C80008  lwz r6, 8(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4D2C: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4D30: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C4D34: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4D38: 419A007C  beq cr6, 0x821c4db4
	if ctx.cr[6].eq {
	pc = 0x821C4DB4; continue 'dispatch;
	}
	// 821C4D3C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4D40: 810B0080  lwz r8, 0x80(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C4D44: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4D48: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821C4D4C: 409A003C  bne cr6, 0x821c4d88
	if !ctx.cr[6].eq {
	pc = 0x821C4D88; continue 'dispatch;
	}
	// 821C4D50: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4D54: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4D58: 390B0078  addi r8, r11, 0x78
	ctx.r[8].s64 = ctx.r[11].s64 + 120;
	// 821C4D5C: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C4D60: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821C4D64: 7D05512E  stwx r8, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C4D68: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C4D6C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4D70: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4D74: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4D78: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4D7C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4D80: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C4D84: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C4D88: 894B008C  lbz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C4D8C: 90CB007C  stw r6, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[6].u32 ) };
	// 821C4D90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4D94: 409A0020  bne cr6, 0x821c4db4
	if !ctx.cr[6].eq {
	pc = 0x821C4DB4; continue 'dispatch;
	}
	// 821C4D98: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4D9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C4DA0: 38CB0078  addi r6, r11, 0x78
	ctx.r[6].s64 = ctx.r[11].s64 + 120;
	// 821C4DA4: 39270001  addi r9, r7, 1
	ctx.r[9].s64 = ctx.r[7].s64 + 1;
	// 821C4DA8: 994B008C  stb r10, 0x8c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 821C4DAC: 91240DB0  stw r9, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 821C4DB0: 7CC8192E  stwx r6, r8, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32), ctx.r[6].u32) };
	// 821C4DB4: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4DB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821C4DBC: 389F0150  addi r4, r31, 0x150
	ctx.r[4].s64 = ctx.r[31].s64 + 336;
	// 821C4DC0: 480ABF11  bl 0x82270cd0
	ctx.lr = 0x821C4DC4;
	sub_82270CD0(ctx, base);
	// 821C4DC4: 397F0110  addi r11, r31, 0x110
	ctx.r[11].s64 = ctx.r[31].s64 + 272;
	// 821C4DC8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 821C4DCC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C4DD0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C4DD4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C4DD8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C4DDC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C4DE0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C4DE4: 4200FFF0  bdnz 0x821c4dd4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C4DD4; continue 'dispatch;
	}
	// 821C4DE8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821C4DEC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 821C4DF0: 480ABEE1  bl 0x82270cd0
	ctx.lr = 0x821C4DF4;
	sub_82270CD0(ctx, base);
	// 821C4DF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C4DF8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C4DFC: 3BCB9490  addi r30, r11, -0x6b70
	ctx.r[30].s64 = ctx.r[11].s64 + -27504;
	// 821C4E00: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 821C4E04: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 821C4E08: 38E10098  addi r7, r1, 0x98
	ctx.r[7].s64 = ctx.r[1].s64 + 152;
	// 821C4E0C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821C4E10: C01EFFF4  lfs f0, -0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4E14: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 821C4E18: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821C4E1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C4F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C4F48 size=1796
    let mut pc: u32 = 0x821C4F48;
    'dispatch: loop {
        match pc {
            0x821C4F48 => {
    //   block [0x821C4F48..0x821C564C)
	// 821C4F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C4F4C: 48AE44BD  bl 0x82ca9408
	ctx.lr = 0x821C4F50;
	sub_82CA93D0(ctx, base);
	// 821C4F50: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C4F54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C4F58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C4F5C: 39200470  li r9, 0x470
	ctx.r[9].s64 = 1136;
	// 821C4F60: 3BAB93BC  addi r29, r11, -0x6c44
	ctx.r[29].s64 = ctx.r[11].s64 + -27716;
	// 821C4F64: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 821C4F68: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4F6C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821C4F70: C01D3800  lfs f0, 0x3800(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4F74: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821C4F78: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C4F7C: C1879A80  lfs f12, -0x6580(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C4F80: C1BD2E64  lfs f13, 0x2e64(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(11876 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C4F84: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C5650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C5650 size=64
    let mut pc: u32 = 0x821C5650;
    'dispatch: loop {
        match pc {
            0x821C5650 => {
    //   block [0x821C5650..0x821C5690)
	// 821C5650: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821C5654: 39800020  li r12, 0x20
	ctx.r[12].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C5690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C5690 size=44
    let mut pc: u32 = 0x821C5690;
    'dispatch: loop {
        match pc {
            0x821C5690 => {
    //   block [0x821C5690..0x821C56BC)
	// 821C5690: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821C5694: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C5698: 7CEA0194  addze r7, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[7].s64 = tmp.s64;
	// 821C569C: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C56A0: 792AFFE6  rldicr r10, r9, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821C56A4: 7CE607B4  extsw r6, r7
	ctx.r[6].s64 = ctx.r[7].s32 as i64;
	// 821C56A8: 7D453436  srd r5, r10, r6
	if (ctx.r[6].u8 & 0x40) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = (ctx.r[10].u64) >> ((ctx.r[6].u8 & 0x3F) as u32);
	}
	// 821C56AC: E9281760  ld r9, 0x1760(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(5984 as u32) ) };
	// 821C56B0: 7CA44838  and r4, r5, r9
	ctx.r[4].u64 = ctx.r[5].u64 & ctx.r[9].u64;
	// 821C56B4: 2B240000  cmpldi cr6, r4, 0
	ctx.cr[6].compare_u64(ctx.r[4].u64, 0, &mut ctx.xer);
	// 821C56B8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C56BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C56BC size=88
    let mut pc: u32 = 0x821C56BC;
    'dispatch: loop {
        match pc {
            0x821C56BC => {
    //   block [0x821C56BC..0x821C5714)
	// 821C56BC: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 821C56C0: 5567F0BE  srwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C56C4: 38CB0078  addi r6, r11, 0x78
	ctx.r[6].s64 = ctx.r[11].s64 + 120;
	// 821C56C8: 55692036  slwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C56CC: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 821C56D0: 81680364  lwz r11, 0x364(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C56D4: 54C42036  slwi r4, r6, 4
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821C56D8: 7C673850  subf r3, r7, r7
	ctx.r[3].s64 = ctx.r[7].s64 - ctx.r[7].s64;
	// 821C56DC: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821C56E0: D1AA0784  stfs f13, 0x784(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1924 as u32), tmp.u32 ) };
	// 821C56E4: 78690020  clrldi r9, r3, 0x20
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 821C56E8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821C56EC: 7C045D2E  stfsx f0, r4, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821C56F0: 7CA64E34  srad r6, r5, r9
	tmp.u64 = (ctx.r[9].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[5].s64 < 0) && ((ctx.r[5].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[6].s64 = ctx.r[5].s64 >> tmp.u64;
	// 821C56F4: D18A0788  stfs f12, 0x788(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1928 as u32), tmp.u32 ) };
	// 821C56F8: 7CC53C36  srd r5, r6, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = (ctx.r[6].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 821C56FC: C0089484  lfs f0, -0x6b7c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C5700: D00A078C  stfs f0, 0x78c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1932 as u32), tmp.u32 ) };
	// 821C5704: E88B0000  ld r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C5708: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 821C570C: F86B0000  std r3, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 821C5710: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C5718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C5718 size=76
    let mut pc: u32 = 0x821C5718;
    'dispatch: loop {
        match pc {
            0x821C5718 => {
    //   block [0x821C5718..0x821C5764)
	// 821C5718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C571C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C5720: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C5724: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C5728: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C572C: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C5730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5734: 419A001C  beq cr6, 0x821c5750
	if ctx.cr[6].eq {
	pc = 0x821C5750; continue 'dispatch;
	}
	// 821C5738: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 821C573C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5740: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5744: 4826068D  bl 0x82425dd0
	ctx.lr = 0x821C5748;
	sub_82425DD0(ctx, base);
	// 821C5748: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C574C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 821C5750: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C5754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C5758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C575C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C5760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C5768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C5768 size=1096
    let mut pc: u32 = 0x821C5768;
    'dispatch: loop {
        match pc {
            0x821C5768 => {
    //   block [0x821C5768..0x821C5BB0)
	// 821C5768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C576C: 48AE3C75  bl 0x82ca93e0
	ctx.lr = 0x821C5770;
	sub_82CA93D0(ctx, base);
	// 821C5770: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 821C5774: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C5778: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C577C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821C5780: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C5784: 3BEB8214  addi r31, r11, -0x7dec
	ctx.r[31].s64 = ctx.r[11].s64 + -32236;
	// 821C5788: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C578C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5790: 419A00E8  beq cr6, 0x821c5878
	if ctx.cr[6].eq {
	pc = 0x821C5878; continue 'dispatch;
	}
	// 821C5794: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5798: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 821C579C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C57A0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C57A4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C57A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C57AC: 419A000C  beq cr6, 0x821c57b8
	if ctx.cr[6].eq {
	pc = 0x821C57B8; continue 'dispatch;
	}
	// 821C57B0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821C57B4: 419A0008  beq cr6, 0x821c57bc
	if ctx.cr[6].eq {
	pc = 0x821C57BC; continue 'dispatch;
	}
	// 821C57B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C57BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C57C0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821C57C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C57C8: 419A00A8  beq cr6, 0x821c5870
	if ctx.cr[6].eq {
	pc = 0x821C5870; continue 'dispatch;
	}
	// 821C57CC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C57D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C57D4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821C57D8: 488D6D41  bl 0x82a9c518
	ctx.lr = 0x821C57DC;
	sub_82A9C518(ctx, base);
	// 821C57DC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821C57E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C57E4: 409A0008  bne cr6, 0x821c57ec
	if !ctx.cr[6].eq {
	pc = 0x821C57EC; continue 'dispatch;
	}
	// 821C57E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C57EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C57F0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821C57F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C57F8: 409A0008  bne cr6, 0x821c5800
	if !ctx.cr[6].eq {
	pc = 0x821C5800; continue 'dispatch;
	}
	// 821C57FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C5800: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 821C5804: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C5808: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 821C580C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5810: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C5818: 419AFF8C  beq cr6, 0x821c57a4
	if ctx.cr[6].eq {
	pc = 0x821C57A4; continue 'dispatch;
	}
	// 821C581C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5820: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C5824: 419A0020  beq cr6, 0x821c5844
	if ctx.cr[6].eq {
	pc = 0x821C5844; continue 'dispatch;
	}
	// 821C5828: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C582C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5830: 419AFF74  beq cr6, 0x821c57a4
	if ctx.cr[6].eq {
	pc = 0x821C57A4; continue 'dispatch;
	}
	// 821C5834: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 821C5838: 409A0018  bne cr6, 0x821c5850
	if !ctx.cr[6].eq {
	pc = 0x821C5850; continue 'dispatch;
	}
	// 821C583C: 4852B955  bl 0x826f1190
	ctx.lr = 0x821C5840;
	sub_826F1190(ctx, base);
	// 821C5840: 4BFFFF64  b 0x821c57a4
	pc = 0x821C57A4; continue 'dispatch;
	// 821C5844: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C5848: 4BFCE5F1  bl 0x82193e38
	ctx.lr = 0x821C584C;
	sub_82193E38(ctx, base);
	// 821C584C: 4BFFFF58  b 0x821c57a4
	pc = 0x821C57A4; continue 'dispatch;
	// 821C5850: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 821C5854: 409A000C  bne cr6, 0x821c5860
	if !ctx.cr[6].eq {
	pc = 0x821C5860; continue 'dispatch;
	}
	// 821C5858: 4852BBC1  bl 0x826f1418
	ctx.lr = 0x821C585C;
	sub_826F1418(ctx, base);
	// 821C585C: 4BFFFF48  b 0x821c57a4
	pc = 0x821C57A4; continue 'dispatch;
	// 821C5860: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 821C5864: 409AFF40  bne cr6, 0x821c57a4
	if !ctx.cr[6].eq {
	pc = 0x821C57A4; continue 'dispatch;
	}
	// 821C5868: 4852BA79  bl 0x826f12e0
	ctx.lr = 0x821C586C;
	sub_826F12E0(ctx, base);
	// 821C586C: 4BFFFF38  b 0x821c57a4
	pc = 0x821C57A4; continue 'dispatch;
	// 821C5870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5874: 4829036D  bl 0x82455be0
	ctx.lr = 0x821C5878;
	sub_82455BE0(ctx, base);
	// 821C5878: 897E0020  lbz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C587C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5880: 419A0324  beq cr6, 0x821c5ba4
	if ctx.cr[6].eq {
	pc = 0x821C5BA4; continue 'dispatch;
	}
	// 821C5884: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C588C: 419A0318  beq cr6, 0x821c5ba4
	if ctx.cr[6].eq {
	pc = 0x821C5BA4; continue 'dispatch;
	}
	// 821C5890: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821C5894: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821C5898: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C589C: 997F6BC6  stb r11, 0x6bc6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(27590 as u32), ctx.r[11].u8 ) };
	// 821C58A0: 48BB2BD1  bl 0x82d78470
	ctx.lr = 0x821C58A4;
	sub_82D78470(ctx, base);
	// 821C58A4: 3E40834C  lis r18, -0x7cb4
	ctx.r[18].s64 = -2092171264;
	// 821C58A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C58AC: 997F6BC6  stb r11, 0x6bc6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(27590 as u32), ctx.r[11].u8 ) };
	// 821C58B0: 8972EA0E  lbz r11, -0x15f2(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(-5618 as u32) ) } as u64;
	// 821C58B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C58B8: 419A02EC  beq cr6, 0x821c5ba4
	if ctx.cr[6].eq {
	pc = 0x821C5BA4; continue 'dispatch;
	}
	// 821C58BC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C58C0: 48BB3601  bl 0x82d78ec0
	ctx.lr = 0x821C58C4;
	sub_82D78EC0(ctx, base);
	// 821C58C4: 82ED0000  lwz r23, 0(r13)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C58C8: 3AC00004  li r22, 4
	ctx.r[22].s64 = 4;
	// 821C58CC: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 821C58D0: 38800044  li r4, 0x44
	ctx.r[4].s64 = 68;
	// 821C58D4: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821C58D8: 7C76B82E  lwzx r3, r22, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 821C58DC: 48B8F96D  bl 0x82d55248
	ctx.lr = 0x821C58E0;
	sub_82D55248(ctx, base);
	// 821C58E0: 39600044  li r11, 0x44
	ctx.r[11].s64 = 68;
	// 821C58E4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 821C58E8: 48BBD581  bl 0x82d82e68
	ctx.lr = 0x821C58EC;
	sub_82D82E68(ctx, base);
	// 821C58EC: 8153000C  lwz r10, 0xc(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C58F0: 3B930008  addi r28, r19, 8
	ctx.r[28].s64 = ctx.r[19].s64 + 8;
	// 821C58F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C58F8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821C58FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C5900: 419A00E0  beq cr6, 0x821c59e0
	if ctx.cr[6].eq {
	pc = 0x821C59E0; continue 'dispatch;
	}
	// 821C5904: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821C5908: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821C590C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821C5910: 3EA0834C  lis r21, -0x7cb4
	ctx.r[21].s64 = -2092171264;
	// 821C5914: 3E80834C  lis r20, -0x7cb4
	ctx.r[20].s64 = -2092171264;
	// 821C5918: 3B0B0CA0  addi r24, r11, 0xca0
	ctx.r[24].s64 = ctx.r[11].s64 + 3232;
	// 821C591C: 3B6A6E58  addi r27, r10, 0x6e58
	ctx.r[27].s64 = ctx.r[10].s64 + 28248;
	// 821C5920: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5924: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821C5928: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C592C: 7FDA582E  lwzx r30, r26, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821C5930: 809E0070  lwz r4, 0x70(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 821C5934: 4806759D  bl 0x8222ced0
	ctx.lr = 0x821C5938;
	sub_8222CED0(ctx, base);
	// 821C5938: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C593C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5940: 409A0038  bne cr6, 0x821c5978
	if !ctx.cr[6].eq {
	pc = 0x821C5978; continue 'dispatch;
	}
	// 821C5944: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821C5948: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821C594C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5950: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5954: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5958: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821C595C: 419A0014  beq cr6, 0x821c5970
	if ctx.cr[6].eq {
	pc = 0x821C5970; continue 'dispatch;
	}
	// 821C5960: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C5964: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C5968: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C596C: 419AFFE0  beq cr6, 0x821c594c
	if ctx.cr[6].eq {
	pc = 0x821C594C; continue 'dispatch;
	}
	// 821C5970: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C5974: 48000014  b 0x821c5988
	pc = 0x821C5988; continue 'dispatch;
	// 821C5978: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821C597C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5980: 480A7E79  bl 0x8226d7f8
	ctx.lr = 0x821C5984;
	sub_8226D7F8(ctx, base);
	// 821C5984: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821C5988: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C598C: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821C5990: 4804F449  bl 0x82214dd8
	ctx.lr = 0x821C5994;
	sub_82214DD8(ctx, base);
	// 821C5994: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821C5998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C599C: 419A000C  beq cr6, 0x821c59a8
	if ctx.cr[6].eq {
	pc = 0x821C59A8; continue 'dispatch;
	}
	// 821C59A0: 8974EA0F  lbz r11, -0x15f1(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(-5617 as u32) ) } as u64;
	// 821C59A4: 48000014  b 0x821c59b8
	pc = 0x821C59B8; continue 'dispatch;
	// 821C59A8: 897E00D8  lbz r11, 0xd8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(216 as u32) ) } as u64;
	// 821C59AC: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 821C59B0: 409A0010  bne cr6, 0x821c59c0
	if !ctx.cr[6].eq {
	pc = 0x821C59C0; continue 'dispatch;
	}
	// 821C59B4: 8975EA10  lbz r11, -0x15f0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(-5616 as u32) ) } as u64;
	// 821C59B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C59BC: 419A0010  beq cr6, 0x821c59cc
	if ctx.cr[6].eq {
	pc = 0x821C59CC; continue 'dispatch;
	}
	// 821C59C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C59C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C59C8: 48BBDA21  bl 0x82d833e8
	ctx.lr = 0x821C59CC;
	sub_82D833E8(ctx, base);
	// 821C59CC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C59D0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 821C59D4: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 821C59D8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C59DC: 409AFF44  bne cr6, 0x821c5920
	if !ctx.cr[6].eq {
	pc = 0x821C5920; continue 'dispatch;
	}
	// 821C59E0: 38A0000D  li r5, 0xd
	ctx.r[5].s64 = 13;
	// 821C59E4: 7C76B82E  lwzx r3, r22, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 821C59E8: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 821C59EC: 48B8F85D  bl 0x82d55248
	ctx.lr = 0x821C59F0;
	sub_82D55248(ctx, base);
	// 821C59F0: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 821C59F4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 821C59F8: 48C85A11  bl 0x82e4b408
	ctx.lr = 0x821C59FC;
	sub_82E4B408(ctx, base);
	// 821C59FC: A15D0004  lhz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5A00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C5A04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C5A08: 419A0010  beq cr6, 0x821c5a18
	if ctx.cr[6].eq {
	pc = 0x821C5A18; continue 'dispatch;
	}
	// 821C5A0C: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5A10: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821C5A14: B15D0006  sth r10, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 821C5A18: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C5A1C: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 821C5A20: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C5A24: 556900BE  clrlwi r9, r11, 2
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821C5A28: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821C5A2C: 409A0010  bne cr6, 0x821c5a3c
	if !ctx.cr[6].eq {
	pc = 0x821C5A3C; continue 'dispatch;
	}
	// 821C5A30: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821C5A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5A38: 48B91561  bl 0x82d56f98
	ctx.lr = 0x821C5A3C;
	sub_82D56F98(ctx, base);
	// 821C5A3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5A40: 38A00019  li r5, 0x19
	ctx.r[5].s64 = 25;
	// 821C5A44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5A48: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 821C5A4C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C5A50: 7C76B82E  lwzx r3, r22, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 821C5A54: 7FA9512E  stwx r29, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 821C5A58: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5A5C: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821C5A60: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821C5A64: 48B8F7E5  bl 0x82d55248
	ctx.lr = 0x821C5A68;
	sub_82D55248(ctx, base);
	// 821C5A68: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 821C5A6C: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 821C5A70: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
	// 821C5A74: 38866E64  addi r4, r6, 0x6e64
	ctx.r[4].s64 = ctx.r[6].s64 + 28260;
	// 821C5A78: 4828D709  bl 0x82453180
	ctx.lr = 0x821C5A7C;
	sub_82453180(ctx, base);
	// 821C5A7C: 3C80834C  lis r4, -0x7cb4
	ctx.r[4].s64 = -2092171264;
	// 821C5A80: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C5A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C5A88: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 821C5A8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821C5A90: 8964EA11  lbz r11, -0x15ef(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(-5615 as u32) ) } as u64;
	// 821C5A94: 38E96A98  addi r7, r9, 0x6a98
	ctx.r[7].s64 = ctx.r[9].s64 + 27288;
	// 821C5A98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C5A9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C5AA0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 821C5AA4: 88CA0000  lbz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5AA8: 48C86951  bl 0x82e4c3f8
	ctx.lr = 0x821C5AAC;
	sub_82E4C3F8(ctx, base);
	// 821C5AAC: A11F0004  lhz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5AB0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C5AB4: 419A0034  beq cr6, 0x821c5ae8
	if ctx.cr[6].eq {
	pc = 0x821C5AE8; continue 'dispatch;
	}
	// 821C5AB8: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5ABC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821C5AC0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 821C5AC4: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 821C5AC8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5ACC: 409A001C  bne cr6, 0x821c5ae8
	if !ctx.cr[6].eq {
	pc = 0x821C5AE8; continue 'dispatch;
	}
	// 821C5AD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5AD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C5AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5ADC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5AE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5AE4: 4E800421  bctrl
	ctx.lr = 0x821C5AE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5AE8: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5AF0: 419A0034  beq cr6, 0x821c5b24
	if ctx.cr[6].eq {
	pc = 0x821C5B24; continue 'dispatch;
	}
	// 821C5AF4: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5AF8: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821C5AFC: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 821C5B00: B13E0006  sth r9, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 821C5B04: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5B08: 409A001C  bne cr6, 0x821c5b24
	if !ctx.cr[6].eq {
	pc = 0x821C5B24; continue 'dispatch;
	}
	// 821C5B0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C5B14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C5B18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5B20: 4E800421  bctrl
	ctx.lr = 0x821C5B24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5B24: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5B2C: 419A0034  beq cr6, 0x821c5b60
	if ctx.cr[6].eq {
	pc = 0x821C5B60; continue 'dispatch;
	}
	// 821C5B30: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5B34: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821C5B38: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 821C5B3C: B13D0006  sth r9, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 821C5B40: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5B44: 409A001C  bne cr6, 0x821c5b60
	if !ctx.cr[6].eq {
	pc = 0x821C5B60; continue 'dispatch;
	}
	// 821C5B48: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C5B50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C5B54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5B5C: 4E800421  bctrl
	ctx.lr = 0x821C5B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5B60: A1730004  lhz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5B68: 419A0034  beq cr6, 0x821c5b9c
	if ctx.cr[6].eq {
	pc = 0x821C5B9C; continue 'dispatch;
	}
	// 821C5B6C: A1730006  lhz r11, 6(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[19].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5B70: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821C5B74: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 821C5B78: B1330006  sth r9, 6(r19)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[19].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 821C5B7C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5B80: 409A001C  bne cr6, 0x821c5b9c
	if !ctx.cr[6].eq {
	pc = 0x821C5B9C; continue 'dispatch;
	}
	// 821C5B84: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C5B8C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821C5B90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5B98: 4E800421  bctrl
	ctx.lr = 0x821C5B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5B9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C5BA0: 9972EA0E  stb r11, -0x15f2(r18)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[18].u32.wrapping_add(-5618 as u32), ctx.r[11].u8 ) };
	// 821C5BA4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821C5BA8: CBE1FF80  lfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 821C5BAC: 48AE3884  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C5BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C5BB0 size=2248
    let mut pc: u32 = 0x821C5BB0;
    'dispatch: loop {
        match pc {
            0x821C5BB0 => {
    //   block [0x821C5BB0..0x821C6478)
	// 821C5BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C5BB4: 48AE384D  bl 0x82ca9400
	ctx.lr = 0x821C5BB8;
	sub_82CA93D0(ctx, base);
	// 821C5BB8: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 821C5BBC: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821C5BC0: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821C5BC4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C5BC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821C5BCC: C01C0038  lfs f0, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C5BD0: D03C0038  stfs f1, 0x38(r28)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821C5BD4: EFA10028  fsubs f29, f1, f0
	ctx.f[29].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 821C5BD8: 480BE539  bl 0x82284110
	ctx.lr = 0x821C5BDC;
	sub_82284110(ctx, base);
	// 821C5BDC: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821C5BE0: 817D6B08  lwz r11, 0x6b08(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821C5BE4: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C5BE8: 48026E49  bl 0x821eca30
	ctx.lr = 0x821C5BEC;
	sub_821ECA30(ctx, base);
	// 821C5BEC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C5BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5BF4: 409A0870  bne cr6, 0x821c6464
	if !ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C5BF8: 897C0030  lbz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C5BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5C00: 419A0864  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C5C04: 387C0010  addi r3, r28, 0x10
	ctx.r[3].s64 = ctx.r[28].s64 + 16;
	// 821C5C08: 489A3629  bl 0x82b69230
	ctx.lr = 0x821C5C0C;
	sub_82B69230(ctx, base);
	// 821C5C0C: 815C0028  lwz r10, 0x28(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C5C10: 813C0024  lwz r9, 0x24(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C5C14: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 821C5C18: 3BDC0020  addi r30, r28, 0x20
	ctx.r[30].s64 = ctx.r[28].s64 + 32;
	// 821C5C1C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C5C20: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821C5C24: 7CE85BD7  divw. r7, r8, r11
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821C5C28: 41820090  beq 0x821c5cb8
	if ctx.cr[0].eq {
	pc = 0x821C5CB8; continue 'dispatch;
	}
	// 821C5C2C: 553F003E  slwi r31, r9, 0
	ctx.r[31].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821C5C30: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 821C5C34: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C5C38: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821C5C3C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C5C40: 419A0078  beq cr6, 0x821c5cb8
	if ctx.cr[6].eq {
	pc = 0x821C5CB8; continue 'dispatch;
	}
	// 821C5C44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C5C48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C5C4C: 4821877D  bl 0x823de3c8
	ctx.lr = 0x821C5C50;
	sub_823DE3C8(ctx, base);
	// 821C5C50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C5C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5C58: 419A004C  beq cr6, 0x821c5ca4
	if ctx.cr[6].eq {
	pc = 0x821C5CA4; continue 'dispatch;
	}
	// 821C5C5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C5C60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C5C64: 4821832D  bl 0x823ddf90
	ctx.lr = 0x821C5C68;
	sub_823DDF90(ctx, base);
	// 821C5C68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821C5C6C: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821C5C70: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5C74: 4821966D  bl 0x823df2e0
	ctx.lr = 0x821C5C78;
	sub_823DF2E0(ctx, base);
	// 821C5C78: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5C7C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821C5C80: 3864FFD0  addi r3, r4, -0x30
	ctx.r[3].s64 = ctx.r[4].s64 + -48;
	// 821C5C84: 48204C1D  bl 0x823ca8a0
	ctx.lr = 0x821C5C88;
	sub_823CA8A0(ctx, base);
	// 821C5C88: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C5C8C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5C90: 392BFFD0  addi r9, r11, -0x30
	ctx.r[9].s64 = ctx.r[11].s64 + -48;
	// 821C5C94: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821C5C98: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C5C9C: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C5CA0: 4800000C  b 0x821c5cac
	pc = 0x821C5CAC; continue 'dispatch;
	// 821C5CA4: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821C5CA8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821C5CAC: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C5CB0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C5CB4: 409AFF90  bne cr6, 0x821c5c44
	if !ctx.cr[6].eq {
	pc = 0x821C5C44; continue 'dispatch;
	}
	// 821C5CB8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5CBC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 821C5CC0: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5CC4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821C5CC8: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821C5CCC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821C5CD0: 419A0054  beq cr6, 0x821c5d24
	if ctx.cr[6].eq {
	pc = 0x821C5D24; continue 'dispatch;
	}
	// 821C5CD4: 807B6AB8  lwz r3, 0x6ab8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C5CD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5CDC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C5CE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5CE4: 4E800421  bctrl
	ctx.lr = 0x821C5CE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5CE8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821C5CEC: 807C0048  lwz r3, 0x48(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C5CF0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5CF4: 388B00A0  addi r4, r11, 0xa0
	ctx.r[4].s64 = ctx.r[11].s64 + 160;
	// 821C5CF8: 480D55F1  bl 0x8229b2e8
	ctx.lr = 0x821C5CFC;
	sub_8229B2E8(ctx, base);
	// 821C5CFC: 807B6AB8  lwz r3, 0x6ab8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C5D00: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5D04: 80E80014  lwz r7, 0x14(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C5D08: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821C5D0C: 4E800421  bctrl
	ctx.lr = 0x821C5D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5D10: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821C5D14: 807C004C  lwz r3, 0x4c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C5D18: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5D1C: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 821C5D20: 480D55C9  bl 0x8229b2e8
	ctx.lr = 0x821C5D24;
	sub_8229B2E8(ctx, base);
	// 821C5D24: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5D28: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5D2C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 821C5D30: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C5D34: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821C5D38: 419A0120  beq cr6, 0x821c5e58
	if ctx.cr[6].eq {
	pc = 0x821C5E58; continue 'dispatch;
	}
	// 821C5D3C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5D40: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5D48: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821C5D4C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821C5D50: 419A0020  beq cr6, 0x821c5d70
	if ctx.cr[6].eq {
	pc = 0x821C5D70; continue 'dispatch;
	}
	// 821C5D54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C5D58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C5D5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C5D60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C5D64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C5D68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C5D6C: 4082FFE8  bne 0x821c5d54
	if !ctx.cr[0].eq {
	pc = 0x821C5D54; continue 'dispatch;
	}
	// 821C5D70: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5D74: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5D7C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821C5D80: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 821C5D84: 419A0020  beq cr6, 0x821c5da4
	if ctx.cr[6].eq {
	pc = 0x821C5DA4; continue 'dispatch;
	}
	// 821C5D88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C5D8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C5D90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C5D94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C5D98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C5D9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C5DA0: 4082FFE8  bne 0x821c5d88
	if !ctx.cr[0].eq {
	pc = 0x821C5D88; continue 'dispatch;
	}
	// 821C5DA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C5DA8: 409A0014  bne cr6, 0x821c5dbc
	if !ctx.cr[6].eq {
	pc = 0x821C5DBC; continue 'dispatch;
	}
	// 821C5DAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C5DB0: 4BFF1D69  bl 0x821b7b18
	ctx.lr = 0x821C5DB4;
	sub_821B7B18(ctx, base);
	// 821C5DB4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C5DB8: 48000058  b 0x821c5e10
	pc = 0x821C5E10; continue 'dispatch;
	// 821C5DBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5DC4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C5DC8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5DCC: 4E800421  bctrl
	ctx.lr = 0x821C5DD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5DD0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C5DD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C5DD8: 409A0014  bne cr6, 0x821c5dec
	if !ctx.cr[6].eq {
	pc = 0x821C5DEC; continue 'dispatch;
	}
	// 821C5DDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C5DE0: 4BFF1D39  bl 0x821b7b18
	ctx.lr = 0x821C5DE4;
	sub_821B7B18(ctx, base);
	// 821C5DE4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C5DE8: 48000028  b 0x821c5e10
	pc = 0x821C5E10; continue 'dispatch;
	// 821C5DEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5DF4: 889C0044  lbz r4, 0x44(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 821C5DF8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C5DFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5E00: 4E800421  bctrl
	ctx.lr = 0x821C5E04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5E04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C5E08: 4BFF1D11  bl 0x821b7b18
	ctx.lr = 0x821C5E0C;
	sub_821B7B18(ctx, base);
	// 821C5E0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C5E10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C5E14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5E18: 419A0010  beq cr6, 0x821c5e28
	if ctx.cr[6].eq {
	pc = 0x821C5E28; continue 'dispatch;
	}
	// 821C5E1C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 821C5E20: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821C5E24: 48000020  b 0x821c5e44
	pc = 0x821C5E44; continue 'dispatch;
	// 821C5E28: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821C5E2C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C5E30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821C5E34: 48217FA5  bl 0x823dddd8
	ctx.lr = 0x821C5E38;
	sub_823DDDD8(ctx, base);
	// 821C5E38: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821C5E3C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C5E40: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C5E44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C5E48: 4BFF1CD1  bl 0x821b7b18
	ctx.lr = 0x821C5E4C;
	sub_821B7B18(ctx, base);
	// 821C5E4C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5E50: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C5E54: 409AFEE8  bne cr6, 0x821c5d3c
	if !ctx.cr[6].eq {
	pc = 0x821C5D3C; continue 'dispatch;
	}
	// 821C5E58: 897C0044  lbz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 821C5E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5E60: 419A0604  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C5E64: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C5E68: 394BC080  addi r10, r11, -0x3f80
	ctx.r[10].s64 = ctx.r[11].s64 + -16256;
	// 821C5E6C: 892A0030  lbz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C5E70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C5E74: 419A05D8  beq cr6, 0x821c644c
	if ctx.cr[6].eq {
	pc = 0x821C644C; continue 'dispatch;
	}
	// 821C5E78: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C5E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5E80: 419A05CC  beq cr6, 0x821c644c
	if ctx.cr[6].eq {
	pc = 0x821C644C; continue 'dispatch;
	}
	// 821C5E84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C5E88: 895C003C  lbz r10, 0x3c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 821C5E8C: C19C0034  lfs f12, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C5E90: 392BBC68  addi r9, r11, -0x4398
	ctx.r[9].s64 = ctx.r[11].s64 + -17304;
	// 821C5E94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C5E98: C3C9D81C  lfs f30, -0x27e4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821C5E9C: 419A000C  beq cr6, 0x821c5ea8
	if ctx.cr[6].eq {
	pc = 0x821C5EA8; continue 'dispatch;
	}
	// 821C5EA0: D3DC0034  stfs f30, 0x34(r28)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821C5EA4: 9B5C003C  stb r26, 0x3c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[26].u8 ) };
	// 821C5EA8: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C5EAC: C3E9D828  lfs f31, -0x27d8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10200 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C5EB0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821C5EB4: 40980030  bge cr6, 0x821c5ee4
	if !ctx.cr[6].lt {
	pc = 0x821C5EE4; continue 'dispatch;
	}
	// 821C5EB8: 897C0031  lbz r11, 0x31(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(49 as u32) ) } as u64;
	// 821C5EBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5EC0: 419A0014  beq cr6, 0x821c5ed4
	if ctx.cr[6].eq {
	pc = 0x821C5ED4; continue 'dispatch;
	}
	// 821C5EC4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C5EC8: C1ABC4A8  lfs f13, -0x3b58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C5ECC: EC0D077A  fmadds f0, f13, f29, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 821C5ED0: 48000010  b 0x821c5ee0
	pc = 0x821C5EE0; continue 'dispatch;
	// 821C5ED4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C5ED8: C1ABC4A4  lfs f13, -0x3b5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C5EDC: EC0D077C  fnmsubs f0, f13, f29, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 821C5EE0: D01C0034  stfs f0, 0x34(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821C5EE4: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C5EE8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821C5EEC: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821C5EF0: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821C5EF4: 5548DF7A  rlwinm r8, r10, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C5EF8: 5547F77A  rlwinm r7, r10, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821C5EFC: 38CB0E68  addi r6, r11, 0xe68
	ctx.r[6].s64 = ctx.r[11].s64 + 3688;
	// 821C5F00: 7D053B78  or r5, r8, r7
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821C5F04: 7DA62C2E  lfsx f13, r6, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C5F08: FD6DF02E  fsel f11, f13, f0, f30
	ctx.f[11].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[30].f64 };
	// 821C5F0C: ED4BF828  fsubs f10, f11, f31
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[31].f64) as f32) as f64);
	// 821C5F10: FF0AF000  fcmpu cr6, f10, f30
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[30].f64);
	// 821C5F14: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821C5F18: 5483DF7A  rlwinm r3, r4, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821C5F1C: 548BF77A  rlwinm r11, r4, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 821C5F20: 7C6A5B78  or r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 821C5F24: 7D26542E  lfsx f9, r6, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821C5F28: FD095FEE  fsel f8, f9, f31, f11
	ctx.f[8].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[11].f64 };
	// 821C5F2C: D11C0034  stfs f8, 0x34(r28)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821C5F30: FC004090  fmr f0, f8
	ctx.f[0].f64 = ctx.f[8].f64;
	// 821C5F34: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821C5F38: 419A052C  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C5F3C: 817D6B08  lwz r11, 0x6b08(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821C5F40: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C5F44: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C5F48: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C5F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5F50: 419A0018  beq cr6, 0x821c5f68
	if ctx.cr[6].eq {
	pc = 0x821C5F68; continue 'dispatch;
	}
	// 821C5F54: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C5F58: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C5F5C: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821C5F60: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821C5F64: 41990008  bgt cr6, 0x821c5f6c
	if ctx.cr[6].gt {
	pc = 0x821C5F6C; continue 'dispatch;
	}
	// 821C5F68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 821C5F6C: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C5F70: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C5F74: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821C5F78: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5F7C: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821C5F80: 808A7D1C  lwz r4, 0x7d1c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32028 as u32) ) } as u64;
	// 821C5F84: C0490A54  lfs f2, 0xa54(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2644 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821C5F88: 48238349  bl 0x823fe2d0
	ctx.lr = 0x821C5F8C;
	sub_823FE2D0(ctx, base);
	// 821C5F8C: C01C0034  lfs f0, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C5F90: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821C5F94: 4198006C  blt cr6, 0x821c6000
	if ctx.cr[6].lt {
	pc = 0x821C6000; continue 'dispatch;
	}
	// 821C5F98: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C5F9C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821C5FA0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821C5FA4: 807C0040  lwz r3, 0x40(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C5FA8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C6478 size=652
    let mut pc: u32 = 0x821C6478;
    'dispatch: loop {
        match pc {
            0x821C6478 => {
    //   block [0x821C6478..0x821C6704)
	// 821C6478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C647C: 48AE2F85  bl 0x82ca9400
	ctx.lr = 0x821C6480;
	sub_82CA93D0(ctx, base);
	// 821C6480: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C6488: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821C648C: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6490: 40820014  bne 0x821c64a4
	if !ctx.cr[0].eq {
	pc = 0x821C64A4; continue 'dispatch;
	}
	// 821C6494: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6498: 917F31B0  stw r11, 0x31b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12720 as u32), ctx.r[11].u32 ) };
	// 821C649C: 480DFA4D  bl 0x822a5ee8
	ctx.lr = 0x821C64A0;
	sub_822A5EE8(ctx, base);
	// 821C64A0: 48000008  b 0x821c64a8
	pc = 0x821C64A8; continue 'dispatch;
	// 821C64A4: 48022A1D  bl 0x821e8ec0
	ctx.lr = 0x821C64A8;
	sub_821E8EC0(ctx, base);
	// 821C64A8: 817F3440  lwz r11, 0x3440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13376 as u32) ) } as u64;
	// 821C64AC: 387F3438  addi r3, r31, 0x3438
	ctx.r[3].s64 = ctx.r[31].s64 + 13368;
	// 821C64B0: 815F3444  lwz r10, 0x3444(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13380 as u32) ) } as u64;
	// 821C64B4: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821C64B8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C64BC: 4099000C  ble cr6, 0x821c64c8
	if !ctx.cr[6].gt {
	pc = 0x821C64C8; continue 'dispatch;
	}
	// 821C64C0: 4800B0F1  bl 0x821d15b0
	ctx.lr = 0x821C64C4;
	sub_821D15B0(ctx, base);
	// 821C64C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821C64C8: 3D408300  lis r10, -0x7d00
	ctx.r[10].s64 = -2097152000;
	// 821C64CC: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821C64D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821C64D4: 817F2934  lwz r11, 0x2934(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10548 as u32) ) } as u64;
	// 821C64D8: 895F2ABF  lbz r10, 0x2abf(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10943 as u32) ) } as u64;
	// 821C64DC: 891F2ABC  lbz r8, 0x2abc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821C64E0: 61080040  ori r8, r8, 0x40
	ctx.r[8].u64 = ctx.r[8].u64 | 64;
	// 821C64E4: 556BE77E  rlwinm r11, r11, 0x1c, 0x1d, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821C64E8: 913F3440  stw r9, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[9].u32 ) };
	// 821C64EC: 554A06B5  rlwinm. r10, r10, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821C64F0: 991F2ABC  stb r8, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[8].u8 ) };
	// 821C64F4: 917F31A0  stw r11, 0x31a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12704 as u32), ctx.r[11].u32 ) };
	// 821C64F8: 4182003C  beq 0x821c6534
	if ctx.cr[0].eq {
	pc = 0x821C6534; continue 'dispatch;
	}
	// 821C64FC: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821C6500: E97F0028  ld r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 821C6504: 815F2880  lwz r10, 0x2880(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10368 as u32) ) } as u64;
	// 821C6508: 798C2FE6  rldicr r12, r12, 0x25, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(37) & 0xFFFFFFFFFFFFFFFF;
	// 821C650C: 813F3378  lwz r9, 0x3378(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13176 as u32) ) } as u64;
	// 821C6510: 554A04BE  clrlwi r10, r10, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 821C6514: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821C6518: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C651C: F97F0028  std r11, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	// 821C6520: 419A0014  beq cr6, 0x821c6534
	if ctx.cr[6].eq {
	pc = 0x821C6534; continue 'dispatch;
	}
	// 821C6524: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821C6528: 798CCFE6  rldicr r12, r12, 0x39, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(57) & 0xFFFFFFFFFFFFFFFF;
	// 821C652C: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821C6530: F97F0028  std r11, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	// 821C6534: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821C6538: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821C653C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C6540: 616B0040  ori r11, r11, 0x40
	ctx.r[11].u64 = ctx.r[11].u64 | 64;
	// 821C6544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6548: 997F2ABD  stb r11, 0x2abd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10941 as u32), ctx.r[11].u8 ) };
	// 821C654C: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821C6550: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 821C6554: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821C6558: 915F319C  stw r10, 0x319c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12700 as u32), ctx.r[10].u32 ) };
	// 821C655C: 480DFFFD  bl 0x822a6558
	ctx.lr = 0x821C6560;
	sub_822A6558(ctx, base);
	// 821C6560: 817F3384  lwz r11, 0x3384(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13188 as u32) ) } as u64;
	// 821C6564: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6568: 40820194  bne 0x821c66fc
	if !ctx.cr[0].eq {
	pc = 0x821C66FC; continue 'dispatch;
	}
	// 821C656C: 897F2ABF  lbz r11, 0x2abf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10943 as u32) ) } as u64;
	// 821C6570: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6574: 41820188  beq 0x821c66fc
	if ctx.cr[0].eq {
	pc = 0x821C66FC; continue 'dispatch;
	}
	// 821C6578: 817F31CC  lwz r11, 0x31cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12748 as u32) ) } as u64;
	// 821C657C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821C6580: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 821C6584: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 821C6588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C658C: 40990050  ble cr6, 0x821c65dc
	if !ctx.cr[6].gt {
	pc = 0x821C65DC; continue 'dispatch;
	}
	// 821C6590: 5567003E  slwi r7, r11, 0
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C6594: 395F31DC  addi r10, r31, 0x31dc
	ctx.r[10].s64 = ctx.r[31].s64 + 12764;
	// 821C6598: 397F32C4  addi r11, r31, 0x32c4
	ctx.r[11].s64 = ctx.r[31].s64 + 12996;
	// 821C659C: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821C65A0: 812AFFFC  lwz r9, -4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821C65A4: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C65A8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C65AC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821C65B0: 7D053050  subf r8, r5, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 821C65B4: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C65B8: 41990008  bgt cr6, 0x821c65c0
	if ctx.cr[6].gt {
	pc = 0x821C65C0; continue 'dispatch;
	}
	// 821C65BC: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 821C65C0: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C65C4: 41990008  bgt cr6, 0x821c65cc
	if ctx.cr[6].gt {
	pc = 0x821C65CC; continue 'dispatch;
	}
	// 821C65C8: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 821C65CC: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821C65D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C65D4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821C65D8: 4082FFC4  bne 0x821c659c
	if !ctx.cr[0].eq {
	pc = 0x821C659C; continue 'dispatch;
	}
	// 821C65DC: 389F3168  addi r4, r31, 0x3168
	ctx.r[4].s64 = ctx.r[31].s64 + 12648;
	// 821C65E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821C65E4: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 821C65E8: 48AE2E99  bl 0x82ca9480
	ctx.lr = 0x821C65EC;
	sub_82CA9480(ctx, base);
	// 821C65EC: 817F3184  lwz r11, 0x3184(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12676 as u32) ) } as u64;
	// 821C65F0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821C65F4: 813F3188  lwz r9, 0x3188(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12680 as u32) ) } as u64;
	// 821C65F8: 811F318C  lwz r8, 0x318c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12684 as u32) ) } as u64;
	// 821C65FC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 821C6600: 80DF3190  lwz r6, 0x3190(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12688 as u32) ) } as u64;
	// 821C6604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6608: 38871AA8  addi r4, r7, 0x1aa8
	ctx.r[4].s64 = ctx.r[7].s64 + 6824;
	// 821C660C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821C6610: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6614: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821C6618: 90CA000C  stw r6, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 821C661C: 4803393D  bl 0x821f9f58
	ctx.lr = 0x821C6620;
	sub_821F9F58(ctx, base);
	// 821C6620: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821C6624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6628: 388B1590  addi r4, r11, 0x1590
	ctx.r[4].s64 = ctx.r[11].s64 + 5520;
	// 821C662C: 480335DD  bl 0x821f9c08
	ctx.lr = 0x821C6630;
	sub_821F9C08(ctx, base);
	// 821C6630: 817F337C  lwz r11, 0x337c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13180 as u32) ) } as u64;
	// 821C6634: 815F3380  lwz r10, 0x3380(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13184 as u32) ) } as u64;
	// 821C6638: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C663C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6640: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821C6644: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 821C6648: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821C664C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C6650: 4809EFA1  bl 0x822655f0
	ctx.lr = 0x821C6654;
	sub_822655F0(ctx, base);
	// 821C6654: 3BDF3390  addi r30, r31, 0x3390
	ctx.r[30].s64 = ctx.r[31].s64 + 13200;
	// 821C6658: 811F33A4  lwz r8, 0x33a4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13220 as u32) ) } as u64;
	// 821C665C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C6660: C03F33A0  lfs f1, 0x33a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C6664: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821C6668: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 821C666C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6670: 4801C971  bl 0x821e2fe0
	ctx.lr = 0x821C6674;
	sub_821E2FE0(ctx, base);
	// 821C6674: 897F2ABF  lbz r11, 0x2abf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10943 as u32) ) } as u64;
	// 821C6678: 3BA0000F  li r29, 0xf
	ctx.r[29].s64 = 15;
	// 821C667C: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6680: 40820008  bne 0x821c6688
	if !ctx.cr[0].eq {
	pc = 0x821C6688; continue 'dispatch;
	}
	// 821C6684: 3BA0003F  li r29, 0x3f
	ctx.r[29].s64 = 63;
	// 821C6688: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821C668C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821C6690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6694: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 821C6698: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821C669C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 821C66A0: 4809EF51  bl 0x822655f0
	ctx.lr = 0x821C66A4;
	sub_822655F0(ctx, base);
	// 821C66A4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821C66A8: 811F33A4  lwz r8, 0x33a4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13220 as u32) ) } as u64;
	// 821C66AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C66B0: C03F33A0  lfs f1, 0x33a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C66B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821C66B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C66BC: 4801C925  bl 0x821e2fe0
	ctx.lr = 0x821C66C0;
	sub_821E2FE0(ctx, base);
	// 821C66C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C66C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C66C8: 4809EF29  bl 0x822655f0
	ctx.lr = 0x821C66CC;
	sub_822655F0(ctx, base);
	// 821C66CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C66D0: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821C66D4: C0C10084  lfs f6, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821C66D8: C0A10080  lfs f5, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821C66DC: C081007C  lfs f4, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821C66E0: C0610078  lfs f3, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821C66E4: C0410074  lfs f2, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821C66E8: C0210070  lfs f1, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C66EC: 48033615  bl 0x821f9d00
	ctx.lr = 0x821C66F0;
	sub_821F9D00(ctx, base);
	// 821C66F0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821C66F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C66F8: 48033511  bl 0x821f9c08
	ctx.lr = 0x821C66FC;
	sub_821F9C08(ctx, base);
	// 821C66FC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821C6700: 48AE2D50  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6708 size=92
    let mut pc: u32 = 0x821C6708;
    'dispatch: loop {
        match pc {
            0x821C6708 => {
    //   block [0x821C6708..0x821C6764)
	// 821C6708: 548BD97E  srwi r11, r4, 5
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C670C: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6710: 548906FE  clrlwi r9, r4, 0x1b
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821C6714: 396B09E0  addi r11, r11, 0x9e0
	ctx.r[11].s64 = ctx.r[11].s64 + 2528;
	// 821C6718: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821C671C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C6720: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821C6724: 7D084830  slw r8, r8, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 821C6728: 7CEB182E  lwzx r7, r11, r3
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 821C672C: 7D4A4830  slw r10, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 821C6730: 7CE94078  andc r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 & !ctx.r[8].u64;
	// 821C6734: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821C6738: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821C673C: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821C6740: 7D4B192E  stwx r10, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 821C6744: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821C6748: 4082FFC0  bne 0x821c6708
	if !ctx.cr[0].eq {
	pc = 0x821C6708; continue 'dispatch;
	}
	// 821C674C: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821C6750: E9630020  ld r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	// 821C6754: 798CC7E6  rldicr r12, r12, 0x38, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(56) & 0xFFFFFFFFFFFFFFFF;
	// 821C6758: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821C675C: F9630020  std r11, 0x20(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 821C6760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C6768 size=140
    let mut pc: u32 = 0x821C6768;
    'dispatch: loop {
        match pc {
            0x821C6768 => {
    //   block [0x821C6768..0x821C67F4)
	// 821C6768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C676C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C6770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C6774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C6778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C677C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C6780: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C6788: 419A0054  beq cr6, 0x821c67dc
	if ctx.cr[6].eq {
	pc = 0x821C67DC; continue 'dispatch;
	}
	// 821C678C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821C6790: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C6794: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C6798: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C679C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821C67A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C67A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C67A8: 4082FFE8  bne 0x821c6790
	if !ctx.cr[0].eq {
	pc = 0x821C6790; continue 'dispatch;
	}
	// 821C67AC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821C67B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C67B4: 41990020  bgt cr6, 0x821c67d4
	if ctx.cr[6].gt {
	pc = 0x821C67D4; continue 'dispatch;
	}
	// 821C67B8: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C67BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C67C0: 419A0014  beq cr6, 0x821c67d4
	if ctx.cr[6].eq {
	pc = 0x821C67D4; continue 'dispatch;
	}
	// 821C67C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C67C8: 48979259  bl 0x82b3fa20
	ctx.lr = 0x821C67CC;
	sub_82B3FA20(ctx, base);
	// 821C67CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C67D0: 48055569  bl 0x8221bd38
	ctx.lr = 0x821C67D4;
	sub_8221BD38(ctx, base);
	// 821C67D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C67D8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821C67DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C67E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C67E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C67E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C67EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C67F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C67F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C67F8 size=88
    let mut pc: u32 = 0x821C67F8;
    'dispatch: loop {
        match pc {
            0x821C67F8 => {
    //   block [0x821C67F8..0x821C6850)
	// 821C67F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C67FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C6800: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C6804: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C680C: 4BFFFF5D  bl 0x821c6768
	ctx.lr = 0x821C6810;
	sub_821C6768(ctx, base);
	// 821C6810: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C6814: 390B708C  addi r8, r11, 0x708c
	ctx.r[8].s64 = ctx.r[11].s64 + 28812;
	// 821C6818: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C681C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C6820: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C6824: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821C6828: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C682C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C6830: 4082FFE8  bne 0x821c6818
	if !ctx.cr[0].eq {
	pc = 0x821C6818; continue 'dispatch;
	}
	// 821C6834: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821C6838: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821C683C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C6840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C6844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C6848: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C684C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6850 size=12
    let mut pc: u32 = 0x821C6850;
    'dispatch: loop {
        match pc {
            0x821C6850 => {
    //   block [0x821C6850..0x821C685C)
	// 821C6850: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821C6854: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C6858: 480C0558  b 0x82286db0
	sub_82286DB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


