pub fn sub_82EE8640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8640 size=56
    let mut pc: u32 = 0x82EE8640;
    'dispatch: loop {
        match pc {
            0x82EE8640 => {
    //   block [0x82EE8640..0x82EE8678)
	// 82EE8640: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8644: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82EE8648: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE864C: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE8650: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8654: 40820024  bne 0x82ee8678
	if !ctx.cr[0].eq {
		sub_82EE8678(ctx, base);
		return;
	}
	// 82EE8658: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE865C: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE8660: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8664: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE8668: 409A0010  bne cr6, 0x82ee8678
	if !ctx.cr[6].eq {
		sub_82EE8678(ctx, base);
		return;
	}
	// 82EE866C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8670: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8674: 4800000C  b 0x82ee8680
	sub_82EE8678(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8678 size=40
    let mut pc: u32 = 0x82EE8678;
    'dispatch: loop {
        match pc {
            0x82EE8678 => {
    //   block [0x82EE8678..0x82EE86A0)
	// 82EE8678: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE867C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8680: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8684: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE8688: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE868C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8690: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8694: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8698: F94B0108  std r10, 0x108(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), ctx.r[10].u64 ) };
	// 82EE869C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE86A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE86A0 size=16
    let mut pc: u32 = 0x82EE86A0;
    'dispatch: loop {
        match pc {
            0x82EE86A0 => {
    //   block [0x82EE86A0..0x82EE86B0)
	// 82EE86A0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE86A4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE86A8: E86B0110  ld r3, 0x110(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	// 82EE86AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE86B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE86B0 size=56
    let mut pc: u32 = 0x82EE86B0;
    'dispatch: loop {
        match pc {
            0x82EE86B0 => {
    //   block [0x82EE86B0..0x82EE86E8)
	// 82EE86B0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE86B4: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82EE86B8: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE86BC: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE86C0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE86C4: 40820024  bne 0x82ee86e8
	if !ctx.cr[0].eq {
		sub_82EE86E8(ctx, base);
		return;
	}
	// 82EE86C8: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE86CC: E96B0110  ld r11, 0x110(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	// 82EE86D0: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE86D4: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE86D8: 409A0010  bne cr6, 0x82ee86e8
	if !ctx.cr[6].eq {
		sub_82EE86E8(ctx, base);
		return;
	}
	// 82EE86DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE86E0: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE86E4: 4800000C  b 0x82ee86f0
	sub_82EE86E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE86E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE86E8 size=40
    let mut pc: u32 = 0x82EE86E8;
    'dispatch: loop {
        match pc {
            0x82EE86E8 => {
    //   block [0x82EE86E8..0x82EE8710)
	// 82EE86E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE86EC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE86F0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE86F4: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE86F8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE86FC: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8700: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8704: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8708: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE870C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8710 size=24
    let mut pc: u32 = 0x82EE8710;
    'dispatch: loop {
        match pc {
            0x82EE8710 => {
    //   block [0x82EE8710..0x82EE8728)
	// 82EE8710: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8714: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8718: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82EE871C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8720: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 82EE8724: 48000010  b 0x82ee8734
	sub_82EE8728(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8728 size=60
    let mut pc: u32 = 0x82EE8728;
    'dispatch: loop {
        match pc {
            0x82EE8728 => {
    //   block [0x82EE8728..0x82EE8764)
	// 82EE8728: 8161FFF8  lwz r11, -8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE872C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE8730: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 82EE8734: 8161FFF8  lwz r11, -8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE8738: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE873C: 40980028  bge cr6, 0x82ee8764
	if !ctx.cr[6].lt {
		sub_82EE8764(ctx, base);
		return;
	}
	// 82EE8740: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8744: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE8748: 8141FFF8  lwz r10, -8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE874C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE8750: E921FFF0  ld r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE8754: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE8758: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EE875C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82EE8760: 4BFFFFC8  b 0x82ee8728
	pc = 0x82EE8728; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8764(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8764 size=8
    let mut pc: u32 = 0x82EE8764;
    'dispatch: loop {
        match pc {
            0x82EE8764 => {
    //   block [0x82EE8764..0x82EE876C)
	// 82EE8764: E861FFF0  ld r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE8768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8770 size=44
    let mut pc: u32 = 0x82EE8770;
    'dispatch: loop {
        match pc {
            0x82EE8770 => {
    //   block [0x82EE8770..0x82EE879C)
	// 82EE8770: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8774: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE8778: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE877C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE8780: 40980020  bge cr6, 0x82ee87a0
	if !ctx.cr[6].lt {
		sub_82EE87A0(ctx, base);
		return;
	}
	// 82EE8784: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8788: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE878C: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8790: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE8794: 7C6B502A  ldx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE8798: 4800000C  b 0x82ee87a4
	sub_82EE87A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE879C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE879C size=4
    let mut pc: u32 = 0x82EE879C;
    'dispatch: loop {
        match pc {
            0x82EE879C => {
    //   block [0x82EE879C..0x82EE87A0)
	// 82EE879C: 48000008  b 0x82ee87a4
	sub_82EE87A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE87A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE87A0 size=8
    let mut pc: u32 = 0x82EE87A0;
    'dispatch: loop {
        match pc {
            0x82EE87A0 => {
    //   block [0x82EE87A0..0x82EE87A8)
	// 82EE87A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE87A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE87A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE87A8 size=88
    let mut pc: u32 = 0x82EE87A8;
    'dispatch: loop {
        match pc {
            0x82EE87A8 => {
    //   block [0x82EE87A8..0x82EE8800)
	// 82EE87A8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE87AC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE87B0: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82EE87B4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE87B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE87BC: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE87C0: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE87C4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE87C8: 40980034  bge cr6, 0x82ee87fc
	if !ctx.cr[6].lt {
	pc = 0x82EE87FC; continue 'dispatch;
	}
	// 82EE87CC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE87D0: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE87D4: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE87D8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE87DC: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE87E0: E9410020  ld r10, 0x20(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82EE87E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE87E8: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE87EC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE87F0: 81210014  lwz r9, 0x14(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE87F4: 39290118  addi r9, r9, 0x118
	ctx.r[9].s64 = ctx.r[9].s64 + 280;
	// 82EE87F8: 7D69512A  stdx r11, r9, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u64) };
	// 82EE87FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8800 size=16
    let mut pc: u32 = 0x82EE8800;
    'dispatch: loop {
        match pc {
            0x82EE8800 => {
    //   block [0x82EE8800..0x82EE8810)
	// 82EE8800: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8804: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8808: E86B0130  ld r3, 0x130(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE880C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8810 size=56
    let mut pc: u32 = 0x82EE8810;
    'dispatch: loop {
        match pc {
            0x82EE8810 => {
    //   block [0x82EE8810..0x82EE8848)
	// 82EE8810: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8814: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82EE8818: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE881C: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE8820: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8824: 40820024  bne 0x82ee8848
	if !ctx.cr[0].eq {
		sub_82EE8848(ctx, base);
		return;
	}
	// 82EE8828: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE882C: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE8830: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8834: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE8838: 409A0010  bne cr6, 0x82ee8848
	if !ctx.cr[6].eq {
		sub_82EE8848(ctx, base);
		return;
	}
	// 82EE883C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8840: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8844: 4800000C  b 0x82ee8850
	sub_82EE8848(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8848 size=40
    let mut pc: u32 = 0x82EE8848;
    'dispatch: loop {
        match pc {
            0x82EE8848 => {
    //   block [0x82EE8848..0x82EE8870)
	// 82EE8848: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE884C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8850: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8854: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE8858: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE885C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8860: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8864: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8868: F94B0130  std r10, 0x130(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(304 as u32), ctx.r[10].u64 ) };
	// 82EE886C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8870 size=16
    let mut pc: u32 = 0x82EE8870;
    'dispatch: loop {
        match pc {
            0x82EE8870 => {
    //   block [0x82EE8870..0x82EE8880)
	// 82EE8870: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8874: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8878: 886B013C  lbz r3, 0x13c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EE887C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8880 size=56
    let mut pc: u32 = 0x82EE8880;
    'dispatch: loop {
        match pc {
            0x82EE8880 => {
    //   block [0x82EE8880..0x82EE88B8)
	// 82EE8880: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8884: 9881001F  stb r4, 0x1f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(31 as u32), ctx.r[4].u8 ) };
	// 82EE8888: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE888C: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE8890: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8894: 40820024  bne 0x82ee88b8
	if !ctx.cr[0].eq {
		sub_82EE88B8(ctx, base);
		return;
	}
	// 82EE8898: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE889C: 896B013C  lbz r11, 0x13c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EE88A0: 8941001F  lbz r10, 0x1f(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(31 as u32) ) } as u64;
	// 82EE88A4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EE88A8: 409A0010  bne cr6, 0x82ee88b8
	if !ctx.cr[6].eq {
		sub_82EE88B8(ctx, base);
		return;
	}
	// 82EE88AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE88B0: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE88B4: 4800000C  b 0x82ee88c0
	sub_82EE88B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE88B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE88B8 size=40
    let mut pc: u32 = 0x82EE88B8;
    'dispatch: loop {
        match pc {
            0x82EE88B8 => {
    //   block [0x82EE88B8..0x82EE88E0)
	// 82EE88B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE88BC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE88C0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE88C4: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE88C8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE88CC: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE88D0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE88D4: 8941001F  lbz r10, 0x1f(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(31 as u32) ) } as u64;
	// 82EE88D8: 994B013C  stb r10, 0x13c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(316 as u32), ctx.r[10].u8 ) };
	// 82EE88DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE88E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE88E0 size=16
    let mut pc: u32 = 0x82EE88E0;
    'dispatch: loop {
        match pc {
            0x82EE88E0 => {
    //   block [0x82EE88E0..0x82EE88F0)
	// 82EE88E0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE88E4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE88E8: E86B0358  ld r3, 0x358(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE88EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE88F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE88F0 size=88
    let mut pc: u32 = 0x82EE88F0;
    'dispatch: loop {
        match pc {
            0x82EE88F0 => {
    //   block [0x82EE88F0..0x82EE8948)
	// 82EE88F0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE88F4: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE88F8: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE88FC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EE8900: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE8904: 7D4B5836  sld r11, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = (ctx.r[10].u64) << ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82EE8908: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82EE890C: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8910: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8914: 41980048  blt cr6, 0x82ee895c
	if ctx.cr[6].lt {
		sub_82EE895C(ctx, base);
		return;
	}
	// 82EE8918: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE891C: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 82EE8920: 4199003C  bgt cr6, 0x82ee895c
	if ctx.cr[6].gt {
		sub_82EE895C(ctx, base);
		return;
	}
	// 82EE8924: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8928: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE892C: E941FFF0  ld r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE8930: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82EE8934: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82EE8938: 419A0010  beq cr6, 0x82ee8948
	if ctx.cr[6].eq {
		sub_82EE8948(ctx, base);
		return;
	}
	// 82EE893C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE8940: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 82EE8944: 4800000C  b 0x82ee8950
	sub_82EE8948(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8948 size=20
    let mut pc: u32 = 0x82EE8948;
    'dispatch: loop {
        match pc {
            0x82EE8948 => {
    //   block [0x82EE8948..0x82EE895C)
	// 82EE8948: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE894C: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 82EE8950: 8161FFF8  lwz r11, -8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE8954: 9161FFFC  stw r11, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 82EE8958: 4800000C  b 0x82ee8964
	sub_82EE895C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE895C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE895C size=20
    let mut pc: u32 = 0x82EE895C;
    'dispatch: loop {
        match pc {
            0x82EE895C => {
    //   block [0x82EE895C..0x82EE8970)
	// 82EE895C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8960: 9161FFFC  stw r11, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 82EE8964: 8161FFFC  lwz r11, -4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EE8968: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE896C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8970 size=92
    let mut pc: u32 = 0x82EE8970;
    'dispatch: loop {
        match pc {
            0x82EE8970 => {
    //   block [0x82EE8970..0x82EE89CC)
	// 82EE8970: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8974: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE8978: 98A10027  stb r5, 0x27(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(39 as u32), ctx.r[5].u8 ) };
	// 82EE897C: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8980: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8984: 419800B4  blt cr6, 0x82ee8a38
	if ctx.cr[6].lt {
		sub_82EE8A14(ctx, base);
		return;
	}
	// 82EE8988: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE898C: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82EE8990: 409800A8  bge cr6, 0x82ee8a38
	if !ctx.cr[6].lt {
		sub_82EE8A14(ctx, base);
		return;
	}
	// 82EE8994: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8998: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EE899C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE89A0: 7D4B5836  sld r11, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = (ctx.r[10].u64) << ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82EE89A4: F961FFE8  std r11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[11].u64 ) };
	// 82EE89A8: 89610027  lbz r11, 0x27(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(39 as u32) ) } as u64;
	// 82EE89AC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE89B0: 4182001C  beq 0x82ee89cc
	if ctx.cr[0].eq {
		sub_82EE89CC(ctx, base);
		return;
	}
	// 82EE89B4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE89B8: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE89BC: E941FFE8  ld r10, -0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE89C0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EE89C4: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82EE89C8: 4800001C  b 0x82ee89e4
	sub_82EE89CC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE89CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE89CC size=72
    let mut pc: u32 = 0x82EE89CC;
    'dispatch: loop {
        match pc {
            0x82EE89CC => {
    //   block [0x82EE89CC..0x82EE8A14)
	// 82EE89CC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE89D0: E941FFE8  ld r10, -0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE89D4: 7D4A50F8  nor r10, r10, r10
	ctx.r[10].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 82EE89D8: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE89DC: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82EE89E0: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82EE89E4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE89E8: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE89EC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE89F0: 40820024  bne 0x82ee8a14
	if !ctx.cr[0].eq {
		sub_82EE8A14(ctx, base);
		return;
	}
	// 82EE89F4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE89F8: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE89FC: E941FFE0  ld r10, -0x20(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EE8A00: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82EE8A04: 409A0010  bne cr6, 0x82ee8a14
	if !ctx.cr[6].eq {
		sub_82EE8A14(ctx, base);
		return;
	}
	// 82EE8A08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8A0C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8A10: 4800000C  b 0x82ee8a1c
	sub_82EE8A14(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8A14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8A14 size=40
    let mut pc: u32 = 0x82EE8A14;
    'dispatch: loop {
        match pc {
            0x82EE8A14 => {
    //   block [0x82EE8A14..0x82EE8A3C)
	// 82EE8A14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE8A18: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8A1C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8A20: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE8A24: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE8A28: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8A2C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8A30: E941FFE0  ld r10, -0x20(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EE8A34: F94B0358  std r10, 0x358(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(856 as u32), ctx.r[10].u64 ) };
	// 82EE8A38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8A40 size=28
    let mut pc: u32 = 0x82EE8A40;
    'dispatch: loop {
        match pc {
            0x82EE8A40 => {
    //   block [0x82EE8A40..0x82EE8A5C)
	// 82EE8A40: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8A44: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE8A48: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8A4C: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE8A50: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8A54: 7C6B50AE  lbzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE8A58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8A60 size=40
    let mut pc: u32 = 0x82EE8A60;
    'dispatch: loop {
        match pc {
            0x82EE8A60 => {
    //   block [0x82EE8A60..0x82EE8A88)
	// 82EE8A60: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8A64: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE8A68: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EE8A6C: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8A70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8A74: 41980010  blt cr6, 0x82ee8a84
	if ctx.cr[6].lt {
	pc = 0x82EE8A84; continue 'dispatch;
	}
	// 82EE8A78: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8A7C: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 82EE8A80: 41980008  blt cr6, 0x82ee8a88
	if ctx.cr[6].lt {
		sub_82EE8A88(ctx, base);
		return;
	}
	// 82EE8A84: 480000A4  b 0x82ee8b28
	sub_82EE8AF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8A88 size=32
    let mut pc: u32 = 0x82EE8A88;
    'dispatch: loop {
        match pc {
            0x82EE8A88 => {
    //   block [0x82EE8A88..0x82EE8AA8)
	// 82EE8A88: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8A8C: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE8A90: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8A94: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE8A98: 81410024  lwz r10, 0x24(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE8A9C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EE8AA0: 41980008  blt cr6, 0x82ee8aa8
	if ctx.cr[6].lt {
		sub_82EE8AA8(ctx, base);
		return;
	}
	// 82EE8AA4: 48000084  b 0x82ee8b28
	sub_82EE8AF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8AA8 size=16
    let mut pc: u32 = 0x82EE8AA8;
    'dispatch: loop {
        match pc {
            0x82EE8AA8 => {
    //   block [0x82EE8AA8..0x82EE8AB8)
	// 82EE8AA8: 81610024  lwz r11, 0x24(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE8AAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8AB0: 409A0008  bne cr6, 0x82ee8ab8
	if !ctx.cr[6].eq {
		sub_82EE8AB8(ctx, base);
		return;
	}
	// 82EE8AB4: 48000074  b 0x82ee8b28
	sub_82EE8AF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8AB8 size=64
    let mut pc: u32 = 0x82EE8AB8;
    'dispatch: loop {
        match pc {
            0x82EE8AB8 => {
    //   block [0x82EE8AB8..0x82EE8AF8)
	// 82EE8AB8: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8ABC: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE8AC0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8AC4: 40820034  bne 0x82ee8af8
	if !ctx.cr[0].eq {
		sub_82EE8AF8(ctx, base);
		return;
	}
	// 82EE8AC8: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8ACC: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE8AD0: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8AD4: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE8AD8: 81410024  lwz r10, 0x24(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE8ADC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE8AE0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE8AE4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EE8AE8: 409A0010  bne cr6, 0x82ee8af8
	if !ctx.cr[6].eq {
		sub_82EE8AF8(ctx, base);
		return;
	}
	// 82EE8AEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8AF0: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8AF4: 4800000C  b 0x82ee8b00
	sub_82EE8AF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8AF8 size=52
    let mut pc: u32 = 0x82EE8AF8;
    'dispatch: loop {
        match pc {
            0x82EE8AF8 => {
    //   block [0x82EE8AF8..0x82EE8B2C)
	// 82EE8AF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE8AFC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8B00: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8B04: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE8B08: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE8B0C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8B10: 81610024  lwz r11, 0x24(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE8B14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8B18: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8B1C: 394A0348  addi r10, r10, 0x348
	ctx.r[10].s64 = ctx.r[10].s64 + 840;
	// 82EE8B20: 8121001C  lwz r9, 0x1c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8B24: 7D6A49AE  stbx r11, r10, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	// 82EE8B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE8B30 size=1340
    let mut pc: u32 = 0x82EE8B30;
    'dispatch: loop {
        match pc {
            0x82EE8B30 => {
    //   block [0x82EE8B30..0x82EE906C)
	// 82EE8B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE8B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE8B38: 9421FA40  stwu r1, -0x5c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1472 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE8B3C: 906105D4  stw r3, 0x5d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1492 as u32), ctx.r[3].u32 ) };
	// 82EE8B40: 908105DC  stw r4, 0x5dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1500 as u32), ctx.r[4].u32 ) };
	// 82EE8B44: 90A105E4  stw r5, 0x5e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1508 as u32), ctx.r[5].u32 ) };
	// 82EE8B48: 80C105DC  lwz r6, 0x5dc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1500 as u32) ) } as u64;
	// 82EE8B4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8B50: 38ABBF80  addi r5, r11, -0x4080
	ctx.r[5].s64 = ctx.r[11].s64 + -16512;
	// 82EE8B54: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE8B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE8B5C: 4800268D  bl 0x82eeb1e8
	ctx.lr = 0x82EE8B60;
	sub_82EEB1E8(ctx, base);
	// 82EE8B60: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8B64: 48208DC5  bl 0x830f1928
	ctx.lr = 0x82EE8B68;
	sub_830F1928(ctx, base);
	// 82EE8B68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EE8B6C: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8B70: 48208E91  bl 0x830f1a00
	ctx.lr = 0x82EE8B74;
	sub_830F1A00(ctx, base);
	// 82EE8B74: 90610264  stw r3, 0x264(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(612 as u32), ctx.r[3].u32 ) };
	// 82EE8B78: 81610264  lwz r11, 0x264(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EE8B7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8B80: 4098001C  bge cr6, 0x82ee8b9c
	if !ctx.cr[6].lt {
	pc = 0x82EE8B9C; continue 'dispatch;
	}
	// 82EE8B84: 81610264  lwz r11, 0x264(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EE8B88: 91610594  stw r11, 0x594(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1428 as u32), ctx.r[11].u32 ) };
	// 82EE8B8C: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8B90: 48208E21  bl 0x830f19b0
	ctx.lr = 0x82EE8B94;
	sub_830F19B0(ctx, base);
	// 82EE8B94: 80610594  lwz r3, 0x594(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1428 as u32) ) } as u64;
	// 82EE8B98: 480004C4  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
	// 82EE8B9C: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8BA0: 482088B9  bl 0x830f1458
	ctx.lr = 0x82EE8BA4;
	sub_830F1458(ctx, base);
	// 82EE8BA4: 90610258  stw r3, 0x258(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(600 as u32), ctx.r[3].u32 ) };
	// 82EE8BA8: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8BB0: 409A0020  bne cr6, 0x82ee8bd0
	if !ctx.cr[6].eq {
	pc = 0x82EE8BD0; continue 'dispatch;
	}
	// 82EE8BB4: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8BB8: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8BBC: 91610598  stw r11, 0x598(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1432 as u32), ctx.r[11].u32 ) };
	// 82EE8BC0: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8BC4: 48208DED  bl 0x830f19b0
	ctx.lr = 0x82EE8BC8;
	sub_830F19B0(ctx, base);
	// 82EE8BC8: 80610598  lwz r3, 0x598(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1432 as u32) ) } as u64;
	// 82EE8BCC: 48000490  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
	// 82EE8BD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE8BD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8BD8: 388BBF74  addi r4, r11, -0x408c
	ctx.r[4].s64 = ctx.r[11].s64 + -16524;
	// 82EE8BDC: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8BE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE8BE4: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8BE8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE8BEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE8BF0: 4E800421  bctrl
	ctx.lr = 0x82EE8BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE8BF4: 9061025C  stw r3, 0x25c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(604 as u32), ctx.r[3].u32 ) };
	// 82EE8BF8: 8161025C  lwz r11, 0x25c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(604 as u32) ) } as u64;
	// 82EE8BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8C00: 409A0020  bne cr6, 0x82ee8c20
	if !ctx.cr[6].eq {
	pc = 0x82EE8C20; continue 'dispatch;
	}
	// 82EE8C04: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8C08: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8C0C: 9161059C  stw r11, 0x59c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1436 as u32), ctx.r[11].u32 ) };
	// 82EE8C10: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8C14: 48208D9D  bl 0x830f19b0
	ctx.lr = 0x82EE8C18;
	sub_830F19B0(ctx, base);
	// 82EE8C18: 8061059C  lwz r3, 0x59c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1436 as u32) ) } as u64;
	// 82EE8C1C: 48000440  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
	// 82EE8C20: 80A1025C  lwz r5, 0x25c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(604 as u32) ) } as u64;
	// 82EE8C24: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82EE8C28: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C2C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EE8C30: 482086E9  bl 0x830f1318
	ctx.lr = 0x82EE8C34;
	sub_830F1318(ctx, base);
	// 82EE8C34: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C38: A16B0008  lhz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE8C3C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8C40: 4082001C  bne 0x82ee8c5c
	if !ctx.cr[0].eq {
	pc = 0x82EE8C5C; continue 'dispatch;
	}
	// 82EE8C44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8C48: 38ABBF5C  addi r5, r11, -0x40a4
	ctx.r[5].s64 = ctx.r[11].s64 + -16548;
	// 82EE8C4C: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82EE8C50: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C54: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EE8C58: 482086C1  bl 0x830f1318
	ctx.lr = 0x82EE8C5C;
	sub_830F1318(ctx, base);
	// 82EE8C5C: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C60: 38AB0108  addi r5, r11, 0x108
	ctx.r[5].s64 = ctx.r[11].s64 + 264;
	// 82EE8C64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8C68: 388BBF44  addi r4, r11, -0x40bc
	ctx.r[4].s64 = ctx.r[11].s64 + -16572;
	// 82EE8C6C: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8C70: 48001921  bl 0x82eea590
	ctx.lr = 0x82EE8C74;
	sub_82EEA590(ctx, base);
	// 82EE8C74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8C78: 40820020  bne 0x82ee8c98
	if !ctx.cr[0].eq {
	pc = 0x82EE8C98; continue 'dispatch;
	}
	// 82EE8C7C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8C80: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8C84: 916105A0  stw r11, 0x5a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1440 as u32), ctx.r[11].u32 ) };
	// 82EE8C88: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8C8C: 48208D25  bl 0x830f19b0
	ctx.lr = 0x82EE8C90;
	sub_830F19B0(ctx, base);
	// 82EE8C90: 806105A0  lwz r3, 0x5a0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1440 as u32) ) } as u64;
	// 82EE8C94: 480003C8  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
	// 82EE8C98: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C9C: 38AB0130  addi r5, r11, 0x130
	ctx.r[5].s64 = ctx.r[11].s64 + 304;
	// 82EE8CA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8CA4: 388BBF38  addi r4, r11, -0x40c8
	ctx.r[4].s64 = ctx.r[11].s64 + -16584;
	// 82EE8CA8: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8CAC: 480018E5  bl 0x82eea590
	ctx.lr = 0x82EE8CB0;
	sub_82EEA590(ctx, base);
	// 82EE8CB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8CB4: 40820020  bne 0x82ee8cd4
	if !ctx.cr[0].eq {
	pc = 0x82EE8CD4; continue 'dispatch;
	}
	// 82EE8CB8: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8CBC: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8CC0: 916105A4  stw r11, 0x5a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1444 as u32), ctx.r[11].u32 ) };
	// 82EE8CC4: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8CC8: 48208CE9  bl 0x830f19b0
	ctx.lr = 0x82EE8CCC;
	sub_830F19B0(ctx, base);
	// 82EE8CCC: 806105A4  lwz r3, 0x5a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EE8CD0: 4800038C  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
	// 82EE8CD4: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8CD8: 38AB0358  addi r5, r11, 0x358
	ctx.r[5].s64 = ctx.r[11].s64 + 856;
	// 82EE8CDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8CE0: 388BBF10  addi r4, r11, -0x40f0
	ctx.r[4].s64 = ctx.r[11].s64 + -16624;
	// 82EE8CE4: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8CE8: 48001931  bl 0x82eea618
	ctx.lr = 0x82EE8CEC;
	sub_82EEA618(ctx, base);
	// 82EE8CEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8CF0: 40820020  bne 0x82ee8d10
	if !ctx.cr[0].eq {
	pc = 0x82EE8D10; continue 'dispatch;
	}
	// 82EE8CF4: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8CF8: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8CFC: 916105A8  stw r11, 0x5a8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1448 as u32), ctx.r[11].u32 ) };
	// 82EE8D00: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8D04: 48208CAD  bl 0x830f19b0
	ctx.lr = 0x82EE8D08;
	sub_830F19B0(ctx, base);
	// 82EE8D08: 806105A8  lwz r3, 0x5a8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1448 as u32) ) } as u64;
	// 82EE8D0C: 48000350  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
	// 82EE8D10: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8D14: 38AB0110  addi r5, r11, 0x110
	ctx.r[5].s64 = ctx.r[11].s64 + 272;
	// 82EE8D18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D1C: 388BBF00  addi r4, r11, -0x4100
	ctx.r[4].s64 = ctx.r[11].s64 + -16640;
	// 82EE8D20: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8D24: 4800186D  bl 0x82eea590
	ctx.lr = 0x82EE8D28;
	sub_82EEA590(ctx, base);
	// 82EE8D28: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8D2C: 38AB013C  addi r5, r11, 0x13c
	ctx.r[5].s64 = ctx.r[11].s64 + 316;
	// 82EE8D30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D34: 388BBEEC  addi r4, r11, -0x4114
	ctx.r[4].s64 = ctx.r[11].s64 + -16660;
	// 82EE8D38: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8D3C: 48001965  bl 0x82eea6a0
	ctx.lr = 0x82EE8D40;
	sub_82EEA6A0(ctx, base);
	// 82EE8D40: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8D44: 38AB0138  addi r5, r11, 0x138
	ctx.r[5].s64 = ctx.r[11].s64 + 312;
	// 82EE8D48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D4C: 388BBED4  addi r4, r11, -0x412c
	ctx.r[4].s64 = ctx.r[11].s64 + -16684;
	// 82EE8D50: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8D54: 480019D5  bl 0x82eea728
	ctx.lr = 0x82EE8D58;
	sub_82EEA728(ctx, base);
	// 82EE8D58: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8D5C: 38AB0140  addi r5, r11, 0x140
	ctx.r[5].s64 = ctx.r[11].s64 + 320;
	// 82EE8D60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D64: 388BBEC8  addi r4, r11, -0x4138
	ctx.r[4].s64 = ctx.r[11].s64 + -16696;
	// 82EE8D68: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8D6C: 48001825  bl 0x82eea590
	ctx.lr = 0x82EE8D70;
	sub_82EEA590(ctx, base);
	// 82EE8D70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8D74: 91610278  stw r11, 0x278(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 82EE8D78: 48000010  b 0x82ee8d88
	pc = 0x82EE8D88; continue 'dispatch;
	// 82EE8D7C: 81610278  lwz r11, 0x278(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EE8D80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE8D84: 91610278  stw r11, 0x278(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 82EE8D88: 81610278  lwz r11, 0x278(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EE8D8C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE8D90: 40980040  bge cr6, 0x82ee8dd0
	if !ctx.cr[6].lt {
	pc = 0x82EE8DD0; continue 'dispatch;
	}
	// 82EE8D94: 80C10278  lwz r6, 0x278(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EE8D98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D9C: 38ABBEA8  addi r5, r11, -0x4158
	ctx.r[5].s64 = ctx.r[11].s64 + -16728;
	// 82EE8DA0: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE8DA4: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 82EE8DA8: 48002441  bl 0x82eeb1e8
	ctx.lr = 0x82EE8DAC;
	sub_82EEB1E8(ctx, base);
	// 82EE8DAC: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8DB0: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE8DB4: 81410278  lwz r10, 0x278(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EE8DB8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE8DBC: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE8DC0: 38810280  addi r4, r1, 0x280
	ctx.r[4].s64 = ctx.r[1].s64 + 640;
	// 82EE8DC4: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8DC8: 480017C9  bl 0x82eea590
	ctx.lr = 0x82EE8DCC;
	sub_82EEA590(ctx, base);
	// 82EE8DCC: 4BFFFFB0  b 0x82ee8d7c
	pc = 0x82EE8D7C; continue 'dispatch;
	// 82EE8DD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE8DD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8DD8: 388BBE84  addi r4, r11, -0x417c
	ctx.r[4].s64 = ctx.r[11].s64 + -16764;
	// 82EE8DDC: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8DE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE8DE4: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8DE8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE8DEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE8DF0: 4E800421  bctrl
	ctx.lr = 0x82EE8DF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE8DF4: 90610260  stw r3, 0x260(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(608 as u32), ctx.r[3].u32 ) };
	// 82EE8DF8: 81610260  lwz r11, 0x260(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EE8DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8E00: 419A0018  beq cr6, 0x82ee8e18
	if ctx.cr[6].eq {
	pc = 0x82EE8E18; continue 'dispatch;
	}
	// 82EE8E04: 80A10260  lwz r5, 0x260(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EE8E08: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82EE8E0C: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8E10: 386B0148  addi r3, r11, 0x148
	ctx.r[3].s64 = ctx.r[11].s64 + 328;
	// 82EE8E14: 48208505  bl 0x830f1318
	ctx.lr = 0x82EE8E18;
	sub_830F1318(ctx, base);
	// 82EE8E18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE8E1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8E20: 388BBE5C  addi r4, r11, -0x41a4
	ctx.r[4].s64 = ctx.r[11].s64 + -16804;
	// 82EE8E24: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8E28: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE8E2C: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8E30: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE8E34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE8E38: 4E800421  bctrl
	ctx.lr = 0x82EE8E3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE8E3C: 9061026C  stw r3, 0x26c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(620 as u32), ctx.r[3].u32 ) };
	// 82EE8E40: 8161026C  lwz r11, 0x26c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EE8E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8E48: 419A0018  beq cr6, 0x82ee8e60
	if ctx.cr[6].eq {
	pc = 0x82EE8E60; continue 'dispatch;
	}
	// 82EE8E4C: 80A1026C  lwz r5, 0x26c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EE8E50: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82EE8E54: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8E58: 386B0248  addi r3, r11, 0x248
	ctx.r[3].s64 = ctx.r[11].s64 + 584;
	// 82EE8E5C: 482084BD  bl 0x830f1318
	ctx.lr = 0x82EE8E60;
	sub_830F1318(ctx, base);
	// 82EE8E60: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE8E64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8E68: 388BBE34  addi r4, r11, -0x41cc
	ctx.r[4].s64 = ctx.r[11].s64 + -16844;
	// 82EE8E6C: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8E70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE8E74: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8E78: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE8E7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE8E80: 4E800421  bctrl
	ctx.lr = 0x82EE8E84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE8E84: 90610268  stw r3, 0x268(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(616 as u32), ctx.r[3].u32 ) };
	// 82EE8E88: 81610268  lwz r11, 0x268(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8E90: 419A013C  beq cr6, 0x82ee8fcc
	if ctx.cr[6].eq {
	pc = 0x82EE8FCC; continue 'dispatch;
	}
	// 82EE8E94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8E98: 91610488  stw r11, 0x488(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1160 as u32), ctx.r[11].u32 ) };
	// 82EE8E9C: 48000010  b 0x82ee8eac
	pc = 0x82EE8EAC; continue 'dispatch;
	// 82EE8EA0: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE8EA8: 91610488  stw r11, 0x488(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1160 as u32), ctx.r[11].u32 ) };
	// 82EE8EAC: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EB0: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE8EB4: 40980118  bge cr6, 0x82ee8fcc
	if !ctx.cr[6].lt {
	pc = 0x82EE8FCC; continue 'dispatch;
	}
	// 82EE8EB8: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EBC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8EC0: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8EC4: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8EC8: 2F0B002E  cmpwi cr6, r11, 0x2e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 46, &mut ctx.xer);
	// 82EE8ECC: 409A001C  bne cr6, 0x82ee8ee8
	if !ctx.cr[6].eq {
	pc = 0x82EE8EE8; continue 'dispatch;
	}
	// 82EE8ED0: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8ED4: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE8ED8: 81410488  lwz r10, 0x488(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EDC: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 82EE8EE0: 7D2B51AE  stbx r9, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u8) };
	// 82EE8EE4: 480000E4  b 0x82ee8fc8
	pc = 0x82EE8FC8; continue 'dispatch;
	// 82EE8EE8: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EEC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8EF0: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8EF4: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8EF8: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 82EE8EFC: 41990030  bgt cr6, 0x82ee8f2c
	if ctx.cr[6].gt {
	pc = 0x82EE8F2C; continue 'dispatch;
	}
	// 82EE8F00: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F04: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F08: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8F0C: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8F10: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 82EE8F14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8F18: 814105D4  lwz r10, 0x5d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8F1C: 394A0348  addi r10, r10, 0x348
	ctx.r[10].s64 = ctx.r[10].s64 + 840;
	// 82EE8F20: 81210488  lwz r9, 0x488(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F24: 7D6A49AE  stbx r11, r10, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	// 82EE8F28: 480000A0  b 0x82ee8fc8
	pc = 0x82EE8FC8; continue 'dispatch;
	// 82EE8F2C: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F30: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F34: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8F38: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8F3C: 2F0B005A  cmpwi cr6, r11, 0x5a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 90, &mut ctx.xer);
	// 82EE8F40: 4199003C  bgt cr6, 0x82ee8f7c
	if ctx.cr[6].gt {
	pc = 0x82EE8F7C; continue 'dispatch;
	}
	// 82EE8F44: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F48: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F4C: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8F50: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8F54: 396BFFBF  addi r11, r11, -0x41
	ctx.r[11].s64 = ctx.r[11].s64 + -65;
	// 82EE8F58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8F5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8F60: 396B000A  addi r11, r11, 0xa
	ctx.r[11].s64 = ctx.r[11].s64 + 10;
	// 82EE8F64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8F68: 814105D4  lwz r10, 0x5d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8F6C: 394A0348  addi r10, r10, 0x348
	ctx.r[10].s64 = ctx.r[10].s64 + 840;
	// 82EE8F70: 81210488  lwz r9, 0x488(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F74: 7D6A49AE  stbx r11, r10, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	// 82EE8F78: 48000050  b 0x82ee8fc8
	pc = 0x82EE8FC8; continue 'dispatch;
	// 82EE8F7C: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F80: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F84: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8F88: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8F8C: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 82EE8F90: 41990038  bgt cr6, 0x82ee8fc8
	if ctx.cr[6].gt {
	pc = 0x82EE8FC8; continue 'dispatch;
	}
	// 82EE8F94: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F98: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F9C: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8FA0: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8FA4: 396BFF9F  addi r11, r11, -0x61
	ctx.r[11].s64 = ctx.r[11].s64 + -97;
	// 82EE8FA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8FAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8FB0: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82EE8FB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8FB8: 814105D4  lwz r10, 0x5d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8FBC: 394A0348  addi r10, r10, 0x348
	ctx.r[10].s64 = ctx.r[10].s64 + 840;
	// 82EE8FC0: 81210488  lwz r9, 0x488(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8FC4: 7D6A49AE  stbx r11, r10, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	// 82EE8FC8: 4BFFFED8  b 0x82ee8ea0
	pc = 0x82EE8EA0; continue 'dispatch;
	// 82EE8FCC: 816105E4  lwz r11, 0x5e4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1508 as u32) ) } as u64;
	// 82EE8FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8FD4: 419A005C  beq cr6, 0x82ee9030
	if ctx.cr[6].eq {
	pc = 0x82EE9030; continue 'dispatch;
	}
	// 82EE8FD8: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8FDC: 816B0360  lwz r11, 0x360(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE8FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8FE4: 419A001C  beq cr6, 0x82ee9000
	if ctx.cr[6].eq {
	pc = 0x82EE9000; continue 'dispatch;
	}
	// 82EE8FE8: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8FEC: 806B0360  lwz r3, 0x360(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE8FF0: 4BBA20E9  bl 0x82a8b0d8
	ctx.lr = 0x82EE8FF4;
	sub_82A8B0D8(ctx, base);
	// 82EE8FF4: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8FF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE8FFC: 914B0360  stw r10, 0x360(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(864 as u32), ctx.r[10].u32 ) };
	// 82EE9000: 80C105DC  lwz r6, 0x5dc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1500 as u32) ) } as u64;
	// 82EE9004: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9008: 38ABBE1C  addi r5, r11, -0x41e4
	ctx.r[5].s64 = ctx.r[11].s64 + -16868;
	// 82EE900C: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE9010: 38610490  addi r3, r1, 0x490
	ctx.r[3].s64 = ctx.r[1].s64 + 1168;
	// 82EE9014: 48002035  bl 0x82eeb048
	ctx.lr = 0x82EE9018;
	sub_82EEB048(ctx, base);
	// 82EE9018: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE901C: 38AB0360  addi r5, r11, 0x360
	ctx.r[5].s64 = ctx.r[11].s64 + 864;
	// 82EE9020: 38810490  addi r4, r1, 0x490
	ctx.r[4].s64 = ctx.r[1].s64 + 1168;
	// 82EE9024: 806105E4  lwz r3, 0x5e4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1508 as u32) ) } as u64;
	// 82EE9028: 4BE2EB21  bl 0x82d17b48
	ctx.lr = 0x82EE902C;
	sub_82D17B48(ctx, base);
	// 82EE902C: 9061048C  stw r3, 0x48c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1164 as u32), ctx.r[3].u32 ) };
	// 82EE9030: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE9034: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9038: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE903C: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE9040: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9044: 994B0365  stb r10, 0x365(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(869 as u32), ctx.r[10].u8 ) };
	// 82EE9048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE904C: 916105AC  stw r11, 0x5ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1452 as u32), ctx.r[11].u32 ) };
	// 82EE9050: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE9054: 4820895D  bl 0x830f19b0
	ctx.lr = 0x82EE9058;
	sub_830F19B0(ctx, base);
	// 82EE9058: 806105AC  lwz r3, 0x5ac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1452 as u32) ) } as u64;
	// 82EE905C: 382105C0  addi r1, r1, 0x5c0
	ctx.r[1].s64 = ctx.r[1].s64 + 1472;
	// 82EE9060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE9064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE9068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9070 size=536
    let mut pc: u32 = 0x82EE9070;
    'dispatch: loop {
        match pc {
            0x82EE9070 => {
    //   block [0x82EE9070..0x82EE9288)
	// 82EE9070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE9074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE9078: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE907C: 90610214  stw r3, 0x214(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(532 as u32), ctx.r[3].u32 ) };
	// 82EE9080: 9081021C  stw r4, 0x21c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(540 as u32), ctx.r[4].u32 ) };
	// 82EE9084: 90A10224  stw r5, 0x224(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(548 as u32), ctx.r[5].u32 ) };
	// 82EE9088: 90C1022C  stw r6, 0x22c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(556 as u32), ctx.r[6].u32 ) };
	// 82EE908C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EE9090: 396B8F48  addi r11, r11, -0x70b8
	ctx.r[11].s64 = ctx.r[11].s64 + -28856;
	// 82EE9094: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82EE9098: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EE909C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82EE90A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EE90A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82EE90A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EE90AC: 4082FFE8  bne 0x82ee9094
	if !ctx.cr[0].eq {
	pc = 0x82EE9094; continue 'dispatch;
	}
	// 82EE90B0: 7D4A5378  mr r10, r10
	ctx.r[10].u64 = ctx.r[10].u64;
	// 82EE90B4: 914101E8  stw r10, 0x1e8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), ctx.r[10].u32 ) };
	// 82EE90B8: 816101E8  lwz r11, 0x1e8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EE90BC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EE90C0: 80C10060  lwz r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE90C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE90C8: 38ABBFB4  addi r5, r11, -0x404c
	ctx.r[5].s64 = ctx.r[11].s64 + -16460;
	// 82EE90CC: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82EE90D0: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82EE90D4: 48001F75  bl 0x82eeb048
	ctx.lr = 0x82EE90D8;
	sub_82EEB048(ctx, base);
	// 82EE90D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EE90DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE90E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE90E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE90E8: 4BDD9BF9  bl 0x82cc2ce0
	ctx.lr = 0x82EE90EC;
	sub_82CC2CE0(ctx, base);
	// 82EE90EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EE90F0: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE90F4: 4800224D  bl 0x82eeb340
	ctx.lr = 0x82EE90F8;
	sub_82EEB340(ctx, base);
	// 82EE90F8: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE90FC: 480022D5  bl 0x82eeb3d0
	ctx.lr = 0x82EE9100;
	sub_82EEB3D0(ctx, base);
	// 82EE9100: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9104: 41820020  beq 0x82ee9124
	if ctx.cr[0].eq {
	pc = 0x82EE9124; continue 'dispatch;
	}
	// 82EE9108: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE910C: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EE9110: 916101D4  stw r11, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82EE9114: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE9118: 48002249  bl 0x82eeb360
	ctx.lr = 0x82EE911C;
	sub_82EEB360(ctx, base);
	// 82EE911C: 806101D4  lwz r3, 0x1d4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EE9120: 48000158  b 0x82ee9278
	pc = 0x82EE9278; continue 'dispatch;
	// 82EE9124: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9128: 91610180  stw r11, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82EE912C: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 82EE9130: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE9134: 38610184  addi r3, r1, 0x184
	ctx.r[3].s64 = ctx.r[1].s64 + 388;
	// 82EE9138: 4BDC0879  bl 0x82ca99b0
	ctx.lr = 0x82EE913C;
	sub_82CA99B0(ctx, base);
	// 82EE913C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE9140: 48004081  bl 0x82eed1c0
	ctx.lr = 0x82EE9144;
	sub_82EED1C0(ctx, base);
	// 82EE9144: 9061018C  stw r3, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[3].u32 ) };
	// 82EE9148: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE914C: 91610178  stw r11, 0x178(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82EE9150: 3961017C  addi r11, r1, 0x17c
	ctx.r[11].s64 = ctx.r[1].s64 + 380;
	// 82EE9154: 916101EC  stw r11, 0x1ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
	// 82EE9158: 816101EC  lwz r11, 0x1ec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EE915C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9160: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EE9164: 39610180  addi r11, r1, 0x180
	ctx.r[11].s64 = ctx.r[1].s64 + 384;
	// 82EE9168: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE916C: E9410178  ld r10, 0x178(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 82EE9170: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE9174: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EE9178: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EE917C: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82EE9180: 80A10224  lwz r5, 0x224(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EE9184: 388101B0  addi r4, r1, 0x1b0
	ctx.r[4].s64 = ctx.r[1].s64 + 432;
	// 82EE9188: 8061021C  lwz r3, 0x21c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE918C: 4BDDAFAD  bl 0x82cc4138
	ctx.lr = 0x82EE9190;
	sub_82CC4138(ctx, base);
	// 82EE9190: 906101D0  stw r3, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[3].u32 ) };
	// 82EE9194: 816101D0  lwz r11, 0x1d0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EE9198: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EE919C: 419A0020  beq cr6, 0x82ee91bc
	if ctx.cr[6].eq {
	pc = 0x82EE91BC; continue 'dispatch;
	}
	// 82EE91A0: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE91A4: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE91A8: 916101D8  stw r11, 0x1d8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 82EE91AC: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE91B0: 480021B1  bl 0x82eeb360
	ctx.lr = 0x82EE91B4;
	sub_82EEB360(ctx, base);
	// 82EE91B4: 806101D8  lwz r3, 0x1d8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EE91B8: 480000C0  b 0x82ee9278
	pc = 0x82EE9278; continue 'dispatch;
	// 82EE91BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE91C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE91C4: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EE91C8: 4BDD9BB9  bl 0x82cc2d80
	ctx.lr = 0x82EE91CC;
	sub_82CC2D80(ctx, base);
	// 82EE91CC: 906101D0  stw r3, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[3].u32 ) };
	// 82EE91D0: 816101D0  lwz r11, 0x1d0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EE91D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE91D8: 419A0020  beq cr6, 0x82ee91f8
	if ctx.cr[6].eq {
	pc = 0x82EE91F8; continue 'dispatch;
	}
	// 82EE91DC: 806101D0  lwz r3, 0x1d0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EE91E0: 4B418CA1  bl 0x82301e80
	ctx.lr = 0x82EE91E4;
	sub_82301E80(ctx, base);
	// 82EE91E4: 906101DC  stw r3, 0x1dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(476 as u32), ctx.r[3].u32 ) };
	// 82EE91E8: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE91EC: 48002175  bl 0x82eeb360
	ctx.lr = 0x82EE91F0;
	sub_82EEB360(ctx, base);
	// 82EE91F0: 806101DC  lwz r3, 0x1dc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(476 as u32) ) } as u64;
	// 82EE91F4: 48000084  b 0x82ee9278
	pc = 0x82EE9278; continue 'dispatch;
	// 82EE91F8: 38C101B0  addi r6, r1, 0x1b0
	ctx.r[6].s64 = ctx.r[1].s64 + 432;
	// 82EE91FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9200: 38ABBFAC  addi r5, r11, -0x4054
	ctx.r[5].s64 = ctx.r[11].s64 + -16468;
	// 82EE9204: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE9208: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE920C: 48001E3D  bl 0x82eeb048
	ctx.lr = 0x82EE9210;
	sub_82EEB048(ctx, base);
	// 82EE9210: 80A1022C  lwz r5, 0x22c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(556 as u32) ) } as u64;
	// 82EE9214: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE9218: 80610214  lwz r3, 0x214(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EE921C: 4BFFF915  bl 0x82ee8b30
	ctx.lr = 0x82EE9220;
	sub_82EE8B30(ctx, base);
	// 82EE9220: 9061019C  stw r3, 0x19c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), ctx.r[3].u32 ) };
	// 82EE9224: 8161019C  lwz r11, 0x19c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EE9228: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE922C: 4098001C  bge cr6, 0x82ee9248
	if !ctx.cr[6].lt {
	pc = 0x82EE9248; continue 'dispatch;
	}
	// 82EE9230: 8161019C  lwz r11, 0x19c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EE9234: 916101E0  stw r11, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EE9238: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE923C: 48002125  bl 0x82eeb360
	ctx.lr = 0x82EE9240;
	sub_82EEB360(ctx, base);
	// 82EE9240: 806101E0  lwz r3, 0x1e0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EE9244: 48000034  b 0x82ee9278
	pc = 0x82EE9278; continue 'dispatch;
	// 82EE9248: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EE924C: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82EE9250: 4BDDA7A1  bl 0x82cc39f0
	ctx.lr = 0x82EE9254;
	sub_82CC39F0(ctx, base);
	// 82EE9254: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE9258: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE925C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EE9260: 4BDD9B21  bl 0x82cc2d80
	ctx.lr = 0x82EE9264;
	sub_82CC2D80(ctx, base);
	// 82EE9264: 8161019C  lwz r11, 0x19c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EE9268: 916101E4  stw r11, 0x1e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82EE926C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE9270: 480020F1  bl 0x82eeb360
	ctx.lr = 0x82EE9274;
	sub_82EEB360(ctx, base);
	// 82EE9274: 806101E4  lwz r3, 0x1e4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(484 as u32) ) } as u64;
	// 82EE9278: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82EE927C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE9280: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE9284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9288 size=1980
    let mut pc: u32 = 0x82EE9288;
    'dispatch: loop {
        match pc {
            0x82EE9288 => {
    //   block [0x82EE9288..0x82EE9A44)
	// 82EE9288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE928C: 4BDC0145  bl 0x82ca93d0
	ctx.lr = 0x82EE9290;
	sub_82CA93D0(ctx, base);
	// 82EE9290: 9421FBC0  stwu r1, -0x440(r1)
	ea = ctx.r[1].u32.wrapping_add(-1088 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE9294: 90610454  stw r3, 0x454(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1108 as u32), ctx.r[3].u32 ) };
	// 82EE9298: 9081045C  stw r4, 0x45c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1116 as u32), ctx.r[4].u32 ) };
	// 82EE929C: 98A10467  stb r5, 0x467(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1127 as u32), ctx.r[5].u8 ) };
	// 82EE92A0: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE92A4: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE92A8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE92AC: 4182070C  beq 0x82ee99b8
	if ctx.cr[0].eq {
	pc = 0x82EE99B8; continue 'dispatch;
	}
	// 82EE92B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE92B4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EE92B8: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE92BC: 4800215D  bl 0x82eeb418
	ctx.lr = 0x82EE92C0;
	sub_82EEB418(ctx, base);
	// 82EE92C0: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE92C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE92C8: 419A0014  beq cr6, 0x82ee92dc
	if ctx.cr[6].eq {
	pc = 0x82EE92DC; continue 'dispatch;
	}
	// 82EE92CC: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE92D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE92D4: 91610340  stw r11, 0x340(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(832 as u32), ctx.r[11].u32 ) };
	// 82EE92D8: 4800000C  b 0x82ee92e4
	pc = 0x82EE92E4; continue 'dispatch;
	// 82EE92DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE92E0: 91610340  stw r11, 0x340(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(832 as u32), ctx.r[11].u32 ) };
	// 82EE92E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE92E8: 3BEBC16C  addi r31, r11, -0x3e94
	ctx.r[31].s64 = ctx.r[11].s64 + -16020;
	// 82EE92EC: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE92F0: EBCB0140  ld r30, 0x140(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) };
	// 82EE92F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE92F8: 3BABC15C  addi r29, r11, -0x3ea4
	ctx.r[29].s64 = ctx.r[11].s64 + -16036;
	// 82EE92FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9300: 3B8BC16C  addi r28, r11, -0x3e94
	ctx.r[28].s64 = ctx.r[11].s64 + -16020;
	// 82EE9304: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9308: 836B0138  lwz r27, 0x138(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EE930C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9310: 3B4BC140  addi r26, r11, -0x3ec0
	ctx.r[26].s64 = ctx.r[11].s64 + -16064;
	// 82EE9314: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9318: 3B2BC16C  addi r25, r11, -0x3e94
	ctx.r[25].s64 = ctx.r[11].s64 + -16020;
	// 82EE931C: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9320: EB0B0358  ld r24, 0x358(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE9324: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9328: 3AEBC110  addi r23, r11, -0x3ef0
	ctx.r[23].s64 = ctx.r[11].s64 + -16112;
	// 82EE932C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9330: 3ACBC16C  addi r22, r11, -0x3e94
	ctx.r[22].s64 = ctx.r[11].s64 + -16020;
	// 82EE9334: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9338: 3AAB0148  addi r21, r11, 0x148
	ctx.r[21].s64 = ctx.r[11].s64 + 328;
	// 82EE933C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9340: 3A8BC0E4  addi r20, r11, -0x3f1c
	ctx.r[20].s64 = ctx.r[11].s64 + -16156;
	// 82EE9344: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9348: 3A6BC16C  addi r19, r11, -0x3e94
	ctx.r[19].s64 = ctx.r[11].s64 + -16020;
	// 82EE934C: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9350: 3A4B0248  addi r18, r11, 0x248
	ctx.r[18].s64 = ctx.r[11].s64 + 584;
	// 82EE9354: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9358: 3A2BC0B8  addi r17, r11, -0x3f48
	ctx.r[17].s64 = ctx.r[11].s64 + -16200;
	// 82EE935C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9360: 3A0BC16C  addi r16, r11, -0x3e94
	ctx.r[16].s64 = ctx.r[11].s64 + -16020;
	// 82EE9364: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9368: 4BFFF509  bl 0x82ee8870
	ctx.lr = 0x82EE936C;
	sub_82EE8870(ctx, base);
	// 82EE936C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE9370: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EE9374: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EE9378: 696F0001  xori r15, r11, 1
	ctx.r[15].u64 = ctx.r[11].u64 ^ 1;
	// 82EE937C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9380: 39CBC0A0  addi r14, r11, -0x3f60
	ctx.r[14].s64 = ctx.r[11].s64 + -16224;
	// 82EE9384: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9388: 396BC16C  addi r11, r11, -0x3e94
	ctx.r[11].s64 = ctx.r[11].s64 + -16020;
	// 82EE938C: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9390: 91610344  stw r11, 0x344(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(836 as u32), ctx.r[11].u32 ) };
	// 82EE9394: 4BFFF30D  bl 0x82ee86a0
	ctx.lr = 0x82EE9398;
	sub_82EE86A0(ctx, base);
	// 82EE9398: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE939C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE93A0: 394AC08C  addi r10, r10, -0x3f74
	ctx.r[10].s64 = ctx.r[10].s64 + -16244;
	// 82EE93A4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE93A8: 3929C16C  addi r9, r9, -0x3e94
	ctx.r[9].s64 = ctx.r[9].s64 + -16020;
	// 82EE93AC: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE93B0: 91210348  stw r9, 0x348(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(840 as u32), ctx.r[9].u32 ) };
	// 82EE93B4: 9141034C  stw r10, 0x34c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(844 as u32), ctx.r[10].u32 ) };
	// 82EE93B8: F9610350  std r11, 0x350(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(848 as u32), ctx.r[11].u64 ) };
	// 82EE93BC: 4BFFF445  bl 0x82ee8800
	ctx.lr = 0x82EE93C0;
	sub_82EE8800(ctx, base);
	// 82EE93C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE93C4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE93C8: 394AC07C  addi r10, r10, -0x3f84
	ctx.r[10].s64 = ctx.r[10].s64 + -16260;
	// 82EE93CC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE93D0: 3929C16C  addi r9, r9, -0x3e94
	ctx.r[9].s64 = ctx.r[9].s64 + -16020;
	// 82EE93D4: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE93D8: 91210358  stw r9, 0x358(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(856 as u32), ctx.r[9].u32 ) };
	// 82EE93DC: 9141035C  stw r10, 0x35c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(860 as u32), ctx.r[10].u32 ) };
	// 82EE93E0: F9610360  std r11, 0x360(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(864 as u32), ctx.r[11].u64 ) };
	// 82EE93E4: 4BFFF24D  bl 0x82ee8630
	ctx.lr = 0x82EE93E8;
	sub_82EE8630(ctx, base);
	// 82EE93E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE93EC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE93F0: 394AC05C  addi r10, r10, -0x3fa4
	ctx.r[10].s64 = ctx.r[10].s64 + -16292;
	// 82EE93F4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE93F8: 3929C16C  addi r9, r9, -0x3e94
	ctx.r[9].s64 = ctx.r[9].s64 + -16020;
	// 82EE93FC: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9400: 91210368  stw r9, 0x368(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(872 as u32), ctx.r[9].u32 ) };
	// 82EE9404: 9141036C  stw r10, 0x36c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(876 as u32), ctx.r[10].u32 ) };
	// 82EE9408: F9610370  std r11, 0x370(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(880 as u32), ctx.r[11].u64 ) };
	// 82EE940C: 4BFFF12D  bl 0x82ee8538
	ctx.lr = 0x82EE9410;
	sub_82EE8538(ctx, base);
	// 82EE9410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE9414: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE9418: 394AC04C  addi r10, r10, -0x3fb4
	ctx.r[10].s64 = ctx.r[10].s64 + -16308;
	// 82EE941C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE9420: 3889C024  addi r4, r9, -0x3fdc
	ctx.r[4].s64 = ctx.r[9].s64 + -16348;
	// 82EE9424: 80610340  lwz r3, 0x340(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(832 as u32) ) } as u64;
	// 82EE9428: 91410378  stw r10, 0x378(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(888 as u32), ctx.r[10].u32 ) };
	// 82EE942C: 9161037C  stw r11, 0x37c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(892 as u32), ctx.r[11].u32 ) };
	// 82EE9430: 48002429  bl 0x82eeb858
	ctx.lr = 0x82EE9434;
	sub_82EEB858(ctx, base);
	// 82EE9434: 81610378  lwz r11, 0x378(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(888 as u32) ) } as u64;
	// 82EE9438: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE943C: 4800241D  bl 0x82eeb858
	ctx.lr = 0x82EE9440;
	sub_82EEB858(ctx, base);
	// 82EE9440: 8161037C  lwz r11, 0x37c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(892 as u32) ) } as u64;
	// 82EE9444: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9448: 48002411  bl 0x82eeb858
	ctx.lr = 0x82EE944C;
	sub_82EEB858(ctx, base);
	// 82EE944C: 81610368  lwz r11, 0x368(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(872 as u32) ) } as u64;
	// 82EE9450: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9454: 48002405  bl 0x82eeb858
	ctx.lr = 0x82EE9458;
	sub_82EEB858(ctx, base);
	// 82EE9458: 8161036C  lwz r11, 0x36c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(876 as u32) ) } as u64;
	// 82EE945C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9460: 480023F9  bl 0x82eeb858
	ctx.lr = 0x82EE9464;
	sub_82EEB858(ctx, base);
	// 82EE9464: E9610370  ld r11, 0x370(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(880 as u32) ) };
	// 82EE9468: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE946C: 48000CF5  bl 0x82eea160
	ctx.lr = 0x82EE9470;
	sub_82EEA160(ctx, base);
	// 82EE9470: 81610358  lwz r11, 0x358(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(856 as u32) ) } as u64;
	// 82EE9474: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9478: 480023E1  bl 0x82eeb858
	ctx.lr = 0x82EE947C;
	sub_82EEB858(ctx, base);
	// 82EE947C: 8161035C  lwz r11, 0x35c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EE9480: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9484: 480023D5  bl 0x82eeb858
	ctx.lr = 0x82EE9488;
	sub_82EEB858(ctx, base);
	// 82EE9488: E9610360  ld r11, 0x360(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(864 as u32) ) };
	// 82EE948C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9490: 48000CD1  bl 0x82eea160
	ctx.lr = 0x82EE9494;
	sub_82EEA160(ctx, base);
	// 82EE9494: 81610348  lwz r11, 0x348(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(840 as u32) ) } as u64;
	// 82EE9498: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE949C: 480023BD  bl 0x82eeb858
	ctx.lr = 0x82EE94A0;
	sub_82EEB858(ctx, base);
	// 82EE94A0: 8161034C  lwz r11, 0x34c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(844 as u32) ) } as u64;
	// 82EE94A4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE94A8: 480023B1  bl 0x82eeb858
	ctx.lr = 0x82EE94AC;
	sub_82EEB858(ctx, base);
	// 82EE94AC: E9610350  ld r11, 0x350(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(848 as u32) ) };
	// 82EE94B0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE94B4: 48000CAD  bl 0x82eea160
	ctx.lr = 0x82EE94B8;
	sub_82EEA160(ctx, base);
	// 82EE94B8: 81610344  lwz r11, 0x344(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(836 as u32) ) } as u64;
	// 82EE94BC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE94C0: 48002399  bl 0x82eeb858
	ctx.lr = 0x82EE94C4;
	sub_82EEB858(ctx, base);
	// 82EE94C4: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 82EE94C8: 48002391  bl 0x82eeb858
	ctx.lr = 0x82EE94CC;
	sub_82EEB858(ctx, base);
	// 82EE94CC: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 82EE94D0: 48000971  bl 0x82ee9e40
	ctx.lr = 0x82EE94D4;
	sub_82EE9E40(ctx, base);
	// 82EE94D4: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82EE94D8: 48002381  bl 0x82eeb858
	ctx.lr = 0x82EE94DC;
	sub_82EEB858(ctx, base);
	// 82EE94DC: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 82EE94E0: 48002379  bl 0x82eeb858
	ctx.lr = 0x82EE94E4;
	sub_82EEB858(ctx, base);
	// 82EE94E4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82EE94E8: 48002371  bl 0x82eeb858
	ctx.lr = 0x82EE94EC;
	sub_82EEB858(ctx, base);
	// 82EE94EC: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82EE94F0: 48002369  bl 0x82eeb858
	ctx.lr = 0x82EE94F4;
	sub_82EEB858(ctx, base);
	// 82EE94F4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EE94F8: 48002361  bl 0x82eeb858
	ctx.lr = 0x82EE94FC;
	sub_82EEB858(ctx, base);
	// 82EE94FC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EE9500: 48002359  bl 0x82eeb858
	ctx.lr = 0x82EE9504;
	sub_82EEB858(ctx, base);
	// 82EE9504: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EE9508: 48002351  bl 0x82eeb858
	ctx.lr = 0x82EE950C;
	sub_82EEB858(ctx, base);
	// 82EE950C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EE9510: 48002349  bl 0x82eeb858
	ctx.lr = 0x82EE9514;
	sub_82EEB858(ctx, base);
	// 82EE9514: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EE9518: 48000DB1  bl 0x82eea2c8
	ctx.lr = 0x82EE951C;
	sub_82EEA2C8(ctx, base);
	// 82EE951C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EE9520: 48002339  bl 0x82eeb858
	ctx.lr = 0x82EE9524;
	sub_82EEB858(ctx, base);
	// 82EE9524: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EE9528: 48002331  bl 0x82eeb858
	ctx.lr = 0x82EE952C;
	sub_82EEB858(ctx, base);
	// 82EE952C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EE9530: 48000AC9  bl 0x82ee9ff8
	ctx.lr = 0x82EE9534;
	sub_82EE9FF8(ctx, base);
	// 82EE9534: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EE9538: 48002321  bl 0x82eeb858
	ctx.lr = 0x82EE953C;
	sub_82EEB858(ctx, base);
	// 82EE953C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE9540: 48002319  bl 0x82eeb858
	ctx.lr = 0x82EE9544;
	sub_82EEB858(ctx, base);
	// 82EE9544: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE9548: 48000C19  bl 0x82eea160
	ctx.lr = 0x82EE954C;
	sub_82EEA160(ctx, base);
	// 82EE954C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE9550: 48002309  bl 0x82eeb858
	ctx.lr = 0x82EE9554;
	sub_82EEB858(ctx, base);
	// 82EE9554: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9558: 91610218  stw r11, 0x218(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82EE955C: 48000010  b 0x82ee956c
	pc = 0x82EE956C; continue 'dispatch;
	// 82EE9560: 81610218  lwz r11, 0x218(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(536 as u32) ) } as u64;
	// 82EE9564: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9568: 91610218  stw r11, 0x218(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82EE956C: 81610218  lwz r11, 0x218(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(536 as u32) ) } as u64;
	// 82EE9570: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE9574: 40980084  bge cr6, 0x82ee95f8
	if !ctx.cr[6].lt {
	pc = 0x82EE95F8; continue 'dispatch;
	}
	// 82EE9578: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE957C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9580: 419A0014  beq cr6, 0x82ee9594
	if ctx.cr[6].eq {
	pc = 0x82EE9594; continue 'dispatch;
	}
	// 82EE9584: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9588: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE958C: 91610380  stw r11, 0x380(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(896 as u32), ctx.r[11].u32 ) };
	// 82EE9590: 4800000C  b 0x82ee959c
	pc = 0x82EE959C; continue 'dispatch;
	// 82EE9594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9598: 91610380  stw r11, 0x380(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(896 as u32), ctx.r[11].u32 ) };
	// 82EE959C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE95A0: 3BEBC16C  addi r31, r11, -0x3e94
	ctx.r[31].s64 = ctx.r[11].s64 + -16020;
	// 82EE95A4: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE95A8: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE95AC: 81410218  lwz r10, 0x218(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(536 as u32) ) } as u64;
	// 82EE95B0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE95B4: 7FCB502A  ldx r30, r11, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE95B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE95BC: 3BABC020  addi r29, r11, -0x3fe0
	ctx.r[29].s64 = ctx.r[11].s64 + -16352;
	// 82EE95C0: 83810218  lwz r28, 0x218(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(536 as u32) ) } as u64;
	// 82EE95C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE95C8: 388BC004  addi r4, r11, -0x3ffc
	ctx.r[4].s64 = ctx.r[11].s64 + -16380;
	// 82EE95CC: 80610380  lwz r3, 0x380(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(896 as u32) ) } as u64;
	// 82EE95D0: 48002289  bl 0x82eeb858
	ctx.lr = 0x82EE95D4;
	sub_82EEB858(ctx, base);
	// 82EE95D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EE95D8: 4BD98C41  bl 0x82c82218
	ctx.lr = 0x82EE95DC;
	sub_82C82218(ctx, base);
	// 82EE95DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE95E0: 480011D1  bl 0x82eea7b0
	ctx.lr = 0x82EE95E4;
	sub_82EEA7B0(ctx, base);
	// 82EE95E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE95E8: 48000B79  bl 0x82eea160
	ctx.lr = 0x82EE95EC;
	sub_82EEA160(ctx, base);
	// 82EE95EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE95F0: 48002269  bl 0x82eeb858
	ctx.lr = 0x82EE95F4;
	sub_82EEB858(ctx, base);
	// 82EE95F4: 4BFFFF6C  b 0x82ee9560
	pc = 0x82EE9560; continue 'dispatch;
	// 82EE95F8: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE95FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9600: 419A0014  beq cr6, 0x82ee9614
	if ctx.cr[6].eq {
	pc = 0x82EE9614; continue 'dispatch;
	}
	// 82EE9604: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9608: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE960C: 91610384  stw r11, 0x384(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(900 as u32), ctx.r[11].u32 ) };
	// 82EE9610: 4800000C  b 0x82ee961c
	pc = 0x82EE961C; continue 'dispatch;
	// 82EE9614: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9618: 91610384  stw r11, 0x384(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(900 as u32), ctx.r[11].u32 ) };
	// 82EE961C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9620: 3BEBC020  addi r31, r11, -0x3fe0
	ctx.r[31].s64 = ctx.r[11].s64 + -16352;
	// 82EE9624: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9628: 388BBFDC  addi r4, r11, -0x4024
	ctx.r[4].s64 = ctx.r[11].s64 + -16420;
	// 82EE962C: 80610384  lwz r3, 0x384(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(900 as u32) ) } as u64;
	// 82EE9630: 48002229  bl 0x82eeb858
	ctx.lr = 0x82EE9634;
	sub_82EEB858(ctx, base);
	// 82EE9634: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE9638: 48001179  bl 0x82eea7b0
	ctx.lr = 0x82EE963C;
	sub_82EEA7B0(ctx, base);
	// 82EE963C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9640: 9161021C  stw r11, 0x21c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 82EE9644: 48000010  b 0x82ee9654
	pc = 0x82EE9654; continue 'dispatch;
	// 82EE9648: 8161021C  lwz r11, 0x21c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE964C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9650: 9161021C  stw r11, 0x21c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 82EE9654: 8161021C  lwz r11, 0x21c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE9658: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE965C: 40980160  bge cr6, 0x82ee97bc
	if !ctx.cr[6].lt {
	pc = 0x82EE97BC; continue 'dispatch;
	}
	// 82EE9660: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9664: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE9668: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE966C: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9670: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82EE9674: 4098004C  bge cr6, 0x82ee96c0
	if !ctx.cr[6].lt {
	pc = 0x82EE96C0; continue 'dispatch;
	}
	// 82EE9678: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE967C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9680: 419A0014  beq cr6, 0x82ee9694
	if ctx.cr[6].eq {
	pc = 0x82EE9694; continue 'dispatch;
	}
	// 82EE9684: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9688: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE968C: 91610388  stw r11, 0x388(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(904 as u32), ctx.r[11].u32 ) };
	// 82EE9690: 4800000C  b 0x82ee969c
	pc = 0x82EE969C; continue 'dispatch;
	// 82EE9694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9698: 91610388  stw r11, 0x388(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(904 as u32), ctx.r[11].u32 ) };
	// 82EE969C: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE96A0: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE96A4: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE96A8: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE96AC: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 82EE96B0: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 82EE96B4: 80610388  lwz r3, 0x388(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(904 as u32) ) } as u64;
	// 82EE96B8: 48001441  bl 0x82eeaaf8
	ctx.lr = 0x82EE96BC;
	sub_82EEAAF8(ctx, base);
	// 82EE96BC: 480000FC  b 0x82ee97b8
	pc = 0x82EE97B8; continue 'dispatch;
	// 82EE96C0: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE96C4: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE96C8: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE96CC: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE96D0: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 82EE96D4: 40980050  bge cr6, 0x82ee9724
	if !ctx.cr[6].lt {
	pc = 0x82EE9724; continue 'dispatch;
	}
	// 82EE96D8: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE96DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE96E0: 419A0014  beq cr6, 0x82ee96f4
	if ctx.cr[6].eq {
	pc = 0x82EE96F4; continue 'dispatch;
	}
	// 82EE96E4: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE96E8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE96EC: 9161038C  stw r11, 0x38c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 82EE96F0: 4800000C  b 0x82ee96fc
	pc = 0x82EE96FC; continue 'dispatch;
	// 82EE96F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE96F8: 9161038C  stw r11, 0x38c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 82EE96FC: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9700: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE9704: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE9708: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE970C: 396BFFF6  addi r11, r11, -0xa
	ctx.r[11].s64 = ctx.r[11].s64 + -10;
	// 82EE9710: 396B0041  addi r11, r11, 0x41
	ctx.r[11].s64 = ctx.r[11].s64 + 65;
	// 82EE9714: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 82EE9718: 8061038C  lwz r3, 0x38c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(908 as u32) ) } as u64;
	// 82EE971C: 480013DD  bl 0x82eeaaf8
	ctx.lr = 0x82EE9720;
	sub_82EEAAF8(ctx, base);
	// 82EE9720: 48000098  b 0x82ee97b8
	pc = 0x82EE97B8; continue 'dispatch;
	// 82EE9724: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9728: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE972C: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE9730: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9734: 2F0B003E  cmpwi cr6, r11, 0x3e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 62, &mut ctx.xer);
	// 82EE9738: 40980050  bge cr6, 0x82ee9788
	if !ctx.cr[6].lt {
	pc = 0x82EE9788; continue 'dispatch;
	}
	// 82EE973C: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9744: 419A0014  beq cr6, 0x82ee9758
	if ctx.cr[6].eq {
	pc = 0x82EE9758; continue 'dispatch;
	}
	// 82EE9748: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE974C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE9750: 91610390  stw r11, 0x390(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82EE9754: 4800000C  b 0x82ee9760
	pc = 0x82EE9760; continue 'dispatch;
	// 82EE9758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE975C: 91610390  stw r11, 0x390(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82EE9760: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9764: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE9768: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE976C: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9770: 396BFFDC  addi r11, r11, -0x24
	ctx.r[11].s64 = ctx.r[11].s64 + -36;
	// 82EE9774: 396B0061  addi r11, r11, 0x61
	ctx.r[11].s64 = ctx.r[11].s64 + 97;
	// 82EE9778: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 82EE977C: 80610390  lwz r3, 0x390(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EE9780: 48001379  bl 0x82eeaaf8
	ctx.lr = 0x82EE9784;
	sub_82EEAAF8(ctx, base);
	// 82EE9784: 48000034  b 0x82ee97b8
	pc = 0x82EE97B8; continue 'dispatch;
	// 82EE9788: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE978C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9790: 419A0014  beq cr6, 0x82ee97a4
	if ctx.cr[6].eq {
	pc = 0x82EE97A4; continue 'dispatch;
	}
	// 82EE9794: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9798: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE979C: 91610394  stw r11, 0x394(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(916 as u32), ctx.r[11].u32 ) };
	// 82EE97A0: 4800000C  b 0x82ee97ac
	pc = 0x82EE97AC; continue 'dispatch;
	// 82EE97A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE97A8: 91610394  stw r11, 0x394(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(916 as u32), ctx.r[11].u32 ) };
	// 82EE97AC: 3880002E  li r4, 0x2e
	ctx.r[4].s64 = 46;
	// 82EE97B0: 80610394  lwz r3, 0x394(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EE97B4: 48001345  bl 0x82eeaaf8
	ctx.lr = 0x82EE97B8;
	sub_82EEAAF8(ctx, base);
	// 82EE97B8: 4BFFFE90  b 0x82ee9648
	pc = 0x82EE9648; continue 'dispatch;
	// 82EE97BC: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE97C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE97C4: 419A0014  beq cr6, 0x82ee97d8
	if ctx.cr[6].eq {
	pc = 0x82EE97D8; continue 'dispatch;
	}
	// 82EE97C8: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE97CC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE97D0: 91610398  stw r11, 0x398(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 82EE97D4: 4800000C  b 0x82ee97e0
	pc = 0x82EE97E0; continue 'dispatch;
	// 82EE97D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE97DC: 91610398  stw r11, 0x398(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 82EE97E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE97E4: 388BC16C  addi r4, r11, -0x3e94
	ctx.r[4].s64 = ctx.r[11].s64 + -16020;
	// 82EE97E8: 80610398  lwz r3, 0x398(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EE97EC: 4800206D  bl 0x82eeb858
	ctx.lr = 0x82EE97F0;
	sub_82EEB858(ctx, base);
	// 82EE97F0: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE97F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE97F8: 419A0014  beq cr6, 0x82ee980c
	if ctx.cr[6].eq {
	pc = 0x82EE980C; continue 'dispatch;
	}
	// 82EE97FC: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9800: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE9804: 9161039C  stw r11, 0x39c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 82EE9808: 4800000C  b 0x82ee9814
	pc = 0x82EE9814; continue 'dispatch;
	// 82EE980C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9810: 9161039C  stw r11, 0x39c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 82EE9814: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9818: 388BBFD4  addi r4, r11, -0x402c
	ctx.r[4].s64 = ctx.r[11].s64 + -16428;
	// 82EE981C: 8061039C  lwz r3, 0x39c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EE9820: 48002039  bl 0x82eeb858
	ctx.lr = 0x82EE9824;
	sub_82EEB858(ctx, base);
	// 82EE9824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE9828: 38810190  addi r4, r1, 0x190
	ctx.r[4].s64 = ctx.r[1].s64 + 400;
	// 82EE982C: 48001D05  bl 0x82eeb530
	ctx.lr = 0x82EE9830;
	sub_82EEB530(ctx, base);
	// 82EE9830: 80C1045C  lwz r6, 0x45c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EE9834: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9838: 38ABBFC0  addi r5, r11, -0x4040
	ctx.r[5].s64 = ctx.r[11].s64 + -16448;
	// 82EE983C: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE9840: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EE9844: 48001805  bl 0x82eeb048
	ctx.lr = 0x82EE9848;
	sub_82EEB048(ctx, base);
	// 82EE9848: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE984C: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 82EE9850: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EE9854: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EE9858: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE985C: 3C804000  lis r4, 0x4000
	ctx.r[4].s64 = 1073741824;
	// 82EE9860: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EE9864: 4BDD9C2D  bl 0x82cc3490
	ctx.lr = 0x82EE9868;
	sub_82CC3490(ctx, base);
	// 82EE9868: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EE986C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9870: 48001AD1  bl 0x82eeb340
	ctx.lr = 0x82EE9874;
	sub_82EEB340(ctx, base);
	// 82EE9874: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9878: 48001B59  bl 0x82eeb3d0
	ctx.lr = 0x82EE987C;
	sub_82EEB3D0(ctx, base);
	// 82EE987C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9880: 41820030  beq 0x82ee98b0
	if ctx.cr[0].eq {
	pc = 0x82EE98B0; continue 'dispatch;
	}
	// 82EE9884: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE9888: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE988C: 91610334  stw r11, 0x334(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(820 as u32), ctx.r[11].u32 ) };
	// 82EE9890: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9894: 48001ACD  bl 0x82eeb360
	ctx.lr = 0x82EE9898;
	sub_82EEB360(ctx, base);
	// 82EE9898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE989C: 4B408A1D  bl 0x822f22b8
	ctx.lr = 0x82EE98A0;
	sub_822F22B8(ctx, base);
	// 82EE98A0: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE98A4: 48001A65  bl 0x82eeb308
	ctx.lr = 0x82EE98A8;
	sub_82EEB308(ctx, base);
	// 82EE98A8: 80610334  lwz r3, 0x334(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(820 as u32) ) } as u64;
	// 82EE98AC: 48000190  b 0x82ee9a3c
	pc = 0x82EE9A3C; continue 'dispatch;
	// 82EE98B0: 3960FEFF  li r11, -0x101
	ctx.r[11].s64 = -257;
	// 82EE98B4: B161006C  sth r11, 0x6c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u16 ) };
	// 82EE98B8: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82EE98BC: 3BC1006C  addi r30, r1, 0x6c
	ctx.r[30].s64 = ctx.r[1].s64 + 108;
	// 82EE98C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE98C4: 480038FD  bl 0x82eed1c0
	ctx.lr = 0x82EE98C8;
	sub_82EED1C0(ctx, base);
	// 82EE98C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE98CC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EE98D0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EE98D4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EE98D8: 4BDDD6E1  bl 0x82cc6fb8
	ctx.lr = 0x82EE98DC;
	sub_82CC6FB8(ctx, base);
	// 82EE98DC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EE98E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE98E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE98E8: 409A0030  bne cr6, 0x82ee9918
	if !ctx.cr[6].eq {
	pc = 0x82EE9918; continue 'dispatch;
	}
	// 82EE98EC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE98F0: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE98F4: 91610338  stw r11, 0x338(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(824 as u32), ctx.r[11].u32 ) };
	// 82EE98F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE98FC: 48001A65  bl 0x82eeb360
	ctx.lr = 0x82EE9900;
	sub_82EEB360(ctx, base);
	// 82EE9900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE9904: 4B4089B5  bl 0x822f22b8
	ctx.lr = 0x82EE9908;
	sub_822F22B8(ctx, base);
	// 82EE9908: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE990C: 480019FD  bl 0x82eeb308
	ctx.lr = 0x82EE9910;
	sub_82EEB308(ctx, base);
	// 82EE9910: 80610338  lwz r3, 0x338(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(824 as u32) ) } as u64;
	// 82EE9914: 48000128  b 0x82ee9a3c
	pc = 0x82EE9A3C; continue 'dispatch;
	// 82EE9918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE991C: 48000B15  bl 0x82eea430
	ctx.lr = 0x82EE9920;
	sub_82EEA430(ctx, base);
	// 82EE9920: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE9924: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EE9928: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82EE992C: 83C1007C  lwz r30, 0x7c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EE9930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE9934: 4B40D045  bl 0x822f6978
	ctx.lr = 0x82EE9938;
	sub_822F6978(ctx, base);
	// 82EE9938: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EE993C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9940: 48003881  bl 0x82eed1c0
	ctx.lr = 0x82EE9944;
	sub_82EED1C0(ctx, base);
	// 82EE9944: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE9948: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EE994C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EE9950: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EE9954: 4BDDD665  bl 0x82cc6fb8
	ctx.lr = 0x82EE9958;
	sub_82CC6FB8(ctx, base);
	// 82EE9958: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EE995C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE9960: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9964: 409A0030  bne cr6, 0x82ee9994
	if !ctx.cr[6].eq {
	pc = 0x82EE9994; continue 'dispatch;
	}
	// 82EE9968: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE996C: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE9970: 9161033C  stw r11, 0x33c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(828 as u32), ctx.r[11].u32 ) };
	// 82EE9974: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9978: 480019E9  bl 0x82eeb360
	ctx.lr = 0x82EE997C;
	sub_82EEB360(ctx, base);
	// 82EE997C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE9980: 4B408939  bl 0x822f22b8
	ctx.lr = 0x82EE9984;
	sub_822F22B8(ctx, base);
	// 82EE9984: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE9988: 48001981  bl 0x82eeb308
	ctx.lr = 0x82EE998C;
	sub_82EEB308(ctx, base);
	// 82EE998C: 8061033C  lwz r3, 0x33c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(828 as u32) ) } as u64;
	// 82EE9990: 480000AC  b 0x82ee9a3c
	pc = 0x82EE9A3C; continue 'dispatch;
	// 82EE9994: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9998: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE999C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE99A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE99A4: 480019BD  bl 0x82eeb360
	ctx.lr = 0x82EE99A8;
	sub_82EEB360(ctx, base);
	// 82EE99A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE99AC: 4B40890D  bl 0x822f22b8
	ctx.lr = 0x82EE99B0;
	sub_822F22B8(ctx, base);
	// 82EE99B0: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE99B4: 48001955  bl 0x82eeb308
	ctx.lr = 0x82EE99B8;
	sub_82EEB308(ctx, base);
	// 82EE99B8: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE99BC: 896B0365  lbz r11, 0x365(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(869 as u32) ) } as u64;
	// 82EE99C0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE99C4: 41820074  beq 0x82ee9a38
	if ctx.cr[0].eq {
	pc = 0x82EE9A38; continue 'dispatch;
	}
	// 82EE99C8: 89610467  lbz r11, 0x467(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1127 as u32) ) } as u64;
	// 82EE99CC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE99D0: 41820068  beq 0x82ee9a38
	if ctx.cr[0].eq {
	pc = 0x82EE9A38; continue 'dispatch;
	}
	// 82EE99D4: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE99D8: 816B0360  lwz r11, 0x360(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE99DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE99E0: 419A0058  beq cr6, 0x82ee9a38
	if ctx.cr[6].eq {
	pc = 0x82EE9A38; continue 'dispatch;
	}
	// 82EE99E4: 80C1045C  lwz r6, 0x45c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EE99E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE99EC: 38ABBE1C  addi r5, r11, -0x41e4
	ctx.r[5].s64 = ctx.r[11].s64 + -16868;
	// 82EE99F0: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE99F4: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82EE99F8: 48001651  bl 0x82eeb048
	ctx.lr = 0x82EE99FC;
	sub_82EEB048(ctx, base);
	// 82EE99FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EE9A00: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9A04: 80AB0360  lwz r5, 0x360(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE9A08: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EE9A0C: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82EE9A10: 4BE2CEB1  bl 0x82d168c0
	ctx.lr = 0x82EE9A14;
	sub_82D168C0(ctx, base);
	// 82EE9A14: 90610220  stw r3, 0x220(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(544 as u32), ctx.r[3].u32 ) };
	// 82EE9A18: 81610220  lwz r11, 0x220(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(544 as u32) ) } as u64;
	// 82EE9A1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9A20: 4098000C  bge cr6, 0x82ee9a2c
	if !ctx.cr[6].lt {
	pc = 0x82EE9A2C; continue 'dispatch;
	}
	// 82EE9A24: 80610220  lwz r3, 0x220(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(544 as u32) ) } as u64;
	// 82EE9A28: 48000014  b 0x82ee9a3c
	pc = 0x82EE9A3C; continue 'dispatch;
	// 82EE9A2C: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9A30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9A34: 994B0365  stb r10, 0x365(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(869 as u32), ctx.r[10].u8 ) };
	// 82EE9A38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE9A3C: 38210440  addi r1, r1, 0x440
	ctx.r[1].s64 = ctx.r[1].s64 + 1088;
	// 82EE9A40: 4BDBF9E0  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9A48 size=1016
    let mut pc: u32 = 0x82EE9A48;
    'dispatch: loop {
        match pc {
            0x82EE9A48 => {
    //   block [0x82EE9A48..0x82EE9E40)
	// 82EE9A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE9A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE9A50: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE9A54: 906100F4  stw r3, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 82EE9A58: 908100FC  stw r4, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[4].u32 ) };
	// 82EE9A5C: 90A10104  stw r5, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[5].u32 ) };
	// 82EE9A60: 90C1010C  stw r6, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[6].u32 ) };
	// 82EE9A64: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9A68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE9A6C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE9A70: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9A74: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE9A78: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82EE9A7C: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9A80: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE9A84: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 82EE9A88: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9A8C: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE9A90: 396BFE0C  addi r11, r11, -0x1f4
	ctx.r[11].s64 = ctx.r[11].s64 + -500;
	// 82EE9A94: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 82EE9A98: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9A9C: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE9AA0: F96100B8  std r11, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u64 ) };
	// 82EE9AA4: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AA8: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE9AAC: E9410098  ld r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82EE9AB0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE9AB4: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AB8: F96A0108  std r11, 0x108(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(264 as u32), ctx.r[11].u64 ) };
	// 82EE9ABC: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AC0: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE9AC4: E94100B8  ld r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 82EE9AC8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE9ACC: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AD0: F96A0130  std r11, 0x130(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(304 as u32), ctx.r[11].u64 ) };
	// 82EE9AD4: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AD8: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE9ADC: 2F2B0000  cmpdi cr6, r11, 0
	ctx.cr[6].compare_i64(ctx.r[11].s64, 0, &mut ctx.xer);
	// 82EE9AE0: 40980030  bge cr6, 0x82ee9b10
	if !ctx.cr[6].lt {
	pc = 0x82EE9B10; continue 'dispatch;
	}
	// 82EE9AE4: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AE8: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AEC: E94A0108  ld r10, 0x108(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(264 as u32) ) };
	// 82EE9AF0: 7D4A00D0  neg r10, r10
	ctx.r[10].s64 = -ctx.r[10].s64;
	// 82EE9AF4: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE9AF8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE9AFC: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9B00: F96A0130  std r11, 0x130(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(304 as u32), ctx.r[11].u64 ) };
	// 82EE9B04: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9B08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9B0C: F94B0108  std r10, 0x108(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), ctx.r[10].u64 ) };
	// 82EE9B10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9B14: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EE9B18: 48000010  b 0x82ee9b28
	pc = 0x82EE9B28; continue 'dispatch;
	// 82EE9B1C: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EE9B20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9B24: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EE9B28: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EE9B2C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE9B30: 4098002C  bge cr6, 0x82ee9b5c
	if !ctx.cr[6].lt {
	pc = 0x82EE9B5C; continue 'dispatch;
	}
	// 82EE9B34: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9B38: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE9B3C: 814100C0  lwz r10, 0xc0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EE9B40: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE9B44: 812100C0  lwz r9, 0xc0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EE9B48: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EE9B4C: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82EE9B50: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE9B54: 7D68492A  stdx r11, r8, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u64) };
	// 82EE9B58: 4BFFFFC4  b 0x82ee9b1c
	pc = 0x82EE9B1C; continue 'dispatch;
	// 82EE9B5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9B60: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 82EE9B64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9B68: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EE9B6C: 48000010  b 0x82ee9b7c
	pc = 0x82EE9B7C; continue 'dispatch;
	// 82EE9B70: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9B74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9B78: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EE9B7C: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9B80: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE9B84: 40980068  bge cr6, 0x82ee9bec
	if !ctx.cr[6].lt {
	pc = 0x82EE9BEC; continue 'dispatch;
	}
	// 82EE9B88: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9B8C: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE9B90: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9B94: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE9B98: 81210104  lwz r9, 0x104(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9B9C: 39290118  addi r9, r9, 0x118
	ctx.r[9].s64 = ctx.r[9].s64 + 280;
	// 82EE9BA0: 810100C4  lwz r8, 0xc4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9BA4: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EE9BA8: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE9BAC: 7D49402A  ldx r10, r9, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	// 82EE9BB0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE9BB4: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9BB8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE9BBC: 812100F4  lwz r9, 0xf4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9BC0: 39290118  addi r9, r9, 0x118
	ctx.r[9].s64 = ctx.r[9].s64 + 280;
	// 82EE9BC4: 7D69512A  stdx r11, r9, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u64) };
	// 82EE9BC8: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9BCC: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE9BD0: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9BD4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE9BD8: E92100A0  ld r9, 0xa0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9BDC: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE9BE0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EE9BE4: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 82EE9BE8: 4BFFFF88  b 0x82ee9b70
	pc = 0x82EE9B70; continue 'dispatch;
	// 82EE9BEC: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9BF0: E96B0110  ld r11, 0x110(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	// 82EE9BF4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82EE9BF8: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9BFC: 3D400004  lis r10, 4
	ctx.r[10].s64 = 262144;
	// 82EE9C00: 614A93E0  ori r10, r10, 0x93e0
	ctx.r[10].u64 = ctx.r[10].u64 | 37856;
	// 82EE9C04: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE9C08: 40990014  ble cr6, 0x82ee9c1c
	if !ctx.cr[6].gt {
	pc = 0x82EE9C1C; continue 'dispatch;
	}
	// 82EE9C0C: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C10: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82EE9C14: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE9C18: 4800005C  b 0x82ee9c74
	pc = 0x82EE9C74; continue 'dispatch;
	// 82EE9C1C: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9C20: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 82EE9C24: 614A24F8  ori r10, r10, 0x24f8
	ctx.r[10].u64 = ctx.r[10].u64 | 9464;
	// 82EE9C28: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE9C2C: 40990014  ble cr6, 0x82ee9c40
	if !ctx.cr[6].gt {
	pc = 0x82EE9C40; continue 'dispatch;
	}
	// 82EE9C30: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C34: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82EE9C38: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE9C3C: 48000038  b 0x82ee9c74
	pc = 0x82EE9C74; continue 'dispatch;
	// 82EE9C40: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9C44: 2F2B3A98  cmpdi cr6, r11, 0x3a98
	ctx.cr[6].compare_i64(ctx.r[11].s64, 15000, &mut ctx.xer);
	// 82EE9C48: 40990014  ble cr6, 0x82ee9c5c
	if !ctx.cr[6].gt {
	pc = 0x82EE9C5C; continue 'dispatch;
	}
	// 82EE9C4C: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C50: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82EE9C54: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE9C58: 4800001C  b 0x82ee9c74
	pc = 0x82EE9C74; continue 'dispatch;
	// 82EE9C5C: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9C60: 2F2B0BB8  cmpdi cr6, r11, 0xbb8
	ctx.cr[6].compare_i64(ctx.r[11].s64, 3000, &mut ctx.xer);
	// 82EE9C64: 40990010  ble cr6, 0x82ee9c74
	if !ctx.cr[6].gt {
	pc = 0x82EE9C74; continue 'dispatch;
	}
	// 82EE9C68: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C6C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EE9C70: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE9C74: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C78: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE9C7C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82EE9C80: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C84: 81410104  lwz r10, 0x104(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9C88: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE9C8C: E94A0358  ld r10, 0x358(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(856 as u32) ) };
	// 82EE9C90: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EE9C94: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C98: F96A0358  std r11, 0x358(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(856 as u32), ctx.r[11].u64 ) };
	// 82EE9C9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9CA0: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EE9CA4: 48000010  b 0x82ee9cb4
	pc = 0x82EE9CB4; continue 'dispatch;
	// 82EE9CA8: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EE9CAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9CB0: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EE9CB4: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EE9CB8: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE9CBC: 40980024  bge cr6, 0x82ee9ce0
	if !ctx.cr[6].lt {
	pc = 0x82EE9CE0; continue 'dispatch;
	}
	// 82EE9CC0: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9CC4: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE9CC8: 814100C8  lwz r10, 0xc8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EE9CCC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EE9CD0: 810100C8  lwz r8, 0xc8(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EE9CD4: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9CD8: 7D6941AE  stbx r11, r9, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u8) };
	// 82EE9CDC: 4BFFFFCC  b 0x82ee9ca8
	pc = 0x82EE9CA8; continue 'dispatch;
	// 82EE9CE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9CE4: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82EE9CE8: 48000010  b 0x82ee9cf8
	pc = 0x82EE9CF8; continue 'dispatch;
	// 82EE9CEC: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9CF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9CF4: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82EE9CF8: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9CFC: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE9D00: 40980024  bge cr6, 0x82ee9d24
	if !ctx.cr[6].lt {
	pc = 0x82EE9D24; continue 'dispatch;
	}
	// 82EE9D04: 808100CC  lwz r4, 0xcc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9D08: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9D0C: 4BFFED35  bl 0x82ee8a40
	ctx.lr = 0x82EE9D10;
	sub_82EE8A40(ctx, base);
	// 82EE9D10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EE9D14: 808100CC  lwz r4, 0xcc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9D18: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9D1C: 4BFFED45  bl 0x82ee8a60
	ctx.lr = 0x82EE9D20;
	sub_82EE8A60(ctx, base);
	// 82EE9D20: 4BFFFFCC  b 0x82ee9cec
	pc = 0x82EE9CEC; continue 'dispatch;
	// 82EE9D24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE9D28: 8081010C  lwz r4, 0x10c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EE9D2C: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82EE9D30: 4BDDA551  bl 0x82cc4280
	ctx.lr = 0x82EE9D34;
	sub_82CC4280(ctx, base);
	// 82EE9D34: 906100B0  stw r3, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82EE9D38: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EE9D3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9D40: 419A00EC  beq cr6, 0x82ee9e2c
	if ctx.cr[6].eq {
	pc = 0x82EE9E2C; continue 'dispatch;
	}
	// 82EE9D44: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9D48: E9410070  ld r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82EE9D4C: F94B0108  std r10, 0x108(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), ctx.r[10].u64 ) };
	// 82EE9D50: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9D54: E94100A8  ld r10, 0xa8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82EE9D58: F94B0130  std r10, 0x130(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(304 as u32), ctx.r[10].u64 ) };
	// 82EE9D5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9D60: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82EE9D64: 48000010  b 0x82ee9d74
	pc = 0x82EE9D74; continue 'dispatch;
	// 82EE9D68: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EE9D6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9D70: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82EE9D74: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EE9D78: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE9D7C: 4098002C  bge cr6, 0x82ee9da8
	if !ctx.cr[6].lt {
	pc = 0x82EE9DA8; continue 'dispatch;
	}
	// 82EE9D80: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EE9D84: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE9D88: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82EE9D8C: 812100F4  lwz r9, 0xf4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9D90: 39290118  addi r9, r9, 0x118
	ctx.r[9].s64 = ctx.r[9].s64 + 280;
	// 82EE9D94: 810100D0  lwz r8, 0xd0(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EE9D98: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EE9D9C: 7D6A582A  ldx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 82EE9DA0: 7D69412A  stdx r11, r9, r8
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u64) };
	// 82EE9DA4: 4BFFFFC4  b 0x82ee9d68
	pc = 0x82EE9D68; continue 'dispatch;
	// 82EE9DA8: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9DAC: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EE9DB0: F94B0358  std r10, 0x358(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(856 as u32), ctx.r[10].u64 ) };
	// 82EE9DB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9DB8: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82EE9DBC: 48000010  b 0x82ee9dcc
	pc = 0x82EE9DCC; continue 'dispatch;
	// 82EE9DC0: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE9DC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9DC8: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82EE9DCC: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE9DD0: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE9DD4: 40980024  bge cr6, 0x82ee9df8
	if !ctx.cr[6].lt {
	pc = 0x82EE9DF8; continue 'dispatch;
	}
	// 82EE9DD8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EE9DDC: 814100D4  lwz r10, 0xd4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE9DE0: 812100F4  lwz r9, 0xf4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9DE4: 39290348  addi r9, r9, 0x348
	ctx.r[9].s64 = ctx.r[9].s64 + 840;
	// 82EE9DE8: 810100D4  lwz r8, 0xd4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE9DEC: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9DF0: 7D6941AE  stbx r11, r9, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u8) };
	// 82EE9DF4: 4BFFFFCC  b 0x82ee9dc0
	pc = 0x82EE9DC0; continue 'dispatch;
	// 82EE9DF8: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9DFC: E9410068  ld r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82EE9E00: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE9E04: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EE9E08: 2B0B048F  cmplwi cr6, r11, 0x48f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1167 as u32, &mut ctx.xer);
	// 82EE9E0C: 409A0014  bne cr6, 0x82ee9e20
	if !ctx.cr[6].eq {
	pc = 0x82EE9E20; continue 'dispatch;
	}
	// 82EE9E10: 3860048F  li r3, 0x48f
	ctx.r[3].s64 = 1167;
	// 82EE9E14: 4B41806D  bl 0x82301e80
	ctx.lr = 0x82EE9E18;
	sub_82301E80(ctx, base);
	// 82EE9E18: 48000018  b 0x82ee9e30
	pc = 0x82EE9E30; continue 'dispatch;
	// 82EE9E1C: 48000010  b 0x82ee9e2c
	pc = 0x82EE9E2C; continue 'dispatch;
	// 82EE9E20: 806100B0  lwz r3, 0xb0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EE9E24: 4B41805D  bl 0x82301e80
	ctx.lr = 0x82EE9E28;
	sub_82301E80(ctx, base);
	// 82EE9E28: 48000008  b 0x82ee9e30
	pc = 0x82EE9E30; continue 'dispatch;
	// 82EE9E2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE9E30: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EE9E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE9E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE9E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9E40 size=440
    let mut pc: u32 = 0x82EE9E40;
    'dispatch: loop {
        match pc {
            0x82EE9E40 => {
    //   block [0x82EE9E40..0x82EE9FF8)
	// 82EE9E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE9E44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE9E48: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE9E4C: 906100C4  stw r3, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82EE9E50: 908100CC  stw r4, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[4].u32 ) };
	// 82EE9E54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9E58: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EE9E5C: 808100C4  lwz r4, 0xc4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9E60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EE9E64: 4BD96DED  bl 0x82c80c50
	ctx.lr = 0x82EE9E68;
	sub_82C80C50(ctx, base);
	// 82EE9E68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EE9E6C: 4BD9610D  bl 0x82c7ff78
	ctx.lr = 0x82EE9E70;
	sub_82C7FF78(ctx, base);
	// 82EE9E70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9E74: 41820140  beq 0x82ee9fb4
	if ctx.cr[0].eq {
	pc = 0x82EE9FB4; continue 'dispatch;
	}
	// 82EE9E78: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EE9E7C: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9E80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9E84: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9E88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9E8C: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9E90: 4B792549  bl 0x8267c3d8
	ctx.lr = 0x82EE9E94;
	sub_8267C3D8(ctx, base);
	// 82EE9E94: 4BD96E5D  bl 0x82c80cf0
	ctx.lr = 0x82EE9E98;
	sub_82C80CF0(ctx, base);
	// 82EE9E98: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EE9E9C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EE9EA0: 4B792481  bl 0x8267c320
	ctx.lr = 0x82EE9EA4;
	sub_8267C320(ctx, base);
	// 82EE9EA4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9EA8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9EAC: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9EB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9EB4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9EB8: 482D21A9  bl 0x831bc060
	ctx.lr = 0x82EE9EBC;
	sub_831BC060(ctx, base);
	// 82EE9EBC: 546B052C  rlwinm r11, r3, 0, 0x14, 0x16
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82EE9EC0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EE9EC4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EE9EC8: 2F0B0400  cmpwi cr6, r11, 0x400
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1024, &mut ctx.xer);
	// 82EE9ECC: 419A001C  beq cr6, 0x82ee9ee8
	if ctx.cr[6].eq {
	pc = 0x82EE9EE8; continue 'dispatch;
	}
	// 82EE9ED0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EE9ED4: 2F0B0800  cmpwi cr6, r11, 0x800
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2048, &mut ctx.xer);
	// 82EE9ED8: 419A0010  beq cr6, 0x82ee9ee8
	if ctx.cr[6].eq {
	pc = 0x82EE9EE8; continue 'dispatch;
	}
	// 82EE9EDC: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9EE0: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EE9EE4: 4800000C  b 0x82ee9ef0
	pc = 0x82EE9EF0; continue 'dispatch;
	// 82EE9EE8: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9EEC: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EE9EF0: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EE9EF4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EE9EF8: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9EFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9F00: 409A0010  bne cr6, 0x82ee9f10
	if !ctx.cr[6].eq {
	pc = 0x82EE9F10; continue 'dispatch;
	}
	// 82EE9F04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9F08: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82EE9F0C: 4800001C  b 0x82ee9f28
	pc = 0x82EE9F28; continue 'dispatch;
	// 82EE9F10: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9F18: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9F20: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9F24: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82EE9F28: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE9F2C: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82EE9F30: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9F38: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9F40: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9F44: 4BD9602D  bl 0x82c7ff70
	ctx.lr = 0x82EE9F48;
	sub_82C7FF70(ctx, base);
	// 82EE9F48: B061009C  sth r3, 0x9c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[3].u16 ) };
	// 82EE9F4C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EE9F50: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EE9F54: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9F5C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9F64: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9F68: 4BA201D9  bl 0x8290a140
	ctx.lr = 0x82EE9F6C;
	sub_8290A140(ctx, base);
	// 82EE9F6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EE9F70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9F74: 4BD96435  bl 0x82c803a8
	ctx.lr = 0x82EE9F78;
	sub_82C803A8(ctx, base);
	// 82EE9F78: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EE9F7C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE9F80: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EE9F84: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EE9F88: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EE9F8C: 80E100A0  lwz r7, 0xa0(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EE9F90: A101009C  lhz r8, 0x9c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EE9F94: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EE9F98: 480004A9  bl 0x82eea440
	ctx.lr = 0x82EE9F9C;
	sub_82EEA440(ctx, base);
	// 82EE9F9C: 4BD95FDD  bl 0x82c7ff78
	ctx.lr = 0x82EE9FA0;
	sub_82C7FF78(ctx, base);
	// 82EE9FA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9FA4: 41820010  beq 0x82ee9fb4
	if ctx.cr[0].eq {
	pc = 0x82EE9FB4; continue 'dispatch;
	}
	// 82EE9FA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE9FAC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EE9FB0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EE9FB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE9FB8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE9FBC: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9FC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9FC4: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9FC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9FCC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9FD0: 4BD91791  bl 0x82c7b760
	ctx.lr = 0x82EE9FD4;
	sub_82C7B760(ctx, base);
	// 82EE9FD4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9FD8: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EE9FDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EE9FE0: 4BD97011  bl 0x82c80ff0
	ctx.lr = 0x82EE9FE4;
	sub_82C80FF0(ctx, base);
	// 82EE9FE4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EE9FE8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EE9FEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE9FF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE9FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9FF8 size=356
    let mut pc: u32 = 0x82EE9FF8;
    'dispatch: loop {
        match pc {
            0x82EE9FF8 => {
    //   block [0x82EE9FF8..0x82EEA15C)
	// 82EE9FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE9FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA000: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA004: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EEA008: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 82EEA00C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA010: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA014: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA018: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA01C: 4BD96C35  bl 0x82c80c50
	ctx.lr = 0x82EEA020;
	sub_82C80C50(ctx, base);
	// 82EEA020: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA024: 4BD95F55  bl 0x82c7ff78
	ctx.lr = 0x82EEA028;
	sub_82C7FF78(ctx, base);
	// 82EEA028: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA02C: 418200EC  beq 0x82eea118
	if ctx.cr[0].eq {
	pc = 0x82EEA118; continue 'dispatch;
	}
	// 82EEA030: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA034: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA038: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA03C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA040: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA044: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA048: 4B792391  bl 0x8267c3d8
	ctx.lr = 0x82EEA04C;
	sub_8267C3D8(ctx, base);
	// 82EEA04C: 4BD96CA5  bl 0x82c80cf0
	ctx.lr = 0x82EEA050;
	sub_82C80CF0(ctx, base);
	// 82EEA050: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EEA054: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA058: 4B7922C9  bl 0x8267c320
	ctx.lr = 0x82EEA05C;
	sub_8267C320(ctx, base);
	// 82EEA05C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA064: 409A0010  bne cr6, 0x82eea074
	if !ctx.cr[6].eq {
	pc = 0x82EEA074; continue 'dispatch;
	}
	// 82EEA068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA06C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEA070: 4800001C  b 0x82eea08c
	pc = 0x82EEA08C; continue 'dispatch;
	// 82EEA074: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA078: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA07C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA080: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA084: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA088: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEA08C: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEA090: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EEA094: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA098: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA09C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA0A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA0A4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA0A8: 4BD95EC9  bl 0x82c7ff70
	ctx.lr = 0x82EEA0AC;
	sub_82C7FF70(ctx, base);
	// 82EEA0AC: B0610090  sth r3, 0x90(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u16 ) };
	// 82EEA0B0: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA0B4: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82EEA0B8: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA0BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA0C0: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA0C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA0C8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA0CC: 4BA20075  bl 0x8290a140
	ctx.lr = 0x82EEA0D0;
	sub_8290A140(ctx, base);
	// 82EEA0D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEA0D4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEA0D8: 4BD962D1  bl 0x82c803a8
	ctx.lr = 0x82EEA0DC;
	sub_82C803A8(ctx, base);
	// 82EEA0DC: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEA0E0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEA0E4: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA0E8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEA0EC: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEA0F0: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEA0F4: A1010090  lhz r8, 0x90(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EEA0F8: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEA0FC: 4BD95E85  bl 0x82c7ff80
	ctx.lr = 0x82EEA100;
	sub_82C7FF80(ctx, base);
	// 82EEA100: 4BD95E79  bl 0x82c7ff78
	ctx.lr = 0x82EEA104;
	sub_82C7FF78(ctx, base);
	// 82EEA104: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA108: 41820010  beq 0x82eea118
	if ctx.cr[0].eq {
	pc = 0x82EEA118; continue 'dispatch;
	}
	// 82EEA10C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA110: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA114: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA118: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA11C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA120: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA124: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA128: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA12C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA130: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA134: 4BD9162D  bl 0x82c7b760
	ctx.lr = 0x82EEA138;
	sub_82C7B760(ctx, base);
	// 82EEA138: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA13C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEA140: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA144: 4BD96EAD  bl 0x82c80ff0
	ctx.lr = 0x82EEA148;
	sub_82C80FF0(ctx, base);
	// 82EEA148: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA14C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EEA150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA160 size=356
    let mut pc: u32 = 0x82EEA160;
    'dispatch: loop {
        match pc {
            0x82EEA160 => {
    //   block [0x82EEA160..0x82EEA2C4)
	// 82EEA160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA168: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA16C: 906100C4  stw r3, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82EEA170: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82EEA174: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA178: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA17C: 808100C4  lwz r4, 0xc4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA180: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA184: 4BD96ACD  bl 0x82c80c50
	ctx.lr = 0x82EEA188;
	sub_82C80C50(ctx, base);
	// 82EEA188: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA18C: 4BD95DED  bl 0x82c7ff78
	ctx.lr = 0x82EEA190;
	sub_82C7FF78(ctx, base);
	// 82EEA190: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA194: 418200EC  beq 0x82eea280
	if ctx.cr[0].eq {
	pc = 0x82EEA280; continue 'dispatch;
	}
	// 82EEA198: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA19C: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA1A4: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA1AC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA1B0: 4B792229  bl 0x8267c3d8
	ctx.lr = 0x82EEA1B4;
	sub_8267C3D8(ctx, base);
	// 82EEA1B4: 4BD96B3D  bl 0x82c80cf0
	ctx.lr = 0x82EEA1B8;
	sub_82C80CF0(ctx, base);
	// 82EEA1B8: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EEA1BC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA1C0: 4B792161  bl 0x8267c320
	ctx.lr = 0x82EEA1C4;
	sub_8267C320(ctx, base);
	// 82EEA1C4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA1CC: 409A0010  bne cr6, 0x82eea1dc
	if !ctx.cr[6].eq {
	pc = 0x82EEA1DC; continue 'dispatch;
	}
	// 82EEA1D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA1D4: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEA1D8: 4800001C  b 0x82eea1f4
	pc = 0x82EEA1F4; continue 'dispatch;
	// 82EEA1DC: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA1E4: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA1EC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA1F0: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEA1F4: E96100C8  ld r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 82EEA1F8: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EEA1FC: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA200: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA204: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA208: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA20C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA210: 4BD95D61  bl 0x82c7ff70
	ctx.lr = 0x82EEA214;
	sub_82C7FF70(ctx, base);
	// 82EEA214: B0610098  sth r3, 0x98(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[3].u16 ) };
	// 82EEA218: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA21C: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EEA220: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA224: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA228: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA22C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA230: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA234: 4BA1FF0D  bl 0x8290a140
	ctx.lr = 0x82EEA238;
	sub_8290A140(ctx, base);
	// 82EEA238: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEA23C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEA240: 4BD96169  bl 0x82c803a8
	ctx.lr = 0x82EEA244;
	sub_82C803A8(ctx, base);
	// 82EEA244: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEA248: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEA24C: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA250: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEA254: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEA258: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEA25C: A1010098  lhz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EEA260: E9210090  ld r9, 0x90(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EEA264: 4800024D  bl 0x82eea4b0
	ctx.lr = 0x82EEA268;
	sub_82EEA4B0(ctx, base);
	// 82EEA268: 4BD95D11  bl 0x82c7ff78
	ctx.lr = 0x82EEA26C;
	sub_82C7FF78(ctx, base);
	// 82EEA26C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA270: 41820010  beq 0x82eea280
	if ctx.cr[0].eq {
	pc = 0x82EEA280; continue 'dispatch;
	}
	// 82EEA274: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA278: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA27C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA280: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA284: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA288: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA28C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA290: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA294: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA298: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA29C: 4BD914C5  bl 0x82c7b760
	ctx.lr = 0x82EEA2A0;
	sub_82C7B760(ctx, base);
	// 82EEA2A0: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA2A4: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEA2A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA2AC: 4BD96D45  bl 0x82c80ff0
	ctx.lr = 0x82EEA2B0;
	sub_82C80FF0(ctx, base);
	// 82EEA2B0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA2B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EEA2B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA2BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA2C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA2C8 size=356
    let mut pc: u32 = 0x82EEA2C8;
    'dispatch: loop {
        match pc {
            0x82EEA2C8 => {
    //   block [0x82EEA2C8..0x82EEA42C)
	// 82EEA2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA2D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA2D4: 906100C4  stw r3, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82EEA2D8: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82EEA2DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA2E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA2E4: 808100C4  lwz r4, 0xc4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA2E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA2EC: 4BD96965  bl 0x82c80c50
	ctx.lr = 0x82EEA2F0;
	sub_82C80C50(ctx, base);
	// 82EEA2F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA2F4: 4BD95C85  bl 0x82c7ff78
	ctx.lr = 0x82EEA2F8;
	sub_82C7FF78(ctx, base);
	// 82EEA2F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA2FC: 418200EC  beq 0x82eea3e8
	if ctx.cr[0].eq {
	pc = 0x82EEA3E8; continue 'dispatch;
	}
	// 82EEA300: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA304: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA308: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA30C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA310: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA314: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA318: 4B7920C1  bl 0x8267c3d8
	ctx.lr = 0x82EEA31C;
	sub_8267C3D8(ctx, base);
	// 82EEA31C: 4BD969D5  bl 0x82c80cf0
	ctx.lr = 0x82EEA320;
	sub_82C80CF0(ctx, base);
	// 82EEA320: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EEA324: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA328: 4B791FF9  bl 0x8267c320
	ctx.lr = 0x82EEA32C;
	sub_8267C320(ctx, base);
	// 82EEA32C: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA334: 409A0010  bne cr6, 0x82eea344
	if !ctx.cr[6].eq {
	pc = 0x82EEA344; continue 'dispatch;
	}
	// 82EEA338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA33C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEA340: 4800001C  b 0x82eea35c
	pc = 0x82EEA35C; continue 'dispatch;
	// 82EEA344: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA348: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA34C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA350: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA354: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA358: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEA35C: E96100C8  ld r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 82EEA360: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EEA364: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA368: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA36C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA370: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA374: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA378: 4BD95BF9  bl 0x82c7ff70
	ctx.lr = 0x82EEA37C;
	sub_82C7FF70(ctx, base);
	// 82EEA37C: B0610098  sth r3, 0x98(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[3].u16 ) };
	// 82EEA380: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA384: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EEA388: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA38C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA390: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA398: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA39C: 4BA1FDA5  bl 0x8290a140
	ctx.lr = 0x82EEA3A0;
	sub_8290A140(ctx, base);
	// 82EEA3A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEA3A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEA3A8: 4BD96001  bl 0x82c803a8
	ctx.lr = 0x82EEA3AC;
	sub_82C803A8(ctx, base);
	// 82EEA3AC: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEA3B0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEA3B4: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA3B8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEA3BC: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEA3C0: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEA3C4: A1010098  lhz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EEA3C8: E9210090  ld r9, 0x90(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EEA3CC: 48000155  bl 0x82eea520
	ctx.lr = 0x82EEA3D0;
	sub_82EEA520(ctx, base);
	// 82EEA3D0: 4BD95BA9  bl 0x82c7ff78
	ctx.lr = 0x82EEA3D4;
	sub_82C7FF78(ctx, base);
	// 82EEA3D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA3D8: 41820010  beq 0x82eea3e8
	if ctx.cr[0].eq {
	pc = 0x82EEA3E8; continue 'dispatch;
	}
	// 82EEA3DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA3E0: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA3E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA3E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA3EC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA3F0: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA3F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA3F8: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA3FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA400: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA404: 4BD9135D  bl 0x82c7b760
	ctx.lr = 0x82EEA408;
	sub_82C7B760(ctx, base);
	// 82EEA408: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA40C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEA410: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA414: 4BD96BDD  bl 0x82c80ff0
	ctx.lr = 0x82EEA418;
	sub_82C80FF0(ctx, base);
	// 82EEA418: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA41C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EEA420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEA430 size=16
    let mut pc: u32 = 0x82EEA430;
    'dispatch: loop {
        match pc {
            0x82EEA430 => {
    //   block [0x82EEA430..0x82EEA440)
	// 82EEA430: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEA434: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEA438: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEA43C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA440 size=112
    let mut pc: u32 = 0x82EEA440;
    'dispatch: loop {
        match pc {
            0x82EEA440 => {
    //   block [0x82EEA440..0x82EEA4B0)
	// 82EEA440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA448: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA44C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA450: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA454: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEA458: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82EEA45C: 90E10094  stw r7, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 82EEA460: B101009E  sth r8, 0x9e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(158 as u32), ctx.r[8].u16 ) };
	// 82EEA464: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 82EEA468: 812100A4  lwz r9, 0xa4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEA46C: A101009E  lhz r8, 0x9e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(158 as u32) ) } as u64;
	// 82EEA470: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEA474: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEA478: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA47C: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA480: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA484: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA488: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA48C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA490: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEA494: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA498: 4E800421  bctrl
	ctx.lr = 0x82EEA49C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA49C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA4A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA4A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA4A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA4AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA4B0 size=112
    let mut pc: u32 = 0x82EEA4B0;
    'dispatch: loop {
        match pc {
            0x82EEA4B0 => {
    //   block [0x82EEA4B0..0x82EEA520)
	// 82EEA4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA4B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA4BC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA4C0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA4C4: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEA4C8: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82EEA4CC: 90E10094  stw r7, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 82EEA4D0: B101009E  sth r8, 0x9e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(158 as u32), ctx.r[8].u16 ) };
	// 82EEA4D4: F92100A0  std r9, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u64 ) };
	// 82EEA4D8: E92100A0  ld r9, 0xa0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EEA4DC: A101009E  lhz r8, 0x9e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(158 as u32) ) } as u64;
	// 82EEA4E0: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEA4E4: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEA4E8: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA4EC: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA4F0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA4F4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA4F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA4FC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA500: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEA504: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA508: 4E800421  bctrl
	ctx.lr = 0x82EEA50C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA50C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA510: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA514: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA518: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA51C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA520 size=112
    let mut pc: u32 = 0x82EEA520;
    'dispatch: loop {
        match pc {
            0x82EEA520 => {
    //   block [0x82EEA520..0x82EEA590)
	// 82EEA520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA528: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA52C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA530: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA534: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEA538: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82EEA53C: 90E10094  stw r7, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 82EEA540: B101009E  sth r8, 0x9e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(158 as u32), ctx.r[8].u16 ) };
	// 82EEA544: F92100A0  std r9, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u64 ) };
	// 82EEA548: E92100A0  ld r9, 0xa0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EEA54C: A101009E  lhz r8, 0x9e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(158 as u32) ) } as u64;
	// 82EEA550: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEA554: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEA558: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA55C: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA560: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA564: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA568: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA56C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA570: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EEA574: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA578: 4E800421  bctrl
	ctx.lr = 0x82EEA57C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA57C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA58C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA590 size=136
    let mut pc: u32 = 0x82EEA590;
    'dispatch: loop {
        match pc {
            0x82EEA590 => {
    //   block [0x82EEA590..0x82EEA618)
	// 82EEA590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA598: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA59C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA5A0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA5A4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEA5A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA5AC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA5B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA5B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA5B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA5BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEA5C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA5C4: 4E800421  bctrl
	ctx.lr = 0x82EEA5C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA5C8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA5CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA5D4: 409A000C  bne cr6, 0x82eea5e0
	if !ctx.cr[6].eq {
	pc = 0x82EEA5E0; continue 'dispatch;
	}
	// 82EEA5D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA5DC: 4800002C  b 0x82eea608
	pc = 0x82EEA608; continue 'dispatch;
	// 82EEA5E0: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA5E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA5E8: 480007E9  bl 0x82eeadd0
	ctx.lr = 0x82EEA5EC;
	sub_82EEADD0(ctx, base);
	// 82EEA5EC: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEA5F0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA5F4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA5F8: 4082000C  bne 0x82eea604
	if !ctx.cr[0].eq {
	pc = 0x82EEA604; continue 'dispatch;
	}
	// 82EEA5FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA600: 48000008  b 0x82eea608
	pc = 0x82EEA608; continue 'dispatch;
	// 82EEA604: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEA608: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA60C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA618 size=136
    let mut pc: u32 = 0x82EEA618;
    'dispatch: loop {
        match pc {
            0x82EEA618 => {
    //   block [0x82EEA618..0x82EEA6A0)
	// 82EEA618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA61C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA620: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA624: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA628: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA62C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEA630: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA634: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA638: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA63C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA640: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA644: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEA648: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA64C: 4E800421  bctrl
	ctx.lr = 0x82EEA650;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA650: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA654: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA65C: 409A000C  bne cr6, 0x82eea668
	if !ctx.cr[6].eq {
	pc = 0x82EEA668; continue 'dispatch;
	}
	// 82EEA660: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA664: 4800002C  b 0x82eea690
	pc = 0x82EEA690; continue 'dispatch;
	// 82EEA668: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA66C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA670: 480008A1  bl 0x82eeaf10
	ctx.lr = 0x82EEA674;
	sub_82EEAF10(ctx, base);
	// 82EEA674: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEA678: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA67C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA680: 4082000C  bne 0x82eea68c
	if !ctx.cr[0].eq {
	pc = 0x82EEA68C; continue 'dispatch;
	}
	// 82EEA684: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA688: 48000008  b 0x82eea690
	pc = 0x82EEA690; continue 'dispatch;
	// 82EEA68C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEA690: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA69C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA6A0 size=136
    let mut pc: u32 = 0x82EEA6A0;
    'dispatch: loop {
        match pc {
            0x82EEA6A0 => {
    //   block [0x82EEA6A0..0x82EEA728)
	// 82EEA6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA6A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA6A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA6AC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA6B0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA6B4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEA6B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA6BC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA6C0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA6C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA6C8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA6CC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEA6D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA6D4: 4E800421  bctrl
	ctx.lr = 0x82EEA6D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA6D8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA6DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA6E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA6E4: 409A000C  bne cr6, 0x82eea6f0
	if !ctx.cr[6].eq {
	pc = 0x82EEA6F0; continue 'dispatch;
	}
	// 82EEA6E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA6EC: 4800002C  b 0x82eea718
	pc = 0x82EEA718; continue 'dispatch;
	// 82EEA6F0: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA6F4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA6F8: 480008B9  bl 0x82eeafb0
	ctx.lr = 0x82EEA6FC;
	sub_82EEAFB0(ctx, base);
	// 82EEA6FC: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEA700: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA704: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA708: 4082000C  bne 0x82eea714
	if !ctx.cr[0].eq {
	pc = 0x82EEA714; continue 'dispatch;
	}
	// 82EEA70C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA710: 48000008  b 0x82eea718
	pc = 0x82EEA718; continue 'dispatch;
	// 82EEA714: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEA718: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA71C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA728 size=136
    let mut pc: u32 = 0x82EEA728;
    'dispatch: loop {
        match pc {
            0x82EEA728 => {
    //   block [0x82EEA728..0x82EEA7B0)
	// 82EEA728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA730: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA734: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA738: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA73C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEA740: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA744: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA748: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA74C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA750: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA754: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEA758: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA75C: 4E800421  bctrl
	ctx.lr = 0x82EEA760;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA760: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA764: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA76C: 409A000C  bne cr6, 0x82eea778
	if !ctx.cr[6].eq {
	pc = 0x82EEA778; continue 'dispatch;
	}
	// 82EEA770: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA774: 4800002C  b 0x82eea7a0
	pc = 0x82EEA7A0; continue 'dispatch;
	// 82EEA778: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA77C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA780: 480006F1  bl 0x82eeae70
	ctx.lr = 0x82EEA784;
	sub_82EEAE70(ctx, base);
	// 82EEA784: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEA788: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA78C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA790: 4082000C  bne 0x82eea79c
	if !ctx.cr[0].eq {
	pc = 0x82EEA79C; continue 'dispatch;
	}
	// 82EEA794: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA798: 48000008  b 0x82eea7a0
	pc = 0x82EEA7A0; continue 'dispatch;
	// 82EEA79C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEA7A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA7A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA7A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA7AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA7B0 size=836
    let mut pc: u32 = 0x82EEA7B0;
    'dispatch: loop {
        match pc {
            0x82EEA7B0 => {
    //   block [0x82EEA7B0..0x82EEAAF4)
	// 82EEA7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA7B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEA7BC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA7C0: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EEA7C4: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 82EEA7C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA7CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA7D0: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEA7D4: 4811E52D  bl 0x83008d00
	ctx.lr = 0x82EEA7D8;
	sub_83008D00(ctx, base);
	// 82EEA7D8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA7DC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA7E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA7E4: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA7E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA7EC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA7F0: 4BA23521  bl 0x8290dd10
	ctx.lr = 0x82EEA7F4;
	sub_8290DD10(ctx, base);
	// 82EEA7F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA7F8: 40810050  ble 0x82eea848
	if !ctx.cr[0].gt {
	pc = 0x82EEA848; continue 'dispatch;
	}
	// 82EEA7FC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA800: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA804: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA808: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA80C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA810: 4BA23501  bl 0x8290dd10
	ctx.lr = 0x82EEA814;
	sub_8290DD10(ctx, base);
	// 82EEA814: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA818: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EEA81C: 4099002C  ble cr6, 0x82eea848
	if !ctx.cr[6].gt {
	pc = 0x82EEA848; continue 'dispatch;
	}
	// 82EEA820: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA824: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA828: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA82C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA830: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA834: 4BA234DD  bl 0x8290dd10
	ctx.lr = 0x82EEA838;
	sub_8290DD10(ctx, base);
	// 82EEA838: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA83C: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82EEA840: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EEA844: 4800000C  b 0x82eea850
	pc = 0x82EEA850; continue 'dispatch;
	// 82EEA848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA84C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EEA850: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EEA854: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEA858: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA85C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEA860: 4BD963F1  bl 0x82c80c50
	ctx.lr = 0x82EEA864;
	sub_82C80C50(ctx, base);
	// 82EEA864: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEA868: 4BD95711  bl 0x82c7ff78
	ctx.lr = 0x82EEA86C;
	sub_82C7FF78(ctx, base);
	// 82EEA86C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA870: 40820014  bne 0x82eea884
	if !ctx.cr[0].eq {
	pc = 0x82EEA884; continue 'dispatch;
	}
	// 82EEA874: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA878: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA87C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA880: 4800022C  b 0x82eeaaac
	pc = 0x82EEAAAC; continue 'dispatch;
	// 82EEA884: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EEA888: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA88C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA890: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA898: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA89C: 4B791B3D  bl 0x8267c3d8
	ctx.lr = 0x82EEA8A0;
	sub_8267C3D8(ctx, base);
	// 82EEA8A0: 4BD90131  bl 0x82c7a9d0
	ctx.lr = 0x82EEA8A4;
	sub_82C7A9D0(ctx, base);
	// 82EEA8A4: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EEA8A8: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EEA8AC: 4B791A75  bl 0x8267c320
	ctx.lr = 0x82EEA8B0;
	sub_8267C320(ctx, base);
	// 82EEA8B0: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA8B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA8B8: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA8BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA8C0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA8C4: 482D179D  bl 0x831bc060
	ctx.lr = 0x82EEA8C8;
	sub_831BC060(ctx, base);
	// 82EEA8C8: 546B05F2  rlwinm r11, r3, 0, 0x17, 0x19
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82EEA8CC: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82EEA8D0: 419A0090  beq cr6, 0x82eea960
	if ctx.cr[6].eq {
	pc = 0x82EEA960; continue 'dispatch;
	}
	// 82EEA8D4: 48000010  b 0x82eea8e4
	pc = 0x82EEA8E4; continue 'dispatch;
	// 82EEA8D8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEA8DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEA8E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEA8E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEA8E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA8EC: 40990074  ble cr6, 0x82eea960
	if !ctx.cr[6].gt {
	pc = 0x82EEA960; continue 'dispatch;
	}
	// 82EEA8F0: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA8F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA8F8: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA8FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA900: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA904: 4BD9566D  bl 0x82c7ff70
	ctx.lr = 0x82EEA908;
	sub_82C7FF70(ctx, base);
	// 82EEA908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEA90C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA910: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA914: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA918: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA91C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA920: 4BA1F821  bl 0x8290a140
	ctx.lr = 0x82EEA924;
	sub_8290A140(ctx, base);
	// 82EEA924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEA928: 4BD95A19  bl 0x82c80340
	ctx.lr = 0x82EEA92C;
	sub_82C80340(ctx, base);
	// 82EEA92C: B0610070  sth r3, 0x70(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u16 ) };
	// 82EEA930: 4BEC7291  bl 0x82db1bc0
	ctx.lr = 0x82EEA934;
	sub_82DB1BC0(ctx, base);
	// 82EEA934: B0610072  sth r3, 0x72(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[3].u16 ) };
	// 82EEA938: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EEA93C: 38610072  addi r3, r1, 0x72
	ctx.r[3].s64 = ctx.r[1].s64 + 114;
	// 82EEA940: 4BD8E681  bl 0x82c78fc0
	ctx.lr = 0x82EEA944;
	sub_82C78FC0(ctx, base);
	// 82EEA944: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA948: 41820014  beq 0x82eea95c
	if ctx.cr[0].eq {
	pc = 0x82EEA95C; continue 'dispatch;
	}
	// 82EEA94C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA950: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA954: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA958: 48000008  b 0x82eea960
	pc = 0x82EEA960; continue 'dispatch;
	// 82EEA95C: 4BFFFF7C  b 0x82eea8d8
	pc = 0x82EEA8D8; continue 'dispatch;
	// 82EEA960: 4800001C  b 0x82eea97c
	pc = 0x82EEA97C; continue 'dispatch;
	// 82EEA964: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA968: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEA96C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEA970: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEA974: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EEA978: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82EEA97C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA980: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA984: 409A0074  bne cr6, 0x82eea9f8
	if !ctx.cr[6].eq {
	pc = 0x82EEA9F8; continue 'dispatch;
	}
	// 82EEA988: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA98C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA990: 40990068  ble cr6, 0x82eea9f8
	if !ctx.cr[6].gt {
	pc = 0x82EEA9F8; continue 'dispatch;
	}
	// 82EEA994: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEA998: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA99C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EEA9A0: 4BD8E639  bl 0x82c78fd8
	ctx.lr = 0x82EEA9A4;
	sub_82C78FD8(ctx, base);
	// 82EEA9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEA9A8: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA9AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA9B0: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA9B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA9B8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA9BC: 4BA1F785  bl 0x8290a140
	ctx.lr = 0x82EEA9C0;
	sub_8290A140(ctx, base);
	// 82EEA9C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEA9C4: 4BD9597D  bl 0x82c80340
	ctx.lr = 0x82EEA9C8;
	sub_82C80340(ctx, base);
	// 82EEA9C8: B0610074  sth r3, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u16 ) };
	// 82EEA9CC: 4BEC71F5  bl 0x82db1bc0
	ctx.lr = 0x82EEA9D0;
	sub_82DB1BC0(ctx, base);
	// 82EEA9D0: B0610076  sth r3, 0x76(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[3].u16 ) };
	// 82EEA9D4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82EEA9D8: 38610076  addi r3, r1, 0x76
	ctx.r[3].s64 = ctx.r[1].s64 + 118;
	// 82EEA9DC: 4BD8E5E5  bl 0x82c78fc0
	ctx.lr = 0x82EEA9E0;
	sub_82C78FC0(ctx, base);
	// 82EEA9E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA9E4: 41820010  beq 0x82eea9f4
	if ctx.cr[0].eq {
	pc = 0x82EEA9F4; continue 'dispatch;
	}
	// 82EEA9E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA9EC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA9F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA9F4: 4BFFFF70  b 0x82eea964
	pc = 0x82EEA964; continue 'dispatch;
	// 82EEA9F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA9FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAA00: 409A0090  bne cr6, 0x82eeaa90
	if !ctx.cr[6].eq {
	pc = 0x82EEAA90; continue 'dispatch;
	}
	// 82EEAA04: 48000010  b 0x82eeaa14
	pc = 0x82EEAA14; continue 'dispatch;
	// 82EEAA08: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEAA0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEAA10: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEAA14: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEAA18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAA1C: 40990074  ble cr6, 0x82eeaa90
	if !ctx.cr[6].gt {
	pc = 0x82EEAA90; continue 'dispatch;
	}
	// 82EEAA20: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAA28: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAA30: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAA34: 4BD9553D  bl 0x82c7ff70
	ctx.lr = 0x82EEAA38;
	sub_82C7FF70(ctx, base);
	// 82EEAA38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEAA3C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA40: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAA44: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAA4C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAA50: 4BA1F6F1  bl 0x8290a140
	ctx.lr = 0x82EEAA54;
	sub_8290A140(ctx, base);
	// 82EEAA54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEAA58: 4BD958E9  bl 0x82c80340
	ctx.lr = 0x82EEAA5C;
	sub_82C80340(ctx, base);
	// 82EEAA5C: B0610078  sth r3, 0x78(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u16 ) };
	// 82EEAA60: 4BEC7161  bl 0x82db1bc0
	ctx.lr = 0x82EEAA64;
	sub_82DB1BC0(ctx, base);
	// 82EEAA64: B061007A  sth r3, 0x7a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[3].u16 ) };
	// 82EEAA68: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82EEAA6C: 3861007A  addi r3, r1, 0x7a
	ctx.r[3].s64 = ctx.r[1].s64 + 122;
	// 82EEAA70: 4BD8E551  bl 0x82c78fc0
	ctx.lr = 0x82EEAA74;
	sub_82C78FC0(ctx, base);
	// 82EEAA74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAA78: 41820014  beq 0x82eeaa8c
	if ctx.cr[0].eq {
	pc = 0x82EEAA8C; continue 'dispatch;
	}
	// 82EEAA7C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAA80: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEAA84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAA88: 48000008  b 0x82eeaa90
	pc = 0x82EEAA90; continue 'dispatch;
	// 82EEAA8C: 4BFFFF7C  b 0x82eeaa08
	pc = 0x82EEAA08; continue 'dispatch;
	// 82EEAA90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEAA94: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA98: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAA9C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAAA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAAA4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAAA8: 4B7916F9  bl 0x8267c1a0
	ctx.lr = 0x82EEAAAC;
	sub_8267C1A0(ctx, base);
	// 82EEAAAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEAAB0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAAB4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAAB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAABC: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAAC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAAC4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAAC8: 4BD90C99  bl 0x82c7b760
	ctx.lr = 0x82EEAACC;
	sub_82C7B760(ctx, base);
	// 82EEAACC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAAD0: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEAAD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEAAD8: 4BD96519  bl 0x82c80ff0
	ctx.lr = 0x82EEAADC;
	sub_82C80FF0(ctx, base);
	// 82EEAADC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEAAE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EEAAE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEAAE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEAAEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEAAF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEAAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEAAF8 size=724
    let mut pc: u32 = 0x82EEAAF8;
    'dispatch: loop {
        match pc {
            0x82EEAAF8 => {
    //   block [0x82EEAAF8..0x82EEADCC)
	// 82EEAAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEAAFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEAB00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEAB04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEAB08: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEAB0C: 988100AF  stb r4, 0xaf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(175 as u32), ctx.r[4].u8 ) };
	// 82EEAB10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAB14: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAB18: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEAB20: 4BD96131  bl 0x82c80c50
	ctx.lr = 0x82EEAB24;
	sub_82C80C50(ctx, base);
	// 82EEAB24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEAB28: 4BD95451  bl 0x82c7ff78
	ctx.lr = 0x82EEAB2C;
	sub_82C7FF78(ctx, base);
	// 82EEAB2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAB30: 41820238  beq 0x82eead68
	if ctx.cr[0].eq {
	pc = 0x82EEAD68; continue 'dispatch;
	}
	// 82EEAB34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEAB38: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAB40: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAB48: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAB4C: 4B79188D  bl 0x8267c3d8
	ctx.lr = 0x82EEAB50;
	sub_8267C3D8(ctx, base);
	// 82EEAB50: 4BD8FE81  bl 0x82c7a9d0
	ctx.lr = 0x82EEAB54;
	sub_82C7A9D0(ctx, base);
	// 82EEAB54: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EEAB58: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEAB5C: 4B7917C5  bl 0x8267c320
	ctx.lr = 0x82EEAB60;
	sub_8267C320(ctx, base);
	// 82EEAB60: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAB68: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAB70: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAB74: 4BA2319D  bl 0x8290dd10
	ctx.lr = 0x82EEAB78;
	sub_8290DD10(ctx, base);
	// 82EEAB78: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82EEAB7C: 41990010  bgt cr6, 0x82eeab8c
	if ctx.cr[6].gt {
	pc = 0x82EEAB8C; continue 'dispatch;
	}
	// 82EEAB80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAB84: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEAB88: 48000024  b 0x82eeabac
	pc = 0x82EEABAC; continue 'dispatch;
	// 82EEAB8C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAB94: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAB9C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEABA0: 4BA23171  bl 0x8290dd10
	ctx.lr = 0x82EEABA4;
	sub_8290DD10(ctx, base);
	// 82EEABA4: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 82EEABA8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEABAC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEABB0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEABB4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEABB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEABBC: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEABC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEABC4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEABC8: 482D1499  bl 0x831bc060
	ctx.lr = 0x82EEABCC;
	sub_831BC060(ctx, base);
	// 82EEABCC: 546B05F2  rlwinm r11, r3, 0, 0x17, 0x19
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82EEABD0: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82EEABD4: 419A0098  beq cr6, 0x82eeac6c
	if ctx.cr[6].eq {
	pc = 0x82EEAC6C; continue 'dispatch;
	}
	// 82EEABD8: 48000010  b 0x82eeabe8
	pc = 0x82EEABE8; continue 'dispatch;
	// 82EEABDC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEABE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEABE4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEABE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEABEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEABF0: 409A007C  bne cr6, 0x82eeac6c
	if !ctx.cr[6].eq {
	pc = 0x82EEAC6C; continue 'dispatch;
	}
	// 82EEABF4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEABF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEABFC: 40990070  ble cr6, 0x82eeac6c
	if !ctx.cr[6].gt {
	pc = 0x82EEAC6C; continue 'dispatch;
	}
	// 82EEAC00: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAC08: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAC10: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAC14: 4BD9535D  bl 0x82c7ff70
	ctx.lr = 0x82EEAC18;
	sub_82C7FF70(ctx, base);
	// 82EEAC18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEAC1C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC20: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAC24: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAC2C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAC30: 4BA1F511  bl 0x8290a140
	ctx.lr = 0x82EEAC34;
	sub_8290A140(ctx, base);
	// 82EEAC34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEAC38: 4BD95709  bl 0x82c80340
	ctx.lr = 0x82EEAC3C;
	sub_82C80340(ctx, base);
	// 82EEAC3C: B061006C  sth r3, 0x6c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u16 ) };
	// 82EEAC40: 4BEC6F81  bl 0x82db1bc0
	ctx.lr = 0x82EEAC44;
	sub_82DB1BC0(ctx, base);
	// 82EEAC44: B061006E  sth r3, 0x6e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(110 as u32), ctx.r[3].u16 ) };
	// 82EEAC48: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82EEAC4C: 3861006E  addi r3, r1, 0x6e
	ctx.r[3].s64 = ctx.r[1].s64 + 110;
	// 82EEAC50: 4BD8E371  bl 0x82c78fc0
	ctx.lr = 0x82EEAC54;
	sub_82C78FC0(ctx, base);
	// 82EEAC54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAC58: 41820010  beq 0x82eeac68
	if ctx.cr[0].eq {
	pc = 0x82EEAC68; continue 'dispatch;
	}
	// 82EEAC5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAC60: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEAC64: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAC68: 4BFFFF74  b 0x82eeabdc
	pc = 0x82EEABDC; continue 'dispatch;
	// 82EEAC6C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAC70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAC74: 409A0060  bne cr6, 0x82eeacd4
	if !ctx.cr[6].eq {
	pc = 0x82EEACD4; continue 'dispatch;
	}
	// 82EEAC78: 888100AF  lbz r4, 0xaf(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(175 as u32) ) } as u64;
	// 82EEAC7C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEAC80: 4BD8E359  bl 0x82c78fd8
	ctx.lr = 0x82EEAC84;
	sub_82C78FD8(ctx, base);
	// 82EEAC84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEAC88: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAC90: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAC98: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAC9C: 4BA1F4A5  bl 0x8290a140
	ctx.lr = 0x82EEACA0;
	sub_8290A140(ctx, base);
	// 82EEACA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEACA4: 4BD9569D  bl 0x82c80340
	ctx.lr = 0x82EEACA8;
	sub_82C80340(ctx, base);
	// 82EEACA8: B0610070  sth r3, 0x70(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u16 ) };
	// 82EEACAC: 4BEC6F15  bl 0x82db1bc0
	ctx.lr = 0x82EEACB0;
	sub_82DB1BC0(ctx, base);
	// 82EEACB0: B0610072  sth r3, 0x72(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[3].u16 ) };
	// 82EEACB4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EEACB8: 38610072  addi r3, r1, 0x72
	ctx.r[3].s64 = ctx.r[1].s64 + 114;
	// 82EEACBC: 4BD8E305  bl 0x82c78fc0
	ctx.lr = 0x82EEACC0;
	sub_82C78FC0(ctx, base);
	// 82EEACC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEACC4: 41820010  beq 0x82eeacd4
	if ctx.cr[0].eq {
	pc = 0x82EEACD4; continue 'dispatch;
	}
	// 82EEACC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEACCC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEACD0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEACD4: 48000010  b 0x82eeace4
	pc = 0x82EEACE4; continue 'dispatch;
	// 82EEACD8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEACDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEACE0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEACE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEACE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEACEC: 409A007C  bne cr6, 0x82eead68
	if !ctx.cr[6].eq {
	pc = 0x82EEAD68; continue 'dispatch;
	}
	// 82EEACF0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEACF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEACF8: 40990070  ble cr6, 0x82eead68
	if !ctx.cr[6].gt {
	pc = 0x82EEAD68; continue 'dispatch;
	}
	// 82EEACFC: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD00: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAD04: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAD0C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAD10: 4BD95261  bl 0x82c7ff70
	ctx.lr = 0x82EEAD14;
	sub_82C7FF70(ctx, base);
	// 82EEAD14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEAD18: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAD20: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAD28: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAD2C: 4BA1F415  bl 0x8290a140
	ctx.lr = 0x82EEAD30;
	sub_8290A140(ctx, base);
	// 82EEAD30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEAD34: 4BD9560D  bl 0x82c80340
	ctx.lr = 0x82EEAD38;
	sub_82C80340(ctx, base);
	// 82EEAD38: B0610074  sth r3, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u16 ) };
	// 82EEAD3C: 4BEC6E85  bl 0x82db1bc0
	ctx.lr = 0x82EEAD40;
	sub_82DB1BC0(ctx, base);
	// 82EEAD40: B0610076  sth r3, 0x76(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[3].u16 ) };
	// 82EEAD44: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82EEAD48: 38610076  addi r3, r1, 0x76
	ctx.r[3].s64 = ctx.r[1].s64 + 118;
	// 82EEAD4C: 4BD8E275  bl 0x82c78fc0
	ctx.lr = 0x82EEAD50;
	sub_82C78FC0(ctx, base);
	// 82EEAD50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAD54: 41820010  beq 0x82eead64
	if ctx.cr[0].eq {
	pc = 0x82EEAD64; continue 'dispatch;
	}
	// 82EEAD58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAD5C: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEAD60: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAD64: 4BFFFF74  b 0x82eeacd8
	pc = 0x82EEACD8; continue 'dispatch;
	// 82EEAD68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEAD6C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAD74: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAD7C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAD80: 4B791421  bl 0x8267c1a0
	ctx.lr = 0x82EEAD84;
	sub_8267C1A0(ctx, base);
	// 82EEAD84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEAD88: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAD8C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAD94: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAD9C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEADA0: 4BD909C1  bl 0x82c7b760
	ctx.lr = 0x82EEADA4;
	sub_82C7B760(ctx, base);
	// 82EEADA4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEADA8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EEADAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEADB0: 4BD96241  bl 0x82c80ff0
	ctx.lr = 0x82EEADB4;
	sub_82C80FF0(ctx, base);
	// 82EEADB4: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EEADB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEADBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEADC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEADC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEADC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEADD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEADD0 size=160
    let mut pc: u32 = 0x82EEADD0;
    'dispatch: loop {
        match pc {
            0x82EEADD0 => {
    //   block [0x82EEADD0..0x82EEAE70)
	// 82EEADD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEADD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEADD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEADDC: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEADE0: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEADE4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEADE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEADEC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEADF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEADF4: 409A0010  bne cr6, 0x82eeae04
	if !ctx.cr[6].eq {
	pc = 0x82EEAE04; continue 'dispatch;
	}
	// 82EEADF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEADFC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82EEAE00: 48000018  b 0x82eeae18
	pc = 0x82EEAE18; continue 'dispatch;
	// 82EEAE04: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82EEAE08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEAE0C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAE10: 4811E249  bl 0x83009058
	ctx.lr = 0x82EEAE14;
	sub_83009058(ctx, base);
	// 82EEAE14: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82EEAE18: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82EEAE1C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEAE20: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82EEAE24: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAE28: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAE2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEAE30: 419A0020  beq cr6, 0x82eeae50
	if ctx.cr[6].eq {
	pc = 0x82EEAE50; continue 'dispatch;
	}
	// 82EEAE34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAE38: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAE3C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEAE40: 40820010  bne 0x82eeae50
	if !ctx.cr[0].eq {
	pc = 0x82EEAE50; continue 'dispatch;
	}
	// 82EEAE44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEAE48: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEAE4C: 4800000C  b 0x82eeae58
	pc = 0x82EEAE58; continue 'dispatch;
	// 82EEAE50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAE54: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEAE58: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEAE5C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEAE60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEAE64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEAE68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEAE6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEAE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEAE70 size=160
    let mut pc: u32 = 0x82EEAE70;
    'dispatch: loop {
        match pc {
            0x82EEAE70 => {
    //   block [0x82EEAE70..0x82EEAF10)
	// 82EEAE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEAE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEAE78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEAE7C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEAE80: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEAE84: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAE88: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAE8C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAE90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEAE94: 409A0010  bne cr6, 0x82eeaea4
	if !ctx.cr[6].eq {
	pc = 0x82EEAEA4; continue 'dispatch;
	}
	// 82EEAE98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAE9C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEAEA0: 48000018  b 0x82eeaeb8
	pc = 0x82EEAEB8; continue 'dispatch;
	// 82EEAEA4: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82EEAEA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEAEAC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAEB0: 4BDC2131  bl 0x82cacfe0
	ctx.lr = 0x82EEAEB4;
	sub_82CACFE0(ctx, base);
	// 82EEAEB4: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEAEB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEAEBC: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEAEC0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEAEC4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAEC8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAECC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEAED0: 419A0020  beq cr6, 0x82eeaef0
	if ctx.cr[6].eq {
	pc = 0x82EEAEF0; continue 'dispatch;
	}
	// 82EEAED4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAED8: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAEDC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEAEE0: 40820010  bne 0x82eeaef0
	if !ctx.cr[0].eq {
	pc = 0x82EEAEF0; continue 'dispatch;
	}
	// 82EEAEE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEAEE8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEAEEC: 4800000C  b 0x82eeaef8
	pc = 0x82EEAEF8; continue 'dispatch;
	// 82EEAEF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAEF4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEAEF8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEAEFC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEAF00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEAF04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEAF08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEAF0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEAF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEAF10 size=160
    let mut pc: u32 = 0x82EEAF10;
    'dispatch: loop {
        match pc {
            0x82EEAF10 => {
    //   block [0x82EEAF10..0x82EEAFB0)
	// 82EEAF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEAF14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEAF18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEAF1C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEAF20: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEAF24: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAF28: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAF2C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAF30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEAF34: 409A0010  bne cr6, 0x82eeaf44
	if !ctx.cr[6].eq {
	pc = 0x82EEAF44; continue 'dispatch;
	}
	// 82EEAF38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAF3C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82EEAF40: 48000018  b 0x82eeaf58
	pc = 0x82EEAF58; continue 'dispatch;
	// 82EEAF44: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82EEAF48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEAF4C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAF50: 4811E129  bl 0x83009078
	ctx.lr = 0x82EEAF54;
	sub_83009078(ctx, base);
	// 82EEAF54: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82EEAF58: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82EEAF5C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEAF60: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82EEAF64: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAF68: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAF6C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEAF70: 419A0020  beq cr6, 0x82eeaf90
	if ctx.cr[6].eq {
	pc = 0x82EEAF90; continue 'dispatch;
	}
	// 82EEAF74: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAF78: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAF7C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEAF80: 40820010  bne 0x82eeaf90
	if !ctx.cr[0].eq {
	pc = 0x82EEAF90; continue 'dispatch;
	}
	// 82EEAF84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEAF88: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEAF8C: 4800000C  b 0x82eeaf98
	pc = 0x82EEAF98; continue 'dispatch;
	// 82EEAF90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAF94: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEAF98: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEAF9C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEAFA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEAFA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEAFA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEAFAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEAFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEAFB0 size=152
    let mut pc: u32 = 0x82EEAFB0;
    'dispatch: loop {
        match pc {
            0x82EEAFB0 => {
    //   block [0x82EEAFB0..0x82EEB048)
	// 82EEAFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEAFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEAFB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEAFBC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEAFC0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEAFC4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEAFC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEAFCC: 419A0068  beq cr6, 0x82eeb034
	if ctx.cr[6].eq {
	pc = 0x82EEB034; continue 'dispatch;
	}
	// 82EEAFD0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEAFD4: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAFD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEAFDC: 386BC17C  addi r3, r11, -0x3e84
	ctx.r[3].s64 = ctx.r[11].s64 + -16004;
	// 82EEAFE0: 4BDC1D21  bl 0x82cacd00
	ctx.lr = 0x82EEAFE4;
	sub_82CACD00(ctx, base);
	// 82EEAFE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EEAFE8: 4182001C  beq 0x82eeb004
	if ctx.cr[0].eq {
	pc = 0x82EEB004; continue 'dispatch;
	}
	// 82EEAFEC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEAFF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEAFF4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEAFF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEAFFC: 4800003C  b 0x82eeb038
	pc = 0x82EEB038; continue 'dispatch;
	// 82EEB000: 48000034  b 0x82eeb034
	pc = 0x82EEB034; continue 'dispatch;
	// 82EEB004: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB008: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB00C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB010: 386BC170  addi r3, r11, -0x3e90
	ctx.r[3].s64 = ctx.r[11].s64 + -16016;
	// 82EEB014: 4BDC1CED  bl 0x82cacd00
	ctx.lr = 0x82EEB018;
	sub_82CACD00(ctx, base);
	// 82EEB018: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EEB01C: 41820018  beq 0x82eeb034
	if ctx.cr[0].eq {
	pc = 0x82EEB034; continue 'dispatch;
	}
	// 82EEB020: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB024: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEB028: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEB02C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEB030: 48000008  b 0x82eeb038
	pc = 0x82EEB038; continue 'dispatch;
	// 82EEB034: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEB038: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB03C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB040: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB048 size=284
    let mut pc: u32 = 0x82EEB048;
    'dispatch: loop {
        match pc {
            0x82EEB048 => {
    //   block [0x82EEB048..0x82EEB164)
	// 82EEB048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEB054: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82EEB058: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 82EEB05C: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 82EEB060: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 82EEB064: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 82EEB068: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB06C: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEB070: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EEB074: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEB078: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB07C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB080: 409A004C  bne cr6, 0x82eeb0cc
	if !ctx.cr[6].eq {
	pc = 0x82EEB0CC; continue 'dispatch;
	}
	// 82EEB084: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB088: 896B8F4D  lbz r11, -0x70b3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28851 as u32) ) } as u64;
	// 82EEB08C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB090: 4082003C  bne 0x82eeb0cc
	if !ctx.cr[0].eq {
	pc = 0x82EEB0CC; continue 'dispatch;
	}
	// 82EEB094: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB098: 3BEB8F4D  addi r31, r11, -0x70b3
	ctx.r[31].s64 = ctx.r[11].s64 + -28851;
	// 82EEB09C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB0A0: 38CBC1FC  addi r6, r11, -0x3e04
	ctx.r[6].s64 = ctx.r[11].s64 + -15876;
	// 82EEB0A4: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 82EEB0A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB0AC: 388BC198  addi r4, r11, -0x3e68
	ctx.r[4].s64 = ctx.r[11].s64 + -15976;
	// 82EEB0B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEB0B4: 480000B5  bl 0x82eeb168
	ctx.lr = 0x82EEB0B8;
	sub_82EEB168(ctx, base);
	// 82EEB0B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEB0BC: 48206CFD  bl 0x830f1db8
	ctx.lr = 0x82EEB0C0;
	sub_830F1DB8(ctx, base);
	// 82EEB0C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB0C4: 40820008  bne 0x82eeb0cc
	if !ctx.cr[0].eq {
	pc = 0x82EEB0CC; continue 'dispatch;
	}
	// 82EEB0C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEB0CC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEB0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB0D4: 409A004C  bne cr6, 0x82eeb120
	if !ctx.cr[6].eq {
	pc = 0x82EEB120; continue 'dispatch;
	}
	// 82EEB0D8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB0DC: 896B8F4C  lbz r11, -0x70b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28852 as u32) ) } as u64;
	// 82EEB0E0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB0E4: 4082003C  bne 0x82eeb120
	if !ctx.cr[0].eq {
	pc = 0x82EEB120; continue 'dispatch;
	}
	// 82EEB0E8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB0EC: 3BEB8F4C  addi r31, r11, -0x70b4
	ctx.r[31].s64 = ctx.r[11].s64 + -28852;
	// 82EEB0F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB0F4: 38CBC188  addi r6, r11, -0x3e78
	ctx.r[6].s64 = ctx.r[11].s64 + -15992;
	// 82EEB0F8: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 82EEB0FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB100: 388BC198  addi r4, r11, -0x3e68
	ctx.r[4].s64 = ctx.r[11].s64 + -15976;
	// 82EEB104: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEB108: 48000061  bl 0x82eeb168
	ctx.lr = 0x82EEB10C;
	sub_82EEB168(ctx, base);
	// 82EEB10C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEB110: 48206CA9  bl 0x830f1db8
	ctx.lr = 0x82EEB114;
	sub_830F1DB8(ctx, base);
	// 82EEB114: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB118: 40820008  bne 0x82eeb120
	if !ctx.cr[0].eq {
	pc = 0x82EEB120; continue 'dispatch;
	}
	// 82EEB11C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEB120: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEB124: 394100B8  addi r10, r1, 0xb8
	ctx.r[10].s64 = ctx.r[1].s64 + 184;
	// 82EEB128: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEB12C: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB130: 80A100B4  lwz r5, 0xb4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEB134: 808100AC  lwz r4, 0xac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EEB138: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB13C: 4BDC148D  bl 0x82cac5c8
	ctx.lr = 0x82EEB140;
	sub_82CAC5C8(ctx, base);
	// 82EEB140: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEB144: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB148: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB14C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEB150: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEB154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB15C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEB160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB168 size=76
    let mut pc: u32 = 0x82EEB168;
    'dispatch: loop {
        match pc {
            0x82EEB168 => {
    //   block [0x82EEB168..0x82EEB1B4)
	// 82EEB168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB16C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB170: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB174: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB178: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB17C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEB180: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEB184: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEB188: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB18C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB190: 48000029  bl 0x82eeb1b8
	ctx.lr = 0x82EEB194;
	sub_82EEB1B8(ctx, base);
	// 82EEB194: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB198: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEB19C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEB1A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB1A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB1B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEB1B8 size=44
    let mut pc: u32 = 0x82EEB1B8;
    'dispatch: loop {
        match pc {
            0x82EEB1B8 => {
    //   block [0x82EEB1B8..0x82EEB1E4)
	// 82EEB1B8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEB1BC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEB1C0: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EEB1C4: 81610024  lwz r11, 0x24(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EEB1C8: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB1CC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEB1D0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB1D4: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEB1D8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEB1DC: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB1E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB1E8 size=284
    let mut pc: u32 = 0x82EEB1E8;
    'dispatch: loop {
        match pc {
            0x82EEB1E8 => {
    //   block [0x82EEB1E8..0x82EEB304)
	// 82EEB1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB1EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB1F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEB1F4: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82EEB1F8: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 82EEB1FC: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 82EEB200: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 82EEB204: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 82EEB208: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB20C: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEB210: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EEB214: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEB218: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB220: 409A004C  bne cr6, 0x82eeb26c
	if !ctx.cr[6].eq {
	pc = 0x82EEB26C; continue 'dispatch;
	}
	// 82EEB224: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB228: 896B8F4F  lbz r11, -0x70b1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28849 as u32) ) } as u64;
	// 82EEB22C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB230: 4082003C  bne 0x82eeb26c
	if !ctx.cr[0].eq {
	pc = 0x82EEB26C; continue 'dispatch;
	}
	// 82EEB234: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB238: 3BEB8F4F  addi r31, r11, -0x70b1
	ctx.r[31].s64 = ctx.r[11].s64 + -28849;
	// 82EEB23C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB240: 38CBC1FC  addi r6, r11, -0x3e04
	ctx.r[6].s64 = ctx.r[11].s64 + -15876;
	// 82EEB244: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 82EEB248: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB24C: 388BC198  addi r4, r11, -0x3e68
	ctx.r[4].s64 = ctx.r[11].s64 + -15976;
	// 82EEB250: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEB254: 4BFFFF15  bl 0x82eeb168
	ctx.lr = 0x82EEB258;
	sub_82EEB168(ctx, base);
	// 82EEB258: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEB25C: 48206B5D  bl 0x830f1db8
	ctx.lr = 0x82EEB260;
	sub_830F1DB8(ctx, base);
	// 82EEB260: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB264: 40820008  bne 0x82eeb26c
	if !ctx.cr[0].eq {
	pc = 0x82EEB26C; continue 'dispatch;
	}
	// 82EEB268: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEB26C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEB270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB274: 409A004C  bne cr6, 0x82eeb2c0
	if !ctx.cr[6].eq {
	pc = 0x82EEB2C0; continue 'dispatch;
	}
	// 82EEB278: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB27C: 896B8F4E  lbz r11, -0x70b2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28850 as u32) ) } as u64;
	// 82EEB280: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB284: 4082003C  bne 0x82eeb2c0
	if !ctx.cr[0].eq {
	pc = 0x82EEB2C0; continue 'dispatch;
	}
	// 82EEB288: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB28C: 3BEB8F4E  addi r31, r11, -0x70b2
	ctx.r[31].s64 = ctx.r[11].s64 + -28850;
	// 82EEB290: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB294: 38CBC188  addi r6, r11, -0x3e78
	ctx.r[6].s64 = ctx.r[11].s64 + -15992;
	// 82EEB298: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 82EEB29C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB2A0: 388BC198  addi r4, r11, -0x3e68
	ctx.r[4].s64 = ctx.r[11].s64 + -15976;
	// 82EEB2A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEB2A8: 4BFFFEC1  bl 0x82eeb168
	ctx.lr = 0x82EEB2AC;
	sub_82EEB168(ctx, base);
	// 82EEB2AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEB2B0: 48206B09  bl 0x830f1db8
	ctx.lr = 0x82EEB2B4;
	sub_830F1DB8(ctx, base);
	// 82EEB2B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB2B8: 40820008  bne 0x82eeb2c0
	if !ctx.cr[0].eq {
	pc = 0x82EEB2C0; continue 'dispatch;
	}
	// 82EEB2BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEB2C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEB2C4: 394100B8  addi r10, r1, 0xb8
	ctx.r[10].s64 = ctx.r[1].s64 + 184;
	// 82EEB2C8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEB2CC: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB2D0: 80A100B4  lwz r5, 0xb4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEB2D4: 808100AC  lwz r4, 0xac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EEB2D8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB2DC: 4BDC25A5  bl 0x82cad880
	ctx.lr = 0x82EEB2E0;
	sub_82CAD880(ctx, base);
	// 82EEB2E0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEB2E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB2E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB2EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEB2F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEB2F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB2F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB2FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEB300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB308 size=56
    let mut pc: u32 = 0x82EEB308;
    'dispatch: loop {
        match pc {
            0x82EEB308 => {
    //   block [0x82EEB308..0x82EEB340)
	// 82EEB308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB310: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB314: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB318: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB31C: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEB320: 480001B1  bl 0x82eeb4d0
	ctx.lr = 0x82EEB324;
	sub_82EEB4D0(ctx, base);
	// 82EEB324: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB328: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEB32C: 4BD8DDB5  bl 0x82c790e0
	ctx.lr = 0x82EEB330;
	sub_82C790E0(ctx, base);
	// 82EEB330: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB334: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB338: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEB340 size=28
    let mut pc: u32 = 0x82EEB340;
    'dispatch: loop {
        match pc {
            0x82EEB340 => {
    //   block [0x82EEB340..0x82EEB35C)
	// 82EEB340: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEB344: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEB348: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEB34C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB350: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEB354: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB360 size=44
    let mut pc: u32 = 0x82EEB360;
    'dispatch: loop {
        match pc {
            0x82EEB360 => {
    //   block [0x82EEB360..0x82EEB38C)
	// 82EEB360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB368: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB36C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB370: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB374: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB378: 48000019  bl 0x82eeb390
	ctx.lr = 0x82EEB37C;
	sub_82EEB390(ctx, base);
	// 82EEB37C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB390 size=64
    let mut pc: u32 = 0x82EEB390;
    'dispatch: loop {
        match pc {
            0x82EEB390 => {
    //   block [0x82EEB390..0x82EEB3D0)
	// 82EEB390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB398: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB39C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB3A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB3A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB3A8: 419A0018  beq cr6, 0x82eeb3c0
	if ctx.cr[6].eq {
	pc = 0x82EEB3C0; continue 'dispatch;
	}
	// 82EEB3AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB3B0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EEB3B4: 419A000C  beq cr6, 0x82eeb3c0
	if ctx.cr[6].eq {
	pc = 0x82EEB3C0; continue 'dispatch;
	}
	// 82EEB3B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB3BC: 4BDD73F5  bl 0x82cc27b0
	ctx.lr = 0x82EEB3C0;
	sub_82CC27B0(ctx, base);
	// 82EEB3C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB3C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB3C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEB3D0 size=48
    let mut pc: u32 = 0x82EEB3D0;
    'dispatch: loop {
        match pc {
            0x82EEB3D0 => {
    //   block [0x82EEB3D0..0x82EEB400)
	// 82EEB3D0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEB3D4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB3D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB3DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB3E0: 419A0020  beq cr6, 0x82eeb400
	if ctx.cr[6].eq {
		sub_82EEB400(ctx, base);
		return;
	}
	// 82EEB3E4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB3E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB3EC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EEB3F0: 419A0010  beq cr6, 0x82eeb400
	if ctx.cr[6].eq {
		sub_82EEB400(ctx, base);
		return;
	}
	// 82EEB3F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB3F8: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEB3FC: 4800000C  b 0x82eeb408
	sub_82EEB400(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEB400 size=20
    let mut pc: u32 = 0x82EEB400;
    'dispatch: loop {
        match pc {
            0x82EEB400 => {
    //   block [0x82EEB400..0x82EEB414)
	// 82EEB400: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEB404: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEB408: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEB40C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEB410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB418 size=184
    let mut pc: u32 = 0x82EEB418;
    'dispatch: loop {
        match pc {
            0x82EEB418 => {
    //   block [0x82EEB418..0x82EEB4D0)
	// 82EEB418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB420: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB424: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB428: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB42C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEB430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB434: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB438: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEB43C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB440: 419A003C  beq cr6, 0x82eeb47c
	if ctx.cr[6].eq {
	pc = 0x82EEB47C; continue 'dispatch;
	}
	// 82EEB444: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB448: 396BC20C  addi r11, r11, -0x3df4
	ctx.r[11].s64 = ctx.r[11].s64 + -15860;
	// 82EEB44C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB450: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEB454: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB458: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EEB45C: 394AB27C  addi r10, r10, -0x4d84
	ctx.r[10].s64 = ctx.r[10].s64 + -19844;
	// 82EEB460: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEB464: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB468: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEB46C: 4BD8DCA5  bl 0x82c79110
	ctx.lr = 0x82EEB470;
	sub_82C79110(ctx, base);
	// 82EEB470: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB474: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EEB478: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB47C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEB480: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB484: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82EEB488: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB48C: 4800023D  bl 0x82eeb6c8
	ctx.lr = 0x82EEB490;
	sub_82EEB6C8(ctx, base);
	// 82EEB490: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB494: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB498: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB49C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB4A0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EEB4A4: 3929C208  addi r9, r9, -0x3df8
	ctx.r[9].s64 = ctx.r[9].s64 + -15864;
	// 82EEB4A8: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82EEB4AC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB4B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB4B4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB4B8: 4BD94F89  bl 0x82c80440
	ctx.lr = 0x82EEB4BC;
	sub_82C80440(ctx, base);
	// 82EEB4BC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB4C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB4C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB4C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB4CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB4D0 size=96
    let mut pc: u32 = 0x82EEB4D0;
    'dispatch: loop {
        match pc {
            0x82EEB4D0 => {
    //   block [0x82EEB4D0..0x82EEB530)
	// 82EEB4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB4D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB4D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB4DC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB4E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB4E4: 396BFFAC  addi r11, r11, -0x54
	ctx.r[11].s64 = ctx.r[11].s64 + -84;
	// 82EEB4E8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB4EC: 814AFFAC  lwz r10, -0x54(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-84 as u32) ) } as u64;
	// 82EEB4F0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB4F4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EEB4F8: 3929C208  addi r9, r9, -0x3df8
	ctx.r[9].s64 = ctx.r[9].s64 + -15864;
	// 82EEB4FC: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 82EEB500: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB504: 396BFFAC  addi r11, r11, -0x54
	ctx.r[11].s64 = ctx.r[11].s64 + -84;
	// 82EEB508: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB50C: 4BD8E2FD  bl 0x82c79808
	ctx.lr = 0x82EEB510;
	sub_82C79808(ctx, base);
	// 82EEB510: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB514: 396BFFAC  addi r11, r11, -0x54
	ctx.r[11].s64 = ctx.r[11].s64 + -84;
	// 82EEB518: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB51C: 4800004D  bl 0x82eeb568
	ctx.lr = 0x82EEB520;
	sub_82EEB568(ctx, base);
	// 82EEB520: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB52C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB530 size=56
    let mut pc: u32 = 0x82EEB530;
    'dispatch: loop {
        match pc {
            0x82EEB530 => {
    //   block [0x82EEB530..0x82EEB568)
	// 82EEB530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB538: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB53C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB540: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB544: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB548: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB54C: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82EEB550: 4BD95031  bl 0x82c80580
	ctx.lr = 0x82EEB554;
	sub_82C80580(ctx, base);
	// 82EEB554: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB558: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB55C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB568 size=132
    let mut pc: u32 = 0x82EEB568;
    'dispatch: loop {
        match pc {
            0x82EEB568 => {
    //   block [0x82EEB568..0x82EEB5EC)
	// 82EEB568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB570: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB574: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB578: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB57C: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82EEB580: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB584: 814AFFF4  lwz r10, -0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EEB588: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB58C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EEB590: 3929C214  addi r9, r9, -0x3dec
	ctx.r[9].s64 = ctx.r[9].s64 + -15852;
	// 82EEB594: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 82EEB598: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB59C: 356BFFF4  addic. r11, r11, -0xc
	ctx.xer.ca = (ctx.r[11].u32 > (!(-12 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB5A0: 41820018  beq 0x82eeb5b8
	if ctx.cr[0].eq {
	pc = 0x82EEB5B8; continue 'dispatch;
	}
	// 82EEB5A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB5A8: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82EEB5AC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EEB5B0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB5B4: 4800000C  b 0x82eeb5c0
	pc = 0x82EEB5C0; continue 'dispatch;
	// 82EEB5B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB5BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB5C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB5C4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EEB5C8: 4BD94989  bl 0x82c7ff50
	ctx.lr = 0x82EEB5CC;
	sub_82C7FF50(ctx, base);
	// 82EEB5CC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB5D0: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82EEB5D4: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEB5D8: 4BD8DB19  bl 0x82c790f0
	ctx.lr = 0x82EEB5DC;
	sub_82C790F0(ctx, base);
	// 82EEB5DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB5E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB5E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB5E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB5F0 size=80
    let mut pc: u32 = 0x82EEB5F0;
    'dispatch: loop {
        match pc {
            0x82EEB5F0 => {
    //   block [0x82EEB5F0..0x82EEB640)
	// 82EEB5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB5F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB5F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB5FC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB600: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB604: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB608: 386BFFAC  addi r3, r11, -0x54
	ctx.r[3].s64 = ctx.r[11].s64 + -84;
	// 82EEB60C: 4BFFFCFD  bl 0x82eeb308
	ctx.lr = 0x82EEB610;
	sub_82EEB308(ctx, base);
	// 82EEB610: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB614: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB618: 41820010  beq 0x82eeb628
	if ctx.cr[0].eq {
	pc = 0x82EEB628; continue 'dispatch;
	}
	// 82EEB61C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB620: 386BFFAC  addi r3, r11, -0x54
	ctx.r[3].s64 = ctx.r[11].s64 + -84;
	// 82EEB624: 4B95A18D  bl 0x828457b0
	ctx.lr = 0x82EEB628;
	sub_828457B0(ctx, base);
	// 82EEB628: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB62C: 386BFFAC  addi r3, r11, -0x54
	ctx.r[3].s64 = ctx.r[11].s64 + -84;
	// 82EEB630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB63C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB640 size=80
    let mut pc: u32 = 0x82EEB640;
    'dispatch: loop {
        match pc {
            0x82EEB640 => {
    //   block [0x82EEB640..0x82EEB690)
	// 82EEB640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB648: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB64C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB650: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB654: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB658: 386BFFF4  addi r3, r11, -0xc
	ctx.r[3].s64 = ctx.r[11].s64 + -12;
	// 82EEB65C: 48000035  bl 0x82eeb690
	ctx.lr = 0x82EEB660;
	sub_82EEB690(ctx, base);
	// 82EEB660: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB664: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB668: 41820010  beq 0x82eeb678
	if ctx.cr[0].eq {
	pc = 0x82EEB678; continue 'dispatch;
	}
	// 82EEB66C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB670: 386BFFF4  addi r3, r11, -0xc
	ctx.r[3].s64 = ctx.r[11].s64 + -12;
	// 82EEB674: 4B95A13D  bl 0x828457b0
	ctx.lr = 0x82EEB678;
	sub_828457B0(ctx, base);
	// 82EEB678: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB67C: 386BFFF4  addi r3, r11, -0xc
	ctx.r[3].s64 = ctx.r[11].s64 + -12;
	// 82EEB680: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB68C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB690 size=56
    let mut pc: u32 = 0x82EEB690;
    'dispatch: loop {
        match pc {
            0x82EEB690 => {
    //   block [0x82EEB690..0x82EEB6C8)
	// 82EEB690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB698: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB69C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB6A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB6A4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB6A8: 4BFFFEC1  bl 0x82eeb568
	ctx.lr = 0x82EEB6AC;
	sub_82EEB568(ctx, base);
	// 82EEB6AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB6B0: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB6B4: 4BD8DA2D  bl 0x82c790e0
	ctx.lr = 0x82EEB6B8;
	sub_82C790E0(ctx, base);
	// 82EEB6B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB6BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB6C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB6C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB6C8 size=192
    let mut pc: u32 = 0x82EEB6C8;
    'dispatch: loop {
        match pc {
            0x82EEB6C8 => {
    //   block [0x82EEB6C8..0x82EEB788)
	// 82EEB6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB6CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB6D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB6D4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB6D8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB6DC: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEB6E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB6E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB6E8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEB6EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB6F0: 419A003C  beq cr6, 0x82eeb72c
	if ctx.cr[6].eq {
	pc = 0x82EEB72C; continue 'dispatch;
	}
	// 82EEB6F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EEB6F8: 396BB238  addi r11, r11, -0x4dc8
	ctx.r[11].s64 = ctx.r[11].s64 + -19912;
	// 82EEB6FC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB700: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEB704: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB708: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82EEB70C: 394AE4CC  addi r10, r10, -0x1b34
	ctx.r[10].s64 = ctx.r[10].s64 + -6964;
	// 82EEB710: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEB714: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB718: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB71C: 4BD8D9F5  bl 0x82c79110
	ctx.lr = 0x82EEB720;
	sub_82C79110(ctx, base);
	// 82EEB720: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB724: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EEB728: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB72C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EEB730: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEB734: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB738: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB73C: 4BD905ED  bl 0x82c7bd28
	ctx.lr = 0x82EEB740;
	sub_82C7BD28(ctx, base);
	// 82EEB740: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EEB744: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEB748: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEB74C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB750: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEB754: 48000035  bl 0x82eeb788
	ctx.lr = 0x82EEB758;
	sub_82EEB788(ctx, base);
	// 82EEB758: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB75C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB760: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB764: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB768: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EEB76C: 3929C214  addi r9, r9, -0x3dec
	ctx.r[9].s64 = ctx.r[9].s64 + -15852;
	// 82EEB770: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82EEB774: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB778: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB77C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB780: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB788 size=204
    let mut pc: u32 = 0x82EEB788;
    'dispatch: loop {
        match pc {
            0x82EEB788 => {
    //   block [0x82EEB788..0x82EEB854)
	// 82EEB788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB790: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB794: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB798: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB79C: 98A10087  stb r5, 0x87(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(135 as u32), ctx.r[5].u8 ) };
	// 82EEB7A0: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEB7A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB7A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB7AC: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEB7B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB7B4: 419A002C  beq cr6, 0x82eeb7e0
	if ctx.cr[6].eq {
	pc = 0x82EEB7E0; continue 'dispatch;
	}
	// 82EEB7B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82EEB7BC: 396BE4CC  addi r11, r11, -0x1b34
	ctx.r[11].s64 = ctx.r[11].s64 + -6964;
	// 82EEB7C0: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB7C4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEB7C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB7CC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EEB7D0: 4BD8D941  bl 0x82c79110
	ctx.lr = 0x82EEB7D4;
	sub_82C79110(ctx, base);
	// 82EEB7D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB7D8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EEB7DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB7E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB7E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB7E8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB7EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB7F0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82EEB7F4: 3929E4A0  addi r9, r9, -0x1b60
	ctx.r[9].s64 = ctx.r[9].s64 + -7008;
	// 82EEB7F8: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82EEB7FC: 89610087  lbz r11, 0x87(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(135 as u32) ) } as u64;
	// 82EEB800: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB804: 4182003C  beq 0x82eeb840
	if ctx.cr[0].eq {
	pc = 0x82EEB840; continue 'dispatch;
	}
	// 82EEB808: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB80C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB810: 409A0010  bne cr6, 0x82eeb820
	if !ctx.cr[6].eq {
	pc = 0x82EEB820; continue 'dispatch;
	}
	// 82EEB814: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB818: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEB81C: 4800001C  b 0x82eeb838
	pc = 0x82EEB838; continue 'dispatch;
	// 82EEB820: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB824: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB828: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB82C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB830: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEB834: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEB838: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEB83C: 4BDEC4FD  bl 0x82cd7d38
	ctx.lr = 0x82EEB840;
	sub_82CD7D38(ctx, base);
	// 82EEB840: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB844: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB848: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB84C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB858 size=728
    let mut pc: u32 = 0x82EEB858;
    'dispatch: loop {
        match pc {
            0x82EEB858 => {
    //   block [0x82EEB858..0x82EEBB30)
	// 82EEB858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB860: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EEB864: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEB868: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB86C: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEB870: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EEB874: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB878: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB87C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EEB880: 4BD0D011  bl 0x82bf8890
	ctx.lr = 0x82EEB884;
	sub_82BF8890(ctx, base);
	// 82EEB884: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEB888: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB88C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB890: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB898: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEB89C: 4BA22475  bl 0x8290dd10
	ctx.lr = 0x82EEB8A0;
	sub_8290DD10(ctx, base);
	// 82EEB8A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB8A4: 40810050  ble 0x82eeb8f4
	if !ctx.cr[0].gt {
	pc = 0x82EEB8F4; continue 'dispatch;
	}
	// 82EEB8A8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB8AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB8B0: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB8B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB8B8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEB8BC: 4BA22455  bl 0x8290dd10
	ctx.lr = 0x82EEB8C0;
	sub_8290DD10(ctx, base);
	// 82EEB8C0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEB8C4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EEB8C8: 4099002C  ble cr6, 0x82eeb8f4
	if !ctx.cr[6].gt {
	pc = 0x82EEB8F4; continue 'dispatch;
	}
	// 82EEB8CC: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB8D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB8D4: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB8D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB8DC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEB8E0: 4BA22431  bl 0x8290dd10
	ctx.lr = 0x82EEB8E4;
	sub_8290DD10(ctx, base);
	// 82EEB8E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEB8E8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82EEB8EC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEB8F0: 4800000C  b 0x82eeb8fc
	pc = 0x82EEB8FC; continue 'dispatch;
	// 82EEB8F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB8F8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEB8FC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB900: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEB904: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB908: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEB90C: 4BD95345  bl 0x82c80c50
	ctx.lr = 0x82EEB910;
	sub_82C80C50(ctx, base);
	// 82EEB910: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEB914: 4BD94665  bl 0x82c7ff78
	ctx.lr = 0x82EEB918;
	sub_82C7FF78(ctx, base);
	// 82EEB918: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB91C: 40820014  bne 0x82eeb930
	if !ctx.cr[0].eq {
	pc = 0x82EEB930; continue 'dispatch;
	}
	// 82EEB920: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB924: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEB928: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB92C: 480001B8  b 0x82eebae4
	pc = 0x82EEBAE4; continue 'dispatch;
	// 82EEB930: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB934: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB938: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB93C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB940: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEB944: 482D071D  bl 0x831bc060
	ctx.lr = 0x82EEB948;
	sub_831BC060(ctx, base);
	// 82EEB948: 546B05F2  rlwinm r11, r3, 0, 0x17, 0x19
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82EEB94C: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82EEB950: 419A0090  beq cr6, 0x82eeb9e0
	if ctx.cr[6].eq {
	pc = 0x82EEB9E0; continue 'dispatch;
	}
	// 82EEB954: 48000010  b 0x82eeb964
	pc = 0x82EEB964; continue 'dispatch;
	// 82EEB958: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEB95C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEB960: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEB964: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEB968: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB96C: 40990074  ble cr6, 0x82eeb9e0
	if !ctx.cr[6].gt {
	pc = 0x82EEB9E0; continue 'dispatch;
	}
	// 82EEB970: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB974: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB978: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB97C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB980: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEB984: 4BD945ED  bl 0x82c7ff70
	ctx.lr = 0x82EEB988;
	sub_82C7FF70(ctx, base);
	// 82EEB988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEB98C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB990: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB994: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB998: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB99C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEB9A0: 4BA1E7A1  bl 0x8290a140
	ctx.lr = 0x82EEB9A4;
	sub_8290A140(ctx, base);
	// 82EEB9A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEB9A8: 4BD94999  bl 0x82c80340
	ctx.lr = 0x82EEB9AC;
	sub_82C80340(ctx, base);
	// 82EEB9AC: B0610068  sth r3, 0x68(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u16 ) };
	// 82EEB9B0: 4BEC6211  bl 0x82db1bc0
	ctx.lr = 0x82EEB9B4;
	sub_82DB1BC0(ctx, base);
	// 82EEB9B4: B061006A  sth r3, 0x6a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(106 as u32), ctx.r[3].u16 ) };
	// 82EEB9B8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82EEB9BC: 3861006A  addi r3, r1, 0x6a
	ctx.r[3].s64 = ctx.r[1].s64 + 106;
	// 82EEB9C0: 4BD8D601  bl 0x82c78fc0
	ctx.lr = 0x82EEB9C4;
	sub_82C78FC0(ctx, base);
	// 82EEB9C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB9C8: 41820014  beq 0x82eeb9dc
	if ctx.cr[0].eq {
	pc = 0x82EEB9DC; continue 'dispatch;
	}
	// 82EEB9CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB9D0: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEB9D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB9D8: 48000008  b 0x82eeb9e0
	pc = 0x82EEB9E0; continue 'dispatch;
	// 82EEB9DC: 4BFFFF7C  b 0x82eeb958
	pc = 0x82EEB958; continue 'dispatch;
	// 82EEB9E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB9E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB9E8: 409A0048  bne cr6, 0x82eeba30
	if !ctx.cr[6].eq {
	pc = 0x82EEBA30; continue 'dispatch;
	}
	// 82EEB9EC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEB9F0: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EEB9F4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB9F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB9FC: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBA00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEBA04: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEBA08: 4BA1E739  bl 0x8290a140
	ctx.lr = 0x82EEBA0C;
	sub_8290A140(ctx, base);
	// 82EEBA0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EEBA10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEBA14: 4800011D  bl 0x82eebb30
	ctx.lr = 0x82EEBA18;
	sub_82EEBB30(ctx, base);
	// 82EEBA18: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEBA1C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EEBA20: 419A0010  beq cr6, 0x82eeba30
	if ctx.cr[6].eq {
	pc = 0x82EEBA30; continue 'dispatch;
	}
	// 82EEBA24: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEBA28: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEBA2C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEBA30: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEBA34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBA38: 409A0090  bne cr6, 0x82eebac8
	if !ctx.cr[6].eq {
	pc = 0x82EEBAC8; continue 'dispatch;
	}
	// 82EEBA3C: 48000010  b 0x82eeba4c
	pc = 0x82EEBA4C; continue 'dispatch;
	// 82EEBA40: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEBA44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEBA48: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEBA4C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEBA50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBA54: 40990074  ble cr6, 0x82eebac8
	if !ctx.cr[6].gt {
	pc = 0x82EEBAC8; continue 'dispatch;
	}
	// 82EEBA58: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBA5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBA60: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBA64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEBA68: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEBA6C: 4BD94505  bl 0x82c7ff70
	ctx.lr = 0x82EEBA70;
	sub_82C7FF70(ctx, base);
	// 82EEBA70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEBA74: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBA78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBA7C: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBA80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEBA84: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEBA88: 4BA1E6B9  bl 0x8290a140
	ctx.lr = 0x82EEBA8C;
	sub_8290A140(ctx, base);
	// 82EEBA8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEBA90: 4BD948B1  bl 0x82c80340
	ctx.lr = 0x82EEBA94;
	sub_82C80340(ctx, base);
	// 82EEBA94: B061006C  sth r3, 0x6c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u16 ) };
	// 82EEBA98: 4BEC6129  bl 0x82db1bc0
	ctx.lr = 0x82EEBA9C;
	sub_82DB1BC0(ctx, base);
	// 82EEBA9C: B061006E  sth r3, 0x6e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(110 as u32), ctx.r[3].u16 ) };
	// 82EEBAA0: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82EEBAA4: 3861006E  addi r3, r1, 0x6e
	ctx.r[3].s64 = ctx.r[1].s64 + 110;
	// 82EEBAA8: 4BD8D519  bl 0x82c78fc0
	ctx.lr = 0x82EEBAAC;
	sub_82C78FC0(ctx, base);
	// 82EEBAAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBAB0: 41820014  beq 0x82eebac4
	if ctx.cr[0].eq {
	pc = 0x82EEBAC4; continue 'dispatch;
	}
	// 82EEBAB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEBAB8: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEBABC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEBAC0: 48000008  b 0x82eebac8
	pc = 0x82EEBAC8; continue 'dispatch;
	// 82EEBAC4: 4BFFFF7C  b 0x82eeba40
	pc = 0x82EEBA40; continue 'dispatch;
	// 82EEBAC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEBACC: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBAD0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBAD4: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBAD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEBADC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEBAE0: 4B7906C1  bl 0x8267c1a0
	ctx.lr = 0x82EEBAE4;
	sub_8267C1A0(ctx, base);
	// 82EEBAE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEBAE8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEBAEC: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBAF0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBAF4: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBAF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEBAFC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEBB00: 4BD8FC61  bl 0x82c7b760
	ctx.lr = 0x82EEBB04;
	sub_82C7B760(ctx, base);
	// 82EEBB04: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEBB08: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EEBB0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEBB10: 4BD954E1  bl 0x82c80ff0
	ctx.lr = 0x82EEBB14;
	sub_82C80FF0(ctx, base);
	// 82EEBB14: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EEBB18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEBB1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBB20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBB24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EEBB28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEBB2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBB30 size=72
    let mut pc: u32 = 0x82EEBB30;
    'dispatch: loop {
        match pc {
            0x82EEBB30 => {
    //   block [0x82EEBB30..0x82EEBB78)
	// 82EEBB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBB38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBB3C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEBB40: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEBB44: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEBB48: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEBB4C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEBB50: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEBB54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBB58: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEBB5C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EEBB60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBB64: 4E800421  bctrl
	ctx.lr = 0x82EEBB68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBB68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEBB6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBB70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBB78 size=64
    let mut pc: u32 = 0x82EEBB78;
    'dispatch: loop {
        match pc {
            0x82EEBB78 => {
    //   block [0x82EEBB78..0x82EEBBB8)
	// 82EEBB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBB80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBB84: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEBB88: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEBB8C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEBB90: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEBB94: 48000025  bl 0x82eebbb8
	ctx.lr = 0x82EEBB98;
	sub_82EEBBB8(ctx, base);
	// 82EEBB98: 39630000  addi r11, r3, 0
	ctx.r[11].s64 = ctx.r[3].s64 + 0;
	// 82EEBB9C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EEBBA0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EEBBA4: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEBBA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEBBAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBBB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBBB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EEBBB8 size=96
    let mut pc: u32 = 0x82EEBBB8;
    'dispatch: loop {
        match pc {
            0x82EEBBB8 => {
    //   block [0x82EEBBB8..0x82EEBC18)
	// 82EEBBB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBBBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBBC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBBC4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEBBC8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEBBCC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEBBD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBBD4: 409A0014  bne cr6, 0x82eebbe8
	if !ctx.cr[6].eq {
	pc = 0x82EEBBE8; continue 'dispatch;
	}
	// 82EEBBD8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEBBDC: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82EEBBE0: 7C6B5910  subfe r3, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[3].u32 = res;
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82EEBBE4: 48000024  b 0x82eebc08
	pc = 0x82EEBC08; continue 'dispatch;
	// 82EEBBE8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEBBEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBBF0: 409A000C  bne cr6, 0x82eebbfc
	if !ctx.cr[6].eq {
	pc = 0x82EEBBFC; continue 'dispatch;
	}
	// 82EEBBF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEBBF8: 48000010  b 0x82eebc08
	pc = 0x82EEBC08; continue 'dispatch;
	// 82EEBBFC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEBC00: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEBC04: 4BDC45E5  bl 0x82cb01e8
	ctx.lr = 0x82EEBC08;
	sub_82CB01E8(ctx, base);
	// 82EEBC08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEBC0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBC10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBC14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBC18 size=308
    let mut pc: u32 = 0x82EEBC18;
    'dispatch: loop {
        match pc {
            0x82EEBC18 => {
    //   block [0x82EEBC18..0x82EEBD4C)
	// 82EEBC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBC20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBC24: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEBC28: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEBC2C: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82EEBC30: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEBC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBC38: 419A002C  beq cr6, 0x82eebc64
	if ctx.cr[6].eq {
	pc = 0x82EEBC64; continue 'dispatch;
	}
	// 82EEBC3C: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBC40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBC44: 419A0020  beq cr6, 0x82eebc64
	if ctx.cr[6].eq {
	pc = 0x82EEBC64; continue 'dispatch;
	}
	// 82EEBC48: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEBC4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBC50: 419A0014  beq cr6, 0x82eebc64
	if ctx.cr[6].eq {
	pc = 0x82EEBC64; continue 'dispatch;
	}
	// 82EEBC54: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEBC58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBC5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBC60: 419A0010  beq cr6, 0x82eebc70
	if ctx.cr[6].eq {
	pc = 0x82EEBC70; continue 'dispatch;
	}
	// 82EEBC64: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEBC68: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EEBC6C: 480000D0  b 0x82eebd3c
	pc = 0x82EEBD3C; continue 'dispatch;
	// 82EEBC70: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBC74: 816B8F58  lwz r11, -0x70a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEBC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBC7C: 419A001C  beq cr6, 0x82eebc98
	if ctx.cr[6].eq {
	pc = 0x82EEBC98; continue 'dispatch;
	}
	// 82EEBC80: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBC84: 816B8F58  lwz r11, -0x70a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEBC88: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEBC8C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEBC90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEBC94: 480000A8  b 0x82eebd3c
	pc = 0x82EEBD3C; continue 'dispatch;
	// 82EEBC98: 388002F0  li r4, 0x2f0
	ctx.r[4].s64 = 752;
	// 82EEBC9C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEBCA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBCA4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEBCA8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBCAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBCB0: 4E800421  bctrl
	ctx.lr = 0x82EEBCB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBCB4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EEBCB8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEBCBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBCC0: 409A0010  bne cr6, 0x82eebcd0
	if !ctx.cr[6].eq {
	pc = 0x82EEBCD0; continue 'dispatch;
	}
	// 82EEBCC4: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEBCC8: 6163000E  ori r3, r11, 0xe
	ctx.r[3].u64 = ctx.r[11].u64 | 14;
	// 82EEBCCC: 48000070  b 0x82eebd3c
	pc = 0x82EEBD3C; continue 'dispatch;
	// 82EEBCD0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEBCD4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBCD8: 916A8F50  stw r11, -0x70b0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-28848 as u32), ctx.r[11].u32 ) };
	// 82EEBCDC: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBCE0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBCE4: 916A8F54  stw r11, -0x70ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-28844 as u32), ctx.r[11].u32 ) };
	// 82EEBCE8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEBCEC: 386002F0  li r3, 0x2f0
	ctx.r[3].s64 = 752;
	// 82EEBCF0: 4B405F21  bl 0x822f1c10
	ctx.lr = 0x82EEBCF4;
	sub_822F1C10(ctx, base);
	// 82EEBCF4: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEBCF8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEBCFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBD00: 419A0014  beq cr6, 0x82eebd14
	if ctx.cr[6].eq {
	pc = 0x82EEBD14; continue 'dispatch;
	}
	// 82EEBD04: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEBD08: 480004E1  bl 0x82eec1e8
	ctx.lr = 0x82EEBD0C;
	sub_82EEC1E8(ctx, base);
	// 82EEBD0C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EEBD10: 4800000C  b 0x82eebd1c
	pc = 0x82EEBD1C; continue 'dispatch;
	// 82EEBD14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEBD18: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEBD1C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEBD20: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBD24: 916A8F58  stw r11, -0x70a8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-28840 as u32), ctx.r[11].u32 ) };
	// 82EEBD28: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBD2C: 816B8F58  lwz r11, -0x70a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEBD30: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEBD34: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEBD38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEBD3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEBD40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBD44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBD48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBD50 size=168
    let mut pc: u32 = 0x82EEBD50;
    'dispatch: loop {
        match pc {
            0x82EEBD50 => {
    //   block [0x82EEBD50..0x82EEBDF8)
	// 82EEBD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBD54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBD58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEBD5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBD60: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEBD64: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEBD68: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBD6C: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBD70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBD74: 409A004C  bne cr6, 0x82eebdc0
	if !ctx.cr[6].eq {
	pc = 0x82EEBDC0; continue 'dispatch;
	}
	// 82EEBD78: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBD7C: 896B8F5C  lbz r11, -0x70a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28836 as u32) ) } as u64;
	// 82EEBD80: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEBD84: 4082003C  bne 0x82eebdc0
	if !ctx.cr[0].eq {
	pc = 0x82EEBDC0; continue 'dispatch;
	}
	// 82EEBD88: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBD8C: 3BEB8F5C  addi r31, r11, -0x70a4
	ctx.r[31].s64 = ctx.r[11].s64 + -28836;
	// 82EEBD90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBD94: 38CBC228  addi r6, r11, -0x3dd8
	ctx.r[6].s64 = ctx.r[11].s64 + -15832;
	// 82EEBD98: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 82EEBD9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBDA0: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEBDA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEBDA8: 4BFFF3C1  bl 0x82eeb168
	ctx.lr = 0x82EEBDAC;
	sub_82EEB168(ctx, base);
	// 82EEBDAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEBDB0: 48206009  bl 0x830f1db8
	ctx.lr = 0x82EEBDB4;
	sub_830F1DB8(ctx, base);
	// 82EEBDB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBDB8: 40820008  bne 0x82eebdc0
	if !ctx.cr[0].eq {
	pc = 0x82EEBDC0; continue 'dispatch;
	}
	// 82EEBDBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEBDC0: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBDC4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBDC8: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBDCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBDD0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBDD4: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBDD8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEBDDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBDE0: 4E800421  bctrl
	ctx.lr = 0x82EEBDE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBDE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEBDE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBDEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBDF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEBDF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBDF8 size=168
    let mut pc: u32 = 0x82EEBDF8;
    'dispatch: loop {
        match pc {
            0x82EEBDF8 => {
    //   block [0x82EEBDF8..0x82EEBEA0)
	// 82EEBDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBE00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEBE04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBE08: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEBE0C: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEBE10: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBE14: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBE18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBE1C: 409A004C  bne cr6, 0x82eebe68
	if !ctx.cr[6].eq {
	pc = 0x82EEBE68; continue 'dispatch;
	}
	// 82EEBE20: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBE24: 896B8F5D  lbz r11, -0x70a3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28835 as u32) ) } as u64;
	// 82EEBE28: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEBE2C: 4082003C  bne 0x82eebe68
	if !ctx.cr[0].eq {
	pc = 0x82EEBE68; continue 'dispatch;
	}
	// 82EEBE30: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBE34: 3BEB8F5D  addi r31, r11, -0x70a3
	ctx.r[31].s64 = ctx.r[11].s64 + -28835;
	// 82EEBE38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBE3C: 38CBC228  addi r6, r11, -0x3dd8
	ctx.r[6].s64 = ctx.r[11].s64 + -15832;
	// 82EEBE40: 38A0003C  li r5, 0x3c
	ctx.r[5].s64 = 60;
	// 82EEBE44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBE48: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEBE4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEBE50: 4BFFF319  bl 0x82eeb168
	ctx.lr = 0x82EEBE54;
	sub_82EEB168(ctx, base);
	// 82EEBE54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEBE58: 48205F61  bl 0x830f1db8
	ctx.lr = 0x82EEBE5C;
	sub_830F1DB8(ctx, base);
	// 82EEBE5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBE60: 40820008  bne 0x82eebe68
	if !ctx.cr[0].eq {
	pc = 0x82EEBE68; continue 'dispatch;
	}
	// 82EEBE64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEBE68: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBE6C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBE70: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBE74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBE78: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBE7C: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBE80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBE84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBE88: 4E800421  bctrl
	ctx.lr = 0x82EEBE8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBE8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEBE90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBE94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBE98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEBE9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBEA0 size=176
    let mut pc: u32 = 0x82EEBEA0;
    'dispatch: loop {
        match pc {
            0x82EEBEA0 => {
    //   block [0x82EEBEA0..0x82EEBF50)
	// 82EEBEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBEA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBEA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEBEAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBEB0: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEBEB4: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEBEB8: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82EEBEBC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBEC0: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBEC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBEC8: 409A004C  bne cr6, 0x82eebf14
	if !ctx.cr[6].eq {
	pc = 0x82EEBF14; continue 'dispatch;
	}
	// 82EEBECC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBED0: 896B8F5E  lbz r11, -0x70a2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28834 as u32) ) } as u64;
	// 82EEBED4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEBED8: 4082003C  bne 0x82eebf14
	if !ctx.cr[0].eq {
	pc = 0x82EEBF14; continue 'dispatch;
	}
	// 82EEBEDC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBEE0: 3BEB8F5E  addi r31, r11, -0x70a2
	ctx.r[31].s64 = ctx.r[11].s64 + -28834;
	// 82EEBEE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBEE8: 38CBC228  addi r6, r11, -0x3dd8
	ctx.r[6].s64 = ctx.r[11].s64 + -15832;
	// 82EEBEEC: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 82EEBEF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBEF4: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEBEF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEBEFC: 4BFFF26D  bl 0x82eeb168
	ctx.lr = 0x82EEBF00;
	sub_82EEB168(ctx, base);
	// 82EEBF00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEBF04: 48205EB5  bl 0x830f1db8
	ctx.lr = 0x82EEBF08;
	sub_830F1DB8(ctx, base);
	// 82EEBF08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBF0C: 40820008  bne 0x82eebf14
	if !ctx.cr[0].eq {
	pc = 0x82EEBF14; continue 'dispatch;
	}
	// 82EEBF10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEBF14: 80A10094  lwz r5, 0x94(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEBF18: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBF1C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBF20: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBF24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBF28: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBF2C: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBF30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEBF34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBF38: 4E800421  bctrl
	ctx.lr = 0x82EEBF3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBF3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEBF40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBF44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBF48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEBF4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBF50 size=168
    let mut pc: u32 = 0x82EEBF50;
    'dispatch: loop {
        match pc {
            0x82EEBF50 => {
    //   block [0x82EEBF50..0x82EEBFF8)
	// 82EEBF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBF54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBF58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEBF5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBF60: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEBF64: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEBF68: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBF6C: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEBF70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBF74: 409A004C  bne cr6, 0x82eebfc0
	if !ctx.cr[6].eq {
	pc = 0x82EEBFC0; continue 'dispatch;
	}
	// 82EEBF78: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBF7C: 896B8F5F  lbz r11, -0x70a1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28833 as u32) ) } as u64;
	// 82EEBF80: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEBF84: 4082003C  bne 0x82eebfc0
	if !ctx.cr[0].eq {
	pc = 0x82EEBFC0; continue 'dispatch;
	}
	// 82EEBF88: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBF8C: 3BEB8F5F  addi r31, r11, -0x70a1
	ctx.r[31].s64 = ctx.r[11].s64 + -28833;
	// 82EEBF90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBF94: 38CBC244  addi r6, r11, -0x3dbc
	ctx.r[6].s64 = ctx.r[11].s64 + -15804;
	// 82EEBF98: 38A0004D  li r5, 0x4d
	ctx.r[5].s64 = 77;
	// 82EEBF9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBFA0: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEBFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEBFA8: 4BFFF1C1  bl 0x82eeb168
	ctx.lr = 0x82EEBFAC;
	sub_82EEB168(ctx, base);
	// 82EEBFAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEBFB0: 48205E09  bl 0x830f1db8
	ctx.lr = 0x82EEBFB4;
	sub_830F1DB8(ctx, base);
	// 82EEBFB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBFB8: 40820008  bne 0x82eebfc0
	if !ctx.cr[0].eq {
	pc = 0x82EEBFC0; continue 'dispatch;
	}
	// 82EEBFBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEBFC0: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBFC4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBFC8: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEBFCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBFD0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBFD4: 806A8F54  lwz r3, -0x70ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEBFD8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBFDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBFE0: 4E800421  bctrl
	ctx.lr = 0x82EEBFE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBFE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEBFE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBFEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBFF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEBFF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBFF8 size=168
    let mut pc: u32 = 0x82EEBFF8;
    'dispatch: loop {
        match pc {
            0x82EEBFF8 => {
    //   block [0x82EEBFF8..0x82EEC0A0)
	// 82EEBFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBFFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC004: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC008: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEC00C: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEC010: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC014: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC01C: 409A004C  bne cr6, 0x82eec068
	if !ctx.cr[6].eq {
	pc = 0x82EEC068; continue 'dispatch;
	}
	// 82EEC020: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC024: 896B8F60  lbz r11, -0x70a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28832 as u32) ) } as u64;
	// 82EEC028: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC02C: 4082003C  bne 0x82eec068
	if !ctx.cr[0].eq {
	pc = 0x82EEC068; continue 'dispatch;
	}
	// 82EEC030: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC034: 3BEB8F60  addi r31, r11, -0x70a0
	ctx.r[31].s64 = ctx.r[11].s64 + -28832;
	// 82EEC038: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC03C: 38CBC244  addi r6, r11, -0x3dbc
	ctx.r[6].s64 = ctx.r[11].s64 + -15804;
	// 82EEC040: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 82EEC044: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC048: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC04C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEC050: 4BFFF119  bl 0x82eeb168
	ctx.lr = 0x82EEC054;
	sub_82EEB168(ctx, base);
	// 82EEC054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC058: 48205D61  bl 0x830f1db8
	ctx.lr = 0x82EEC05C;
	sub_830F1DB8(ctx, base);
	// 82EEC05C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC060: 40820008  bne 0x82eec068
	if !ctx.cr[0].eq {
	pc = 0x82EEC068; continue 'dispatch;
	}
	// 82EEC064: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEC068: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEC06C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC070: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC074: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC078: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC07C: 806A8F54  lwz r3, -0x70ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC080: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEC084: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC088: 4E800421  bctrl
	ctx.lr = 0x82EEC08C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC08C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEC090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC098: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEC09C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC0A0 size=160
    let mut pc: u32 = 0x82EEC0A0;
    'dispatch: loop {
        match pc {
            0x82EEC0A0 => {
    //   block [0x82EEC0A0..0x82EEC140)
	// 82EEC0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC0A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC0A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC0AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC0B0: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEC0B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC0B8: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC0BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC0C0: 409A004C  bne cr6, 0x82eec10c
	if !ctx.cr[6].eq {
	pc = 0x82EEC10C; continue 'dispatch;
	}
	// 82EEC0C4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC0C8: 896B8F61  lbz r11, -0x709f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28831 as u32) ) } as u64;
	// 82EEC0CC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC0D0: 4082003C  bne 0x82eec10c
	if !ctx.cr[0].eq {
	pc = 0x82EEC10C; continue 'dispatch;
	}
	// 82EEC0D4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC0D8: 3BEB8F61  addi r31, r11, -0x709f
	ctx.r[31].s64 = ctx.r[11].s64 + -28831;
	// 82EEC0DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC0E0: 38CBC244  addi r6, r11, -0x3dbc
	ctx.r[6].s64 = ctx.r[11].s64 + -15804;
	// 82EEC0E4: 38A00059  li r5, 0x59
	ctx.r[5].s64 = 89;
	// 82EEC0E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC0EC: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC0F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEC0F4: 4BFFF075  bl 0x82eeb168
	ctx.lr = 0x82EEC0F8;
	sub_82EEB168(ctx, base);
	// 82EEC0F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC0FC: 48205CBD  bl 0x830f1db8
	ctx.lr = 0x82EEC100;
	sub_830F1DB8(ctx, base);
	// 82EEC100: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC104: 40820008  bne 0x82eec10c
	if !ctx.cr[0].eq {
	pc = 0x82EEC10C; continue 'dispatch;
	}
	// 82EEC108: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEC10C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC110: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC114: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC118: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC11C: 806A8F54  lwz r3, -0x70ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC120: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEC124: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC128: 4E800421  bctrl
	ctx.lr = 0x82EEC12C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC12C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEC130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC138: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEC13C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC140 size=168
    let mut pc: u32 = 0x82EEC140;
    'dispatch: loop {
        match pc {
            0x82EEC140 => {
    //   block [0x82EEC140..0x82EEC1E8)
	// 82EEC140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC14C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC150: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEC154: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEC158: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC15C: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC164: 409A004C  bne cr6, 0x82eec1b0
	if !ctx.cr[6].eq {
	pc = 0x82EEC1B0; continue 'dispatch;
	}
	// 82EEC168: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC16C: 896B8F62  lbz r11, -0x709e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28830 as u32) ) } as u64;
	// 82EEC170: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC174: 4082003C  bne 0x82eec1b0
	if !ctx.cr[0].eq {
	pc = 0x82EEC1B0; continue 'dispatch;
	}
	// 82EEC178: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC17C: 3BEB8F62  addi r31, r11, -0x709e
	ctx.r[31].s64 = ctx.r[11].s64 + -28830;
	// 82EEC180: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC184: 38CBC244  addi r6, r11, -0x3dbc
	ctx.r[6].s64 = ctx.r[11].s64 + -15804;
	// 82EEC188: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 82EEC18C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC190: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC194: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEC198: 4BFFEFD1  bl 0x82eeb168
	ctx.lr = 0x82EEC19C;
	sub_82EEB168(ctx, base);
	// 82EEC19C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC1A0: 48205C19  bl 0x830f1db8
	ctx.lr = 0x82EEC1A4;
	sub_830F1DB8(ctx, base);
	// 82EEC1A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC1A8: 40820008  bne 0x82eec1b0
	if !ctx.cr[0].eq {
	pc = 0x82EEC1B0; continue 'dispatch;
	}
	// 82EEC1AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEC1B0: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEC1B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC1B8: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC1BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC1C0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC1C4: 806A8F54  lwz r3, -0x70ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC1C8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEC1CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC1D0: 4E800421  bctrl
	ctx.lr = 0x82EEC1D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC1D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEC1D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC1DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC1E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEC1E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC1E8 size=184
    let mut pc: u32 = 0x82EEC1E8;
    'dispatch: loop {
        match pc {
            0x82EEC1E8 => {
    //   block [0x82EEC1E8..0x82EEC2A0)
	// 82EEC1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC1EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC1F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC1F4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC1F8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC1FC: 480000ED  bl 0x82eec2e8
	ctx.lr = 0x82EEC200;
	sub_82EEC2E8(ctx, base);
	// 82EEC200: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC204: 396BC260  addi r11, r11, -0x3da0
	ctx.r[11].s64 = ctx.r[11].s64 + -15776;
	// 82EEC208: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC20C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC210: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC214: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC218: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEC21C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC220: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEC224: 48000145  bl 0x82eec368
	ctx.lr = 0x82EEC228;
	sub_82EEC368(ctx, base);
	// 82EEC228: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC22C: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEC230: 48000179  bl 0x82eec3a8
	ctx.lr = 0x82EEC234;
	sub_82EEC3A8(ctx, base);
	// 82EEC234: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC238: 38AB000C  addi r5, r11, 0xc
	ctx.r[5].s64 = ctx.r[11].s64 + 12;
	// 82EEC23C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC240: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 82EEC244: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC248: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC24C: 48101265  bl 0x82fed4b0
	ctx.lr = 0x82EEC250;
	sub_82FED4B0(ctx, base);
	// 82EEC250: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC254: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEC258: 482056D1  bl 0x830f1928
	ctx.lr = 0x82EEC25C;
	sub_830F1928(ctx, base);
	// 82EEC25C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC260: 386B005C  addi r3, r11, 0x5c
	ctx.r[3].s64 = ctx.r[11].s64 + 92;
	// 82EEC264: 482056C5  bl 0x830f1928
	ctx.lr = 0x82EEC268;
	sub_830F1928(ctx, base);
	// 82EEC268: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC26C: 386B0064  addi r3, r11, 0x64
	ctx.r[3].s64 = ctx.r[11].s64 + 100;
	// 82EEC270: 48000179  bl 0x82eec3e8
	ctx.lr = 0x82EEC274;
	sub_82EEC3E8(ctx, base);
	// 82EEC274: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC278: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEC27C: 914B02EC  stw r10, 0x2ec(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(748 as u32), ctx.r[10].u32 ) };
	// 82EEC280: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC284: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC288: 48001919  bl 0x82eedba0
	ctx.lr = 0x82EEC28C;
	sub_82EEDBA0(ctx, base);
	// 82EEC28C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC29C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC2A0 size=68
    let mut pc: u32 = 0x82EEC2A0;
    'dispatch: loop {
        match pc {
            0x82EEC2A0 => {
    //   block [0x82EEC2A0..0x82EEC2E4)
	// 82EEC2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC2A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC2AC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC2B0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC2B4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC2B8: 48000291  bl 0x82eec548
	ctx.lr = 0x82EEC2BC;
	sub_82EEC548(ctx, base);
	// 82EEC2BC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC2C0: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC2C4: 4182000C  beq 0x82eec2d0
	if ctx.cr[0].eq {
	pc = 0x82EEC2D0; continue 'dispatch;
	}
	// 82EEC2C8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC2CC: 4B9594E5  bl 0x828457b0
	ctx.lr = 0x82EEC2D0;
	sub_828457B0(ctx, base);
	// 82EEC2D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC2D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC2D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC2DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC2E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC2E8 size=28
    let mut pc: u32 = 0x82EEC2E8;
    'dispatch: loop {
        match pc {
            0x82EEC2E8 => {
    //   block [0x82EEC2E8..0x82EEC304)
	// 82EEC2E8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC2EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC2F0: 396BC278  addi r11, r11, -0x3d88
	ctx.r[11].s64 = ctx.r[11].s64 + -15752;
	// 82EEC2F4: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC2F8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC2FC: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC308 size=68
    let mut pc: u32 = 0x82EEC308;
    'dispatch: loop {
        match pc {
            0x82EEC308 => {
    //   block [0x82EEC308..0x82EEC34C)
	// 82EEC308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC310: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC314: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC318: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC31C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC320: 48000031  bl 0x82eec350
	ctx.lr = 0x82EEC324;
	sub_82EEC350(ctx, base);
	// 82EEC324: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC328: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC32C: 4182000C  beq 0x82eec338
	if ctx.cr[0].eq {
	pc = 0x82EEC338; continue 'dispatch;
	}
	// 82EEC330: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC334: 4B95947D  bl 0x828457b0
	ctx.lr = 0x82EEC338;
	sub_828457B0(ctx, base);
	// 82EEC338: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC33C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC350 size=24
    let mut pc: u32 = 0x82EEC350;
    'dispatch: loop {
        match pc {
            0x82EEC350 => {
    //   block [0x82EEC350..0x82EEC368)
	// 82EEC350: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC354: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC358: 396BC278  addi r11, r11, -0x3d88
	ctx.r[11].s64 = ctx.r[11].s64 + -15752;
	// 82EEC35C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC360: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC368 size=60
    let mut pc: u32 = 0x82EEC368;
    'dispatch: loop {
        match pc {
            0x82EEC368 => {
    //   block [0x82EEC368..0x82EEC3A4)
	// 82EEC368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC370: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC374: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC378: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC37C: 4800011D  bl 0x82eec498
	ctx.lr = 0x82EEC380;
	sub_82EEC498(ctx, base);
	// 82EEC380: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC384: 396BC290  addi r11, r11, -0x3d70
	ctx.r[11].s64 = ctx.r[11].s64 + -15728;
	// 82EEC388: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC38C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC390: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC394: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC398: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC39C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC3A8 size=60
    let mut pc: u32 = 0x82EEC3A8;
    'dispatch: loop {
        match pc {
            0x82EEC3A8 => {
    //   block [0x82EEC3A8..0x82EEC3E4)
	// 82EEC3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC3B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC3B4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC3B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC3BC: 4800016D  bl 0x82eec528
	ctx.lr = 0x82EEC3C0;
	sub_82EEC528(ctx, base);
	// 82EEC3C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC3C4: 396BC2AC  addi r11, r11, -0x3d54
	ctx.r[11].s64 = ctx.r[11].s64 + -15700;
	// 82EEC3C8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC3CC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC3D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC3D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC3D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC3DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC3E8 size=60
    let mut pc: u32 = 0x82EEC3E8;
    'dispatch: loop {
        match pc {
            0x82EEC3E8 => {
    //   block [0x82EEC3E8..0x82EEC424)
	// 82EEC3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC3F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC3F4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC3F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEC3FC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC400: 48001AA9  bl 0x82eedea8
	ctx.lr = 0x82EEC404;
	sub_82EEDEA8(ctx, base);
	// 82EEC404: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC408: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EEC40C: 48000DC5  bl 0x82eed1d0
	ctx.lr = 0x82EEC410;
	sub_82EED1D0(ctx, base);
	// 82EEC410: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC414: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC41C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC428 size=68
    let mut pc: u32 = 0x82EEC428;
    'dispatch: loop {
        match pc {
            0x82EEC428 => {
    //   block [0x82EEC428..0x82EEC46C)
	// 82EEC428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC430: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC434: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC438: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC43C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC440: 48000031  bl 0x82eec470
	ctx.lr = 0x82EEC444;
	sub_82EEC470(ctx, base);
	// 82EEC444: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC448: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC44C: 4182000C  beq 0x82eec458
	if ctx.cr[0].eq {
	pc = 0x82EEC458; continue 'dispatch;
	}
	// 82EEC450: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC454: 4B95935D  bl 0x828457b0
	ctx.lr = 0x82EEC458;
	sub_828457B0(ctx, base);
	// 82EEC458: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC45C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC460: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC464: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC470 size=40
    let mut pc: u32 = 0x82EEC470;
    'dispatch: loop {
        match pc {
            0x82EEC470 => {
    //   block [0x82EEC470..0x82EEC498)
	// 82EEC470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC478: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC47C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC480: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC484: 4800163D  bl 0x82eedac0
	ctx.lr = 0x82EEC488;
	sub_82EEDAC0(ctx, base);
	// 82EEC488: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC48C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC498 size=28
    let mut pc: u32 = 0x82EEC498;
    'dispatch: loop {
        match pc {
            0x82EEC498 => {
    //   block [0x82EEC498..0x82EEC4B4)
	// 82EEC498: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC49C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC4A0: 396BC2C0  addi r11, r11, -0x3d40
	ctx.r[11].s64 = ctx.r[11].s64 + -15680;
	// 82EEC4A4: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC4A8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC4AC: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC4B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC4B8 size=68
    let mut pc: u32 = 0x82EEC4B8;
    'dispatch: loop {
        match pc {
            0x82EEC4B8 => {
    //   block [0x82EEC4B8..0x82EEC4FC)
	// 82EEC4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC4BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC4C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC4C4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC4C8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC4CC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC4D0: 48000031  bl 0x82eec500
	ctx.lr = 0x82EEC4D4;
	sub_82EEC500(ctx, base);
	// 82EEC4D4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC4D8: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC4DC: 4182000C  beq 0x82eec4e8
	if ctx.cr[0].eq {
	pc = 0x82EEC4E8; continue 'dispatch;
	}
	// 82EEC4E0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC4E4: 4B9592CD  bl 0x828457b0
	ctx.lr = 0x82EEC4E8;
	sub_828457B0(ctx, base);
	// 82EEC4E8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC4EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC4F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC4F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC4F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC500 size=40
    let mut pc: u32 = 0x82EEC500;
    'dispatch: loop {
        match pc {
            0x82EEC500 => {
    //   block [0x82EEC500..0x82EEC528)
	// 82EEC500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC508: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC50C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC510: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC514: 4800154D  bl 0x82eeda60
	ctx.lr = 0x82EEC518;
	sub_82EEDA60(ctx, base);
	// 82EEC518: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC51C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC528 size=28
    let mut pc: u32 = 0x82EEC528;
    'dispatch: loop {
        match pc {
            0x82EEC528 => {
    //   block [0x82EEC528..0x82EEC544)
	// 82EEC528: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC52C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC530: 396BC2DC  addi r11, r11, -0x3d24
	ctx.r[11].s64 = ctx.r[11].s64 + -15652;
	// 82EEC534: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC538: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC53C: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC540: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC548 size=160
    let mut pc: u32 = 0x82EEC548;
    'dispatch: loop {
        match pc {
            0x82EEC548 => {
    //   block [0x82EEC548..0x82EEC5E8)
	// 82EEC548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC54C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC550: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC554: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC558: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC55C: 396BC260  addi r11, r11, -0x3da0
	ctx.r[11].s64 = ctx.r[11].s64 + -15776;
	// 82EEC560: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC564: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC568: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC56C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC570: 48001601  bl 0x82eedb70
	ctx.lr = 0x82EEC574;
	sub_82EEDB70(ctx, base);
	// 82EEC574: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC578: 41820010  beq 0x82eec588
	if ctx.cr[0].eq {
	pc = 0x82EEC588; continue 'dispatch;
	}
	// 82EEC57C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC580: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC584: 4810101D  bl 0x82fed5a0
	ctx.lr = 0x82EEC588;
	sub_82FED5A0(ctx, base);
	// 82EEC588: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC58C: 386B0064  addi r3, r11, 0x64
	ctx.r[3].s64 = ctx.r[11].s64 + 100;
	// 82EEC590: 48003AC9  bl 0x82ef0058
	ctx.lr = 0x82EEC594;
	sub_82EF0058(ctx, base);
	// 82EEC594: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC598: 386B005C  addi r3, r11, 0x5c
	ctx.r[3].s64 = ctx.r[11].s64 + 92;
	// 82EEC59C: 48205415  bl 0x830f19b0
	ctx.lr = 0x82EEC5A0;
	sub_830F19B0(ctx, base);
	// 82EEC5A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5A4: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEC5A8: 48205409  bl 0x830f19b0
	ctx.lr = 0x82EEC5AC;
	sub_830F19B0(ctx, base);
	// 82EEC5AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5B0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC5B4: 481017FD  bl 0x82feddb0
	ctx.lr = 0x82EEC5B8;
	sub_82FEDDB0(ctx, base);
	// 82EEC5B8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5BC: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEC5C0: 4BFFFF41  bl 0x82eec500
	ctx.lr = 0x82EEC5C4;
	sub_82EEC500(ctx, base);
	// 82EEC5C4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5C8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEC5CC: 4BFFFEA5  bl 0x82eec470
	ctx.lr = 0x82EEC5D0;
	sub_82EEC470(ctx, base);
	// 82EEC5D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5D4: 4BFFFD7D  bl 0x82eec350
	ctx.lr = 0x82EEC5D8;
	sub_82EEC350(ctx, base);
	// 82EEC5D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC5E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC5E8 size=56
    let mut pc: u32 = 0x82EEC5E8;
    'dispatch: loop {
        match pc {
            0x82EEC5E8 => {
    //   block [0x82EEC5E8..0x82EEC620)
	// 82EEC5E8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC5EC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC5F0: 396B02EC  addi r11, r11, 0x2ec
	ctx.r[11].s64 = ctx.r[11].s64 + 748;
	// 82EEC5F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82EEC5F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC5FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82EEC600: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EEC604: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82EEC608: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC60C: 4082FFE8  bne 0x82eec5f4
	if !ctx.cr[0].eq {
	pc = 0x82EEC5F4; continue 'dispatch;
	}
	// 82EEC610: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EEC614: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEC618: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEC61C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC620 size=596
    let mut pc: u32 = 0x82EEC620;
    'dispatch: loop {
        match pc {
            0x82EEC620 => {
    //   block [0x82EEC620..0x82EEC874)
	// 82EEC620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EEC62C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC630: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC634: 906100C4  stw r3, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82EEC638: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC63C: 816B8F58  lwz r11, -0x70a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC640: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC644: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEC648: 419A004C  beq cr6, 0x82eec694
	if ctx.cr[6].eq {
	pc = 0x82EEC694; continue 'dispatch;
	}
	// 82EEC64C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC650: 896B8F65  lbz r11, -0x709b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28827 as u32) ) } as u64;
	// 82EEC654: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC658: 4082003C  bne 0x82eec694
	if !ctx.cr[0].eq {
	pc = 0x82EEC694; continue 'dispatch;
	}
	// 82EEC65C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC660: 3BEB8F65  addi r31, r11, -0x709b
	ctx.r[31].s64 = ctx.r[11].s64 + -28827;
	// 82EEC664: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC668: 38CBC360  addi r6, r11, -0x3ca0
	ctx.r[6].s64 = ctx.r[11].s64 + -15520;
	// 82EEC66C: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 82EEC670: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC674: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC678: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEC67C: 4BFFEAED  bl 0x82eeb168
	ctx.lr = 0x82EEC680;
	sub_82EEB168(ctx, base);
	// 82EEC680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC684: 48205735  bl 0x830f1db8
	ctx.lr = 0x82EEC688;
	sub_830F1DB8(ctx, base);
	// 82EEC688: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC68C: 40820008  bne 0x82eec694
	if !ctx.cr[0].eq {
	pc = 0x82EEC694; continue 'dispatch;
	}
	// 82EEC690: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEC694: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC698: 816B02EC  lwz r11, 0x2ec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(748 as u32) ) } as u64;
	// 82EEC69C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC6A0: 4199004C  bgt cr6, 0x82eec6ec
	if ctx.cr[6].gt {
	pc = 0x82EEC6EC; continue 'dispatch;
	}
	// 82EEC6A4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC6A8: 896B8F64  lbz r11, -0x709c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28828 as u32) ) } as u64;
	// 82EEC6AC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC6B0: 4082003C  bne 0x82eec6ec
	if !ctx.cr[0].eq {
	pc = 0x82EEC6EC; continue 'dispatch;
	}
	// 82EEC6B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC6B8: 3BEB8F64  addi r31, r11, -0x709c
	ctx.r[31].s64 = ctx.r[11].s64 + -28828;
	// 82EEC6BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC6C0: 38CBC34C  addi r6, r11, -0x3cb4
	ctx.r[6].s64 = ctx.r[11].s64 + -15540;
	// 82EEC6C4: 38A0007B  li r5, 0x7b
	ctx.r[5].s64 = 123;
	// 82EEC6C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC6CC: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC6D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEC6D4: 4BFFEA95  bl 0x82eeb168
	ctx.lr = 0x82EEC6D8;
	sub_82EEB168(ctx, base);
	// 82EEC6D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC6DC: 482056DD  bl 0x830f1db8
	ctx.lr = 0x82EEC6E0;
	sub_830F1DB8(ctx, base);
	// 82EEC6E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC6E4: 40820008  bne 0x82eec6ec
	if !ctx.cr[0].eq {
	pc = 0x82EEC6EC; continue 'dispatch;
	}
	// 82EEC6E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEC6EC: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC6F0: 396B02EC  addi r11, r11, 0x2ec
	ctx.r[11].s64 = ctx.r[11].s64 + 748;
	// 82EEC6F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82EEC6F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC6FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82EEC700: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EEC704: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82EEC708: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC70C: 4082FFE8  bne 0x82eec6f4
	if !ctx.cr[0].eq {
	pc = 0x82EEC6F4; continue 'dispatch;
	}
	// 82EEC710: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EEC714: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEC718: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEC71C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEC720: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEC724: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC728: 409A0130  bne cr6, 0x82eec858
	if !ctx.cr[6].eq {
	pc = 0x82EEC858; continue 'dispatch;
	}
	// 82EEC72C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC730: 816B8F58  lwz r11, -0x70a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC734: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC738: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEC73C: 409A011C  bne cr6, 0x82eec858
	if !ctx.cr[6].eq {
	pc = 0x82EEC858; continue 'dispatch;
	}
	// 82EEC740: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC744: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEC748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC74C: 419A0058  beq cr6, 0x82eec7a4
	if ctx.cr[6].eq {
	pc = 0x82EEC7A4; continue 'dispatch;
	}
	// 82EEC750: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC754: 896B8F63  lbz r11, -0x709d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28829 as u32) ) } as u64;
	// 82EEC758: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC75C: 40820048  bne 0x82eec7a4
	if !ctx.cr[0].eq {
	pc = 0x82EEC7A4; continue 'dispatch;
	}
	// 82EEC760: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC764: 3BEBC308  addi r31, r11, -0x3cf8
	ctx.r[31].s64 = ctx.r[11].s64 + -15608;
	// 82EEC768: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC76C: 3BCB8F63  addi r30, r11, -0x709d
	ctx.r[30].s64 = ctx.r[11].s64 + -28829;
	// 82EEC770: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC774: 38CBC2F0  addi r6, r11, -0x3d10
	ctx.r[6].s64 = ctx.r[11].s64 + -15632;
	// 82EEC778: 38A00084  li r5, 0x84
	ctx.r[5].s64 = 132;
	// 82EEC77C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC780: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC784: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEC788: 4BFFE9E1  bl 0x82eeb168
	ctx.lr = 0x82EEC78C;
	sub_82EEB168(ctx, base);
	// 82EEC78C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EEC790: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEC794: 482056FD  bl 0x830f1e90
	ctx.lr = 0x82EEC798;
	sub_830F1E90(ctx, base);
	// 82EEC798: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC79C: 40820008  bne 0x82eec7a4
	if !ctx.cr[0].eq {
	pc = 0x82EEC7A4; continue 'dispatch;
	}
	// 82EEC7A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEC7A4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC7A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEC7AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC7B0: 419A0038  beq cr6, 0x82eec7e8
	if ctx.cr[6].eq {
	pc = 0x82EEC7E8; continue 'dispatch;
	}
	// 82EEC7B4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC7B8: 396B02EC  addi r11, r11, 0x2ec
	ctx.r[11].s64 = ctx.r[11].s64 + 748;
	// 82EEC7BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82EEC7C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC7C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82EEC7C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EEC7CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82EEC7D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC7D4: 4082FFE8  bne 0x82eec7bc
	if !ctx.cr[0].eq {
	pc = 0x82EEC7BC; continue 'dispatch;
	}
	// 82EEC7D8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EEC7DC: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEC7E0: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEC7E4: 48000078  b 0x82eec85c
	pc = 0x82EEC85C; continue 'dispatch;
	// 82EEC7E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEC7EC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC7F0: 816B8F58  lwz r11, -0x70a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC7F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC7F8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC7FC: 806A8F58  lwz r3, -0x70a8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC800: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC804: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC808: 4E800421  bctrl
	ctx.lr = 0x82EEC80C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC80C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC810: 808B8F58  lwz r4, -0x70a8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC814: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC818: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEC81C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC820: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC824: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEC828: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEC82C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC830: 4E800421  bctrl
	ctx.lr = 0x82EEC834;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC834: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC838: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC83C: 914B8F58  stw r10, -0x70a8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28840 as u32), ctx.r[10].u32 ) };
	// 82EEC840: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC844: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC848: 914B8F50  stw r10, -0x70b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28848 as u32), ctx.r[10].u32 ) };
	// 82EEC84C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC850: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC854: 914B8F54  stw r10, -0x70ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28844 as u32), ctx.r[10].u32 ) };
	// 82EEC858: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEC85C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EEC860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC868: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EEC86C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEC870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC878 size=128
    let mut pc: u32 = 0x82EEC878;
    'dispatch: loop {
        match pc {
            0x82EEC878 => {
    //   block [0x82EEC878..0x82EEC8F8)
	// 82EEC878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC880: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC884: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC888: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC88C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEC890: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEC894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC898: 409A0010  bne cr6, 0x82eec8a8
	if !ctx.cr[6].eq {
	pc = 0x82EEC8A8; continue 'dispatch;
	}
	// 82EEC89C: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEC8A0: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EEC8A4: 48000044  b 0x82eec8e8
	pc = 0x82EEC8E8; continue 'dispatch;
	// 82EEC8A8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82EEC8AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEC8B0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC8B4: 48001175  bl 0x82eeda28
	ctx.lr = 0x82EEC8B8;
	sub_82EEDA28(ctx, base);
	// 82EEC8B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC8BC: 40820010  bne 0x82eec8cc
	if !ctx.cr[0].eq {
	pc = 0x82EEC8CC; continue 'dispatch;
	}
	// 82EEC8C0: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEC8C4: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EEC8C8: 48000020  b 0x82eec8e8
	pc = 0x82EEC8E8; continue 'dispatch;
	// 82EEC8CC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EEC8D0: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEC8D4: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC8D8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC8DC: 386B0064  addi r3, r11, 0x64
	ctx.r[3].s64 = ctx.r[11].s64 + 100;
	// 82EEC8E0: 48001769  bl 0x82eee048
	ctx.lr = 0x82EEC8E4;
	sub_82EEE048(ctx, base);
	// 82EEC8E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEC8E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC8EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC8F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC8F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EEC8F8 size=1144
    let mut pc: u32 = 0x82EEC8F8;
    'dispatch: loop {
        match pc {
            0x82EEC8F8 => {
    //   block [0x82EEC8F8..0x82EECD70)
	// 82EEC8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC900: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC904: 9421FB00  stwu r1, -0x500(r1)
	ea = ctx.r[1].u32.wrapping_add(-1280 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC908: 90610514  stw r3, 0x514(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1300 as u32), ctx.r[3].u32 ) };
	// 82EEC90C: 9081051C  stw r4, 0x51c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1308 as u32), ctx.r[4].u32 ) };
	// 82EEC910: 90A10524  stw r5, 0x524(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1316 as u32), ctx.r[5].u32 ) };
	// 82EEC914: 90C1052C  stw r6, 0x52c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1324 as u32), ctx.r[6].u32 ) };
	// 82EEC918: 90E10534  stw r7, 0x534(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1332 as u32), ctx.r[7].u32 ) };
	// 82EEC91C: 9101053C  stw r8, 0x53c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1340 as u32), ctx.r[8].u32 ) };
	// 82EEC920: 91210544  stw r9, 0x544(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1348 as u32), ctx.r[9].u32 ) };
	// 82EEC924: 9141054C  stw r10, 0x54c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1356 as u32), ctx.r[10].u32 ) };
	// 82EEC928: 8161052C  lwz r11, 0x52c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82EEC92C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC930: 419A0010  beq cr6, 0x82eec940
	if ctx.cr[6].eq {
	pc = 0x82EEC940; continue 'dispatch;
	}
	// 82EEC934: 8161054C  lwz r11, 0x54c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82EEC938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC93C: 409A0010  bne cr6, 0x82eec94c
	if !ctx.cr[6].eq {
	pc = 0x82EEC94C; continue 'dispatch;
	}
	// 82EEC940: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEC944: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EEC948: 48000414  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
	// 82EEC94C: 8061054C  lwz r3, 0x54c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82EEC950: 48205731  bl 0x830f2080
	ctx.lr = 0x82EEC954;
	sub_830F2080(ctx, base);
	// 82EEC954: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EEC958: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EEC95C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC960: 40980010  bge cr6, 0x82eec970
	if !ctx.cr[6].lt {
	pc = 0x82EEC970; continue 'dispatch;
	}
	// 82EEC964: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EEC968: 6163FFFF  ori r3, r11, 0xffff
	ctx.r[3].u64 = ctx.r[11].u64 | 65535;
	// 82EEC96C: 480003F0  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
	// 82EEC970: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC974: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82EEC978: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EEC97C: 80E10544  lwz r7, 0x544(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1348 as u32) ) } as u64;
	// 82EEC980: 80C1053C  lwz r6, 0x53c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82EEC984: 80A10534  lwz r5, 0x534(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1332 as u32) ) } as u64;
	// 82EEC988: 8081052C  lwz r4, 0x52c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82EEC98C: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EEC990: 80610514  lwz r3, 0x514(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EEC994: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82EEC998: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EEC99C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEC9A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC9A4: 4E800421  bctrl
	ctx.lr = 0x82EEC9A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC9A8: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EEC9AC: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EEC9B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC9B4: 4098004C  bge cr6, 0x82eeca00
	if !ctx.cr[6].lt {
	pc = 0x82EECA00; continue 'dispatch;
	}
	// 82EEC9B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC9BC: 896B8F66  lbz r11, -0x709a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28826 as u32) ) } as u64;
	// 82EEC9C0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC9C4: 4082003C  bne 0x82eeca00
	if !ctx.cr[0].eq {
	pc = 0x82EECA00; continue 'dispatch;
	}
	// 82EEC9C8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC9CC: 3BEB8F66  addi r31, r11, -0x709a
	ctx.r[31].s64 = ctx.r[11].s64 + -28826;
	// 82EEC9D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC9D4: 38CBC464  addi r6, r11, -0x3b9c
	ctx.r[6].s64 = ctx.r[11].s64 + -15260;
	// 82EEC9D8: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 82EEC9DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC9E0: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC9E4: 386104C8  addi r3, r1, 0x4c8
	ctx.r[3].s64 = ctx.r[1].s64 + 1224;
	// 82EEC9E8: 4BFFE781  bl 0x82eeb168
	ctx.lr = 0x82EEC9EC;
	sub_82EEB168(ctx, base);
	// 82EEC9EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC9F0: 482053C9  bl 0x830f1db8
	ctx.lr = 0x82EEC9F4;
	sub_830F1DB8(ctx, base);
	// 82EEC9F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC9F8: 40820008  bne 0x82eeca00
	if !ctx.cr[0].eq {
	pc = 0x82EECA00; continue 'dispatch;
	}
	// 82EEC9FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EECA00: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECA04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECA08: 4098000C  bge cr6, 0x82eeca14
	if !ctx.cr[6].lt {
	pc = 0x82EECA14; continue 'dispatch;
	}
	// 82EECA0C: 80610474  lwz r3, 0x474(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECA10: 4800034C  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
	// 82EECA14: 80810524  lwz r4, 0x524(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1316 as u32) ) } as u64;
	// 82EECA18: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECA1C: 386B02E4  addi r3, r11, 0x2e4
	ctx.r[3].s64 = ctx.r[11].s64 + 740;
	// 82EECA20: 4811C681  bl 0x830090a0
	ctx.lr = 0x82EECA24;
	sub_830090A0(ctx, base);
	// 82EECA24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EECA28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECA2C: 388BC460  addi r4, r11, -0x3ba0
	ctx.r[4].s64 = ctx.r[11].s64 + -15264;
	// 82EECA30: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECA34: 386B02E4  addi r3, r11, 0x2e4
	ctx.r[3].s64 = ctx.r[11].s64 + 740;
	// 82EECA38: 48000F89  bl 0x82eed9c0
	ctx.lr = 0x82EECA3C;
	sub_82EED9C0(ctx, base);
	// 82EECA3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EECA40: 40820060  bne 0x82eecaa0
	if !ctx.cr[0].eq {
	pc = 0x82EECAA0; continue 'dispatch;
	}
	// 82EECA44: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECA48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECA4C: 38ABC450  addi r5, r11, -0x3bb0
	ctx.r[5].s64 = ctx.r[11].s64 + -15280;
	// 82EECA50: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECA54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EECA58: 4BFFE5F1  bl 0x82eeb048
	ctx.lr = 0x82EECA5C;
	sub_82EEB048(ctx, base);
	// 82EECA5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EECA60: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECA64: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECA68: 48100669  bl 0x82fed0d0
	ctx.lr = 0x82EECA6C;
	sub_82FED0D0(ctx, base);
	// 82EECA6C: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECA70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EECA74: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EECA78: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EECA7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECA80: 38ABC43C  addi r5, r11, -0x3bc4
	ctx.r[5].s64 = ctx.r[11].s64 + -15300;
	// 82EECA84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECA88: 388BC430  addi r4, r11, -0x3bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -15312;
	// 82EECA8C: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECA90: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECA94: 481006BD  bl 0x82fed150
	ctx.lr = 0x82EECA98;
	sub_82FED150(ctx, base);
	// 82EECA98: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECA9C: 48000154  b 0x82eecbf0
	pc = 0x82EECBF0; continue 'dispatch;
	// 82EECAA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EECAA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECAA8: 388BC42C  addi r4, r11, -0x3bd4
	ctx.r[4].s64 = ctx.r[11].s64 + -15316;
	// 82EECAAC: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECAB0: 386B02E4  addi r3, r11, 0x2e4
	ctx.r[3].s64 = ctx.r[11].s64 + 740;
	// 82EECAB4: 48000F0D  bl 0x82eed9c0
	ctx.lr = 0x82EECAB8;
	sub_82EED9C0(ctx, base);
	// 82EECAB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EECABC: 40820060  bne 0x82eecb1c
	if !ctx.cr[0].eq {
	pc = 0x82EECB1C; continue 'dispatch;
	}
	// 82EECAC0: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECAC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECAC8: 38ABC41C  addi r5, r11, -0x3be4
	ctx.r[5].s64 = ctx.r[11].s64 + -15332;
	// 82EECACC: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECAD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EECAD4: 4BFFE575  bl 0x82eeb048
	ctx.lr = 0x82EECAD8;
	sub_82EEB048(ctx, base);
	// 82EECAD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EECADC: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECAE0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECAE4: 481005ED  bl 0x82fed0d0
	ctx.lr = 0x82EECAE8;
	sub_82FED0D0(ctx, base);
	// 82EECAE8: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECAEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EECAF0: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EECAF4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EECAF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECAFC: 38ABC40C  addi r5, r11, -0x3bf4
	ctx.r[5].s64 = ctx.r[11].s64 + -15348;
	// 82EECB00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB04: 388BC430  addi r4, r11, -0x3bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -15312;
	// 82EECB08: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECB0C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECB10: 48100641  bl 0x82fed150
	ctx.lr = 0x82EECB14;
	sub_82FED150(ctx, base);
	// 82EECB14: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECB18: 480000D8  b 0x82eecbf0
	pc = 0x82EECBF0; continue 'dispatch;
	// 82EECB1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EECB20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB24: 388BC408  addi r4, r11, -0x3bf8
	ctx.r[4].s64 = ctx.r[11].s64 + -15352;
	// 82EECB28: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECB2C: 386B02E4  addi r3, r11, 0x2e4
	ctx.r[3].s64 = ctx.r[11].s64 + 740;
	// 82EECB30: 48000E91  bl 0x82eed9c0
	ctx.lr = 0x82EECB34;
	sub_82EED9C0(ctx, base);
	// 82EECB34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EECB38: 40820060  bne 0x82eecb98
	if !ctx.cr[0].eq {
	pc = 0x82EECB98; continue 'dispatch;
	}
	// 82EECB3C: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECB40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB44: 38ABC3F8  addi r5, r11, -0x3c08
	ctx.r[5].s64 = ctx.r[11].s64 + -15368;
	// 82EECB48: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECB4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EECB50: 4BFFE4F9  bl 0x82eeb048
	ctx.lr = 0x82EECB54;
	sub_82EEB048(ctx, base);
	// 82EECB54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EECB58: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECB5C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECB60: 48100571  bl 0x82fed0d0
	ctx.lr = 0x82EECB64;
	sub_82FED0D0(ctx, base);
	// 82EECB64: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECB68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EECB6C: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EECB70: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EECB74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB78: 38ABC3E8  addi r5, r11, -0x3c18
	ctx.r[5].s64 = ctx.r[11].s64 + -15384;
	// 82EECB7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB80: 388BC430  addi r4, r11, -0x3bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -15312;
	// 82EECB84: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECB88: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECB8C: 481005C5  bl 0x82fed150
	ctx.lr = 0x82EECB90;
	sub_82FED150(ctx, base);
	// 82EECB90: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECB94: 4800005C  b 0x82eecbf0
	pc = 0x82EECBF0; continue 'dispatch;
	// 82EECB98: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECB9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECBA0: 38ABC3D8  addi r5, r11, -0x3c28
	ctx.r[5].s64 = ctx.r[11].s64 + -15400;
	// 82EECBA4: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECBA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EECBAC: 4BFFE49D  bl 0x82eeb048
	ctx.lr = 0x82EECBB0;
	sub_82EEB048(ctx, base);
	// 82EECBB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EECBB4: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECBB8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECBBC: 48100515  bl 0x82fed0d0
	ctx.lr = 0x82EECBC0;
	sub_82FED0D0(ctx, base);
	// 82EECBC0: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECBC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EECBC8: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EECBCC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EECBD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECBD4: 38ABC3C4  addi r5, r11, -0x3c3c
	ctx.r[5].s64 = ctx.r[11].s64 + -15420;
	// 82EECBD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECBDC: 388BC430  addi r4, r11, -0x3bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -15312;
	// 82EECBE0: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECBE4: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECBE8: 48100569  bl 0x82fed150
	ctx.lr = 0x82EECBEC;
	sub_82FED150(ctx, base);
	// 82EECBEC: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECBF0: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECBF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECBF8: 4098000C  bge cr6, 0x82eecc04
	if !ctx.cr[6].lt {
	pc = 0x82EECC04; continue 'dispatch;
	}
	// 82EECBFC: 80610474  lwz r3, 0x474(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECC00: 4800015C  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
	// 82EECC04: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECC08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECC0C: 38ABC3B4  addi r5, r11, -0x3c4c
	ctx.r[5].s64 = ctx.r[11].s64 + -15436;
	// 82EECC10: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECC14: 38610370  addi r3, r1, 0x370
	ctx.r[3].s64 = ctx.r[1].s64 + 880;
	// 82EECC18: 4BFFE431  bl 0x82eeb048
	ctx.lr = 0x82EECC1C;
	sub_82EEB048(ctx, base);
	// 82EECC1C: 396104D4  addi r11, r1, 0x4d4
	ctx.r[11].s64 = ctx.r[1].s64 + 1236;
	// 82EECC20: 916104D8  stw r11, 0x4d8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1240 as u32), ctx.r[11].u32 ) };
	// 82EECC24: 806104D8  lwz r3, 0x4d8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EECC28: 48000871  bl 0x82eed498
	ctx.lr = 0x82EECC2C;
	sub_82EED498(ctx, base);
	// 82EECC2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EECC30: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC34: 480005ED  bl 0x82eed220
	ctx.lr = 0x82EECC38;
	sub_82EED220(ctx, base);
	// 82EECC38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EECC3C: 38810370  addi r4, r1, 0x370
	ctx.r[4].s64 = ctx.r[1].s64 + 880;
	// 82EECC40: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC44: 4800066D  bl 0x82eed2b0
	ctx.lr = 0x82EECC48;
	sub_82EED2B0(ctx, base);
	// 82EECC48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECC4C: 388BC3AC  addi r4, r11, -0x3c54
	ctx.r[4].s64 = ctx.r[11].s64 + -15444;
	// 82EECC50: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC54: 480032CD  bl 0x82eeff20
	ctx.lr = 0x82EECC58;
	sub_82EEFF20(ctx, base);
	// 82EECC58: 90610368  stw r3, 0x368(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(872 as u32), ctx.r[3].u32 ) };
	// 82EECC5C: 81610368  lwz r11, 0x368(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(872 as u32) ) } as u64;
	// 82EECC60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECC64: 4098001C  bge cr6, 0x82eecc80
	if !ctx.cr[6].lt {
	pc = 0x82EECC80; continue 'dispatch;
	}
	// 82EECC68: 81610368  lwz r11, 0x368(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(872 as u32) ) } as u64;
	// 82EECC6C: 916104DC  stw r11, 0x4dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1244 as u32), ctx.r[11].u32 ) };
	// 82EECC70: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC74: 48000605  bl 0x82eed278
	ctx.lr = 0x82EECC78;
	sub_82EED278(ctx, base);
	// 82EECC78: 806104DC  lwz r3, 0x4dc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1244 as u32) ) } as u64;
	// 82EECC7C: 480000E0  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
	// 82EECC80: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC84: 480007E5  bl 0x82eed468
	ctx.lr = 0x82EECC88;
	sub_82EED468(ctx, base);
	// 82EECC88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EECC8C: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECC90: 81410514  lwz r10, 0x514(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECC94: 386A0054  addi r3, r10, 0x54
	ctx.r[3].s64 = ctx.r[10].s64 + 84;
	// 82EECC98: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EECC9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EECCA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECCA4: 4E800421  bctrl
	ctx.lr = 0x82EECCA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECCA8: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECCAC: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECCB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECCB4: 4098001C  bge cr6, 0x82eeccd0
	if !ctx.cr[6].lt {
	pc = 0x82EECCD0; continue 'dispatch;
	}
	// 82EECCB8: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECCBC: 916104E0  stw r11, 0x4e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1248 as u32), ctx.r[11].u32 ) };
	// 82EECCC0: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECCC4: 480005B5  bl 0x82eed278
	ctx.lr = 0x82EECCC8;
	sub_82EED278(ctx, base);
	// 82EECCC8: 806104E0  lwz r3, 0x4e0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1248 as u32) ) } as u64;
	// 82EECCCC: 48000090  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
	// 82EECCD0: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECCD4: 38EB02E4  addi r7, r11, 0x2e4
	ctx.r[7].s64 = ctx.r[11].s64 + 740;
	// 82EECCD8: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECCDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECCE0: 38ABC37C  addi r5, r11, -0x3c84
	ctx.r[5].s64 = ctx.r[11].s64 + -15492;
	// 82EECCE4: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECCE8: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82EECCEC: 4BFFE4FD  bl 0x82eeb1e8
	ctx.lr = 0x82EECCF0;
	sub_82EEB1E8(ctx, base);
	// 82EECCF0: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 82EECCF4: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECCF8: 81410514  lwz r10, 0x514(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECCFC: 386A005C  addi r3, r10, 0x5c
	ctx.r[3].s64 = ctx.r[10].s64 + 92;
	// 82EECD00: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EECD04: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EECD08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECD0C: 4E800421  bctrl
	ctx.lr = 0x82EECD10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECD10: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECD14: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECD18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECD1C: 4098001C  bge cr6, 0x82eecd38
	if !ctx.cr[6].lt {
	pc = 0x82EECD38; continue 'dispatch;
	}
	// 82EECD20: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECD24: 916104E4  stw r11, 0x4e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1252 as u32), ctx.r[11].u32 ) };
	// 82EECD28: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECD2C: 4800054D  bl 0x82eed278
	ctx.lr = 0x82EECD30;
	sub_82EED278(ctx, base);
	// 82EECD30: 806104E4  lwz r3, 0x4e4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1252 as u32) ) } as u64;
	// 82EECD34: 48000028  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
	// 82EECD38: 8081051C  lwz r4, 0x51c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECD3C: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECD40: 386B01E0  addi r3, r11, 0x1e0
	ctx.r[3].s64 = ctx.r[11].s64 + 480;
	// 82EECD44: 482045ED  bl 0x830f1330
	ctx.lr = 0x82EECD48;
	sub_830F1330(ctx, base);
	// 82EECD48: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECD4C: 916104E8  stw r11, 0x4e8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1256 as u32), ctx.r[11].u32 ) };
	// 82EECD50: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECD54: 48000525  bl 0x82eed278
	ctx.lr = 0x82EECD58;
	sub_82EED278(ctx, base);
	// 82EECD58: 806104E8  lwz r3, 0x4e8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1256 as u32) ) } as u64;
	// 82EECD5C: 38210500  addi r1, r1, 0x500
	ctx.r[1].s64 = ctx.r[1].s64 + 1280;
	// 82EECD60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EECD64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EECD68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EECD6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EECD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EECD70 size=768
    let mut pc: u32 = 0x82EECD70;
    'dispatch: loop {
        match pc {
            0x82EECD70 => {
    //   block [0x82EECD70..0x82EED070)
	// 82EECD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EECD74: 4BDBC681  bl 0x82ca93f4
	ctx.lr = 0x82EECD78;
	sub_82CA93D0(ctx, base);
	// 82EECD78: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EECD7C: 90610234  stw r3, 0x234(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(564 as u32), ctx.r[3].u32 ) };
	// 82EECD80: 9081023C  stw r4, 0x23c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(572 as u32), ctx.r[4].u32 ) };
	// 82EECD84: 90A10244  stw r5, 0x244(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(580 as u32), ctx.r[5].u32 ) };
	// 82EECD88: 90C1024C  stw r6, 0x24c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(588 as u32), ctx.r[6].u32 ) };
	// 82EECD8C: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECD90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EECD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECD98: 419A0010  beq cr6, 0x82eecda8
	if ctx.cr[6].eq {
	pc = 0x82EECDA8; continue 'dispatch;
	}
	// 82EECD9C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EECDA0: 6163FFFF  ori r3, r11, 0xffff
	ctx.r[3].u64 = ctx.r[11].u64 | 65535;
	// 82EECDA4: 480002C4  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
	// 82EECDA8: 8161023C  lwz r11, 0x23c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EECDAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECDB0: 419A002C  beq cr6, 0x82eecddc
	if ctx.cr[6].eq {
	pc = 0x82EECDDC; continue 'dispatch;
	}
	// 82EECDB4: 81610244  lwz r11, 0x244(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EECDB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECDBC: 419A0020  beq cr6, 0x82eecddc
	if ctx.cr[6].eq {
	pc = 0x82EECDDC; continue 'dispatch;
	}
	// 82EECDC0: 8161024C  lwz r11, 0x24c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EECDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECDC8: 419A0014  beq cr6, 0x82eecddc
	if ctx.cr[6].eq {
	pc = 0x82EECDDC; continue 'dispatch;
	}
	// 82EECDCC: 8161024C  lwz r11, 0x24c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EECDD0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECDD8: 419A0010  beq cr6, 0x82eecde8
	if ctx.cr[6].eq {
	pc = 0x82EECDE8; continue 'dispatch;
	}
	// 82EECDDC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EECDE0: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EECDE4: 48000284  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
	// 82EECDE8: 80C1023C  lwz r6, 0x23c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EECDEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECDF0: 38ABC47C  addi r5, r11, -0x3b84
	ctx.r[5].s64 = ctx.r[11].s64 + -15236;
	// 82EECDF4: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECDF8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82EECDFC: 4BFFE24D  bl 0x82eeb048
	ctx.lr = 0x82EECE00;
	sub_82EEB048(ctx, base);
	// 82EECE00: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECE04: 4800897D  bl 0x82ef5780
	ctx.lr = 0x82EECE08;
	sub_82EF5780(ctx, base);
	// 82EECE08: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECE0C: 48008975  bl 0x82ef5780
	ctx.lr = 0x82EECE10;
	sub_82EF5780(ctx, base);
	// 82EECE10: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECE14: 48117D95  bl 0x83004ba8
	ctx.lr = 0x82EECE18;
	sub_83004BA8(ctx, base);
	// 82EECE18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EECE1C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECE20: 48117D89  bl 0x83004ba8
	ctx.lr = 0x82EECE24;
	sub_83004BA8(ctx, base);
	// 82EECE24: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EECE28: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EECE2C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EECE30: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECE34: 81410234  lwz r10, 0x234(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECE38: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 82EECE3C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EECE40: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EECE44: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EECE48: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EECE4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECE50: 4E800421  bctrl
	ctx.lr = 0x82EECE54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECE54: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EECE58: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EECE5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECE60: 40980028  bge cr6, 0x82eece88
	if !ctx.cr[6].lt {
	pc = 0x82EECE88; continue 'dispatch;
	}
	// 82EECE64: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EECE68: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EECE6C: 916101B4  stw r11, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 82EECE70: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECE74: 4800709D  bl 0x82ef3f10
	ctx.lr = 0x82EECE78;
	sub_82EF3F10(ctx, base);
	// 82EECE78: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECE7C: 48006FE5  bl 0x82ef3e60
	ctx.lr = 0x82EECE80;
	sub_82EF3E60(ctx, base);
	// 82EECE80: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EECE84: 480001E4  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
	// 82EECE88: 38800508  li r4, 0x508
	ctx.r[4].s64 = 1288;
	// 82EECE8C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EECE90: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EECE94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECE98: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EECE9C: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EECEA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECEA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECEA8: 4E800421  bctrl
	ctx.lr = 0x82EECEAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECEAC: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 82EECEB0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EECEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECEB8: 409A0028  bne cr6, 0x82eecee0
	if !ctx.cr[6].eq {
	pc = 0x82EECEE0; continue 'dispatch;
	}
	// 82EECEBC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EECEC0: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 82EECEC4: 916101B8  stw r11, 0x1b8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EECEC8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECECC: 48007045  bl 0x82ef3f10
	ctx.lr = 0x82EECED0;
	sub_82EF3F10(ctx, base);
	// 82EECED0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECED4: 48006F8D  bl 0x82ef3e60
	ctx.lr = 0x82EECED8;
	sub_82EF3E60(ctx, base);
	// 82EECED8: 806101B8  lwz r3, 0x1b8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EECEDC: 4800018C  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
	// 82EECEE0: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EECEE4: 38600508  li r3, 0x508
	ctx.r[3].s64 = 1288;
	// 82EECEE8: 48000189  bl 0x82eed070
	ctx.lr = 0x82EECEEC;
	sub_82EED070(ctx, base);
	// 82EECEEC: 906101BC  stw r3, 0x1bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), ctx.r[3].u32 ) };
	// 82EECEF0: 816101BC  lwz r11, 0x1bc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EECEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECEF8: 419A0018  beq cr6, 0x82eecf10
	if ctx.cr[6].eq {
	pc = 0x82EECF10; continue 'dispatch;
	}
	// 82EECEFC: 80810234  lwz r4, 0x234(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF00: 806101BC  lwz r3, 0x1bc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EECF04: 48008B4D  bl 0x82ef5a50
	ctx.lr = 0x82EECF08;
	sub_82EF5A50(ctx, base);
	// 82EECF08: 906101C8  stw r3, 0x1c8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[3].u32 ) };
	// 82EECF0C: 4800000C  b 0x82eecf18
	pc = 0x82EECF18; continue 'dispatch;
	// 82EECF10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EECF14: 916101C8  stw r11, 0x1c8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	// 82EECF18: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF1C: 814101C8  lwz r10, 0x1c8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(456 as u32) ) } as u64;
	// 82EECF20: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EECF24: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF28: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82EECF2C: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF30: 3BCB0064  addi r30, r11, 0x64
	ctx.r[30].s64 = ctx.r[11].s64 + 100;
	// 82EECF34: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF38: 3BAB02E4  addi r29, r11, 0x2e4
	ctx.r[29].s64 = ctx.r[11].s64 + 740;
	// 82EECF3C: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF40: 3B8B01E0  addi r28, r11, 0x1e0
	ctx.r[28].s64 = ctx.r[11].s64 + 480;
	// 82EECF44: 8361023C  lwz r27, 0x23c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EECF48: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF4C: 81410234  lwz r10, 0x234(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF50: 386A005C  addi r3, r10, 0x5c
	ctx.r[3].s64 = ctx.r[10].s64 + 92;
	// 82EECF54: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EECF58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECF5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECF60: 4E800421  bctrl
	ctx.lr = 0x82EECF64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECF64: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EECF68: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF6C: 81410234  lwz r10, 0x234(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF70: 386A0054  addi r3, r10, 0x54
	ctx.r[3].s64 = ctx.r[10].s64 + 84;
	// 82EECF74: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EECF78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECF7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECF80: 4E800421  bctrl
	ctx.lr = 0x82EECF84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECF84: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EECF88: 83010244  lwz r24, 0x244(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EECF8C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECF90: 48000231  bl 0x82eed1c0
	ctx.lr = 0x82EECF94;
	sub_82EED1C0(ctx, base);
	// 82EECF94: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82EECF98: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECF9C: 48000225  bl 0x82eed1c0
	ctx.lr = 0x82EECFA0;
	sub_82EED1C0(ctx, base);
	// 82EECFA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EECFA4: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECFA8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EECFAC: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82EECFB0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EECFB4: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82EECFB8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EECFBC: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EECFC0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82EECFC4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EECFC8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EECFCC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82EECFD0: 48003559  bl 0x82ef0528
	ctx.lr = 0x82EECFD4;
	sub_82EF0528(ctx, base);
	// 82EECFD4: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EECFD8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EECFDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECFE0: 40980034  bge cr6, 0x82eed014
	if !ctx.cr[6].lt {
	pc = 0x82EED014; continue 'dispatch;
	}
	// 82EECFE4: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECFE8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EECFEC: 80610234  lwz r3, 0x234(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECFF0: 48000091  bl 0x82eed080
	ctx.lr = 0x82EECFF4;
	sub_82EED080(ctx, base);
	// 82EECFF4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EECFF8: 916101C0  stw r11, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82EECFFC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EED000: 48006F11  bl 0x82ef3f10
	ctx.lr = 0x82EED004;
	sub_82EF3F10(ctx, base);
	// 82EED004: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EED008: 48006E59  bl 0x82ef3e60
	ctx.lr = 0x82EED00C;
	sub_82EF3E60(ctx, base);
	// 82EED00C: 806101C0  lwz r3, 0x1c0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EED010: 48000058  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
	// 82EED014: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EED018: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED020: 419A0018  beq cr6, 0x82eed038
	if ctx.cr[6].eq {
	pc = 0x82EED038; continue 'dispatch;
	}
	// 82EED024: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EED028: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED02C: 396B04F8  addi r11, r11, 0x4f8
	ctx.r[11].s64 = ctx.r[11].s64 + 1272;
	// 82EED030: 916101CC  stw r11, 0x1cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 82EED034: 4800000C  b 0x82eed040
	pc = 0x82EED040; continue 'dispatch;
	// 82EED038: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED03C: 916101CC  stw r11, 0x1cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 82EED040: 816101CC  lwz r11, 0x1cc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EED044: 8141024C  lwz r10, 0x24c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EED048: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EED04C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED050: 916101C4  stw r11, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 82EED054: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EED058: 48006EB9  bl 0x82ef3f10
	ctx.lr = 0x82EED05C;
	sub_82EF3F10(ctx, base);
	// 82EED05C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EED060: 48006E01  bl 0x82ef3e60
	ctx.lr = 0x82EED064;
	sub_82EF3E60(ctx, base);
	// 82EED064: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EED068: 38210220  addi r1, r1, 0x220
	ctx.r[1].s64 = ctx.r[1].s64 + 544;
	// 82EED06C: 4BDBC3D8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED070 size=16
    let mut pc: u32 = 0x82EED070;
    'dispatch: loop {
        match pc {
            0x82EED070 => {
    //   block [0x82EED070..0x82EED080)
	// 82EED070: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED074: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EED078: 8061001C  lwz r3, 0x1c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EED07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED080 size=316
    let mut pc: u32 = 0x82EED080;
    'dispatch: loop {
        match pc {
            0x82EED080 => {
    //   block [0x82EED080..0x82EED1BC)
	// 82EED080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EED08C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED090: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EED094: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EED098: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED0A0: 409A004C  bne cr6, 0x82eed0ec
	if !ctx.cr[6].eq {
	pc = 0x82EED0EC; continue 'dispatch;
	}
	// 82EED0A4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED0A8: 896B8F68  lbz r11, -0x7098(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28824 as u32) ) } as u64;
	// 82EED0AC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EED0B0: 4082003C  bne 0x82eed0ec
	if !ctx.cr[0].eq {
	pc = 0x82EED0EC; continue 'dispatch;
	}
	// 82EED0B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED0B8: 3BEB8F68  addi r31, r11, -0x7098
	ctx.r[31].s64 = ctx.r[11].s64 + -28824;
	// 82EED0BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED0C0: 38CBC4A0  addi r6, r11, -0x3b60
	ctx.r[6].s64 = ctx.r[11].s64 + -15200;
	// 82EED0C4: 38A00131  li r5, 0x131
	ctx.r[5].s64 = 305;
	// 82EED0C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED0CC: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EED0D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED0D4: 4BFFE095  bl 0x82eeb168
	ctx.lr = 0x82EED0D8;
	sub_82EEB168(ctx, base);
	// 82EED0D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EED0DC: 48204CDD  bl 0x830f1db8
	ctx.lr = 0x82EED0E0;
	sub_830F1DB8(ctx, base);
	// 82EED0E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED0E4: 40820008  bne 0x82eed0ec
	if !ctx.cr[0].eq {
	pc = 0x82EED0EC; continue 'dispatch;
	}
	// 82EED0E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EED0EC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EED0F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED0F4: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED0F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EED0FC: 419A004C  beq cr6, 0x82eed148
	if ctx.cr[6].eq {
	pc = 0x82EED148; continue 'dispatch;
	}
	// 82EED100: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED104: 896B8F67  lbz r11, -0x7099(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28825 as u32) ) } as u64;
	// 82EED108: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EED10C: 4082003C  bne 0x82eed148
	if !ctx.cr[0].eq {
	pc = 0x82EED148; continue 'dispatch;
	}
	// 82EED110: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED114: 3BEB8F67  addi r31, r11, -0x7099
	ctx.r[31].s64 = ctx.r[11].s64 + -28825;
	// 82EED118: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED11C: 38CBC488  addi r6, r11, -0x3b78
	ctx.r[6].s64 = ctx.r[11].s64 + -15224;
	// 82EED120: 38A00132  li r5, 0x132
	ctx.r[5].s64 = 306;
	// 82EED124: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED128: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EED12C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EED130: 4BFFE039  bl 0x82eeb168
	ctx.lr = 0x82EED134;
	sub_82EEB168(ctx, base);
	// 82EED134: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EED138: 48204C81  bl 0x830f1db8
	ctx.lr = 0x82EED13C;
	sub_830F1DB8(ctx, base);
	// 82EED13C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED140: 40820008  bne 0x82eed148
	if !ctx.cr[0].eq {
	pc = 0x82EED148; continue 'dispatch;
	}
	// 82EED144: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EED148: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED14C: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED150: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED154: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED158: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED15C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EED160: 4E800421  bctrl
	ctx.lr = 0x82EED164;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EED164: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED168: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED16C: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EED170: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED174: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EED178: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EED17C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EED180: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EED184: 4E800421  bctrl
	ctx.lr = 0x82EED188;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EED188: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EED18C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED190: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED194: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EED198: 409A0010  bne cr6, 0x82eed1a8
	if !ctx.cr[6].eq {
	pc = 0x82EED1A8; continue 'dispatch;
	}
	// 82EED19C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EED1A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED1A4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EED1A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EED1AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED1B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED1B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EED1B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED1C0 size=16
    let mut pc: u32 = 0x82EED1C0;
    'dispatch: loop {
        match pc {
            0x82EED1C0 => {
    //   block [0x82EED1C0..0x82EED1D0)
	// 82EED1C0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED1C4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EED1C8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED1CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED1D0 size=76
    let mut pc: u32 = 0x82EED1D0;
    'dispatch: loop {
        match pc {
            0x82EED1D0 => {
    //   block [0x82EED1D0..0x82EED21C)
	// 82EED1D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED1D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED1D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED1DC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED1E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EED1E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EED1E8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EED1EC: 481179BD  bl 0x83004ba8
	ctx.lr = 0x82EED1F0;
	sub_83004BA8(ctx, base);
	// 82EED1F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EED1F4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED1F8: 48001C21  bl 0x82eeee18
	ctx.lr = 0x82EED1FC;
	sub_82EEEE18(ctx, base);
	// 82EED1FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED200: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED204: 48000325  bl 0x82eed528
	ctx.lr = 0x82EED208;
	sub_82EED528(ctx, base);
	// 82EED208: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED20C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED220 size=88
    let mut pc: u32 = 0x82EED220;
    'dispatch: loop {
        match pc {
            0x82EED220 => {
    //   block [0x82EED220..0x82EED278)
	// 82EED220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED228: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED22C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED230: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED234: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED238: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED23C: 480003E5  bl 0x82eed620
	ctx.lr = 0x82EED240;
	sub_82EED620(ctx, base);
	// 82EED240: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED244: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED248: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EED24C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED250: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED254: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED258: 4BFFE0E9  bl 0x82eeb340
	ctx.lr = 0x82EED25C;
	sub_82EEB340(ctx, base);
	// 82EED25C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED260: 48000271  bl 0x82eed4d0
	ctx.lr = 0x82EED264;
	sub_82EED4D0(ctx, base);
	// 82EED264: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED278 size=52
    let mut pc: u32 = 0x82EED278;
    'dispatch: loop {
        match pc {
            0x82EED278 => {
    //   block [0x82EED278..0x82EED2AC)
	// 82EED278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED280: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED284: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED288: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED28C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED290: 48000421  bl 0x82eed6b0
	ctx.lr = 0x82EED294;
	sub_82EED6B0(ctx, base);
	// 82EED294: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED298: 48000239  bl 0x82eed4d0
	ctx.lr = 0x82EED29C;
	sub_82EED4D0(ctx, base);
	// 82EED29C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED2A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED2A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED2B0 size=440
    let mut pc: u32 = 0x82EED2B0;
    'dispatch: loop {
        match pc {
            0x82EED2B0 => {
    //   block [0x82EED2B0..0x82EED468)
	// 82EED2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED2B4: 4BDBC159  bl 0x82ca940c
	ctx.lr = 0x82EED2B8;
	sub_82CA93D0(ctx, base);
	// 82EED2B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED2BC: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EED2C0: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 82EED2C4: 90A100C4  stw r5, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[5].u32 ) };
	// 82EED2C8: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED2CC: 4800031D  bl 0x82eed5e8
	ctx.lr = 0x82EED2D0;
	sub_82EED5E8(ctx, base);
	// 82EED2D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EED2D4: 3D000800  lis r8, 0x800
	ctx.r[8].s64 = 134217728;
	// 82EED2D8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 82EED2DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EED2E0: 80A100C4  lwz r5, 0xc4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EED2E4: 3C808000  lis r4, -0x8000
	ctx.r[4].s64 = -2147483648;
	// 82EED2E8: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EED2EC: 4BDD61A5  bl 0x82cc3490
	ctx.lr = 0x82EED2F0;
	sub_82CC3490(ctx, base);
	// 82EED2F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EED2F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED2F8: 4BFFE049  bl 0x82eeb340
	ctx.lr = 0x82EED2FC;
	sub_82EEB340(ctx, base);
	// 82EED2FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED300: 4BFFFEC1  bl 0x82eed1c0
	ctx.lr = 0x82EED304;
	sub_82EED1C0(ctx, base);
	// 82EED304: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EED308: 409A0020  bne cr6, 0x82eed328
	if !ctx.cr[6].eq {
	pc = 0x82EED328; continue 'dispatch;
	}
	// 82EED30C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EED310: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EED314: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EED318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED31C: 4BFFE045  bl 0x82eeb360
	ctx.lr = 0x82EED320;
	sub_82EEB360(ctx, base);
	// 82EED320: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EED324: 4800013C  b 0x82eed460
	pc = 0x82EED460; continue 'dispatch;
	// 82EED328: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED32C: 4BFFFE95  bl 0x82eed1c0
	ctx.lr = 0x82EED330;
	sub_82EED1C0(ctx, base);
	// 82EED330: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED334: 4BDD9ADD  bl 0x82cc6e10
	ctx.lr = 0x82EED338;
	sub_82CC6E10(ctx, base);
	// 82EED338: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EED33C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EED340: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EED344: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED348: 48000339  bl 0x82eed680
	ctx.lr = 0x82EED34C;
	sub_82EED680(ctx, base);
	// 82EED34C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EED350: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED354: 4BFFDFED  bl 0x82eeb340
	ctx.lr = 0x82EED358;
	sub_82EEB340(ctx, base);
	// 82EED358: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED35C: 48002F65  bl 0x82ef02c0
	ctx.lr = 0x82EED360;
	sub_82EF02C0(ctx, base);
	// 82EED360: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED364: 40820028  bne 0x82eed38c
	if !ctx.cr[0].eq {
	pc = 0x82EED38C; continue 'dispatch;
	}
	// 82EED368: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EED36C: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 82EED370: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EED374: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED378: 48000339  bl 0x82eed6b0
	ctx.lr = 0x82EED37C;
	sub_82EED6B0(ctx, base);
	// 82EED37C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED380: 4BFFDFE1  bl 0x82eeb360
	ctx.lr = 0x82EED384;
	sub_82EEB360(ctx, base);
	// 82EED384: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EED388: 480000D8  b 0x82eed460
	pc = 0x82EED460; continue 'dispatch;
	// 82EED38C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED390: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EED394: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EED398: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82EED39C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED3A0: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED3A4: 4800033D  bl 0x82eed6e0
	ctx.lr = 0x82EED3A8;
	sub_82EED6E0(ctx, base);
	// 82EED3A8: 3BE10064  addi r31, r1, 0x64
	ctx.r[31].s64 = ctx.r[1].s64 + 100;
	// 82EED3AC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED3B0: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED3B4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED3B8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED3BC: 4BFFFE05  bl 0x82eed1c0
	ctx.lr = 0x82EED3C0;
	sub_82EED1C0(ctx, base);
	// 82EED3C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EED3C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED3C8: 4BFFFDF9  bl 0x82eed1c0
	ctx.lr = 0x82EED3CC;
	sub_82EED1C0(ctx, base);
	// 82EED3CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EED3D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EED3D4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EED3D8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EED3DC: 4BDD62AD  bl 0x82cc3688
	ctx.lr = 0x82EED3E0;
	sub_82CC3688(ctx, base);
	// 82EED3E0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EED3E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EED3E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED3EC: 419A0010  beq cr6, 0x82eed3fc
	if ctx.cr[6].eq {
	pc = 0x82EED3FC; continue 'dispatch;
	}
	// 82EED3F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED3F4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EED3F8: 48000010  b 0x82eed408
	pc = 0x82EED408; continue 'dispatch;
	// 82EED3FC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EED400: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EED404: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EED408: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED40C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EED410: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED414: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED418: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED41C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED420: 4BFFFDA1  bl 0x82eed1c0
	ctx.lr = 0x82EED424;
	sub_82EED1C0(ctx, base);
	// 82EED424: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EED428: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED42C: 38ABC4AC  addi r5, r11, -0x3b54
	ctx.r[5].s64 = ctx.r[11].s64 + -15188;
	// 82EED430: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 82EED434: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED438: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EED43C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EED440: 4BFFDDA9  bl 0x82eeb1e8
	ctx.lr = 0x82EED444;
	sub_82EEB1E8(ctx, base);
	// 82EED444: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EED448: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EED44C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED450: 48000261  bl 0x82eed6b0
	ctx.lr = 0x82EED454;
	sub_82EED6B0(ctx, base);
	// 82EED454: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED458: 4BFFDF09  bl 0x82eeb360
	ctx.lr = 0x82EED45C;
	sub_82EEB360(ctx, base);
	// 82EED45C: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EED460: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EED464: 4BDBBFF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED468 size=44
    let mut pc: u32 = 0x82EED468;
    'dispatch: loop {
        match pc {
            0x82EED468 => {
    //   block [0x82EED468..0x82EED494)
	// 82EED468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED470: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED474: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED478: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED47C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED480: 4BFFFD41  bl 0x82eed1c0
	ctx.lr = 0x82EED484;
	sub_82EED1C0(ctx, base);
	// 82EED484: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED48C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED498 size=56
    let mut pc: u32 = 0x82EED498;
    'dispatch: loop {
        match pc {
            0x82EED498 => {
    //   block [0x82EED498..0x82EED4D0)
	// 82EED498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED4A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED4A4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED4A8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4AC: 481176FD  bl 0x83004ba8
	ctx.lr = 0x82EED4B0;
	sub_83004BA8(ctx, base);
	// 82EED4B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4B4: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EED4B8: 481176F1  bl 0x83004ba8
	ctx.lr = 0x82EED4BC;
	sub_83004BA8(ctx, base);
	// 82EED4BC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED4C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED4C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED4CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED4D0 size=84
    let mut pc: u32 = 0x82EED4D0;
    'dispatch: loop {
        match pc {
            0x82EED4D0 => {
    //   block [0x82EED4D0..0x82EED524)
	// 82EED4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED4D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED4D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED4DC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED4E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED4E8: 419A0014  beq cr6, 0x82eed4fc
	if ctx.cr[6].eq {
	pc = 0x82EED4FC; continue 'dispatch;
	}
	// 82EED4EC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EED4F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EED4F8: 4800000C  b 0x82eed504
	pc = 0x82EED504; continue 'dispatch;
	// 82EED4FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED500: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EED504: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EED508: 48000171  bl 0x82eed678
	ctx.lr = 0x82EED50C;
	sub_82EED678(ctx, base);
	// 82EED50C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED510: 48000169  bl 0x82eed678
	ctx.lr = 0x82EED514;
	sub_82EED678(ctx, base);
	// 82EED514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED51C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED528 size=192
    let mut pc: u32 = 0x82EED528;
    'dispatch: loop {
        match pc {
            0x82EED528 => {
    //   block [0x82EED528..0x82EED5E8)
	// 82EED528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED52C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED530: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED534: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED538: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED53C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED540: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED544: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EED548: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED54C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED550: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EED554: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED558: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED55C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EED560: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED568: 409A0010  bne cr6, 0x82eed578
	if !ctx.cr[6].eq {
	pc = 0x82EED578; continue 'dispatch;
	}
	// 82EED56C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EED570: 48000068  b 0x82eed5d8
	pc = 0x82EED5D8; continue 'dispatch;
	// 82EED574: 48000060  b 0x82eed5d4
	pc = 0x82EED5D4; continue 'dispatch;
	// 82EED578: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED57C: 4800019D  bl 0x82eed718
	ctx.lr = 0x82EED580;
	sub_82EED718(ctx, base);
	// 82EED580: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED584: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EED588: 4098000C  bge cr6, 0x82eed594
	if !ctx.cr[6].lt {
	pc = 0x82EED594; continue 'dispatch;
	}
	// 82EED58C: 480001B5  bl 0x82eed740
	ctx.lr = 0x82EED590;
	sub_82EED740(ctx, base);
	// 82EED590: 48000044  b 0x82eed5d4
	pc = 0x82EED5D4; continue 'dispatch;
	// 82EED594: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED598: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED59C: 48000205  bl 0x82eed7a0
	ctx.lr = 0x82EED5A0;
	sub_82EED7A0(ctx, base);
	// 82EED5A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5A4: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EED5A8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5AC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED5B4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EED5B8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5BC: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED5C0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EED5C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED5C8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EED5CC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5D0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EED5D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EED5D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED5E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED5E8 size=56
    let mut pc: u32 = 0x82EED5E8;
    'dispatch: loop {
        match pc {
            0x82EED5E8 => {
    //   block [0x82EED5E8..0x82EED620)
	// 82EED5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED5F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED5F4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED5F8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5FC: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED600: 48000279  bl 0x82eed878
	ctx.lr = 0x82EED604;
	sub_82EED878(ctx, base);
	// 82EED604: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED608: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED60C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EED610: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED614: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED618: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED61C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED620 size=88
    let mut pc: u32 = 0x82EED620;
    'dispatch: loop {
        match pc {
            0x82EED620 => {
    //   block [0x82EED620..0x82EED678)
	// 82EED620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED628: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED62C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED630: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED634: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED638: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED63C: 48000155  bl 0x82eed790
	ctx.lr = 0x82EED640;
	sub_82EED790(ctx, base);
	// 82EED640: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED648: 419A0014  beq cr6, 0x82eed65c
	if ctx.cr[6].eq {
	pc = 0x82EED65C; continue 'dispatch;
	}
	// 82EED64C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED650: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EED654: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EED658: 4800000C  b 0x82eed664
	pc = 0x82EED664; continue 'dispatch;
	// 82EED65C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED660: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EED664: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED668: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED66C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED670: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED678 size=8
    let mut pc: u32 = 0x82EED678;
    'dispatch: loop {
        match pc {
            0x82EED678 => {
    //   block [0x82EED678..0x82EED680)
	// 82EED678: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED67C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED680 size=48
    let mut pc: u32 = 0x82EED680;
    'dispatch: loop {
        match pc {
            0x82EED680 => {
    //   block [0x82EED680..0x82EED6B0)
	// 82EED680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED688: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED68C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED690: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED694: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EED698: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED69C: 4B3FCB1D  bl 0x822ea1b8
	ctx.lr = 0x82EED6A0;
	sub_822EA1B8(ctx, base);
	// 82EED6A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED6A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED6A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED6AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED6B0 size=44
    let mut pc: u32 = 0x82EED6B0;
    'dispatch: loop {
        match pc {
            0x82EED6B0 => {
    //   block [0x82EED6B0..0x82EED6DC)
	// 82EED6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED6B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED6B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED6BC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED6C0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED6C4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED6C8: 48000241  bl 0x82eed908
	ctx.lr = 0x82EED6CC;
	sub_82EED908(ctx, base);
	// 82EED6CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED6D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED6D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED6E0 size=56
    let mut pc: u32 = 0x82EED6E0;
    'dispatch: loop {
        match pc {
            0x82EED6E0 => {
    //   block [0x82EED6E0..0x82EED718)
	// 82EED6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED6E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED6EC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED6F0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED6F4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED6F8: 48000181  bl 0x82eed878
	ctx.lr = 0x82EED6FC;
	sub_82EED878(ctx, base);
	// 82EED6FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EED700: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED704: 480000CD  bl 0x82eed7d0
	ctx.lr = 0x82EED708;
	sub_82EED7D0(ctx, base);
	// 82EED708: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED70C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED714: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED718 size=40
    let mut pc: u32 = 0x82EED718;
    'dispatch: loop {
        match pc {
            0x82EED718 => {
    //   block [0x82EED718..0x82EED740)
	// 82EED718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED71C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED720: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED724: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED728: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED72C: 48000175  bl 0x82eed8a0
	ctx.lr = 0x82EED730;
	sub_82EED8A0(ctx, base);
	// 82EED730: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED73C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED740 size=76
    let mut pc: u32 = 0x82EED740;
    'dispatch: loop {
        match pc {
            0x82EED740 => {
    //   block [0x82EED740..0x82EED78C)
	// 82EED740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED748: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED74C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EED750: 388B16DC  addi r4, r11, 0x16dc
	ctx.r[4].s64 = ctx.r[11].s64 + 5852;
	// 82EED754: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EED758: 4B4047E9  bl 0x822f1f40
	ctx.lr = 0x82EED75C;
	sub_822F1F40(ctx, base);
	// 82EED75C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EED760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED764: 4B40460D  bl 0x822f1d70
	ctx.lr = 0x82EED768;
	sub_822F1D70(ctx, base);
	// 82EED768: 4B4046B9  bl 0x822f1e20
	ctx.lr = 0x82EED76C;
	sub_822F1E20(ctx, base);
	// 82EED76C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED770: 4B404571  bl 0x822f1ce0
	ctx.lr = 0x82EED774;
	sub_822F1CE0(ctx, base);
	// 82EED774: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EED778: 4B284099  bl 0x82171810
	ctx.lr = 0x82EED77C;
	sub_82171810(ctx, base);
	// 82EED77C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EED780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED790 size=16
    let mut pc: u32 = 0x82EED790;
    'dispatch: loop {
        match pc {
            0x82EED790 => {
    //   block [0x82EED790..0x82EED7A0)
	// 82EED790: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED794: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EED798: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EED79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED7A0 size=48
    let mut pc: u32 = 0x82EED7A0;
    'dispatch: loop {
        match pc {
            0x82EED7A0 => {
    //   block [0x82EED7A0..0x82EED7D0)
	// 82EED7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED7A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED7AC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED7B0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED7B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED7B8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED7BC: 4800018D  bl 0x82eed948
	ctx.lr = 0x82EED7C0;
	sub_82EED948(ctx, base);
	// 82EED7C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED7C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED7C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED7CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED7D0 size=168
    let mut pc: u32 = 0x82EED7D0;
    'dispatch: loop {
        match pc {
            0x82EED7D0 => {
    //   block [0x82EED7D0..0x82EED878)
	// 82EED7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED7D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED7D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EED7DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED7E0: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EED7E4: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EED7E8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EED7EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED7F0: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EED7F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EED7F8: 409A004C  bne cr6, 0x82eed844
	if !ctx.cr[6].eq {
	pc = 0x82EED844; continue 'dispatch;
	}
	// 82EED7FC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED800: 896B8F69  lbz r11, -0x7097(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28823 as u32) ) } as u64;
	// 82EED804: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EED808: 4082003C  bne 0x82eed844
	if !ctx.cr[0].eq {
	pc = 0x82EED844; continue 'dispatch;
	}
	// 82EED80C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED810: 3BEB8F69  addi r31, r11, -0x7097
	ctx.r[31].s64 = ctx.r[11].s64 + -28823;
	// 82EED814: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED818: 38CBC53C  addi r6, r11, -0x3ac4
	ctx.r[6].s64 = ctx.r[11].s64 + -15044;
	// 82EED81C: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 82EED820: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED824: 388BC4D8  addi r4, r11, -0x3b28
	ctx.r[4].s64 = ctx.r[11].s64 + -15144;
	// 82EED828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED82C: 4BFFD93D  bl 0x82eeb168
	ctx.lr = 0x82EED830;
	sub_82EEB168(ctx, base);
	// 82EED830: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EED834: 48204585  bl 0x830f1db8
	ctx.lr = 0x82EED838;
	sub_830F1DB8(ctx, base);
	// 82EED838: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED83C: 40820008  bne 0x82eed844
	if !ctx.cr[0].eq {
	pc = 0x82EED844; continue 'dispatch;
	}
	// 82EED840: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EED844: 83E10084  lwz r31, 0x84(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EED848: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EED84C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED850: 4BFFDAF1  bl 0x82eeb340
	ctx.lr = 0x82EED854;
	sub_82EEB340(ctx, base);
	// 82EED854: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EED858: 48000081  bl 0x82eed8d8
	ctx.lr = 0x82EED85C;
	sub_82EED8D8(ctx, base);
	// 82EED85C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED860: 4BFFFE51  bl 0x82eed6b0
	ctx.lr = 0x82EED864;
	sub_82EED6B0(ctx, base);
	// 82EED864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EED868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED86C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EED874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED878 size=36
    let mut pc: u32 = 0x82EED878;
    'dispatch: loop {
        match pc {
            0x82EED878 => {
    //   block [0x82EED878..0x82EED89C)
	// 82EED878: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED87C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EED880: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED884: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EED888: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EED88C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED890: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EED894: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EED898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED8A0 size=40
    let mut pc: u32 = 0x82EED8A0;
    'dispatch: loop {
        match pc {
            0x82EED8A0 => {
    //   block [0x82EED8A0..0x82EED8C8)
	// 82EED8A0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED8A4: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82EED8A8: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EED8AC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EED8B0: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EED8B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED8B8: 40990010  ble cr6, 0x82eed8c8
	if !ctx.cr[6].gt {
		sub_82EED8C8(ctx, base);
		return;
	}
	// 82EED8BC: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EED8C0: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82EED8C4: 4800000C  b 0x82eed8d0
	sub_82EED8C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED8C8 size=16
    let mut pc: u32 = 0x82EED8C8;
    'dispatch: loop {
        match pc {
            0x82EED8C8 => {
    //   block [0x82EED8C8..0x82EED8D8)
	// 82EED8C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EED8CC: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82EED8D0: 8061FFF4  lwz r3, -0xc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EED8D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED8D8 size=48
    let mut pc: u32 = 0x82EED8D8;
    'dispatch: loop {
        match pc {
            0x82EED8D8 => {
    //   block [0x82EED8D8..0x82EED908)
	// 82EED8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED8DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED8E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED8E4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED8E8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED8EC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED8F0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED8F4: 4BC62355  bl 0x82b4fc48
	ctx.lr = 0x82EED8F8;
	sub_82B4FC48(ctx, base);
	// 82EED8F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED8FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED908 size=60
    let mut pc: u32 = 0x82EED908;
    'dispatch: loop {
        match pc {
            0x82EED908 => {
    //   block [0x82EED908..0x82EED944)
	// 82EED908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED90C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED910: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED914: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED918: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED920: 419A0014  beq cr6, 0x82eed934
	if ctx.cr[6].eq {
	pc = 0x82EED934; continue 'dispatch;
	}
	// 82EED924: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED928: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EED92C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EED930: 4B957E81  bl 0x828457b0
	ctx.lr = 0x82EED934;
	sub_828457B0(ctx, base);
	// 82EED934: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED93C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED948 size=120
    let mut pc: u32 = 0x82EED948;
    'dispatch: loop {
        match pc {
            0x82EED948 => {
    //   block [0x82EED948..0x82EED9C0)
	// 82EED948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED94C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED950: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED954: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED958: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED95C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED964: 41990010  bgt cr6, 0x82eed974
	if ctx.cr[6].gt {
	pc = 0x82EED974; continue 'dispatch;
	}
	// 82EED968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED96C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EED970: 48000034  b 0x82eed9a4
	pc = 0x82EED9A4; continue 'dispatch;
	// 82EED974: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED978: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EED97C: 0CCB0000  twi 6, r11, 0
	// 82EED980: 7D6A5B96  divwu r11, r10, r11
	ctx.r[11].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82EED984: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EED988: 4098001C  bge cr6, 0x82eed9a4
	if !ctx.cr[6].lt {
	pc = 0x82EED9A4; continue 'dispatch;
	}
	// 82EED98C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED990: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED994: 4B404265  bl 0x822f1bf8
	ctx.lr = 0x82EED998;
	sub_822F1BF8(ctx, base);
	// 82EED998: 4B404489  bl 0x822f1e20
	ctx.lr = 0x82EED99C;
	sub_822F1E20(ctx, base);
	// 82EED99C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED9A0: 4B4041F9  bl 0x822f1b98
	ctx.lr = 0x82EED9A4;
	sub_822F1B98(ctx, base);
	// 82EED9A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED9A8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EED9AC: 4B3FC80D  bl 0x822ea1b8
	ctx.lr = 0x82EED9B0;
	sub_822EA1B8(ctx, base);
	// 82EED9B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED9B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED9B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED9BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EED9C0 size=100
    let mut pc: u32 = 0x82EED9C0;
    'dispatch: loop {
        match pc {
            0x82EED9C0 => {
    //   block [0x82EED9C0..0x82EEDA24)
	// 82EED9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED9C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED9C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED9CC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED9D0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED9D4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EED9D8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED9DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED9E0: 409A0014  bne cr6, 0x82eed9f4
	if !ctx.cr[6].eq {
	pc = 0x82EED9F4; continue 'dispatch;
	}
	// 82EED9E4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED9E8: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82EED9EC: 7C6B5910  subfe r3, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[3].u32 = res;
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82EED9F0: 48000024  b 0x82eeda14
	pc = 0x82EEDA14; continue 'dispatch;
	// 82EED9F4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED9F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED9FC: 409A000C  bne cr6, 0x82eeda08
	if !ctx.cr[6].eq {
	pc = 0x82EEDA08; continue 'dispatch;
	}
	// 82EEDA00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEDA04: 48000010  b 0x82eeda14
	pc = 0x82EEDA14; continue 'dispatch;
	// 82EEDA08: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDA0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDA10: 4BDBF141  bl 0x82cacb50
	ctx.lr = 0x82EEDA14;
	sub_82CACB50(ctx, base);
	// 82EEDA14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDA28 size=56
    let mut pc: u32 = 0x82EEDA28;
    'dispatch: loop {
        match pc {
            0x82EEDA28 => {
    //   block [0x82EEDA28..0x82EEDA60)
	// 82EEDA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDA2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDA30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDA34: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDA38: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDA3C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEDA40: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 82EEDA44: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EEDA48: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EEDA4C: 4800019D  bl 0x82eedbe8
	ctx.lr = 0x82EEDA50;
	sub_82EEDBE8(ctx, base);
	// 82EEDA50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDA54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDA58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDA5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDA60 size=24
    let mut pc: u32 = 0x82EEDA60;
    'dispatch: loop {
        match pc {
            0x82EEDA60 => {
    //   block [0x82EEDA60..0x82EEDA78)
	// 82EEDA60: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDA64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDA68: 396BC2DC  addi r11, r11, -0x3d24
	ctx.r[11].s64 = ctx.r[11].s64 + -15652;
	// 82EEDA6C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDA70: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEDA74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDA78 size=68
    let mut pc: u32 = 0x82EEDA78;
    'dispatch: loop {
        match pc {
            0x82EEDA78 => {
    //   block [0x82EEDA78..0x82EEDABC)
	// 82EEDA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDA7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDA80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDA84: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDA88: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDA8C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDA90: 4BFFFFD1  bl 0x82eeda60
	ctx.lr = 0x82EEDA94;
	sub_82EEDA60(ctx, base);
	// 82EEDA94: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDA98: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDA9C: 4182000C  beq 0x82eedaa8
	if ctx.cr[0].eq {
	pc = 0x82EEDAA8; continue 'dispatch;
	}
	// 82EEDAA0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDAA4: 4B957D0D  bl 0x828457b0
	ctx.lr = 0x82EEDAA8;
	sub_828457B0(ctx, base);
	// 82EEDAA8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDAAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDAB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDAB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDAB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDAC0 size=24
    let mut pc: u32 = 0x82EEDAC0;
    'dispatch: loop {
        match pc {
            0x82EEDAC0 => {
    //   block [0x82EEDAC0..0x82EEDAD8)
	// 82EEDAC0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDAC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDAC8: 396BC2C0  addi r11, r11, -0x3d40
	ctx.r[11].s64 = ctx.r[11].s64 + -15680;
	// 82EEDACC: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDAD0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEDAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDAD8 size=12
    let mut pc: u32 = 0x82EEDAD8;
    'dispatch: loop {
        match pc {
            0x82EEDAD8 => {
    //   block [0x82EEDAD8..0x82EEDAE4)
	// 82EEDAD8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDADC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEDAE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDAE8 size=68
    let mut pc: u32 = 0x82EEDAE8;
    'dispatch: loop {
        match pc {
            0x82EEDAE8 => {
    //   block [0x82EEDAE8..0x82EEDB2C)
	// 82EEDAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDAEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDAF0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDAF4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDAF8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDAFC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB00: 4BFFFFC1  bl 0x82eedac0
	ctx.lr = 0x82EEDB04;
	sub_82EEDAC0(ctx, base);
	// 82EEDB04: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDB08: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDB0C: 4182000C  beq 0x82eedb18
	if ctx.cr[0].eq {
	pc = 0x82EEDB18; continue 'dispatch;
	}
	// 82EEDB10: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB14: 4B957C9D  bl 0x828457b0
	ctx.lr = 0x82EEDB18;
	sub_828457B0(ctx, base);
	// 82EEDB18: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDB20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDB24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDB28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDB30 size=64
    let mut pc: u32 = 0x82EEDB30;
    'dispatch: loop {
        match pc {
            0x82EEDB30 => {
    //   block [0x82EEDB30..0x82EEDB70)
	// 82EEDB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDB38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDB3C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDB40: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDB44: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDB48: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB4C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB50: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEDB54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEDB58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEDB5C: 4E800421  bctrl
	ctx.lr = 0x82EEDB60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEDB60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDB64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDB68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDB6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDB70 size=48
    let mut pc: u32 = 0x82EEDB70;
    'dispatch: loop {
        match pc {
            0x82EEDB70 => {
    //   block [0x82EEDB70..0x82EEDBA0)
	// 82EEDB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDB74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDB78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDB7C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDB80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEDB84: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB88: 386B001C  addi r3, r11, 0x1c
	ctx.r[3].s64 = ctx.r[11].s64 + 28;
	// 82EEDB8C: 4800002D  bl 0x82eedbb8
	ctx.lr = 0x82EEDB90;
	sub_82EEDBB8(ctx, base);
	// 82EEDB90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDB94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDB98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDB9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDBA0 size=20
    let mut pc: u32 = 0x82EEDBA0;
    'dispatch: loop {
        match pc {
            0x82EEDBA0 => {
    //   block [0x82EEDBA0..0x82EEDBB4)
	// 82EEDBA0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDBA4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDBA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEDBAC: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82EEDBB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDBB8 size=44
    let mut pc: u32 = 0x82EEDBB8;
    'dispatch: loop {
        match pc {
            0x82EEDBB8 => {
    //   block [0x82EEDBB8..0x82EEDBE4)
	// 82EEDBB8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDBBC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEDBC0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDBC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDBC8: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEDBCC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEDBD0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EEDBD4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EEDBD8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EEDBDC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEDBE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDBE8 size=72
    let mut pc: u32 = 0x82EEDBE8;
    'dispatch: loop {
        match pc {
            0x82EEDBE8 => {
    //   block [0x82EEDBE8..0x82EEDC30)
	// 82EEDBE8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDBEC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEDBF0: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EEDBF4: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEDBF8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDBFC: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDC00: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDC04: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEDC08: 41990028  bgt cr6, 0x82eedc30
	if ctx.cr[6].gt {
		sub_82EEDC30(ctx, base);
		return;
	}
	// 82EEDC0C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDC10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDC14: 81410024  lwz r10, 0x24(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EEDC18: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDC1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEDC20: 41990010  bgt cr6, 0x82eedc30
	if ctx.cr[6].gt {
		sub_82EEDC30(ctx, base);
		return;
	}
	// 82EEDC24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEDC28: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEDC2C: 4800000C  b 0x82eedc38
	sub_82EEDC30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDC30 size=20
    let mut pc: u32 = 0x82EEDC30;
    'dispatch: loop {
        match pc {
            0x82EEDC30 => {
    //   block [0x82EEDC30..0x82EEDC44)
	// 82EEDC30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEDC34: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEDC38: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEDC3C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEDC40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDC48 size=44
    let mut pc: u32 = 0x82EEDC48;
    'dispatch: loop {
        match pc {
            0x82EEDC48 => {
    //   block [0x82EEDC48..0x82EEDC74)
	// 82EEDC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDC50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDC54: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDC58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEDC5C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDC60: 4800B0E1  bl 0x82ef8d40
	ctx.lr = 0x82EEDC64;
	sub_82EF8D40(ctx, base);
	// 82EEDC64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDC68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDC6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDC70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDC78 size=24
    let mut pc: u32 = 0x82EEDC78;
    'dispatch: loop {
        match pc {
            0x82EEDC78 => {
    //   block [0x82EEDC78..0x82EEDC90)
	// 82EEDC78: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDC7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDC80: 396BC544  addi r11, r11, -0x3abc
	ctx.r[11].s64 = ctx.r[11].s64 + -15036;
	// 82EEDC84: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDC88: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEDC8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDC90 size=144
    let mut pc: u32 = 0x82EEDC90;
    'dispatch: loop {
        match pc {
            0x82EEDC90 => {
    //   block [0x82EEDC90..0x82EEDD20)
	// 82EEDC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDC98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDC9C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDCA0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDCA4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDCA8: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDCAC: 41820044  beq 0x82eedcf0
	if ctx.cr[0].eq {
	pc = 0x82EEDCF0; continue 'dispatch;
	}
	// 82EEDCB0: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EEDCB4: 38CBDC78  addi r6, r11, -0x2388
	ctx.r[6].s64 = ctx.r[11].s64 + -9096;
	// 82EEDCB8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCBC: 80ABFFFC  lwz r5, -4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EEDCC0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EEDCC4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCC8: 4B402371  bl 0x822f0038
	ctx.lr = 0x82EEDCCC;
	sub_822F0038(ctx, base);
	// 82EEDCCC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDCD0: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDCD4: 41820010  beq 0x82eedce4
	if ctx.cr[0].eq {
	pc = 0x82EEDCE4; continue 'dispatch;
	}
	// 82EEDCD8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCDC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EEDCE0: 4B957AD1  bl 0x828457b0
	ctx.lr = 0x82EEDCE4;
	sub_828457B0(ctx, base);
	// 82EEDCE4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCE8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EEDCEC: 48000024  b 0x82eedd10
	pc = 0x82EEDD10; continue 'dispatch;
	// 82EEDCF0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCF4: 4BFFFF85  bl 0x82eedc78
	ctx.lr = 0x82EEDCF8;
	sub_82EEDC78(ctx, base);
	// 82EEDCF8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDCFC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDD00: 4182000C  beq 0x82eedd0c
	if ctx.cr[0].eq {
	pc = 0x82EEDD0C; continue 'dispatch;
	}
	// 82EEDD04: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD08: 4B957AA9  bl 0x828457b0
	ctx.lr = 0x82EEDD0C;
	sub_828457B0(ctx, base);
	// 82EEDD0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDD14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDD18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDD1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDD20 size=56
    let mut pc: u32 = 0x82EEDD20;
    'dispatch: loop {
        match pc {
            0x82EEDD20 => {
    //   block [0x82EEDD20..0x82EEDD58)
	// 82EEDD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDD28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDD2C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDD30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDD34: 396BC558  addi r11, r11, -0x3aa8
	ctx.r[11].s64 = ctx.r[11].s64 + -15016;
	// 82EEDD38: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD3C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEDD40: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD44: 4BFFFF35  bl 0x82eedc78
	ctx.lr = 0x82EEDD48;
	sub_82EEDC78(ctx, base);
	// 82EEDD48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDD4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDD50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDD54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDD58 size=144
    let mut pc: u32 = 0x82EEDD58;
    'dispatch: loop {
        match pc {
            0x82EEDD58 => {
    //   block [0x82EEDD58..0x82EEDDE8)
	// 82EEDD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDD5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDD60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDD64: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDD68: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDD6C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDD70: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDD74: 41820044  beq 0x82eeddb8
	if ctx.cr[0].eq {
	pc = 0x82EEDDB8; continue 'dispatch;
	}
	// 82EEDD78: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EEDD7C: 38CBDD20  addi r6, r11, -0x22e0
	ctx.r[6].s64 = ctx.r[11].s64 + -8928;
	// 82EEDD80: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD84: 80ABFFFC  lwz r5, -4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EEDD88: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EEDD8C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD90: 4B4022A9  bl 0x822f0038
	ctx.lr = 0x82EEDD94;
	sub_822F0038(ctx, base);
	// 82EEDD94: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDD98: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDD9C: 41820010  beq 0x82eeddac
	if ctx.cr[0].eq {
	pc = 0x82EEDDAC; continue 'dispatch;
	}
	// 82EEDDA0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDDA4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EEDDA8: 4B957A09  bl 0x828457b0
	ctx.lr = 0x82EEDDAC;
	sub_828457B0(ctx, base);
	// 82EEDDAC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDDB0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EEDDB4: 48000024  b 0x82eeddd8
	pc = 0x82EEDDD8; continue 'dispatch;
	// 82EEDDB8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDDBC: 4BFFFF65  bl 0x82eedd20
	ctx.lr = 0x82EEDDC0;
	sub_82EEDD20(ctx, base);
	// 82EEDDC0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDDC4: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDDC8: 4182000C  beq 0x82eeddd4
	if ctx.cr[0].eq {
	pc = 0x82EEDDD4; continue 'dispatch;
	}
	// 82EEDDCC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDDD0: 4B9579E1  bl 0x828457b0
	ctx.lr = 0x82EEDDD4;
	sub_828457B0(ctx, base);
	// 82EEDDD4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDDD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDDDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDDE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDDE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDDE8 size=48
    let mut pc: u32 = 0x82EEDDE8;
    'dispatch: loop {
        match pc {
            0x82EEDDE8 => {
    //   block [0x82EEDDE8..0x82EEDE18)
	// 82EEDDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDDEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDDF0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDDF4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDDF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEDDFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EEDE00: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDE04: 4800CCC5  bl 0x82efaac8
	ctx.lr = 0x82EEDE08;
	sub_82EFAAC8(ctx, base);
	// 82EEDE08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDE0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDE10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDE14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDE18 size=48
    let mut pc: u32 = 0x82EEDE18;
    'dispatch: loop {
        match pc {
            0x82EEDE18 => {
    //   block [0x82EEDE18..0x82EEDE48)
	// 82EEDE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDE20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDE24: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDE28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEDE2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEDE30: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDE34: 4800BD4D  bl 0x82ef9b80
	ctx.lr = 0x82EEDE38;
	sub_82EF9B80(ctx, base);
	// 82EEDE38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDE3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDE40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDE44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDE48 size=48
    let mut pc: u32 = 0x82EEDE48;
    'dispatch: loop {
        match pc {
            0x82EEDE48 => {
    //   block [0x82EEDE48..0x82EEDE78)
	// 82EEDE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDE4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDE50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDE54: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDE58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEDE5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EEDE60: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDE64: 4800BE9D  bl 0x82ef9d00
	ctx.lr = 0x82EEDE68;
	sub_82EF9D00(ctx, base);
	// 82EEDE68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDE6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDE70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDE74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDE78 size=48
    let mut pc: u32 = 0x82EEDE78;
    'dispatch: loop {
        match pc {
            0x82EEDE78 => {
    //   block [0x82EEDE78..0x82EEDEA8)
	// 82EEDE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDE7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDE80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDE84: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDE88: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82EEDE8C: 3C800002  lis r4, 2
	ctx.r[4].s64 = 131072;
	// 82EEDE90: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDE94: 4800D96D  bl 0x82efb800
	ctx.lr = 0x82EEDE98;
	sub_82EFB800(ctx, base);
	// 82EEDE98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDE9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDEA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDEA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDEA8 size=196
    let mut pc: u32 = 0x82EEDEA8;
    'dispatch: loop {
        match pc {
            0x82EEDEA8 => {
    //   block [0x82EEDEA8..0x82EEDF6C)
	// 82EEDEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDEB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEDEB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDEB8: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEDEBC: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEDEC0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDEC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEDEC8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEDECC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDED0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEDED4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEDED8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDEDC: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEDEE0: 48000759  bl 0x82eee638
	ctx.lr = 0x82EEDEE4;
	sub_82EEE638(ctx, base);
	// 82EEDEE4: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEDEE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDEEC: 4098004C  bge cr6, 0x82eedf38
	if !ctx.cr[6].lt {
	pc = 0x82EEDF38; continue 'dispatch;
	}
	// 82EEDEF0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEDEF4: 896B8F70  lbz r11, -0x7090(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28816 as u32) ) } as u64;
	// 82EEDEF8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEDEFC: 4082003C  bne 0x82eedf38
	if !ctx.cr[0].eq {
	pc = 0x82EEDF38; continue 'dispatch;
	}
	// 82EEDF00: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEDF04: 3BEB8F70  addi r31, r11, -0x7090
	ctx.r[31].s64 = ctx.r[11].s64 + -28816;
	// 82EEDF08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDF0C: 38CBC594  addi r6, r11, -0x3a6c
	ctx.r[6].s64 = ctx.r[11].s64 + -14956;
	// 82EEDF10: 38A0000D  li r5, 0xd
	ctx.r[5].s64 = 13;
	// 82EEDF14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDF18: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEDF1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEDF20: 4BFFD249  bl 0x82eeb168
	ctx.lr = 0x82EEDF24;
	sub_82EEB168(ctx, base);
	// 82EEDF24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEDF28: 48203E91  bl 0x830f1db8
	ctx.lr = 0x82EEDF2C;
	sub_830F1DB8(ctx, base);
	// 82EEDF2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDF30: 40820008  bne 0x82eedf38
	if !ctx.cr[0].eq {
	pc = 0x82EEDF38; continue 'dispatch;
	}
	// 82EEDF34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEDF38: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEDF3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDF40: 40990014  ble cr6, 0x82eedf54
	if !ctx.cr[6].gt {
	pc = 0x82EEDF54; continue 'dispatch;
	}
	// 82EEDF44: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEDF48: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDF4C: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEDF50: 48000761  bl 0x82eee6b0
	ctx.lr = 0x82EEDF54;
	sub_82EEE6B0(ctx, base);
	// 82EEDF54: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDF58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEDF5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDF60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDF64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEDF68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDF70 size=52
    let mut pc: u32 = 0x82EEDF70;
    'dispatch: loop {
        match pc {
            0x82EEDF70 => {
    //   block [0x82EEDF70..0x82EEDFA4)
	// 82EEDF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDF78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDF7C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDF80: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDF84: 480002ED  bl 0x82eee270
	ctx.lr = 0x82EEDF88;
	sub_82EEE270(ctx, base);
	// 82EEDF88: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDF8C: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEDF90: 480006F9  bl 0x82eee688
	ctx.lr = 0x82EEDF94;
	sub_82EEE688(ctx, base);
	// 82EEDF94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDF98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDF9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDFA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDFA8 size=156
    let mut pc: u32 = 0x82EEDFA8;
    'dispatch: loop {
        match pc {
            0x82EEDFA8 => {
    //   block [0x82EEDFA8..0x82EEE044)
	// 82EEDFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDFAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDFB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEDFB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDFB8: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEDFBC: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEDFC0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDFC4: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEDFC8: 480008A9  bl 0x82eee870
	ctx.lr = 0x82EEDFCC;
	sub_82EEE870(ctx, base);
	// 82EEDFCC: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEDFD0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EEDFD4: 4198004C  blt cr6, 0x82eee020
	if ctx.cr[6].lt {
	pc = 0x82EEE020; continue 'dispatch;
	}
	// 82EEDFD8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEDFDC: 896B8F71  lbz r11, -0x708f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28815 as u32) ) } as u64;
	// 82EEDFE0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEDFE4: 4082003C  bne 0x82eee020
	if !ctx.cr[0].eq {
	pc = 0x82EEE020; continue 'dispatch;
	}
	// 82EEDFE8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEDFEC: 3BEB8F71  addi r31, r11, -0x708f
	ctx.r[31].s64 = ctx.r[11].s64 + -28815;
	// 82EEDFF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDFF4: 38CBC5A0  addi r6, r11, -0x3a60
	ctx.r[6].s64 = ctx.r[11].s64 + -14944;
	// 82EEDFF8: 38A00019  li r5, 0x19
	ctx.r[5].s64 = 25;
	// 82EEDFFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE000: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE004: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEE008: 4BFFD161  bl 0x82eeb168
	ctx.lr = 0x82EEE00C;
	sub_82EEB168(ctx, base);
	// 82EEE00C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE010: 48203DA9  bl 0x830f1db8
	ctx.lr = 0x82EEE014;
	sub_830F1DB8(ctx, base);
	// 82EEE014: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE018: 40820008  bne 0x82eee020
	if !ctx.cr[0].eq {
	pc = 0x82EEE020; continue 'dispatch;
	}
	// 82EEE01C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEE020: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEE024: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE028: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE02C: 4800088D  bl 0x82eee8b8
	ctx.lr = 0x82EEE030;
	sub_82EEE8B8(ctx, base);
	// 82EEE030: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEE034: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE038: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE03C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE048 size=292
    let mut pc: u32 = 0x82EEE048;
    'dispatch: loop {
        match pc {
            0x82EEE048 => {
    //   block [0x82EEE048..0x82EEE16C)
	// 82EEE048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEE054: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE058: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEE05C: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEE060: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEE064: 90C100AC  stw r6, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[6].u32 ) };
	// 82EEE068: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE06C: 480001CD  bl 0x82eee238
	ctx.lr = 0x82EEE070;
	sub_82EEE238(ctx, base);
	// 82EEE070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEE074: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEE078: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE07C: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 82EEE080: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82EEE084: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EEE088: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EEE08C: 80A100AC  lwz r5, 0xac(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EEE090: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE094: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE098: 4BDD6301  bl 0x82cc4398
	ctx.lr = 0x82EEE09C;
	sub_82CC4398(ctx, base);
	// 82EEE09C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEE0A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE0A4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EEE0A8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE0B0: 419A003C  beq cr6, 0x82eee0ec
	if ctx.cr[6].eq {
	pc = 0x82EEE0EC; continue 'dispatch;
	}
	// 82EEE0B4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE0B8: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 82EEE0BC: 419A001C  beq cr6, 0x82eee0d8
	if ctx.cr[6].eq {
	pc = 0x82EEE0D8; continue 'dispatch;
	}
	// 82EEE0C0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE0C4: 3D408007  lis r10, -0x7ff9
	ctx.r[10].s64 = -2147024896;
	// 82EEE0C8: 614A0057  ori r10, r10, 0x57
	ctx.r[10].u64 = ctx.r[10].u64 | 87;
	// 82EEE0CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEE0D0: 419A0010  beq cr6, 0x82eee0e0
	if ctx.cr[6].eq {
	pc = 0x82EEE0E0; continue 'dispatch;
	}
	// 82EEE0D4: 48000034  b 0x82eee108
	pc = 0x82EEE108; continue 'dispatch;
	// 82EEE0D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEE0DC: 4800007C  b 0x82eee158
	pc = 0x82EEE158; continue 'dispatch;
	// 82EEE0E0: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEE0E4: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EEE0E8: 48000070  b 0x82eee158
	pc = 0x82EEE158; continue 'dispatch;
	// 82EEE0EC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE0F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEE0F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEE0F8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE0FC: 480001F5  bl 0x82eee2f0
	ctx.lr = 0x82EEE100;
	sub_82EEE2F0(ctx, base);
	// 82EEE100: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEE104: 48000054  b 0x82eee158
	pc = 0x82EEE158; continue 'dispatch;
	// 82EEE108: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE10C: 896B8F72  lbz r11, -0x708e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28814 as u32) ) } as u64;
	// 82EEE110: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE114: 4082003C  bne 0x82eee150
	if !ctx.cr[0].eq {
	pc = 0x82EEE150; continue 'dispatch;
	}
	// 82EEE118: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE11C: 3BEB8F72  addi r31, r11, -0x708e
	ctx.r[31].s64 = ctx.r[11].s64 + -28814;
	// 82EEE120: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EEE124: 38CB1700  addi r6, r11, 0x1700
	ctx.r[6].s64 = ctx.r[11].s64 + 5888;
	// 82EEE128: 38A0003D  li r5, 0x3d
	ctx.r[5].s64 = 61;
	// 82EEE12C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE130: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE134: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE138: 4BFFD031  bl 0x82eeb168
	ctx.lr = 0x82EEE13C;
	sub_82EEB168(ctx, base);
	// 82EEE13C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE140: 48203C79  bl 0x830f1db8
	ctx.lr = 0x82EEE144;
	sub_830F1DB8(ctx, base);
	// 82EEE144: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE148: 40820008  bne 0x82eee150
	if !ctx.cr[0].eq {
	pc = 0x82EEE150; continue 'dispatch;
	}
	// 82EEE14C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEE150: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EEE154: 61634005  ori r3, r11, 0x4005
	ctx.r[3].u64 = ctx.r[11].u64 | 16389;
	// 82EEE158: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEE15C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE170 size=80
    let mut pc: u32 = 0x82EEE170;
    'dispatch: loop {
        match pc {
            0x82EEE170 => {
    //   block [0x82EEE170..0x82EEE1C0)
	// 82EEE170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE178: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE17C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE180: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE184: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE188: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE18C: 409A000C  bne cr6, 0x82eee198
	if !ctx.cr[6].eq {
	pc = 0x82EEE198; continue 'dispatch;
	}
	// 82EEE190: 48000020  b 0x82eee1b0
	pc = 0x82EEE1B0; continue 'dispatch;
	// 82EEE194: 4800001C  b 0x82eee1b0
	pc = 0x82EEE1B0; continue 'dispatch;
	// 82EEE198: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE19C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE1A0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EEE1A4: 409A000C  bne cr6, 0x82eee1b0
	if !ctx.cr[6].eq {
	pc = 0x82EEE1B0; continue 'dispatch;
	}
	// 82EEE1A8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE1AC: 4800028D  bl 0x82eee438
	ctx.lr = 0x82EEE1B0;
	sub_82EEE438(ctx, base);
	// 82EEE1B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE1B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE1B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE1BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE1C0 size=120
    let mut pc: u32 = 0x82EEE1C0;
    'dispatch: loop {
        match pc {
            0x82EEE1C0 => {
    //   block [0x82EEE1C0..0x82EEE238)
	// 82EEE1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE1C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EEE1CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEE1D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE1D4: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEE1D8: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEE1DC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE1E0: 48000091  bl 0x82eee270
	ctx.lr = 0x82EEE1E4;
	sub_82EEE270(ctx, base);
	// 82EEE1E4: 83E1009C  lwz r31, 0x9c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE1E8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82EEE1EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE1F0: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE1F4: 388B0024  addi r4, r11, 0x24
	ctx.r[4].s64 = ctx.r[11].s64 + 36;
	// 82EEE1F8: 48005A11  bl 0x82ef3c08
	ctx.lr = 0x82EEE1FC;
	sub_82EF3C08(ctx, base);
	// 82EEE1FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEE200: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EEE204: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEE208: 480007E9  bl 0x82eee9f0
	ctx.lr = 0x82EEE20C;
	sub_82EEE9F0(ctx, base);
	// 82EEE20C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82EEE210: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEE214: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE218: 388B0024  addi r4, r11, 0x24
	ctx.r[4].s64 = ctx.r[11].s64 + 36;
	// 82EEE21C: 480006ED  bl 0x82eee908
	ctx.lr = 0x82EEE220;
	sub_82EEE908(ctx, base);
	// 82EEE220: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEE224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE22C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EEE230: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE238 size=52
    let mut pc: u32 = 0x82EEE238;
    'dispatch: loop {
        match pc {
            0x82EEE238 => {
    //   block [0x82EEE238..0x82EEE26C)
	// 82EEE238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE240: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE244: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE248: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE24C: 48000025  bl 0x82eee270
	ctx.lr = 0x82EEE250;
	sub_82EEE270(ctx, base);
	// 82EEE250: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE254: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE258: 48000739  bl 0x82eee990
	ctx.lr = 0x82EEE25C;
	sub_82EEE990(ctx, base);
	// 82EEE25C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE270 size=128
    let mut pc: u32 = 0x82EEE270;
    'dispatch: loop {
        match pc {
            0x82EEE270 => {
    //   block [0x82EEE270..0x82EEE2F0)
	// 82EEE270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE278: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE27C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE280: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE284: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE28C: 419A0048  beq cr6, 0x82eee2d4
	if ctx.cr[6].eq {
	pc = 0x82EEE2D4; continue 'dispatch;
	}
	// 82EEE290: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE294: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE298: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EEE29C: 409A0020  bne cr6, 0x82eee2bc
	if !ctx.cr[6].eq {
	pc = 0x82EEE2BC; continue 'dispatch;
	}
	// 82EEE2A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE2A8: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EEE2AC: 409A0010  bne cr6, 0x82eee2bc
	if !ctx.cr[6].eq {
	pc = 0x82EEE2BC; continue 'dispatch;
	}
	// 82EEE2B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2B4: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEE2B8: 4BDD5199  bl 0x82cc3450
	ctx.lr = 0x82EEE2BC;
	sub_82CC3450(ctx, base);
	// 82EEE2BC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2C0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE2C4: 4BDD44ED  bl 0x82cc27b0
	ctx.lr = 0x82EEE2C8;
	sub_82CC27B0(ctx, base);
	// 82EEE2C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEE2D0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEE2D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEE2DC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEE2E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE2E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE2E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE2F0 size=324
    let mut pc: u32 = 0x82EEE2F0;
    'dispatch: loop {
        match pc {
            0x82EEE2F0 => {
    //   block [0x82EEE2F0..0x82EEE434)
	// 82EEE2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE2F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEE2FC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE300: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEE304: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE308: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE30C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE310: 409A004C  bne cr6, 0x82eee35c
	if !ctx.cr[6].eq {
	pc = 0x82EEE35C; continue 'dispatch;
	}
	// 82EEE314: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE318: 896B8F74  lbz r11, -0x708c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28812 as u32) ) } as u64;
	// 82EEE31C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE320: 4082003C  bne 0x82eee35c
	if !ctx.cr[0].eq {
	pc = 0x82EEE35C; continue 'dispatch;
	}
	// 82EEE324: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE328: 3BEB8F74  addi r31, r11, -0x708c
	ctx.r[31].s64 = ctx.r[11].s64 + -28812;
	// 82EEE32C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE330: 38CBC5BC  addi r6, r11, -0x3a44
	ctx.r[6].s64 = ctx.r[11].s64 + -14916;
	// 82EEE334: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82EEE338: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE33C: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE340: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE344: 4BFFCE25  bl 0x82eeb168
	ctx.lr = 0x82EEE348;
	sub_82EEB168(ctx, base);
	// 82EEE348: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE34C: 48203A6D  bl 0x830f1db8
	ctx.lr = 0x82EEE350;
	sub_830F1DB8(ctx, base);
	// 82EEE350: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE354: 40820008  bne 0x82eee35c
	if !ctx.cr[0].eq {
	pc = 0x82EEE35C; continue 'dispatch;
	}
	// 82EEE358: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEE35C: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 82EEE360: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEE364: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE368: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEE36C: 4BDBB645  bl 0x82ca99b0
	ctx.lr = 0x82EEE370;
	sub_82CA99B0(ctx, base);
	// 82EEE370: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEE374: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEE378: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE37C: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 82EEE380: 4BDBB631  bl 0x82ca99b0
	ctx.lr = 0x82EEE384;
	sub_82CA99B0(ctx, base);
	// 82EEE384: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE388: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 82EEE38C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EEE390: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEE394: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE398: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EEE39C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE3A0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE3A4: 4BDD63CD  bl 0x82cc4770
	ctx.lr = 0x82EEE3A8;
	sub_82CC4770(ctx, base);
	// 82EEE3A8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EEE3AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE3B0: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EEE3B4: 409A001C  bne cr6, 0x82eee3d0
	if !ctx.cr[6].eq {
	pc = 0x82EEE3D0; continue 'dispatch;
	}
	// 82EEE3B8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE3BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEE3C0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEE3C4: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE3C8: 48000071  bl 0x82eee438
	ctx.lr = 0x82EEE3CC;
	sub_82EEE438(ctx, base);
	// 82EEE3CC: 48000054  b 0x82eee420
	pc = 0x82EEE420; continue 'dispatch;
	// 82EEE3D0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE3D4: 896B8F73  lbz r11, -0x708d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28813 as u32) ) } as u64;
	// 82EEE3D8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE3DC: 4082003C  bne 0x82eee418
	if !ctx.cr[0].eq {
	pc = 0x82EEE418; continue 'dispatch;
	}
	// 82EEE3E0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE3E4: 3BEB8F73  addi r31, r11, -0x708d
	ctx.r[31].s64 = ctx.r[11].s64 + -28813;
	// 82EEE3E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EEE3EC: 38CB1700  addi r6, r11, 0x1700
	ctx.r[6].s64 = ctx.r[11].s64 + 5888;
	// 82EEE3F0: 38A0008C  li r5, 0x8c
	ctx.r[5].s64 = 140;
	// 82EEE3F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE3F8: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE3FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEE400: 4BFFCD69  bl 0x82eeb168
	ctx.lr = 0x82EEE404;
	sub_82EEB168(ctx, base);
	// 82EEE404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE408: 482039B1  bl 0x830f1db8
	ctx.lr = 0x82EEE40C;
	sub_830F1DB8(ctx, base);
	// 82EEE40C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE410: 40820008  bne 0x82eee418
	if !ctx.cr[0].eq {
	pc = 0x82EEE418; continue 'dispatch;
	}
	// 82EEE414: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEE418: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE41C: 4BFFFE55  bl 0x82eee270
	ctx.lr = 0x82EEE420;
	sub_82EEE270(ctx, base);
	// 82EEE420: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEE424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE42C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE438 size=508
    let mut pc: u32 = 0x82EEE438;
    'dispatch: loop {
        match pc {
            0x82EEE438 => {
    //   block [0x82EEE438..0x82EEE634)
	// 82EEE438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEE444: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE448: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EEE44C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE450: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE454: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EEE458: 419A004C  beq cr6, 0x82eee4a4
	if ctx.cr[6].eq {
	pc = 0x82EEE4A4; continue 'dispatch;
	}
	// 82EEE45C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE460: 896B8F76  lbz r11, -0x708a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28810 as u32) ) } as u64;
	// 82EEE464: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE468: 4082003C  bne 0x82eee4a4
	if !ctx.cr[0].eq {
	pc = 0x82EEE4A4; continue 'dispatch;
	}
	// 82EEE46C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE470: 3BEB8F76  addi r31, r11, -0x708a
	ctx.r[31].s64 = ctx.r[11].s64 + -28810;
	// 82EEE474: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE478: 38CBC5DC  addi r6, r11, -0x3a24
	ctx.r[6].s64 = ctx.r[11].s64 + -14884;
	// 82EEE47C: 38A00093  li r5, 0x93
	ctx.r[5].s64 = 147;
	// 82EEE480: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE484: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE488: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEE48C: 4BFFCCDD  bl 0x82eeb168
	ctx.lr = 0x82EEE490;
	sub_82EEB168(ctx, base);
	// 82EEE490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE494: 48203925  bl 0x830f1db8
	ctx.lr = 0x82EEE498;
	sub_830F1DB8(ctx, base);
	// 82EEE498: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE49C: 40820008  bne 0x82eee4a4
	if !ctx.cr[0].eq {
	pc = 0x82EEE4A4; continue 'dispatch;
	}
	// 82EEE4A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEE4A4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE4A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE4AC: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EEE4B0: 419A0170  beq cr6, 0x82eee620
	if ctx.cr[6].eq {
	pc = 0x82EEE620; continue 'dispatch;
	}
	// 82EEE4B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEE4B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEE4BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEE4C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEE4C4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE4C8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEE4CC: 4BDD48B5  bl 0x82cc2d80
	ctx.lr = 0x82EEE4D0;
	sub_82CC2D80(ctx, base);
	// 82EEE4D0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEE4D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE4D8: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EEE4DC: 419A0010  beq cr6, 0x82eee4ec
	if ctx.cr[6].eq {
	pc = 0x82EEE4EC; continue 'dispatch;
	}
	// 82EEE4E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE4E4: 2B0B03E4  cmplwi cr6, r11, 0x3e4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 996 as u32, &mut ctx.xer);
	// 82EEE4E8: 409A0008  bne cr6, 0x82eee4f0
	if !ctx.cr[6].eq {
	pc = 0x82EEE4F0; continue 'dispatch;
	}
	// 82EEE4EC: 48000134  b 0x82eee620
	pc = 0x82EEE620; continue 'dispatch;
	// 82EEE4F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE4F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE4F8: 409A0114  bne cr6, 0x82eee60c
	if !ctx.cr[6].eq {
	pc = 0x82EEE60C; continue 'dispatch;
	}
	// 82EEE4FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE500: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEE504: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEE508: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82EEE50C: 4099004C  ble cr6, 0x82eee558
	if !ctx.cr[6].gt {
	pc = 0x82EEE558; continue 'dispatch;
	}
	// 82EEE510: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE514: 896B8F75  lbz r11, -0x708b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28811 as u32) ) } as u64;
	// 82EEE518: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE51C: 4082003C  bne 0x82eee558
	if !ctx.cr[0].eq {
	pc = 0x82EEE558; continue 'dispatch;
	}
	// 82EEE520: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE524: 3BEB8F75  addi r31, r11, -0x708b
	ctx.r[31].s64 = ctx.r[11].s64 + -28811;
	// 82EEE528: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE52C: 38CBC5D4  addi r6, r11, -0x3a2c
	ctx.r[6].s64 = ctx.r[11].s64 + -14892;
	// 82EEE530: 38A0009F  li r5, 0x9f
	ctx.r[5].s64 = 159;
	// 82EEE534: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE538: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE53C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEE540: 4BFFCC29  bl 0x82eeb168
	ctx.lr = 0x82EEE544;
	sub_82EEB168(ctx, base);
	// 82EEE544: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE548: 48203871  bl 0x830f1db8
	ctx.lr = 0x82EEE54C;
	sub_830F1DB8(ctx, base);
	// 82EEE54C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE550: 40820008  bne 0x82eee558
	if !ctx.cr[0].eq {
	pc = 0x82EEE558; continue 'dispatch;
	}
	// 82EEE554: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEE558: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEE55C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE560: 409900AC  ble cr6, 0x82eee60c
	if !ctx.cr[6].gt {
	pc = 0x82EEE60C; continue 'dispatch;
	}
	// 82EEE564: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE568: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE56C: 48000305  bl 0x82eee870
	ctx.lr = 0x82EEE570;
	sub_82EEE870(ctx, base);
	// 82EEE570: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EEE574: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EEE578: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEE57C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEE580: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE584: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE588: 48000281  bl 0x82eee808
	ctx.lr = 0x82EEE58C;
	sub_82EEE808(ctx, base);
	// 82EEE58C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEE590: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEE594: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EEE598: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EEE59C: 4800001C  b 0x82eee5b8
	pc = 0x82EEE5B8; continue 'dispatch;
	// 82EEE5A0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEE5A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EEE5A8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEE5AC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE5B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EEE5B4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EEE5B8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEE5BC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEE5C0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EEE5C4: 4098003C  bge cr6, 0x82eee600
	if !ctx.cr[6].lt {
	pc = 0x82EEE600; continue 'dispatch;
	}
	// 82EEE5C8: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE5CC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE5D0: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE5D4: 480002E5  bl 0x82eee8b8
	ctx.lr = 0x82EEE5D8;
	sub_82EEE8B8(ctx, base);
	// 82EEE5D8: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEE5DC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEE5E0: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEE5E4: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE5E8: 394A0034  addi r10, r10, 0x34
	ctx.r[10].s64 = ctx.r[10].s64 + 52;
	// 82EEE5EC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEE5F0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE5F4: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEE5F8: 4BDBAE89  bl 0x82ca9480
	ctx.lr = 0x82EEE5FC;
	sub_82CA9480(ctx, base);
	// 82EEE5FC: 4BFFFFA4  b 0x82eee5a0
	pc = 0x82EEE5A0; continue 'dispatch;
	// 82EEE600: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE604: 4BFFFCED  bl 0x82eee2f0
	ctx.lr = 0x82EEE608;
	sub_82EEE2F0(ctx, base);
	// 82EEE608: 48000018  b 0x82eee620
	pc = 0x82EEE620; continue 'dispatch;
	// 82EEE60C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE610: 4BFFFC61  bl 0x82eee270
	ctx.lr = 0x82EEE614;
	sub_82EEE270(ctx, base);
	// 82EEE614: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE618: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEE61C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEE620: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EEE624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE62C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE638 size=76
    let mut pc: u32 = 0x82EEE638;
    'dispatch: loop {
        match pc {
            0x82EEE638 => {
    //   block [0x82EEE638..0x82EEE684)
	// 82EEE638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE640: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE644: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE648: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEE64C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEE650: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE654: 48116555  bl 0x83004ba8
	ctx.lr = 0x82EEE658;
	sub_83004BA8(ctx, base);
	// 82EEE658: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEE65C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE660: 480007B9  bl 0x82eeee18
	ctx.lr = 0x82EEE664;
	sub_82EEEE18(ctx, base);
	// 82EEE664: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEE668: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE66C: 4800061D  bl 0x82eeec88
	ctx.lr = 0x82EEE670;
	sub_82EEEC88(ctx, base);
	// 82EEE670: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE674: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE678: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE67C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE688 size=40
    let mut pc: u32 = 0x82EEE688;
    'dispatch: loop {
        match pc {
            0x82EEE688 => {
    //   block [0x82EEE688..0x82EEE6B0)
	// 82EEE688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE68C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE690: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE694: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE698: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE69C: 480006E5  bl 0x82eeed80
	ctx.lr = 0x82EEE6A0;
	sub_82EEED80(ctx, base);
	// 82EEE6A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE6A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE6A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE6AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE6B0 size=344
    let mut pc: u32 = 0x82EEE6B0;
    'dispatch: loop {
        match pc {
            0x82EEE6B0 => {
    //   block [0x82EEE6B0..0x82EEE808)
	// 82EEE6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE6B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE6B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE6BC: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEE6C0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEE6C4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE6C8: 48000509  bl 0x82eeebd0
	ctx.lr = 0x82EEE6CC;
	sub_82EEEBD0(ctx, base);
	// 82EEE6CC: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE6D0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEE6D4: 4098000C  bge cr6, 0x82eee6e0
	if !ctx.cr[6].lt {
	pc = 0x82EEE6E0; continue 'dispatch;
	}
	// 82EEE6D8: 4BFFF069  bl 0x82eed740
	ctx.lr = 0x82EEE6DC;
	sub_82EED740(ctx, base);
	// 82EEE6DC: 4800011C  b 0x82eee7f8
	pc = 0x82EEE7F8; continue 'dispatch;
	// 82EEE6E0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE6E4: 4800035D  bl 0x82eeea40
	ctx.lr = 0x82EEE6E8;
	sub_82EEEA40(ctx, base);
	// 82EEE6E8: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE6EC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEE6F0: 40980108  bge cr6, 0x82eee7f8
	if !ctx.cr[6].lt {
	pc = 0x82EEE7F8; continue 'dispatch;
	}
	// 82EEE6F4: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE6F8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE6FC: 48000755  bl 0x82eeee50
	ctx.lr = 0x82EEE700;
	sub_82EEEE50(ctx, base);
	// 82EEE700: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EEE704: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE708: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EEE70C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE710: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE714: 48000375  bl 0x82eeea88
	ctx.lr = 0x82EEE718;
	sub_82EEEA88(ctx, base);
	// 82EEE718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE71C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EEE720: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE724: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEE728: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEE72C: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE730: 480054D9  bl 0x82ef3c08
	ctx.lr = 0x82EEE734;
	sub_82EF3C08(ctx, base);
	// 82EEE734: E8830000  ld r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEE738: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE73C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82EEE740: 80C10068  lwz r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EEE744: 48000C4D  bl 0x82eef390
	ctx.lr = 0x82EEE748;
	sub_82EEF390(ctx, base);
	// 82EEE748: 48000014  b 0x82eee75c
	pc = 0x82EEE75C; continue 'dispatch;
	// 82EEE74C: 80A1009C  lwz r5, 0x9c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE750: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE754: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE758: 48116619  bl 0x83004d70
	ctx.lr = 0x82EEE75C;
	sub_83004D70(ctx, base);
	// 82EEE75C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE760: 48000111  bl 0x82eee870
	ctx.lr = 0x82EEE764;
	sub_82EEE870(ctx, base);
	// 82EEE764: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEE768: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE76C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE774: 419A0048  beq cr6, 0x82eee7bc
	if ctx.cr[6].eq {
	pc = 0x82EEE7BC; continue 'dispatch;
	}
	// 82EEE778: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE77C: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE780: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE784: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE788: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE78C: 480005BD  bl 0x82eeed48
	ctx.lr = 0x82EEE790;
	sub_82EEED48(ctx, base);
	// 82EEE790: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE794: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE798: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEE79C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE7A0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEE7A4: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEE7A8: 7CAB53D6  divw r5, r11, r10
	ctx.r[5].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEE7AC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7B0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE7B4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7B8: 481165B9  bl 0x83004d70
	ctx.lr = 0x82EEE7BC;
	sub_83004D70(ctx, base);
	// 82EEE7BC: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE7C0: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEE7C4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE7C8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEE7CC: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7D0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EEE7D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE7D8: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEE7DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE7E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEE7E4: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7E8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEE7EC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7F0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE7F4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEE7F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEE7FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE808 size=104
    let mut pc: u32 = 0x82EEE808;
    'dispatch: loop {
        match pc {
            0x82EEE808 => {
    //   block [0x82EEE808..0x82EEE870)
	// 82EEE808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE810: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE814: 906102B4  stw r3, 0x2b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(692 as u32), ctx.r[3].u32 ) };
	// 82EEE818: 908102BC  stw r4, 0x2bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(700 as u32), ctx.r[4].u32 ) };
	// 82EEE81C: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEE820: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEE824: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82EEE828: 4BDBB189  bl 0x82ca99b0
	ctx.lr = 0x82EEE82C;
	sub_82CA99B0(ctx, base);
	// 82EEE82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEE830: 38810190  addi r4, r1, 0x190
	ctx.r[4].s64 = ctx.r[1].s64 + 400;
	// 82EEE834: 38A00108  li r5, 0x108
	ctx.r[5].s64 = 264;
	// 82EEE838: 4BDBAC49  bl 0x82ca9480
	ctx.lr = 0x82EEE83C;
	sub_82CA9480(ctx, base);
	// 82EEE83C: E8A10160  ld r5, 0x160(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 82EEE840: E8C10168  ld r6, 0x168(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) };
	// 82EEE844: E8E10170  ld r7, 0x170(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 82EEE848: E9010178  ld r8, 0x178(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 82EEE84C: E9210180  ld r9, 0x180(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) };
	// 82EEE850: E9410188  ld r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 82EEE854: 808102BC  lwz r4, 0x2bc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(700 as u32) ) } as u64;
	// 82EEE858: 806102B4  lwz r3, 0x2b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(692 as u32) ) } as u64;
	// 82EEE85C: 4800026D  bl 0x82eeeac8
	ctx.lr = 0x82EEE860;
	sub_82EEEAC8(ctx, base);
	// 82EEE860: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 82EEE864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE86C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEE870 size=32
    let mut pc: u32 = 0x82EEE870;
    'dispatch: loop {
        match pc {
            0x82EEE870 => {
    //   block [0x82EEE870..0x82EEE890)
	// 82EEE870: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEE874: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEE878: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE880: 409A0010  bne cr6, 0x82eee890
	if !ctx.cr[6].eq {
		sub_82EEE890(ctx, base);
		return;
	}
	// 82EEE884: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEE888: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEE88C: 48000024  b 0x82eee8b0
	sub_82EEE890(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEE890 size=40
    let mut pc: u32 = 0x82EEE890;
    'dispatch: loop {
        match pc {
            0x82EEE890 => {
    //   block [0x82EEE890..0x82EEE8B8)
	// 82EEE890: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEE894: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEE898: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE89C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE8A0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEE8A4: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEE8A8: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEE8AC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEE8B0: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEE8B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE8B8 size=80
    let mut pc: u32 = 0x82EEE8B8;
    'dispatch: loop {
        match pc {
            0x82EEE8B8 => {
    //   block [0x82EEE8B8..0x82EEE908)
	// 82EEE8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE8BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE8C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE8C4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE8C8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEE8CC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE8D0: 4BFFFFA1  bl 0x82eee870
	ctx.lr = 0x82EEE8D4;
	sub_82EEE870(ctx, base);
	// 82EEE8D4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE8D8: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EEE8DC: 41980008  blt cr6, 0x82eee8e4
	if ctx.cr[6].lt {
	pc = 0x82EEE8E4; continue 'dispatch;
	}
	// 82EEE8E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEE8E4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE8E8: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE8EC: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s64 = ctx.r[10].s64 * 312;
	// 82EEE8F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE8F4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEE8F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE8FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE908 size=136
    let mut pc: u32 = 0x82EEE908;
    'dispatch: loop {
        match pc {
            0x82EEE908 => {
    //   block [0x82EEE908..0x82EEE990)
	// 82EEE908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE90C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE910: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE914: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE918: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEE91C: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEE920: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE924: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE928: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE92C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE930: 386B0138  addi r3, r11, 0x138
	ctx.r[3].s64 = ctx.r[11].s64 + 312;
	// 82EEE934: 48000A9D  bl 0x82eef3d0
	ctx.lr = 0x82EEE938;
	sub_82EEF3D0(ctx, base);
	// 82EEE938: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE93C: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE940: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE944: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE948: 388BFEC8  addi r4, r11, -0x138
	ctx.r[4].s64 = ctx.r[11].s64 + -312;
	// 82EEE94C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE950: 480003F9  bl 0x82eeed48
	ctx.lr = 0x82EEE954;
	sub_82EEED48(ctx, base);
	// 82EEE954: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE958: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE95C: 396BFEC8  addi r11, r11, -0x138
	ctx.r[11].s64 = ctx.r[11].s64 + -312;
	// 82EEE960: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE964: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEE968: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE96C: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EEE970: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEE974: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE978: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEE97C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE980: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE98C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE990 size=92
    let mut pc: u32 = 0x82EEE990;
    'dispatch: loop {
        match pc {
            0x82EEE990 => {
    //   block [0x82EEE990..0x82EEE9EC)
	// 82EEE990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE998: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE99C: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEE9A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEE9A4: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE9A8: 480000E1  bl 0x82eeea88
	ctx.lr = 0x82EEE9AC;
	sub_82EEEA88(ctx, base);
	// 82EEE9AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE9B0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EEE9B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE9B8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EEE9BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE9C0: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE9C4: 48005245  bl 0x82ef3c08
	ctx.lr = 0x82EEE9C8;
	sub_82EF3C08(ctx, base);
	// 82EEE9C8: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEE9CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEE9D0: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE9D4: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82EEE9D8: 48000221  bl 0x82eeebf8
	ctx.lr = 0x82EEE9DC;
	sub_82EEEBF8(ctx, base);
	// 82EEE9DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEE9E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE9E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE9E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE9F0 size=80
    let mut pc: u32 = 0x82EEE9F0;
    'dispatch: loop {
        match pc {
            0x82EEE9F0 => {
    //   block [0x82EEE9F0..0x82EEEA40)
	// 82EEE9F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE9F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE9F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE9FC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEA00: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEA04: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEEA08: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEA0C: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82EEEA10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82EEEA14: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEEA18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEEA1C: 48000465  bl 0x82eeee80
	ctx.lr = 0x82EEEA20;
	sub_82EEEE80(ctx, base);
	// 82EEEA20: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEEA24: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEA28: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82EEEA2C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEA30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEA34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEA38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEA3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEEA40 size=32
    let mut pc: u32 = 0x82EEEA40;
    'dispatch: loop {
        match pc {
            0x82EEEA40 => {
    //   block [0x82EEEA40..0x82EEEA60)
	// 82EEEA40: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEEA44: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEEA48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEEA50: 409A0010  bne cr6, 0x82eeea60
	if !ctx.cr[6].eq {
		sub_82EEEA60(ctx, base);
		return;
	}
	// 82EEEA54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEEA58: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEEA5C: 48000024  b 0x82eeea80
	sub_82EEEA60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEEA60 size=40
    let mut pc: u32 = 0x82EEEA60;
    'dispatch: loop {
        match pc {
            0x82EEEA60 => {
    //   block [0x82EEEA60..0x82EEEA88)
	// 82EEEA60: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEEA64: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEEA68: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEEA6C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEA70: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEEA74: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEEA78: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEEA7C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEEA80: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEEA84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEA88 size=60
    let mut pc: u32 = 0x82EEEA88;
    'dispatch: loop {
        match pc {
            0x82EEEA88 => {
    //   block [0x82EEEA88..0x82EEEAC4)
	// 82EEEA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEA90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEA94: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEA98: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEA9C: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEAA0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEAA4: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEEAA8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEAAC: 480058AD  bl 0x82ef4358
	ctx.lr = 0x82EEEAB0;
	sub_82EF4358(ctx, base);
	// 82EEEAB0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEAB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEAB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEAC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEAC8 size=264
    let mut pc: u32 = 0x82EEEAC8;
    'dispatch: loop {
        match pc {
            0x82EEEAC8 => {
    //   block [0x82EEEAC8..0x82EEEBD0)
	// 82EEEAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEAD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EEEAD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEEAD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEADC: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EEEAE0: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 82EEEAE4: F8A100C0  std r5, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[5].u64 ) };
	// 82EEEAE8: F8C100C8  std r6, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[6].u64 ) };
	// 82EEEAEC: F8E100D0  std r7, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[7].u64 ) };
	// 82EEEAF0: F90100D8  std r8, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[8].u64 ) };
	// 82EEEAF4: F92100E0  std r9, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[9].u64 ) };
	// 82EEEAF8: F94100E8  std r10, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[10].u64 ) };
	// 82EEEAFC: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB00: 4BFFFD71  bl 0x82eee870
	ctx.lr = 0x82EEEB04;
	sub_82EEE870(ctx, base);
	// 82EEEB04: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEEB08: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEEB0C: 40980044  bge cr6, 0x82eeeb50
	if !ctx.cr[6].lt {
	pc = 0x82EEEB50; continue 'dispatch;
	}
	// 82EEEB10: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 82EEEB14: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EEEB18: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB1C: 4BFFFD55  bl 0x82eee870
	ctx.lr = 0x82EEEB20;
	sub_82EEE870(ctx, base);
	// 82EEEB20: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEEB24: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82EEEB28: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEEB2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEEB30: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB34: 4BFFFF55  bl 0x82eeea88
	ctx.lr = 0x82EEEB38;
	sub_82EEEA88(ctx, base);
	// 82EEEB38: E8830000  ld r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEEB3C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB40: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEB44: 80C10078  lwz r6, 0x78(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EEEB48: 48000371  bl 0x82eeeeb8
	ctx.lr = 0x82EEEB4C;
	sub_82EEEEB8(ctx, base);
	// 82EEEB4C: 4800006C  b 0x82eeebb8
	pc = 0x82EEEBB8; continue 'dispatch;
	// 82EEEB50: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB54: 4BFFFD1D  bl 0x82eee870
	ctx.lr = 0x82EEEB58;
	sub_82EEE870(ctx, base);
	// 82EEEB58: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEEB5C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EEEB60: 40980058  bge cr6, 0x82eeebb8
	if !ctx.cr[6].lt {
	pc = 0x82EEEBB8; continue 'dispatch;
	}
	// 82EEEB64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEEB68: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB6C: 4BFFFF1D  bl 0x82eeea88
	ctx.lr = 0x82EEEB70;
	sub_82EEEA88(ctx, base);
	// 82EEEB70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEEB74: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EEEB78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEB7C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEEB80: 83E100BC  lwz r31, 0xbc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEEB84: 3BC10068  addi r30, r1, 0x68
	ctx.r[30].s64 = ctx.r[1].s64 + 104;
	// 82EEEB88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEEB8C: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB90: 48005079  bl 0x82ef3c08
	ctx.lr = 0x82EEEB94;
	sub_82EF3C08(ctx, base);
	// 82EEEB94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEEB98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EEEB9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEEBA0: 4BFFFE51  bl 0x82eee9f0
	ctx.lr = 0x82EEEBA4;
	sub_82EEE9F0(ctx, base);
	// 82EEEBA4: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEEBA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EEEBAC: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEBB0: E8C10080  ld r6, 0x80(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEEBB4: 48000045  bl 0x82eeebf8
	ctx.lr = 0x82EEEBB8;
	sub_82EEEBF8(ctx, base);
	// 82EEEBB8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EEEBBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEBC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEBC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EEEBC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEEBCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEBD0 size=40
    let mut pc: u32 = 0x82EEEBD0;
    'dispatch: loop {
        match pc {
            0x82EEEBD0 => {
    //   block [0x82EEEBD0..0x82EEEBF8)
	// 82EEEBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEBD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEBD8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEBDC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEBE0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEBE4: 4800068D  bl 0x82eef270
	ctx.lr = 0x82EEEBE8;
	sub_82EEF270(ctx, base);
	// 82EEEBE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEBEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEBF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEBF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEBF8 size=144
    let mut pc: u32 = 0x82EEEBF8;
    'dispatch: loop {
        match pc {
            0x82EEEBF8 => {
    //   block [0x82EEEBF8..0x82EEEC88)
	// 82EEEBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEBFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEC00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEC04: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEC08: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEC0C: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEEC10: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82EEEC14: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82EEEC18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEEC1C: 4811581D  bl 0x83004438
	ctx.lr = 0x82EEEC20;
	sub_83004438(ctx, base);
	// 82EEEC20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEEC24: 4182003C  beq 0x82eeec60
	if ctx.cr[0].eq {
	pc = 0x82EEEC60; continue 'dispatch;
	}
	// 82EEEC28: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEEC2C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEC30: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEEC34: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEEC38: 48000799  bl 0x82eef3d0
	ctx.lr = 0x82EEEC3C;
	sub_82EEF3D0(ctx, base);
	// 82EEEC3C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EEEC40: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEC44: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEEC48: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEEC4C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEC50: 480000F9  bl 0x82eeed48
	ctx.lr = 0x82EEEC54;
	sub_82EEED48(ctx, base);
	// 82EEEC54: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEC58: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEEC5C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEEC60: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEC64: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EEEC68: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEEC6C: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEEC70: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEEC74: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEC78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEC7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEC80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEC84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEC88 size=192
    let mut pc: u32 = 0x82EEEC88;
    'dispatch: loop {
        match pc {
            0x82EEEC88 => {
    //   block [0x82EEEC88..0x82EEED48)
	// 82EEEC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEC8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEC90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEC94: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEC98: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEC9C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEECA4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEECA8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEECB0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEECB4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEECBC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EEECC0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEECC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEECC8: 409A0010  bne cr6, 0x82eeecd8
	if !ctx.cr[6].eq {
	pc = 0x82EEECD8; continue 'dispatch;
	}
	// 82EEECCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEECD0: 48000068  b 0x82eeed38
	pc = 0x82EEED38; continue 'dispatch;
	// 82EEECD4: 48000060  b 0x82eeed34
	pc = 0x82EEED34; continue 'dispatch;
	// 82EEECD8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECDC: 4BFFFEF5  bl 0x82eeebd0
	ctx.lr = 0x82EEECE0;
	sub_82EEEBD0(ctx, base);
	// 82EEECE0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEECE4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEECE8: 4098000C  bge cr6, 0x82eeecf4
	if !ctx.cr[6].lt {
	pc = 0x82EEECF4; continue 'dispatch;
	}
	// 82EEECEC: 4BFFEA55  bl 0x82eed740
	ctx.lr = 0x82EEECF0;
	sub_82EED740(ctx, base);
	// 82EEECF0: 48000044  b 0x82eeed34
	pc = 0x82EEED34; continue 'dispatch;
	// 82EEECF4: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEECF8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECFC: 48000155  bl 0x82eeee50
	ctx.lr = 0x82EEED00;
	sub_82EEEE50(ctx, base);
	// 82EEED00: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED04: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EEED08: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED0C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEED14: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEED18: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED1C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEED20: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s64 = ctx.r[10].s64 * 312;
	// 82EEED24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEED28: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEED2C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED30: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EEED34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEED38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEED3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEED40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEED44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEED48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEED48 size=56
    let mut pc: u32 = 0x82EEED48;
    'dispatch: loop {
        match pc {
            0x82EEED48 => {
    //   block [0x82EEED48..0x82EEED80)
	// 82EEED48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEED4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEED50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEED54: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEED58: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEED5C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEED60: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED64: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEED68: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEED6C: 480006FD  bl 0x82eef468
	ctx.lr = 0x82EEED70;
	sub_82EEF468(ctx, base);
	// 82EEED70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEED74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEED78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEED7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEED80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEED80 size=152
    let mut pc: u32 = 0x82EEED80;
    'dispatch: loop {
        match pc {
            0x82EEED80 => {
    //   block [0x82EEED80..0x82EEEE18)
	// 82EEED80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEED84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEED88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEED8C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEED90: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEED98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEED9C: 419A0048  beq cr6, 0x82eeede4
	if ctx.cr[6].eq {
	pc = 0x82EEEDE4; continue 'dispatch;
	}
	// 82EEEDA0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDA4: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEEDA8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDAC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEDB0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDB4: 4BFFFF95  bl 0x82eeed48
	ctx.lr = 0x82EEEDB8;
	sub_82EEED48(ctx, base);
	// 82EEEDB8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDBC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDC0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEEDC4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEDC8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEEDCC: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEEDD0: 7CAB53D6  divw r5, r11, r10
	ctx.r[5].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEEDD4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDD8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEDDC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDE0: 48115F91  bl 0x83004d70
	ctx.lr = 0x82EEEDE4;
	sub_83004D70(ctx, base);
	// 82EEEDE4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEEDEC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEEDF0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEEDF8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEEDFC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEE00: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEEE04: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EEEE08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEE0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEE10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEE14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEE18 size=52
    let mut pc: u32 = 0x82EEEE18;
    'dispatch: loop {
        match pc {
            0x82EEEE18 => {
    //   block [0x82EEEE18..0x82EEEE4C)
	// 82EEEE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEE20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEE24: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEE28: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEE2C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEE30: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEE34: 4BFFE95D  bl 0x82eed790
	ctx.lr = 0x82EEEE38;
	sub_82EED790(ctx, base);
	// 82EEEE38: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEE3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEE40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEE44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEE48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEE50 size=48
    let mut pc: u32 = 0x82EEEE50;
    'dispatch: loop {
        match pc {
            0x82EEEE50 => {
    //   block [0x82EEEE50..0x82EEEE80)
	// 82EEEE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEE54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEE58: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEE5C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEE60: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEE64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEEE68: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEE6C: 4800064D  bl 0x82eef4b8
	ctx.lr = 0x82EEEE70;
	sub_82EEF4B8(ctx, base);
	// 82EEEE70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEE74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEE78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEE7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEE80 size=52
    let mut pc: u32 = 0x82EEEE80;
    'dispatch: loop {
        match pc {
            0x82EEEE80 => {
    //   block [0x82EEEE80..0x82EEEEB4)
	// 82EEEE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEE88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEE8C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEE90: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEE94: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEE98: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEE9C: 4800040D  bl 0x82eef2a8
	ctx.lr = 0x82EEEEA0;
	sub_82EEF2A8(ctx, base);
	// 82EEEEA0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEEA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEEA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEEAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEEB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEEB8 size=948
    let mut pc: u32 = 0x82EEEEB8;
    'dispatch: loop {
        match pc {
            0x82EEEEB8 => {
    //   block [0x82EEEEB8..0x82EEF26C)
	// 82EEEEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEEBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEEC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEEEC4: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEEC8: 906101C4  stw r3, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[3].u32 ) };
	// 82EEEECC: F88101C8  std r4, 0x1c8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[4].u64 ) };
	// 82EEEED0: 90A101D4  stw r5, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[5].u32 ) };
	// 82EEEED4: 90C101DC  stw r6, 0x1dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(476 as u32), ctx.r[6].u32 ) };
	// 82EEEED8: 808101DC  lwz r4, 0x1dc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(476 as u32) ) } as u64;
	// 82EEEEDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEEEE0: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEEEE4: 4BDBA59D  bl 0x82ca9480
	ctx.lr = 0x82EEEEE8;
	sub_82CA9480(ctx, base);
	// 82EEEEE8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEEEC: 4BFFFB55  bl 0x82eeea40
	ctx.lr = 0x82EEEEF0;
	sub_82EEEA40(ctx, base);
	// 82EEEEF0: 90610188  stw r3, 0x188(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[3].u32 ) };
	// 82EEEEF4: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEEF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEEEFC: 409A0008  bne cr6, 0x82eeef04
	if !ctx.cr[6].eq {
	pc = 0x82EEEF04; continue 'dispatch;
	}
	// 82EEEF00: 48000358  b 0x82eef258
	pc = 0x82EEF258; continue 'dispatch;
	// 82EEEF04: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEF08: 4BFFFCC9  bl 0x82eeebd0
	ctx.lr = 0x82EEEF0C;
	sub_82EEEBD0(ctx, base);
	// 82EEEF0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEEF10: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEF14: 4BFFF95D  bl 0x82eee870
	ctx.lr = 0x82EEEF18;
	sub_82EEE870(ctx, base);
	// 82EEEF18: 7D63F850  subf r11, r3, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 82EEEF1C: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEF20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEEF24: 4098000C  bge cr6, 0x82eeef30
	if !ctx.cr[6].lt {
	pc = 0x82EEEF30; continue 'dispatch;
	}
	// 82EEEF28: 4BFFE819  bl 0x82eed740
	ctx.lr = 0x82EEEF2C;
	sub_82EED740(ctx, base);
	// 82EEEF2C: 4800032C  b 0x82eef258
	pc = 0x82EEF258; continue 'dispatch;
	// 82EEEF30: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEF34: 4BFFF93D  bl 0x82eee870
	ctx.lr = 0x82EEEF38;
	sub_82EEE870(ctx, base);
	// 82EEEF38: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEF3C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82EEEF40: 81410188  lwz r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF44: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEEF48: 409801B4  bge cr6, 0x82eef0fc
	if !ctx.cr[6].lt {
	pc = 0x82EEF0FC; continue 'dispatch;
	}
	// 82EEEF4C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEF50: 4BFFFC81  bl 0x82eeebd0
	ctx.lr = 0x82EEEF54;
	sub_82EEEBD0(ctx, base);
	// 82EEEF54: 81610188  lwz r11, 0x188(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF58: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EEEF5C: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EEEF60: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82EEEF64: 81410188  lwz r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEEF6C: 40980010  bge cr6, 0x82eeef7c
	if !ctx.cr[6].lt {
	pc = 0x82EEEF7C; continue 'dispatch;
	}
	// 82EEEF70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEEF74: 91610198  stw r11, 0x198(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EEEF78: 4800001C  b 0x82eeef94
	pc = 0x82EEEF94; continue 'dispatch;
	// 82EEEF7C: 81610188  lwz r11, 0x188(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF80: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EEEF84: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EEEF88: 81410188  lwz r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF8C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEEF90: 91610198  stw r11, 0x198(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EEEF94: 81610198  lwz r11, 0x198(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EEEF98: 91610188  stw r11, 0x188(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 82EEEF9C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFA0: 4BFFF8D1  bl 0x82eee870
	ctx.lr = 0x82EEEFA4;
	sub_82EEE870(ctx, base);
	// 82EEEFA4: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEFA8: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82EEEFAC: 81410188  lwz r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEFB0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEEFB4: 40980018  bge cr6, 0x82eeefcc
	if !ctx.cr[6].lt {
	pc = 0x82EEEFCC; continue 'dispatch;
	}
	// 82EEEFB8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFBC: 4BFFF8B5  bl 0x82eee870
	ctx.lr = 0x82EEEFC0;
	sub_82EEE870(ctx, base);
	// 82EEEFC0: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEFC4: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82EEEFC8: 91610188  stw r11, 0x188(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 82EEEFCC: 80810188  lwz r4, 0x188(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEFD0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFD4: 4BFFFE7D  bl 0x82eeee50
	ctx.lr = 0x82EEEFD8;
	sub_82EEEE50(ctx, base);
	// 82EEEFD8: 90610190  stw r3, 0x190(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[3].u32 ) };
	// 82EEEFDC: 81610190  lwz r11, 0x190(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEEFE0: 9161018C  stw r11, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 82EEEFE4: 80C10190  lwz r6, 0x190(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEEFE8: 80A101CC  lwz r5, 0x1cc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEEFEC: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFF0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEFF4: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFF8: 48000539  bl 0x82eef530
	ctx.lr = 0x82EEEFFC;
	sub_82EEF530(ctx, base);
	// 82EEEFFC: 9061018C  stw r3, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[3].u32 ) };
	// 82EEF000: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EEF004: 80A101D4  lwz r5, 0x1d4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF008: 8081018C  lwz r4, 0x18c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EEF00C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF010: 48000331  bl 0x82eef340
	ctx.lr = 0x82EEF014;
	sub_82EEF340(ctx, base);
	// 82EEF014: 9061018C  stw r3, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[3].u32 ) };
	// 82EEF018: 80C1018C  lwz r6, 0x18c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EEF01C: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF020: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF024: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF028: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF02C: 48000505  bl 0x82eef530
	ctx.lr = 0x82EEF030;
	sub_82EEF530(ctx, base);
	// 82EEF030: 48000024  b 0x82eef054
	pc = 0x82EEF054; continue 'dispatch;
	// 82EEF034: 80A1018C  lwz r5, 0x18c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EEF038: 80810190  lwz r4, 0x190(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF03C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF040: 4BFFFD09  bl 0x82eeed48
	ctx.lr = 0x82EEF044;
	sub_82EEED48(ctx, base);
	// 82EEF044: 80A10188  lwz r5, 0x188(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEF048: 80810190  lwz r4, 0x190(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF04C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF050: 48115D21  bl 0x83004d70
	ctx.lr = 0x82EEF054;
	sub_83004D70(ctx, base);
	// 82EEF054: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF058: 4BFFF819  bl 0x82eee870
	ctx.lr = 0x82EEF05C;
	sub_82EEE870(ctx, base);
	// 82EEF05C: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF060: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EEF064: 916101D4  stw r11, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82EEF068: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF06C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEF074: 419A0048  beq cr6, 0x82eef0bc
	if ctx.cr[6].eq {
	pc = 0x82EEF0BC; continue 'dispatch;
	}
	// 82EEF078: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF07C: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF080: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF084: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF088: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF08C: 4BFFFCBD  bl 0x82eeed48
	ctx.lr = 0x82EEF090;
	sub_82EEED48(ctx, base);
	// 82EEF090: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF094: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF098: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEF09C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF0A0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF0A4: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEF0A8: 7CAB53D6  divw r5, r11, r10
	ctx.r[5].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEF0AC: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0B0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF0B4: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0B8: 48115CB9  bl 0x83004d70
	ctx.lr = 0x82EEF0BC;
	sub_83004D70(ctx, base);
	// 82EEF0BC: 81610188  lwz r11, 0x188(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEF0C0: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEF0C4: 81410190  lwz r10, 0x190(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF0C8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF0CC: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0D0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EEF0D4: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF0D8: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEF0DC: 81410190  lwz r10, 0x190(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF0E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF0E4: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0E8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEF0EC: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0F0: 81410190  lwz r10, 0x190(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF0F4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEF0F8: 48000160  b 0x82eef258
	pc = 0x82EEF258; continue 'dispatch;
	// 82EEF0FC: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF100: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF104: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF108: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF10C: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEF110: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEF114: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF118: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF11C: 409800CC  bge cr6, 0x82eef1e8
	if !ctx.cr[6].lt {
	pc = 0x82EEF1E8; continue 'dispatch;
	}
	// 82EEF120: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF124: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEF128: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF12C: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF130: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF134: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF138: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF13C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF140: 480003F1  bl 0x82eef530
	ctx.lr = 0x82EEF144;
	sub_82EEF530(ctx, base);
	// 82EEF144: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EEF148: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF14C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF150: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF154: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF158: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEF15C: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEF160: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF164: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEF168: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF16C: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF170: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF174: 480001CD  bl 0x82eef340
	ctx.lr = 0x82EEF178;
	sub_82EEF340(ctx, base);
	// 82EEF178: 48000030  b 0x82eef1a8
	pc = 0x82EEF1A8; continue 'dispatch;
	// 82EEF17C: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF180: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF184: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s64 = ctx.r[10].s64 * 312;
	// 82EEF188: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF18C: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF190: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF194: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEF198: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF19C: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF1A0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1A4: 4BFFFBA5  bl 0x82eeed48
	ctx.lr = 0x82EEF1A8;
	sub_82EEED48(ctx, base);
	// 82EEF1A8: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1AC: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF1B0: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s64 = ctx.r[10].s64 * 312;
	// 82EEF1B4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF1B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF1BC: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1C0: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEF1C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EEF1C8: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1CC: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF1D0: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s64 = ctx.r[10].s64 * 312;
	// 82EEF1D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF1D8: 7C8A5850  subf r4, r10, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF1DC: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF1E0: 48000391  bl 0x82eef570
	ctx.lr = 0x82EEF1E4;
	sub_82EEF570(ctx, base);
	// 82EEF1E4: 48000074  b 0x82eef258
	pc = 0x82EEF258; continue 'dispatch;
	// 82EEF1E8: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1EC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF1F0: 91610194  stw r11, 0x194(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EEF1F4: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1F8: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF1FC: 80A10194  lwz r5, 0x194(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EEF200: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF204: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEF208: 81410194  lwz r10, 0x194(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EEF20C: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEF210: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF214: 4800031D  bl 0x82eef530
	ctx.lr = 0x82EEF218;
	sub_82EEF530(ctx, base);
	// 82EEF218: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF21C: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EEF220: 80A10194  lwz r5, 0x194(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EEF224: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF228: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEF22C: 81410194  lwz r10, 0x194(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EEF230: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEF234: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF238: 48000399  bl 0x82eef5d0
	ctx.lr = 0x82EEF23C;
	sub_82EEF5D0(ctx, base);
	// 82EEF23C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EEF240: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF244: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEF248: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF24C: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF250: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF254: 4800031D  bl 0x82eef570
	ctx.lr = 0x82EEF258;
	sub_82EEF570(ctx, base);
	// 82EEF258: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82EEF25C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF260: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEF268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEF270 size=40
    let mut pc: u32 = 0x82EEF270;
    'dispatch: loop {
        match pc {
            0x82EEF270 => {
    //   block [0x82EEF270..0x82EEF298)
	// 82EEF270: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEF274: 3D6000D2  lis r11, 0xd2
	ctx.r[11].s64 = 13762560;
	// 82EEF278: 616B0D20  ori r11, r11, 0xd20
	ctx.r[11].u64 = ctx.r[11].u64 | 3360;
	// 82EEF27C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEF280: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEF284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEF288: 40990010  ble cr6, 0x82eef298
	if !ctx.cr[6].gt {
		sub_82EEF298(ctx, base);
		return;
	}
	// 82EEF28C: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEF290: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82EEF294: 4800000C  b 0x82eef2a0
	sub_82EEF298(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEF298 size=16
    let mut pc: u32 = 0x82EEF298;
    'dispatch: loop {
        match pc {
            0x82EEF298 => {
    //   block [0x82EEF298..0x82EEF2A8)
	// 82EEF298: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEF29C: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82EEF2A0: 8061FFF4  lwz r3, -0xc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EEF2A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEF2A8 size=148
    let mut pc: u32 = 0x82EEF2A8;
    'dispatch: loop {
        match pc {
            0x82EEF2A8 => {
    //   block [0x82EEF2A8..0x82EEF33C)
	// 82EEF2A8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEF2AC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEF2B0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF2B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF2B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEF2BC: 409A0008  bne cr6, 0x82eef2c4
	if !ctx.cr[6].eq {
	pc = 0x82EEF2C4; continue 'dispatch;
	}
	// 82EEF2C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEF2C4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF2C8: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEF2CC: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s64 = ctx.r[10].s64 * 312;
	// 82EEF2D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF2D4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF2D8: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF2DC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF2E0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF2E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF2E8: 4199002C  bgt cr6, 0x82eef314
	if ctx.cr[6].gt {
	pc = 0x82EEF314; continue 'dispatch;
	}
	// 82EEF2EC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF2F0: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEF2F4: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s64 = ctx.r[10].s64 * 312;
	// 82EEF2F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF2FC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF300: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF304: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF308: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF30C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF310: 40980008  bge cr6, 0x82eef318
	if !ctx.cr[6].lt {
	pc = 0x82EEF318; continue 'dispatch;
	}
	// 82EEF314: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EEF318: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF31C: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEF320: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s64 = ctx.r[10].s64 * 312;
	// 82EEF324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF328: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF32C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF330: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EEF334: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF340 size=80
    let mut pc: u32 = 0x82EEF340;
    'dispatch: loop {
        match pc {
            0x82EEF340 => {
    //   block [0x82EEF340..0x82EEF390)
	// 82EEF340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF348: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF34C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF350: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF354: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF358: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEF35C: 80C10074  lwz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF360: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEF364: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF368: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF36C: 480002FD  bl 0x82eef668
	ctx.lr = 0x82EEF370;
	sub_82EEF668(ctx, base);
	// 82EEF370: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF374: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEF378: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF37C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF380: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF38C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF390 size=64
    let mut pc: u32 = 0x82EEF390;
    'dispatch: loop {
        match pc {
            0x82EEF390 => {
    //   block [0x82EEF390..0x82EEF3D0)
	// 82EEF390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF398: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF39C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF3A0: F8810078  std r4, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[4].u64 ) };
	// 82EEF3A4: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEF3A8: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEF3AC: 80C10074  lwz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF3B0: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEF3B4: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEF3B8: E8610078  ld r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82EEF3BC: 4800031D  bl 0x82eef6d8
	ctx.lr = 0x82EEF3C0;
	sub_82EEF6D8(ctx, base);
	// 82EEF3C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF3C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF3C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF3D0 size=152
    let mut pc: u32 = 0x82EEF3D0;
    'dispatch: loop {
        match pc {
            0x82EEF3D0 => {
    //   block [0x82EEF3D0..0x82EEF468)
	// 82EEF3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF3D4: 4BDBA039  bl 0x82ca940c
	ctx.lr = 0x82EEF3D8;
	sub_82CA93D0(ctx, base);
	// 82EEF3D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF3DC: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEF3E0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEF3E4: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEF3E8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF3EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF3F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF3F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF3F8: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF3FC: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 82EEF400: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EEF404: 4800038D  bl 0x82eef790
	ctx.lr = 0x82EEF408;
	sub_82EEF790(ctx, base);
	// 82EEF408: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF40C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF410: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEF414: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF418: 99610059  stb r11, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 82EEF41C: 38A100A4  addi r5, r1, 0xa4
	ctx.r[5].s64 = ctx.r[1].s64 + 164;
	// 82EEF420: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82EEF424: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 82EEF428: 48005811  bl 0x82ef4c38
	ctx.lr = 0x82EEF42C;
	sub_82EF4C38(ctx, base);
	// 82EEF42C: 8BE30000  lbz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF430: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEF434: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82EEF438: 48000329  bl 0x82eef760
	ctx.lr = 0x82EEF43C;
	sub_82EEF760(ctx, base);
	// 82EEF43C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EEF440: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EEF444: 4800031D  bl 0x82eef760
	ctx.lr = 0x82EEF448;
	sub_82EEF760(ctx, base);
	// 82EEF448: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EEF44C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EEF450: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEF454: 88E10059  lbz r7, 0x59(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82EEF458: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF45C: 48000345  bl 0x82eef7a0
	ctx.lr = 0x82EEF460;
	sub_82EEF7A0(ctx, base);
	// 82EEF460: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEF464: 4BDB9FF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF468 size=76
    let mut pc: u32 = 0x82EEF468;
    'dispatch: loop {
        match pc {
            0x82EEF468 => {
    //   block [0x82EEF468..0x82EEF4B4)
	// 82EEF468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF470: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF474: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF478: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF47C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF480: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EEF484: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EEF488: 48000309  bl 0x82eef790
	ctx.lr = 0x82EEF48C;
	sub_82EEF790(ctx, base);
	// 82EEF48C: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEF490: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF494: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF498: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF49C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF4A0: 480003C9  bl 0x82eef868
	ctx.lr = 0x82EEF4A4;
	sub_82EEF868(ctx, base);
	// 82EEF4A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF4A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF4AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF4B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF4B8 size=120
    let mut pc: u32 = 0x82EEF4B8;
    'dispatch: loop {
        match pc {
            0x82EEF4B8 => {
    //   block [0x82EEF4B8..0x82EEF530)
	// 82EEF4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF4BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF4C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF4C4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF4C8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF4CC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF4D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEF4D4: 41990010  bgt cr6, 0x82eef4e4
	if ctx.cr[6].gt {
	pc = 0x82EEF4E4; continue 'dispatch;
	}
	// 82EEF4D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEF4DC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEF4E0: 48000034  b 0x82eef514
	pc = 0x82EEF514; continue 'dispatch;
	// 82EEF4E4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF4E8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EEF4EC: 0CCB0000  twi 6, r11, 0
	// 82EEF4F0: 7D6A5B96  divwu r11, r10, r11
	ctx.r[11].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82EEF4F4: 2B0B0138  cmplwi cr6, r11, 0x138
	ctx.cr[6].compare_u32(ctx.r[11].u32, 312 as u32, &mut ctx.xer);
	// 82EEF4F8: 4098001C  bge cr6, 0x82eef514
	if !ctx.cr[6].lt {
	pc = 0x82EEF514; continue 'dispatch;
	}
	// 82EEF4FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEF500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEF504: 4B4026F5  bl 0x822f1bf8
	ctx.lr = 0x82EEF508;
	sub_822F1BF8(ctx, base);
	// 82EEF508: 4B402919  bl 0x822f1e20
	ctx.lr = 0x82EEF50C;
	sub_822F1E20(ctx, base);
	// 82EEF50C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEF510: 4B402689  bl 0x822f1b98
	ctx.lr = 0x82EEF514;
	sub_822F1B98(ctx, base);
	// 82EEF514: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF518: 1C6B0138  mulli r3, r11, 0x138
	ctx.r[3].s64 = ctx.r[11].s64 * 312;
	// 82EEF51C: 4B3FAC9D  bl 0x822ea1b8
	ctx.lr = 0x82EEF520;
	sub_822EA1B8(ctx, base);
	// 82EEF520: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF52C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF530 size=64
    let mut pc: u32 = 0x82EEF530;
    'dispatch: loop {
        match pc {
            0x82EEF530 => {
    //   block [0x82EEF530..0x82EEF570)
	// 82EEF530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF538: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF53C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF540: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF544: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF548: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEF54C: 80C10074  lwz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF550: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEF554: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF558: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF55C: 4800036D  bl 0x82eef8c8
	ctx.lr = 0x82EEF560;
	sub_82EEF8C8(ctx, base);
	// 82EEF560: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF564: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF568: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF56C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF570 size=92
    let mut pc: u32 = 0x82EEF570;
    'dispatch: loop {
        match pc {
            0x82EEF570 => {
    //   block [0x82EEF570..0x82EEF5CC)
	// 82EEF570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EEF57C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEF580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF584: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEF588: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEF58C: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82EEF590: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEF594: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82EEF598: 480001C9  bl 0x82eef760
	ctx.lr = 0x82EEF59C;
	sub_82EEF760(ctx, base);
	// 82EEF59C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EEF5A0: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82EEF5A4: 480001BD  bl 0x82eef760
	ctx.lr = 0x82EEF5A8;
	sub_82EEF760(ctx, base);
	// 82EEF5A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EEF5AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEF5B0: 480003A1  bl 0x82eef950
	ctx.lr = 0x82EEF5B4;
	sub_82EEF950(ctx, base);
	// 82EEF5B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEF5B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF5BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF5C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EEF5C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEF5C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF5D0 size=148
    let mut pc: u32 = 0x82EEF5D0;
    'dispatch: loop {
        match pc {
            0x82EEF5D0 => {
    //   block [0x82EEF5D0..0x82EEF664)
	// 82EEF5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF5D4: 4BDB9E39  bl 0x82ca940c
	ctx.lr = 0x82EEF5D8;
	sub_82CA93D0(ctx, base);
	// 82EEF5D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF5DC: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEF5E0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEF5E4: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEF5E8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF5EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF5F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF5F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF5F8: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF5FC: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEF600: 48005809  bl 0x82ef4e08
	ctx.lr = 0x82EEF604;
	sub_82EF4E08(ctx, base);
	// 82EEF604: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF608: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF60C: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEF610: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF614: 99610059  stb r11, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 82EEF618: 38A100A4  addi r5, r1, 0xa4
	ctx.r[5].s64 = ctx.r[1].s64 + 164;
	// 82EEF61C: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82EEF620: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 82EEF624: 48005615  bl 0x82ef4c38
	ctx.lr = 0x82EEF628;
	sub_82EF4C38(ctx, base);
	// 82EEF628: 8BE30000  lbz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF62C: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEF630: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82EEF634: 4800012D  bl 0x82eef760
	ctx.lr = 0x82EEF638;
	sub_82EEF760(ctx, base);
	// 82EEF638: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EEF63C: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EEF640: 48000121  bl 0x82eef760
	ctx.lr = 0x82EEF644;
	sub_82EEF760(ctx, base);
	// 82EEF644: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EEF648: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EEF64C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEF650: 88E10059  lbz r7, 0x59(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82EEF654: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF658: 48000359  bl 0x82eef9b0
	ctx.lr = 0x82EEF65C;
	sub_82EEF9B0(ctx, base);
	// 82EEF65C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEF660: 4BDB9DFC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF668 size=108
    let mut pc: u32 = 0x82EEF668;
    'dispatch: loop {
        match pc {
            0x82EEF668 => {
    //   block [0x82EEF668..0x82EEF6D4)
	// 82EEF668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF66C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF670: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF674: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF678: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF67C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF680: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEF684: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF688: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF68C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF690: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF694: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF698: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82EEF69C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EEF6A0: 480000F1  bl 0x82eef790
	ctx.lr = 0x82EEF6A4;
	sub_82EEF790(ctx, base);
	// 82EEF6A4: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF6A8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF6AC: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF6B0: 80C1008C  lwz r6, 0x8c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEF6B4: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF6B8: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF6BC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF6C0: 48000369  bl 0x82eefa28
	ctx.lr = 0x82EEF6C4;
	sub_82EEFA28(ctx, base);
	// 82EEF6C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF6C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF6CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF6D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF6D8 size=132
    let mut pc: u32 = 0x82EEF6D8;
    'dispatch: loop {
        match pc {
            0x82EEF6D8 => {
    //   block [0x82EEF6D8..0x82EEF75C)
	// 82EEF6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF6DC: 4BDB9D2D  bl 0x82ca9408
	ctx.lr = 0x82EEF6E0;
	sub_82CA93D0(ctx, base);
	// 82EEF6E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF6E4: F86100A0  std r3, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u64 ) };
	// 82EEF6E8: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82EEF6EC: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEF6F0: 90C100BC  stw r6, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[6].u32 ) };
	// 82EEF6F4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF6F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF6FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF700: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF704: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF708: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 82EEF70C: 480056FD  bl 0x82ef4e08
	ctx.lr = 0x82EEF710;
	sub_82EF4E08(ctx, base);
	// 82EEF710: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF714: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF718: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEF71C: 8BE10051  lbz r31, 0x51(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF720: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEF724: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEF728: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EEF72C: 480003E5  bl 0x82eefb10
	ctx.lr = 0x82EEF730;
	sub_82EEFB10(ctx, base);
	// 82EEF730: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EEF734: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EEF738: 480003D9  bl 0x82eefb10
	ctx.lr = 0x82EEF73C;
	sub_82EEFB10(ctx, base);
	// 82EEF73C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EEF740: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EEF744: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EEF748: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EEF74C: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF750: 480003F1  bl 0x82eefb40
	ctx.lr = 0x82EEF754;
	sub_82EEFB40(ctx, base);
	// 82EEF754: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEF758: 4BDB9D00  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF760 size=44
    let mut pc: u32 = 0x82EEF760;
    'dispatch: loop {
        match pc {
            0x82EEF760 => {
    //   block [0x82EEF760..0x82EEF78C)
	// 82EEF760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF768: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF76C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF770: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF774: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF778: 48005719  bl 0x82ef4e90
	ctx.lr = 0x82EEF77C;
	sub_82EF4E90(ctx, base);
	// 82EEF77C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEF790 size=16
    let mut pc: u32 = 0x82EEF790;
    'dispatch: loop {
        match pc {
            0x82EEF790 => {
    //   block [0x82EEF790..0x82EEF7A0)
	// 82EEF790: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEF794: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEF798: 8861FFF0  lbz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEF79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF7A0 size=196
    let mut pc: u32 = 0x82EEF7A0;
    'dispatch: loop {
        match pc {
            0x82EEF7A0 => {
    //   block [0x82EEF7A0..0x82EEF864)
	// 82EEF7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF7A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEF7AC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF7B0: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEF7B4: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEF7B8: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEF7BC: 98C100AF  stb r6, 0xaf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(175 as u32), ctx.r[6].u8 ) };
	// 82EEF7C0: 98E100B7  stb r7, 0xb7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(183 as u32), ctx.r[7].u8 ) };
	// 82EEF7C4: 990100BF  stb r8, 0xbf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(191 as u32), ctx.r[8].u8 ) };
	// 82EEF7C8: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEF7CC: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEF7D0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF7D4: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEF7D8: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEF7DC: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEF7E0: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEF7E4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF7E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEF7EC: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82EEF7F0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEF7F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF7F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF7FC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF800: 39610055  addi r11, r1, 0x55
	ctx.r[11].s64 = ctx.r[1].s64 + 85;
	// 82EEF804: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EEF808: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EEF80C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF810: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF814: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF818: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82EEF81C: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 82EEF820: 99610061  stb r11, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 82EEF824: 8BE10056  lbz r31, 0x56(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82EEF828: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEF82C: 4BFFFF35  bl 0x82eef760
	ctx.lr = 0x82EEF830;
	sub_82EEF760(ctx, base);
	// 82EEF830: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EEF834: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEF838: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEF83C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEF840: 88E10061  lbz r7, 0x61(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(97 as u32) ) } as u64;
	// 82EEF844: 89010060  lbz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEF848: 48000341  bl 0x82eefb88
	ctx.lr = 0x82EEF84C;
	sub_82EEFB88(ctx, base);
	// 82EEF84C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF850: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEF854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF85C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEF860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF868 size=92
    let mut pc: u32 = 0x82EEF868;
    'dispatch: loop {
        match pc {
            0x82EEF868 => {
    //   block [0x82EEF868..0x82EEF8C4)
	// 82EEF868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF870: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF874: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF878: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF87C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF880: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EEF884: 48000010  b 0x82eef894
	pc = 0x82EEF894; continue 'dispatch;
	// 82EEF888: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF88C: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEF890: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEF894: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF898: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF89C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF8A0: 419A0014  beq cr6, 0x82eef8b4
	if ctx.cr[6].eq {
	pc = 0x82EEF8B4; continue 'dispatch;
	}
	// 82EEF8A4: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF8A8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF8AC: 48114B0D  bl 0x830043b8
	ctx.lr = 0x82EEF8B0;
	sub_830043B8(ctx, base);
	// 82EEF8B0: 4BFFFFD8  b 0x82eef888
	pc = 0x82EEF888; continue 'dispatch;
	// 82EEF8B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF8B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF8BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF8C8 size=132
    let mut pc: u32 = 0x82EEF8C8;
    'dispatch: loop {
        match pc {
            0x82EEF8C8 => {
    //   block [0x82EEF8C8..0x82EEF94C)
	// 82EEF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF8CC: 4BDB9B3D  bl 0x82ca9408
	ctx.lr = 0x82EEF8D0;
	sub_82CA93D0(ctx, base);
	// 82EEF8D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF8D4: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEF8D8: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EEF8DC: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEF8E0: 90C100BC  stw r6, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[6].u32 ) };
	// 82EEF8E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF8E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF8EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF8F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF8F4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF8F8: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 82EEF8FC: 4800550D  bl 0x82ef4e08
	ctx.lr = 0x82EEF900;
	sub_82EF4E08(ctx, base);
	// 82EEF900: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF904: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF908: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEF90C: 8BE10051  lbz r31, 0x51(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF910: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEF914: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEF918: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 82EEF91C: 4BFFFE45  bl 0x82eef760
	ctx.lr = 0x82EEF920;
	sub_82EEF760(ctx, base);
	// 82EEF920: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EEF924: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEF928: 4BFFFE39  bl 0x82eef760
	ctx.lr = 0x82EEF92C;
	sub_82EEF760(ctx, base);
	// 82EEF92C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EEF930: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EEF934: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EEF938: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EEF93C: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF940: 48000201  bl 0x82eefb40
	ctx.lr = 0x82EEF944;
	sub_82EEFB40(ctx, base);
	// 82EEF944: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEF948: 4BDB9B10  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF950 size=92
    let mut pc: u32 = 0x82EEF950;
    'dispatch: loop {
        match pc {
            0x82EEF950 => {
    //   block [0x82EEF950..0x82EEF9AC)
	// 82EEF950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF958: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF95C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF960: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF964: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF968: 48000010  b 0x82eef978
	pc = 0x82EEF978; continue 'dispatch;
	// 82EEF96C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF970: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEF974: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEF978: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF97C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF980: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF984: 419A0018  beq cr6, 0x82eef99c
	if ctx.cr[6].eq {
	pc = 0x82EEF99C; continue 'dispatch;
	}
	// 82EEF988: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF98C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF990: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEF994: 4BDB9AED  bl 0x82ca9480
	ctx.lr = 0x82EEF998;
	sub_82CA9480(ctx, base);
	// 82EEF998: 4BFFFFD4  b 0x82eef96c
	pc = 0x82EEF96C; continue 'dispatch;
	// 82EEF99C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF9B0 size=116
    let mut pc: u32 = 0x82EEF9B0;
    'dispatch: loop {
        match pc {
            0x82EEF9B0 => {
    //   block [0x82EEF9B0..0x82EEFA24)
	// 82EEF9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF9B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF9BC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF9C0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF9C4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF9C8: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EEF9CC: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEF9D0: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEF9D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF9D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF9DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF9E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF9E4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF9E8: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82EEF9EC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EEF9F0: 4BFFFDA1  bl 0x82eef790
	ctx.lr = 0x82EEF9F4;
	sub_82EEF790(ctx, base);
	// 82EEF9F4: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF9F8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF9FC: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEFA00: 88C1008F  lbz r6, 0x8f(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(143 as u32) ) } as u64;
	// 82EEFA04: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFA08: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFA0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFA10: 480001F1  bl 0x82eefc00
	ctx.lr = 0x82EEFA14;
	sub_82EEFC00(ctx, base);
	// 82EEFA14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFA28 size=172
    let mut pc: u32 = 0x82EEFA28;
    'dispatch: loop {
        match pc {
            0x82EEFA28 => {
    //   block [0x82EEFA28..0x82EEFAD4)
	// 82EEFA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFA2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFA30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFA34: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFA38: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFA3C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFA40: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEFA44: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFA48: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEFA4C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFA50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFA54: 4800001C  b 0x82eefa70
	pc = 0x82EEFA70; continue 'dispatch;
	// 82EEFA58: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFA5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEFA60: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEFA64: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFA68: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFA6C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEFA70: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFA74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEFA78: 40990018  ble cr6, 0x82eefa90
	if !ctx.cr[6].gt {
	pc = 0x82EEFA90; continue 'dispatch;
	}
	// 82EEFA7C: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFA80: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFA84: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFA88: 48000051  bl 0x82eefad8
	ctx.lr = 0x82EEFA8C;
	sub_82EEFAD8(ctx, base);
	// 82EEFA8C: 4BFFFFCC  b 0x82eefa58
	pc = 0x82EEFA58; continue 'dispatch;
	// 82EEFA90: 48000034  b 0x82eefac4
	pc = 0x82EEFAC4; continue 'dispatch;
	// 82EEFA94: 48000010  b 0x82eefaa4
	pc = 0x82EEFAA4; continue 'dispatch;
	// 82EEFA98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFA9C: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFAA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFAA4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFAA8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFAAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFAB0: 419A0014  beq cr6, 0x82eefac4
	if ctx.cr[6].eq {
	pc = 0x82EEFAC4; continue 'dispatch;
	}
	// 82EEFAB4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFAB8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFABC: 481148FD  bl 0x830043b8
	ctx.lr = 0x82EEFAC0;
	sub_830043B8(ctx, base);
	// 82EEFAC0: 4BFFFFD8  b 0x82eefa98
	pc = 0x82EEFA98; continue 'dispatch;
	// 82EEFAC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFAC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFAD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFAD8 size=52
    let mut pc: u32 = 0x82EEFAD8;
    'dispatch: loop {
        match pc {
            0x82EEFAD8 => {
    //   block [0x82EEFAD8..0x82EEFB0C)
	// 82EEFAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFAE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFAE4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFAE8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFAEC: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFAF0: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFAF4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFAF8: 480001D1  bl 0x82eefcc8
	ctx.lr = 0x82EEFAFC;
	sub_82EEFCC8(ctx, base);
	// 82EEFAFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFB00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFB04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFB08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFB10 size=44
    let mut pc: u32 = 0x82EEFB10;
    'dispatch: loop {
        match pc {
            0x82EEFB10 => {
    //   block [0x82EEFB10..0x82EEFB3C)
	// 82EEFB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFB14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFB18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFB1C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFB20: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFB24: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFB28: 48000211  bl 0x82eefd38
	ctx.lr = 0x82EEFB2C;
	sub_82EEFD38(ctx, base);
	// 82EEFB2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFB30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFB34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFB38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFB40 size=72
    let mut pc: u32 = 0x82EEFB40;
    'dispatch: loop {
        match pc {
            0x82EEFB40 => {
    //   block [0x82EEFB40..0x82EEFB88)
	// 82EEFB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFB44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFB48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFB4C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFB50: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFB54: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFB58: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEFB5C: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFB60: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEFB64: 80C1008C  lwz r6, 0x8c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFB68: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFB6C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFB70: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFB74: 480001F5  bl 0x82eefd68
	ctx.lr = 0x82EEFB78;
	sub_82EEFD68(ctx, base);
	// 82EEFB78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFB7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFB80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFB84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFB88 size=120
    let mut pc: u32 = 0x82EEFB88;
    'dispatch: loop {
        match pc {
            0x82EEFB88 => {
    //   block [0x82EEFB88..0x82EEFC00)
	// 82EEFB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFB8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFB90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFB94: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFB98: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFB9C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFBA0: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EEFBA4: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFBA8: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEFBAC: 4800001C  b 0x82eefbc8
	pc = 0x82EEFBC8; continue 'dispatch;
	// 82EEFBB0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFBB4: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFBB8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEFBBC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFBC0: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFBC4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEFBC8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFBCC: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFBD0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFBD4: 419A0018  beq cr6, 0x82eefbec
	if ctx.cr[6].eq {
	pc = 0x82EEFBEC; continue 'dispatch;
	}
	// 82EEFBD8: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFBDC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFBE0: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEFBE4: 4BDB989D  bl 0x82ca9480
	ctx.lr = 0x82EEFBE8;
	sub_82CA9480(ctx, base);
	// 82EEFBE8: 4BFFFFC8  b 0x82eefbb0
	pc = 0x82EEFBB0; continue 'dispatch;
	// 82EEFBEC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFBF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFBF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFBF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFBFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFC00 size=196
    let mut pc: u32 = 0x82EEFC00;
    'dispatch: loop {
        match pc {
            0x82EEFC00 => {
    //   block [0x82EEFC00..0x82EEFCC4)
	// 82EEFC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFC04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFC08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEFC0C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFC10: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEFC14: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEFC18: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEFC1C: 98C100AF  stb r6, 0xaf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(175 as u32), ctx.r[6].u8 ) };
	// 82EEFC20: 98E100B7  stb r7, 0xb7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(183 as u32), ctx.r[7].u8 ) };
	// 82EEFC24: 990100BF  stb r8, 0xbf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(191 as u32), ctx.r[8].u8 ) };
	// 82EEFC28: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEFC2C: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEFC30: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEFC34: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEFC38: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEFC3C: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 * 312;
	// 82EEFC40: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEFC44: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEFC48: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFC4C: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82EEFC50: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEFC54: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEFC58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEFC5C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEFC60: 39610055  addi r11, r1, 0x55
	ctx.r[11].s64 = ctx.r[1].s64 + 85;
	// 82EEFC64: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EEFC68: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EEFC6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEFC70: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEFC74: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFC78: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82EEFC7C: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 82EEFC80: 99610061  stb r11, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 82EEFC84: 8BE10056  lbz r31, 0x56(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82EEFC88: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEFC8C: 4BFFFAD5  bl 0x82eef760
	ctx.lr = 0x82EEFC90;
	sub_82EEF760(ctx, base);
	// 82EEFC90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EEFC94: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEFC98: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEFC9C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEFCA0: 88E10061  lbz r7, 0x61(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(97 as u32) ) } as u64;
	// 82EEFCA4: 89010060  lbz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEFCA8: 48000149  bl 0x82eefdf0
	ctx.lr = 0x82EEFCAC;
	sub_82EEFDF0(ctx, base);
	// 82EEFCAC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFCB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEFCB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFCB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFCBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEFCC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFCC8 size=108
    let mut pc: u32 = 0x82EEFCC8;
    'dispatch: loop {
        match pc {
            0x82EEFCC8 => {
    //   block [0x82EEFCC8..0x82EEFD34)
	// 82EEFCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFCCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFCD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFCD4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEFCD8: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEFCDC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFCE0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFCE4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFCE8: 38600138  li r3, 0x138
	ctx.r[3].s64 = 312;
	// 82EEFCEC: 4B401F25  bl 0x822f1c10
	ctx.lr = 0x82EEFCF0;
	sub_822F1C10(ctx, base);
	// 82EEFCF0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEFCF4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFCF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEFCFC: 419A0020  beq cr6, 0x82eefd1c
	if ctx.cr[6].eq {
	pc = 0x82EEFD1C; continue 'dispatch;
	}
	// 82EEFD00: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFD04: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFD08: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEFD0C: 4BDB9775  bl 0x82ca9480
	ctx.lr = 0x82EEFD10;
	sub_82CA9480(ctx, base);
	// 82EEFD10: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFD14: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEFD18: 4800000C  b 0x82eefd24
	pc = 0x82EEFD24; continue 'dispatch;
	// 82EEFD1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEFD20: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEFD24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEFD28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFD2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFD30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFD38 size=44
    let mut pc: u32 = 0x82EEFD38;
    'dispatch: loop {
        match pc {
            0x82EEFD38 => {
    //   block [0x82EEFD38..0x82EEFD64)
	// 82EEFD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFD3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFD40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFD44: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFD48: 9881007F  stb r4, 0x7f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(127 as u32), ctx.r[4].u8 ) };
	// 82EEFD4C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFD50: 48113691  bl 0x830033e0
	ctx.lr = 0x82EEFD54;
	sub_830033E0(ctx, base);
	// 82EEFD54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFD58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFD5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFD60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFD68 size=136
    let mut pc: u32 = 0x82EEFD68;
    'dispatch: loop {
        match pc {
            0x82EEFD68 => {
    //   block [0x82EEFD68..0x82EEFDF0)
	// 82EEFD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFD6C: 4BDB969D  bl 0x82ca9408
	ctx.lr = 0x82EEFD70;
	sub_82CA93D0(ctx, base);
	// 82EEFD70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFD74: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEFD78: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EEFD7C: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEFD80: 90C100BC  stw r6, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[6].u32 ) };
	// 82EEFD84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEFD88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEFD8C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFD90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEFD94: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEFD98: 388100B4  addi r4, r1, 0xb4
	ctx.r[4].s64 = ctx.r[1].s64 + 180;
	// 82EEFD9C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEFDA0: 4BFFF9F1  bl 0x82eef790
	ctx.lr = 0x82EEFDA4;
	sub_82EEF790(ctx, base);
	// 82EEFDA4: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEFDA8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFDAC: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEFDB0: 8BE10051  lbz r31, 0x51(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEFDB4: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEFDB8: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEFDBC: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 82EEFDC0: 4BFFF9A1  bl 0x82eef760
	ctx.lr = 0x82EEFDC4;
	sub_82EEF760(ctx, base);
	// 82EEFDC4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EEFDC8: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEFDCC: 4BFFF995  bl 0x82eef760
	ctx.lr = 0x82EEFDD0;
	sub_82EEF760(ctx, base);
	// 82EEFDD0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EEFDD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EEFDD8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EEFDDC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EEFDE0: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEFDE4: 48000085  bl 0x82eefe68
	ctx.lr = 0x82EEFDE8;
	sub_82EEFE68(ctx, base);
	// 82EEFDE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEFDEC: 4BDB966C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFDF0 size=116
    let mut pc: u32 = 0x82EEFDF0;
    'dispatch: loop {
        match pc {
            0x82EEFDF0 => {
    //   block [0x82EEFDF0..0x82EEFE64)
	// 82EEFDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFDF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFDF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFDFC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFE00: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFE04: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFE08: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EEFE0C: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFE10: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEFE14: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFE18: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFE1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFE20: 419A0030  beq cr6, 0x82eefe50
	if ctx.cr[6].eq {
	pc = 0x82EEFE50; continue 'dispatch;
	}
	// 82EEFE24: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFE28: 396BFEC8  addi r11, r11, -0x138
	ctx.r[11].s64 = ctx.r[11].s64 + -312;
	// 82EEFE2C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEFE30: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE34: 396BFEC8  addi r11, r11, -0x138
	ctx.r[11].s64 = ctx.r[11].s64 + -312;
	// 82EEFE38: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEFE3C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFE40: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE44: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEFE48: 4BDB9639  bl 0x82ca9480
	ctx.lr = 0x82EEFE4C;
	sub_82CA9480(ctx, base);
	// 82EEFE4C: 4BFFFFC8  b 0x82eefe14
	pc = 0x82EEFE14; continue 'dispatch;
	// 82EEFE50: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFE58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFE5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFE60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFE68 size=180
    let mut pc: u32 = 0x82EEFE68;
    'dispatch: loop {
        match pc {
            0x82EEFE68 => {
    //   block [0x82EEFE68..0x82EEFF1C)
	// 82EEFE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFE6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFE70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFE74: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFE78: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFE7C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFE80: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEFE84: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFE88: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEFE8C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFE94: 4800001C  b 0x82eefeb0
	pc = 0x82EEFEB0; continue 'dispatch;
	// 82EEFE98: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE9C: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFEA0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEFEA4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFEA8: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFEAC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEFEB0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFEB4: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFEB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFEBC: 419A0018  beq cr6, 0x82eefed4
	if ctx.cr[6].eq {
	pc = 0x82EEFED4; continue 'dispatch;
	}
	// 82EEFEC0: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFEC4: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFEC8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFECC: 4BFFFC0D  bl 0x82eefad8
	ctx.lr = 0x82EEFED0;
	sub_82EEFAD8(ctx, base);
	// 82EEFED0: 4BFFFFC8  b 0x82eefe98
	pc = 0x82EEFE98; continue 'dispatch;
	// 82EEFED4: 48000034  b 0x82eeff08
	pc = 0x82EEFF08; continue 'dispatch;
	// 82EEFED8: 48000010  b 0x82eefee8
	pc = 0x82EEFEE8; continue 'dispatch;
	// 82EEFEDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFEE0: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFEE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFEE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFEEC: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFEF0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFEF4: 419A0014  beq cr6, 0x82eeff08
	if ctx.cr[6].eq {
	pc = 0x82EEFF08; continue 'dispatch;
	}
	// 82EEFEF8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFEFC: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFF00: 481144B9  bl 0x830043b8
	ctx.lr = 0x82EEFF04;
	sub_830043B8(ctx, base);
	// 82EEFF04: 4BFFFFD8  b 0x82eefedc
	pc = 0x82EEFEDC; continue 'dispatch;
	// 82EEFF08: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFF0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFF10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFF14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFF18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFF20 size=232
    let mut pc: u32 = 0x82EEFF20;
    'dispatch: loop {
        match pc {
            0x82EEFF20 => {
    //   block [0x82EEFF20..0x82EF0008)
	// 82EEFF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFF24: 4BDB94E9  bl 0x82ca940c
	ctx.lr = 0x82EEFF28;
	sub_82CA93D0(ctx, base);
	// 82EEFF28: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFF2C: 90610124  stw r3, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[3].u32 ) };
	// 82EEFF30: 9081012C  stw r4, 0x12c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), ctx.r[4].u32 ) };
	// 82EEFF34: 3BE100E0  addi r31, r1, 0xe0
	ctx.r[31].s64 = ctx.r[1].s64 + 224;
	// 82EEFF38: 3BC100E4  addi r30, r1, 0xe4
	ctx.r[30].s64 = ctx.r[1].s64 + 228;
	// 82EEFF3C: 83A1012C  lwz r29, 0x12c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(300 as u32) ) } as u64;
	// 82EEFF40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEFF44: 4811B9AD  bl 0x8300b8f0
	ctx.lr = 0x82EEFF48;
	sub_8300B8F0(ctx, base);
	// 82EEFF48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EEFF4C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EEFF50: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEFF54: 4BDD86BD  bl 0x82cc8610
	ctx.lr = 0x82EEFF58;
	sub_82CC8610(ctx, base);
	// 82EEFF58: 816100E4  lwz r11, 0xe4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82EEFF5C: 916100DC  stw r11, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 82EEFF60: 816100E0  lwz r11, 0xe0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 82EEFF64: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 82EEFF68: 419A0010  beq cr6, 0x82eeff78
	if ctx.cr[6].eq {
	pc = 0x82EEFF78; continue 'dispatch;
	}
	// 82EEFF6C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EEFF70: 61634005  ori r3, r11, 0x4005
	ctx.r[3].u64 = ctx.r[11].u64 | 16389;
	// 82EEFF74: 4800008C  b 0x82ef0000
	pc = 0x82EF0000; continue 'dispatch;
	// 82EEFF78: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEFF7C: 4811B95D  bl 0x8300b8d8
	ctx.lr = 0x82EEFF80;
	sub_8300B8D8(ctx, base);
	// 82EEFF80: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82EEFF84: 4811345D  bl 0x830033e0
	ctx.lr = 0x82EEFF88;
	sub_830033E0(ctx, base);
	// 82EEFF88: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEFF8C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFF90: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82EEFF94: 4BFFD4D5  bl 0x82eed468
	ctx.lr = 0x82EEFF98;
	sub_82EED468(ctx, base);
	// 82EEFF98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEFF9C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEFFA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEFFA4: 4811B93D  bl 0x8300b8e0
	ctx.lr = 0x82EEFFA8;
	sub_8300B8E0(ctx, base);
	// 82EEFFA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFFAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFFB0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82EEFFB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEFFB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEFFBC: 4811B925  bl 0x8300b8e0
	ctx.lr = 0x82EEFFC0;
	sub_8300B8E0(ctx, base);
	// 82EEFFC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EEFFC4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEFFC8: 4811B921  bl 0x8300b8e8
	ctx.lr = 0x82EEFFCC;
	sub_8300B8E8(ctx, base);
	// 82EEFFCC: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 82EEFFD0: 808100DC  lwz r4, 0xdc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82EEFFD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEFFD8: 48119139  bl 0x83009110
	ctx.lr = 0x82EEFFDC;
	sub_83009110(ctx, base);
	// 82EEFFDC: 906100D8  stw r3, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 82EEFFE0: 816100D8  lwz r11, 0xd8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 82EEFFE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEFFE8: 409A0010  bne cr6, 0x82eefff8
	if !ctx.cr[6].eq {
	pc = 0x82EEFFF8; continue 'dispatch;
	}
	// 82EEFFEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEFFF0: 48000010  b 0x82ef0000
	pc = 0x82EF0000; continue 'dispatch;
	// 82EEFFF4: 4800000C  b 0x82ef0000
	pc = 0x82EF0000; continue 'dispatch;
	// 82EEFFF8: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EEFFFC: 61634005  ori r3, r11, 0x4005
	ctx.r[3].u64 = ctx.r[11].u64 | 16389;
	// 82EF0000: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82EF0004: 4BDB9458  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0008 size=80
    let mut pc: u32 = 0x82EF0008;
    'dispatch: loop {
        match pc {
            0x82EF0008 => {
    //   block [0x82EF0008..0x82EF0058)
	// 82EF0008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF000C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0010: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0014: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0018: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF001C: 3880005C  li r4, 0x5c
	ctx.r[4].s64 = 92;
	// 82EF0020: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF0024: 4BDBD86D  bl 0x82cad890
	ctx.lr = 0x82EF0028;
	sub_82CAD890(ctx, base);
	// 82EF0028: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF002C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0030: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF0034: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF0038: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82EF003C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0040: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0044: 4B3DD065  bl 0x822cd0a8
	ctx.lr = 0x82EF0048;
	sub_822CD0A8(ctx, base);
	// 82EF0048: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF004C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0058 size=60
    let mut pc: u32 = 0x82EF0058;
    'dispatch: loop {
        match pc {
            0x82EF0058 => {
    //   block [0x82EF0058..0x82EF0094)
	// 82EF0058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF005C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0060: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0064: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0068: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF006C: 4800002D  bl 0x82ef0098
	ctx.lr = 0x82EF0070;
	sub_82EF0098(ctx, base);
	// 82EF0070: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0074: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF0078: 48003B69  bl 0x82ef3be0
	ctx.lr = 0x82EF007C;
	sub_82EF3BE0(ctx, base);
	// 82EF007C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0080: 4BFFDEF1  bl 0x82eedf70
	ctx.lr = 0x82EF0084;
	sub_82EEDF70(ctx, base);
	// 82EF0084: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF0088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF008C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0098 size=184
    let mut pc: u32 = 0x82EF0098;
    'dispatch: loop {
        match pc {
            0x82EF0098 => {
    //   block [0x82EF0098..0x82EF0150)
	// 82EF0098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF009C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF00A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF00A4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF00A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF00AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF00B0: 48000010  b 0x82ef00c0
	pc = 0x82EF00C0; continue 'dispatch;
	// 82EF00B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF00B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF00BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF00C0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF00C4: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF00C8: 48003B81  bl 0x82ef3c48
	ctx.lr = 0x82EF00CC;
	sub_82EF3C48(ctx, base);
	// 82EF00CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF00D0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EF00D4: 40980060  bge cr6, 0x82ef0134
	if !ctx.cr[6].lt {
	pc = 0x82EF0134; continue 'dispatch;
	}
	// 82EF00D8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF00DC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF00E0: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF00E4: 48003BAD  bl 0x82ef3c90
	ctx.lr = 0x82EF00E8;
	sub_82EF3C90(ctx, base);
	// 82EF00E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF00EC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF00F0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF00F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF00F8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF00FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0100: 419A0028  beq cr6, 0x82ef0128
	if ctx.cr[6].eq {
	pc = 0x82EF0128; continue 'dispatch;
	}
	// 82EF0104: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EF0108: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF010C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0110: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0114: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0118: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF011C: 4E800421  bctrl
	ctx.lr = 0x82EF0120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0120: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EF0124: 4800000C  b 0x82ef0130
	pc = 0x82EF0130; continue 'dispatch;
	// 82EF0128: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF012C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EF0130: 4BFFFF84  b 0x82ef00b4
	pc = 0x82EF00B4; continue 'dispatch;
	// 82EF0134: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0138: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF013C: 48003CC5  bl 0x82ef3e00
	ctx.lr = 0x82EF0140;
	sub_82EF3E00(ctx, base);
	// 82EF0140: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF0144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF014C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0150 size=364
    let mut pc: u32 = 0x82EF0150;
    'dispatch: loop {
        match pc {
            0x82EF0150 => {
    //   block [0x82EF0150..0x82EF02BC)
	// 82EF0150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0158: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF015C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF0160: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EF0164: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0168: 4BFFE009  bl 0x82eee170
	ctx.lr = 0x82EF016C;
	sub_82EEE170(ctx, base);
	// 82EF016C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0170: 48000151  bl 0x82ef02c0
	ctx.lr = 0x82EF0174;
	sub_82EF02C0(ctx, base);
	// 82EF0174: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0178: 40820134  bne 0x82ef02ac
	if !ctx.cr[0].eq {
	pc = 0x82EF02AC; continue 'dispatch;
	}
	// 82EF017C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0180: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF0184: 48003AC5  bl 0x82ef3c48
	ctx.lr = 0x82EF0188;
	sub_82EF3C48(ctx, base);
	// 82EF0188: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF018C: 40820120  bne 0x82ef02ac
	if !ctx.cr[0].eq {
	pc = 0x82EF02AC; continue 'dispatch;
	}
	// 82EF0190: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0194: 4BFFFF05  bl 0x82ef0098
	ctx.lr = 0x82EF0198;
	sub_82EF0098(ctx, base);
	// 82EF0198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF019C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF01A0: 48000010  b 0x82ef01b0
	pc = 0x82EF01B0; continue 'dispatch;
	// 82EF01A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF01A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF01AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF01B0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF01B4: 4800012D  bl 0x82ef02e0
	ctx.lr = 0x82EF01B8;
	sub_82EF02E0(ctx, base);
	// 82EF01B8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF01BC: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EF01C0: 40980090  bge cr6, 0x82ef0250
	if !ctx.cr[6].lt {
	pc = 0x82EF0250; continue 'dispatch;
	}
	// 82EF01C4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF01C8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF01CC: 4BFFDDDD  bl 0x82eedfa8
	ctx.lr = 0x82EF01D0;
	sub_82EEDFA8(ctx, base);
	// 82EF01D0: 81630134  lwz r11, 0x134(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF01D4: 3D405841  lis r10, 0x5841
	ctx.r[10].s64 = 1480654848;
	// 82EF01D8: 614A091D  ori r10, r10, 0x91d
	ctx.r[10].u64 = ctx.r[10].u64 | 2333;
	// 82EF01DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF01E0: 409A006C  bne cr6, 0x82ef024c
	if !ctx.cr[6].eq {
	pc = 0x82EF024C; continue 'dispatch;
	}
	// 82EF01E4: 38600368  li r3, 0x368
	ctx.r[3].s64 = 872;
	// 82EF01E8: 4B3F9FD1  bl 0x822ea1b8
	ctx.lr = 0x82EF01EC;
	sub_822EA1B8(ctx, base);
	// 82EF01EC: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EF01F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF01F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF01F8: 419A0014  beq cr6, 0x82ef020c
	if ctx.cr[6].eq {
	pc = 0x82EF020C; continue 'dispatch;
	}
	// 82EF01FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF0200: 4BFF8129  bl 0x82ee8328
	ctx.lr = 0x82EF0204;
	sub_82EE8328(ctx, base);
	// 82EF0204: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF0208: 4800000C  b 0x82ef0214
	pc = 0x82EF0214; continue 'dispatch;
	// 82EF020C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF0210: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EF0214: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF0218: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF021C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0220: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0224: 4BFFDD85  bl 0x82eedfa8
	ctx.lr = 0x82EF0228;
	sub_82EEDFA8(ctx, base);
	// 82EF0228: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EF022C: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF0230: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0234: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF0238: 4BFF8E39  bl 0x82ee9070
	ctx.lr = 0x82EF023C;
	sub_82EE9070(ctx, base);
	// 82EF023C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82EF0240: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0244: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF0248: 48003A99  bl 0x82ef3ce0
	ctx.lr = 0x82EF024C;
	sub_82EF3CE0(ctx, base);
	// 82EF024C: 4BFFFF58  b 0x82ef01a4
	pc = 0x82EF01A4; continue 'dispatch;
	// 82EF0250: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0254: 4800008D  bl 0x82ef02e0
	ctx.lr = 0x82EF0258;
	sub_82EF02E0(ctx, base);
	// 82EF0258: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 82EF025C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF0260: 48000010  b 0x82ef0270
	pc = 0x82EF0270; continue 'dispatch;
	// 82EF0264: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0268: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EF026C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF0270: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0274: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0278: 41980034  blt cr6, 0x82ef02ac
	if ctx.cr[6].lt {
	pc = 0x82EF02AC; continue 'dispatch;
	}
	// 82EF027C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0280: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0284: 4BFFDD25  bl 0x82eedfa8
	ctx.lr = 0x82EF0288;
	sub_82EEDFA8(ctx, base);
	// 82EF0288: 81630134  lwz r11, 0x134(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF028C: 3D405841  lis r10, 0x5841
	ctx.r[10].s64 = 1480654848;
	// 82EF0290: 614A091D  ori r10, r10, 0x91d
	ctx.r[10].u64 = ctx.r[10].u64 | 2333;
	// 82EF0294: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF0298: 419A0010  beq cr6, 0x82ef02a8
	if ctx.cr[6].eq {
	pc = 0x82EF02A8; continue 'dispatch;
	}
	// 82EF029C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF02A0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF02A4: 4BFFDF1D  bl 0x82eee1c0
	ctx.lr = 0x82EF02A8;
	sub_82EEE1C0(ctx, base);
	// 82EF02A8: 4BFFFFBC  b 0x82ef0264
	pc = 0x82EF0264; continue 'dispatch;
	// 82EF02AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF02B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF02B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF02B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF02C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF02C0 size=32
    let mut pc: u32 = 0x82EF02C0;
    'dispatch: loop {
        match pc {
            0x82EF02C0 => {
    //   block [0x82EF02C0..0x82EF02E0)
	// 82EF02C0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF02C4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF02C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF02CC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF02D0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF02D4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EF02D8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF02DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF02E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF02E0 size=44
    let mut pc: u32 = 0x82EF02E0;
    'dispatch: loop {
        match pc {
            0x82EF02E0 => {
    //   block [0x82EF02E0..0x82EF030C)
	// 82EF02E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF02E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF02E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF02EC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF02F0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF02F4: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EF02F8: 4BFFE579  bl 0x82eee870
	ctx.lr = 0x82EF02FC;
	sub_82EEE870(ctx, base);
	// 82EF02FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF0300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0310 size=56
    let mut pc: u32 = 0x82EF0310;
    'dispatch: loop {
        match pc {
            0x82EF0310 => {
    //   block [0x82EF0310..0x82EF0348)
	// 82EF0310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0318: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF031C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0320: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0324: 4BFFFF9D  bl 0x82ef02c0
	ctx.lr = 0x82EF0328;
	sub_82EF02C0(ctx, base);
	// 82EF0328: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EF032C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF0330: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF0334: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF0338: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF033C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0340: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0348 size=292
    let mut pc: u32 = 0x82EF0348;
    'dispatch: loop {
        match pc {
            0x82EF0348 => {
    //   block [0x82EF0348..0x82EF046C)
	// 82EF0348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF034C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0354: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0358: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF035C: 480FE24D  bl 0x82fee5a8
	ctx.lr = 0x82EF0360;
	sub_82FEE5A8(ctx, base);
	// 82EF0360: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0364: 396BC600  addi r11, r11, -0x3a00
	ctx.r[11].s64 = ctx.r[11].s64 + -14848;
	// 82EF0368: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF036C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF0370: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0374: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF0378: 394AC5F8  addi r10, r10, -0x3a08
	ctx.r[10].s64 = ctx.r[10].s64 + -14856;
	// 82EF037C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EF0380: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0384: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF0388: 994B0030  stb r10, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 82EF038C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0390: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF0394: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EF0398: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF039C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03A0: 914B0044  stw r10, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 82EF03A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03AC: 914B0050  stw r10, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EF03B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03B8: 914B0054  stw r10, 0x54(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EF03BC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03C4: 994B0468  stb r10, 0x468(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1128 as u32), ctx.r[10].u8 ) };
	// 82EF03C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03D0: 994B0469  stb r10, 0x469(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1129 as u32), ctx.r[10].u8 ) };
	// 82EF03D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03DC: 914B046C  stw r10, 0x46c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1132 as u32), ctx.r[10].u32 ) };
	// 82EF03E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03E8: 914B0474  stw r10, 0x474(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1140 as u32), ctx.r[10].u32 ) };
	// 82EF03EC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03F4: 914B0478  stw r10, 0x478(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1144 as u32), ctx.r[10].u32 ) };
	// 82EF03F8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF0400: 994B0488  stb r10, 0x488(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1160 as u32), ctx.r[10].u8 ) };
	// 82EF0404: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0408: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF040C: 994B0489  stb r10, 0x489(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1161 as u32), ctx.r[10].u8 ) };
	// 82EF0410: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0414: 394000FE  li r10, 0xfe
	ctx.r[10].s64 = 254;
	// 82EF0418: 914B0494  stw r10, 0x494(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1172 as u32), ctx.r[10].u32 ) };
	// 82EF041C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0420: 386B0498  addi r3, r11, 0x498
	ctx.r[3].s64 = ctx.r[11].s64 + 1176;
	// 82EF0424: 48201E45  bl 0x830f2268
	ctx.lr = 0x82EF0428;
	sub_830F2268(ctx, base);
	// 82EF0428: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF042C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF0430: 994B04DC  stb r10, 0x4dc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1244 as u32), ctx.r[10].u8 ) };
	// 82EF0434: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0438: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF043C: 994B04DD  stb r10, 0x4dd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1245 as u32), ctx.r[10].u8 ) };
	// 82EF0440: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0444: 386B04E0  addi r3, r11, 0x4e0
	ctx.r[3].s64 = ctx.r[11].s64 + 1248;
	// 82EF0448: 482014E1  bl 0x830f1928
	ctx.lr = 0x82EF044C;
	sub_830F1928(ctx, base);
	// 82EF044C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0450: 386B04E8  addi r3, r11, 0x4e8
	ctx.r[3].s64 = ctx.r[11].s64 + 1256;
	// 82EF0454: 482014D5  bl 0x830f1928
	ctx.lr = 0x82EF0458;
	sub_830F1928(ctx, base);
	// 82EF0458: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF045C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF0460: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0464: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0470 size=68
    let mut pc: u32 = 0x82EF0470;
    'dispatch: loop {
        match pc {
            0x82EF0470 => {
    //   block [0x82EF0470..0x82EF04B4)
	// 82EF0470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0478: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF047C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0480: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF0484: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0488: 48000031  bl 0x82ef04b8
	ctx.lr = 0x82EF048C;
	sub_82EF04B8(ctx, base);
	// 82EF048C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF0490: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0494: 4182000C  beq 0x82ef04a0
	if ctx.cr[0].eq {
	pc = 0x82EF04A0; continue 'dispatch;
	}
	// 82EF0498: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF049C: 4800522D  bl 0x82ef56c8
	ctx.lr = 0x82EF04A0;
	sub_82EF56C8(ctx, base);
	// 82EF04A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF04A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF04AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF04B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF04B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF04B8 size=108
    let mut pc: u32 = 0x82EF04B8;
    'dispatch: loop {
        match pc {
            0x82EF04B8 => {
    //   block [0x82EF04B8..0x82EF0524)
	// 82EF04B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF04BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF04C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF04C4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF04C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF04CC: 396BC600  addi r11, r11, -0x3a00
	ctx.r[11].s64 = ctx.r[11].s64 + -14848;
	// 82EF04D0: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04D4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF04D8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04DC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF04E0: 394AC5F8  addi r10, r10, -0x3a08
	ctx.r[10].s64 = ctx.r[10].s64 + -14856;
	// 82EF04E4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EF04E8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF04F0: 914B046C  stw r10, 0x46c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1132 as u32), ctx.r[10].u32 ) };
	// 82EF04F4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04F8: 386B04E8  addi r3, r11, 0x4e8
	ctx.r[3].s64 = ctx.r[11].s64 + 1256;
	// 82EF04FC: 482014B5  bl 0x830f19b0
	ctx.lr = 0x82EF0500;
	sub_830F19B0(ctx, base);
	// 82EF0500: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0504: 386B04E0  addi r3, r11, 0x4e0
	ctx.r[3].s64 = ctx.r[11].s64 + 1248;
	// 82EF0508: 482014A9  bl 0x830f19b0
	ctx.lr = 0x82EF050C;
	sub_830F19B0(ctx, base);
	// 82EF050C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0510: 480FE191  bl 0x82fee6a0
	ctx.lr = 0x82EF0514;
	sub_82FEE6A0(ctx, base);
	// 82EF0514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF0518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF051C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF0528 size=1648
    let mut pc: u32 = 0x82EF0528;
    'dispatch: loop {
        match pc {
            0x82EF0528 => {
    //   block [0x82EF0528..0x82EF0B98)
	// 82EF0528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF052C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0530: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF0534: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF0538: 9421FA70  stwu r1, -0x590(r1)
	ea = ctx.r[1].u32.wrapping_add(-1424 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF053C: 906105A4  stw r3, 0x5a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1444 as u32), ctx.r[3].u32 ) };
	// 82EF0540: 908105AC  stw r4, 0x5ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1452 as u32), ctx.r[4].u32 ) };
	// 82EF0544: 90A105B4  stw r5, 0x5b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1460 as u32), ctx.r[5].u32 ) };
	// 82EF0548: 90C105BC  stw r6, 0x5bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1468 as u32), ctx.r[6].u32 ) };
	// 82EF054C: 90E105C4  stw r7, 0x5c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1476 as u32), ctx.r[7].u32 ) };
	// 82EF0550: 910105CC  stw r8, 0x5cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1484 as u32), ctx.r[8].u32 ) };
	// 82EF0554: 912105D4  stw r9, 0x5d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1492 as u32), ctx.r[9].u32 ) };
	// 82EF0558: 914105DC  stw r10, 0x5dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1500 as u32), ctx.r[10].u32 ) };
	// 82EF055C: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0560: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF0564: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0568: 419A004C  beq cr6, 0x82ef05b4
	if ctx.cr[6].eq {
	pc = 0x82EF05B4; continue 'dispatch;
	}
	// 82EF056C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0570: 896B8F7F  lbz r11, -0x7081(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28801 as u32) ) } as u64;
	// 82EF0574: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0578: 4082003C  bne 0x82ef05b4
	if !ctx.cr[0].eq {
	pc = 0x82EF05B4; continue 'dispatch;
	}
	// 82EF057C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0580: 3BEB8F7F  addi r31, r11, -0x7081
	ctx.r[31].s64 = ctx.r[11].s64 + -28801;
	// 82EF0584: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0588: 38CBC6D4  addi r6, r11, -0x392c
	ctx.r[6].s64 = ctx.r[11].s64 + -14636;
	// 82EF058C: 38A000D2  li r5, 0xd2
	ctx.r[5].s64 = 210;
	// 82EF0590: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0594: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0598: 386104D8  addi r3, r1, 0x4d8
	ctx.r[3].s64 = ctx.r[1].s64 + 1240;
	// 82EF059C: 4BFFABCD  bl 0x82eeb168
	ctx.lr = 0x82EF05A0;
	sub_82EEB168(ctx, base);
	// 82EF05A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF05A4: 48201815  bl 0x830f1db8
	ctx.lr = 0x82EF05A8;
	sub_830F1DB8(ctx, base);
	// 82EF05A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF05AC: 40820008  bne 0x82ef05b4
	if !ctx.cr[0].eq {
	pc = 0x82EF05B4; continue 'dispatch;
	}
	// 82EF05B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EF05B4: 816105AC  lwz r11, 0x5ac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1452 as u32) ) } as u64;
	// 82EF05B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF05BC: 409A004C  bne cr6, 0x82ef0608
	if !ctx.cr[6].eq {
	pc = 0x82EF0608; continue 'dispatch;
	}
	// 82EF05C0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF05C4: 896B8F7E  lbz r11, -0x7082(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28802 as u32) ) } as u64;
	// 82EF05C8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF05CC: 4082003C  bne 0x82ef0608
	if !ctx.cr[0].eq {
	pc = 0x82EF0608; continue 'dispatch;
	}
	// 82EF05D0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF05D4: 3BEB8F7E  addi r31, r11, -0x7082
	ctx.r[31].s64 = ctx.r[11].s64 + -28802;
	// 82EF05D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF05DC: 38CBC790  addi r6, r11, -0x3870
	ctx.r[6].s64 = ctx.r[11].s64 + -14448;
	// 82EF05E0: 38A000D3  li r5, 0xd3
	ctx.r[5].s64 = 211;
	// 82EF05E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF05E8: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF05EC: 386104E8  addi r3, r1, 0x4e8
	ctx.r[3].s64 = ctx.r[1].s64 + 1256;
	// 82EF05F0: 4BFFAB79  bl 0x82eeb168
	ctx.lr = 0x82EF05F4;
	sub_82EEB168(ctx, base);
	// 82EF05F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF05F8: 482017C1  bl 0x830f1db8
	ctx.lr = 0x82EF05FC;
	sub_830F1DB8(ctx, base);
	// 82EF05FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0600: 40820008  bne 0x82ef0608
	if !ctx.cr[0].eq {
	pc = 0x82EF0608; continue 'dispatch;
	}
	// 82EF0604: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EF0608: 816105B4  lwz r11, 0x5b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1460 as u32) ) } as u64;
	// 82EF060C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0610: 409A004C  bne cr6, 0x82ef065c
	if !ctx.cr[6].eq {
	pc = 0x82EF065C; continue 'dispatch;
	}
	// 82EF0614: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0618: 896B8F7D  lbz r11, -0x7083(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28803 as u32) ) } as u64;
	// 82EF061C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0620: 4082003C  bne 0x82ef065c
	if !ctx.cr[0].eq {
	pc = 0x82EF065C; continue 'dispatch;
	}
	// 82EF0624: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0628: 3BEB8F7D  addi r31, r11, -0x7083
	ctx.r[31].s64 = ctx.r[11].s64 + -28803;
	// 82EF062C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0630: 38CBC6B8  addi r6, r11, -0x3948
	ctx.r[6].s64 = ctx.r[11].s64 + -14664;
	// 82EF0634: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 82EF0638: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF063C: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0640: 386104F8  addi r3, r1, 0x4f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1272;
	// 82EF0644: 4BFFAB25  bl 0x82eeb168
	ctx.lr = 0x82EF0648;
	sub_82EEB168(ctx, base);
	// 82EF0648: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF064C: 4820176D  bl 0x830f1db8
	ctx.lr = 0x82EF0650;
	sub_830F1DB8(ctx, base);
	// 82EF0650: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0654: 40820008  bne 0x82ef065c
	if !ctx.cr[0].eq {
	pc = 0x82EF065C; continue 'dispatch;
	}
	// 82EF0658: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EF065C: 816105BC  lwz r11, 0x5bc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1468 as u32) ) } as u64;
	// 82EF0660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0664: 409A004C  bne cr6, 0x82ef06b0
	if !ctx.cr[6].eq {
	pc = 0x82EF06B0; continue 'dispatch;
	}
	// 82EF0668: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF066C: 896B8F7C  lbz r11, -0x7084(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28804 as u32) ) } as u64;
	// 82EF0670: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0674: 4082003C  bne 0x82ef06b0
	if !ctx.cr[0].eq {
	pc = 0x82EF06B0; continue 'dispatch;
	}
	// 82EF0678: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF067C: 3BEB8F7C  addi r31, r11, -0x7084
	ctx.r[31].s64 = ctx.r[11].s64 + -28804;
	// 82EF0680: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0684: 38CBC6A4  addi r6, r11, -0x395c
	ctx.r[6].s64 = ctx.r[11].s64 + -14684;
	// 82EF0688: 38A000D5  li r5, 0xd5
	ctx.r[5].s64 = 213;
	// 82EF068C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0690: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0694: 38610508  addi r3, r1, 0x508
	ctx.r[3].s64 = ctx.r[1].s64 + 1288;
	// 82EF0698: 4BFFAAD1  bl 0x82eeb168
	ctx.lr = 0x82EF069C;
	sub_82EEB168(ctx, base);
	// 82EF069C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF06A0: 48201719  bl 0x830f1db8
	ctx.lr = 0x82EF06A4;
	sub_830F1DB8(ctx, base);
	// 82EF06A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF06A8: 40820008  bne 0x82ef06b0
	if !ctx.cr[0].eq {
	pc = 0x82EF06B0; continue 'dispatch;
	}
	// 82EF06AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EF06B0: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF06B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF06B8: 409A004C  bne cr6, 0x82ef0704
	if !ctx.cr[6].eq {
	pc = 0x82EF0704; continue 'dispatch;
	}
	// 82EF06BC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF06C0: 896B8F7B  lbz r11, -0x7085(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28805 as u32) ) } as u64;
	// 82EF06C4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF06C8: 4082003C  bne 0x82ef0704
	if !ctx.cr[0].eq {
	pc = 0x82EF0704; continue 'dispatch;
	}
	// 82EF06CC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF06D0: 3BEB8F7B  addi r31, r11, -0x7085
	ctx.r[31].s64 = ctx.r[11].s64 + -28805;
	// 82EF06D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF06D8: 38CBC77C  addi r6, r11, -0x3884
	ctx.r[6].s64 = ctx.r[11].s64 + -14468;
	// 82EF06DC: 38A000D6  li r5, 0xd6
	ctx.r[5].s64 = 214;
	// 82EF06E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF06E4: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF06E8: 38610518  addi r3, r1, 0x518
	ctx.r[3].s64 = ctx.r[1].s64 + 1304;
	// 82EF06EC: 4BFFAA7D  bl 0x82eeb168
	ctx.lr = 0x82EF06F0;
	sub_82EEB168(ctx, base);
	// 82EF06F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF06F4: 482016C5  bl 0x830f1db8
	ctx.lr = 0x82EF06F8;
	sub_830F1DB8(ctx, base);
	// 82EF06F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF06FC: 40820008  bne 0x82ef0704
	if !ctx.cr[0].eq {
	pc = 0x82EF0704; continue 'dispatch;
	}
	// 82EF0700: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EF0704: 816105C4  lwz r11, 0x5c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1476 as u32) ) } as u64;
	// 82EF0708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF070C: 409A004C  bne cr6, 0x82ef0758
	if !ctx.cr[6].eq {
	pc = 0x82EF0758; continue 'dispatch;
	}
	// 82EF0710: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0714: 896B8F7A  lbz r11, -0x7086(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28806 as u32) ) } as u64;
	// 82EF0718: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF071C: 4082003C  bne 0x82ef0758
	if !ctx.cr[0].eq {
	pc = 0x82EF0758; continue 'dispatch;
	}
	// 82EF0720: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0724: 3BEB8F7A  addi r31, r11, -0x7086
	ctx.r[31].s64 = ctx.r[11].s64 + -28806;
	// 82EF0728: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF072C: 38CBC690  addi r6, r11, -0x3970
	ctx.r[6].s64 = ctx.r[11].s64 + -14704;
	// 82EF0730: 38A000D7  li r5, 0xd7
	ctx.r[5].s64 = 215;
	// 82EF0734: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0738: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF073C: 38610528  addi r3, r1, 0x528
	ctx.r[3].s64 = ctx.r[1].s64 + 1320;
	// 82EF0740: 4BFFAA29  bl 0x82eeb168
	ctx.lr = 0x82EF0744;
	sub_82EEB168(ctx, base);
	// 82EF0744: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF0748: 48201671  bl 0x830f1db8
	ctx.lr = 0x82EF074C;
	sub_830F1DB8(ctx, base);
	// 82EF074C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0750: 40820008  bne 0x82ef0758
	if !ctx.cr[0].eq {
	pc = 0x82EF0758; continue 'dispatch;
	}
	// 82EF0754: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EF0758: 816105CC  lwz r11, 0x5cc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1484 as u32) ) } as u64;
	// 82EF075C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0760: 409A004C  bne cr6, 0x82ef07ac
	if !ctx.cr[6].eq {
	pc = 0x82EF07AC; continue 'dispatch;
	}
	// 82EF0764: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0768: 896B8F79  lbz r11, -0x7087(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28807 as u32) ) } as u64;
	// 82EF076C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0770: 4082003C  bne 0x82ef07ac
	if !ctx.cr[0].eq {
	pc = 0x82EF07AC; continue 'dispatch;
	}
	// 82EF0774: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0778: 3BEB8F79  addi r31, r11, -0x7087
	ctx.r[31].s64 = ctx.r[11].s64 + -28807;
	// 82EF077C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0780: 38CBC680  addi r6, r11, -0x3980
	ctx.r[6].s64 = ctx.r[11].s64 + -14720;
	// 82EF0784: 38A000D8  li r5, 0xd8
	ctx.r[5].s64 = 216;
	// 82EF0788: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF078C: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0790: 38610538  addi r3, r1, 0x538
	ctx.r[3].s64 = ctx.r[1].s64 + 1336;
	// 82EF0794: 4BFFA9D5  bl 0x82eeb168
	ctx.lr = 0x82EF0798;
	sub_82EEB168(ctx, base);
	// 82EF0798: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF079C: 4820161D  bl 0x830f1db8
	ctx.lr = 0x82EF07A0;
	sub_830F1DB8(ctx, base);
	// 82EF07A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF07A4: 40820008  bne 0x82ef07ac
	if !ctx.cr[0].eq {
	pc = 0x82EF07AC; continue 'dispatch;
	}
	// 82EF07A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EF07AC: 808105D4  lwz r4, 0x5d4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF07B0: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF07B4: 386B0260  addi r3, r11, 0x260
	ctx.r[3].s64 = ctx.r[11].s64 + 608;
	// 82EF07B8: 48200B79  bl 0x830f1330
	ctx.lr = 0x82EF07BC;
	sub_830F1330(ctx, base);
	// 82EF07BC: 808105DC  lwz r4, 0x5dc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1500 as u32) ) } as u64;
	// 82EF07C0: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF07C4: 386B0364  addi r3, r11, 0x364
	ctx.r[3].s64 = ctx.r[11].s64 + 868;
	// 82EF07C8: 48200B69  bl 0x830f1330
	ctx.lr = 0x82EF07CC;
	sub_830F1330(ctx, base);
	// 82EF07CC: 816105AC  lwz r11, 0x5ac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1452 as u32) ) } as u64;
	// 82EF07D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF07D4: 419A0028  beq cr6, 0x82ef07fc
	if ctx.cr[6].eq {
	pc = 0x82EF07FC; continue 'dispatch;
	}
	// 82EF07D8: 816105B4  lwz r11, 0x5b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1460 as u32) ) } as u64;
	// 82EF07DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF07E0: 419A001C  beq cr6, 0x82ef07fc
	if ctx.cr[6].eq {
	pc = 0x82EF07FC; continue 'dispatch;
	}
	// 82EF07E4: 816105BC  lwz r11, 0x5bc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1468 as u32) ) } as u64;
	// 82EF07E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF07EC: 419A0010  beq cr6, 0x82ef07fc
	if ctx.cr[6].eq {
	pc = 0x82EF07FC; continue 'dispatch;
	}
	// 82EF07F0: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF07F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF07F8: 409A0010  bne cr6, 0x82ef0808
	if !ctx.cr[6].eq {
	pc = 0x82EF0808; continue 'dispatch;
	}
	// 82EF07FC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EF0800: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EF0804: 4800037C  b 0x82ef0b80
	pc = 0x82EF0B80; continue 'dispatch;
	// 82EF0808: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF080C: 814105BC  lwz r10, 0x5bc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1468 as u32) ) } as u64;
	// 82EF0810: 914B046C  stw r10, 0x46c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1132 as u32), ctx.r[10].u32 ) };
	// 82EF0814: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0818: 814105C4  lwz r10, 0x5c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1476 as u32) ) } as u64;
	// 82EF081C: 914B0480  stw r10, 0x480(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	// 82EF0820: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0824: 814105CC  lwz r10, 0x5cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1484 as u32) ) } as u64;
	// 82EF0828: 914B0484  stw r10, 0x484(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1156 as u32), ctx.r[10].u32 ) };
	// 82EF082C: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0830: 814105EC  lwz r10, 0x5ec(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1516 as u32) ) } as u64;
	// 82EF0834: 914B04D8  stw r10, 0x4d8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1240 as u32), ctx.r[10].u32 ) };
	// 82EF0838: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF083C: 814105F4  lwz r10, 0x5f4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1524 as u32) ) } as u64;
	// 82EF0840: 914B0470  stw r10, 0x470(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1136 as u32), ctx.r[10].u32 ) };
	// 82EF0844: 80E105E4  lwz r7, 0x5e4(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1508 as u32) ) } as u64;
	// 82EF0848: 80C105D4  lwz r6, 0x5d4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF084C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0850: 38ABC37C  addi r5, r11, -0x3c84
	ctx.r[5].s64 = ctx.r[11].s64 + -15492;
	// 82EF0854: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF0858: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 82EF085C: 4BFFA98D  bl 0x82eeb1e8
	ctx.lr = 0x82EF0860;
	sub_82EEB1E8(ctx, base);
	// 82EF0860: 388102D0  addi r4, r1, 0x2d0
	ctx.r[4].s64 = ctx.r[1].s64 + 720;
	// 82EF0864: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0868: 814105A4  lwz r10, 0x5a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF086C: 386A04E0  addi r3, r10, 0x4e0
	ctx.r[3].s64 = ctx.r[10].s64 + 1248;
	// 82EF0870: 816B04E0  lwz r11, 0x4e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1248 as u32) ) } as u64;
	// 82EF0874: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0878: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF087C: 4E800421  bctrl
	ctx.lr = 0x82EF0880;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0880: 9061015C  stw r3, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[3].u32 ) };
	// 82EF0884: 8161015C  lwz r11, 0x15c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82EF0888: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF088C: 41980028  blt cr6, 0x82ef08b4
	if ctx.cr[6].lt {
	pc = 0x82EF08B4; continue 'dispatch;
	}
	// 82EF0890: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0894: 814105A4  lwz r10, 0x5a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0898: 386A04E0  addi r3, r10, 0x4e0
	ctx.r[3].s64 = ctx.r[10].s64 + 1248;
	// 82EF089C: 816B04E0  lwz r11, 0x4e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1248 as u32) ) } as u64;
	// 82EF08A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF08A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF08A8: 4E800421  bctrl
	ctx.lr = 0x82EF08AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF08AC: 90610570  stw r3, 0x570(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1392 as u32), ctx.r[3].u32 ) };
	// 82EF08B0: 4800000C  b 0x82ef08bc
	pc = 0x82EF08BC; continue 'dispatch;
	// 82EF08B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF08B8: 91610570  stw r11, 0x570(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1392 as u32), ctx.r[11].u32 ) };
	// 82EF08BC: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF08C0: 81410570  lwz r10, 0x570(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1392 as u32) ) } as u64;
	// 82EF08C4: 914B0474  stw r10, 0x474(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1140 as u32), ctx.r[10].u32 ) };
	// 82EF08C8: 80C105D4  lwz r6, 0x5d4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF08CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF08D0: 38ABC3B4  addi r5, r11, -0x3c4c
	ctx.r[5].s64 = ctx.r[11].s64 + -15436;
	// 82EF08D4: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF08D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF08DC: 4BFFA76D  bl 0x82eeb048
	ctx.lr = 0x82EF08E0;
	sub_82EEB048(ctx, base);
	// 82EF08E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF08E4: 996101C0  stb r11, 0x1c0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[11].u8 ) };
	// 82EF08E8: 38A00103  li r5, 0x103
	ctx.r[5].s64 = 259;
	// 82EF08EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF08F0: 386101C1  addi r3, r1, 0x1c1
	ctx.r[3].s64 = ctx.r[1].s64 + 449;
	// 82EF08F4: 4BDB90BD  bl 0x82ca99b0
	ctx.lr = 0x82EF08F8;
	sub_82CA99B0(ctx, base);
	// 82EF08F8: 808105D4  lwz r4, 0x5d4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF08FC: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 82EF0900: 4BFFF709  bl 0x82ef0008
	ctx.lr = 0x82EF0904;
	sub_82EF0008(ctx, base);
	// 82EF0904: 39610544  addi r11, r1, 0x544
	ctx.r[11].s64 = ctx.r[1].s64 + 1348;
	// 82EF0908: 91610548  stw r11, 0x548(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1352 as u32), ctx.r[11].u32 ) };
	// 82EF090C: 80610548  lwz r3, 0x548(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1352 as u32) ) } as u64;
	// 82EF0910: 4BFFCB89  bl 0x82eed498
	ctx.lr = 0x82EF0914;
	sub_82EED498(ctx, base);
	// 82EF0914: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF0918: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF091C: 4BFFC905  bl 0x82eed220
	ctx.lr = 0x82EF0920;
	sub_82EED220(ctx, base);
	// 82EF0920: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0924: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EF0928: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF092C: 4BFFC985  bl 0x82eed2b0
	ctx.lr = 0x82EF0930;
	sub_82EED2B0(ctx, base);
	// 82EF0930: 388101C0  addi r4, r1, 0x1c0
	ctx.r[4].s64 = ctx.r[1].s64 + 448;
	// 82EF0934: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF0938: 4BFFF5E9  bl 0x82eeff20
	ctx.lr = 0x82EF093C;
	sub_82EEFF20(ctx, base);
	// 82EF093C: 90610158  stw r3, 0x158(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[3].u32 ) };
	// 82EF0940: 81610158  lwz r11, 0x158(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EF0944: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0948: 40980020  bge cr6, 0x82ef0968
	if !ctx.cr[6].lt {
	pc = 0x82EF0968; continue 'dispatch;
	}
	// 82EF094C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EF0950: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EF0954: 9161054C  stw r11, 0x54c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1356 as u32), ctx.r[11].u32 ) };
	// 82EF0958: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF095C: 4BFFC91D  bl 0x82eed278
	ctx.lr = 0x82EF0960;
	sub_82EED278(ctx, base);
	// 82EF0960: 8061054C  lwz r3, 0x54c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82EF0964: 4800021C  b 0x82ef0b80
	pc = 0x82EF0B80; continue 'dispatch;
	// 82EF0968: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF096C: 4BFFCAFD  bl 0x82eed468
	ctx.lr = 0x82EF0970;
	sub_82EED468(ctx, base);
	// 82EF0970: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF0974: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0978: 814105A4  lwz r10, 0x5a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF097C: 386A04E8  addi r3, r10, 0x4e8
	ctx.r[3].s64 = ctx.r[10].s64 + 1256;
	// 82EF0980: 816B04E8  lwz r11, 0x4e8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1256 as u32) ) } as u64;
	// 82EF0984: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF0988: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF098C: 4E800421  bctrl
	ctx.lr = 0x82EF0990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0990: 9061015C  stw r3, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[3].u32 ) };
	// 82EF0994: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0998: 814105A4  lwz r10, 0x5a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF099C: 386A04E8  addi r3, r10, 0x4e8
	ctx.r[3].s64 = ctx.r[10].s64 + 1256;
	// 82EF09A0: 816B04E8  lwz r11, 0x4e8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1256 as u32) ) } as u64;
	// 82EF09A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF09A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF09AC: 4E800421  bctrl
	ctx.lr = 0x82EF09B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF09B0: 90610154  stw r3, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[3].u32 ) };
	// 82EF09B4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF09B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF09BC: 388BC668  addi r4, r11, -0x3998
	ctx.r[4].s64 = ctx.r[11].s64 + -14744;
	// 82EF09C0: 81610154  lwz r11, 0x154(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF09C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF09C8: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF09CC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF09D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF09D4: 4E800421  bctrl
	ctx.lr = 0x82EF09D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF09D8: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF09DC: 906B0478  stw r3, 0x478(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1144 as u32), ctx.r[3].u32 ) };
	// 82EF09E0: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF09E4: 816B0478  lwz r11, 0x478(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1144 as u32) ) } as u64;
	// 82EF09E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF09EC: 409A0058  bne cr6, 0x82ef0a44
	if !ctx.cr[6].eq {
	pc = 0x82EF0A44; continue 'dispatch;
	}
	// 82EF09F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF09F4: 896B8F78  lbz r11, -0x7088(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28808 as u32) ) } as u64;
	// 82EF09F8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF09FC: 40820048  bne 0x82ef0a44
	if !ctx.cr[0].eq {
	pc = 0x82EF0A44; continue 'dispatch;
	}
	// 82EF0A00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A04: 3BEBC750  addi r31, r11, -0x38b0
	ctx.r[31].s64 = ctx.r[11].s64 + -14512;
	// 82EF0A08: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0A0C: 3BCB8F78  addi r30, r11, -0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + -28808;
	// 82EF0A10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A14: 38CBC73C  addi r6, r11, -0x38c4
	ctx.r[6].s64 = ctx.r[11].s64 + -14532;
	// 82EF0A18: 38A00107  li r5, 0x107
	ctx.r[5].s64 = 263;
	// 82EF0A1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A20: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0A24: 38610550  addi r3, r1, 0x550
	ctx.r[3].s64 = ctx.r[1].s64 + 1360;
	// 82EF0A28: 4BFFA741  bl 0x82eeb168
	ctx.lr = 0x82EF0A2C;
	sub_82EEB168(ctx, base);
	// 82EF0A2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF0A30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF0A34: 4820145D  bl 0x830f1e90
	ctx.lr = 0x82EF0A38;
	sub_830F1E90(ctx, base);
	// 82EF0A38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0A3C: 40820008  bne 0x82ef0a44
	if !ctx.cr[0].eq {
	pc = 0x82EF0A44; continue 'dispatch;
	}
	// 82EF0A40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EF0A44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF0A48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A4C: 388BC654  addi r4, r11, -0x39ac
	ctx.r[4].s64 = ctx.r[11].s64 + -14764;
	// 82EF0A50: 81610154  lwz r11, 0x154(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF0A54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0A58: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF0A5C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF0A60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0A64: 4E800421  bctrl
	ctx.lr = 0x82EF0A68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0A68: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0A6C: 906B047C  stw r3, 0x47c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1148 as u32), ctx.r[3].u32 ) };
	// 82EF0A70: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0A74: 816B047C  lwz r11, 0x47c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1148 as u32) ) } as u64;
	// 82EF0A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0A7C: 409A0058  bne cr6, 0x82ef0ad4
	if !ctx.cr[6].eq {
	pc = 0x82EF0AD4; continue 'dispatch;
	}
	// 82EF0A80: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0A84: 896B8F77  lbz r11, -0x7089(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28809 as u32) ) } as u64;
	// 82EF0A88: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0A8C: 40820048  bne 0x82ef0ad4
	if !ctx.cr[0].eq {
	pc = 0x82EF0AD4; continue 'dispatch;
	}
	// 82EF0A90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A94: 3BEBC710  addi r31, r11, -0x38f0
	ctx.r[31].s64 = ctx.r[11].s64 + -14576;
	// 82EF0A98: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0A9C: 3BCB8F77  addi r30, r11, -0x7089
	ctx.r[30].s64 = ctx.r[11].s64 + -28809;
	// 82EF0AA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0AA4: 38CBC6F8  addi r6, r11, -0x3908
	ctx.r[6].s64 = ctx.r[11].s64 + -14600;
	// 82EF0AA8: 38A0010A  li r5, 0x10a
	ctx.r[5].s64 = 266;
	// 82EF0AAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0AB0: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0AB4: 38610560  addi r3, r1, 0x560
	ctx.r[3].s64 = ctx.r[1].s64 + 1376;
	// 82EF0AB8: 4BFFA6B1  bl 0x82eeb168
	ctx.lr = 0x82EF0ABC;
	sub_82EEB168(ctx, base);
	// 82EF0ABC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF0AC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF0AC4: 482013CD  bl 0x830f1e90
	ctx.lr = 0x82EF0AC8;
	sub_830F1E90(ctx, base);
	// 82EF0AC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0ACC: 40820008  bne 0x82ef0ad4
	if !ctx.cr[0].eq {
	pc = 0x82EF0AD4; continue 'dispatch;
	}
	// 82EF0AD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82EF0AD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0AD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0ADC: 388BC640  addi r4, r11, -0x39c0
	ctx.r[4].s64 = ctx.r[11].s64 + -14784;
	// 82EF0AE0: 81610154  lwz r11, 0x154(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF0AE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0AE8: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF0AEC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0AF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0AF4: 4E800421  bctrl
	ctx.lr = 0x82EF0AF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0AF8: 90610160  stw r3, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[3].u32 ) };
	// 82EF0AFC: 81610160  lwz r11, 0x160(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EF0B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0B04: 419A0014  beq cr6, 0x82ef0b18
	if ctx.cr[6].eq {
	pc = 0x82EF0B18; continue 'dispatch;
	}
	// 82EF0B08: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B0C: 388B0050  addi r4, r11, 0x50
	ctx.r[4].s64 = ctx.r[11].s64 + 80;
	// 82EF0B10: 80610160  lwz r3, 0x160(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EF0B14: 4BFFA35D  bl 0x82eeae70
	ctx.lr = 0x82EF0B18;
	sub_82EEAE70(ctx, base);
	// 82EF0B18: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF0B1C: 80A105B4  lwz r5, 0x5b4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1460 as u32) ) } as u64;
	// 82EF0B20: 808105AC  lwz r4, 0x5ac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1452 as u32) ) } as u64;
	// 82EF0B24: 806105A4  lwz r3, 0x5a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B28: 480FDC21  bl 0x82fee748
	ctx.lr = 0x82EF0B2C;
	sub_82FEE748(ctx, base);
	// 82EF0B2C: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF0B34: 914B0044  stw r10, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 82EF0B38: 4B375579  bl 0x822660b0
	ctx.lr = 0x82EF0B3C;
	sub_822660B0(ctx, base);
	// 82EF0B3C: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B40: 906B0048  stw r3, 0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82EF0B44: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B48: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF0B4C: 994B0468  stb r10, 0x468(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1128 as u32), ctx.r[10].u8 ) };
	// 82EF0B50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0B54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF0B58: C02B0AA0  lfs f1, 0xaa0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2720 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF0B5C: 806105A4  lwz r3, 0x5a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B60: 480FD891  bl 0x82fee3f0
	ctx.lr = 0x82EF0B64;
	sub_82FEE3F0(ctx, base);
	// 82EF0B64: 806105A4  lwz r3, 0x5a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B68: 48002D91  bl 0x82ef38f8
	ctx.lr = 0x82EF0B6C;
	sub_82EF38F8(ctx, base);
	// 82EF0B6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF0B70: 9161056C  stw r11, 0x56c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1388 as u32), ctx.r[11].u32 ) };
	// 82EF0B74: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF0B78: 4BFFC701  bl 0x82eed278
	ctx.lr = 0x82EF0B7C;
	sub_82EED278(ctx, base);
	// 82EF0B7C: 8061056C  lwz r3, 0x56c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1388 as u32) ) } as u64;
	// 82EF0B80: 38210590  addi r1, r1, 0x590
	ctx.r[1].s64 = ctx.r[1].s64 + 1424;
	// 82EF0B84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0B88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0B8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF0B90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF0B94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0B98 size=596
    let mut pc: u32 = 0x82EF0B98;
    'dispatch: loop {
        match pc {
            0x82EF0B98 => {
    //   block [0x82EF0B98..0x82EF0DEC)
	// 82EF0B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0B9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0BA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF0BA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF0BA8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0BAC: 906100E4  stw r3, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[3].u32 ) };
	// 82EF0BB0: 908100EC  stw r4, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[4].u32 ) };
	// 82EF0BB4: 816100EC  lwz r11, 0xec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82EF0BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0BBC: 409A0008  bne cr6, 0x82ef0bc4
	if !ctx.cr[6].eq {
	pc = 0x82EF0BC4; continue 'dispatch;
	}
	// 82EF0BC0: 48000214  b 0x82ef0dd4
	pc = 0x82EF0DD4; continue 'dispatch;
	// 82EF0BC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0BC8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EF0BCC: 388B17CC  addi r4, r11, 0x17cc
	ctx.r[4].s64 = ctx.r[11].s64 + 6092;
	// 82EF0BD0: 816100EC  lwz r11, 0xec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82EF0BD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0BD8: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82EF0BDC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF0BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0BE4: 4E800421  bctrl
	ctx.lr = 0x82EF0BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0BE8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF0BEC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0BF4: 419A01E0  beq cr6, 0x82ef0dd4
	if ctx.cr[6].eq {
	pc = 0x82EF0DD4; continue 'dispatch;
	}
	// 82EF0BF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0BFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0C00: 388BC7E4  addi r4, r11, -0x381c
	ctx.r[4].s64 = ctx.r[11].s64 + -14364;
	// 82EF0C04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0C08: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0C0C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0C10: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0C14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0C18: 4E800421  bctrl
	ctx.lr = 0x82EF0C1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0C1C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF0C20: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0C28: 419A0180  beq cr6, 0x82ef0da8
	if ctx.cr[6].eq {
	pc = 0x82EF0DA8; continue 'dispatch;
	}
	// 82EF0C2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF0C30: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0C34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0C38: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0C3C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EF0C40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0C44: 4E800421  bctrl
	ctx.lr = 0x82EF0C48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0C48: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EF0C4C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0C54: 419A0154  beq cr6, 0x82ef0da8
	if ctx.cr[6].eq {
	pc = 0x82EF0DA8; continue 'dispatch;
	}
	// 82EF0C58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF0C5C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0C64: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C68: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EF0C6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0C70: 4E800421  bctrl
	ctx.lr = 0x82EF0C74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0C74: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EF0C78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0C7C: 3BEBC7D8  addi r31, r11, -0x3828
	ctx.r[31].s64 = ctx.r[11].s64 + -14376;
	// 82EF0C80: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0C88: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF0C90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0C94: 4E800421  bctrl
	ctx.lr = 0x82EF0C98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0C98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF0C9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0CA0: 48003C79  bl 0x82ef4918
	ctx.lr = 0x82EF0CA4;
	sub_82EF4918(ctx, base);
	// 82EF0CA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0CA8: 41820060  beq 0x82ef0d08
	if ctx.cr[0].eq {
	pc = 0x82EF0D08; continue 'dispatch;
	}
	// 82EF0CAC: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF0CB0: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF0CB4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EF0CB8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF0CBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EF0CC0: 4B32EE49  bl 0x8221fb08
	ctx.lr = 0x82EF0CC4;
	sub_8221FB08(ctx, base);
	// 82EF0CC4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0CC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EF0CCC: 48004B45  bl 0x82ef5810
	ctx.lr = 0x82EF0CD0;
	sub_82EF5810(ctx, base);
	// 82EF0CD0: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF0CD4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82EF0CD8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EF0CDC: 48004B35  bl 0x82ef5810
	ctx.lr = 0x82EF0CE0;
	sub_82EF5810(ctx, base);
	// 82EF0CE0: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82EF0CE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0CE8: 3BCBC7BC  addi r30, r11, -0x3844
	ctx.r[30].s64 = ctx.r[11].s64 + -14404;
	// 82EF0CEC: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82EF0CF0: 48004C49  bl 0x82ef5938
	ctx.lr = 0x82EF0CF4;
	sub_82EF5938(ctx, base);
	// 82EF0CF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF0CF8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF0CFC: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82EF0D00: 48004B39  bl 0x82ef5838
	ctx.lr = 0x82EF0D04;
	sub_82EF5838(ctx, base);
	// 82EF0D04: 48000084  b 0x82ef0d88
	pc = 0x82EF0D88; continue 'dispatch;
	// 82EF0D08: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF0D0C: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF0D10: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82EF0D14: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF0D18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EF0D1C: 4B32EDED  bl 0x8221fb08
	ctx.lr = 0x82EF0D20;
	sub_8221FB08(ctx, base);
	// 82EF0D20: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0D24: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EF0D28: 48004AE9  bl 0x82ef5810
	ctx.lr = 0x82EF0D2C;
	sub_82EF5810(ctx, base);
	// 82EF0D2C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0D30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0D34: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0D38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF0D3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0D40: 4E800421  bctrl
	ctx.lr = 0x82EF0D44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0D44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF0D48: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82EF0D4C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EF0D50: 48004AC1  bl 0x82ef5810
	ctx.lr = 0x82EF0D54;
	sub_82EF5810(ctx, base);
	// 82EF0D54: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF0D58: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82EF0D5C: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 82EF0D60: 48004AB1  bl 0x82ef5810
	ctx.lr = 0x82EF0D64;
	sub_82EF5810(ctx, base);
	// 82EF0D64: 3BE10080  addi r31, r1, 0x80
	ctx.r[31].s64 = ctx.r[1].s64 + 128;
	// 82EF0D68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0D6C: 3BCBC79C  addi r30, r11, -0x3864
	ctx.r[30].s64 = ctx.r[11].s64 + -14436;
	// 82EF0D70: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82EF0D74: 48004BC5  bl 0x82ef5938
	ctx.lr = 0x82EF0D78;
	sub_82EF5938(ctx, base);
	// 82EF0D78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF0D7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF0D80: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82EF0D84: 48004AB5  bl 0x82ef5838
	ctx.lr = 0x82EF0D88;
	sub_82EF5838(ctx, base);
	// 82EF0D88: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0D8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0D90: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0D94: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EF0D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0D9C: 4E800421  bctrl
	ctx.lr = 0x82EF0DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0DA0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EF0DA4: 4BFFFEA8  b 0x82ef0c4c
	pc = 0x82EF0C4C; continue 'dispatch;
	// 82EF0DA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0DAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EF0DB0: 388B17CC  addi r4, r11, 0x17cc
	ctx.r[4].s64 = ctx.r[11].s64 + 6092;
	// 82EF0DB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0DB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0DBC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0DC0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF0DC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0DC8: 4E800421  bctrl
	ctx.lr = 0x82EF0DCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0DCC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF0DD0: 4BFFFE1C  b 0x82ef0bec
	pc = 0x82EF0BEC; continue 'dispatch;
	// 82EF0DD4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EF0DD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0DDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0DE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF0DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF0DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0DF0 size=2140
    let mut pc: u32 = 0x82EF0DF0;
    'dispatch: loop {
        match pc {
            0x82EF0DF0 => {
    //   block [0x82EF0DF0..0x82EF164C)
	// 82EF0DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0DF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF0DFC: 3BE1FBC0  addi r31, r1, -0x440
	ctx.r[31].s64 = ctx.r[1].s64 + -1088;
	// 82EF0E00: 9421FBC0  stwu r1, -0x440(r1)
	ea = ctx.r[1].u32.wrapping_add(-1088 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0E04: 907F0454  stw r3, 0x454(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1108 as u32), ctx.r[3].u32 ) };
	// 82EF0E08: 909F045C  stw r4, 0x45c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1116 as u32), ctx.r[4].u32 ) };
	// 82EF0E0C: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0E14: 409A0008  bne cr6, 0x82ef0e1c
	if !ctx.cr[6].eq {
	pc = 0x82EF0E1C; continue 'dispatch;
	}
	// 82EF0E18: 48000820  b 0x82ef1638
	pc = 0x82EF1638; continue 'dispatch;
	// 82EF0E1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0E20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0E24: 388BC898  addi r4, r11, -0x3768
	ctx.r[4].s64 = ctx.r[11].s64 + -14184;
	// 82EF0E28: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0E2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0E30: 807F045C  lwz r3, 0x45c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0E34: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0E38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0E3C: 4E800421  bctrl
	ctx.lr = 0x82EF0E40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0E40: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF0E44: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0E4C: 409A0014  bne cr6, 0x82ef0e60
	if !ctx.cr[6].eq {
	pc = 0x82EF0E60; continue 'dispatch;
	}
	// 82EF0E50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF0E54: 396B0AF8  addi r11, r11, 0xaf8
	ctx.r[11].s64 = ctx.r[11].s64 + 2808;
	// 82EF0E58: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF0E5C: 4800014C  b 0x82ef0fa8
	pc = 0x82EF0FA8; continue 'dispatch;
	// 82EF0E60: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 82EF0E64: 4800491D  bl 0x82ef5780
	ctx.lr = 0x82EF0E68;
	sub_82EF5780(ctx, base);
	// 82EF0E68: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0E6C: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 82EF0E70: 480049A1  bl 0x82ef5810
	ctx.lr = 0x82EF0E74;
	sub_82EF5810(ctx, base);
	// 82EF0E74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0E78: 38CBC880  addi r6, r11, -0x3780
	ctx.r[6].s64 = ctx.r[11].s64 + -14208;
	// 82EF0E7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0E80: 38ABC874  addi r5, r11, -0x378c
	ctx.r[5].s64 = ctx.r[11].s64 + -14220;
	// 82EF0E84: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF0E88: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82EF0E8C: 4BFFA1BD  bl 0x82eeb048
	ctx.lr = 0x82EF0E90;
	sub_82EEB048(ctx, base);
	// 82EF0E90: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF0E94: 48004AA5  bl 0x82ef5938
	ctx.lr = 0x82EF0E98;
	sub_82EF5938(ctx, base);
	// 82EF0E98: 907F040C  stw r3, 0x40c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), ctx.r[3].u32 ) };
	// 82EF0E9C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF0EA0: 38BF0170  addi r5, r31, 0x170
	ctx.r[5].s64 = ctx.r[31].s64 + 368;
	// 82EF0EA4: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 82EF0EA8: 807F040C  lwz r3, 0x40c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) } as u64;
	// 82EF0EAC: 817F040C  lwz r11, 0x40c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) } as u64;
	// 82EF0EB0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0EB4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF0EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0EBC: 4E800421  bctrl
	ctx.lr = 0x82EF0EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0EC0: 817F0454  lwz r11, 0x454(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF0EC4: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0EC8: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82EF0ECC: F97F0410  std r11, 0x410(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), ctx.r[11].u64 ) };
	// 82EF0ED0: C81F0410  lfd f0, 0x410(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	// 82EF0ED4: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF0ED8: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 82EF0EDC: 4800490D  bl 0x82ef57e8
	ctx.lr = 0x82EF0EE0;
	sub_82EF57E8(ctx, base);
	// 82EF0EE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0EE4: 38CBC640  addi r6, r11, -0x39c0
	ctx.r[6].s64 = ctx.r[11].s64 + -14784;
	// 82EF0EE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0EEC: 38ABC874  addi r5, r11, -0x378c
	ctx.r[5].s64 = ctx.r[11].s64 + -14220;
	// 82EF0EF0: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF0EF4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82EF0EF8: 4BFFA151  bl 0x82eeb048
	ctx.lr = 0x82EF0EFC;
	sub_82EEB048(ctx, base);
	// 82EF0EFC: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF0F00: 48004A39  bl 0x82ef5938
	ctx.lr = 0x82EF0F04;
	sub_82EF5938(ctx, base);
	// 82EF0F04: 907F0418  stw r3, 0x418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), ctx.r[3].u32 ) };
	// 82EF0F08: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF0F0C: 38BF0170  addi r5, r31, 0x170
	ctx.r[5].s64 = ctx.r[31].s64 + 368;
	// 82EF0F10: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 82EF0F14: 807F0418  lwz r3, 0x418(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) } as u64;
	// 82EF0F18: 817F0418  lwz r11, 0x418(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) } as u64;
	// 82EF0F1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0F20: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF0F24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0F28: 4E800421  bctrl
	ctx.lr = 0x82EF0F2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0F2C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EF0F30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0F34: 38CBC860  addi r6, r11, -0x37a0
	ctx.r[6].s64 = ctx.r[11].s64 + -14240;
	// 82EF0F38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0F3C: 38ABC898  addi r5, r11, -0x3768
	ctx.r[5].s64 = ctx.r[11].s64 + -14184;
	// 82EF0F40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0F44: 388BC850  addi r4, r11, -0x37b0
	ctx.r[4].s64 = ctx.r[11].s64 + -14256;
	// 82EF0F48: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0F4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0F50: 807F045C  lwz r3, 0x45c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0F54: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF0F58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0F5C: 4E800421  bctrl
	ctx.lr = 0x82EF0F60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0F60: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF0F64: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0F6C: 419A003C  beq cr6, 0x82ef0fa8
	if ctx.cr[6].eq {
	pc = 0x82EF0FA8; continue 'dispatch;
	}
	// 82EF0F70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0F74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0F78: 388BC7D8  addi r4, r11, -0x3828
	ctx.r[4].s64 = ctx.r[11].s64 + -14376;
	// 82EF0F7C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0F80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0F84: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0F88: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0F8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0F90: 4E800421  bctrl
	ctx.lr = 0x82EF0F94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0F94: 907F0180  stw r3, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[3].u32 ) };
	// 82EF0F98: 817F0454  lwz r11, 0x454(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF0F9C: 388B0054  addi r4, r11, 0x54
	ctx.r[4].s64 = ctx.r[11].s64 + 84;
	// 82EF0FA0: 807F0180  lwz r3, 0x180(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EF0FA4: 4BFF9ECD  bl 0x82eeae70
	ctx.lr = 0x82EF0FA8;
	sub_82EEAE70(ctx, base);
	// 82EF0FA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF0FAC: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82EF0FB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0FB4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0FB8: 388BC850  addi r4, r11, -0x37b0
	ctx.r[4].s64 = ctx.r[11].s64 + -14256;
	// 82EF0FBC: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0FC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0FC4: 807F045C  lwz r3, 0x45c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0FC8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF0FCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0FD0: 4E800421  bctrl
	ctx.lr = 0x82EF0FD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0FD4: 907F0188  stw r3, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[3].u32 ) };
	// 82EF0FD8: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF0FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0FE0: 419A021C  beq cr6, 0x82ef11fc
	if ctx.cr[6].eq {
	pc = 0x82EF11FC; continue 'dispatch;
	}
	// 82EF0FE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0FE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0FEC: 388BC898  addi r4, r11, -0x3768
	ctx.r[4].s64 = ctx.r[11].s64 + -14184;
	// 82EF0FF0: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF0FF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0FF8: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF0FFC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1004: 4E800421  bctrl
	ctx.lr = 0x82EF1008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1008: 907F0194  stw r3, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[3].u32 ) };
	// 82EF100C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1010: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1014: 388BC844  addi r4, r11, -0x37bc
	ctx.r[4].s64 = ctx.r[11].s64 + -14268;
	// 82EF1018: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF101C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1020: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF1024: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1028: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF102C: 4E800421  bctrl
	ctx.lr = 0x82EF1030;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1030: 907F018C  stw r3, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[3].u32 ) };
	// 82EF1034: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1038: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF103C: 388BC7D8  addi r4, r11, -0x3828
	ctx.r[4].s64 = ctx.r[11].s64 + -14376;
	// 82EF1040: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF1044: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1048: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF104C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1054: 4E800421  bctrl
	ctx.lr = 0x82EF1058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1058: 907F0190  stw r3, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[3].u32 ) };
	// 82EF105C: 817F018C  lwz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EF1060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1064: 419A0160  beq cr6, 0x82ef11c4
	if ctx.cr[6].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF1068: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EF106C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1070: 419A0154  beq cr6, 0x82ef11c4
	if ctx.cr[6].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF1074: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EF1078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF107C: 419A0148  beq cr6, 0x82ef11c4
	if ctx.cr[6].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF1080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1084: 997F0199  stb r11, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[11].u8 ) };
	// 82EF1088: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EF108C: 997F0198  stb r11, 0x198(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u8 ) };
	// 82EF1090: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EF1094: 480046ED  bl 0x82ef5780
	ctx.lr = 0x82EF1098;
	sub_82EF5780(ctx, base);
	// 82EF1098: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF109C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF10A0: 388BC834  addi r4, r11, -0x37cc
	ctx.r[4].s64 = ctx.r[11].s64 + -14284;
	// 82EF10A4: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EF10A8: 48003871  bl 0x82ef4918
	ctx.lr = 0x82EF10AC;
	sub_82EF4918(ctx, base);
	// 82EF10AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF10B0: 41820030  beq 0x82ef10e0
	if ctx.cr[0].eq {
	pc = 0x82EF10E0; continue 'dispatch;
	}
	// 82EF10B4: 389F01B0  addi r4, r31, 0x1b0
	ctx.r[4].s64 = ctx.r[31].s64 + 432;
	// 82EF10B8: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EF10BC: 4800433D  bl 0x82ef53f8
	ctx.lr = 0x82EF10C0;
	sub_82EF53F8(ctx, base);
	// 82EF10C0: 987F0199  stb r3, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[3].u8 ) };
	// 82EF10C4: 897F0199  lbz r11, 0x199(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(409 as u32) ) } as u64;
	// 82EF10C8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF10CC: 41820010  beq 0x82ef10dc
	if ctx.cr[0].eq {
	pc = 0x82EF10DC; continue 'dispatch;
	}
	// 82EF10D0: C83F01B0  lfd f1, 0x1b0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) };
	// 82EF10D4: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EF10D8: 48004711  bl 0x82ef57e8
	ctx.lr = 0x82EF10DC;
	sub_82EF57E8(ctx, base);
	// 82EF10DC: 48000088  b 0x82ef1164
	pc = 0x82EF1164; continue 'dispatch;
	// 82EF10E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF10E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF10E8: 388BC824  addi r4, r11, -0x37dc
	ctx.r[4].s64 = ctx.r[11].s64 + -14300;
	// 82EF10EC: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EF10F0: 48003829  bl 0x82ef4918
	ctx.lr = 0x82EF10F4;
	sub_82EF4918(ctx, base);
	// 82EF10F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF10F8: 41820030  beq 0x82ef1128
	if ctx.cr[0].eq {
	pc = 0x82EF1128; continue 'dispatch;
	}
	// 82EF10FC: 389F01B8  addi r4, r31, 0x1b8
	ctx.r[4].s64 = ctx.r[31].s64 + 440;
	// 82EF1100: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EF1104: 4BFF9EAD  bl 0x82eeafb0
	ctx.lr = 0x82EF1108;
	sub_82EEAFB0(ctx, base);
	// 82EF1108: 987F0199  stb r3, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[3].u8 ) };
	// 82EF110C: 897F0199  lbz r11, 0x199(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(409 as u32) ) } as u64;
	// 82EF1110: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF1114: 41820010  beq 0x82ef1124
	if ctx.cr[0].eq {
	pc = 0x82EF1124; continue 'dispatch;
	}
	// 82EF1118: 889F01B8  lbz r4, 0x1b8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EF111C: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EF1120: 480046A1  bl 0x82ef57c0
	ctx.lr = 0x82EF1124;
	sub_82EF57C0(ctx, base);
	// 82EF1124: 48000040  b 0x82ef1164
	pc = 0x82EF1164; continue 'dispatch;
	// 82EF1128: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF112C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1130: 388BC814  addi r4, r11, -0x37ec
	ctx.r[4].s64 = ctx.r[11].s64 + -14316;
	// 82EF1134: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EF1138: 480037E1  bl 0x82ef4918
	ctx.lr = 0x82EF113C;
	sub_82EF4918(ctx, base);
	// 82EF113C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF1140: 4182001C  beq 0x82ef115c
	if ctx.cr[0].eq {
	pc = 0x82EF115C; continue 'dispatch;
	}
	// 82EF1144: 809F0190  lwz r4, 0x190(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EF1148: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EF114C: 480046C5  bl 0x82ef5810
	ctx.lr = 0x82EF1150;
	sub_82EF5810(ctx, base);
	// 82EF1150: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EF1154: 997F0199  stb r11, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[11].u8 ) };
	// 82EF1158: 4800000C  b 0x82ef1164
	pc = 0x82EF1164; continue 'dispatch;
	// 82EF115C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1160: 997F0198  stb r11, 0x198(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u8 ) };
	// 82EF1164: 897F0199  lbz r11, 0x199(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(409 as u32) ) } as u64;
	// 82EF1168: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF116C: 41820058  beq 0x82ef11c4
	if ctx.cr[0].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF1170: 897F0198  lbz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EF1174: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF1178: 4182004C  beq 0x82ef11c4
	if ctx.cr[0].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF117C: 80DF0194  lwz r6, 0x194(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EF1180: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1184: 38ABC874  addi r5, r11, -0x378c
	ctx.r[5].s64 = ctx.r[11].s64 + -14220;
	// 82EF1188: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF118C: 387F01C0  addi r3, r31, 0x1c0
	ctx.r[3].s64 = ctx.r[31].s64 + 448;
	// 82EF1190: 4BFF9EB9  bl 0x82eeb048
	ctx.lr = 0x82EF1194;
	sub_82EEB048(ctx, base);
	// 82EF1194: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF1198: 480047A1  bl 0x82ef5938
	ctx.lr = 0x82EF119C;
	sub_82EF5938(ctx, base);
	// 82EF119C: 907F041C  stw r3, 0x41c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1052 as u32), ctx.r[3].u32 ) };
	// 82EF11A0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF11A4: 38BF01A0  addi r5, r31, 0x1a0
	ctx.r[5].s64 = ctx.r[31].s64 + 416;
	// 82EF11A8: 389F01C0  addi r4, r31, 0x1c0
	ctx.r[4].s64 = ctx.r[31].s64 + 448;
	// 82EF11AC: 807F041C  lwz r3, 0x41c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1052 as u32) ) } as u64;
	// 82EF11B0: 817F041C  lwz r11, 0x41c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1052 as u32) ) } as u64;
	// 82EF11B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF11B8: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF11BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF11C0: 4E800421  bctrl
	ctx.lr = 0x82EF11C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF11C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF11C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF11CC: 388BC850  addi r4, r11, -0x37b0
	ctx.r[4].s64 = ctx.r[11].s64 + -14256;
	// 82EF11D0: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF11D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF11D8: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF11DC: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF11E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF11E4: 4E800421  bctrl
	ctx.lr = 0x82EF11E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF11E8: 907F0188  stw r3, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[3].u32 ) };
	// 82EF11EC: 817F0184  lwz r11, 0x184(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 82EF11F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF11F4: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82EF11F8: 4BFFFDE0  b 0x82ef0fd8
	pc = 0x82EF0FD8; continue 'dispatch;
	// 82EF11FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1200: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 82EF1204: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1208: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF120C: 388BC7F8  addi r4, r11, -0x3808
	ctx.r[4].s64 = ctx.r[11].s64 + -14344;
	// 82EF1210: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF1214: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1218: 807F045C  lwz r3, 0x45c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF121C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF1220: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1224: 4E800421  bctrl
	ctx.lr = 0x82EF1228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1228: 907F02C8  stw r3, 0x2c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(712 as u32), ctx.r[3].u32 ) };
	// 82EF122C: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1234: 419A0404  beq cr6, 0x82ef1638
	if ctx.cr[6].eq {
	pc = 0x82EF1638; continue 'dispatch;
	}
	// 82EF1238: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF123C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1240: 388BC898  addi r4, r11, -0x3768
	ctx.r[4].s64 = ctx.r[11].s64 + -14184;
	// 82EF1244: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1248: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF124C: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1250: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1254: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1258: 4E800421  bctrl
	ctx.lr = 0x82EF125C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF125C: 907F02D0  stw r3, 0x2d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(720 as u32), ctx.r[3].u32 ) };
	// 82EF1260: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1264: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1268: 388BC844  addi r4, r11, -0x37bc
	ctx.r[4].s64 = ctx.r[11].s64 + -14268;
	// 82EF126C: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1270: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1274: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1278: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF127C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1280: 4E800421  bctrl
	ctx.lr = 0x82EF1284;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1284: 907F02CC  stw r3, 0x2cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(716 as u32), ctx.r[3].u32 ) };
	// 82EF1288: 817F02CC  lwz r11, 0x2cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) } as u64;
	// 82EF128C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1290: 419A0370  beq cr6, 0x82ef1600
	if ctx.cr[6].eq {
	pc = 0x82EF1600; continue 'dispatch;
	}
	// 82EF1294: 817F02D0  lwz r11, 0x2d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(720 as u32) ) } as u64;
	// 82EF1298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF129C: 419A0364  beq cr6, 0x82ef1600
	if ctx.cr[6].eq {
	pc = 0x82EF1600; continue 'dispatch;
	}
	// 82EF12A0: 80DF02D0  lwz r6, 0x2d0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(720 as u32) ) } as u64;
	// 82EF12A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF12A8: 38ABC874  addi r5, r11, -0x378c
	ctx.r[5].s64 = ctx.r[11].s64 + -14220;
	// 82EF12AC: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF12B0: 387F02E0  addi r3, r31, 0x2e0
	ctx.r[3].s64 = ctx.r[31].s64 + 736;
	// 82EF12B4: 4BFF9D95  bl 0x82eeb048
	ctx.lr = 0x82EF12B8;
	sub_82EEB048(ctx, base);
	// 82EF12B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF12BC: 997F02D4  stb r11, 0x2d4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(724 as u32), ctx.r[11].u8 ) };
	// 82EF12C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF12C4: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	// 82EF12C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF12CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF12D0: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF12D4: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF12D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF12DC: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF12E0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF12E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF12E8: 4E800421  bctrl
	ctx.lr = 0x82EF12EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF12EC: 907F03E4  stw r3, 0x3e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(996 as u32), ctx.r[3].u32 ) };
	// 82EF12F0: 817F03E4  lwz r11, 0x3e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 82EF12F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF12F8: 419A003C  beq cr6, 0x82ef1334
	if ctx.cr[6].eq {
	pc = 0x82EF1334; continue 'dispatch;
	}
	// 82EF12FC: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1300: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF1304: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	// 82EF1308: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF130C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1310: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF1314: 817F03E4  lwz r11, 0x3e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 82EF1318: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF131C: 807F03E4  lwz r3, 0x3e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 82EF1320: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF1324: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1328: 4E800421  bctrl
	ctx.lr = 0x82EF132C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF132C: 907F03E4  stw r3, 0x3e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(996 as u32), ctx.r[3].u32 ) };
	// 82EF1330: 4BFFFFC0  b 0x82ef12f0
	pc = 0x82EF12F0; continue 'dispatch;
	// 82EF1334: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1338: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF133C: 388BC834  addi r4, r11, -0x37cc
	ctx.r[4].s64 = ctx.r[11].s64 + -14284;
	// 82EF1340: 807F02CC  lwz r3, 0x2cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) } as u64;
	// 82EF1344: 480035D5  bl 0x82ef4918
	ctx.lr = 0x82EF1348;
	sub_82EF4918(ctx, base);
	// 82EF1348: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF134C: 4182015C  beq 0x82ef14a8
	if ctx.cr[0].eq {
	pc = 0x82EF14A8; continue 'dispatch;
	}
	// 82EF1350: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1354: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF1358: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 82EF135C: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82EF1360: 4BDBF2F5  bl 0x82cb0654
	ctx.lr = 0x82EF1364;
	sub_82CB0654(ctx, base);
	// 82EF1364: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1368: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 82EF136C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1370: 917F0420  stw r11, 0x420(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1056 as u32), ctx.r[11].u32 ) };
	// 82EF1374: 817F0420  lwz r11, 0x420(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1056 as u32) ) } as u64;
	// 82EF1378: 917F03E8  stw r11, 0x3e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), ctx.r[11].u32 ) };
	// 82EF137C: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1380: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82EF1384: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF1388: 807F03E8  lwz r3, 0x3e8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82EF138C: 4BDB8625  bl 0x82ca99b0
	ctx.lr = 0x82EF1390;
	sub_82CA99B0(ctx, base);
	// 82EF1390: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1394: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1398: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF139C: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF13A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF13A4: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF13A8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF13AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF13B0: 4E800421  bctrl
	ctx.lr = 0x82EF13B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF13B4: 907F03F0  stw r3, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[3].u32 ) };
	// 82EF13B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF13BC: 917F03F4  stw r11, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[11].u32 ) };
	// 82EF13C0: 48000038  b 0x82ef13f8
	pc = 0x82EF13F8; continue 'dispatch;
	// 82EF13C4: 817F03F4  lwz r11, 0x3f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 82EF13C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF13CC: 917F03F4  stw r11, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[11].u32 ) };
	// 82EF13D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF13D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF13D8: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF13DC: 817F03F0  lwz r11, 0x3f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF13E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF13E4: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF13E8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF13EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF13F0: 4E800421  bctrl
	ctx.lr = 0x82EF13F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF13F4: 907F03F0  stw r3, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[3].u32 ) };
	// 82EF13F8: 817F03F0  lwz r11, 0x3f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF13FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1400: 419A0064  beq cr6, 0x82ef1464
	if ctx.cr[6].eq {
	pc = 0x82EF1464; continue 'dispatch;
	}
	// 82EF1404: 817F03F4  lwz r11, 0x3f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 82EF1408: 815F02D8  lwz r10, 0x2d8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF140C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EF1410: 40980054  bge cr6, 0x82ef1464
	if !ctx.cr[6].lt {
	pc = 0x82EF1464; continue 'dispatch;
	}
	// 82EF1414: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1418: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF141C: 388BC7D8  addi r4, r11, -0x3828
	ctx.r[4].s64 = ctx.r[11].s64 + -14376;
	// 82EF1420: 817F03F0  lwz r11, 0x3f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF1424: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1428: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF142C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1430: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1434: 4E800421  bctrl
	ctx.lr = 0x82EF1438;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1438: 907F03F8  stw r3, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[3].u32 ) };
	// 82EF143C: 817F03F8  lwz r11, 0x3f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 82EF1440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1444: 419A001C  beq cr6, 0x82ef1460
	if ctx.cr[6].eq {
	pc = 0x82EF1460; continue 'dispatch;
	}
	// 82EF1448: 817F03F4  lwz r11, 0x3f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 82EF144C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF1450: 815F03E8  lwz r10, 0x3e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82EF1454: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF1458: 807F03F8  lwz r3, 0x3f8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 82EF145C: 48003F9D  bl 0x82ef53f8
	ctx.lr = 0x82EF1460;
	sub_82EF53F8(ctx, base);
	// 82EF1460: 4BFFFF64  b 0x82ef13c4
	pc = 0x82EF13C4; continue 'dispatch;
	// 82EF1464: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF1468: 480044D1  bl 0x82ef5938
	ctx.lr = 0x82EF146C;
	sub_82EF5938(ctx, base);
	// 82EF146C: 907F0424  stw r3, 0x424(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), ctx.r[3].u32 ) };
	// 82EF1470: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EF1474: 811F02D8  lwz r8, 0x2d8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1478: 80FF03E8  lwz r7, 0x3e8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82EF147C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF1480: 38BF02E0  addi r5, r31, 0x2e0
	ctx.r[5].s64 = ctx.r[31].s64 + 736;
	// 82EF1484: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EF1488: 807F0424  lwz r3, 0x424(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) } as u64;
	// 82EF148C: 817F0424  lwz r11, 0x424(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) } as u64;
	// 82EF1490: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1494: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF1498: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF149C: 4E800421  bctrl
	ctx.lr = 0x82EF14A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF14A0: 987F03EC  stb r3, 0x3ec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[3].u8 ) };
	// 82EF14A4: 4800015C  b 0x82ef1600
	pc = 0x82EF1600; continue 'dispatch;
	// 82EF14A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF14AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF14B0: 388BC814  addi r4, r11, -0x37ec
	ctx.r[4].s64 = ctx.r[11].s64 + -14316;
	// 82EF14B4: 807F02CC  lwz r3, 0x2cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) } as u64;
	// 82EF14B8: 48003461  bl 0x82ef4918
	ctx.lr = 0x82EF14BC;
	sub_82EF4918(ctx, base);
	// 82EF14BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF14C0: 41820140  beq 0x82ef1600
	if ctx.cr[0].eq {
	pc = 0x82EF1600; continue 'dispatch;
	}
	// 82EF14C4: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF14C8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF14CC: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 82EF14D0: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82EF14D4: 4BDBF181  bl 0x82cb0654
	ctx.lr = 0x82EF14D8;
	sub_82CB0654(ctx, base);
	// 82EF14D8: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF14DC: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 82EF14E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF14E4: 917F0428  stw r11, 0x428(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), ctx.r[11].u32 ) };
	// 82EF14E8: 817F0428  lwz r11, 0x428(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1064 as u32) ) } as u64;
	// 82EF14EC: 917F03FC  stw r11, 0x3fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1020 as u32), ctx.r[11].u32 ) };
	// 82EF14F0: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF14F4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82EF14F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF14FC: 807F03FC  lwz r3, 0x3fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 82EF1500: 4BDB84B1  bl 0x82ca99b0
	ctx.lr = 0x82EF1504;
	sub_82CA99B0(ctx, base);
	// 82EF1504: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1508: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF150C: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF1510: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1514: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1518: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF151C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF1520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1524: 4E800421  bctrl
	ctx.lr = 0x82EF1528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1528: 907F0404  stw r3, 0x404(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), ctx.r[3].u32 ) };
	// 82EF152C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1530: 917F0408  stw r11, 0x408(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), ctx.r[11].u32 ) };
	// 82EF1534: 48000038  b 0x82ef156c
	pc = 0x82EF156C; continue 'dispatch;
	// 82EF1538: 817F0408  lwz r11, 0x408(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82EF153C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF1540: 917F0408  stw r11, 0x408(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), ctx.r[11].u32 ) };
	// 82EF1544: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1548: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF154C: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF1550: 817F0404  lwz r11, 0x404(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF1554: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1558: 807F0404  lwz r3, 0x404(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF155C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF1560: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1564: 4E800421  bctrl
	ctx.lr = 0x82EF1568;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1568: 907F0404  stw r3, 0x404(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), ctx.r[3].u32 ) };
	// 82EF156C: 817F0404  lwz r11, 0x404(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF1570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1574: 419A004C  beq cr6, 0x82ef15c0
	if ctx.cr[6].eq {
	pc = 0x82EF15C0; continue 'dispatch;
	}
	// 82EF1578: 817F0408  lwz r11, 0x408(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82EF157C: 815F02D8  lwz r10, 0x2d8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1580: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EF1584: 4098003C  bge cr6, 0x82ef15c0
	if !ctx.cr[6].lt {
	pc = 0x82EF15C0; continue 'dispatch;
	}
	// 82EF1588: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF158C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1590: 388BC7D8  addi r4, r11, -0x3828
	ctx.r[4].s64 = ctx.r[11].s64 + -14376;
	// 82EF1594: 817F0404  lwz r11, 0x404(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF1598: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF159C: 807F0404  lwz r3, 0x404(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF15A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF15A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF15A8: 4E800421  bctrl
	ctx.lr = 0x82EF15AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF15AC: 817F0408  lwz r11, 0x408(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82EF15B0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF15B4: 815F03FC  lwz r10, 0x3fc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 82EF15B8: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82EF15BC: 4BFFFF7C  b 0x82ef1538
	pc = 0x82EF1538; continue 'dispatch;
	// 82EF15C0: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF15C4: 48004375  bl 0x82ef5938
	ctx.lr = 0x82EF15C8;
	sub_82EF5938(ctx, base);
	// 82EF15C8: 907F042C  stw r3, 0x42c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), ctx.r[3].u32 ) };
	// 82EF15CC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EF15D0: 811F02D8  lwz r8, 0x2d8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF15D4: 80FF03FC  lwz r7, 0x3fc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 82EF15D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF15DC: 38BF02E0  addi r5, r31, 0x2e0
	ctx.r[5].s64 = ctx.r[31].s64 + 736;
	// 82EF15E0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EF15E4: 807F042C  lwz r3, 0x42c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1068 as u32) ) } as u64;
	// 82EF15E8: 817F042C  lwz r11, 0x42c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1068 as u32) ) } as u64;
	// 82EF15EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF15F0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF15F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF15F8: 4E800421  bctrl
	ctx.lr = 0x82EF15FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF15FC: 987F0400  stb r3, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[3].u8 ) };
	// 82EF1600: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1604: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1608: 388BC7F8  addi r4, r11, -0x3808
	ctx.r[4].s64 = ctx.r[11].s64 + -14344;
	// 82EF160C: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1610: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1614: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1618: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF161C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1620: 4E800421  bctrl
	ctx.lr = 0x82EF1624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1624: 907F02C8  stw r3, 0x2c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(712 as u32), ctx.r[3].u32 ) };
	// 82EF1628: 817F02C4  lwz r11, 0x2c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(708 as u32) ) } as u64;
	// 82EF162C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF1630: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 82EF1634: 4BFFFBF8  b 0x82ef122c
	pc = 0x82EF122C; continue 'dispatch;
	// 82EF1638: 383F0440  addi r1, r31, 0x440
	ctx.r[1].s64 = ctx.r[31].s64 + 1088;
	// 82EF163C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF1648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1650 size=508
    let mut pc: u32 = 0x82EF1650;
    'dispatch: loop {
        match pc {
            0x82EF1650 => {
    //   block [0x82EF1650..0x82EF184C)
	// 82EF1650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF165C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF1660: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1664: 90610134  stw r3, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[3].u32 ) };
	// 82EF1668: 9081013C  stw r4, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[4].u32 ) };
	// 82EF166C: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF1670: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF1674: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF1678: 40820020  bne 0x82ef1698
	if !ctx.cr[0].eq {
	pc = 0x82EF1698; continue 'dispatch;
	}
	// 82EF167C: 8061013C  lwz r3, 0x13c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF1680: 48000211  bl 0x82ef1890
	ctx.lr = 0x82EF1684;
	sub_82EF1890(ctx, base);
	// 82EF1684: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF1688: 40820010  bne 0x82ef1698
	if !ctx.cr[0].eq {
	pc = 0x82EF1698; continue 'dispatch;
	}
	// 82EF168C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EF1690: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF1694: 48000B9D  bl 0x82ef2230
	ctx.lr = 0x82EF1698;
	sub_82EF2230(ctx, base);
	// 82EF1698: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF169C: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF16A0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF16A4: 41820074  beq 0x82ef1718
	if ctx.cr[0].eq {
	pc = 0x82EF1718; continue 'dispatch;
	}
	// 82EF16A8: 8061013C  lwz r3, 0x13c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF16AC: 480001D5  bl 0x82ef1880
	ctx.lr = 0x82EF16B0;
	sub_82EF1880(ctx, base);
	// 82EF16B0: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82EF16B4: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF16B8: 41820060  beq 0x82ef1718
	if ctx.cr[0].eq {
	pc = 0x82EF1718; continue 'dispatch;
	}
	// 82EF16BC: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF16C0: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF16C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF16C8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF16CC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82EF16D0: 4B32E439  bl 0x8221fb08
	ctx.lr = 0x82EF16D4;
	sub_8221FB08(ctx, base);
	// 82EF16D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF16D8: C82B0D38  lfd f1, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82EF16DC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82EF16E0: 48004109  bl 0x82ef57e8
	ctx.lr = 0x82EF16E4;
	sub_82EF57E8(ctx, base);
	// 82EF16E4: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF16E8: 48004251  bl 0x82ef5938
	ctx.lr = 0x82EF16EC;
	sub_82EF5938(ctx, base);
	// 82EF16EC: 906100E0  stw r3, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[3].u32 ) };
	// 82EF16F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF16F4: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 82EF16F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF16FC: 388BC8B8  addi r4, r11, -0x3748
	ctx.r[4].s64 = ctx.r[11].s64 + -14152;
	// 82EF1700: 806100E0  lwz r3, 0xe0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 82EF1704: 816100E0  lwz r11, 0xe0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 82EF1708: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF170C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF1710: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1714: 4E800421  bctrl
	ctx.lr = 0x82EF1718;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1718: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF171C: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF1720: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82EF1724: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF1728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF172C: 4B32E3DD  bl 0x8221fb08
	ctx.lr = 0x82EF1730;
	sub_8221FB08(ctx, base);
	// 82EF1730: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF1734: C82B0D38  lfd f1, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82EF1738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF173C: 480040AD  bl 0x82ef57e8
	ctx.lr = 0x82EF1740;
	sub_82EF57E8(ctx, base);
	// 82EF1740: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF1744: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82EF1748: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF174C: F96100E8  std r11, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 82EF1750: C80100E8  lfd f0, 0xe8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 82EF1754: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1758: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF175C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EF1760: 48004089  bl 0x82ef57e8
	ctx.lr = 0x82EF1764;
	sub_82EF57E8(ctx, base);
	// 82EF1764: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF1768: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82EF176C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1770: F96100F0  std r11, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u64 ) };
	// 82EF1774: C80100F0  lfd f0, 0xf0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	// 82EF1778: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF177C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1780: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 82EF1784: 48004065  bl 0x82ef57e8
	ctx.lr = 0x82EF1788;
	sub_82EF57E8(ctx, base);
	// 82EF1788: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF178C: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EF1790: 480000C1  bl 0x82ef1850
	ctx.lr = 0x82EF1794;
	sub_82EF1850(ctx, base);
	// 82EF1794: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1798: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82EF179C: 4800404D  bl 0x82ef57e8
	ctx.lr = 0x82EF17A0;
	sub_82EF57E8(ctx, base);
	// 82EF17A0: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF17A4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EF17A8: 480000B9  bl 0x82ef1860
	ctx.lr = 0x82EF17AC;
	sub_82EF1860(ctx, base);
	// 82EF17AC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF17B0: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 82EF17B4: 48004035  bl 0x82ef57e8
	ctx.lr = 0x82EF17B8;
	sub_82EF57E8(ctx, base);
	// 82EF17B8: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF17BC: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82EF17C0: 48000091  bl 0x82ef1850
	ctx.lr = 0x82EF17C4;
	sub_82EF1850(ctx, base);
	// 82EF17C4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF17C8: 386B0050  addi r3, r11, 0x50
	ctx.r[3].s64 = ctx.r[11].s64 + 80;
	// 82EF17CC: 4800401D  bl 0x82ef57e8
	ctx.lr = 0x82EF17D0;
	sub_82EF57E8(ctx, base);
	// 82EF17D0: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF17D4: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82EF17D8: 48000089  bl 0x82ef1860
	ctx.lr = 0x82EF17DC;
	sub_82EF1860(ctx, base);
	// 82EF17DC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF17E0: 386B0060  addi r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 + 96;
	// 82EF17E4: 48004005  bl 0x82ef57e8
	ctx.lr = 0x82EF17E8;
	sub_82EF57E8(ctx, base);
	// 82EF17E8: 8061013C  lwz r3, 0x13c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF17EC: 48000085  bl 0x82ef1870
	ctx.lr = 0x82EF17F0;
	sub_82EF1870(ctx, base);
	// 82EF17F0: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82EF17F4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF17F8: F96100F8  std r11, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u64 ) };
	// 82EF17FC: C80100F8  lfd f0, 0xf8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 82EF1800: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1804: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1808: 386B0070  addi r3, r11, 0x70
	ctx.r[3].s64 = ctx.r[11].s64 + 112;
	// 82EF180C: 48003FDD  bl 0x82ef57e8
	ctx.lr = 0x82EF1810;
	sub_82EF57E8(ctx, base);
	// 82EF1810: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82EF1814: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1818: 3BCBC8A4  addi r30, r11, -0x375c
	ctx.r[30].s64 = ctx.r[11].s64 + -14172;
	// 82EF181C: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF1820: 48004119  bl 0x82ef5938
	ctx.lr = 0x82EF1824;
	sub_82EF5938(ctx, base);
	// 82EF1824: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF1828: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF182C: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 82EF1830: 48004009  bl 0x82ef5838
	ctx.lr = 0x82EF1834;
	sub_82EF5838(ctx, base);
	// 82EF1834: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EF1838: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF183C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1840: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF1844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF1848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EF1850 size=16
    let mut pc: u32 = 0x82EF1850;
    'dispatch: loop {
        match pc {
            0x82EF1850 => {
    //   block [0x82EF1850..0x82EF1860)
	// 82EF1850: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1854: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1858: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF185C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EF1860 size=16
    let mut pc: u32 = 0x82EF1860;
    'dispatch: loop {
        match pc {
            0x82EF1860 => {
    //   block [0x82EF1860..0x82EF1870)
	// 82EF1860: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1864: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1868: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF186C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF1870 size=16
    let mut pc: u32 = 0x82EF1870;
    'dispatch: loop {
        match pc {
            0x82EF1870 => {
    //   block [0x82EF1870..0x82EF1880)
	// 82EF1870: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1874: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1878: A06B0000  lhz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF187C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF1880 size=16
    let mut pc: u32 = 0x82EF1880;
    'dispatch: loop {
        match pc {
            0x82EF1880 => {
    //   block [0x82EF1880..0x82EF1890)
	// 82EF1880: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1884: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1888: A06B0024  lhz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EF188C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF1890 size=16
    let mut pc: u32 = 0x82EF1890;
    'dispatch: loop {
        match pc {
            0x82EF1890 => {
    //   block [0x82EF1890..0x82EF18A0)
	// 82EF1890: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1894: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1898: 886B003C  lbz r3, 0x3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EF189C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF18A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF18A0 size=1144
    let mut pc: u32 = 0x82EF18A0;
    'dispatch: loop {
        match pc {
            0x82EF18A0 => {
    //   block [0x82EF18A0..0x82EF1D18)
	// 82EF18A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF18A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF18A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF18AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF18B0: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF18B4: 90610224  stw r3, 0x224(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(548 as u32), ctx.r[3].u32 ) };
	// 82EF18B8: 9081022C  stw r4, 0x22c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(556 as u32), ctx.r[4].u32 ) };
	// 82EF18BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF18C0: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82EF18C4: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF18C8: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF18CC: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 82EF18D0: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF18D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF18D8: 4B32E231  bl 0x8221fb08
	ctx.lr = 0x82EF18DC;
	sub_8221FB08(ctx, base);
	// 82EF18DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF18E0: C82B0D38  lfd f1, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82EF18E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF18E8: 48003F01  bl 0x82ef57e8
	ctx.lr = 0x82EF18EC;
	sub_82EF57E8(ctx, base);
	// 82EF18EC: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF18F0: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF18F4: 4BFF6C45  bl 0x82ee8538
	ctx.lr = 0x82EF18F8;
	sub_82EE8538(ctx, base);
	// 82EF18F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF18FC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1900: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EF1904: 48003F0D  bl 0x82ef5810
	ctx.lr = 0x82EF1908;
	sub_82EF5810(ctx, base);
	// 82EF1908: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF190C: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF1910: 4BFF6D21  bl 0x82ee8630
	ctx.lr = 0x82EF1914;
	sub_82EE8630(ctx, base);
	// 82EF1914: F8610160  std r3, 0x160(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[3].u64 ) };
	// 82EF1918: C8010160  lfd f0, 0x160(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 82EF191C: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1920: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1924: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 82EF1928: 48003EC1  bl 0x82ef57e8
	ctx.lr = 0x82EF192C;
	sub_82EF57E8(ctx, base);
	// 82EF192C: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1930: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF1934: 4BFF6ECD  bl 0x82ee8800
	ctx.lr = 0x82EF1938;
	sub_82EE8800(ctx, base);
	// 82EF1938: F8610168  std r3, 0x168(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[3].u64 ) };
	// 82EF193C: C8010168  lfd f0, 0x168(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) };
	// 82EF1940: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1944: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1948: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82EF194C: 48003E9D  bl 0x82ef57e8
	ctx.lr = 0x82EF1950;
	sub_82EF57E8(ctx, base);
	// 82EF1950: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1954: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF1958: 4BFF6D49  bl 0x82ee86a0
	ctx.lr = 0x82EF195C;
	sub_82EE86A0(ctx, base);
	// 82EF195C: F8610170  std r3, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[3].u64 ) };
	// 82EF1960: C8010170  lfd f0, 0x170(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 82EF1964: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1968: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF196C: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 82EF1970: 48003E79  bl 0x82ef57e8
	ctx.lr = 0x82EF1974;
	sub_82EF57E8(ctx, base);
	// 82EF1974: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1978: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF197C: 4800039D  bl 0x82ef1d18
	ctx.lr = 0x82EF1980;
	sub_82EF1D18(ctx, base);
	// 82EF1980: F8610178  std r3, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[3].u64 ) };
	// 82EF1984: C8010178  lfd f0, 0x178(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 82EF1988: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF198C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1990: 386B0050  addi r3, r11, 0x50
	ctx.r[3].s64 = ctx.r[11].s64 + 80;
	// 82EF1994: 48003E55  bl 0x82ef57e8
	ctx.lr = 0x82EF1998;
	sub_82EF57E8(ctx, base);
	// 82EF1998: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF199C: 808B0050  lwz r4, 0x50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF19A0: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF19A4: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF19A8: 4BFF6DC9  bl 0x82ee8770
	ctx.lr = 0x82EF19AC;
	sub_82EE8770(ctx, base);
	// 82EF19AC: F8610180  std r3, 0x180(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[3].u64 ) };
	// 82EF19B0: C8010180  lfd f0, 0x180(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) };
	// 82EF19B4: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF19B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF19BC: 386B0060  addi r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 + 96;
	// 82EF19C0: 48003E29  bl 0x82ef57e8
	ctx.lr = 0x82EF19C4;
	sub_82EF57E8(ctx, base);
	// 82EF19C4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82EF19C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF19CC: 3BCBC978  addi r30, r11, -0x3688
	ctx.r[30].s64 = ctx.r[11].s64 + -13960;
	// 82EF19D0: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF19D4: 48003F65  bl 0x82ef5938
	ctx.lr = 0x82EF19D8;
	sub_82EF5938(ctx, base);
	// 82EF19D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF19DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF19E0: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 82EF19E4: 48003E55  bl 0x82ef5838
	ctx.lr = 0x82EF19E8;
	sub_82EF5838(ctx, base);
	// 82EF19E8: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF19EC: 816B0478  lwz r11, 0x478(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1144 as u32) ) } as u64;
	// 82EF19F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF19F4: 419A0014  beq cr6, 0x82ef1a08
	if ctx.cr[6].eq {
	pc = 0x82EF1A08; continue 'dispatch;
	}
	// 82EF19F8: 8081022C  lwz r4, 0x22c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(556 as u32) ) } as u64;
	// 82EF19FC: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1A00: 48000B09  bl 0x82ef2508
	ctx.lr = 0x82EF1A04;
	sub_82EF2508(ctx, base);
	// 82EF1A04: 906100F0  stw r3, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	// 82EF1A08: 816100F0  lwz r11, 0xf0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EF1A0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF1A10: 4098000C  bge cr6, 0x82ef1a1c
	if !ctx.cr[6].lt {
	pc = 0x82EF1A1C; continue 'dispatch;
	}
	// 82EF1A14: 806100F0  lwz r3, 0xf0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EF1A18: 480002E8  b 0x82ef1d00
	pc = 0x82EF1D00; continue 'dispatch;
	// 82EF1A1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1A20: 916100F4  stw r11, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82EF1A24: 48000010  b 0x82ef1a34
	pc = 0x82EF1A34; continue 'dispatch;
	// 82EF1A28: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EF1A2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF1A30: 916100F4  stw r11, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82EF1A34: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EF1A38: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82EF1A3C: 40980078  bge cr6, 0x82ef1ab4
	if !ctx.cr[6].lt {
	pc = 0x82EF1AB4; continue 'dispatch;
	}
	// 82EF1A40: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF1A44: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF1A48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF1A4C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF1A50: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82EF1A54: 4B32E0B5  bl 0x8221fb08
	ctx.lr = 0x82EF1A58;
	sub_8221FB08(ctx, base);
	// 82EF1A58: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EF1A5C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1A60: F9610188  std r11, 0x188(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[11].u64 ) };
	// 82EF1A64: C8010188  lfd f0, 0x188(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 82EF1A68: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1A6C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82EF1A70: 48003D79  bl 0x82ef57e8
	ctx.lr = 0x82EF1A74;
	sub_82EF57E8(ctx, base);
	// 82EF1A74: 808100F4  lwz r4, 0xf4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EF1A78: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1A7C: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF1A80: 4BFF6E71  bl 0x82ee88f0
	ctx.lr = 0x82EF1A84;
	sub_82EE88F0(ctx, base);
	// 82EF1A84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF1A88: 41820028  beq 0x82ef1ab0
	if ctx.cr[0].eq {
	pc = 0x82EF1AB0; continue 'dispatch;
	}
	// 82EF1A8C: 3BE10100  addi r31, r1, 0x100
	ctx.r[31].s64 = ctx.r[1].s64 + 256;
	// 82EF1A90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1A94: 3BCBC95C  addi r30, r11, -0x36a4
	ctx.r[30].s64 = ctx.r[11].s64 + -13988;
	// 82EF1A98: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1A9C: 48003E9D  bl 0x82ef5938
	ctx.lr = 0x82EF1AA0;
	sub_82EF5938(ctx, base);
	// 82EF1AA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF1AA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF1AA8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1AAC: 48003D8D  bl 0x82ef5838
	ctx.lr = 0x82EF1AB0;
	sub_82EF5838(ctx, base);
	// 82EF1AB0: 4BFFFF78  b 0x82ef1a28
	pc = 0x82EF1A28; continue 'dispatch;
	// 82EF1AB4: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AB8: 816B0474  lwz r11, 0x474(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EF1ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1AC0: 419A0024  beq cr6, 0x82ef1ae4
	if ctx.cr[6].eq {
	pc = 0x82EF1AE4; continue 'dispatch;
	}
	// 82EF1AC4: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AC8: 808B0484  lwz r4, 0x484(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1156 as u32) ) } as u64;
	// 82EF1ACC: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AD0: 4BFFF0C9  bl 0x82ef0b98
	ctx.lr = 0x82EF1AD4;
	sub_82EF0B98(ctx, base);
	// 82EF1AD4: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AD8: 808B0474  lwz r4, 0x474(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EF1ADC: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AE0: 4BFFF0B9  bl 0x82ef0b98
	ctx.lr = 0x82EF1AE4;
	sub_82EF0B98(ctx, base);
	// 82EF1AE4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EF1AE8: 483C7ECD  bl 0x832b99b4
	ctx.lr = 0x82EF1AEC;
	// extern call 0x832B99B4  crate::xboxkrnl::XGetVideoMode
	crate::xboxkrnl::XGetVideoMode(ctx, base);
	// 82EF1AEC: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EF1AF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF1AF4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF1AF8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EF1AFC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1B00: F9610190  std r11, 0x190(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[11].u64 ) };
	// 82EF1B04: C8010190  lfd f0, 0x190(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) };
	// 82EF1B08: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1B0C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82EF1B10: 48003C89  bl 0x82ef5798
	ctx.lr = 0x82EF1B14;
	sub_82EF5798(ctx, base);
	// 82EF1B14: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1B18: 48003E21  bl 0x82ef5938
	ctx.lr = 0x82EF1B1C;
	sub_82EF5938(ctx, base);
	// 82EF1B1C: 90610198  stw r3, 0x198(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[3].u32 ) };
	// 82EF1B20: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1B24: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 82EF1B28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1B2C: 388BC948  addi r4, r11, -0x36b8
	ctx.r[4].s64 = ctx.r[11].s64 + -14008;
	// 82EF1B30: 80610198  lwz r3, 0x198(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EF1B34: 81610198  lwz r11, 0x198(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EF1B38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1B3C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1B40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1B44: 4E800421  bctrl
	ctx.lr = 0x82EF1B48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1B48: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1B4C: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF1B50: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1B54: F96101A0  std r11, 0x1a0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[11].u64 ) };
	// 82EF1B58: C80101A0  lfd f0, 0x1a0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) };
	// 82EF1B5C: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1B60: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82EF1B64: 48003C35  bl 0x82ef5798
	ctx.lr = 0x82EF1B68;
	sub_82EF5798(ctx, base);
	// 82EF1B68: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1B6C: 48003DCD  bl 0x82ef5938
	ctx.lr = 0x82EF1B70;
	sub_82EF5938(ctx, base);
	// 82EF1B70: 906101A8  stw r3, 0x1a8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), ctx.r[3].u32 ) };
	// 82EF1B74: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1B78: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 82EF1B7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1B80: 388BC934  addi r4, r11, -0x36cc
	ctx.r[4].s64 = ctx.r[11].s64 + -14028;
	// 82EF1B84: 806101A8  lwz r3, 0x1a8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EF1B88: 816101A8  lwz r11, 0x1a8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EF1B8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1B90: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1B94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1B98: 4E800421  bctrl
	ctx.lr = 0x82EF1B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1B9C: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1BA0: 896B0469  lbz r11, 0x469(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1129 as u32) ) } as u64;
	// 82EF1BA4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1BA8: F96101B0  std r11, 0x1b0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), ctx.r[11].u64 ) };
	// 82EF1BAC: C80101B0  lfd f0, 0x1b0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(432 as u32) ) };
	// 82EF1BB0: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1BB4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82EF1BB8: 48003BE1  bl 0x82ef5798
	ctx.lr = 0x82EF1BBC;
	sub_82EF5798(ctx, base);
	// 82EF1BBC: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1BC0: 48003D79  bl 0x82ef5938
	ctx.lr = 0x82EF1BC4;
	sub_82EF5938(ctx, base);
	// 82EF1BC4: 906101B8  stw r3, 0x1b8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[3].u32 ) };
	// 82EF1BC8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1BCC: 38A10130  addi r5, r1, 0x130
	ctx.r[5].s64 = ctx.r[1].s64 + 304;
	// 82EF1BD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1BD4: 388BC91C  addi r4, r11, -0x36e4
	ctx.r[4].s64 = ctx.r[11].s64 + -14052;
	// 82EF1BD8: 806101B8  lwz r3, 0x1b8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EF1BDC: 816101B8  lwz r11, 0x1b8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EF1BE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1BE4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1BE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1BEC: 4E800421  bctrl
	ctx.lr = 0x82EF1BF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1BF0: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1BF4: C00B048C  lfs f0, 0x48c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF1BF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF1BFC: C1AB0A54  lfs f13, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EF1C00: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EF1C04: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EF1C08: D80101C0  stfd f0, 0x1c0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.f[0].u64 ) };
	// 82EF1C0C: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF1C10: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1C14: F96101C8  std r11, 0x1c8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[11].u64 ) };
	// 82EF1C18: C80101C8  lfd f0, 0x1c8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(456 as u32) ) };
	// 82EF1C1C: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1C20: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82EF1C24: 48003B75  bl 0x82ef5798
	ctx.lr = 0x82EF1C28;
	sub_82EF5798(ctx, base);
	// 82EF1C28: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1C2C: 48003D0D  bl 0x82ef5938
	ctx.lr = 0x82EF1C30;
	sub_82EF5938(ctx, base);
	// 82EF1C30: 906101D0  stw r3, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[3].u32 ) };
	// 82EF1C34: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1C38: 38A10140  addi r5, r1, 0x140
	ctx.r[5].s64 = ctx.r[1].s64 + 320;
	// 82EF1C3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1C40: 388BC908  addi r4, r11, -0x36f8
	ctx.r[4].s64 = ctx.r[11].s64 + -14072;
	// 82EF1C44: 806101D0  lwz r3, 0x1d0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EF1C48: 816101D0  lwz r11, 0x1d0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EF1C4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1C50: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1C54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1C58: 4E800421  bctrl
	ctx.lr = 0x82EF1C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1C5C: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1C60: C00B0490  lfs f0, 0x490(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF1C64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF1C68: C1AB0A54  lfs f13, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EF1C6C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EF1C70: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EF1C74: D80101D8  stfd f0, 0x1d8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.f[0].u64 ) };
	// 82EF1C78: 816101DC  lwz r11, 0x1dc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(476 as u32) ) } as u64;
	// 82EF1C7C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1C80: F96101E0  std r11, 0x1e0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u64 ) };
	// 82EF1C84: C80101E0  lfd f0, 0x1e0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(480 as u32) ) };
	// 82EF1C88: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1C8C: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82EF1C90: 48003B09  bl 0x82ef5798
	ctx.lr = 0x82EF1C94;
	sub_82EF5798(ctx, base);
	// 82EF1C94: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1C98: 48003CA1  bl 0x82ef5938
	ctx.lr = 0x82EF1C9C;
	sub_82EF5938(ctx, base);
	// 82EF1C9C: 906101E8  stw r3, 0x1e8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), ctx.r[3].u32 ) };
	// 82EF1CA0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1CA4: 38A10150  addi r5, r1, 0x150
	ctx.r[5].s64 = ctx.r[1].s64 + 336;
	// 82EF1CA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1CAC: 388BC8F4  addi r4, r11, -0x370c
	ctx.r[4].s64 = ctx.r[11].s64 + -14092;
	// 82EF1CB0: 806101E8  lwz r3, 0x1e8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EF1CB4: 816101E8  lwz r11, 0x1e8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EF1CB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1CBC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1CC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1CC4: 4E800421  bctrl
	ctx.lr = 0x82EF1CC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1CC8: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1CCC: 48003C6D  bl 0x82ef5938
	ctx.lr = 0x82EF1CD0;
	sub_82EF5938(ctx, base);
	// 82EF1CD0: 906101EC  stw r3, 0x1ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), ctx.r[3].u32 ) };
	// 82EF1CD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF1CD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1CDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1CE0: 388BC8E8  addi r4, r11, -0x3718
	ctx.r[4].s64 = ctx.r[11].s64 + -14104;
	// 82EF1CE4: 806101EC  lwz r3, 0x1ec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EF1CE8: 816101EC  lwz r11, 0x1ec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EF1CEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1CF0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF1CF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1CF8: 4E800421  bctrl
	ctx.lr = 0x82EF1CFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1CFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF1D00: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 82EF1D04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1D08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1D0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF1D10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF1D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1D18 size=40
    let mut pc: u32 = 0x82EF1D18;
    'dispatch: loop {
        match pc {
            0x82EF1D18 => {
    //   block [0x82EF1D18..0x82EF1D40)
	// 82EF1D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1D20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1D24: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF1D28: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF1D2C: 4BFF69E5  bl 0x82ee8710
	ctx.lr = 0x82EF1D30;
	sub_82EE8710(ctx, base);
	// 82EF1D30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF1D34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1D38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1D40 size=368
    let mut pc: u32 = 0x82EF1D40;
    'dispatch: loop {
        match pc {
            0x82EF1D40 => {
    //   block [0x82EF1D40..0x82EF1EB0)
	// 82EF1D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF1D4C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1D50: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF1D54: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EF1D58: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EF1D5C: 90C100AC  stw r6, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[6].u32 ) };
	// 82EF1D60: 90E100B4  stw r7, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[7].u32 ) };
	// 82EF1D64: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1D68: 48003A19  bl 0x82ef5780
	ctx.lr = 0x82EF1D6C;
	sub_82EF5780(ctx, base);
	// 82EF1D6C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF1D70: 48003BC9  bl 0x82ef5938
	ctx.lr = 0x82EF1D74;
	sub_82EF5938(ctx, base);
	// 82EF1D74: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF1D78: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF1D7C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF1D80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1D84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF1D88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1D8C: 4E800421  bctrl
	ctx.lr = 0x82EF1D90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1D90: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EF1D94: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF1D98: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF1D9C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF1DA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1DA4: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF1DA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1DAC: 4E800421  bctrl
	ctx.lr = 0x82EF1DB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1DB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF1DB4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DB8: 480020E9  bl 0x82ef3ea0
	ctx.lr = 0x82EF1DBC;
	sub_82EF3EA0(ctx, base);
	// 82EF1DBC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DC0: 4BFFB401  bl 0x82eed1c0
	ctx.lr = 0x82EF1DC4;
	sub_82EED1C0(ctx, base);
	// 82EF1DC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF1DC8: 40820010  bne 0x82ef1dd8
	if !ctx.cr[0].eq {
	pc = 0x82EF1DD8; continue 'dispatch;
	}
	// 82EF1DCC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DD0: 48002091  bl 0x82ef3e60
	ctx.lr = 0x82EF1DD4;
	sub_82EF3E60(ctx, base);
	// 82EF1DD4: 480000C8  b 0x82ef1e9c
	pc = 0x82EF1E9C; continue 'dispatch;
	// 82EF1DD8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DDC: 4BFFB3E5  bl 0x82eed1c0
	ctx.lr = 0x82EF1DE0;
	sub_82EED1C0(ctx, base);
	// 82EF1DE0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF1DE4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF1DE8: 480000C9  bl 0x82ef1eb0
	ctx.lr = 0x82EF1DEC;
	sub_82EF1EB0(ctx, base);
	// 82EF1DEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF1DF0: 40820010  bne 0x82ef1e00
	if !ctx.cr[0].eq {
	pc = 0x82EF1E00; continue 'dispatch;
	}
	// 82EF1DF4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DF8: 48002069  bl 0x82ef3e60
	ctx.lr = 0x82EF1DFC;
	sub_82EF3E60(ctx, base);
	// 82EF1DFC: 480000A0  b 0x82ef1e9c
	pc = 0x82EF1E9C; continue 'dispatch;
	// 82EF1E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1E04: 4800397D  bl 0x82ef5780
	ctx.lr = 0x82EF1E08;
	sub_82EF5780(ctx, base);
	// 82EF1E08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF1E0C: 480000A5  bl 0x82ef1eb0
	ctx.lr = 0x82EF1E10;
	sub_82EF1EB0(ctx, base);
	// 82EF1E10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF1E14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1E18: 48002139  bl 0x82ef3f50
	ctx.lr = 0x82EF1E1C;
	sub_82EF3F50(ctx, base);
	// 82EF1E1C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF1E20: 806B0470  lwz r3, 0x470(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1136 as u32) ) } as u64;
	// 82EF1E24: 48003AD5  bl 0x82ef58f8
	ctx.lr = 0x82EF1E28;
	sub_82EF58F8(ctx, base);
	// 82EF1E28: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF1E2C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF1E30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1E34: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF1E38: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF1E3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1E40: 4E800421  bctrl
	ctx.lr = 0x82EF1E44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1E44: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EF1E48: 80C100B4  lwz r6, 0xb4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EF1E4C: 80A100AC  lwz r5, 0xac(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF1E50: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF1E54: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF1E58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1E5C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF1E60: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1E64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1E68: 4E800421  bctrl
	ctx.lr = 0x82EF1E6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1E6C: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF1E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1E74: 4BFFB34D  bl 0x82eed1c0
	ctx.lr = 0x82EF1E78;
	sub_82EED1C0(ctx, base);
	// 82EF1E78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF1E7C: 4800A71D  bl 0x82efc598
	ctx.lr = 0x82EF1E80;
	sub_82EFC598(ctx, base);
	// 82EF1E80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF1E84: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF1E88: 4BFFBCA9  bl 0x82eedb30
	ctx.lr = 0x82EF1E8C;
	sub_82EEDB30(ctx, base);
	// 82EF1E8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1E90: 48002081  bl 0x82ef3f10
	ctx.lr = 0x82EF1E94;
	sub_82EF3F10(ctx, base);
	// 82EF1E94: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1E98: 48001FC9  bl 0x82ef3e60
	ctx.lr = 0x82EF1E9C;
	sub_82EF3E60(ctx, base);
	// 82EF1E9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF1EA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1EA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1EA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF1EAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1EB0 size=44
    let mut pc: u32 = 0x82EF1EB0;
    'dispatch: loop {
        match pc {
            0x82EF1EB0 => {
    //   block [0x82EF1EB0..0x82EF1EDC)
	// 82EF1EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1EB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1EBC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF1EC0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF1EC4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EF1EC8: 4BFFB2F9  bl 0x82eed1c0
	ctx.lr = 0x82EF1ECC;
	sub_82EED1C0(ctx, base);
	// 82EF1ECC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF1ED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1ED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1EE0 size=416
    let mut pc: u32 = 0x82EF1EE0;
    'dispatch: loop {
        match pc {
            0x82EF1EE0 => {
    //   block [0x82EF1EE0..0x82EF2080)
	// 82EF1EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1EE8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1EEC: 90610174  stw r3, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[3].u32 ) };
	// 82EF1EF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1EF4: 38EBCAAC  addi r7, r11, -0x3554
	ctx.r[7].s64 = ctx.r[11].s64 + -13652;
	// 82EF1EF8: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1EFC: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF1F00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F04: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF1F08: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF1F0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1F10: 4BFF9139  bl 0x82eeb048
	ctx.lr = 0x82EF1F14;
	sub_82EEB048(ctx, base);
	// 82EF1F14: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF1F18: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF1F1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1F20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F24: 388BCA84  addi r4, r11, -0x357c
	ctx.r[4].s64 = ctx.r[11].s64 + -13692;
	// 82EF1F28: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1F2C: 4BFFFE15  bl 0x82ef1d40
	ctx.lr = 0x82EF1F30;
	sub_82EF1D40(ctx, base);
	// 82EF1F30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F34: 38EBCA6C  addi r7, r11, -0x3594
	ctx.r[7].s64 = ctx.r[11].s64 + -13716;
	// 82EF1F38: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1F3C: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF1F40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F44: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF1F48: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF1F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1F50: 4BFF90F9  bl 0x82eeb048
	ctx.lr = 0x82EF1F54;
	sub_82EEB048(ctx, base);
	// 82EF1F54: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF1F58: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF1F5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1F60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F64: 388BCA50  addi r4, r11, -0x35b0
	ctx.r[4].s64 = ctx.r[11].s64 + -13744;
	// 82EF1F68: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1F6C: 4BFFFDD5  bl 0x82ef1d40
	ctx.lr = 0x82EF1F70;
	sub_82EF1D40(ctx, base);
	// 82EF1F70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F74: 38EBCA34  addi r7, r11, -0x35cc
	ctx.r[7].s64 = ctx.r[11].s64 + -13772;
	// 82EF1F78: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1F7C: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF1F80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F84: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF1F88: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF1F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1F90: 4BFF90B9  bl 0x82eeb048
	ctx.lr = 0x82EF1F94;
	sub_82EEB048(ctx, base);
	// 82EF1F94: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF1F98: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF1F9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1FA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FA4: 388BCA1C  addi r4, r11, -0x35e4
	ctx.r[4].s64 = ctx.r[11].s64 + -13796;
	// 82EF1FA8: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1FAC: 4BFFFD95  bl 0x82ef1d40
	ctx.lr = 0x82EF1FB0;
	sub_82EF1D40(ctx, base);
	// 82EF1FB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FB4: 38EBC9F4  addi r7, r11, -0x360c
	ctx.r[7].s64 = ctx.r[11].s64 + -13836;
	// 82EF1FB8: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1FBC: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF1FC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FC4: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF1FC8: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF1FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1FD0: 4BFF9079  bl 0x82eeb048
	ctx.lr = 0x82EF1FD4;
	sub_82EEB048(ctx, base);
	// 82EF1FD4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF1FD8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF1FDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1FE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FE4: 388BC9D0  addi r4, r11, -0x3630
	ctx.r[4].s64 = ctx.r[11].s64 + -13872;
	// 82EF1FE8: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1FEC: 4BFFFD55  bl 0x82ef1d40
	ctx.lr = 0x82EF1FF0;
	sub_82EF1D40(ctx, base);
	// 82EF1FF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FF4: 38EBC9C0  addi r7, r11, -0x3640
	ctx.r[7].s64 = ctx.r[11].s64 + -13888;
	// 82EF1FF8: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1FFC: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF2000: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2004: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF2008: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF200C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF2010: 4BFF9039  bl 0x82eeb048
	ctx.lr = 0x82EF2014;
	sub_82EEB048(ctx, base);
	// 82EF2014: 38E00068  li r7, 0x68
	ctx.r[7].s64 = 104;
	// 82EF2018: 38C001CC  li r6, 0x1cc
	ctx.r[6].s64 = 460;
	// 82EF201C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF2020: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2024: 388BC9B4  addi r4, r11, -0x364c
	ctx.r[4].s64 = ctx.r[11].s64 + -13900;
	// 82EF2028: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF202C: 4BFFFD15  bl 0x82ef1d40
	ctx.lr = 0x82EF2030;
	sub_82EF1D40(ctx, base);
	// 82EF2030: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF2034: 80EB0054  lwz r7, 0x54(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF2038: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF203C: 38CB0260  addi r6, r11, 0x260
	ctx.r[6].s64 = ctx.r[11].s64 + 608;
	// 82EF2040: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2044: 38ABC9A0  addi r5, r11, -0x3660
	ctx.r[5].s64 = ctx.r[11].s64 + -13920;
	// 82EF2048: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF204C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF2050: 4BFF8FF9  bl 0x82eeb048
	ctx.lr = 0x82EF2054;
	sub_82EEB048(ctx, base);
	// 82EF2054: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF2058: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF205C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF2060: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2064: 388BC990  addi r4, r11, -0x3670
	ctx.r[4].s64 = ctx.r[11].s64 + -13936;
	// 82EF2068: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF206C: 4BFFFCD5  bl 0x82ef1d40
	ctx.lr = 0x82EF2070;
	sub_82EF1D40(ctx, base);
	// 82EF2070: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82EF2074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF207C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF2080 size=92
    let mut pc: u32 = 0x82EF2080;
    'dispatch: loop {
        match pc {
            0x82EF2080 => {
    //   block [0x82EF2080..0x82EF20DC)
	// 82EF2080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2088: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF208C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF2090: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF2094: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF2098: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF209C: D0210094  stfs f1, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EF20A0: D041009C  stfs f2, 0x9c(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EF20A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF20A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF20AC: 994B0469  stb r10, 0x469(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1129 as u32), ctx.r[10].u8 ) };
	// 82EF20B0: C041009C  lfs f2, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EF20B4: C0210094  lfs f1, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF20B8: 80C1008C  lwz r6, 0x8c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF20BC: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF20C0: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF20C4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF20C8: 48000019  bl 0x82ef20e0
	ctx.lr = 0x82EF20CC;
	sub_82EF20E0(ctx, base);
	// 82EF20CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF20D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF20D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF20D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF20E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF20E0 size=332
    let mut pc: u32 = 0x82EF20E0;
    'dispatch: loop {
        match pc {
            0x82EF20E0 => {
    //   block [0x82EF20E0..0x82EF222C)
	// 82EF20E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF20E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF20E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF20EC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF20F0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF20F4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF20F8: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF20FC: D0210094  stfs f1, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EF2100: D041009C  stfs f2, 0x9c(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EF2104: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2108: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF210C: 914B0494  stw r10, 0x494(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1172 as u32), ctx.r[10].u32 ) };
	// 82EF2110: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2114: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF2118: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EF211C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82EF2120: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF2124: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF2128: 4BFFB901  bl 0x82eeda28
	ctx.lr = 0x82EF212C;
	sub_82EEDA28(ctx, base);
	// 82EF212C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2130: 41820010  beq 0x82ef2140
	if ctx.cr[0].eq {
	pc = 0x82EF2140; continue 'dispatch;
	}
	// 82EF2134: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF2138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF213C: 409A0010  bne cr6, 0x82ef214c
	if !ctx.cr[6].eq {
	pc = 0x82EF214C; continue 'dispatch;
	}
	// 82EF2140: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EF2144: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EF2148: 480000D4  b 0x82ef221c
	pc = 0x82EF221C; continue 'dispatch;
	// 82EF214C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2150: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF2154: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF2158: 4182006C  beq 0x82ef21c4
	if ctx.cr[0].eq {
	pc = 0x82EF21C4; continue 'dispatch;
	}
	// 82EF215C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF2160: 48003481  bl 0x82ef55e0
	ctx.lr = 0x82EF2164;
	sub_82EF55E0(ctx, base);
	// 82EF2164: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 82EF2168: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF216C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF2170: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EF2174: 2F0B0030  cmpwi cr6, r11, 0x30
	ctx.cr[6].compare_i32(ctx.r[11].s32, 48, &mut ctx.xer);
	// 82EF2178: 41980024  blt cr6, 0x82ef219c
	if ctx.cr[6].lt {
	pc = 0x82EF219C; continue 'dispatch;
	}
	// 82EF217C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF2180: 48003461  bl 0x82ef55e0
	ctx.lr = 0x82EF2184;
	sub_82EF55E0(ctx, base);
	// 82EF2184: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 82EF2188: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF218C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF2190: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EF2194: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 82EF2198: 4099002C  ble cr6, 0x82ef21c4
	if !ctx.cr[6].gt {
	pc = 0x82EF21C4; continue 'dispatch;
	}
	// 82EF219C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF21A0: 4BFF6501  bl 0x82ee86a0
	ctx.lr = 0x82EF21A4;
	sub_82EE86A0(ctx, base);
	// 82EF21A4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EF21A8: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF21AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF21B0: 388BCAD0  addi r4, r11, -0x3530
	ctx.r[4].s64 = ctx.r[11].s64 + -13616;
	// 82EF21B4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21B8: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	// 82EF21BC: 4800346D  bl 0x82ef5628
	ctx.lr = 0x82EF21C0;
	sub_82EF5628(ctx, base);
	// 82EF21C0: 48000014  b 0x82ef21d4
	pc = 0x82EF21D4; continue 'dispatch;
	// 82EF21C4: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF21C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21CC: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	// 82EF21D0: 481FF199  bl 0x830f1368
	ctx.lr = 0x82EF21D4;
	sub_830F1368(ctx, base);
	// 82EF21D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21D8: C0010094  lfs f0, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF21DC: D00B048C  stfs f0, 0x48c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1164 as u32), tmp.u32 ) };
	// 82EF21E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21E4: C001009C  lfs f0, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF21E8: D00B0490  stfs f0, 0x490(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1168 as u32), tmp.u32 ) };
	// 82EF21EC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21F0: 388B0058  addi r4, r11, 0x58
	ctx.r[4].s64 = ctx.r[11].s64 + 88;
	// 82EF21F4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21F8: 4BFFF6A9  bl 0x82ef18a0
	ctx.lr = 0x82EF21FC;
	sub_82EF18A0(ctx, base);
	// 82EF21FC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF2200: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2204: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF2208: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF220C: 4182000C  beq 0x82ef2218
	if ctx.cr[0].eq {
	pc = 0x82EF2218; continue 'dispatch;
	}
	// 82EF2210: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2214: 4BFFFCCD  bl 0x82ef1ee0
	ctx.lr = 0x82EF2218;
	sub_82EF1EE0(ctx, base);
	// 82EF2218: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF221C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF2220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF2228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF2230 size=208
    let mut pc: u32 = 0x82EF2230;
    'dispatch: loop {
        match pc {
            0x82EF2230 => {
    //   block [0x82EF2230..0x82EF2300)
	// 82EF2230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF223C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF2240: 9881008F  stb r4, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[4].u8 ) };
	// 82EF2244: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF2248: 896B0030  lbz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EF224C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF2250: 4082009C  bne 0x82ef22ec
	if !ctx.cr[0].eq {
	pc = 0x82EF22EC; continue 'dispatch;
	}
	// 82EF2254: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF2258: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EF225C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF2260: 4B373E51  bl 0x822660b0
	ctx.lr = 0x82EF2264;
	sub_822660B0(ctx, base);
	// 82EF2264: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF2268: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF226C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2270: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF2274: 4098001C  bge cr6, 0x82ef2290
	if !ctx.cr[6].lt {
	pc = 0x82EF2290; continue 'dispatch;
	}
	// 82EF2278: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF227C: 216BFFFF  subfic r11, r11, -1
	ctx.xer.ca = ctx.r[11].u32 <= -1 as u32;
	ctx.r[11].s64 = (-1 as i64) - ctx.r[11].s64;
	// 82EF2280: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF2284: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF2288: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF228C: 48000014  b 0x82ef22a0
	pc = 0x82EF22A0; continue 'dispatch;
	// 82EF2290: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF2294: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2298: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF229C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF22A0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF22A4: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22A8: F96A0038  std r11, 0x38(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[11].u64 ) };
	// 82EF22AC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF22B4: 994B0030  stb r10, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 82EF22B8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22BC: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF22C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF22C4: 419A0028  beq cr6, 0x82ef22ec
	if ctx.cr[6].eq {
	pc = 0x82EF22EC; continue 'dispatch;
	}
	// 82EF22C8: 8881008F  lbz r4, 0x8f(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(143 as u32) ) } as u64;
	// 82EF22CC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22D0: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF22D4: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22D8: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF22DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF22E0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF22E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF22E8: 4E800421  bctrl
	ctx.lr = 0x82EF22EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF22EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF22F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF22F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF22F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF22FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF2300 size=272
    let mut pc: u32 = 0x82EF2300;
    'dispatch: loop {
        match pc {
            0x82EF2300 => {
    //   block [0x82EF2300..0x82EF2410)
	// 82EF2300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2308: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF230C: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF2310: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2314: 896B0030  lbz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EF2318: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF231C: 418200E0  beq 0x82ef23fc
	if ctx.cr[0].eq {
	pc = 0x82EF23FC; continue 'dispatch;
	}
	// 82EF2320: 4B373D91  bl 0x822660b0
	ctx.lr = 0x82EF2324;
	sub_822660B0(ctx, base);
	// 82EF2324: 786B0020  clrldi r11, r3, 0x20
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 82EF2328: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82EF232C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2330: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EF2334: E96B0038  ld r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	// 82EF2338: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EF233C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82EF2340: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EF2344: 2F2B0000  cmpdi cr6, r11, 0
	ctx.cr[6].compare_i64(ctx.r[11].s64, 0, &mut ctx.xer);
	// 82EF2348: 40980018  bge cr6, 0x82ef2360
	if !ctx.cr[6].lt {
	pc = 0x82EF2360; continue 'dispatch;
	}
	// 82EF234C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EF2350: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EF2354: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82EF2358: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EF235C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82EF2360: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EF2364: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF2368: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF236C: 916A0048  stw r11, 0x48(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EF2370: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2374: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF2378: 994B0030  stb r10, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 82EF237C: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF2380: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF2384: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF2388: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF238C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF2390: 4B32D779  bl 0x8221fb08
	ctx.lr = 0x82EF2394;
	sub_8221FB08(ctx, base);
	// 82EF2394: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2398: 816B0494  lwz r11, 0x494(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1172 as u32) ) } as u64;
	// 82EF239C: 2B0B00FE  cmplwi cr6, r11, 0xfe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 254 as u32, &mut ctx.xer);
	// 82EF23A0: 419A0028  beq cr6, 0x82ef23c8
	if ctx.cr[6].eq {
	pc = 0x82EF23C8; continue 'dispatch;
	}
	// 82EF23A4: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23A8: 808B0494  lwz r4, 0x494(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1172 as u32) ) } as u64;
	// 82EF23AC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23B0: 386B0498  addi r3, r11, 0x498
	ctx.r[3].s64 = ctx.r[11].s64 + 1176;
	// 82EF23B4: 481FFF05  bl 0x830f22b8
	ctx.lr = 0x82EF23B8;
	sub_830F22B8(ctx, base);
	// 82EF23B8: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23BC: 388B0498  addi r4, r11, 0x498
	ctx.r[4].s64 = ctx.r[11].s64 + 1176;
	// 82EF23C0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23C4: 4BFFF28D  bl 0x82ef1650
	ctx.lr = 0x82EF23C8;
	sub_82EF1650(ctx, base);
	// 82EF23C8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23CC: 4800356D  bl 0x82ef5938
	ctx.lr = 0x82EF23D0;
	sub_82EF5938(ctx, base);
	// 82EF23D0: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF23D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF23D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF23DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF23E0: 388BCADC  addi r4, r11, -0x3524
	ctx.r[4].s64 = ctx.r[11].s64 + -13604;
	// 82EF23E4: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF23E8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF23EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF23F0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF23F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF23F8: 4E800421  bctrl
	ctx.lr = 0x82EF23FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF23FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2400: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF2404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF240C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF2410 size=248
    let mut pc: u32 = 0x82EF2410;
    'dispatch: loop {
        match pc {
            0x82EF2410 => {
    //   block [0x82EF2410..0x82EF2508)
	// 82EF2410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2418: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF241C: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF2420: 9881009F  stb r4, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[4].u8 ) };
	// 82EF2424: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2428: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF242C: 994B04DD  stb r10, 0x4dd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1245 as u32), ctx.r[10].u8 ) };
	// 82EF2430: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF2434: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF2438: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF243C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF2440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF2444: 4B32D6C5  bl 0x8221fb08
	ctx.lr = 0x82EF2448;
	sub_8221FB08(ctx, base);
	// 82EF2448: 8961009F  lbz r11, 0x9f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(159 as u32) ) } as u64;
	// 82EF244C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF2450: 41820070  beq 0x82ef24c0
	if ctx.cr[0].eq {
	pc = 0x82EF24C0; continue 'dispatch;
	}
	// 82EF2454: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2458: 480034E1  bl 0x82ef5938
	ctx.lr = 0x82EF245C;
	sub_82EF5938(ctx, base);
	// 82EF245C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF2460: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF2464: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF2468: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF246C: 388BCB20  addi r4, r11, -0x34e0
	ctx.r[4].s64 = ctx.r[11].s64 + -13536;
	// 82EF2470: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF2474: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF2478: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF247C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF2480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2484: 4E800421  bctrl
	ctx.lr = 0x82EF2488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF2488: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF248C: 480034AD  bl 0x82ef5938
	ctx.lr = 0x82EF2490;
	sub_82EF5938(ctx, base);
	// 82EF2490: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EF2494: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF2498: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF249C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF24A0: 388BCB08  addi r4, r11, -0x34f8
	ctx.r[4].s64 = ctx.r[11].s64 + -13560;
	// 82EF24A4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF24A8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF24AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF24B0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF24B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF24B8: 4E800421  bctrl
	ctx.lr = 0x82EF24BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF24BC: 48000038  b 0x82ef24f4
	pc = 0x82EF24F4; continue 'dispatch;
	// 82EF24C0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF24C4: 48003475  bl 0x82ef5938
	ctx.lr = 0x82EF24C8;
	sub_82EF5938(ctx, base);
	// 82EF24C8: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF24CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF24D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF24D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF24D8: 388BCAF8  addi r4, r11, -0x3508
	ctx.r[4].s64 = ctx.r[11].s64 + -13576;
	// 82EF24DC: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF24E0: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF24E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF24E8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF24EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF24F0: 4E800421  bctrl
	ctx.lr = 0x82EF24F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF24F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF24F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF24FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF2504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF2508 size=192
    let mut pc: u32 = 0x82EF2508;
    'dispatch: loop {
        match pc {
            0x82EF2508 => {
    //   block [0x82EF2508..0x82EF25C8)
	// 82EF2508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF250C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2510: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF2514: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF2518: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF251C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2520: 808B0480  lwz r4, 0x480(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1152 as u32) ) } as u64;
	// 82EF2524: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2528: 4BFFE8C9  bl 0x82ef0df0
	ctx.lr = 0x82EF252C;
	sub_82EF0DF0(ctx, base);
	// 82EF252C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2530: 808B047C  lwz r4, 0x47c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1148 as u32) ) } as u64;
	// 82EF2534: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2538: 4BFFE8B9  bl 0x82ef0df0
	ctx.lr = 0x82EF253C;
	sub_82EF0DF0(ctx, base);
	// 82EF253C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF2540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF2544: 409A0010  bne cr6, 0x82ef2554
	if !ctx.cr[6].eq {
	pc = 0x82EF2554; continue 'dispatch;
	}
	// 82EF2548: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EF254C: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EF2550: 48000068  b 0x82ef25b8
	pc = 0x82EF25B8; continue 'dispatch;
	// 82EF2554: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EF2558: 80C1007C  lwz r6, 0x7c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF255C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2560: 38ABC898  addi r5, r11, -0x3768
	ctx.r[5].s64 = ctx.r[11].s64 + -14184;
	// 82EF2564: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2568: 388BCB34  addi r4, r11, -0x34cc
	ctx.r[4].s64 = ctx.r[11].s64 + -13516;
	// 82EF256C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2570: 816B0478  lwz r11, 0x478(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1144 as u32) ) } as u64;
	// 82EF2574: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2578: 806A0478  lwz r3, 0x478(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1144 as u32) ) } as u64;
	// 82EF257C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2580: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF2584: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2588: 4E800421  bctrl
	ctx.lr = 0x82EF258C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF258C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF2590: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF2598: 409A0010  bne cr6, 0x82ef25a8
	if !ctx.cr[6].eq {
	pc = 0x82EF25A8; continue 'dispatch;
	}
	// 82EF259C: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EF25A0: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EF25A4: 48000014  b 0x82ef25b8
	pc = 0x82EF25B8; continue 'dispatch;
	// 82EF25A8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF25AC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF25B0: 4BFFE841  bl 0x82ef0df0
	ctx.lr = 0x82EF25B4;
	sub_82EF0DF0(ctx, base);
	// 82EF25B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF25B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF25BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF25C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF25C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF25C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF25C8 size=316
    let mut pc: u32 = 0x82EF25C8;
    'dispatch: loop {
        match pc {
            0x82EF25C8 => {
    //   block [0x82EF25C8..0x82EF2704)
	// 82EF25C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF25CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF25D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF25D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF25D8: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF25DC: 906101C4  stw r3, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[3].u32 ) };
	// 82EF25E0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF25E4: 48003385  bl 0x82ef5968
	ctx.lr = 0x82EF25E8;
	sub_82EF5968(ctx, base);
	// 82EF25E8: 480057D1  bl 0x82ef7db8
	ctx.lr = 0x82EF25EC;
	sub_82EF7DB8(ctx, base);
	// 82EF25EC: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF25F0: 48003349  bl 0x82ef5938
	ctx.lr = 0x82EF25F4;
	sub_82EF5938(ctx, base);
	// 82EF25F4: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82EF25F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF25FC: 4800313D  bl 0x82ef5738
	ctx.lr = 0x82EF2600;
	sub_82EF5738(ctx, base);
	// 82EF2600: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2604: 48003335  bl 0x82ef5938
	ctx.lr = 0x82EF2608;
	sub_82EF5938(ctx, base);
	// 82EF2608: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82EF260C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF2610: 480030E1  bl 0x82ef56f0
	ctx.lr = 0x82EF2614;
	sub_82EF56F0(ctx, base);
	// 82EF2614: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2618: 38CB0260  addi r6, r11, 0x260
	ctx.r[6].s64 = ctx.r[11].s64 + 608;
	// 82EF261C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2620: 38ABC47C  addi r5, r11, -0x3b84
	ctx.r[5].s64 = ctx.r[11].s64 + -15236;
	// 82EF2624: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF2628: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82EF262C: 4BFF8A1D  bl 0x82eeb048
	ctx.lr = 0x82EF2630;
	sub_82EEB048(ctx, base);
	// 82EF2630: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82EF2634: 3BC10090  addi r30, r1, 0x90
	ctx.r[30].s64 = ctx.r[1].s64 + 144;
	// 82EF2638: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF263C: 806B0470  lwz r3, 0x470(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1136 as u32) ) } as u64;
	// 82EF2640: 480032E9  bl 0x82ef5928
	ctx.lr = 0x82EF2644;
	sub_82EF5928(ctx, base);
	// 82EF2644: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF2648: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF264C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF2650: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EF2654: 4800A81D  bl 0x82efce70
	ctx.lr = 0x82EF2658;
	sub_82EFCE70(ctx, base);
	// 82EF2658: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF265C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF2660: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82EF2664: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2668: 48003301  bl 0x82ef5968
	ctx.lr = 0x82EF266C;
	sub_82EF5968(ctx, base);
	// 82EF266C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EF2670: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EF2674: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2678: 816B0470  lwz r11, 0x470(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1136 as u32) ) } as u64;
	// 82EF267C: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2680: 806A0470  lwz r3, 0x470(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1136 as u32) ) } as u64;
	// 82EF2684: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2688: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EF268C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF2690: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2694: 4E800421  bctrl
	ctx.lr = 0x82EF2698;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF2698: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF269C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26A0: 480032C9  bl 0x82ef5968
	ctx.lr = 0x82EF26A4;
	sub_82EF5968(ctx, base);
	// 82EF26A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF26A8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF26B0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF26B4: 480FC095  bl 0x82fee748
	ctx.lr = 0x82EF26B8;
	sub_82FEE748(ctx, base);
	// 82EF26B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF26BC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF26C0: 4BFFB471  bl 0x82eedb30
	ctx.lr = 0x82EF26C4;
	sub_82EEDB30(ctx, base);
	// 82EF26C4: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26C8: 480032A1  bl 0x82ef5968
	ctx.lr = 0x82EF26CC;
	sub_82EF5968(ctx, base);
	// 82EF26CC: 48005BCD  bl 0x82ef8298
	ctx.lr = 0x82EF26D0;
	sub_82EF8298(ctx, base);
	// 82EF26D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF26D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF26D8: C02B0AA0  lfs f1, 0xaa0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2720 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF26DC: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26E0: 480FBD11  bl 0x82fee3f0
	ctx.lr = 0x82EF26E4;
	sub_82FEE3F0(ctx, base);
	// 82EF26E4: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26E8: 48001211  bl 0x82ef38f8
	ctx.lr = 0x82EF26EC;
	sub_82EF38F8(ctx, base);
	// 82EF26EC: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82EF26F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF26F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF26F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF26FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF2700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


