pub fn sub_82EAF550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF550 size=88
    let mut pc: u32 = 0x82EAF550;
    'dispatch: loop {
        match pc {
            0x82EAF550 => {
    //   block [0x82EAF550..0x82EAF5A8)
	// 82EAF550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF558: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAF55C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF560: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF568: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAF56C: 4BFFF85D  bl 0x82eaedc8
	ctx.lr = 0x82EAF570;
	sub_82EAEDC8(ctx, base);
	// 82EAF570: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAF574: 41820018  beq 0x82eaf58c
	if ctx.cr[0].eq {
	pc = 0x82EAF58C; continue 'dispatch;
	}
	// 82EAF578: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAF57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF580: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAF584: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF588: 4E800421  bctrl
	ctx.lr = 0x82EAF58C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF58C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF590: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAF594: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAF598: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAF59C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAF5A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAF5A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAF5A8 size=172
    let mut pc: u32 = 0x82EAF5A8;
    'dispatch: loop {
        match pc {
            0x82EAF5A8 => {
    //   block [0x82EAF5A8..0x82EAF654)
	// 82EAF5A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAF5AC: 392003E8  li r9, 0x3e8
	ctx.r[9].s64 = 1000;
	// 82EAF5B0: 394BAFB4  addi r10, r11, -0x504c
	ctx.r[10].s64 = ctx.r[11].s64 + -20556;
	// 82EAF5B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAF5B8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EAF5BC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAF5C0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAF5C4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAF5C8: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EAF5CC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAF5D0: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EAF5D4: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EAF5D8: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EAF5DC: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EAF5E0: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EAF5E4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EAF5E8: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EAF5EC: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82EAF5F0: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EAF5F4: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EAF5F8: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EAF5FC: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EAF600: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EAF604: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EAF608: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EAF60C: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAF610: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAF614: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAF618: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAF61C: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EAF620: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAF624: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAF628: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAF62C: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EAF630: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAF634: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAF638: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EAF63C: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EAF640: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EAF644: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EAF648: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EAF64C: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EAF650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAF658 size=292
    let mut pc: u32 = 0x82EAF658;
    'dispatch: loop {
        match pc {
            0x82EAF658 => {
    //   block [0x82EAF658..0x82EAF77C)
	// 82EAF658: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAF65C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAF660: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF664: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EAF668: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF66C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAF670: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAF674: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAF678: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAF67C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EAF680: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAF684: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EAF688: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAF68C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EAF690: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAF694: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EAF698: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAF69C: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EAF6A0: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAF6A4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EAF6A8: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAF6AC: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EAF6B0: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAF6B4: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EAF6B8: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAF6BC: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82EAF6C0: 81640038  lwz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EAF6C4: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EAF6C8: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EAF6CC: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EAF6D0: 81640040  lwz r11, 0x40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EAF6D4: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EAF6D8: 81640044  lwz r11, 0x44(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EAF6DC: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EAF6E0: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EAF6E4: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EAF6E8: 8164004C  lwz r11, 0x4c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EAF6EC: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EAF6F0: 81640050  lwz r11, 0x50(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EAF6F4: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAF6F8: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAF6FC: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAF700: 81640058  lwz r11, 0x58(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EAF704: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAF708: 8164005C  lwz r11, 0x5c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EAF70C: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAF710: 81640060  lwz r11, 0x60(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAF714: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EAF718: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EAF71C: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAF720: 81640068  lwz r11, 0x68(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EAF724: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAF728: 8164006C  lwz r11, 0x6c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EAF72C: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAF730: 81640070  lwz r11, 0x70(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EAF734: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EAF738: 81640074  lwz r11, 0x74(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EAF73C: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAF740: 81640078  lwz r11, 0x78(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EAF744: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAF748: 81640084  lwz r11, 0x84(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EAF74C: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EAF750: 81640088  lwz r11, 0x88(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EAF754: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EAF758: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EAF75C: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EAF760: 81640090  lwz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EAF764: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EAF768: 8164007C  lwz r11, 0x7c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EAF76C: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EAF770: 81640080  lwz r11, 0x80(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EAF774: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EAF778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF780 size=372
    let mut pc: u32 = 0x82EAF780;
    'dispatch: loop {
        match pc {
            0x82EAF780 => {
    //   block [0x82EAF780..0x82EAF8F4)
	// 82EAF780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAF78C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF790: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF798: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAF79C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EAF7A0: 394BDE74  addi r10, r11, -0x218c
	ctx.r[10].s64 = ctx.r[11].s64 + -8588;
	// 82EAF7A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF7A8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAF7AC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EAF7B0: 9169FEF4  stw r11, -0x10c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-268 as u32), ctx.r[11].u32 ) };
	// 82EAF7B4: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EAF7B8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAF7BC: 9169FEF8  stw r11, -0x108(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-264 as u32), ctx.r[11].u32 ) };
	// 82EAF7C0: 4BFFFE99  bl 0x82eaf658
	ctx.lr = 0x82EAF7C4;
	sub_82EAF658(ctx, base);
	// 82EAF7C4: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82EAF7C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAF7CC: 915E8684  stw r10, -0x797c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-31100 as u32), ctx.r[10].u32 ) };
	// 82EAF7D0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF7D4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAF7D8: 4BFCFE81  bl 0x82e7f658
	ctx.lr = 0x82EAF7DC;
	sub_82E7F658(ctx, base);
	// 82EAF7DC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAF7E0: 386B8698  addi r3, r11, -0x7968
	ctx.r[3].s64 = ctx.r[11].s64 + -31080;
	// 82EAF7E4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF7E8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EAF7EC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAF7F0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAF7F4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAF7F8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAF7FC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAF800: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAF804: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAF808: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAF80C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAF810: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAF814: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAF818: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAF81C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAF820: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAF824: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAF828: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82EAF82C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EAF830: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EAF834: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EAF838: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EAF83C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAF840: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EAF844: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EAF848: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EAF84C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EAF850: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82EAF854: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EAF858: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EAF85C: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EAF860: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82EAF864: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EAF868: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EAF86C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EAF870: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82EAF874: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EAF878: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EAF87C: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EAF880: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EAF884: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EAF888: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EAF88C: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EAF890: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82EAF894: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAF898: 906BFEF0  stw r3, -0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-272 as u32), ctx.r[3].u32 ) };
	// 82EAF89C: 817E8684  lwz r11, -0x797c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-31100 as u32) ) } as u64;
	// 82EAF8A0: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAF8A4: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF8A8: 808B0024  lwz r4, 0x24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAF8AC: 4BFD595D  bl 0x82e85208
	ctx.lr = 0x82EAF8B0;
	sub_82E85208(ctx, base);
	// 82EAF8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAF8B4: 4BFD01CD  bl 0x82e7fa80
	ctx.lr = 0x82EAF8B8;
	sub_82E7FA80(ctx, base);
	// 82EAF8B8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EAF8BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAF8C0: 409A002C  bne cr6, 0x82eaf8ec
	if !ctx.cr[6].eq {
	pc = 0x82EAF8EC; continue 'dispatch;
	}
	// 82EAF8C4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EAF8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAF8CC: 4BCE75AD  bl 0x82b96e78
	ctx.lr = 0x82EAF8D0;
	sub_82B96E78(ctx, base);
	// 82EAF8D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF8D4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EAF8D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAF8DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAF8E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAF8E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAF8E8: 4E800020  blr
	return;
	// 82EAF8EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EAF8F0: 4BFFFFD8  b 0x82eaf8c8
	pc = 0x82EAF8C8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF8F8 size=104
    let mut pc: u32 = 0x82EAF8F8;
    'dispatch: loop {
        match pc {
            0x82EAF8F8 => {
    //   block [0x82EAF8F8..0x82EAF960)
	// 82EAF8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAF904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF90C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAF910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF914: 3BCB8698  addi r30, r11, -0x7968
	ctx.r[30].s64 = ctx.r[11].s64 + -31080;
	// 82EAF918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF91C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAF920: 4BFD53D1  bl 0x82e84cf0
	ctx.lr = 0x82EAF924;
	sub_82E84CF0(ctx, base);
	// 82EAF924: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAF928: 814BFEF8  lwz r10, -0x108(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-264 as u32) ) } as u64;
	// 82EAF92C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAF930: 419A0018  beq cr6, 0x82eaf948
	if ctx.cr[6].eq {
	pc = 0x82EAF948; continue 'dispatch;
	}
	// 82EAF934: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAF938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF93C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAF940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF944: 4E800421  bctrl
	ctx.lr = 0x82EAF948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAF94C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAF950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAF954: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAF958: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAF95C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF960 size=104
    let mut pc: u32 = 0x82EAF960;
    'dispatch: loop {
        match pc {
            0x82EAF960 => {
    //   block [0x82EAF960..0x82EAF9C8)
	// 82EAF960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF964: 4BDF9AA9  bl 0x82ca940c
	ctx.lr = 0x82EAF968;
	sub_82CA93D0(ctx, base);
	// 82EAF968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF970: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAF974: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EAF978: 419A0048  beq cr6, 0x82eaf9c0
	if ctx.cr[6].eq {
	pc = 0x82EAF9C0; continue 'dispatch;
	}
	// 82EAF97C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82EAF980: 4B766FA9  bl 0x82616928
	ctx.lr = 0x82EAF984;
	sub_82616928(ctx, base);
	// 82EAF984: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAF988: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82EAF98C: 41820018  beq 0x82eaf9a4
	if ctx.cr[0].eq {
	pc = 0x82EAF9A4; continue 'dispatch;
	}
	// 82EAF990: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EAF994: 80BDFEF0  lwz r5, -0x110(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82EAF998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF99C: 4BFD58F5  bl 0x82e85290
	ctx.lr = 0x82EAF9A0;
	sub_82E85290(ctx, base);
	// 82EAF9A0: 48000008  b 0x82eaf9a8
	pc = 0x82EAF9A8; continue 'dispatch;
	// 82EAF9A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAF9A8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAF9AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAF9B0: 396B8688  addi r11, r11, -0x7978
	ctx.r[11].s64 = ctx.r[11].s64 + -31096;
	// 82EAF9B4: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EAF9B8: 419A0008  beq cr6, 0x82eaf9c0
	if ctx.cr[6].eq {
	pc = 0x82EAF9C0; continue 'dispatch;
	}
	// 82EAF9BC: 907DFEF0  stw r3, -0x110(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-272 as u32), ctx.r[3].u32 ) };
	// 82EAF9C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAF9C4: 4BDF9A98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF9C8 size=108
    let mut pc: u32 = 0x82EAF9C8;
    'dispatch: loop {
        match pc {
            0x82EAF9C8 => {
    //   block [0x82EAF9C8..0x82EAFA34)
	// 82EAF9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF9D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF9D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF9D8: 3FE08335  lis r31, -0x7ccb
	ctx.r[31].s64 = -2093678592;
	// 82EAF9DC: 807F8688  lwz r3, -0x7978(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-31096 as u32) ) } as u64;
	// 82EAF9E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAF9E4: 419A003C  beq cr6, 0x82eafa20
	if ctx.cr[6].eq {
	pc = 0x82EAFA20; continue 'dispatch;
	}
	// 82EAF9E8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAF9EC: 814BFEF0  lwz r10, -0x110(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82EAF9F0: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EAF9F4: 409A0010  bne cr6, 0x82eafa04
	if !ctx.cr[6].eq {
	pc = 0x82EAFA04; continue 'dispatch;
	}
	// 82EAF9F8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EAF9FC: 394A8698  addi r10, r10, -0x7968
	ctx.r[10].s64 = ctx.r[10].s64 + -31080;
	// 82EAFA00: 914BFEF0  stw r10, -0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-272 as u32), ctx.r[10].u32 ) };
	// 82EAFA04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFA08: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAFA0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFA14: 4E800421  bctrl
	ctx.lr = 0x82EAFA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFA18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAFA1C: 917F8688  stw r11, -0x7978(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-31096 as u32), ctx.r[11].u32 ) };
	// 82EAFA20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFA24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFA28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFA2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFA30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFA38 size=20
    let mut pc: u32 = 0x82EAFA38;
    'dispatch: loop {
        match pc {
            0x82EAFA38 => {
    //   block [0x82EAFA38..0x82EAFA4C)
	// 82EAFA38: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EAFA3C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EAFA40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFA44: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82EAFA48: 4BFD00C0  b 0x82e7fb08
	sub_82E7FB08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFA50 size=16
    let mut pc: u32 = 0x82EAFA50;
    'dispatch: loop {
        match pc {
            0x82EAFA50 => {
    //   block [0x82EAFA50..0x82EAFA60)
	// 82EAFA50: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82EAFA54: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82EAFA58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFA5C: 4BFD00AC  b 0x82e7fb08
	sub_82E7FB08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFA60 size=96
    let mut pc: u32 = 0x82EAFA60;
    'dispatch: loop {
        match pc {
            0x82EAFA60 => {
    //   block [0x82EAFA60..0x82EAFAC0)
	// 82EAFA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFA68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFA6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFA70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFA74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EAFA78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAFA7C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EAFA80: 38AB70A8  addi r5, r11, 0x70a8
	ctx.r[5].s64 = ctx.r[11].s64 + 28840;
	// 82EAFA84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFA88: 4BFD0081  bl 0x82e7fb08
	ctx.lr = 0x82EAFA8C;
	sub_82E7FB08(ctx, base);
	// 82EAFA8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAFA90: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EAFA94: 38AB8FD8  addi r5, r11, -0x7028
	ctx.r[5].s64 = ctx.r[11].s64 + -28712;
	// 82EAFA98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFA9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAFAA0: 4BFD0069  bl 0x82e7fb08
	ctx.lr = 0x82EAFAA4;
	sub_82E7FB08(ctx, base);
	// 82EAFAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFAA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFAAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFAB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFAB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFAB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFAC0 size=96
    let mut pc: u32 = 0x82EAFAC0;
    'dispatch: loop {
        match pc {
            0x82EAFAC0 => {
    //   block [0x82EAFAC0..0x82EAFB20)
	// 82EAFAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFAC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFAD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFAD4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EAFAD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAFADC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EAFAE0: 38AB4D6C  addi r5, r11, 0x4d6c
	ctx.r[5].s64 = ctx.r[11].s64 + 19820;
	// 82EAFAE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFAE8: 4BFD0021  bl 0x82e7fb08
	ctx.lr = 0x82EAFAEC;
	sub_82E7FB08(ctx, base);
	// 82EAFAEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAFAF0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EAFAF4: 38AB8FD8  addi r5, r11, -0x7028
	ctx.r[5].s64 = ctx.r[11].s64 + -28712;
	// 82EAFAF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFAFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAFB00: 4BFD0009  bl 0x82e7fb08
	ctx.lr = 0x82EAFB04;
	sub_82E7FB08(ctx, base);
	// 82EAFB04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFB08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFB0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFB10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFB14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFB18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFB1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFB20 size=96
    let mut pc: u32 = 0x82EAFB20;
    'dispatch: loop {
        match pc {
            0x82EAFB20 => {
    //   block [0x82EAFB20..0x82EAFB80)
	// 82EAFB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFB28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFB2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFB30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFB34: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EAFB38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAFB3C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EAFB40: 38AB4D64  addi r5, r11, 0x4d64
	ctx.r[5].s64 = ctx.r[11].s64 + 19812;
	// 82EAFB44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFB48: 4BFCFFC1  bl 0x82e7fb08
	ctx.lr = 0x82EAFB4C;
	sub_82E7FB08(ctx, base);
	// 82EAFB4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAFB50: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EAFB54: 38AB8FD8  addi r5, r11, -0x7028
	ctx.r[5].s64 = ctx.r[11].s64 + -28712;
	// 82EAFB58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFB5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAFB60: 4BFCFFA9  bl 0x82e7fb08
	ctx.lr = 0x82EAFB64;
	sub_82E7FB08(ctx, base);
	// 82EAFB64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFB68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFB6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFB70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFB74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFB78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFB7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFB80 size=108
    let mut pc: u32 = 0x82EAFB80;
    'dispatch: loop {
        match pc {
            0x82EAFB80 => {
    //   block [0x82EAFB80..0x82EAFBEC)
	// 82EAFB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFB88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFB8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFB90: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFB94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAFB98: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EAFB9C: 816B8688  lwz r11, -0x7978(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31096 as u32) ) } as u64;
	// 82EAFBA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAFBA4: 409A0014  bne cr6, 0x82eafbb8
	if !ctx.cr[6].eq {
	pc = 0x82EAFBB8; continue 'dispatch;
	}
	// 82EAFBA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAFBAC: 419A000C  beq cr6, 0x82eafbb8
	if ctx.cr[6].eq {
	pc = 0x82EAFBB8; continue 'dispatch;
	}
	// 82EAFBB0: 38800064  li r4, 0x64
	ctx.r[4].s64 = 100;
	// 82EAFBB4: 4BFFFDAD  bl 0x82eaf960
	ctx.lr = 0x82EAFBB8;
	sub_82EAF960(ctx, base);
	// 82EAFBB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAFBBC: 396BDE74  addi r11, r11, -0x218c
	ctx.r[11].s64 = ctx.r[11].s64 + -8588;
	// 82EAFBC0: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EAFBC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFBC8: 4E800421  bctrl
	ctx.lr = 0x82EAFBCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFBCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EAFBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFBD4: 4BFD0865  bl 0x82e80438
	ctx.lr = 0x82EAFBD8;
	sub_82E80438(ctx, base);
	// 82EAFBD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFBDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFBE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFBE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFBE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFBF0 size=80
    let mut pc: u32 = 0x82EAFBF0;
    'dispatch: loop {
        match pc {
            0x82EAFBF0 => {
    //   block [0x82EAFBF0..0x82EAFC40)
	// 82EAFBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFBF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFBFC: 4BFD006D  bl 0x82e7fc68
	ctx.lr = 0x82EAFC00;
	sub_82E7FC68(ctx, base);
	// 82EAFC00: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFC04: 816B8684  lwz r11, -0x797c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31100 as u32) ) } as u64;
	// 82EAFC08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAFC0C: 419A001C  beq cr6, 0x82eafc28
	if ctx.cr[6].eq {
	pc = 0x82EAFC28; continue 'dispatch;
	}
	// 82EAFC10: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EAFC14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAFC18: 419A0010  beq cr6, 0x82eafc28
	if ctx.cr[6].eq {
	pc = 0x82EAFC28; continue 'dispatch;
	}
	// 82EAFC1C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAFC20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFC24: 4E800421  bctrl
	ctx.lr = 0x82EAFC28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFC28: 4BFFFDA1  bl 0x82eaf9c8
	ctx.lr = 0x82EAFC2C;
	sub_82EAF9C8(ctx, base);
	// 82EAFC2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFC30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFC34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFC38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFC3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFC40 size=60
    let mut pc: u32 = 0x82EAFC40;
    'dispatch: loop {
        match pc {
            0x82EAFC40 => {
    //   block [0x82EAFC40..0x82EAFC7C)
	// 82EAFC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFC44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFC48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFC4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAFC50: 419A0018  beq cr6, 0x82eafc68
	if ctx.cr[6].eq {
	pc = 0x82EAFC68; continue 'dispatch;
	}
	// 82EAFC54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFC58: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAFC5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFC64: 4E800421  bctrl
	ctx.lr = 0x82EAFC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFC68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFC6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFC70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFC74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFC78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFC80 size=4
    let mut pc: u32 = 0x82EAFC80;
    'dispatch: loop {
        match pc {
            0x82EAFC80 => {
    //   block [0x82EAFC80..0x82EAFC84)
	// 82EAFC80: 4BFCFE60  b 0x82e7fae0
	sub_82E7FAE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFC88 size=4
    let mut pc: u32 = 0x82EAFC88;
    'dispatch: loop {
        match pc {
            0x82EAFC88 => {
    //   block [0x82EAFC88..0x82EAFC8C)
	// 82EAFC88: 4BFD00B0  b 0x82e7fd38
	sub_82E7FD38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFC90 size=4
    let mut pc: u32 = 0x82EAFC90;
    'dispatch: loop {
        match pc {
            0x82EAFC90 => {
    //   block [0x82EAFC90..0x82EAFC94)
	// 82EAFC90: 4BFD0918  b 0x82e805a8
	sub_82E805A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFC98 size=4
    let mut pc: u32 = 0x82EAFC98;
    'dispatch: loop {
        match pc {
            0x82EAFC98 => {
    //   block [0x82EAFC98..0x82EAFC9C)
	// 82EAFC98: 4BFD03A8  b 0x82e80040
	sub_82E80040(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFCA0 size=4
    let mut pc: u32 = 0x82EAFCA0;
    'dispatch: loop {
        match pc {
            0x82EAFCA0 => {
    //   block [0x82EAFCA0..0x82EAFCA4)
	// 82EAFCA0: 4BFFFAE0  b 0x82eaf780
	sub_82EAF780(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFCA8 size=156
    let mut pc: u32 = 0x82EAFCA8;
    'dispatch: loop {
        match pc {
            0x82EAFCA8 => {
    //   block [0x82EAFCA8..0x82EAFD44)
	// 82EAFCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFCAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFCB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFCB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFCB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFCBC: 4BFCFDCD  bl 0x82e7fa88
	ctx.lr = 0x82EAFCC0;
	sub_82E7FA88(ctx, base);
	// 82EAFCC0: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82EAFCC4: 817E8684  lwz r11, -0x797c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-31100 as u32) ) } as u64;
	// 82EAFCC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAFCCC: 419A001C  beq cr6, 0x82eafce8
	if ctx.cr[6].eq {
	pc = 0x82EAFCE8; continue 'dispatch;
	}
	// 82EAFCD0: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EAFCD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAFCD8: 419A0010  beq cr6, 0x82eafce8
	if ctx.cr[6].eq {
	pc = 0x82EAFCE8; continue 'dispatch;
	}
	// 82EAFCDC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAFCE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFCE4: 4E800421  bctrl
	ctx.lr = 0x82EAFCE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFCE8: 4BFFFCE1  bl 0x82eaf9c8
	ctx.lr = 0x82EAFCEC;
	sub_82EAF9C8(ctx, base);
	// 82EAFCEC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFCF0: 3FE08330  lis r31, -0x7cd0
	ctx.r[31].s64 = -2094006272;
	// 82EAFCF4: 386B8698  addi r3, r11, -0x7968
	ctx.r[3].s64 = ctx.r[11].s64 + -31080;
	// 82EAFCF8: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EAFCFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFD00: 396BF8F8  addi r11, r11, -0x708
	ctx.r[11].s64 = ctx.r[11].s64 + -1800;
	// 82EAFD04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EAFD08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFD0C: 917FDAB4  stw r11, -0x254c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-9548 as u32), ctx.r[11].u32 ) };
	// 82EAFD10: 4BFD54F9  bl 0x82e85208
	ctx.lr = 0x82EAFD14;
	sub_82E85208(ctx, base);
	// 82EAFD14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAFD18: 3D4082E8  lis r10, -0x7d18
	ctx.r[10].s64 = -2098724864;
	// 82EAFD1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFD20: 917E8684  stw r11, -0x797c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-31100 as u32), ctx.r[11].u32 ) };
	// 82EAFD24: 396AF5F0  addi r11, r10, -0xa10
	ctx.r[11].s64 = ctx.r[10].s64 + -2576;
	// 82EAFD28: 917FDAB4  stw r11, -0x254c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-9548 as u32), ctx.r[11].u32 ) };
	// 82EAFD2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFD30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFD34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFD38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFD3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFD40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFD48 size=140
    let mut pc: u32 = 0x82EAFD48;
    'dispatch: loop {
        match pc {
            0x82EAFD48 => {
    //   block [0x82EAFD48..0x82EAFDD4)
	// 82EAFD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFD4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFD50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFD54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFD58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFD5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAFD60: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EAFD64: 4B766BC5  bl 0x82616928
	ctx.lr = 0x82EAFD68;
	sub_82616928(ctx, base);
	// 82EAFD68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EAFD6C: 4182001C  beq 0x82eafd88
	if ctx.cr[0].eq {
	pc = 0x82EAFD88; continue 'dispatch;
	}
	// 82EAFD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFD74: 4BFD4495  bl 0x82e84208
	ctx.lr = 0x82EAFD78;
	sub_82E84208(ctx, base);
	// 82EAFD78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAFD7C: 396BA39C  addi r11, r11, -0x5c64
	ctx.r[11].s64 = ctx.r[11].s64 + -23652;
	// 82EAFD80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAFD84: 48000008  b 0x82eafd8c
	pc = 0x82EAFD8C; continue 'dispatch;
	// 82EAFD88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EAFD8C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAFD90: 396BDE74  addi r11, r11, -0x218c
	ctx.r[11].s64 = ctx.r[11].s64 + -8588;
	// 82EAFD94: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EAFD98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFD9C: 4E800421  bctrl
	ctx.lr = 0x82EAFDA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFDA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EAFDA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAFDAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFDB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFDB4: 4E800421  bctrl
	ctx.lr = 0x82EAFDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFDBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFDC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFDC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFDC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFDCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFDD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFDD8 size=564
    let mut pc: u32 = 0x82EAFDD8;
    'dispatch: loop {
        match pc {
            0x82EAFDD8 => {
    //   block [0x82EAFDD8..0x82EB000C)
	// 82EAFDD8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFDDC: 396B8C64  addi r11, r11, -0x739c
	ctx.r[11].s64 = ctx.r[11].s64 + -29596;
	// 82EAFDE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFDE4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFDE8: 419A0224  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFDEC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFDF0: 396BE16C  addi r11, r11, -0x1e94
	ctx.r[11].s64 = ctx.r[11].s64 + -7828;
	// 82EAFDF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFDF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFDFC: 419A0210  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFE00: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFE04: 396B8E0C  addi r11, r11, -0x71f4
	ctx.r[11].s64 = ctx.r[11].s64 + -29172;
	// 82EAFE08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE0C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE10: 419A01FC  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFE14: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFE18: 396B8CF8  addi r11, r11, -0x7308
	ctx.r[11].s64 = ctx.r[11].s64 + -29448;
	// 82EAFE1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE20: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE24: 419A01E8  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFE28: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFE2C: 396B8BE4  addi r11, r11, -0x741c
	ctx.r[11].s64 = ctx.r[11].s64 + -29724;
	// 82EAFE30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE34: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE38: 419A01D4  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFE3C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE40: 396B9E5C  addi r11, r11, -0x61a4
	ctx.r[11].s64 = ctx.r[11].s64 + -24996;
	// 82EAFE44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE48: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE4C: 419A01C0  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFE50: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE54: 396BE058  addi r11, r11, -0x1fa8
	ctx.r[11].s64 = ctx.r[11].s64 + -8104;
	// 82EAFE58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE5C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE60: 419A01AC  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFE64: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE68: 396BDF44  addi r11, r11, -0x20bc
	ctx.r[11].s64 = ctx.r[11].s64 + -8380;
	// 82EAFE6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE70: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE74: 419A0198  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFE78: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE7C: 396BDE30  addi r11, r11, -0x21d0
	ctx.r[11].s64 = ctx.r[11].s64 + -8656;
	// 82EAFE80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE84: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE88: 419A0184  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFE8C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE90: 396BDD1C  addi r11, r11, -0x22e4
	ctx.r[11].s64 = ctx.r[11].s64 + -8932;
	// 82EAFE94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE98: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE9C: 419A0170  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFEA0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFEA4: 396BDC08  addi r11, r11, -0x23f8
	ctx.r[11].s64 = ctx.r[11].s64 + -9208;
	// 82EAFEA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFEAC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFEB0: 419A015C  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFEB4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFEB8: 396BDAF4  addi r11, r11, -0x250c
	ctx.r[11].s64 = ctx.r[11].s64 + -9484;
	// 82EAFEBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFEC0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFEC4: 419A0148  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFEC8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFECC: 396BD9E0  addi r11, r11, -0x2620
	ctx.r[11].s64 = ctx.r[11].s64 + -9760;
	// 82EAFED0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFED4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFED8: 419A0134  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFEDC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFEE0: 396BD8CC  addi r11, r11, -0x2734
	ctx.r[11].s64 = ctx.r[11].s64 + -10036;
	// 82EAFEE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFEE8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFEEC: 419A0120  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFEF0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFEF4: 396BD7B8  addi r11, r11, -0x2848
	ctx.r[11].s64 = ctx.r[11].s64 + -10312;
	// 82EAFEF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFEFC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF00: 419A010C  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFF04: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF08: 396BD6A4  addi r11, r11, -0x295c
	ctx.r[11].s64 = ctx.r[11].s64 + -10588;
	// 82EAFF0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF10: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF14: 419A00F8  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFF18: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF1C: 396BD590  addi r11, r11, -0x2a70
	ctx.r[11].s64 = ctx.r[11].s64 + -10864;
	// 82EAFF20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF24: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF28: 419A00E4  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFF2C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF30: 396BD47C  addi r11, r11, -0x2b84
	ctx.r[11].s64 = ctx.r[11].s64 + -11140;
	// 82EAFF34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF38: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF3C: 419A00D0  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFF40: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF44: 396BD358  addi r11, r11, -0x2ca8
	ctx.r[11].s64 = ctx.r[11].s64 + -11432;
	// 82EAFF48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF4C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF50: 419A00BC  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFF54: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF58: 396BD244  addi r11, r11, -0x2dbc
	ctx.r[11].s64 = ctx.r[11].s64 + -11708;
	// 82EAFF5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF60: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF64: 419A00A8  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFF68: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF6C: 396BD12C  addi r11, r11, -0x2ed4
	ctx.r[11].s64 = ctx.r[11].s64 + -11988;
	// 82EAFF70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF74: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF78: 419A0094  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFF7C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFF80: 396B8AD0  addi r11, r11, -0x7530
	ctx.r[11].s64 = ctx.r[11].s64 + -30000;
	// 82EAFF84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF88: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF8C: 419A0080  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFF90: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFF94: 396B89BC  addi r11, r11, -0x7644
	ctx.r[11].s64 = ctx.r[11].s64 + -30276;
	// 82EAFF98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF9C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFA0: 419A006C  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFFA4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFA8: 396BD018  addi r11, r11, -0x2fe8
	ctx.r[11].s64 = ctx.r[11].s64 + -12264;
	// 82EAFFAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFFB0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFB4: 419A0058  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFFB8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFBC: 396BCF04  addi r11, r11, -0x30fc
	ctx.r[11].s64 = ctx.r[11].s64 + -12540;
	// 82EAFFC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFFC4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFC8: 419A0044  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFFCC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFD0: 396BCDF0  addi r11, r11, -0x3210
	ctx.r[11].s64 = ctx.r[11].s64 + -12816;
	// 82EAFFD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFFD8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFDC: 419A0030  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFFE0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFE4: 396BCCDC  addi r11, r11, -0x3324
	ctx.r[11].s64 = ctx.r[11].s64 + -13092;
	// 82EAFFE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFFEC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFF0: 419A001C  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
		sub_82EB000C(ctx, base);
		return;
	}
	// 82EAFFF4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFFFC: 396BCBC8  addi r11, r11, -0x3438
	ctx.r[11].s64 = ctx.r[11].s64 + -13368;
	// 82EB0000: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0004: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB0008: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB000C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB000C size=8
    let mut pc: u32 = 0x82EB000C;
    'dispatch: loop {
        match pc {
            0x82EB000C => {
    //   block [0x82EB000C..0x82EB0014)
	// 82EB000C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0018 size=456
    let mut pc: u32 = 0x82EB0018;
    'dispatch: loop {
        match pc {
            0x82EB0018 => {
    //   block [0x82EB0018..0x82EB01E0)
	// 82EB0018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB001C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB0020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB0024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB0028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB002C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0030: 4BFD58D1  bl 0x82e85900
	ctx.lr = 0x82EB0034;
	sub_82E85900(ctx, base);
	// 82EB0034: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB0038: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EB003C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB0040: 396BA3B0  addi r11, r11, -0x5c50
	ctx.r[11].s64 = ctx.r[11].s64 + -23632;
	// 82EB0044: 394A8704  addi r10, r10, -0x78fc
	ctx.r[10].s64 = ctx.r[10].s64 + -30972;
	// 82EB0048: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB004C: 3929990C  addi r9, r9, -0x66f4
	ctx.r[9].s64 = ctx.r[9].s64 + -26356;
	// 82EB0050: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB0054: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB0058: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EB005C: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82EB0060: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82EB0064: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82EB0068: 4BFE2ED1  bl 0x82e92f38
	ctx.lr = 0x82EB006C;
	sub_82E92F38(ctx, base);
	// 82EB006C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0070: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EB0074: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0078: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB007C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EB0080: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EB0084: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EB0088: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EB008C: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EB0090: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EB0094: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB0098: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB009C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB00A0: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EB00A4: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EB00A8: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EB00AC: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EB00B0: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EB00B4: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EB00B8: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB00BC: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB00C0: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB00C4: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82EB00C8: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82EB00CC: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82EB00D0: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82EB00D4: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82EB00D8: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EB00DC: D01F0128  stfs f0, 0x128(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EB00E0: D01F012C  stfs f0, 0x12c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EB00E4: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82EB00E8: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EB00EC: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EB00F0: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82EB00F4: 997F00BC  stb r11, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	// 82EB00F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB00FC: 9BDF01B5  stb r30, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[30].u8 ) };
	// 82EB0100: 9BDF00BF  stb r30, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[30].u8 ) };
	// 82EB0104: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82EB0108: 93DF0174  stw r30, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[30].u32 ) };
	// 82EB010C: 93DF0178  stw r30, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[30].u32 ) };
	// 82EB0110: 9BDF00BE  stb r30, 0xbe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(190 as u32), ctx.r[30].u8 ) };
	// 82EB0114: 9BDF00C0  stb r30, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u8 ) };
	// 82EB0118: 9BDF00C1  stb r30, 0xc1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(193 as u32), ctx.r[30].u8 ) };
	// 82EB011C: 9BDF00BD  stb r30, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[30].u8 ) };
	// 82EB0120: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 82EB0124: 93DF0138  stw r30, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[30].u32 ) };
	// 82EB0128: 93DF0134  stw r30, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u32 ) };
	// 82EB012C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0130: D1BF00EC  stfs f13, 0xec(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EB0134: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0138: D1BF00F0  stfs f13, 0xf0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EB013C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0140: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EB0144: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0148: D1BF00E0  stfs f13, 0xe0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB014C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0150: D1BF00E4  stfs f13, 0xe4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB0154: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0158: D1BF00E8  stfs f13, 0xe8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB015C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0160: D1BF00F8  stfs f13, 0xf8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EB0164: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0168: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EB016C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0170: D1BF0100  stfs f13, 0x100(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EB0174: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 82EB0178: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB017C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0180: D1BF0144  stfs f13, 0x144(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EB0184: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0188: D1BF0148  stfs f13, 0x148(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EB018C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0194: D1BF014C  stfs f13, 0x14c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82EB0198: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82EB019C: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB01A0: 93DF0154  stw r30, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[30].u32 ) };
	// 82EB01A4: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB01A8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82EB01AC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EB01B0: 93DF01B0  stw r30, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[30].u32 ) };
	// 82EB01B4: C1AB0B24  lfs f13, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB01B8: 93DF01AC  stw r30, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[30].u32 ) };
	// 82EB01BC: D1BF0194  stfs f13, 0x194(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82EB01C0: 93DF01CC  stw r30, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 82EB01C4: 9BDF01C8  stb r30, 0x1c8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[30].u8 ) };
	// 82EB01C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB01CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB01D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB01D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB01D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB01DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB01E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB01E0 size=12
    let mut pc: u32 = 0x82EB01E0;
    'dispatch: loop {
        match pc {
            0x82EB01E0 => {
    //   block [0x82EB01E0..0x82EB01EC)
	// 82EB01E0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB01E4: 386B8C64  addi r3, r11, -0x739c
	ctx.r[3].s64 = ctx.r[11].s64 + -29596;
	// 82EB01E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB01F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB01F0 size=12
    let mut pc: u32 = 0x82EB01F0;
    'dispatch: loop {
        match pc {
            0x82EB01F0 => {
    //   block [0x82EB01F0..0x82EB01FC)
	// 82EB01F0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB01F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB01F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB01FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB01FC size=20
    let mut pc: u32 = 0x82EB01FC;
    'dispatch: loop {
        match pc {
            0x82EB01FC => {
    //   block [0x82EB01FC..0x82EB0210)
	// 82EB01FC: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EB0200: 8083006C  lwz r4, 0x6c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB0204: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0208: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EB020C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0210 size=20
    let mut pc: u32 = 0x82EB0210;
    'dispatch: loop {
        match pc {
            0x82EB0210 => {
    //   block [0x82EB0210..0x82EB0224)
	// 82EB0210: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0214: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB0218: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB021C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0220: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0224(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0224 size=4
    let mut pc: u32 = 0x82EB0224;
    'dispatch: loop {
        match pc {
            0x82EB0224 => {
    //   block [0x82EB0224..0x82EB0228)
	// 82EB0224: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0228 size=52
    let mut pc: u32 = 0x82EB0228;
    'dispatch: loop {
        match pc {
            0x82EB0228 => {
    //   block [0x82EB0228..0x82EB025C)
	// 82EB0228: 81630160  lwz r11, 0x160(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB022C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0230: 40820010  bne 0x82eb0240
	if !ctx.cr[0].eq {
	pc = 0x82EB0240; continue 'dispatch;
	}
	// 82EB0234: 81430164  lwz r10, 0x164(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB0238: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB023C: 419A0018  beq cr6, 0x82eb0254
	if ctx.cr[6].eq {
	pc = 0x82EB0254; continue 'dispatch;
	}
	// 82EB0240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0244: 419A0018  beq cr6, 0x82eb025c
	if ctx.cr[6].eq {
		sub_82EB025C(ctx, base);
		return;
	}
	// 82EB0248: 81630164  lwz r11, 0x164(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB024C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0250: 419A000C  beq cr6, 0x82eb025c
	if ctx.cr[6].eq {
		sub_82EB025C(ctx, base);
		return;
	}
	// 82EB0254: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB025C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB025C size=8
    let mut pc: u32 = 0x82EB025C;
    'dispatch: loop {
        match pc {
            0x82EB025C => {
    //   block [0x82EB025C..0x82EB0264)
	// 82EB025C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB0260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0268 size=52
    let mut pc: u32 = 0x82EB0268;
    'dispatch: loop {
        match pc {
            0x82EB0268 => {
    //   block [0x82EB0268..0x82EB029C)
	// 82EB0268: 81630168  lwz r11, 0x168(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB026C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0270: 40820010  bne 0x82eb0280
	if !ctx.cr[0].eq {
	pc = 0x82EB0280; continue 'dispatch;
	}
	// 82EB0274: 8143016C  lwz r10, 0x16c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB0278: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB027C: 419A0018  beq cr6, 0x82eb0294
	if ctx.cr[6].eq {
	pc = 0x82EB0294; continue 'dispatch;
	}
	// 82EB0280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0284: 419A0018  beq cr6, 0x82eb029c
	if ctx.cr[6].eq {
		sub_82EB029C(ctx, base);
		return;
	}
	// 82EB0288: 8163016C  lwz r11, 0x16c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB028C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0290: 419A000C  beq cr6, 0x82eb029c
	if ctx.cr[6].eq {
		sub_82EB029C(ctx, base);
		return;
	}
	// 82EB0294: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0298: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB029C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB029C size=8
    let mut pc: u32 = 0x82EB029C;
    'dispatch: loop {
        match pc {
            0x82EB029C => {
    //   block [0x82EB029C..0x82EB02A4)
	// 82EB029C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB02A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB02A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB02A8 size=20
    let mut pc: u32 = 0x82EB02A8;
    'dispatch: loop {
        match pc {
            0x82EB02A8 => {
    //   block [0x82EB02A8..0x82EB02BC)
	// 82EB02A8: 81630158  lwz r11, 0x158(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB02AC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB02B0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB02B4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82EB02B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB02C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB02C0 size=36
    let mut pc: u32 = 0x82EB02C0;
    'dispatch: loop {
        match pc {
            0x82EB02C0 => {
    //   block [0x82EB02C0..0x82EB02E4)
	// 82EB02C0: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB02C4: 814300A0  lwz r10, 0xa0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB02C8: 396B4300  addi r11, r11, 0x4300
	ctx.r[11].s64 = ctx.r[11].s64 + 17152;
	// 82EB02CC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB02D0: 409A0014  bne cr6, 0x82eb02e4
	if !ctx.cr[6].eq {
		sub_82EB02E4(ctx, base);
		return;
	}
	// 82EB02D4: 81630178  lwz r11, 0x178(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) } as u64;
	// 82EB02D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB02DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB02E0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB02E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB02E4 size=8
    let mut pc: u32 = 0x82EB02E4;
    'dispatch: loop {
        match pc {
            0x82EB02E4 => {
    //   block [0x82EB02E4..0x82EB02EC)
	// 82EB02E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB02E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB02F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB02F0 size=2268
    let mut pc: u32 = 0x82EB02F0;
    'dispatch: loop {
        match pc {
            0x82EB02F0 => {
    //   block [0x82EB02F0..0x82EB0BCC)
	// 82EB02F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB02F4: 4BDF90FD  bl 0x82ca93f0
	ctx.lr = 0x82EB02F8;
	sub_82CA93D0(ctx, base);
	// 82EB02F8: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82EB02FC: 4BDFD9DD  bl 0x82cadcd8
	ctx.lr = 0x82EB0300;
	sub_82CADCA0(ctx, base);
	// 82EB0300: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0308: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82EB030C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82EB0310: 4B3B06A9  bl 0x822609b8
	ctx.lr = 0x82EB0314;
	sub_822609B8(ctx, base);
	// 82EB0314: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0318: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EB031C: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0320: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0324: 4BFD1435  bl 0x82e81758
	ctx.lr = 0x82EB0328;
	sub_82E81758(ctx, base);
	// 82EB0328: 987F00C0  stb r3, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[3].u8 ) };
	// 82EB032C: C1BF0110  lfs f13, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0330: C19F0114  lfs f12, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0334: C17F0118  lfs f11, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0338: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB033C: 4182001C  beq 0x82eb0358
	if ctx.cr[0].eq {
	pc = 0x82EB0358; continue 'dispatch;
	}
	// 82EB0340: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0344: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB0348: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB034C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0350: C19F00E8  lfs f12, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0354: 48000018  b 0x82eb036c
	pc = 0x82EB036C; continue 'dispatch;
	// 82EB0358: C01F0144  lfs f0, 0x144(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB035C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB0360: C1BF0148  lfs f13, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0364: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0368: C19F014C  lfs f12, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB036C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0370: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0374: D19F00DC  stfs f12, 0xdc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EB0378: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EB037C: D1BF00D8  stfs f13, 0xd8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EB0380: 3B7F00F8  addi r27, r31, 0xf8
	ctx.r[27].s64 = ctx.r[31].s64 + 248;
	// 82EB0384: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EB0388: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82EB038C: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 82EB0390: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0394: D0170000  stfs f0, 0(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0398: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB039C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB03A0: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB03A4: D0170004  stfs f0, 4(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB03A8: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB03AC: D0170008  stfs f0, 8(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB03B0: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB03B4: D017000C  stfs f0, 0xc(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB03B8: 9B17001C  stb r24, 0x1c(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(28 as u32), ctx.r[24].u8 ) };
	// 82EB03BC: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB03C0: C3DB0000  lfs f30, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB03C4: C3BB0004  lfs f29, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB03C8: C39B0008  lfs f28, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EB03CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB03D0: 41820048  beq 0x82eb0418
	if ctx.cr[0].eq {
	pc = 0x82EB0418; continue 'dispatch;
	}
	// 82EB03D4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB03D8: 419A0040  beq cr6, 0x82eb0418
	if ctx.cr[6].eq {
	pc = 0x82EB0418; continue 'dispatch;
	}
	// 82EB03DC: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB03E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB03E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB03E8: 83ABFFFC  lwz r29, -4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB03EC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB03F0: 41820028  beq 0x82eb0418
	if ctx.cr[0].eq {
	pc = 0x82EB0418; continue 'dispatch;
	}
	// 82EB03F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB03F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB03FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0400: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EB0404: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB040C: 4E800421  bctrl
	ctx.lr = 0x82EB0410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0410: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0414: 41820020  beq 0x82eb0434
	if ctx.cr[0].eq {
	pc = 0x82EB0434; continue 'dispatch;
	}
	// 82EB0418: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EB041C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0420: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0424: 4E800421  bctrl
	ctx.lr = 0x82EB0428;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0428: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB042C: 41820008  beq 0x82eb0434
	if ctx.cr[0].eq {
	pc = 0x82EB0434; continue 'dispatch;
	}
	// 82EB0430: 9ADF00BC  stb r22, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[22].u8 ) };
	// 82EB0434: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EB0438: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB043C: 419A002C  beq cr6, 0x82eb0468
	if ctx.cr[6].eq {
	pc = 0x82EB0468; continue 'dispatch;
	}
	// 82EB0440: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0444: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB0448: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB044C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EB0450: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0458: 4E800421  bctrl
	ctx.lr = 0x82EB045C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB045C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB0460: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB0464: 409A00F0  bne cr6, 0x82eb0554
	if !ctx.cr[6].eq {
	pc = 0x82EB0554; continue 'dispatch;
	}
	// 82EB0468: 897F01B5  lbz r11, 0x1b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82EB046C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0470: 408200E0  bne 0x82eb0550
	if !ctx.cr[0].eq {
	pc = 0x82EB0550; continue 'dispatch;
	}
	// 82EB0474: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB0478: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB047C: 408200D4  bne 0x82eb0550
	if !ctx.cr[0].eq {
	pc = 0x82EB0550; continue 'dispatch;
	}
	// 82EB0480: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0484: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0488: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB048C: C19F00EC  lfs f12, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0490: EC0D6028  fsubs f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0494: C15F00E4  lfs f10, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB0498: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB049C: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB04A0: C19F00E8  lfs f12, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB04A4: C15F00F4  lfs f10, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB04A8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB04AC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB04B0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB04B4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB04B8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB04BC: 40990008  ble cr6, 0x82eb04c4
	if !ctx.cr[6].gt {
	pc = 0x82EB04C4; continue 'dispatch;
	}
	// 82EB04C0: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB04C4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB04C8: 4082002C  bne 0x82eb04f4
	if !ctx.cr[0].eq {
	pc = 0x82EB04F4; continue 'dispatch;
	}
	// 82EB04CC: 897F0094  lbz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB04D0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB04D4: 409A0020  bne cr6, 0x82eb04f4
	if !ctx.cr[6].eq {
	pc = 0x82EB04F4; continue 'dispatch;
	}
	// 82EB04D8: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB04DC: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB04E0: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82EB04E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB04E8: 4198000C  blt cr6, 0x82eb04f4
	if ctx.cr[6].lt {
	pc = 0x82EB04F4; continue 'dispatch;
	}
	// 82EB04EC: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB04F0: 9ADF01B5  stb r22, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[22].u8 ) };
	// 82EB04F4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB04F8: 4082005C  bne 0x82eb0554
	if !ctx.cr[0].eq {
	pc = 0x82EB0554; continue 'dispatch;
	}
	// 82EB04FC: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EB0500: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0504: 40820050  bne 0x82eb0554
	if !ctx.cr[0].eq {
	pc = 0x82EB0554; continue 'dispatch;
	}
	// 82EB0508: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB050C: 409A001C  bne cr6, 0x82eb0528
	if !ctx.cr[6].eq {
	pc = 0x82EB0528; continue 'dispatch;
	}
	// 82EB0510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0518: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EB051C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0520: 4E800421  bctrl
	ctx.lr = 0x82EB0524;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0524: 48000024  b 0x82eb0548
	pc = 0x82EB0548; continue 'dispatch;
	// 82EB0528: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB052C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB0530: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0534: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB0538: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB053C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0540: 4E800421  bctrl
	ctx.lr = 0x82EB0544;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0544: 987F0190  stb r3, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[3].u8 ) };
	// 82EB0548: 8BDF0190  lbz r30, 0x190(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB054C: 48000008  b 0x82eb0554
	pc = 0x82EB0554; continue 'dispatch;
	// 82EB0550: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB0554: 57DE063F  clrlwi. r30, r30, 0x18
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB0558: 4182006C  beq 0x82eb05c4
	if ctx.cr[0].eq {
	pc = 0x82EB05C4; continue 'dispatch;
	}
	// 82EB055C: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB0560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0564: 40820060  bne 0x82eb05c4
	if !ctx.cr[0].eq {
	pc = 0x82EB05C4; continue 'dispatch;
	}
	// 82EB0568: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB056C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0570: 9ADF00BE  stb r22, 0xbe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(190 as u32), ctx.r[22].u8 ) };
	// 82EB0574: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0578: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB057C: 4BFD16BD  bl 0x82e81c38
	ctx.lr = 0x82EB0580;
	sub_82E81C38(ctx, base);
	// 82EB0580: C01F0144  lfs f0, 0x144(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0584: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB0588: C01F0148  lfs f0, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB058C: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB0590: C01F014C  lfs f0, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0594: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB0598: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82EB059C: 815F0154  lwz r10, 0x154(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EB05A0: 893F00BF  lbz r9, 0xbf(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB05A4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05A8: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82EB05AC: 915F0138  stw r10, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[10].u32 ) };
	// 82EB05B0: 41820014  beq 0x82eb05c4
	if ctx.cr[0].eq {
	pc = 0x82EB05C4; continue 'dispatch;
	}
	// 82EB05B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB05B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB05BC: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB05C0: 4BFD1049  bl 0x82e81608
	ctx.lr = 0x82EB05C4;
	sub_82E81608(ctx, base);
	// 82EB05C4: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EB05C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05CC: 41820018  beq 0x82eb05e4
	if ctx.cr[0].eq {
	pc = 0x82EB05E4; continue 'dispatch;
	}
	// 82EB05D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB05D4: 419A05E4  beq cr6, 0x82eb0bb8
	if ctx.cr[6].eq {
	pc = 0x82EB0BB8; continue 'dispatch;
	}
	// 82EB05D8: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB05DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05E0: 418205D8  beq 0x82eb0bb8
	if ctx.cr[0].eq {
	pc = 0x82EB0BB8; continue 'dispatch;
	}
	// 82EB05E4: 897F00BE  lbz r11, 0xbe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(190 as u32) ) } as u64;
	// 82EB05E8: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82EB05EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05F0: 408201B8  bne 0x82eb07a8
	if !ctx.cr[0].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB05F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB05F8: 419A01B0  beq cr6, 0x82eb07a8
	if ctx.cr[6].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB05FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB0600: 419A002C  beq cr6, 0x82eb062c
	if ctx.cr[6].eq {
	pc = 0x82EB062C; continue 'dispatch;
	}
	// 82EB0604: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB060C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0610: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EB0614: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0618: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB061C: 4E800421  bctrl
	ctx.lr = 0x82EB0620;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0620: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB0624: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB0628: 409A0180  bne cr6, 0x82eb07a8
	if !ctx.cr[6].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB062C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0630: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0634: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0638: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EB063C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0640: 4BFD14B1  bl 0x82e81af0
	ctx.lr = 0x82EB0644;
	sub_82E81AF0(ctx, base);
	// 82EB0644: 9B1F00BC  stb r24, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[24].u8 ) };
	// 82EB0648: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB064C: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EB0650: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EB0654: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0658: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EB065C: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EB0660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0664: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0668: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EB066C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0670: 889F0190  lbz r4, 0x190(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB0674: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB0678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB067C: 4E800421  bctrl
	ctx.lr = 0x82EB0680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0680: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB0684: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0688: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB068C: 9B1F01B5  stb r24, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[24].u8 ) };
	// 82EB0690: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0694: 997F00BD  stb r11, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[11].u8 ) };
	// 82EB0698: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB069C: 4BFD164D  bl 0x82e81ce8
	ctx.lr = 0x82EB06A0;
	sub_82E81CE8(ctx, base);
	// 82EB06A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB06A4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB06A8: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB06AC: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB06B0: 4BFD13C1  bl 0x82e81a70
	ctx.lr = 0x82EB06B4;
	sub_82E81A70(ctx, base);
	// 82EB06B4: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB06B8: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EB06BC: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB06C0: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EB06C4: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB06C8: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82EB06CC: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB06D0: 815F0138  lwz r10, 0x138(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB06D4: 893F00BF  lbz r9, 0xbf(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB06D8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB06DC: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82EB06E0: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 82EB06E4: 4182000C  beq 0x82eb06f0
	if ctx.cr[0].eq {
	pc = 0x82EB06F0; continue 'dispatch;
	}
	// 82EB06E8: 9B1F00BD  stb r24, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[24].u8 ) };
	// 82EB06EC: 480004CC  b 0x82eb0bb8
	pc = 0x82EB0BB8; continue 'dispatch;
	// 82EB06F0: 897F00BD  lbz r11, 0xbd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB06F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB06F8: 418200B0  beq 0x82eb07a8
	if ctx.cr[0].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB06FC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB0700: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0704: 40820010  bne 0x82eb0714
	if !ctx.cr[0].eq {
	pc = 0x82EB0714; continue 'dispatch;
	}
	// 82EB0708: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB070C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0710: 41820098  beq 0x82eb07a8
	if ctx.cr[0].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB0714: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB0718: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EB071C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0720: 40820020  bne 0x82eb0740
	if !ctx.cr[0].eq {
	pc = 0x82EB0740; continue 'dispatch;
	}
	// 82EB0724: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB0728: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB072C: 4BFE2B05  bl 0x82e93230
	ctx.lr = 0x82EB0730;
	sub_82E93230(ctx, base);
	// 82EB0730: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB0734: 419A000C  beq cr6, 0x82eb0740
	if ctx.cr[6].eq {
	pc = 0x82EB0740; continue 'dispatch;
	}
	// 82EB0738: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB073C: 907F013C  stw r3, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[3].u32 ) };
	// 82EB0740: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0744: 40820050  bne 0x82eb0794
	if !ctx.cr[0].eq {
	pc = 0x82EB0794; continue 'dispatch;
	}
	// 82EB0748: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB074C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0750: 419A0024  beq cr6, 0x82eb0774
	if ctx.cr[6].eq {
	pc = 0x82EB0774; continue 'dispatch;
	}
	// 82EB0754: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0758: 931F013C  stw r24, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[24].u32 ) };
	// 82EB075C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0760: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0764: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0768: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB076C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0770: 48000020  b 0x82eb0790
	pc = 0x82EB0790; continue 'dispatch;
	// 82EB0774: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB0778: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82EB077C: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0780: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0784: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0788: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB078C: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0790: D01B0008  stfs f0, 8(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB0794: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB079C: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB07A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB07A4: 4E800421  bctrl
	ctx.lr = 0x82EB07A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB07A8: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB07AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB07B0: 41820020  beq 0x82eb07d0
	if ctx.cr[0].eq {
	pc = 0x82EB07D0; continue 'dispatch;
	}
	// 82EB07B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB07B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB07BC: 9B1F00BD  stb r24, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[24].u8 ) };
	// 82EB07C0: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB07C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB07C8: 4E800421  bctrl
	ctx.lr = 0x82EB07CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB07CC: 480003EC  b 0x82eb0bb8
	pc = 0x82EB0BB8; continue 'dispatch;
	// 82EB07D0: 897F00BD  lbz r11, 0xbd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB07D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB07D8: 4082000C  bne 0x82eb07e4
	if !ctx.cr[0].eq {
	pc = 0x82EB07E4; continue 'dispatch;
	}
	// 82EB07DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB07E0: 480003DC  b 0x82eb0bbc
	pc = 0x82EB0BBC; continue 'dispatch;
	// 82EB07E4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB07E8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EB07EC: 40820074  bne 0x82eb0860
	if !ctx.cr[0].eq {
	pc = 0x82EB0860; continue 'dispatch;
	}
	// 82EB07F0: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB07F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB07F8: 41820020  beq 0x82eb0818
	if ctx.cr[0].eq {
	pc = 0x82EB0818; continue 'dispatch;
	}
	// 82EB07FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0800: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0804: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB0808: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB080C: 4B2FF5E5  bl 0x821afdf0
	ctx.lr = 0x82EB0810;
	sub_821AFDF0(ctx, base);
	// 82EB0810: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB0814: 4800004C  b 0x82eb0860
	pc = 0x82EB0860; continue 'dispatch;
	// 82EB0818: 4B3B01A1  bl 0x822609b8
	ctx.lr = 0x82EB081C;
	sub_822609B8(ctx, base);
	// 82EB081C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0820: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB0824: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB0828: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB082C: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0830: C3EB004C  lfs f31, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB0834: 4BFD0E9D  bl 0x82e816d0
	ctx.lr = 0x82EB0838;
	sub_82E816D0(ctx, base);
	// 82EB0838: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB083C: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB0840: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EB0844: 4BFD0ABD  bl 0x82e81300
	ctx.lr = 0x82EB0848;
	sub_82E81300(ctx, base);
	// 82EB0848: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB084C: C00B0C4C  lfs f0, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0850: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0854: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EB0858: 40990008  ble cr6, 0x82eb0860
	if !ctx.cr[6].gt {
	pc = 0x82EB0860; continue 'dispatch;
	}
	// 82EB085C: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB0860: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0864: 418200CC  beq 0x82eb0930
	if ctx.cr[0].eq {
	pc = 0x82EB0930; continue 'dispatch;
	}
	// 82EB0868: 83DF013C  lwz r30, 0x13c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB086C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0870: 41820024  beq 0x82eb0894
	if ctx.cr[0].eq {
	pc = 0x82EB0894; continue 'dispatch;
	}
	// 82EB0874: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB0878: 419A001C  beq cr6, 0x82eb0894
	if ctx.cr[6].eq {
	pc = 0x82EB0894; continue 'dispatch;
	}
	// 82EB087C: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB0880: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB0884: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB0888: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB088C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0890: 4082006C  bne 0x82eb08fc
	if !ctx.cr[0].eq {
	pc = 0x82EB08FC; continue 'dispatch;
	}
	// 82EB0894: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82EB0898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB089C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB08A0: 40820014  bne 0x82eb08b4
	if !ctx.cr[0].eq {
	pc = 0x82EB08B4; continue 'dispatch;
	}
	// 82EB08A4: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EB08A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB08AC: 4E800421  bctrl
	ctx.lr = 0x82EB08B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB08B0: 48000038  b 0x82eb08e8
	pc = 0x82EB08E8; continue 'dispatch;
	// 82EB08B4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EB08B8: 409A0014  bne cr6, 0x82eb08cc
	if !ctx.cr[6].eq {
	pc = 0x82EB08CC; continue 'dispatch;
	}
	// 82EB08BC: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EB08C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB08C4: 4E800421  bctrl
	ctx.lr = 0x82EB08C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB08C8: 48000008  b 0x82eb08d0
	pc = 0x82EB08D0; continue 'dispatch;
	// 82EB08CC: 48003AA5  bl 0x82eb4370
	ctx.lr = 0x82EB08D0;
	sub_82EB4370(ctx, base);
	// 82EB08D0: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB08D4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB08D8: 419A0010  beq cr6, 0x82eb08e8
	if ctx.cr[6].eq {
	pc = 0x82EB08E8; continue 'dispatch;
	}
	// 82EB08DC: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82EB08E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB08E4: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82EB08E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB08EC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB08F0: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB08F4: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB08F8: 4B414941  bl 0x822c5238
	ctx.lr = 0x82EB08FC;
	sub_822C5238(ctx, base);
	// 82EB08FC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EB0900: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0904: 41820014  beq 0x82eb0918
	if ctx.cr[0].eq {
	pc = 0x82EB0918; continue 'dispatch;
	}
	// 82EB0908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB090C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0910: 4E800421  bctrl
	ctx.lr = 0x82EB0914;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0914: 4800001C  b 0x82eb0930
	pc = 0x82EB0930; continue 'dispatch;
	// 82EB0918: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB091C: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB0920: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0924: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB0928: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB092C: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB0930: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB0934: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0938: 41820148  beq 0x82eb0a80
	if ctx.cr[0].eq {
	pc = 0x82EB0A80; continue 'dispatch;
	}
	// 82EB093C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB0940: 419A0140  beq cr6, 0x82eb0a80
	if ctx.cr[6].eq {
	pc = 0x82EB0A80; continue 'dispatch;
	}
	// 82EB0944: 813F008C  lwz r9, 0x8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB0948: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB094C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EB0950: 806AFFFC  lwz r3, -4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB0954: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0958: 41820128  beq 0x82eb0a80
	if ctx.cr[0].eq {
	pc = 0x82EB0A80; continue 'dispatch;
	}
	// 82EB095C: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0960: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0964: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB0968: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB096C: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0970: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB0974: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB0978: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB097C: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0980: 9B010050  stb r24, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u8 ) };
	// 82EB0984: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB0988: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB098C: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0990: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0994: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82EB0998: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EB099C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB09A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB09A4: 4E800421  bctrl
	ctx.lr = 0x82EB09A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB09A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB09AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB09B0: 409A000C  bne cr6, 0x82eb09bc
	if !ctx.cr[6].eq {
	pc = 0x82EB09BC; continue 'dispatch;
	}
	// 82EB09B4: 9B1F01B4  stb r24, 0x1b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[24].u8 ) };
	// 82EB09B8: 4800001C  b 0x82eb09d4
	pc = 0x82EB09D4; continue 'dispatch;
	// 82EB09BC: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EB09C0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EB09C4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EB09C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB09CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB09D0: 4E800421  bctrl
	ctx.lr = 0x82EB09D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB09D4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB09D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB09DC: 4182008C  beq 0x82eb0a68
	if ctx.cr[0].eq {
	pc = 0x82EB0A68; continue 'dispatch;
	}
	// 82EB09E0: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB09E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB09E8: 41820014  beq 0x82eb09fc
	if ctx.cr[0].eq {
	pc = 0x82EB09FC; continue 'dispatch;
	}
	// 82EB09EC: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB09F0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB09F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB09F8: 930BFFFC  stw r24, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[24].u32 ) };
	// 82EB09FC: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB0A00: 813F007C  lwz r9, 0x7c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB0A04: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB0A08: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB0A0C: 4098002C  bge cr6, 0x82eb0a38
	if !ctx.cr[6].lt {
	pc = 0x82EB0A38; continue 'dispatch;
	}
	// 82EB0A10: 813F0088  lwz r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0A14: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 * 12;
	// 82EB0A18: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EB0A1C: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 82EB0A20: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A24: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0A28: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A2C: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB0A30: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A34: 48000018  b 0x82eb0a4c
	pc = 0x82EB0A4C; continue 'dispatch;
	// 82EB0A38: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A3C: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0A40: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A44: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB0A48: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A4C: D01B0008  stfs f0, 8(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB0A50: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A54: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB0A58: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A5C: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB0A60: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A64: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB0A68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0A6C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0A70: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0A74: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0A78: 4B4147C1  bl 0x822c5238
	ctx.lr = 0x82EB0A7C;
	sub_822C5238(ctx, base);
	// 82EB0A7C: 480000DC  b 0x82eb0b58
	pc = 0x82EB0B58; continue 'dispatch;
	// 82EB0A80: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB0A84: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EB0A88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0A8C: 41820020  beq 0x82eb0aac
	if ctx.cr[0].eq {
	pc = 0x82EB0AAC; continue 'dispatch;
	}
	// 82EB0A90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0A94: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0A98: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0A9C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0AA0: 4B2FF351  bl 0x821afdf0
	ctx.lr = 0x82EB0AA4;
	sub_821AFDF0(ctx, base);
	// 82EB0AA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB0AA8: 4800004C  b 0x82eb0af4
	pc = 0x82EB0AF4; continue 'dispatch;
	// 82EB0AAC: 4B3AFF0D  bl 0x822609b8
	ctx.lr = 0x82EB0AB0;
	sub_822609B8(ctx, base);
	// 82EB0AB0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0AB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB0AB8: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0ABC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0AC0: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0AC4: C3EB004C  lfs f31, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB0AC8: 4BFD0C09  bl 0x82e816d0
	ctx.lr = 0x82EB0ACC;
	sub_82E816D0(ctx, base);
	// 82EB0ACC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0AD0: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0AD4: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EB0AD8: 4BFD0829  bl 0x82e81300
	ctx.lr = 0x82EB0ADC;
	sub_82E81300(ctx, base);
	// 82EB0ADC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0AE0: C00B0A98  lfs f0, 0xa98(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0AE4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0AE8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EB0AEC: 40990008  ble cr6, 0x82eb0af4
	if !ctx.cr[6].gt {
	pc = 0x82EB0AF4; continue 'dispatch;
	}
	// 82EB0AF0: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB0AF4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0AF8: 41820030  beq 0x82eb0b28
	if ctx.cr[0].eq {
	pc = 0x82EB0B28; continue 'dispatch;
	}
	// 82EB0AFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0B00: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0B04: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0B08: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0B0C: 4B41472D  bl 0x822c5238
	ctx.lr = 0x82EB0B10;
	sub_822C5238(ctx, base);
	// 82EB0B10: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EB0B14: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 82EB0B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0B1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0B20: 4E800421  bctrl
	ctx.lr = 0x82EB0B24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0B24: 987F01B6  stb r3, 0x1b6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(438 as u32), ctx.r[3].u8 ) };
	// 82EB0B28: 897F01B6  lbz r11, 0x1b6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(438 as u32) ) } as u64;
	// 82EB0B2C: 38BF0104  addi r5, r31, 0x104
	ctx.r[5].s64 = ctx.r[31].s64 + 260;
	// 82EB0B30: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EB0B34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0B3C: 4182000C  beq 0x82eb0b48
	if ctx.cr[0].eq {
	pc = 0x82EB0B48; continue 'dispatch;
	}
	// 82EB0B40: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EB0B44: 48000008  b 0x82eb0b4c
	pc = 0x82EB0B4C; continue 'dispatch;
	// 82EB0B48: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82EB0B4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0B50: 4E800421  bctrl
	ctx.lr = 0x82EB0B54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0B54: 9B1F00BC  stb r24, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[24].u8 ) };
	// 82EB0B58: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0B5C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EB0B60: 409A0020  bne cr6, 0x82eb0b80
	if !ctx.cr[6].eq {
	pc = 0x82EB0B80; continue 'dispatch;
	}
	// 82EB0B64: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0B68: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EB0B6C: 409A0014  bne cr6, 0x82eb0b80
	if !ctx.cr[6].eq {
	pc = 0x82EB0B80; continue 'dispatch;
	}
	// 82EB0B70: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0B74: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82EB0B78: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 82EB0B7C: 419A0008  beq cr6, 0x82eb0b84
	if ctx.cr[6].eq {
	pc = 0x82EB0B84; continue 'dispatch;
	}
	// 82EB0B80: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 82EB0B84: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0B88: 41820018  beq 0x82eb0ba0
	if ctx.cr[0].eq {
	pc = 0x82EB0BA0; continue 'dispatch;
	}
	// 82EB0B8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0B94: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0B98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0B9C: 4E800421  bctrl
	ctx.lr = 0x82EB0BA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0BA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0BA4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EB0BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0BAC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB0BB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0BB4: 4E800421  bctrl
	ctx.lr = 0x82EB0BB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0BB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB0BBC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB0BC0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82EB0BC4: 4BDFD161  bl 0x82cadd24
	ctx.lr = 0x82EB0BC8;
	sub_82CADCEC(ctx, base);
	// 82EB0BC8: 4BDF8878  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0BD0 size=184
    let mut pc: u32 = 0x82EB0BD0;
    'dispatch: loop {
        match pc {
            0x82EB0BD0 => {
    //   block [0x82EB0BD0..0x82EB0C88)
	// 82EB0BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB0BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB0BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB0BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0BE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0BEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB0BF0: C1BF01A0  lfs f13, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0BF4: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0BF8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB0BFC: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0C00: C01F0124  lfs f0, 0x124(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0C04: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0C08: C19F011C  lfs f12, 0x11c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0C0C: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0C10: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0C14: C17F0120  lfs f11, 0x120(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0C18: C19F0114  lfs f12, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0C1C: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0C20: 419A0020  beq cr6, 0x82eb0c40
	if ctx.cr[6].eq {
	pc = 0x82EB0C40; continue 'dispatch;
	}
	// 82EB0C24: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0C28: C17F0198  lfs f11, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0C2C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB0C30: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB0C34: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB0C38: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EB0C3C: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB0C40: 4B3AFD79  bl 0x822609b8
	ctx.lr = 0x82EB0C44;
	sub_822609B8(ctx, base);
	// 82EB0C44: C1630058  lfs f11, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0C48: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0C4C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0C50: C1BF01A8  lfs f13, 0x1a8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0C54: C19F019C  lfs f12, 0x19c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0C58: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82EB0C5C: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 82EB0C60: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB0C64: D01F01A8  stfs f0, 0x1a8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82EB0C68: EDAB602A  fadds f13, f11, f12
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EB0C6C: D1BF019C  stfs f13, 0x19c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB0C70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB0C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB0C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB0C7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB0C80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB0C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0C88 size=156
    let mut pc: u32 = 0x82EB0C88;
    'dispatch: loop {
        match pc {
            0x82EB0C88 => {
    //   block [0x82EB0C88..0x82EB0D24)
	// 82EB0C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB0C90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB0C94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB0C98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0C9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0CA0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0CA4: 83E30184  lwz r31, 0x184(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(388 as u32) ) } as u64;
	// 82EB0CA8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0CAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB0CB0: D0030198  stfs f0, 0x198(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB0CB4: D003019C  stfs f0, 0x19c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB0CB8: 99630190  stb r11, 0x190(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 82EB0CBC: C1830110  lfs f12, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0CC0: C1A300F8  lfs f13, 0xf8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0CC4: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0CC8: C16300FC  lfs f11, 0xfc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0CCC: C1830114  lfs f12, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0CD0: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0CD4: C1430118  lfs f10, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB0CD8: C1630100  lfs f11, 0x100(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0CDC: D00301A8  stfs f0, 0x1a8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82EB0CE0: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB0CE4: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0CE8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB0CEC: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB0CF0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB0CF4: D00301A4  stfs f0, 0x1a4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82EB0CF8: 83CA0014  lwz r30, 0x14(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0CFC: 4B3AFCBD  bl 0x822609b8
	ctx.lr = 0x82EB0D00;
	sub_822609B8(ctx, base);
	// 82EB0D00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB0D04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB0D08: 4B414531  bl 0x822c5238
	ctx.lr = 0x82EB0D0C;
	sub_822C5238(ctx, base);
	// 82EB0D0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB0D10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB0D14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB0D18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB0D1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB0D20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0D28 size=192
    let mut pc: u32 = 0x82EB0D28;
    'dispatch: loop {
        match pc {
            0x82EB0D28 => {
    //   block [0x82EB0D28..0x82EB0DE8)
	// 82EB0D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0D2C: 4BDF86E1  bl 0x82ca940c
	ctx.lr = 0x82EB0D30;
	sub_82CA93D0(ctx, base);
	// 82EB0D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0D38: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB0D3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0D40: 408200A0  bne 0x82eb0de0
	if !ctx.cr[0].eq {
	pc = 0x82EB0DE0; continue 'dispatch;
	}
	// 82EB0D44: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0D48: 83DF0184  lwz r30, 0x184(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 82EB0D4C: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0D50: 4B3AFC69  bl 0x822609b8
	ctx.lr = 0x82EB0D54;
	sub_822609B8(ctx, base);
	// 82EB0D54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB0D58: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB0D5C: 4B2FF095  bl 0x821afdf0
	ctx.lr = 0x82EB0D60;
	sub_821AFDF0(ctx, base);
	// 82EB0D60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0D64: 4182007C  beq 0x82eb0de0
	if ctx.cr[0].eq {
	pc = 0x82EB0DE0; continue 'dispatch;
	}
	// 82EB0D68: C1BF019C  lfs f13, 0x19c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0D6C: C01F0194  lfs f0, 0x194(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0D70: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0D74: C19F0198  lfs f12, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0D78: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82EB0D7C: 41980030  blt cr6, 0x82eb0dac
	if ctx.cr[6].lt {
	pc = 0x82EB0DAC; continue 'dispatch;
	}
	// 82EB0D80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0D84: C16B0C14  lfs f11, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0D88: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EB0D8C: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0D90: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EB0D94: 41990018  bgt cr6, 0x82eb0dac
	if ctx.cr[6].gt {
	pc = 0x82EB0DAC; continue 'dispatch;
	}
	// 82EB0D98: C1BF01A4  lfs f13, 0x1a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0D9C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0DA0: C1BF01A8  lfs f13, 0x1a8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0DA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB0DA8: 40990028  ble cr6, 0x82eb0dd0
	if !ctx.cr[6].gt {
	pc = 0x82EB0DD0; continue 'dispatch;
	}
	// 82EB0DAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB0DB0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0DB4: 83DF0184  lwz r30, 0x184(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 82EB0DB8: 997F0190  stb r11, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 82EB0DBC: 83AA0014  lwz r29, 0x14(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0DC0: 4B3AFBF9  bl 0x822609b8
	ctx.lr = 0x82EB0DC4;
	sub_822609B8(ctx, base);
	// 82EB0DC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB0DC8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB0DCC: 4B41446D  bl 0x822c5238
	ctx.lr = 0x82EB0DD0;
	sub_822C5238(ctx, base);
	// 82EB0DD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0DD4: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0DD8: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB0DDC: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB0DE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB0DE4: 4BDF8678  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0DE8 size=44
    let mut pc: u32 = 0x82EB0DE8;
    'dispatch: loop {
        match pc {
            0x82EB0DE8 => {
    //   block [0x82EB0DE8..0x82EB0E14)
	// 82EB0DE8: 896300BE  lbz r11, 0xbe(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(190 as u32) ) } as u64;
	// 82EB0DEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0DF0: 40820024  bne 0x82eb0e14
	if !ctx.cr[0].eq {
		sub_82EB0E14(ctx, base);
		return;
	}
	// 82EB0DF4: 896300BF  lbz r11, 0xbf(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB0DF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0DFC: 40820018  bne 0x82eb0e14
	if !ctx.cr[0].eq {
		sub_82EB0E14(ctx, base);
		return;
	}
	// 82EB0E00: 896300BD  lbz r11, 0xbd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB0E04: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB0E08: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB0E0C: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EB0E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0E14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0E14 size=8
    let mut pc: u32 = 0x82EB0E14;
    'dispatch: loop {
        match pc {
            0x82EB0E14 => {
    //   block [0x82EB0E14..0x82EB0E1C)
	// 82EB0E14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB0E20 size=352
    let mut pc: u32 = 0x82EB0E20;
    'dispatch: loop {
        match pc {
            0x82EB0E20 => {
    //   block [0x82EB0E20..0x82EB0F80)
	// 82EB0E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0E24: 4BDF85E1  bl 0x82ca9404
	ctx.lr = 0x82EB0E28;
	sub_82CA93D0(ctx, base);
	// 82EB0E28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0E2C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0E30: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB0E34: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82EB0E38: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0E3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0E40: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB0E44: 4B3B6DDD  bl 0x82267c20
	ctx.lr = 0x82EB0E48;
	sub_82267C20(ctx, base);
	// 82EB0E48: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB0E4C: 4082000C  bne 0x82eb0e58
	if !ctx.cr[0].eq {
	pc = 0x82EB0E58; continue 'dispatch;
	}
	// 82EB0E50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0E54: 48000124  b 0x82eb0f78
	pc = 0x82EB0F78; continue 'dispatch;
	// 82EB0E58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB0E5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB0E60: 4BFCB469  bl 0x82e7c2c8
	ctx.lr = 0x82EB0E64;
	sub_82E7C2C8(ctx, base);
	// 82EB0E64: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EB0E68: 4182FFE8  beq 0x82eb0e50
	if ctx.cr[0].eq {
	pc = 0x82EB0E50; continue 'dispatch;
	}
	// 82EB0E6C: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB0E70: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EB0E74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0E78: 41820034  beq 0x82eb0eac
	if ctx.cr[0].eq {
	pc = 0x82EB0EAC; continue 'dispatch;
	}
	// 82EB0E7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0E80: 3B7F0070  addi r27, r31, 0x70
	ctx.r[27].s64 = ctx.r[31].s64 + 112;
	// 82EB0E84: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB0E88: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB0E8C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EB0E90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0E94: 4E800421  bctrl
	ctx.lr = 0x82EB0E98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0E98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0E9C: 40820018  bne 0x82eb0eb4
	if !ctx.cr[0].eq {
	pc = 0x82EB0EB4; continue 'dispatch;
	}
	// 82EB0EA0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB0EA4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB0EA8: 4800000C  b 0x82eb0eb4
	pc = 0x82EB0EB4; continue 'dispatch;
	// 82EB0EAC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB0EB0: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB0EB4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0EB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB0EBC: 38AB70AC  addi r5, r11, 0x70ac
	ctx.r[5].s64 = ctx.r[11].s64 + 28844;
	// 82EB0EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB0EC4: 4BFDC1CD  bl 0x82e8d090
	ctx.lr = 0x82EB0EC8;
	sub_82E8D090(ctx, base);
	// 82EB0EC8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB0ECC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0ED0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB0ED4: 38AB5D84  addi r5, r11, 0x5d84
	ctx.r[5].s64 = ctx.r[11].s64 + 23940;
	// 82EB0ED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB0EDC: 915F0174  stw r10, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 82EB0EE0: 4BFDC1B1  bl 0x82e8d090
	ctx.lr = 0x82EB0EE4;
	sub_82E8D090(ctx, base);
	// 82EB0EE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0EE8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB0EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0EF0: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB0EF4: 915F0178  stw r10, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[10].u32 ) };
	// 82EB0EF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0EFC: 4E800421  bctrl
	ctx.lr = 0x82EB0F00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0F04: 4182002C  beq 0x82eb0f30
	if ctx.cr[0].eq {
	pc = 0x82EB0F30; continue 'dispatch;
	}
	// 82EB0F08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0F10: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB0F14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F18: 4E800421  bctrl
	ctx.lr = 0x82EB0F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F20: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB0F24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB0F28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F2C: 4E800421  bctrl
	ctx.lr = 0x82EB0F30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0F38: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB0F3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F40: 4E800421  bctrl
	ctx.lr = 0x82EB0F44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0F48: 4182002C  beq 0x82eb0f74
	if ctx.cr[0].eq {
	pc = 0x82EB0F74; continue 'dispatch;
	}
	// 82EB0F4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0F54: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB0F58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F5C: 4E800421  bctrl
	ctx.lr = 0x82EB0F60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F64: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB0F68: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0F6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F70: 4E800421  bctrl
	ctx.lr = 0x82EB0F74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB0F78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB0F7C: 4BDF84D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB0F80 size=432
    let mut pc: u32 = 0x82EB0F80;
    'dispatch: loop {
        match pc {
            0x82EB0F80 => {
    //   block [0x82EB0F80..0x82EB1130)
	// 82EB0F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0F84: 4BDF8485  bl 0x82ca9408
	ctx.lr = 0x82EB0F88;
	sub_82CA93D0(ctx, base);
	// 82EB0F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0F8C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB0F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0F94: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EB0F98: 409A0020  bne cr6, 0x82eb0fb8
	if !ctx.cr[6].eq {
	pc = 0x82EB0FB8; continue 'dispatch;
	}
	// 82EB0F9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB0FA0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EB0FA4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EB0FA8: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB0FAC: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 82EB0FB0: 917F0178  stw r11, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82EB0FB4: 480000AC  b 0x82eb1060
	pc = 0x82EB1060; continue 'dispatch;
	// 82EB0FB8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0FBC: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82EB0FC0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0FC4: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB0FC8: 4B3B6C59  bl 0x82267c20
	ctx.lr = 0x82EB0FCC;
	sub_82267C20(ctx, base);
	// 82EB0FCC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB0FD0: 4082000C  bne 0x82eb0fdc
	if !ctx.cr[0].eq {
	pc = 0x82EB0FDC; continue 'dispatch;
	}
	// 82EB0FD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0FD8: 48000114  b 0x82eb10ec
	pc = 0x82EB10EC; continue 'dispatch;
	// 82EB0FDC: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB0FE0: 939F006C  stw r28, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82EB0FE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0FE8: 4182003C  beq 0x82eb1024
	if ctx.cr[0].eq {
	pc = 0x82EB1024; continue 'dispatch;
	}
	// 82EB0FEC: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB0FF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB0FF4: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0FF8: 4182002C  beq 0x82eb1024
	if ctx.cr[0].eq {
	pc = 0x82EB1024; continue 'dispatch;
	}
	// 82EB0FFC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1000: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82EB1004: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1008: 80E70084  lwz r7, 0x84(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EB100C: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EB1010: 419A00E4  beq cr6, 0x82eb10f4
	if ctx.cr[6].eq {
	pc = 0x82EB10F4; continue 'dispatch;
	}
	// 82EB1014: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB1018: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB101C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB1020: 4198FFE4  blt cr6, 0x82eb1004
	if ctx.cr[6].lt {
	pc = 0x82EB1004; continue 'dispatch;
	}
	// 82EB1024: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB1028: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB102C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1030: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB1034: 38AB70AC  addi r5, r11, 0x70ac
	ctx.r[5].s64 = ctx.r[11].s64 + 28844;
	// 82EB1038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB103C: 4BFDC055  bl 0x82e8d090
	ctx.lr = 0x82EB1040;
	sub_82E8D090(ctx, base);
	// 82EB1040: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB1044: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1048: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB104C: 38AB5D84  addi r5, r11, 0x5d84
	ctx.r[5].s64 = ctx.r[11].s64 + 23940;
	// 82EB1050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB1054: 915F0174  stw r10, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 82EB1058: 4BFDC039  bl 0x82e8d090
	ctx.lr = 0x82EB105C;
	sub_82E8D090(ctx, base);
	// 82EB105C: 907F0178  stw r3, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[3].u32 ) };
	// 82EB1060: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1068: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB106C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1070: 4E800421  bctrl
	ctx.lr = 0x82EB1074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1074: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1078: 4182002C  beq 0x82eb10a4
	if ctx.cr[0].eq {
	pc = 0x82EB10A4; continue 'dispatch;
	}
	// 82EB107C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1084: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB1088: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB108C: 4E800421  bctrl
	ctx.lr = 0x82EB1090;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1094: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB1098: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB109C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10A0: 4E800421  bctrl
	ctx.lr = 0x82EB10A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB10A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB10AC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB10B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10B4: 4E800421  bctrl
	ctx.lr = 0x82EB10B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB10BC: 4182002C  beq 0x82eb10e8
	if ctx.cr[0].eq {
	pc = 0x82EB10E8; continue 'dispatch;
	}
	// 82EB10C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB10C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB10C8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB10CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10D0: 4E800421  bctrl
	ctx.lr = 0x82EB10D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB10D8: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB10DC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB10E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10E4: 4E800421  bctrl
	ctx.lr = 0x82EB10E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB10EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB10F0: 4BDF8368  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 82EB10F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB10F8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EB10FC: 348B0004  addic. r4, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EB1100: 4182FF24  beq 0x82eb1024
	if ctx.cr[0].eq {
	pc = 0x82EB1024; continue 'dispatch;
	}
	// 82EB1104: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1108: 3BBF0070  addi r29, r31, 0x70
	ctx.r[29].s64 = ctx.r[31].s64 + 112;
	// 82EB110C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB1110: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EB1114: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1118: 4E800421  bctrl
	ctx.lr = 0x82EB111C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB111C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1120: 4082FF0C  bne 0x82eb102c
	if !ctx.cr[0].eq {
	pc = 0x82EB102C; continue 'dispatch;
	}
	// 82EB1124: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB1128: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB112C: 4BFFFF00  b 0x82eb102c
	pc = 0x82EB102C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB1130 size=12
    let mut pc: u32 = 0x82EB1130;
    'dispatch: loop {
        match pc {
            0x82EB1130 => {
    //   block [0x82EB1130..0x82EB113C)
	// 82EB1130: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB1134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB1138: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB113C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB113C size=24
    let mut pc: u32 = 0x82EB113C;
    'dispatch: loop {
        match pc {
            0x82EB113C => {
    //   block [0x82EB113C..0x82EB1154)
	// 82EB113C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1140: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EB1144: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB1148: 816A0090  lwz r11, 0x90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB114C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1150: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1154(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB1154 size=4
    let mut pc: u32 = 0x82EB1154;
    'dispatch: loop {
        match pc {
            0x82EB1154 => {
    //   block [0x82EB1154..0x82EB1158)
	// 82EB1154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB1158 size=12
    let mut pc: u32 = 0x82EB1158;
    'dispatch: loop {
        match pc {
            0x82EB1158 => {
    //   block [0x82EB1158..0x82EB1164)
	// 82EB1158: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB115C: 996301B5  stb r11, 0x1b5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(437 as u32), ctx.r[11].u8 ) };
	// 82EB1160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB1168 size=12
    let mut pc: u32 = 0x82EB1168;
    'dispatch: loop {
        match pc {
            0x82EB1168 => {
    //   block [0x82EB1168..0x82EB1174)
	// 82EB1168: 816300A4  lwz r11, 0xa4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB116C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1170: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB1178 size=24
    let mut pc: u32 = 0x82EB1178;
    'dispatch: loop {
        match pc {
            0x82EB1178 => {
    //   block [0x82EB1178..0x82EB1190)
	// 82EB1178: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB117C: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82EB1180: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82EB1184: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB1188: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB118C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB1190 size=1012
    let mut pc: u32 = 0x82EB1190;
    'dispatch: loop {
        match pc {
            0x82EB1190 => {
    //   block [0x82EB1190..0x82EB1584)
	// 82EB1190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1194: 4BDF826D  bl 0x82ca9400
	ctx.lr = 0x82EB1198;
	sub_82CA93D0(ctx, base);
	// 82EB1198: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB119C: 4BDFCB3D  bl 0x82cadcd8
	ctx.lr = 0x82EB11A0;
	sub_82CADCA0(ctx, base);
	// 82EB11A0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB11A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB11A8: 3BDF00F8  addi r30, r31, 0xf8
	ctx.r[30].s64 = ctx.r[31].s64 + 248;
	// 82EB11AC: 3BBF0104  addi r29, r31, 0x104
	ctx.r[29].s64 = ctx.r[31].s64 + 260;
	// 82EB11B0: 3B7F0110  addi r27, r31, 0x110
	ctx.r[27].s64 = ctx.r[31].s64 + 272;
	// 82EB11B4: 3B9F0074  addi r28, r31, 0x74
	ctx.r[28].s64 = ctx.r[31].s64 + 116;
	// 82EB11B8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB11BC: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB11C0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB11C4: 409A0028  bne cr6, 0x82eb11ec
	if !ctx.cr[6].eq {
	pc = 0x82EB11EC; continue 'dispatch;
	}
	// 82EB11C8: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB11CC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB11D0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB11D4: 409A0018  bne cr6, 0x82eb11ec
	if !ctx.cr[6].eq {
	pc = 0x82EB11EC; continue 'dispatch;
	}
	// 82EB11D8: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB11DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB11E0: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB11E4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB11E8: 419A0008  beq cr6, 0x82eb11f0
	if ctx.cr[6].eq {
	pc = 0x82EB11F0; continue 'dispatch;
	}
	// 82EB11EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB11F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB11F4: 41820020  beq 0x82eb1214
	if ctx.cr[0].eq {
	pc = 0x82EB1214; continue 'dispatch;
	}
	// 82EB11F8: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB11FC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB1200: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB1204: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1208: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB120C: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB1210: 48000364  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB1214: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB1218: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB121C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1220: 409802D0  bge cr6, 0x82eb14f0
	if !ctx.cr[6].lt {
	pc = 0x82EB14F0; continue 'dispatch;
	}
	// 82EB1224: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1228: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB122C: 811F01BC  lwz r8, 0x1bc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB1230: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB1234: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1238: 409A02B8  bne cr6, 0x82eb14f0
	if !ctx.cr[6].eq {
	pc = 0x82EB14F0; continue 'dispatch;
	}
	// 82EB123C: 815F013C  lwz r10, 0x13c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB1240: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1244: 419902AC  bgt cr6, 0x82eb14f0
	if ctx.cr[6].gt {
	pc = 0x82EB14F0; continue 'dispatch;
	}
	// 82EB1248: 835F0188  lwz r26, 0x188(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB124C: 4B3AF76D  bl 0x822609b8
	ctx.lr = 0x82EB1250;
	sub_822609B8(ctx, base);
	// 82EB1250: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EB1254: 4BFD00AD  bl 0x82e81300
	ctx.lr = 0x82EB1258;
	sub_82E81300(ctx, base);
	// 82EB1258: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB125C: C3AB0C18  lfs f29, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB1260: FF01E800  fcmpu cr6, f1, f29
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 82EB1264: 419A0010  beq cr6, 0x82eb1274
	if ctx.cr[6].eq {
	pc = 0x82EB1274; continue 'dispatch;
	}
	// 82EB1268: C01F01C4  lfs f0, 0x1c4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB126C: EF800072  fmuls f28, f0, f1
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EB1270: 480001C0  b 0x82eb1430
	pc = 0x82EB1430; continue 'dispatch;
	// 82EB1274: 4B3AF745  bl 0x822609b8
	ctx.lr = 0x82EB1278;
	sub_822609B8(ctx, base);
	// 82EB1278: C01F01C4  lfs f0, 0x1c4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB127C: C1A30058  lfs f13, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1280: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1284: 480001AC  b 0x82eb1430
	pc = 0x82EB1430; continue 'dispatch;
	// 82EB1288: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB128C: C11D0000  lfs f8, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB1290: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB1294: C0FD0004  lfs f7, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EB1298: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82EB129C: C0DD0008  lfs f6, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EB12A0: D1010070  stfs f8, 0x70(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EB12A4: D0E10074  stfs f7, 0x74(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EB12A8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB12AC: D0C10078  stfs f6, 0x78(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EB12B0: D3A10050  stfs f29, 0x50(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB12B4: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB12B8: D3A10058  stfs f29, 0x58(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB12BC: 41980070  blt cr6, 0x82eb132c
	if ctx.cr[6].lt {
	pc = 0x82EB132C; continue 'dispatch;
	}
	// 82EB12C0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB12C4: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB12C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB12CC: 409A0028  bne cr6, 0x82eb12f4
	if !ctx.cr[6].eq {
	pc = 0x82EB12F4; continue 'dispatch;
	}
	// 82EB12D0: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB12D4: C17F00E4  lfs f11, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB12D8: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82EB12DC: 409A0018  bne cr6, 0x82eb12f4
	if !ctx.cr[6].eq {
	pc = 0x82EB12F4; continue 'dispatch;
	}
	// 82EB12E0: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB12E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB12E8: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB12EC: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82EB12F0: 419A0008  beq cr6, 0x82eb12f8
	if ctx.cr[6].eq {
	pc = 0x82EB12F8; continue 'dispatch;
	}
	// 82EB12F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB12F8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB12FC: 41820018  beq 0x82eb1314
	if ctx.cr[0].eq {
	pc = 0x82EB1314; continue 'dispatch;
	}
	// 82EB1300: C19F00E4  lfs f12, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1304: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1308: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB130C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1310: 48000040  b 0x82eb1350
	pc = 0x82EB1350; continue 'dispatch;
	// 82EB1314: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1318: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EB131C: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1320: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1324: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1328: 48000028  b 0x82eb1350
	pc = 0x82EB1350; continue 'dispatch;
	// 82EB132C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB1330: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1334: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB1338: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB133C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1340: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1344: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1348: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB134C: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1350: ED4D4028  fsubs f10, f13, f8
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB1354: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1358: EC0C3828  fsubs f0, f12, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB135C: ED2B3028  fsubs f9, f11, f6
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EB1360: ED4A02B2  fmuls f10, f10, f10
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EB1364: EC00503A  fmadds f0, f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EB1368: EC09027A  fmadds f0, f9, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB136C: EFE0002C  fsqrts f31, f0
	ctx.f[31].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB1370: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EB1374: 419A0014  beq cr6, 0x82eb1388
	if ctx.cr[6].eq {
	pc = 0x82EB1388; continue 'dispatch;
	}
	// 82EB1378: C01F01C0  lfs f0, 0x1c0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB137C: EFDC002A  fadds f30, f28, f0
	ctx.f[30].f64 = ((ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB1380: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82EB1384: 419800B8  blt cr6, 0x82eb143c
	if ctx.cr[6].lt {
	pc = 0x82EB143C; continue 'dispatch;
	}
	// 82EB1388: C01F01C0  lfs f0, 0x1c0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB138C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB1390: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB1394: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EB1398: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EB139C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB13A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB13A4: EF9C0028  fsubs f28, f28, f0
	ctx.f[28].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB13A8: 4B3D7D71  bl 0x82289118
	ctx.lr = 0x82EB13AC;
	sub_82289118(ctx, base);
	// 82EB13AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB13B0: 408200E0  bne 0x82eb1490
	if !ctx.cr[0].eq {
	pc = 0x82EB1490; continue 'dispatch;
	}
	// 82EB13B4: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB13B8: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB13BC: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB13C0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB13C4: D1BD0004  stfs f13, 4(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB13C8: D19D0008  stfs f12, 8(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB13CC: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB13D0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB13D4: 409A0020  bne cr6, 0x82eb13f4
	if !ctx.cr[6].eq {
	pc = 0x82EB13F4; continue 'dispatch;
	}
	// 82EB13D8: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB13DC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB13E0: 409A0014  bne cr6, 0x82eb13f4
	if !ctx.cr[6].eq {
	pc = 0x82EB13F4; continue 'dispatch;
	}
	// 82EB13E4: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB13E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB13EC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EB13F0: 419A0008  beq cr6, 0x82eb13f8
	if ctx.cr[6].eq {
	pc = 0x82EB13F8; continue 'dispatch;
	}
	// 82EB13F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB13F8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB13FC: 408200EC  bne 0x82eb14e8
	if !ctx.cr[0].eq {
	pc = 0x82EB14E8; continue 'dispatch;
	}
	// 82EB1400: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB1404: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB1408: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB140C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1410: 40980008  bge cr6, 0x82eb1418
	if !ctx.cr[6].lt {
	pc = 0x82EB1418; continue 'dispatch;
	}
	// 82EB1414: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB1418: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB141C: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1420: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB1424: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB1428: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB142C: D3BF01C0  stfs f29, 0x1c0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB1430: FF1CE800  fcmpu cr6, f28, f29
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[29].f64);
	// 82EB1434: 4199FE54  bgt cr6, 0x82eb1288
	if ctx.cr[6].gt {
	pc = 0x82EB1288; continue 'dispatch;
	}
	// 82EB1438: 4800013C  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB143C: EDAD4028  fsubs f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB1440: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB1444: EC1EF824  fdivs f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 82EB1448: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EB144C: ED8C3828  fsubs f12, f12, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB1450: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EB1454: ED6B3028  fsubs f11, f11, f6
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EB1458: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB145C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB1460: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1464: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1468: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB146C: EDAD402A  fadds f13, f13, f8
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EB1470: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1474: EDAC382A  fadds f13, f12, f7
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EB1478: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB147C: EC00302A  fadds f0, f0, f6
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64;
	// 82EB1480: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1484: 4B3D7C95  bl 0x82289118
	ctx.lr = 0x82EB1488;
	sub_82289118(ctx, base);
	// 82EB1488: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB148C: 4182003C  beq 0x82eb14c8
	if ctx.cr[0].eq {
	pc = 0x82EB14C8; continue 'dispatch;
	}
	// 82EB1490: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1494: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB1498: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB149C: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB14A0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14A4: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB14A8: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB14AC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB14B0: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB14B4: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB14B8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB14BC: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB14C0: D3BF01C0  stfs f29, 0x1c0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB14C4: 480000B0  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB14C8: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14CC: D3DF01C0  stfs f30, 0x1c0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB14D0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB14D4: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14D8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB14DC: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14E0: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB14E4: 48000090  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB14E8: D3FF01C0  stfs f31, 0x1c0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB14EC: 48000088  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB14F0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB14F4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14F8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB14FC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1500: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1504: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB1508: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB150C: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB1510: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1514: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB1518: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB151C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1520: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1524: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1528: 409A0028  bne cr6, 0x82eb1550
	if !ctx.cr[6].eq {
	pc = 0x82EB1550; continue 'dispatch;
	}
	// 82EB152C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1530: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1534: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1538: 409A0018  bne cr6, 0x82eb1550
	if !ctx.cr[6].eq {
	pc = 0x82EB1550; continue 'dispatch;
	}
	// 82EB153C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1540: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB1544: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1548: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB154C: 419A0008  beq cr6, 0x82eb1554
	if ctx.cr[6].eq {
	pc = 0x82EB1554; continue 'dispatch;
	}
	// 82EB1550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB1554: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1558: 41820010  beq 0x82eb1568
	if ctx.cr[0].eq {
	pc = 0x82EB1568; continue 'dispatch;
	}
	// 82EB155C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1560: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1564: 4800000C  b 0x82eb1570
	pc = 0x82EB1570; continue 'dispatch;
	// 82EB1568: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB156C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1570: D01F01C0  stfs f0, 0x1c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB1574: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB1578: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB157C: 4BDFC7A9  bl 0x82cadd24
	ctx.lr = 0x82EB1580;
	sub_82CADCEC(ctx, base);
	// 82EB1580: 4BDF7ED0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1588 size=72
    let mut pc: u32 = 0x82EB1588;
    'dispatch: loop {
        match pc {
            0x82EB1588 => {
    //   block [0x82EB1588..0x82EB15D0)
	// 82EB1588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB158C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB1594: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB159C: 386001D0  li r3, 0x1d0
	ctx.r[3].s64 = 464;
	// 82EB15A0: 4B765389  bl 0x82616928
	ctx.lr = 0x82EB15A4;
	sub_82616928(ctx, base);
	// 82EB15A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB15A8: 41820010  beq 0x82eb15b8
	if ctx.cr[0].eq {
	pc = 0x82EB15B8; continue 'dispatch;
	}
	// 82EB15AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB15B0: 4BFFEA69  bl 0x82eb0018
	ctx.lr = 0x82EB15B4;
	sub_82EB0018(ctx, base);
	// 82EB15B4: 48000008  b 0x82eb15bc
	pc = 0x82EB15BC; continue 'dispatch;
	// 82EB15B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB15BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB15C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB15C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB15C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB15CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB15D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB15D0 size=228
    let mut pc: u32 = 0x82EB15D0;
    'dispatch: loop {
        match pc {
            0x82EB15D0 => {
    //   block [0x82EB15D0..0x82EB16B4)
	// 82EB15D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB15D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB15D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB15DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB15E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB15E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB15E8: 396BA3B0  addi r11, r11, -0x5c50
	ctx.r[11].s64 = ctx.r[11].s64 + -23632;
	// 82EB15EC: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB15F0: 388A5E98  addi r4, r10, 0x5e98
	ctx.r[4].s64 = ctx.r[10].s64 + 24216;
	// 82EB15F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB15F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB15FC: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB1600: 4B3B6621  bl 0x82267c20
	ctx.lr = 0x82EB1604;
	sub_82267C20(ctx, base);
	// 82EB1604: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1608: 4182001C  beq 0x82eb1624
	if ctx.cr[0].eq {
	pc = 0x82EB1624; continue 'dispatch;
	}
	// 82EB160C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1610: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB1614: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB1618: 388B1130  addi r4, r11, 0x1130
	ctx.r[4].s64 = ctx.r[11].s64 + 4400;
	// 82EB161C: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1620: 4BFE6EC1  bl 0x82e984e0
	ctx.lr = 0x82EB1624;
	sub_82E984E0(ctx, base);
	// 82EB1624: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB1628: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB162C: 41820034  beq 0x82eb1660
	if ctx.cr[0].eq {
	pc = 0x82EB1660; continue 'dispatch;
	}
	// 82EB1630: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB1634: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EB1638: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB163C: 419A0020  beq cr6, 0x82eb165c
	if ctx.cr[6].eq {
	pc = 0x82EB165C; continue 'dispatch;
	}
	// 82EB1640: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1644: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB1648: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EB164C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1654: 4E800421  bctrl
	ctx.lr = 0x82EB1658;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1658: 48000008  b 0x82eb1660
	pc = 0x82EB1660; continue 'dispatch;
	// 82EB165C: 4B994155  bl 0x828457b0
	ctx.lr = 0x82EB1660;
	sub_828457B0(ctx, base);
	// 82EB1660: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB1664: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1668: 41820018  beq 0x82eb1680
	if ctx.cr[0].eq {
	pc = 0x82EB1680; continue 'dispatch;
	}
	// 82EB166C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1670: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EB1674: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB167C: 4E800421  bctrl
	ctx.lr = 0x82EB1680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1680: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB1684: 4BFE18ED  bl 0x82e92f70
	ctx.lr = 0x82EB1688;
	sub_82E92F70(ctx, base);
	// 82EB1688: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB168C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1690: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB1694: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EB1698: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EB169C: 4BFD41DD  bl 0x82e85878
	ctx.lr = 0x82EB16A0;
	sub_82E85878(ctx, base);
	// 82EB16A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB16A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB16A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB16AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB16B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB16B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB16B8 size=320
    let mut pc: u32 = 0x82EB16B8;
    'dispatch: loop {
        match pc {
            0x82EB16B8 => {
    //   block [0x82EB16B8..0x82EB17F8)
	// 82EB16B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB16BC: 4BDF7D51  bl 0x82ca940c
	ctx.lr = 0x82EB16C0;
	sub_82CA93D0(ctx, base);
	// 82EB16C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB16C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB16C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB16CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB16D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB16D4: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB16D8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB16DC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB16E0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB16E4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB16E8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB16EC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB16F0: 4B3AF2C9  bl 0x822609b8
	ctx.lr = 0x82EB16F4;
	sub_822609B8(ctx, base);
	// 82EB16F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB16F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB16FC: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1700: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EB1704: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB1708: 995F00BE  stb r10, 0xbe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(190 as u32), ctx.r[10].u8 ) };
	// 82EB170C: 995F00BC  stb r10, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 82EB1710: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1714: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB1718: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB171C: 4E800421  bctrl
	ctx.lr = 0x82EB1720;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1720: C01F0110  lfs f0, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1724: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82EB1728: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB172C: C01F0114  lfs f0, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1730: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB1734: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82EB1738: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB173C: C01F0118  lfs f0, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1744: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EB1748: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB174C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1750: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1754: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82EB1758: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB175C: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82EB1760: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1764: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82EB1768: 995F01B4  stb r10, 0x1b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[10].u8 ) };
	// 82EB176C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1770: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB1774: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1778: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB177C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1780: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB1784: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1788: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EB178C: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1790: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EB1794: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1798: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EB179C: 4BFFEB55  bl 0x82eb02f0
	ctx.lr = 0x82EB17A0;
	sub_82EB02F0(ctx, base);
	// 82EB17A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB17A4: 4082000C  bne 0x82eb17b0
	if !ctx.cr[0].eq {
	pc = 0x82EB17B0; continue 'dispatch;
	}
	// 82EB17A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB17AC: 48000044  b 0x82eb17f0
	pc = 0x82EB17F0; continue 'dispatch;
	// 82EB17B0: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EB17B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB17B8: 40820034  bne 0x82eb17ec
	if !ctx.cr[0].eq {
	pc = 0x82EB17EC; continue 'dispatch;
	}
	// 82EB17BC: 897F01B4  lbz r11, 0x1b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB17C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB17C4: 41820028  beq 0x82eb17ec
	if ctx.cr[0].eq {
	pc = 0x82EB17EC; continue 'dispatch;
	}
	// 82EB17C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB17CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB17D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB17D4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EB17D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB17DC: 4E800421  bctrl
	ctx.lr = 0x82EB17E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB17E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB17E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB17E8: 41820008  beq 0x82eb17f0
	if ctx.cr[0].eq {
	pc = 0x82EB17F0; continue 'dispatch;
	}
	// 82EB17EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB17F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB17F4: 4BDF7C68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB17F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB17F8 size=1040
    let mut pc: u32 = 0x82EB17F8;
    'dispatch: loop {
        match pc {
            0x82EB17F8 => {
    //   block [0x82EB17F8..0x82EB1C08)
	// 82EB17F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB17FC: 4BDF7C11  bl 0x82ca940c
	ctx.lr = 0x82EB1800;
	sub_82CA93D0(ctx, base);
	// 82EB1800: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EB1804: 4BDFC4C1  bl 0x82cadcc4
	ctx.lr = 0x82EB1808;
	sub_82CADCA0(ctx, base);
	// 82EB1808: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB180C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EB1810: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB1814: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82EB1818: 394A115C  addi r10, r10, 0x115c
	ctx.r[10].s64 = ctx.r[10].s64 + 4444;
	// 82EB181C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1820: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82EB1824: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1828: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB182C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB1830: 409A0028  bne cr6, 0x82eb1858
	if !ctx.cr[6].eq {
	pc = 0x82EB1858; continue 'dispatch;
	}
	// 82EB1834: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1838: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB183C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB1840: 409A0018  bne cr6, 0x82eb1858
	if !ctx.cr[6].eq {
	pc = 0x82EB1858; continue 'dispatch;
	}
	// 82EB1844: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1848: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB184C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1850: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB1854: 419A0008  beq cr6, 0x82eb185c
	if ctx.cr[6].eq {
	pc = 0x82EB185C; continue 'dispatch;
	}
	// 82EB1858: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82EB185C: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB1860: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB1864: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB1868: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB186C: C3280C18  lfs f25, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EB1870: C2E90EE0  lfs f23, 0xee0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3808 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82EB1874: C30A0C14  lfs f24, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EB1878: 418202C0  beq 0x82eb1b38
	if ctx.cr[0].eq {
	pc = 0x82EB1B38; continue 'dispatch;
	}
	// 82EB187C: 815F0164  lwz r10, 0x164(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB1880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB1884: 419A00C0  beq cr6, 0x82eb1944
	if ctx.cr[6].eq {
	pc = 0x82EB1944; continue 'dispatch;
	}
	// 82EB1888: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EB188C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EB1890: 4BFD44D9  bl 0x82e85d68
	ctx.lr = 0x82EB1894;
	sub_82E85D68(ctx, base);
	// 82EB1894: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1898: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB189C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB18A0: C00B0044  lfs f0, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB18A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB18A8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB18AC: C1AB0A44  lfs f13, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB18B4: 40990014  ble cr6, 0x82eb18c8
	if !ctx.cr[6].gt {
	pc = 0x82EB18C8; continue 'dispatch;
	}
	// 82EB18B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB18BC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18C0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB18C4: 48000020  b 0x82eb18e4
	pc = 0x82EB18E4; continue 'dispatch;
	// 82EB18C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB18CC: C1AB89C8  lfs f13, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB18D4: 40980010  bge cr6, 0x82eb18e4
	if !ctx.cr[6].lt {
	pc = 0x82EB18E4; continue 'dispatch;
	}
	// 82EB18D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB18DC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18E0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB18E4: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EB18E8: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18EC: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB18F0: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EB18F4: 40980034  bge cr6, 0x82eb1928
	if !ctx.cr[6].lt {
	pc = 0x82EB1928; continue 'dispatch;
	}
	// 82EB18F8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EB18FC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1900: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82EB1904: 41980010  blt cr6, 0x82eb1914
	if ctx.cr[6].lt {
	pc = 0x82EB1914; continue 'dispatch;
	}
	// 82EB1908: FF00C000  fcmpu cr6, f0, f24
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[24].f64);
	// 82EB190C: 41990008  bgt cr6, 0x82eb1914
	if ctx.cr[6].gt {
	pc = 0x82EB1914; continue 'dispatch;
	}
	// 82EB1910: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EB1914: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EB1918: 409AFFE8  bne cr6, 0x82eb1900
	if !ctx.cr[6].eq {
	pc = 0x82EB1900; continue 'dispatch;
	}
	// 82EB191C: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1920: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1924: 48000214  b 0x82eb1b38
	pc = 0x82EB1B38; continue 'dispatch;
	// 82EB1928: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82EB192C: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1930: 4099000C  ble cr6, 0x82eb193c
	if !ctx.cr[6].gt {
	pc = 0x82EB193C; continue 'dispatch;
	}
	// 82EB1934: D30B0008  stfs f24, 8(r11)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1938: 48000200  b 0x82eb1b38
	pc = 0x82EB1B38; continue 'dispatch;
	// 82EB193C: D2EB0008  stfs f23, 8(r11)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1940: 480001F8  b 0x82eb1b38
	pc = 0x82EB1B38; continue 'dispatch;
	// 82EB1944: 815F0160  lwz r10, 0x160(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB1948: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB194C: 419A02A8  beq cr6, 0x82eb1bf4
	if ctx.cr[6].eq {
	pc = 0x82EB1BF4; continue 'dispatch;
	}
	// 82EB1950: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1954: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB1958: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB195C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EB1960: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1964: D3210054  stfs f25, 0x54(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1968: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB196C: 4B3CD8FD  bl 0x8227f268
	ctx.lr = 0x82EB1970;
	sub_8227F268(ctx, base);
	// 82EB1970: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1974: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1978: C3E30008  lfs f31, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB197C: C3C30000  lfs f30, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB1980: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1984: C1AB0050  lfs f13, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1988: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB198C: C1AB0054  lfs f13, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1990: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1994: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB1998: EC2C07BA  fmadds f1, f12, f30, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB199C: FF01C000  fcmpu cr6, f1, f24
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[24].f64);
	// 82EB19A0: 4198000C  blt cr6, 0x82eb19ac
	if ctx.cr[6].lt {
	pc = 0x82EB19AC; continue 'dispatch;
	}
	// 82EB19A4: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	// 82EB19A8: 48000020  b 0x82eb19c8
	pc = 0x82EB19C8; continue 'dispatch;
	// 82EB19AC: FF01B800  fcmpu cr6, f1, f23
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[23].f64);
	// 82EB19B0: 41990010  bgt cr6, 0x82eb19c0
	if ctx.cr[6].gt {
	pc = 0x82EB19C0; continue 'dispatch;
	}
	// 82EB19B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB19B8: C00BA3A4  lfs f0, -0x5c5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB19BC: 4800000C  b 0x82eb19c8
	pc = 0x82EB19C8; continue 'dispatch;
	// 82EB19C0: 4B3AEF81  bl 0x82260940
	ctx.lr = 0x82EB19C4;
	sub_82260940(ctx, base);
	// 82EB19C4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB19C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB19CC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB19D0: C1AB004C  lfs f13, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB19D4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB19D8: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB19DC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB19E0: EDAC6FB8  fmsubs f13, f12, f30, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB19E4: FF0DC800  fcmpu cr6, f13, f25
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[25].f64);
	// 82EB19E8: C1ABDF1C  lfs f13, -0x20e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB19EC: 4099000C  ble cr6, 0x82eb19f8
	if !ctx.cr[6].gt {
	pc = 0x82EB19F8; continue 'dispatch;
	}
	// 82EB19F0: EFC06824  fdivs f30, f0, f13
	ctx.f[30].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EB19F4: 4800000C  b 0x82eb1a00
	pc = 0x82EB1A00; continue 'dispatch;
	// 82EB19F8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EB19FC: FFC00050  fneg f30, f0
	ctx.f[30].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB1A00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1A04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB1A08: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB1A0C: FF60F210  fabs f27, f30
	ctx.f[27].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82EB1A10: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1A14: C3AA0A44  lfs f29, 0xa44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2628 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB1A18: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EB1A1C: C3E989CC  lfs f31, -0x7634(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB1A20: C0030044  lfs f0, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1A24: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EB1A28: C38A89C8  lfs f28, -0x7638(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EB1A2C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EB1A30: 4099000C  ble cr6, 0x82eb1a3c
	if !ctx.cr[6].gt {
	pc = 0x82EB1A3C; continue 'dispatch;
	}
	// 82EB1A34: EF40F828  fsubs f26, f0, f31
	ctx.f[26].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EB1A38: 48000018  b 0x82eb1a50
	pc = 0x82EB1A50; continue 'dispatch;
	// 82EB1A3C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EB1A40: 4098000C  bge cr6, 0x82eb1a4c
	if !ctx.cr[6].lt {
	pc = 0x82EB1A4C; continue 'dispatch;
	}
	// 82EB1A44: EF40F82A  fadds f26, f0, f31
	ctx.f[26].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB1A48: 48000008  b 0x82eb1a50
	pc = 0x82EB1A50; continue 'dispatch;
	// 82EB1A4C: FF400090  fmr f26, f0
	ctx.f[26].f64 = ctx.f[0].f64;
	// 82EB1A50: 895D001C  lbz r10, 0x1c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EB1A54: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1A58: 41820058  beq 0x82eb1ab0
	if ctx.cr[0].eq {
	pc = 0x82EB1AB0; continue 'dispatch;
	}
	// 82EB1A5C: 895F0069  lbz r10, 0x69(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(105 as u32) ) } as u64;
	// 82EB1A60: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1A64: 4182004C  beq 0x82eb1ab0
	if ctx.cr[0].eq {
	pc = 0x82EB1AB0; continue 'dispatch;
	}
	// 82EB1A68: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB1A6C: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB1A70: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB1A74: 388AC904  addi r4, r10, -0x36fc
	ctx.r[4].s64 = ctx.r[10].s64 + -14076;
	// 82EB1A78: 4BFCBC49  bl 0x82e7d6c0
	ctx.lr = 0x82EB1A7C;
	sub_82E7D6C0(ctx, base);
	// 82EB1A7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1A80: 4182003C  beq 0x82eb1abc
	if ctx.cr[0].eq {
	pc = 0x82EB1ABC; continue 'dispatch;
	}
	// 82EB1A84: C01D0014  lfs f0, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1A88: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EB1A8C: 4099000C  ble cr6, 0x82eb1a98
	if !ctx.cr[6].gt {
	pc = 0x82EB1A98; continue 'dispatch;
	}
	// 82EB1A90: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EB1A94: 48000010  b 0x82eb1aa4
	pc = 0x82EB1AA4; continue 'dispatch;
	// 82EB1A98: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EB1A9C: 40980008  bge cr6, 0x82eb1aa4
	if !ctx.cr[6].lt {
	pc = 0x82EB1AA4; continue 'dispatch;
	}
	// 82EB1AA0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB1AA4: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB1AA8: 9BC30004  stb r30, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1AAC: 48000010  b 0x82eb1abc
	pc = 0x82EB1ABC; continue 'dispatch;
	// 82EB1AB0: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1AB4: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EB1AB8: 40980010  bge cr6, 0x82eb1ac8
	if !ctx.cr[6].lt {
	pc = 0x82EB1AC8; continue 'dispatch;
	}
	// 82EB1ABC: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB1AC0: D34B0008  stfs f26, 8(r11)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1AC4: 4BFFFE5C  b 0x82eb1920
	pc = 0x82EB1920; continue 'dispatch;
	// 82EB1AC8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1ACC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB1AD0: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EB1AD4: 4B336BA5  bl 0x821e8678
	ctx.lr = 0x82EB1AD8;
	sub_821E8678(ctx, base);
	// 82EB1AD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1ADC: 40820018  bne 0x82eb1af4
	if !ctx.cr[0].eq {
	pc = 0x82EB1AF4; continue 'dispatch;
	}
	// 82EB1AE0: C01F0050  lfs f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1AE4: EC00D824  fdivs f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[27].f64) as f32) as f64;
	// 82EB1AE8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1AEC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1AF0: 48000014  b 0x82eb1b04
	pc = 0x82EB1B04; continue 'dispatch;
	// 82EB1AF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1AF8: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1AFC: C00B0BF8  lfs f0, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B00: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1B04: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB1B08: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1B0C: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB1B10: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B14: FF1EC800  fcmpu cr6, f30, f25
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[25].f64);
	// 82EB1B18: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1B1C: C1AA0044  lfs f13, 0x44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1B20: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1B24: 4099000C  ble cr6, 0x82eb1b30
	if !ctx.cr[6].gt {
	pc = 0x82EB1B30; continue 'dispatch;
	}
	// 82EB1B28: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB1B2C: 48000008  b 0x82eb1b34
	pc = 0x82EB1B34; continue 'dispatch;
	// 82EB1B30: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB1B34: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B38: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB1B3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1B40: 41820040  beq 0x82eb1b80
	if ctx.cr[0].eq {
	pc = 0x82EB1B80; continue 'dispatch;
	}
	// 82EB1B44: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1B48: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B4C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1B50: C1AA0058  lfs f13, 0x58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1B54: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1B58: 4099000C  ble cr6, 0x82eb1b64
	if !ctx.cr[6].gt {
	pc = 0x82EB1B64; continue 'dispatch;
	}
	// 82EB1B5C: D30B0008  stfs f24, 8(r11)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B60: 48000034  b 0x82eb1b94
	pc = 0x82EB1B94; continue 'dispatch;
	// 82EB1B64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1B68: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1B6C: 4098000C  bge cr6, 0x82eb1b78
	if !ctx.cr[6].lt {
	pc = 0x82EB1B78; continue 'dispatch;
	}
	// 82EB1B70: D2EB0008  stfs f23, 8(r11)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B74: 48000024  b 0x82eb1b98
	pc = 0x82EB1B98; continue 'dispatch;
	// 82EB1B78: D32B0008  stfs f25, 8(r11)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B7C: 4800001C  b 0x82eb1b98
	pc = 0x82EB1B98; continue 'dispatch;
	// 82EB1B80: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB1B84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1B88: 4182006C  beq 0x82eb1bf4
	if ctx.cr[0].eq {
	pc = 0x82EB1BF4; continue 'dispatch;
	}
	// 82EB1B8C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B90: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B94: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1B98: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82EB1B9C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1BA0: 4182004C  beq 0x82eb1bec
	if ctx.cr[0].eq {
	pc = 0x82EB1BEC; continue 'dispatch;
	}
	// 82EB1BA4: 896B0004  lbz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1BA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1BAC: 41820040  beq 0x82eb1bec
	if ctx.cr[0].eq {
	pc = 0x82EB1BEC; continue 'dispatch;
	}
	// 82EB1BB0: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82EB1BB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1BB8: 4182003C  beq 0x82eb1bf4
	if ctx.cr[0].eq {
	pc = 0x82EB1BF4; continue 'dispatch;
	}
	// 82EB1BBC: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1BC0: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1BC4: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1BC8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1BCC: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1BD0: EC00C03C  fnmsubs f0, f0, f0, f24
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[24].f64) as f32) as f64);
	// 82EB1BD4: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB1BD8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1BDC: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1BE0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB1BE4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1BE8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1BEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB1BF0: 48000008  b 0x82eb1bf8
	pc = 0x82EB1BF8; continue 'dispatch;
	// 82EB1BF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB1BF8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB1BFC: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EB1C00: 4BDFC111  bl 0x82cadd10
	ctx.lr = 0x82EB1C04;
	sub_82CADCEC(ctx, base);
	// 82EB1C04: 4BDF7858  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB1C08 size=748
    let mut pc: u32 = 0x82EB1C08;
    'dispatch: loop {
        match pc {
            0x82EB1C08 => {
    //   block [0x82EB1C08..0x82EB1EF4)
	// 82EB1C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1C0C: 4BDF77F5  bl 0x82ca9400
	ctx.lr = 0x82EB1C10;
	sub_82CA93D0(ctx, base);
	// 82EB1C10: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB1C14: 4BDFC091  bl 0x82cadca4
	ctx.lr = 0x82EB1C18;
	sub_82CADCA0(ctx, base);
	// 82EB1C18: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1C1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB1C20: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB1C24: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB1C28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1C2C: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EB1C30: C17E0000  lfs f11, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1C34: C19D0000  lfs f12, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1C38: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB1C3C: C13E0004  lfs f9, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB1C40: C15D0004  lfs f10, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB1C44: ED4A4828  fsubs f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB1C48: C11D0008  lfs f8, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB1C4C: C13E0008  lfs f9, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB1C50: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1C54: ED284828  fsubs f9, f8, f9
	ctx.f[9].f64 = (((ctx.f[8].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB1C58: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1C5C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1C60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1C64: ED0C02F2  fmuls f8, f12, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1C68: C30B0C18  lfs f24, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EB1C6C: ECEA0372  fmuls f7, f10, f13
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1C70: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1C74: EDA94378  fmsubs f13, f9, f13, f8
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB1C78: EC0C3838  fmsubs f0, f12, f0, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB1C7C: ED8A32F8  fmsubs f12, f10, f11, f6
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EB1C80: ED6D0372  fmuls f11, f13, f13
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1C84: ED60583A  fmadds f11, f0, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB1C88: ED6C5B3A  fmadds f11, f12, f12, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB1C8C: ED60582C  fsqrts f11, f11
	ctx.f[11].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 82EB1C90: FF0BC000  fcmpu cr6, f11, f24
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[24].f64);
	// 82EB1C94: 419A0244  beq cr6, 0x82eb1ed8
	if ctx.cr[6].eq {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1C98: 815F0158  lwz r10, 0x158(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB1C9C: C15F0060  lfs f10, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB1CA0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1CA4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1CA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB1CAC: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EB1CB0: C12A0004  lfs f9, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB1CB4: ED695824  fdivs f11, f9, f11
	ctx.f[11].f64 = ((ctx.f[9].f64 / ctx.f[11].f64) as f32) as f64;
	// 82EB1CB8: 80690014  lwz r3, 0x14(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1CBC: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EB1CC0: EECC02F2  fmuls f22, f12, f11
	ctx.f[22].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1CC4: EEAD02F2  fmuls f21, f13, f11
	ctx.f[21].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1CC8: EE8002F2  fmuls f20, f0, f11
	ctx.f[20].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1CCC: 4B3369AD  bl 0x821e8678
	ctx.lr = 0x82EB1CD0;
	sub_821E8678(ctx, base);
	// 82EB1CD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB1CD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1CD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1CDC: 3F608334  lis r27, -0x7ccc
	ctx.r[27].s64 = -2093744128;
	// 82EB1CE0: C1EA0C14  lfs f15, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 82EB1CE4: C22B0BFC  lfs f17, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82EB1CE8: 41820010  beq 0x82eb1cf8
	if ctx.cr[0].eq {
	pc = 0x82EB1CF8; continue 'dispatch;
	}
	// 82EB1CEC: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1CF0: EE600472  fmuls f19, f0, f17
	ctx.f[19].f64 = (((ctx.f[0].f64 * ctx.f[17].f64) as f32) as f64);
	// 82EB1CF4: 4800001C  b 0x82eb1d10
	pc = 0x82EB1D10; continue 'dispatch;
	// 82EB1CF8: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB1CFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1D00: 4182000C  beq 0x82eb1d0c
	if ctx.cr[0].eq {
	pc = 0x82EB1D0C; continue 'dispatch;
	}
	// 82EB1D04: C26B000C  lfs f19, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82EB1D08: 48000008  b 0x82eb1d10
	pc = 0x82EB1D10; continue 'dispatch;
	// 82EB1D0C: FE607890  fmr f19, f15
	ctx.f[19].f64 = ctx.f[15].f64;
	// 82EB1D10: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82EB1D14: C25F0058  lfs f18, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82EB1D18: D3010050  stfs f24, 0x50(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1D1C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB1D20: D3010054  stfs f24, 0x54(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1D24: D3010058  stfs f24, 0x58(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1D28: D3010060  stfs f24, 0x60(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1D2C: C20B84AC  lfs f16, -0x7b54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31572 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 82EB1D30: D3010064  stfs f24, 0x64(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB1D34: D3010068  stfs f24, 0x68(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1D38: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1D3C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82EB1D40: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D44: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1D48: 409A002C  bne cr6, 0x82eb1d74
	if !ctx.cr[6].eq {
	pc = 0x82EB1D74; continue 'dispatch;
	}
	// 82EB1D4C: EFC0B02A  fadds f30, f0, f22
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[22].f64) as f32) as f64;
	// 82EB1D50: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1D54: EFB5682A  fadds f29, f21, f13
	ctx.f[29].f64 = ((ctx.f[21].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB1D58: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D5C: EF80A02A  fadds f28, f0, f20
	ctx.f[28].f64 = ((ctx.f[0].f64 + ctx.f[20].f64) as f32) as f64;
	// 82EB1D60: EC16682A  fadds f0, f22, f13
	ctx.f[0].f64 = ((ctx.f[22].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB1D64: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D68: ED8CA82A  fadds f12, f12, f21
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[21].f64) as f32) as f64;
	// 82EB1D6C: EDB4682A  fadds f13, f20, f13
	ctx.f[13].f64 = ((ctx.f[20].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB1D70: 48000028  b 0x82eb1d98
	pc = 0x82EB1D98; continue 'dispatch;
	// 82EB1D74: EFC0B028  fsubs f30, f0, f22
	ctx.f[30].f64 = (((ctx.f[0].f64 - ctx.f[22].f64) as f32) as f64);
	// 82EB1D78: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1D7C: EFADA828  fsubs f29, f13, f21
	ctx.f[29].f64 = (((ctx.f[13].f64 - ctx.f[21].f64) as f32) as f64);
	// 82EB1D80: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D84: EF80A028  fsubs f28, f0, f20
	ctx.f[28].f64 = (((ctx.f[0].f64 - ctx.f[20].f64) as f32) as f64);
	// 82EB1D88: EC0DB028  fsubs f0, f13, f22
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[22].f64) as f32) as f64);
	// 82EB1D8C: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D90: ED8CA828  fsubs f12, f12, f21
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[21].f64) as f32) as f64);
	// 82EB1D94: EDADA028  fsubs f13, f13, f20
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[20].f64) as f32) as f64);
	// 82EB1D98: ED8CE828  fsubs f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EB1D9C: ED60F028  fsubs f11, f0, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82EB1DA0: EDADE028  fsubs f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EB1DA4: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB1DA8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB1DAC: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB1DB0: EEE0002C  fsqrts f23, f0
	ctx.f[23].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB1DB4: FF17C000  fcmpu cr6, f23, f24
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[24].f64);
	// 82EB1DB8: 419A0120  beq cr6, 0x82eb1ed8
	if ctx.cr[6].eq {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1DBC: EC0FB824  fdivs f0, f15, f23
	ctx.f[0].f64 = ((ctx.f[15].f64 / ctx.f[23].f64) as f32) as f64;
	// 82EB1DC0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB1DC4: FFE0C090  fmr f31, f24
	ctx.f[31].f64 = ctx.f[24].f64;
	// 82EB1DC8: EF6002F2  fmuls f27, f0, f11
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1DCC: EF400332  fmuls f26, f0, f12
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB1DD0: EF200372  fmuls f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1DD4: FF1FB800  fcmpu cr6, f31, f23
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[23].f64);
	// 82EB1DD8: 41990100  bgt cr6, 0x82eb1ed8
	if ctx.cr[6].gt {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1DDC: EDBA07F2  fmuls f13, f26, f31
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB1DE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1DE4: EC1B07F2  fmuls f0, f27, f31
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB1DE8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB1DEC: ED72982A  fadds f11, f18, f19
	ctx.f[11].f64 = ((ctx.f[18].f64 + ctx.f[19].f64) as f32) as f64;
	// 82EB1DF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB1DF4: ED9907F2  fmuls f12, f25, f31
	ctx.f[12].f64 = (((ctx.f[25].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB1DF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EB1DFC: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 82EB1E00: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1E04: EDADE82A  fadds f13, f13, f29
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EB1E08: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1E0C: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EB1E10: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1E14: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1E18: ED8CE02A  fadds f12, f12, f28
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EB1E1C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1E20: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1E24: EC0D5828  fsubs f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB1E28: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB1E2C: 4B77D6E5  bl 0x8262f510
	ctx.lr = 0x82EB1E30;
	sub_8262F510(ctx, base);
	// 82EB1E30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1E34: 418200B8  beq 0x82eb1eec
	if ctx.cr[0].eq {
	pc = 0x82EB1EEC; continue 'dispatch;
	}
	// 82EB1E38: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB1E3C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB1E40: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1E44: 4182000C  beq 0x82eb1e50
	if ctx.cr[0].eq {
	pc = 0x82EB1E50; continue 'dispatch;
	}
	// 82EB1E48: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1E4C: 48000008  b 0x82eb1e54
	pc = 0x82EB1E54; continue 'dispatch;
	// 82EB1E50: FC007890  fmr f0, f15
	ctx.f[0].f64 = ctx.f[15].f64;
	// 82EB1E54: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB1E58: 2B1C0002  cmplwi cr6, r28, 2
	ctx.cr[6].compare_u32(ctx.r[28].u32, 2 as u32, &mut ctx.xer);
	// 82EB1E5C: 4198FF78  blt cr6, 0x82eb1dd4
	if ctx.cr[6].lt {
	pc = 0x82EB1DD4; continue 'dispatch;
	}
	// 82EB1E60: FF1FB800  fcmpu cr6, f31, f23
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[23].f64);
	// 82EB1E64: 41990074  bgt cr6, 0x82eb1ed8
	if ctx.cr[6].gt {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1E68: EC17F828  fsubs f0, f23, f31
	ctx.f[0].f64 = (((ctx.f[23].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EB1E6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1E70: ED529C3A  fmadds f10, f18, f16, f19
	ctx.f[10].f64 = (((ctx.f[18].f64 * ctx.f[16].f64 + ctx.f[19].f64) as f32) as f64);
	// 82EB1E74: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB1E78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB1E7C: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 82EB1E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EB1E84: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1E88: EC00FC7A  fmadds f0, f0, f17, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[17].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EB1E8C: EDBB0032  fmuls f13, f27, f0
	ctx.f[13].f64 = (((ctx.f[27].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1E90: ED9A0032  fmuls f12, f26, f0
	ctx.f[12].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1E94: ED790032  fmuls f11, f25, f0
	ctx.f[11].f64 = (((ctx.f[25].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1E98: EC0DF02A  fadds f0, f13, f30
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EB1E9C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1EA0: EDACE82A  fadds f13, f12, f29
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EB1EA4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1EA8: ED8BE02A  fadds f12, f11, f28
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EB1EAC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1EB0: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1EB4: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1EB8: EC0D5028  fsubs f0, f13, f10
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB1EBC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB1EC0: 4B77D651  bl 0x8262f510
	ctx.lr = 0x82EB1EC4;
	sub_8262F510(ctx, base);
	// 82EB1EC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1EC8: 41820024  beq 0x82eb1eec
	if ctx.cr[0].eq {
	pc = 0x82EB1EEC; continue 'dispatch;
	}
	// 82EB1ECC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EB1ED0: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 82EB1ED4: 4198FE64  blt cr6, 0x82eb1d38
	if ctx.cr[6].lt {
	pc = 0x82EB1D38; continue 'dispatch;
	}
	// 82EB1ED8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB1EDC: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82EB1EE0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB1EE4: 4BDFBE0D  bl 0x82cadcf0
	ctx.lr = 0x82EB1EE8;
	sub_82CADCEC(ctx, base);
	// 82EB1EE8: 4BDF7568  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 82EB1EEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB1EF0: 4BFFFFEC  b 0x82eb1edc
	pc = 0x82EB1EDC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1EF8 size=108
    let mut pc: u32 = 0x82EB1EF8;
    'dispatch: loop {
        match pc {
            0x82EB1EF8 => {
    //   block [0x82EB1EF8..0x82EB1F64)
	// 82EB1EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1F00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1F04: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB1F08: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82EB1F0C: 8124006C  lwz r9, 0x6c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB1F10: 81030060  lwz r8, 0x60(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB1F14: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB1F18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1F1C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82EB1F20: 7C8B5396  divwu r4, r11, r10
	ctx.r[4].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EB1F24: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB1F28: 4098002C  bge cr6, 0x82eb1f54
	if !ctx.cr[6].lt {
	pc = 0x82EB1F54; continue 'dispatch;
	}
	// 82EB1F2C: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB1F30: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB1F34: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1F38: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EB1F3C: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82EB1F40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1F44: 80630064  lwz r3, 0x64(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB1F48: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EB1F4C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EB1F50: 4BFD71A9  bl 0x82e890f8
	ctx.lr = 0x82EB1F54;
	sub_82E890F8(ctx, base);
	// 82EB1F54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB1F58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB1F5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB1F60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1F68 size=88
    let mut pc: u32 = 0x82EB1F68;
    'dispatch: loop {
        match pc {
            0x82EB1F68 => {
    //   block [0x82EB1F68..0x82EB1FC0)
	// 82EB1F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1F70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB1F74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB1F78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1F80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB1F84: 4BFFF64D  bl 0x82eb15d0
	ctx.lr = 0x82EB1F88;
	sub_82EB15D0(ctx, base);
	// 82EB1F88: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1F8C: 41820018  beq 0x82eb1fa4
	if ctx.cr[0].eq {
	pc = 0x82EB1FA4; continue 'dispatch;
	}
	// 82EB1F90: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB1F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1F98: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB1F9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1FA0: 4E800421  bctrl
	ctx.lr = 0x82EB1FA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1FA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB1FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB1FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB1FB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB1FB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB1FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB1FC0 size=480
    let mut pc: u32 = 0x82EB1FC0;
    'dispatch: loop {
        match pc {
            0x82EB1FC0 => {
    //   block [0x82EB1FC0..0x82EB21A0)
	// 82EB1FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1FC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB1FCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB1FD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1FD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB1FD8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1FDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1FE0: 388B60C0  addi r4, r11, 0x60c0
	ctx.r[4].s64 = ctx.r[11].s64 + 24768;
	// 82EB1FE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB1FE8: 4BFD76F9  bl 0x82e896e0
	ctx.lr = 0x82EB1FEC;
	sub_82E896E0(ctx, base);
	// 82EB1FEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1FF0: 41820020  beq 0x82eb2010
	if ctx.cr[0].eq {
	pc = 0x82EB2010; continue 'dispatch;
	}
	// 82EB1FF4: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1FF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1FFC: 41820014  beq 0x82eb2010
	if ctx.cr[0].eq {
	pc = 0x82EB2010; continue 'dispatch;
	}
	// 82EB2000: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB2004: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB2008: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB200C: 419A017C  beq cr6, 0x82eb2188
	if ctx.cr[6].eq {
	pc = 0x82EB2188; continue 'dispatch;
	}
	// 82EB2010: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB2014: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2018: 41820090  beq 0x82eb20a8
	if ctx.cr[0].eq {
	pc = 0x82EB20A8; continue 'dispatch;
	}
	// 82EB201C: 80BF0070  lwz r5, 0x70(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB2020: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 82EB2024: 419A0084  beq cr6, 0x82eb20a8
	if ctx.cr[6].eq {
	pc = 0x82EB20A8; continue 'dispatch;
	}
	// 82EB2028: 897E0058  lbz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB202C: 815E0050  lwz r10, 0x50(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB2030: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2034: 41820074  beq 0x82eb20a8
	if ctx.cr[0].eq {
	pc = 0x82EB20A8; continue 'dispatch;
	}
	// 82EB2038: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB203C: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB2040: 409A0040  bne cr6, 0x82eb2080
	if !ctx.cr[6].eq {
	pc = 0x82EB2080; continue 'dispatch;
	}
	// 82EB2044: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB2048: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB204C: 419A0028  beq cr6, 0x82eb2074
	if ctx.cr[6].eq {
	pc = 0x82EB2074; continue 'dispatch;
	}
	// 82EB2050: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB2054: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB2058: 4098001C  bge cr6, 0x82eb2074
	if !ctx.cr[6].lt {
	pc = 0x82EB2074; continue 'dispatch;
	}
	// 82EB205C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB2060: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 82EB2064: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB2068: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB206C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB2070: 409A0008  bne cr6, 0x82eb2078
	if !ctx.cr[6].eq {
	pc = 0x82EB2078; continue 'dispatch;
	}
	// 82EB2074: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2078: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB207C: 4800010C  b 0x82eb2188
	pc = 0x82EB2188; continue 'dispatch;
	// 82EB2080: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2084: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EB2088: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB208C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB2090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2094: 4E800421  bctrl
	ctx.lr = 0x82EB2098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2098: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB209C: 4182000C  beq 0x82eb20a8
	if ctx.cr[0].eq {
	pc = 0x82EB20A8; continue 'dispatch;
	}
	// 82EB20A0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB20A4: 4BFFFFA0  b 0x82eb2044
	pc = 0x82EB2044; continue 'dispatch;
	// 82EB20A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB20AC: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82EB20B0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB20B4: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB20B8: 396B0034  addi r11, r11, 0x34
	ctx.r[11].s64 = ctx.r[11].s64 + 52;
	// 82EB20BC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB20C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB20C4: 409A0028  bne cr6, 0x82eb20ec
	if !ctx.cr[6].eq {
	pc = 0x82EB20EC; continue 'dispatch;
	}
	// 82EB20C8: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB20CC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB20D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB20D4: 409A0018  bne cr6, 0x82eb20ec
	if !ctx.cr[6].eq {
	pc = 0x82EB20EC; continue 'dispatch;
	}
	// 82EB20D8: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB20DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB20E0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB20E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB20E8: 419A0008  beq cr6, 0x82eb20f0
	if ctx.cr[6].eq {
	pc = 0x82EB20F0; continue 'dispatch;
	}
	// 82EB20EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB20F0: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB20F4: 4182007C  beq 0x82eb2170
	if ctx.cr[0].eq {
	pc = 0x82EB2170; continue 'dispatch;
	}
	// 82EB20F8: 895F01C8  lbz r10, 0x1c8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 82EB20FC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2100: 40820068  bne 0x82eb2168
	if !ctx.cr[0].eq {
	pc = 0x82EB2168; continue 'dispatch;
	}
	// 82EB2104: 815F00A0  lwz r10, 0xa0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB2108: 3BDF01CC  addi r30, r31, 0x1cc
	ctx.r[30].s64 = ctx.r[31].s64 + 460;
	// 82EB210C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB2110: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB2114: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EB2118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB211C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB2120: 4E800421  bctrl
	ctx.lr = 0x82EB2124;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2124: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB2128: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB212C: 907F01CC  stw r3, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[3].u32 ) };
	// 82EB2130: 995F01C8  stb r10, 0x1c8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[10].u8 ) };
	// 82EB2134: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2138: 806B0064  lwz r3, 0x64(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB213C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2140: 41820028  beq 0x82eb2168
	if ctx.cr[0].eq {
	pc = 0x82EB2168; continue 'dispatch;
	}
	// 82EB2144: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB2148: 388BE7E8  addi r4, r11, -0x1818
	ctx.r[4].s64 = ctx.r[11].s64 + -6168;
	// 82EB214C: 4BFD5585  bl 0x82e876d0
	ctx.lr = 0x82EB2150;
	sub_82E876D0(ctx, base);
	// 82EB2150: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2154: 41820014  beq 0x82eb2168
	if ctx.cr[0].eq {
	pc = 0x82EB2168; continue 'dispatch;
	}
	// 82EB2158: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB215C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB2160: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2164: 4BFFFD95  bl 0x82eb1ef8
	ctx.lr = 0x82EB2168;
	sub_82EB1EF8(ctx, base);
	// 82EB2168: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EB216C: 4800001C  b 0x82eb2188
	pc = 0x82EB2188; continue 'dispatch;
	// 82EB2170: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB2174: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB2178: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB217C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2180: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2184: 4E800421  bctrl
	ctx.lr = 0x82EB2188;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2188: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB218C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2190: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2194: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2198: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB219C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB21A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB21A0 size=12
    let mut pc: u32 = 0x82EB21A0;
    'dispatch: loop {
        match pc {
            0x82EB21A0 => {
    //   block [0x82EB21A0..0x82EB21AC)
	// 82EB21A0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82EB21A4: 38850004  addi r4, r5, 4
	ctx.r[4].s64 = ctx.r[5].s64 + 4;
	// 82EB21A8: 4BFFF510  b 0x82eb16b8
	sub_82EB16B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB21B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB21B0 size=140
    let mut pc: u32 = 0x82EB21B0;
    'dispatch: loop {
        match pc {
            0x82EB21B0 => {
    //   block [0x82EB21B0..0x82EB223C)
	// 82EB21B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB21B4: 4BDF7255  bl 0x82ca9408
	ctx.lr = 0x82EB21B8;
	sub_82CA93D0(ctx, base);
	// 82EB21B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB21BC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB21C0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EB21C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB21C8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EB21CC: 4BFFFDF5  bl 0x82eb1fc0
	ctx.lr = 0x82EB21D0;
	sub_82EB1FC0(ctx, base);
	// 82EB21D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB21D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB21D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB21DC: 4BFFFDE5  bl 0x82eb1fc0
	ctx.lr = 0x82EB21E0;
	sub_82EB1FC0(ctx, base);
	// 82EB21E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB21E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB21E8: 419A0048  beq cr6, 0x82eb2230
	if ctx.cr[6].eq {
	pc = 0x82EB2230; continue 'dispatch;
	}
	// 82EB21EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB21F0: 419A0040  beq cr6, 0x82eb2230
	if ctx.cr[6].eq {
	pc = 0x82EB2230; continue 'dispatch;
	}
	// 82EB21F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB21F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB21FC: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB2200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2204: 4E800421  bctrl
	ctx.lr = 0x82EB2208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2208: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB220C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB2210: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB2214: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB2218: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB221C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2220: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2224: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2228: 4E800421  bctrl
	ctx.lr = 0x82EB222C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB222C: 48000008  b 0x82eb2234
	pc = 0x82EB2234; continue 'dispatch;
	// 82EB2230: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB2234: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB2238: 4BDF7220  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB2240 size=8
    let mut pc: u32 = 0x82EB2240;
    'dispatch: loop {
        match pc {
            0x82EB2240 => {
    //   block [0x82EB2240..0x82EB2248)
	// 82EB2240: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2244: 4BFFF474  b 0x82eb16b8
	sub_82EB16B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB2248 size=856
    let mut pc: u32 = 0x82EB2248;
    'dispatch: loop {
        match pc {
            0x82EB2248 => {
    //   block [0x82EB2248..0x82EB25A0)
	// 82EB2248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB224C: 4BDF71B1  bl 0x82ca93fc
	ctx.lr = 0x82EB2250;
	sub_82CA93D0(ctx, base);
	// 82EB2250: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2258: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB225C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB2260: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EB2264: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB2268: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB226C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EB2270: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EB2274: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82EB2278: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EB227C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2280: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB2284: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB2288: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB228C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EB2290: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2294: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EB2298: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB229C: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EB22A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB22A4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB22A8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB22AC: 4200FFF8  bdnz 0x82eb22a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB22A4; continue 'dispatch;
	}
	// 82EB22B0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EB22B4: 9B4100C8  stb r26, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u8 ) };
	// 82EB22B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB22BC: 4BFFFD05  bl 0x82eb1fc0
	ctx.lr = 0x82EB22C0;
	sub_82EB1FC0(ctx, base);
	// 82EB22C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB22C4: 895F0068  lbz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB22C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB22CC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB22D0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82EB22D4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EB22D8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB22DC: 409A0060  bne cr6, 0x82eb233c
	if !ctx.cr[6].eq {
	pc = 0x82EB233C; continue 'dispatch;
	}
	// 82EB22E0: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB22E4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB22E8: 409A0054  bne cr6, 0x82eb233c
	if !ctx.cr[6].eq {
	pc = 0x82EB233C; continue 'dispatch;
	}
	// 82EB22EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB22F0: 419A0068  beq cr6, 0x82eb2358
	if ctx.cr[6].eq {
	pc = 0x82EB2358; continue 'dispatch;
	}
	// 82EB22F4: C01F00EC  lfs f0, 0xec(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB22F8: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB22FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB2300: 409A0028  bne cr6, 0x82eb2328
	if !ctx.cr[6].eq {
	pc = 0x82EB2328; continue 'dispatch;
	}
	// 82EB2304: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2308: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB230C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB2310: 409A0018  bne cr6, 0x82eb2328
	if !ctx.cr[6].eq {
	pc = 0x82EB2328; continue 'dispatch;
	}
	// 82EB2314: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2318: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EB231C: C1BF00F4  lfs f13, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB2320: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB2324: 419A0008  beq cr6, 0x82eb232c
	if ctx.cr[6].eq {
	pc = 0x82EB232C; continue 'dispatch;
	}
	// 82EB2328: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82EB232C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2330: 4182000C  beq 0x82eb233c
	if ctx.cr[0].eq {
	pc = 0x82EB233C; continue 'dispatch;
	}
	// 82EB2334: 807F0138  lwz r3, 0x138(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2338: 48000018  b 0x82eb2350
	pc = 0x82EB2350; continue 'dispatch;
	// 82EB233C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB2340: 419A0018  beq cr6, 0x82eb2358
	if ctx.cr[6].eq {
	pc = 0x82EB2358; continue 'dispatch;
	}
	// 82EB2344: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB2348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB234C: 4BFFFC75  bl 0x82eb1fc0
	ctx.lr = 0x82EB2350;
	sub_82EB1FC0(ctx, base);
	// 82EB2350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB2354: 409A0020  bne cr6, 0x82eb2374
	if !ctx.cr[6].eq {
	pc = 0x82EB2374; continue 'dispatch;
	}
	// 82EB2358: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB235C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB2360: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2364: 389F00E0  addi r4, r31, 0xe0
	ctx.r[4].s64 = ctx.r[31].s64 + 224;
	// 82EB2368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB236C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2370: 4E800421  bctrl
	ctx.lr = 0x82EB2374;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2374: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB2378: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB237C: 40820048  bne 0x82eb23c4
	if !ctx.cr[0].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB2380: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2384: 41820010  beq 0x82eb2394
	if ctx.cr[0].eq {
	pc = 0x82EB2394; continue 'dispatch;
	}
	// 82EB2388: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB238C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB2390: 409A0034  bne cr6, 0x82eb23c4
	if !ctx.cr[6].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB2394: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2398: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB239C: 409A0028  bne cr6, 0x82eb23c4
	if !ctx.cr[6].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB23A0: 897F01B5  lbz r11, 0x1b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82EB23A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB23A8: 4082001C  bne 0x82eb23c4
	if !ctx.cr[0].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB23AC: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB23B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB23B4: 40820010  bne 0x82eb23c4
	if !ctx.cr[0].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB23B8: 9B5B0000  stb r26, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82EB23BC: 887F00BD  lbz r3, 0xbd(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB23C0: 480001D8  b 0x82eb2598
	pc = 0x82EB2598; continue 'dispatch;
	// 82EB23C4: 9B3B0000  stb r25, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82EB23C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB23CC: 93BF0134  stw r29, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[29].u32 ) };
	// 82EB23D0: 907F0138  stw r3, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[3].u32 ) };
	// 82EB23D4: 419A01BC  beq cr6, 0x82eb2590
	if ctx.cr[6].eq {
	pc = 0x82EB2590; continue 'dispatch;
	}
	// 82EB23D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB23DC: 419A01B4  beq cr6, 0x82eb2590
	if ctx.cr[6].eq {
	pc = 0x82EB2590; continue 'dispatch;
	}
	// 82EB23E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB23E4: 3BDF0074  addi r30, r31, 0x74
	ctx.r[30].s64 = ctx.r[31].s64 + 116;
	// 82EB23E8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB23EC: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EB23F0: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82EB23F4: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EB23F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB23FC: 419A0058  beq cr6, 0x82eb2454
	if ctx.cr[6].eq {
	pc = 0x82EB2454; continue 'dispatch;
	}
	// 82EB2400: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2408: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB240C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2410: 4E800421  bctrl
	ctx.lr = 0x82EB2414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2418: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB241C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2420: 4E800421  bctrl
	ctx.lr = 0x82EB2424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2424: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2428: 396B52B8  addi r11, r11, 0x52b8
	ctx.r[11].s64 = ctx.r[11].s64 + 21176;
	// 82EB242C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB2430: 409A0024  bne cr6, 0x82eb2454
	if !ctx.cr[6].eq {
	pc = 0x82EB2454; continue 'dispatch;
	}
	// 82EB2434: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2438: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB243C: 815F0134  lwz r10, 0x134(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB2440: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EB2444: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2448: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB244C: 4BFED4F5  bl 0x82e9f940
	ctx.lr = 0x82EB2450;
	sub_82E9F940(ctx, base);
	// 82EB2450: 48000148  b 0x82eb2598
	pc = 0x82EB2598; continue 'dispatch;
	// 82EB2454: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB245C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB2460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2464: 4E800421  bctrl
	ctx.lr = 0x82EB2468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2468: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB246C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB2470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2474: 916A0054  stw r11, 0x54(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB2478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB247C: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB2480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2484: 4E800421  bctrl
	ctx.lr = 0x82EB2488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2488: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB248C: 906B0058  stw r3, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EB2490: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB2494: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2498: 40820028  bne 0x82eb24c0
	if !ctx.cr[0].eq {
	pc = 0x82EB24C0; continue 'dispatch;
	}
	// 82EB249C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB24A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB24A4: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB24A8: 80BF0134  lwz r5, 0x134(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB24AC: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB24B0: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB24B4: 4BFF158D  bl 0x82ea3a40
	ctx.lr = 0x82EB24B8;
	sub_82EA3A40(ctx, base);
	// 82EB24B8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EB24BC: 480000D8  b 0x82eb2594
	pc = 0x82EB2594; continue 'dispatch;
	// 82EB24C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB24C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB24C8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB24CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB24D0: 4E800421  bctrl
	ctx.lr = 0x82EB24D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB24D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB24D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB24DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB24E0: 4E800421  bctrl
	ctx.lr = 0x82EB24E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB24E4: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB24E8: 4B3AE4D1  bl 0x822609b8
	ctx.lr = 0x82EB24EC;
	sub_822609B8(ctx, base);
	// 82EB24EC: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB24F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB24F4: 4BFCF025  bl 0x82e81518
	ctx.lr = 0x82EB24F8;
	sub_82E81518(ctx, base);
	// 82EB24F8: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82EB24FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB2500: C00B0A8C  lfs f0, 0xa8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2504: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EB2508: 40980008  bge cr6, 0x82eb2510
	if !ctx.cr[6].lt {
	pc = 0x82EB2510; continue 'dispatch;
	}
	// 82EB250C: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 82EB2510: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB2514: 1D5D0014  mulli r10, r29, 0x14
	ctx.r[10].s64 = ctx.r[29].s64 * 20;
	// 82EB2518: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB251C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2520: 9B5F00BF  stb r26, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[26].u8 ) };
	// 82EB2524: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2528: 80BF0134  lwz r5, 0x134(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB252C: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB2530: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2534: 895F01B5  lbz r10, 0x1b5(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82EB2538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB253C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 82EB2540: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 82EB2544: 99410067  stb r10, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[10].u8 ) };
	// 82EB2548: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82EB254C: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB2550: 4BFF0D49  bl 0x82ea3298
	ctx.lr = 0x82EB2554;
	sub_82EA3298(ctx, base);
	// 82EB2554: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EB2558: 4198003C  blt cr6, 0x82eb2594
	if ctx.cr[6].lt {
	pc = 0x82EB2594; continue 'dispatch;
	}
	// 82EB255C: 419A002C  beq cr6, 0x82eb2588
	if ctx.cr[6].eq {
	pc = 0x82EB2588; continue 'dispatch;
	}
	// 82EB2560: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82EB2564: 40980030  bge cr6, 0x82eb2594
	if !ctx.cr[6].lt {
	pc = 0x82EB2594; continue 'dispatch;
	}
	// 82EB2568: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB256C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EB2570: 9B3F00BF  stb r25, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[25].u8 ) };
	// 82EB2574: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2578: 4BFCF091  bl 0x82e81608
	ctx.lr = 0x82EB257C;
	sub_82E81608(ctx, base);
	// 82EB257C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EB2580: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB2584: 4BFCF4C5  bl 0x82e81a48
	ctx.lr = 0x82EB2588;
	sub_82E81A48(ctx, base);
	// 82EB2588: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82EB258C: 48000008  b 0x82eb2594
	pc = 0x82EB2594; continue 'dispatch;
	// 82EB2590: 9B5F00BF  stb r26, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[26].u8 ) };
	// 82EB2594: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB2598: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82EB259C: 4BDF6EB0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB25A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB25A0 size=464
    let mut pc: u32 = 0x82EB25A0;
    'dispatch: loop {
        match pc {
            0x82EB25A0 => {
    //   block [0x82EB25A0..0x82EB2770)
	// 82EB25A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB25A4: 4BDF6E65  bl 0x82ca9408
	ctx.lr = 0x82EB25A8;
	sub_82CA93D0(ctx, base);
	// 82EB25A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB25AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB25B0: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB25B4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EB25B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB25BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB25C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB25C4: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB25CC: 409A0028  bne cr6, 0x82eb25f4
	if !ctx.cr[6].eq {
	pc = 0x82EB25F4; continue 'dispatch;
	}
	// 82EB25D0: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25D4: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB25D8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB25DC: 409A0018  bne cr6, 0x82eb25f4
	if !ctx.cr[6].eq {
	pc = 0x82EB25F4; continue 'dispatch;
	}
	// 82EB25E0: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB25E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB25E8: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25EC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB25F0: 419A0008  beq cr6, 0x82eb25f8
	if ctx.cr[6].eq {
	pc = 0x82EB25F8; continue 'dispatch;
	}
	// 82EB25F4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EB25F8: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25FC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2600: 4182005C  beq 0x82eb265c
	if ctx.cr[0].eq {
	pc = 0x82EB265C; continue 'dispatch;
	}
	// 82EB2604: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB2608: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB260C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2610: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82EB2614: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB2618: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB261C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EB2620: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EB2624: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB2628: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB262C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2630: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB2634: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB2638: 4200FFF8  bdnz 0x82eb2630
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB2630; continue 'dispatch;
	}
	// 82EB263C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB2640: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 82EB2644: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB2648: 4BFFF979  bl 0x82eb1fc0
	ctx.lr = 0x82EB264C;
	sub_82EB1FC0(ctx, base);
	// 82EB264C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB2650: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB2654: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB2658: 48000030  b 0x82eb2688
	pc = 0x82EB2688; continue 'dispatch;
	// 82EB265C: D1A10054  stfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB2660: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB2664: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB2668: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB266C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB2670: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2674: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB2678: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB267C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB2680: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2684: 4E800421  bctrl
	ctx.lr = 0x82EB2688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2688: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB268C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB2690: 409A004C  bne cr6, 0x82eb26dc
	if !ctx.cr[6].eq {
	pc = 0x82EB26DC; continue 'dispatch;
	}
	// 82EB2694: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2698: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82EB269C: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82EB26A0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EB26A4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB26A8: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26AC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB26B0: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26B4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB26B8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26BC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB26C0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82EB26C4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB26C8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB26CC: 4200FFF8  bdnz 0x82eb26c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB26C4; continue 'dispatch;
	}
	// 82EB26D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB26D4: 9B9F0058  stb r28, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EB26D8: 48000090  b 0x82eb2768
	pc = 0x82EB2768; continue 'dispatch;
	// 82EB26DC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26E0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB26E4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB26E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB26EC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26F0: 388B60C0  addi r4, r11, 0x60c0
	ctx.r[4].s64 = ctx.r[11].s64 + 24768;
	// 82EB26F4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB26F8: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26FC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB2700: 9B9F0058  stb r28, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EB2704: 4BFD6FDD  bl 0x82e896e0
	ctx.lr = 0x82EB2708;
	sub_82E896E0(ctx, base);
	// 82EB2708: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EB270C: 41820018  beq 0x82eb2724
	if ctx.cr[0].eq {
	pc = 0x82EB2724; continue 'dispatch;
	}
	// 82EB2710: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB2714: 93C40004  stw r30, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EB2718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB271C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB2720: 4B2FBF89  bl 0x821ae6a8
	ctx.lr = 0x82EB2724;
	sub_821AE6A8(ctx, base);
	// 82EB2724: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB272C: 388B20C0  addi r4, r11, 0x20c0
	ctx.r[4].s64 = ctx.r[11].s64 + 8384;
	// 82EB2730: 4BFD6FB1  bl 0x82e896e0
	ctx.lr = 0x82EB2734;
	sub_82E896E0(ctx, base);
	// 82EB2734: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB2738: 4182002C  beq 0x82eb2764
	if ctx.cr[0].eq {
	pc = 0x82EB2764; continue 'dispatch;
	}
	// 82EB273C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB2744: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2748: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB274C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2750: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2754: 4E800421  bctrl
	ctx.lr = 0x82EB2758;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB275C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2760: 4B2FBF49  bl 0x821ae6a8
	ctx.lr = 0x82EB2764;
	sub_821AE6A8(ctx, base);
	// 82EB2764: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB2768: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EB276C: 4BDF6CEC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2770 size=116
    let mut pc: u32 = 0x82EB2770;
    'dispatch: loop {
        match pc {
            0x82EB2770 => {
    //   block [0x82EB2770..0x82EB27E4)
	// 82EB2770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB277C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2780: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB2784: 816A86F8  lwz r11, -0x7908(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30984 as u32) ) } as u64;
	// 82EB2788: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB278C: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB2790: 3BE986B0  addi r31, r9, -0x7950
	ctx.r[31].s64 = ctx.r[9].s64 + -31056;
	// 82EB2794: 40820038  bne 0x82eb27cc
	if !ctx.cr[0].eq {
	pc = 0x82EB27CC; continue 'dispatch;
	}
	// 82EB2798: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EB279C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EB27A0: 8909DF21  lbz r8, -0x20df(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8415 as u32) ) } as u64;
	// 82EB27A4: 916A86F8  stw r11, -0x7908(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-30984 as u32), ctx.r[11].u32 ) };
	// 82EB27A8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB27AC: 4182000C  beq 0x82eb27b8
	if ctx.cr[0].eq {
	pc = 0x82EB27B8; continue 'dispatch;
	}
	// 82EB27B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB27B4: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EB27B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB27BC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EB27C0: 386A88F0  addi r3, r10, -0x7710
	ctx.r[3].s64 = ctx.r[10].s64 + -30480;
	// 82EB27C4: 9969DF21  stb r11, -0x20df(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8415 as u32), ctx.r[11].u8 ) };
	// 82EB27C8: 4BDF7759  bl 0x82ca9f20
	ctx.lr = 0x82EB27CC;
	sub_82CA9F20(ctx, base);
	// 82EB27CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB27D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB27D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB27D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB27DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB27E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB27E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB27E8 size=116
    let mut pc: u32 = 0x82EB27E8;
    'dispatch: loop {
        match pc {
            0x82EB27E8 => {
    //   block [0x82EB27E8..0x82EB285C)
	// 82EB27E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB27EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB27F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB27F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB27F8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB27FC: 816A8748  lwz r11, -0x78b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30904 as u32) ) } as u64;
	// 82EB2800: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2804: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB2808: 3BE98700  addi r31, r9, -0x7900
	ctx.r[31].s64 = ctx.r[9].s64 + -30976;
	// 82EB280C: 40820038  bne 0x82eb2844
	if !ctx.cr[0].eq {
	pc = 0x82EB2844; continue 'dispatch;
	}
	// 82EB2810: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EB2814: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EB2818: 8909DF20  lbz r8, -0x20e0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8416 as u32) ) } as u64;
	// 82EB281C: 916A8748  stw r11, -0x78b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-30904 as u32), ctx.r[11].u32 ) };
	// 82EB2820: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2824: 4182000C  beq 0x82eb2830
	if ctx.cr[0].eq {
	pc = 0x82EB2830; continue 'dispatch;
	}
	// 82EB2828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB282C: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EB2830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2834: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EB2838: 386A88D8  addi r3, r10, -0x7728
	ctx.r[3].s64 = ctx.r[10].s64 + -30504;
	// 82EB283C: 9969DF20  stb r11, -0x20e0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8416 as u32), ctx.r[11].u8 ) };
	// 82EB2840: 4BDF76E1  bl 0x82ca9f20
	ctx.lr = 0x82EB2844;
	sub_82CA9F20(ctx, base);
	// 82EB2844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2848: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB284C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2854: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2860 size=192
    let mut pc: u32 = 0x82EB2860;
    'dispatch: loop {
        match pc {
            0x82EB2860 => {
    //   block [0x82EB2860..0x82EB2920)
	// 82EB2860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB286C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2878: 4B77BC11  bl 0x8262e488
	ctx.lr = 0x82EB287C;
	sub_8262E488(ctx, base);
	// 82EB287C: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2880: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2884: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2888: 4081006C  ble 0x82eb28f4
	if !ctx.cr[0].gt {
	pc = 0x82EB28F4; continue 'dispatch;
	}
	// 82EB288C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2890: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2894: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82EB2898: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB289C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB28A0: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB28A4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB28A8: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB28AC: 409A0038  bne cr6, 0x82eb28e4
	if !ctx.cr[6].eq {
	pc = 0x82EB28E4; continue 'dispatch;
	}
	// 82EB28B0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB28B4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB28B8: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 82EB28BC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB28C0: 419A0050  beq cr6, 0x82eb2910
	if ctx.cr[6].eq {
	pc = 0x82EB2910; continue 'dispatch;
	}
	// 82EB28C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB28C8: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB28CC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB28D0: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB28D4: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB28D8: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB28DC: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB28E0: 419AFFDC  beq cr6, 0x82eb28bc
	if ctx.cr[6].eq {
	pc = 0x82EB28BC; continue 'dispatch;
	}
	// 82EB28E4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB28E8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB28EC: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB28F0: 4198FFA8  blt cr6, 0x82eb2898
	if ctx.cr[6].lt {
	pc = 0x82EB2898; continue 'dispatch;
	}
	// 82EB28F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB28F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB28FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2904: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2908: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB290C: 4E800020  blr
	return;
	// 82EB2910: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2914: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2918: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB291C: 4BFFFFDC  b 0x82eb28f8
	pc = 0x82EB28F8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2920 size=192
    let mut pc: u32 = 0x82EB2920;
    'dispatch: loop {
        match pc {
            0x82EB2920 => {
    //   block [0x82EB2920..0x82EB29E0)
	// 82EB2920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2928: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB292C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2930: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2938: 4B77BBE9  bl 0x8262e520
	ctx.lr = 0x82EB293C;
	sub_8262E520(ctx, base);
	// 82EB293C: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2940: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2944: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2948: 4081006C  ble 0x82eb29b4
	if !ctx.cr[0].gt {
	pc = 0x82EB29B4; continue 'dispatch;
	}
	// 82EB294C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2950: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2954: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82EB2958: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB295C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2960: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2964: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2968: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB296C: 409A0038  bne cr6, 0x82eb29a4
	if !ctx.cr[6].eq {
	pc = 0x82EB29A4; continue 'dispatch;
	}
	// 82EB2970: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2974: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2978: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 82EB297C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2980: 419A0050  beq cr6, 0x82eb29d0
	if ctx.cr[6].eq {
	pc = 0x82EB29D0; continue 'dispatch;
	}
	// 82EB2984: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2988: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB298C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2990: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2994: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2998: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB299C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB29A0: 419AFFDC  beq cr6, 0x82eb297c
	if ctx.cr[6].eq {
	pc = 0x82EB297C; continue 'dispatch;
	}
	// 82EB29A4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB29A8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB29AC: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB29B0: 4198FFA8  blt cr6, 0x82eb2958
	if ctx.cr[6].lt {
	pc = 0x82EB2958; continue 'dispatch;
	}
	// 82EB29B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB29B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB29BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB29C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB29C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB29C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB29CC: 4E800020  blr
	return;
	// 82EB29D0: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB29D4: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB29D8: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB29DC: 4BFFFFDC  b 0x82eb29b8
	pc = 0x82EB29B8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB29E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB29E0 size=192
    let mut pc: u32 = 0x82EB29E0;
    'dispatch: loop {
        match pc {
            0x82EB29E0 => {
    //   block [0x82EB29E0..0x82EB2AA0)
	// 82EB29E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB29E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB29E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB29EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB29F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB29F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB29F8: 4BFFFD79  bl 0x82eb2770
	ctx.lr = 0x82EB29FC;
	sub_82EB2770(ctx, base);
	// 82EB29FC: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2A00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2A04: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2A08: 4081006C  ble 0x82eb2a74
	if !ctx.cr[0].gt {
	pc = 0x82EB2A74; continue 'dispatch;
	}
	// 82EB2A0C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2A10: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2A14: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82EB2A18: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2A1C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2A20: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2A24: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2A28: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2A2C: 409A0038  bne cr6, 0x82eb2a64
	if !ctx.cr[6].eq {
	pc = 0x82EB2A64; continue 'dispatch;
	}
	// 82EB2A30: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2A34: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2A38: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 82EB2A3C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2A40: 419A0050  beq cr6, 0x82eb2a90
	if ctx.cr[6].eq {
	pc = 0x82EB2A90; continue 'dispatch;
	}
	// 82EB2A44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2A48: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2A4C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2A50: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2A54: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2A58: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2A5C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2A60: 419AFFDC  beq cr6, 0x82eb2a3c
	if ctx.cr[6].eq {
	pc = 0x82EB2A3C; continue 'dispatch;
	}
	// 82EB2A64: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2A68: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2A6C: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2A70: 4198FFA8  blt cr6, 0x82eb2a18
	if ctx.cr[6].lt {
	pc = 0x82EB2A18; continue 'dispatch;
	}
	// 82EB2A74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB2A78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2A7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2A80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2A84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2A88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2A8C: 4E800020  blr
	return;
	// 82EB2A90: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2A94: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2A98: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2A9C: 4BFFFFDC  b 0x82eb2a78
	pc = 0x82EB2A78; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2AA0 size=192
    let mut pc: u32 = 0x82EB2AA0;
    'dispatch: loop {
        match pc {
            0x82EB2AA0 => {
    //   block [0x82EB2AA0..0x82EB2B60)
	// 82EB2AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2AB8: 4BFFFD31  bl 0x82eb27e8
	ctx.lr = 0x82EB2ABC;
	sub_82EB27E8(ctx, base);
	// 82EB2ABC: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2AC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2AC4: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2AC8: 4081006C  ble 0x82eb2b34
	if !ctx.cr[0].gt {
	pc = 0x82EB2B34; continue 'dispatch;
	}
	// 82EB2ACC: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2AD0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2AD4: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82EB2AD8: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2ADC: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2AE0: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2AE4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2AE8: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2AEC: 409A0038  bne cr6, 0x82eb2b24
	if !ctx.cr[6].eq {
	pc = 0x82EB2B24; continue 'dispatch;
	}
	// 82EB2AF0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2AF4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2AF8: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 82EB2AFC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2B00: 419A0050  beq cr6, 0x82eb2b50
	if ctx.cr[6].eq {
	pc = 0x82EB2B50; continue 'dispatch;
	}
	// 82EB2B04: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2B08: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2B0C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2B10: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2B14: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2B18: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2B1C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2B20: 419AFFDC  beq cr6, 0x82eb2afc
	if ctx.cr[6].eq {
	pc = 0x82EB2AFC; continue 'dispatch;
	}
	// 82EB2B24: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2B28: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2B2C: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2B30: 4198FFA8  blt cr6, 0x82eb2ad8
	if ctx.cr[6].lt {
	pc = 0x82EB2AD8; continue 'dispatch;
	}
	// 82EB2B34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB2B38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2B3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2B40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2B44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2B48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2B4C: 4E800020  blr
	return;
	// 82EB2B50: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2B54: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2B58: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2B5C: 4BFFFFDC  b 0x82eb2b38
	pc = 0x82EB2B38; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2B60 size=192
    let mut pc: u32 = 0x82EB2B60;
    'dispatch: loop {
        match pc {
            0x82EB2B60 => {
    //   block [0x82EB2B60..0x82EB2C20)
	// 82EB2B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2B68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2B6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2B70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2B74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2B78: 4B77BB71  bl 0x8262e6e8
	ctx.lr = 0x82EB2B7C;
	sub_8262E6E8(ctx, base);
	// 82EB2B7C: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2B80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2B84: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2B88: 4081006C  ble 0x82eb2bf4
	if !ctx.cr[0].gt {
	pc = 0x82EB2BF4; continue 'dispatch;
	}
	// 82EB2B8C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2B90: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2B94: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82EB2B98: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2B9C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2BA0: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2BA4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2BA8: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2BAC: 409A0038  bne cr6, 0x82eb2be4
	if !ctx.cr[6].eq {
	pc = 0x82EB2BE4; continue 'dispatch;
	}
	// 82EB2BB0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2BB4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2BB8: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 82EB2BBC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2BC0: 419A0050  beq cr6, 0x82eb2c10
	if ctx.cr[6].eq {
	pc = 0x82EB2C10; continue 'dispatch;
	}
	// 82EB2BC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2BC8: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2BCC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2BD0: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2BD4: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2BD8: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2BDC: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2BE0: 419AFFDC  beq cr6, 0x82eb2bbc
	if ctx.cr[6].eq {
	pc = 0x82EB2BBC; continue 'dispatch;
	}
	// 82EB2BE4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2BE8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2BEC: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2BF0: 4198FFA8  blt cr6, 0x82eb2b98
	if ctx.cr[6].lt {
	pc = 0x82EB2B98; continue 'dispatch;
	}
	// 82EB2BF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB2BF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2BFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2C00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2C04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2C08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2C0C: 4E800020  blr
	return;
	// 82EB2C10: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2C14: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2C18: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2C1C: 4BFFFFDC  b 0x82eb2bf8
	pc = 0x82EB2BF8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2C20 size=192
    let mut pc: u32 = 0x82EB2C20;
    'dispatch: loop {
        match pc {
            0x82EB2C20 => {
    //   block [0x82EB2C20..0x82EB2CE0)
	// 82EB2C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2C28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2C2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2C30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2C34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2C38: 4B77B981  bl 0x8262e5b8
	ctx.lr = 0x82EB2C3C;
	sub_8262E5B8(ctx, base);
	// 82EB2C3C: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2C40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2C44: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2C48: 4081006C  ble 0x82eb2cb4
	if !ctx.cr[0].gt {
	pc = 0x82EB2CB4; continue 'dispatch;
	}
	// 82EB2C4C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2C50: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2C54: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82EB2C58: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2C5C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2C60: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2C64: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2C68: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2C6C: 409A0038  bne cr6, 0x82eb2ca4
	if !ctx.cr[6].eq {
	pc = 0x82EB2CA4; continue 'dispatch;
	}
	// 82EB2C70: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2C74: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2C78: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 82EB2C7C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2C80: 419A0050  beq cr6, 0x82eb2cd0
	if ctx.cr[6].eq {
	pc = 0x82EB2CD0; continue 'dispatch;
	}
	// 82EB2C84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2C88: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2C8C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2C90: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2C94: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2C98: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2C9C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2CA0: 419AFFDC  beq cr6, 0x82eb2c7c
	if ctx.cr[6].eq {
	pc = 0x82EB2C7C; continue 'dispatch;
	}
	// 82EB2CA4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2CA8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2CAC: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2CB0: 4198FFA8  blt cr6, 0x82eb2c58
	if ctx.cr[6].lt {
	pc = 0x82EB2C58; continue 'dispatch;
	}
	// 82EB2CB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB2CB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2CBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2CC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2CC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2CC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2CCC: 4E800020  blr
	return;
	// 82EB2CD0: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2CD4: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2CD8: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2CDC: 4BFFFFDC  b 0x82eb2cb8
	pc = 0x82EB2CB8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2CE0 size=192
    let mut pc: u32 = 0x82EB2CE0;
    'dispatch: loop {
        match pc {
            0x82EB2CE0 => {
    //   block [0x82EB2CE0..0x82EB2DA0)
	// 82EB2CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2CE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2CEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2CF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2CF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2CF8: 4B77B959  bl 0x8262e650
	ctx.lr = 0x82EB2CFC;
	sub_8262E650(ctx, base);
	// 82EB2CFC: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2D00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2D04: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2D08: 4081006C  ble 0x82eb2d74
	if !ctx.cr[0].gt {
	pc = 0x82EB2D74; continue 'dispatch;
	}
	// 82EB2D0C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2D10: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2D14: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82EB2D18: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2D1C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2D20: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2D24: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2D28: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2D2C: 409A0038  bne cr6, 0x82eb2d64
	if !ctx.cr[6].eq {
	pc = 0x82EB2D64; continue 'dispatch;
	}
	// 82EB2D30: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2D34: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2D38: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 82EB2D3C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2D40: 419A0050  beq cr6, 0x82eb2d90
	if ctx.cr[6].eq {
	pc = 0x82EB2D90; continue 'dispatch;
	}
	// 82EB2D44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2D48: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2D4C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2D50: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2D54: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2D58: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2D5C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2D60: 419AFFDC  beq cr6, 0x82eb2d3c
	if ctx.cr[6].eq {
	pc = 0x82EB2D3C; continue 'dispatch;
	}
	// 82EB2D64: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2D68: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2D6C: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2D70: 4198FFA8  blt cr6, 0x82eb2d18
	if ctx.cr[6].lt {
	pc = 0x82EB2D18; continue 'dispatch;
	}
	// 82EB2D74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB2D78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2D7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2D80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2D84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2D88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2D8C: 4E800020  blr
	return;
	// 82EB2D90: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2D94: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2D98: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2D9C: 4BFFFFDC  b 0x82eb2d78
	pc = 0x82EB2D78; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2DA0 size=116
    let mut pc: u32 = 0x82EB2DA0;
    'dispatch: loop {
        match pc {
            0x82EB2DA0 => {
    //   block [0x82EB2DA0..0x82EB2E14)
	// 82EB2DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2DA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2DAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2DB0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB2DB4: 816A8B54  lwz r11, -0x74ac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29868 as u32) ) } as u64;
	// 82EB2DB8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2DBC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB2DC0: 3BE98750  addi r31, r9, -0x78b0
	ctx.r[31].s64 = ctx.r[9].s64 + -30896;
	// 82EB2DC4: 40820038  bne 0x82eb2dfc
	if !ctx.cr[0].eq {
	pc = 0x82EB2DFC; continue 'dispatch;
	}
	// 82EB2DC8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EB2DCC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EB2DD0: 8909DF22  lbz r8, -0x20de(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8414 as u32) ) } as u64;
	// 82EB2DD4: 916A8B54  stw r11, -0x74ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-29868 as u32), ctx.r[11].u32 ) };
	// 82EB2DD8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2DDC: 4182000C  beq 0x82eb2de8
	if ctx.cr[0].eq {
	pc = 0x82EB2DE8; continue 'dispatch;
	}
	// 82EB2DE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2DE4: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EB2DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2DEC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EB2DF0: 386A8908  addi r3, r10, -0x76f8
	ctx.r[3].s64 = ctx.r[10].s64 + -30456;
	// 82EB2DF4: 9969DF22  stb r11, -0x20de(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8414 as u32), ctx.r[11].u8 ) };
	// 82EB2DF8: 4BDF7129  bl 0x82ca9f20
	ctx.lr = 0x82EB2DFC;
	sub_82CA9F20(ctx, base);
	// 82EB2DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2E00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB2E04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2E08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2E0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2E18 size=160
    let mut pc: u32 = 0x82EB2E18;
    'dispatch: loop {
        match pc {
            0x82EB2E18 => {
    //   block [0x82EB2E18..0x82EB2EB8)
	// 82EB2E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2E20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2E24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2E28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2E2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EB2E30: 419A0064  beq cr6, 0x82eb2e94
	if ctx.cr[6].eq {
	pc = 0x82EB2E94; continue 'dispatch;
	}
	// 82EB2E34: 4BFFFF6D  bl 0x82eb2da0
	ctx.lr = 0x82EB2E38;
	sub_82EB2DA0(ctx, base);
	// 82EB2E38: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB2E3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB2E40: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2E44: 40810050  ble 0x82eb2e94
	if !ctx.cr[0].gt {
	pc = 0x82EB2E94; continue 'dispatch;
	}
	// 82EB2E48: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EB2E4C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2E50: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EB2E54: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EB2E58: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2E5C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2E60: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2E64: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EB2E68: 41820014  beq 0x82eb2e7c
	if ctx.cr[0].eq {
	pc = 0x82EB2E7C; continue 'dispatch;
	}
	// 82EB2E6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2E70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB2E74: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EB2E78: 419AFFE0  beq cr6, 0x82eb2e58
	if ctx.cr[6].eq {
	pc = 0x82EB2E58; continue 'dispatch;
	}
	// 82EB2E7C: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2E80: 4182002C  beq 0x82eb2eac
	if ctx.cr[0].eq {
	pc = 0x82EB2EAC; continue 'dispatch;
	}
	// 82EB2E84: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EB2E88: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EB2E8C: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EB2E90: 4198FFBC  blt cr6, 0x82eb2e4c
	if ctx.cr[6].lt {
	pc = 0x82EB2E4C; continue 'dispatch;
	}
	// 82EB2E94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB2E98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB2E9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2EA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2EA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2EA8: 4E800020  blr
	return;
	// 82EB2EAC: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2EB0: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2EB4: 4BFFFFE4  b 0x82eb2e98
	pc = 0x82EB2E98; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB2EB8 size=320
    let mut pc: u32 = 0x82EB2EB8;
    'dispatch: loop {
        match pc {
            0x82EB2EB8 => {
    //   block [0x82EB2EB8..0x82EB2FF8)
	// 82EB2EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2EBC: 4BDF6551  bl 0x82ca940c
	ctx.lr = 0x82EB2EC0;
	sub_82CA93D0(ctx, base);
	// 82EB2EC0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EB2EC4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EB2EC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2ECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB2ED0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2ED4: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB2ED8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2EDC: 4E800421  bctrl
	ctx.lr = 0x82EB2EE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2EE0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB2EE4: 817E0168  lwz r11, 0x168(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB2EE8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EB2EEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2EF0: C3CA0C18  lfs f30, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB2EF4: 40820010  bne 0x82eb2f04
	if !ctx.cr[0].eq {
	pc = 0x82EB2F04; continue 'dispatch;
	}
	// 82EB2EF8: 817E016C  lwz r11, 0x16c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB2EFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F00: 4182000C  beq 0x82eb2f0c
	if ctx.cr[0].eq {
	pc = 0x82EB2F0C; continue 'dispatch;
	}
	// 82EB2F04: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 82EB2F08: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB2F0C: 817E0160  lwz r11, 0x160(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB2F10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F14: 40820010  bne 0x82eb2f24
	if !ctx.cr[0].eq {
	pc = 0x82EB2F24; continue 'dispatch;
	}
	// 82EB2F18: 817E0164  lwz r11, 0x164(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB2F1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F20: 4182000C  beq 0x82eb2f2c
	if ctx.cr[0].eq {
	pc = 0x82EB2F2C; continue 'dispatch;
	}
	// 82EB2F24: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 82EB2F28: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB2F2C: 817E0170  lwz r11, 0x170(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 82EB2F30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F34: 4182000C  beq 0x82eb2f40
	if ctx.cr[0].eq {
	pc = 0x82EB2F40; continue 'dispatch;
	}
	// 82EB2F38: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB2F3C: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 82EB2F40: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2F44: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2F48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB2F4C: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EB2F50: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2F54: 4B335725  bl 0x821e8678
	ctx.lr = 0x82EB2F58;
	sub_821E8678(ctx, base);
	// 82EB2F58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F5C: 4182000C  beq 0x82eb2f68
	if ctx.cr[0].eq {
	pc = 0x82EB2F68; continue 'dispatch;
	}
	// 82EB2F60: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2F64: 48000030  b 0x82eb2f94
	pc = 0x82EB2F94; continue 'dispatch;
	// 82EB2F68: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2F6C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB2F70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F74: 4182000C  beq 0x82eb2f80
	if ctx.cr[0].eq {
	pc = 0x82EB2F80; continue 'dispatch;
	}
	// 82EB2F78: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB2F7C: 4800000C  b 0x82eb2f88
	pc = 0x82EB2F88; continue 'dispatch;
	// 82EB2F80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB2F84: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB2F88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB2F8C: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2F90: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB2F94: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB2F98: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB2F9C: 4BFD2A55  bl 0x82e859f0
	ctx.lr = 0x82EB2FA0;
	sub_82E859F0(ctx, base);
	// 82EB2FA0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB2FA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2FA8: 40990040  ble cr6, 0x82eb2fe8
	if !ctx.cr[6].gt {
	pc = 0x82EB2FE8; continue 'dispatch;
	}
	// 82EB2FAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB2FB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB2FB4: C3EB0A8C  lfs f31, 0xa8c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2700 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB2FB8: 817E01AC  lwz r11, 0x1ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB2FBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB2FC0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB2FC4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB2FC8: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82EB2FCC: D3EB0008  stfs f31, 8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB2FD0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB2FD4: D3CB000C  stfs f30, 0xc(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB2FD8: 4BFD2A19  bl 0x82e859f0
	ctx.lr = 0x82EB2FDC;
	sub_82E859F0(ctx, base);
	// 82EB2FDC: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB2FE0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB2FE4: 4198FFD4  blt cr6, 0x82eb2fb8
	if ctx.cr[6].lt {
	pc = 0x82EB2FB8; continue 'dispatch;
	}
	// 82EB2FE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB2FEC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EB2FF0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EB2FF4: 4BDF6468  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB2FF8 size=1848
    let mut pc: u32 = 0x82EB2FF8;
    'dispatch: loop {
        match pc {
            0x82EB2FF8 => {
    //   block [0x82EB2FF8..0x82EB3730)
	// 82EB2FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2FFC: 4BDF6405  bl 0x82ca9400
	ctx.lr = 0x82EB3000;
	sub_82CA93D0(ctx, base);
	// 82EB3000: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82EB3004: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EB3008: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB300C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EB3010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB3014: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82EB3018: 419A0704  beq cr6, 0x82eb371c
	if ctx.cr[6].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB301C: 4BFD29D5  bl 0x82e859f0
	ctx.lr = 0x82EB3020;
	sub_82E859F0(ctx, base);
	// 82EB3020: 83A30400  lwz r29, 0x400(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB3024: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82EB3028: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB302C: 40820010  bne 0x82eb303c
	if !ctx.cr[0].eq {
	pc = 0x82EB303C; continue 'dispatch;
	}
	// 82EB3030: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82EB3034: 4B437185  bl 0x822ea1b8
	ctx.lr = 0x82EB3038;
	sub_822EA1B8(ctx, base);
	// 82EB3038: 48000034  b 0x82eb306c
	pc = 0x82EB306C; continue 'dispatch;
	// 82EB303C: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 82EB3040: 616BCCCC  ori r11, r11, 0xcccc
	ctx.r[11].u64 = ctx.r[11].u64 | 52428;
	// 82EB3044: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB3048: 1D7D0014  mulli r11, r29, 0x14
	ctx.r[11].s64 = ctx.r[29].s64 * 20;
	// 82EB304C: 40990008  ble cr6, 0x82eb3054
	if !ctx.cr[6].gt {
	pc = 0x82EB3054; continue 'dispatch;
	}
	// 82EB3050: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EB3054: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EB3058: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EB305C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB3060: 40990008  ble cr6, 0x82eb3068
	if !ctx.cr[6].gt {
	pc = 0x82EB3068; continue 'dispatch;
	}
	// 82EB3064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB3068: 4B7638C1  bl 0x82616928
	ctx.lr = 0x82EB306C;
	sub_82616928(ctx, base);
	// 82EB306C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB3070: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB3078: C16A0A94  lfs f11, 0xa94(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2708 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB307C: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB3080: 419A0050  beq cr6, 0x82eb30d0
	if ctx.cr[6].eq {
	pc = 0x82EB30D0; continue 'dispatch;
	}
	// 82EB3084: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 82EB3088: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EB308C: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB3090: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB3094: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB3098: 41800040  blt 0x82eb30d8
	if ctx.cr[0].lt {
	pc = 0x82EB30D8; continue 'dispatch;
	}
	// 82EB309C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB30A0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB30A4: 3929A3A8  addi r9, r9, -0x5c58
	ctx.r[9].s64 = ctx.r[9].s64 + -23640;
	// 82EB30A8: C0080A8C  lfs f0, 0xa8c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB30AC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB30B0: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EB30B4: D3CB000C  stfs f30, 0xc(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB30B8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB30BC: D16B0010  stfs f11, 0x10(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB30C0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB30C4: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EB30C8: 4080FFE4  bge 0x82eb30ac
	if !ctx.cr[0].lt {
	pc = 0x82EB30AC; continue 'dispatch;
	}
	// 82EB30CC: 4800000C  b 0x82eb30d8
	pc = 0x82EB30D8; continue 'dispatch;
	// 82EB30D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB30D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB30D8: 3D4082EB  lis r10, -0x7d15
	ctx.r[10].s64 = -2098528256;
	// 82EB30DC: D3DF01C0  stfs f30, 0x1c0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB30E0: 3CA082EB  lis r5, -0x7d15
	ctx.r[5].s64 = -2098528256;
	// 82EB30E4: 909F01AC  stw r4, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[4].u32 ) };
	// 82EB30E8: 394A4370  addi r10, r10, 0x4370
	ctx.r[10].s64 = ctx.r[10].s64 + 17264;
	// 82EB30EC: 93BF00AC  stw r29, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[29].u32 ) };
	// 82EB30F0: 3CC082EB  lis r6, -0x7d15
	ctx.r[6].s64 = -2098528256;
	// 82EB30F4: 93DF01B8  stw r30, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[30].u32 ) };
	// 82EB30F8: 3CE082EA  lis r7, -0x7d16
	ctx.r[7].s64 = -2098593792;
	// 82EB30FC: 93DF01BC  stw r30, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[30].u32 ) };
	// 82EB3100: 3D0082EB  lis r8, -0x7d15
	ctx.r[8].s64 = -2098528256;
	// 82EB3104: 3D2082EB  lis r9, -0x7d15
	ctx.r[9].s64 = -2098528256;
	// 82EB3108: 3D6082EA  lis r11, -0x7d16
	ctx.r[11].s64 = -2098593792;
	// 82EB310C: 915F00A8  stw r10, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	// 82EB3110: 38A54270  addi r5, r5, 0x4270
	ctx.r[5].s64 = ctx.r[5].s64 + 17008;
	// 82EB3114: 396B63A8  addi r11, r11, 0x63a8
	ctx.r[11].s64 = ctx.r[11].s64 + 25512;
	// 82EB3118: 38C642E0  addi r6, r6, 0x42e0
	ctx.r[6].s64 = ctx.r[6].s64 + 17120;
	// 82EB311C: 38E763A8  addi r7, r7, 0x63a8
	ctx.r[7].s64 = ctx.r[7].s64 + 25512;
	// 82EB3120: 39084BA0  addi r8, r8, 0x4ba0
	ctx.r[8].s64 = ctx.r[8].s64 + 19360;
	// 82EB3124: 39294BA0  addi r9, r9, 0x4ba0
	ctx.r[9].s64 = ctx.r[9].s64 + 19360;
	// 82EB3128: 90BF009C  stw r5, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[5].u32 ) };
	// 82EB312C: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82EB3130: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EB3134: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB3138: 90DF00A0  stw r6, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[6].u32 ) };
	// 82EB313C: 90FF00A4  stw r7, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 82EB3140: 911F00B4  stw r8, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[8].u32 ) };
	// 82EB3144: 913F00B8  stw r9, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[9].u32 ) };
	// 82EB3148: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB314C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3150: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3154: 4182000C  beq 0x82eb3160
	if ctx.cr[0].eq {
	pc = 0x82EB3160; continue 'dispatch;
	}
	// 82EB3158: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB315C: 48000008  b 0x82eb3164
	pc = 0x82EB3164; continue 'dispatch;
	// 82EB3160: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB3164: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3168: C1AB0AC8  lfs f13, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB316C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB3170: D01F01C4  stfs f0, 0x1c4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB3174: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3178: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB317C: 4182000C  beq 0x82eb3188
	if ctx.cr[0].eq {
	pc = 0x82EB3188; continue 'dispatch;
	}
	// 82EB3180: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3184: 48000008  b 0x82eb318c
	pc = 0x82EB318C; continue 'dispatch;
	// 82EB3188: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB318C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3190: C18B0BFC  lfs f12, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB3194: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB3198: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB319C: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB31A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB31A4: 4182000C  beq 0x82eb31b0
	if ctx.cr[0].eq {
	pc = 0x82EB31B0; continue 'dispatch;
	}
	// 82EB31A8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB31AC: 48000008  b 0x82eb31b4
	pc = 0x82EB31B4; continue 'dispatch;
	// 82EB31B0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB31B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB31B8: C1AB0C84  lfs f13, 0xc84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB31BC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB31C0: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB31C4: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB31C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB31CC: 4182000C  beq 0x82eb31d8
	if ctx.cr[0].eq {
	pc = 0x82EB31D8; continue 'dispatch;
	}
	// 82EB31D0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB31D4: 48000008  b 0x82eb31dc
	pc = 0x82EB31DC; continue 'dispatch;
	// 82EB31D8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB31DC: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EB31E0: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB31E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB31E8: 4182000C  beq 0x82eb31f4
	if ctx.cr[0].eq {
	pc = 0x82EB31F4; continue 'dispatch;
	}
	// 82EB31EC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB31F0: 48000008  b 0x82eb31f8
	pc = 0x82EB31F8; continue 'dispatch;
	// 82EB31F4: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB31F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB31FC: C1ABBDF4  lfs f13, -0x420c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3200: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB3204: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EB3208: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB320C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3210: 4182000C  beq 0x82eb321c
	if ctx.cr[0].eq {
	pc = 0x82EB321C; continue 'dispatch;
	}
	// 82EB3214: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3218: 48000008  b 0x82eb3220
	pc = 0x82EB3220; continue 'dispatch;
	// 82EB321C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB3220: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EB3224: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3228: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB322C: 4182000C  beq 0x82eb3238
	if ctx.cr[0].eq {
	pc = 0x82EB3238; continue 'dispatch;
	}
	// 82EB3230: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3234: 48000008  b 0x82eb323c
	pc = 0x82EB323C; continue 'dispatch;
	// 82EB3238: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 82EB323C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3240: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EB3244: C00B0AA4  lfs f0, 0xaa4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3248: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB324C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB3250: 937F0054  stw r27, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82EB3254: D1BF004C  stfs f13, 0x4c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EB3258: C00BA500  lfs f0, -0x5b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB325C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB3260: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3264: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3268: 4182000C  beq 0x82eb3274
	if ctx.cr[0].eq {
	pc = 0x82EB3274; continue 'dispatch;
	}
	// 82EB326C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3270: 48000008  b 0x82eb3278
	pc = 0x82EB3278; continue 'dispatch;
	// 82EB3274: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB3278: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB327C: D3FF0060  stfs f31, 0x60(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB3280: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB3284: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3288: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB328C: 4182000C  beq 0x82eb3298
	if ctx.cr[0].eq {
	pc = 0x82EB3298; continue 'dispatch;
	}
	// 82EB3290: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3294: 48000008  b 0x82eb329c
	pc = 0x82EB329C; continue 'dispatch;
	// 82EB3298: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB329C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB32A0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB32A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB32A8: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB32AC: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EB32B0: D17F0064  stfs f11, 0x64(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB32B4: 9BBF0068  stb r29, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u8 ) };
	// 82EB32B8: 9BBF0069  stb r29, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[29].u8 ) };
	// 82EB32BC: 9B7F01B6  stb r27, 0x1b6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(438 as u32), ctx.r[27].u8 ) };
	// 82EB32C0: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB32C4: 4B3353B5  bl 0x821e8678
	ctx.lr = 0x82EB32C8;
	sub_821E8678(ctx, base);
	// 82EB32C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB32CC: 4182000C  beq 0x82eb32d8
	if ctx.cr[0].eq {
	pc = 0x82EB32D8; continue 'dispatch;
	}
	// 82EB32D0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB32D4: 48000028  b 0x82eb32fc
	pc = 0x82EB32FC; continue 'dispatch;
	// 82EB32D8: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB32DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB32E0: 4182000C  beq 0x82eb32ec
	if ctx.cr[0].eq {
	pc = 0x82EB32EC; continue 'dispatch;
	}
	// 82EB32E4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB32E8: 48000008  b 0x82eb32f0
	pc = 0x82EB32F0; continue 'dispatch;
	// 82EB32EC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB32F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB32F4: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB32F8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB32FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3300: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB3304: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 82EB3308: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EB330C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3310: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB3314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3318: 4E800421  bctrl
	ctx.lr = 0x82EB331C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB331C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3320: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 82EB3324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3328: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB332C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3330: 4E800421  bctrl
	ctx.lr = 0x82EB3334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3334: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3338: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB333C: 388BDF68  addi r4, r11, -0x2098
	ctx.r[4].s64 = ctx.r[11].s64 + -8344;
	// 82EB3340: 4B3B48E1  bl 0x82267c20
	ctx.lr = 0x82EB3344;
	sub_82267C20(ctx, base);
	// 82EB3344: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3348: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB334C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB3350: 388BA4F4  addi r4, r11, -0x5b0c
	ctx.r[4].s64 = ctx.r[11].s64 + -23308;
	// 82EB3354: 915F017C  stw r10, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[10].u32 ) };
	// 82EB3358: 4BFD0BC1  bl 0x82e83f18
	ctx.lr = 0x82EB335C;
	sub_82E83F18(ctx, base);
	// 82EB335C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EB3360: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3364: 418200B0  beq 0x82eb3414
	if ctx.cr[0].eq {
	pc = 0x82EB3414; continue 'dispatch;
	}
	// 82EB3368: 4BA5A9A1  bl 0x8290dd08
	ctx.lr = 0x82EB336C;
	sub_8290DD08(ctx, base);
	// 82EB336C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB3370: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB3374: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EB3378: 4BDF97D9  bl 0x82cacb50
	ctx.lr = 0x82EB337C;
	sub_82CACB50(ctx, base);
	// 82EB337C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3380: 41820084  beq 0x82eb3404
	if ctx.cr[0].eq {
	pc = 0x82EB3404; continue 'dispatch;
	}
	// 82EB3384: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB338C: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EB3390: 4BDF97C1  bl 0x82cacb50
	ctx.lr = 0x82EB3394;
	sub_82CACB50(ctx, base);
	// 82EB3394: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3398: 4182006C  beq 0x82eb3404
	if ctx.cr[0].eq {
	pc = 0x82EB3404; continue 'dispatch;
	}
	// 82EB339C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EB33A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33A4: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EB33A8: 4BDF97A9  bl 0x82cacb50
	ctx.lr = 0x82EB33AC;
	sub_82CACB50(ctx, base);
	// 82EB33AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33B0: 41820054  beq 0x82eb3404
	if ctx.cr[0].eq {
	pc = 0x82EB3404; continue 'dispatch;
	}
	// 82EB33B4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB33B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33BC: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EB33C0: 4BDF9791  bl 0x82cacb50
	ctx.lr = 0x82EB33C4;
	sub_82CACB50(ctx, base);
	// 82EB33C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33C8: 41820034  beq 0x82eb33fc
	if ctx.cr[0].eq {
	pc = 0x82EB33FC; continue 'dispatch;
	}
	// 82EB33CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB33D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33D4: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EB33D8: 4BDF9779  bl 0x82cacb50
	ctx.lr = 0x82EB33DC;
	sub_82CACB50(ctx, base);
	// 82EB33DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33E0: 4182001C  beq 0x82eb33fc
	if ctx.cr[0].eq {
	pc = 0x82EB33FC; continue 'dispatch;
	}
	// 82EB33E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB33E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33EC: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EB33F0: 4BDF9761  bl 0x82cacb50
	ctx.lr = 0x82EB33F4;
	sub_82CACB50(ctx, base);
	// 82EB33F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33F8: 40820324  bne 0x82eb371c
	if !ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB33FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB3400: 48000008  b 0x82eb3408
	pc = 0x82EB3408; continue 'dispatch;
	// 82EB3404: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EB3408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EB340C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB3410: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB3414: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3418: 4182006C  beq 0x82eb3484
	if ctx.cr[0].eq {
	pc = 0x82EB3484; continue 'dispatch;
	}
	// 82EB341C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3420: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB3424: 388BA4DC  addi r4, r11, -0x5b24
	ctx.r[4].s64 = ctx.r[11].s64 + -23332;
	// 82EB3428: 4BFD0AF1  bl 0x82e83f18
	ctx.lr = 0x82EB342C;
	sub_82E83F18(ctx, base);
	// 82EB342C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3430: 41820030  beq 0x82eb3460
	if ctx.cr[0].eq {
	pc = 0x82EB3460; continue 'dispatch;
	}
	// 82EB3434: 4BA5A8D5  bl 0x8290dd08
	ctx.lr = 0x82EB3438;
	sub_8290DD08(ctx, base);
	// 82EB3438: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB343C: 41820024  beq 0x82eb3460
	if ctx.cr[0].eq {
	pc = 0x82EB3460; continue 'dispatch;
	}
	// 82EB3440: 4BFFF9D9  bl 0x82eb2e18
	ctx.lr = 0x82EB3444;
	sub_82EB2E18(ctx, base);
	// 82EB3444: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3448: 41820018  beq 0x82eb3460
	if ctx.cr[0].eq {
	pc = 0x82EB3460; continue 'dispatch;
	}
	// 82EB344C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB3450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3458: 4E800421  bctrl
	ctx.lr = 0x82EB345C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB345C: 48000024  b 0x82eb3480
	pc = 0x82EB3480; continue 'dispatch;
	// 82EB3460: 38600104  li r3, 0x104
	ctx.r[3].s64 = 260;
	// 82EB3464: 4B7634C5  bl 0x82616928
	ctx.lr = 0x82EB3468;
	sub_82616928(ctx, base);
	// 82EB3468: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB346C: 41820010  beq 0x82eb347c
	if ctx.cr[0].eq {
	pc = 0x82EB347C; continue 'dispatch;
	}
	// 82EB3470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB3474: 4802C4B5  bl 0x82edf928
	ctx.lr = 0x82EB3478;
	sub_82EDF928(ctx, base);
	// 82EB3478: 48000008  b 0x82eb3480
	pc = 0x82EB3480; continue 'dispatch;
	// 82EB347C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB3480: 907F01B0  stw r3, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB3484: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EB3488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB348C: 4BFD1F1D  bl 0x82e853a8
	ctx.lr = 0x82EB3490;
	sub_82E853A8(ctx, base);
	// 82EB3490: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3494: 41820288  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3498: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB349C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34A4: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EB34A8: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB34AC: 4B3351CD  bl 0x821e8678
	ctx.lr = 0x82EB34B0;
	sub_821E8678(ctx, base);
	// 82EB34B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB34B4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34BC: 907F0158  stw r3, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[3].u32 ) };
	// 82EB34C0: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EB34C4: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB34C8: 4B3351B1  bl 0x821e8678
	ctx.lr = 0x82EB34CC;
	sub_821E8678(ctx, base);
	// 82EB34CC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB34D0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB34D4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34DC: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82EB34E0: 915F015C  stw r10, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[10].u32 ) };
	// 82EB34E4: 4BFCA1DD  bl 0x82e7d6c0
	ctx.lr = 0x82EB34E8;
	sub_82E7D6C0(ctx, base);
	// 82EB34E8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB34EC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB34F0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34F8: 388BCB2C  addi r4, r11, -0x34d4
	ctx.r[4].s64 = ctx.r[11].s64 + -13524;
	// 82EB34FC: 915F0160  stw r10, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[10].u32 ) };
	// 82EB3500: 4BFCA1C1  bl 0x82e7d6c0
	ctx.lr = 0x82EB3504;
	sub_82E7D6C0(ctx, base);
	// 82EB3504: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3508: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB350C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3510: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB3514: 388BCF7C  addi r4, r11, -0x3084
	ctx.r[4].s64 = ctx.r[11].s64 + -12420;
	// 82EB3518: 915F0164  stw r10, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[10].u32 ) };
	// 82EB351C: 4BFCA1A5  bl 0x82e7d6c0
	ctx.lr = 0x82EB3520;
	sub_82E7D6C0(ctx, base);
	// 82EB3520: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3524: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB3528: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB352C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB3530: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82EB3534: 915F0168  stw r10, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[10].u32 ) };
	// 82EB3538: 4BFCA189  bl 0x82e7d6c0
	ctx.lr = 0x82EB353C;
	sub_82E7D6C0(ctx, base);
	// 82EB353C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3540: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB3544: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3548: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB354C: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 82EB3550: 915F016C  stw r10, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[10].u32 ) };
	// 82EB3554: 4BFCA16D  bl 0x82e7d6c0
	ctx.lr = 0x82EB3558;
	sub_82E7D6C0(ctx, base);
	// 82EB3558: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB355C: 907F0170  stw r3, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[3].u32 ) };
	// 82EB3560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3564: 4182000C  beq 0x82eb3570
	if ctx.cr[0].eq {
	pc = 0x82EB3570; continue 'dispatch;
	}
	// 82EB3568: D3CB0008  stfs f30, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB356C: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB3570: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB3574: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3578: 4182000C  beq 0x82eb3584
	if ctx.cr[0].eq {
	pc = 0x82EB3584; continue 'dispatch;
	}
	// 82EB357C: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB3580: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB3584: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB3588: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB358C: 4182000C  beq 0x82eb3598
	if ctx.cr[0].eq {
	pc = 0x82EB3598; continue 'dispatch;
	}
	// 82EB3590: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB3594: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB3598: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB359C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB35A0: 4182000C  beq 0x82eb35ac
	if ctx.cr[0].eq {
	pc = 0x82EB35AC; continue 'dispatch;
	}
	// 82EB35A4: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB35A8: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB35AC: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82EB35B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB35B4: 4182000C  beq 0x82eb35c0
	if ctx.cr[0].eq {
	pc = 0x82EB35C0; continue 'dispatch;
	}
	// 82EB35B8: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB35BC: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB35C0: 4B3AD3F9  bl 0x822609b8
	ctx.lr = 0x82EB35C4;
	sub_822609B8(ctx, base);
	// 82EB35C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB35C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB35CC: 388BA4B0  addi r4, r11, -0x5b50
	ctx.r[4].s64 = ctx.r[11].s64 + -23376;
	// 82EB35D0: 4BFCDC01  bl 0x82e811d0
	ctx.lr = 0x82EB35D4;
	sub_82E811D0(ctx, base);
	// 82EB35D4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB35D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB35DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB35E0: 388BA48C  addi r4, r11, -0x5b74
	ctx.r[4].s64 = ctx.r[11].s64 + -23412;
	// 82EB35E4: 915F0184  stw r10, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[10].u32 ) };
	// 82EB35E8: 4BFCDB81  bl 0x82e81168
	ctx.lr = 0x82EB35EC;
	sub_82E81168(ctx, base);
	// 82EB35EC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB35F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB35F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB35F8: 388BA464  addi r4, r11, -0x5b9c
	ctx.r[4].s64 = ctx.r[11].s64 + -23452;
	// 82EB35FC: 915F0180  stw r10, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[10].u32 ) };
	// 82EB3600: 4BFCDBD1  bl 0x82e811d0
	ctx.lr = 0x82EB3604;
	sub_82E811D0(ctx, base);
	// 82EB3604: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3608: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB360C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB3610: 388BA444  addi r4, r11, -0x5bbc
	ctx.r[4].s64 = ctx.r[11].s64 + -23484;
	// 82EB3614: 915F0188  stw r10, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[10].u32 ) };
	// 82EB3618: 4BFCDBB9  bl 0x82e811d0
	ctx.lr = 0x82EB361C;
	sub_82E811D0(ctx, base);
	// 82EB361C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3620: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3628: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB362C: 915F018C  stw r10, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[10].u32 ) };
	// 82EB3630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3634: 4E800421  bctrl
	ctx.lr = 0x82EB3638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3638: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB363C: 418200E0  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3640: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3648: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB364C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3650: 4E800421  bctrl
	ctx.lr = 0x82EB3654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3654: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3658: 418200C4  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB365C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3664: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB3668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB366C: 4E800421  bctrl
	ctx.lr = 0x82EB3670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3670: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3674: 418200A8  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB367C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3680: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB3684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3688: 4E800421  bctrl
	ctx.lr = 0x82EB368C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB368C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3690: 4182008C  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3694: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB3698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB369C: 409A0010  bne cr6, 0x82eb36ac
	if !ctx.cr[6].eq {
	pc = 0x82EB36AC; continue 'dispatch;
	}
	// 82EB36A0: 38800032  li r4, 0x32
	ctx.r[4].s64 = 50;
	// 82EB36A4: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB36A8: 4BFDF979  bl 0x82e93020
	ctx.lr = 0x82EB36AC;
	sub_82E93020(ctx, base);
	// 82EB36AC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB36B0: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB36B4: 388B5E98  addi r4, r11, 0x5e98
	ctx.r[4].s64 = ctx.r[11].s64 + 24216;
	// 82EB36B8: 4B3B4569  bl 0x82267c20
	ctx.lr = 0x82EB36BC;
	sub_82267C20(ctx, base);
	// 82EB36BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB36C0: 4182001C  beq 0x82eb36dc
	if ctx.cr[0].eq {
	pc = 0x82EB36DC; continue 'dispatch;
	}
	// 82EB36C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB36C8: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB36CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB36D0: 388B1130  addi r4, r11, 0x1130
	ctx.r[4].s64 = ctx.r[11].s64 + 4400;
	// 82EB36D4: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB36D8: 4BFE4CF1  bl 0x82e983c8
	ctx.lr = 0x82EB36DC;
	sub_82E983C8(ctx, base);
	// 82EB36DC: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB36E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB36E4: 4182001C  beq 0x82eb3700
	if ctx.cr[0].eq {
	pc = 0x82EB3700; continue 'dispatch;
	}
	// 82EB36E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB36EC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB36F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB36F4: 4E800421  bctrl
	ctx.lr = 0x82EB36F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB36F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB36FC: 41820020  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3700: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3708: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB370C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3710: 4E800421  bctrl
	ctx.lr = 0x82EB3714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3714: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3718: 48000008  b 0x82eb3720
	pc = 0x82EB3720; continue 'dispatch;
	// 82EB371C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB3720: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EB3724: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EB3728: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EB372C: 4BDF5D24  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB3730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB3730 size=2872
    let mut pc: u32 = 0x82EB3730;
    'dispatch: loop {
        match pc {
            0x82EB3730 => {
    //   block [0x82EB3730..0x82EB4268)
	// 82EB3730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB3734: 4BDF5CD9  bl 0x82ca940c
	ctx.lr = 0x82EB3738;
	sub_82CA93D0(ctx, base);
	// 82EB3738: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EB373C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EB3740: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB3744: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EB3748: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB374C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EB3750: 409A000C  bne cr6, 0x82eb375c
	if !ctx.cr[6].eq {
	pc = 0x82EB375C; continue 'dispatch;
	}
	// 82EB3754: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB3758: 48000B00  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB375C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3764: 3BCB88AC  addi r30, r11, -0x7754
	ctx.r[30].s64 = ctx.r[11].s64 + -30548;
	// 82EB3768: 483088F9  bl 0x831bc060
	ctx.lr = 0x82EB376C;
	sub_831BC060(ctx, base);
	// 82EB376C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3770: 4BDF93E1  bl 0x82cacb50
	ctx.lr = 0x82EB3774;
	sub_82CACB50(ctx, base);
	// 82EB3774: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB377C: 40820024  bne 0x82eb37a0
	if !ctx.cr[0].eq {
	pc = 0x82EB37A0; continue 'dispatch;
	}
	// 82EB3780: 4BA5A589  bl 0x8290dd08
	ctx.lr = 0x82EB3784;
	sub_8290DD08(ctx, base);
	// 82EB3784: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3788: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EB378C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB3790: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB3794: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3798: 4E800421  bctrl
	ctx.lr = 0x82EB379C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB379C: 48000ABC  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB37A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB37A4: 3BCBA674  addi r30, r11, -0x598c
	ctx.r[30].s64 = ctx.r[11].s64 + -22924;
	// 82EB37A8: 483088B9  bl 0x831bc060
	ctx.lr = 0x82EB37AC;
	sub_831BC060(ctx, base);
	// 82EB37AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB37B0: 4BDF93A1  bl 0x82cacb50
	ctx.lr = 0x82EB37B4;
	sub_82CACB50(ctx, base);
	// 82EB37B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB37B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB37BC: 40820048  bne 0x82eb3804
	if !ctx.cr[0].eq {
	pc = 0x82EB3804; continue 'dispatch;
	}
	// 82EB37C0: 4BA5A549  bl 0x8290dd08
	ctx.lr = 0x82EB37C4;
	sub_8290DD08(ctx, base);
	// 82EB37C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB37C8: 4182FF8C  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB37CC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB37D0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB37D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB37D8: 4182000C  beq 0x82eb37e4
	if ctx.cr[0].eq {
	pc = 0x82EB37E4; continue 'dispatch;
	}
	// 82EB37DC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB37E0: 4800000C  b 0x82eb37ec
	pc = 0x82EB37EC; continue 'dispatch;
	// 82EB37E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB37E8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB37EC: 4BDF83C5  bl 0x82cabbb0
	ctx.lr = 0x82EB37F0;
	sub_82CABBB0(ctx, base);
	// 82EB37F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB37F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB37F8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB37FC: D01D0034  stfs f0, 0x34(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB3800: 48000A58  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3804: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3808: 3BCBA668  addi r30, r11, -0x5998
	ctx.r[30].s64 = ctx.r[11].s64 + -22936;
	// 82EB380C: 48308855  bl 0x831bc060
	ctx.lr = 0x82EB3810;
	sub_831BC060(ctx, base);
	// 82EB3810: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3814: 4BDF933D  bl 0x82cacb50
	ctx.lr = 0x82EB3818;
	sub_82CACB50(ctx, base);
	// 82EB3818: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB381C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3820: 40820080  bne 0x82eb38a0
	if !ctx.cr[0].eq {
	pc = 0x82EB38A0; continue 'dispatch;
	}
	// 82EB3824: 4BA5A4E5  bl 0x8290dd08
	ctx.lr = 0x82EB3828;
	sub_8290DD08(ctx, base);
	// 82EB3828: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB382C: 4182FF28  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3830: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82EB3834: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB3838: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB383C: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB3840: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3844: 4182000C  beq 0x82eb3850
	if ctx.cr[0].eq {
	pc = 0x82EB3850; continue 'dispatch;
	}
	// 82EB3848: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB384C: 48000008  b 0x82eb3854
	pc = 0x82EB3854; continue 'dispatch;
	// 82EB3850: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82EB3854: 4BDF835D  bl 0x82cabbb0
	ctx.lr = 0x82EB3858;
	sub_82CABBB0(ctx, base);
	// 82EB3858: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB385C: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3860: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3864: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3868: 4182000C  beq 0x82eb3874
	if ctx.cr[0].eq {
	pc = 0x82EB3874; continue 'dispatch;
	}
	// 82EB386C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3870: 48000008  b 0x82eb3878
	pc = 0x82EB3878; continue 'dispatch;
	// 82EB3874: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 82EB3878: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB387C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3880: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB3884: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3888: 816A0030  lwz r11, 0x30(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB388C: EC4D083A  fmadds f2, f13, f0, f1
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64);
	// 82EB3890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3894: 4E800421  bctrl
	ctx.lr = 0x82EB3898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3898: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB389C: 480009BC  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB38A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB38A4: 3BCBA65C  addi r30, r11, -0x59a4
	ctx.r[30].s64 = ctx.r[11].s64 + -22948;
	// 82EB38A8: 483087B9  bl 0x831bc060
	ctx.lr = 0x82EB38AC;
	sub_831BC060(ctx, base);
	// 82EB38AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB38B0: 4BDF92A1  bl 0x82cacb50
	ctx.lr = 0x82EB38B4;
	sub_82CACB50(ctx, base);
	// 82EB38B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB38B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB38BC: 40820048  bne 0x82eb3904
	if !ctx.cr[0].eq {
	pc = 0x82EB3904; continue 'dispatch;
	}
	// 82EB38C0: 4BA5A449  bl 0x8290dd08
	ctx.lr = 0x82EB38C4;
	sub_8290DD08(ctx, base);
	// 82EB38C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB38C8: 4182FE8C  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB38CC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB38D0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB38D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB38D8: 4182000C  beq 0x82eb38e4
	if ctx.cr[0].eq {
	pc = 0x82EB38E4; continue 'dispatch;
	}
	// 82EB38DC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB38E0: 4800000C  b 0x82eb38ec
	pc = 0x82EB38EC; continue 'dispatch;
	// 82EB38E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB38E8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB38EC: 4BDF82C5  bl 0x82cabbb0
	ctx.lr = 0x82EB38F0;
	sub_82CABBB0(ctx, base);
	// 82EB38F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB38F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB38F8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB38FC: D01D0038  stfs f0, 0x38(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB3900: 48000958  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3904: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3908: 3BCBA648  addi r30, r11, -0x59b8
	ctx.r[30].s64 = ctx.r[11].s64 + -22968;
	// 82EB390C: 48308755  bl 0x831bc060
	ctx.lr = 0x82EB3910;
	sub_831BC060(ctx, base);
	// 82EB3910: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3914: 4BDF923D  bl 0x82cacb50
	ctx.lr = 0x82EB3918;
	sub_82CACB50(ctx, base);
	// 82EB3918: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB391C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3920: 40820048  bne 0x82eb3968
	if !ctx.cr[0].eq {
	pc = 0x82EB3968; continue 'dispatch;
	}
	// 82EB3924: 4BA5A3E5  bl 0x8290dd08
	ctx.lr = 0x82EB3928;
	sub_8290DD08(ctx, base);
	// 82EB3928: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB392C: 4182FE28  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3930: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3934: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3938: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB393C: 4182000C  beq 0x82eb3948
	if ctx.cr[0].eq {
	pc = 0x82EB3948; continue 'dispatch;
	}
	// 82EB3940: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3944: 4800000C  b 0x82eb3950
	pc = 0x82EB3950; continue 'dispatch;
	// 82EB3948: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB394C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3950: 4BDF8261  bl 0x82cabbb0
	ctx.lr = 0x82EB3954;
	sub_82CABBB0(ctx, base);
	// 82EB3954: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3958: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB395C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3960: D01D0040  stfs f0, 0x40(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EB3964: 480008F4  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3968: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB396C: 3BCBA638  addi r30, r11, -0x59c8
	ctx.r[30].s64 = ctx.r[11].s64 + -22984;
	// 82EB3970: 483086F1  bl 0x831bc060
	ctx.lr = 0x82EB3974;
	sub_831BC060(ctx, base);
	// 82EB3974: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3978: 4BDF91D9  bl 0x82cacb50
	ctx.lr = 0x82EB397C;
	sub_82CACB50(ctx, base);
	// 82EB397C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3984: 40820048  bne 0x82eb39cc
	if !ctx.cr[0].eq {
	pc = 0x82EB39CC; continue 'dispatch;
	}
	// 82EB3988: 4BA5A381  bl 0x8290dd08
	ctx.lr = 0x82EB398C;
	sub_8290DD08(ctx, base);
	// 82EB398C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3990: 4182FDC4  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3994: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3998: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB399C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB39A0: 4182000C  beq 0x82eb39ac
	if ctx.cr[0].eq {
	pc = 0x82EB39AC; continue 'dispatch;
	}
	// 82EB39A4: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB39A8: 4800000C  b 0x82eb39b4
	pc = 0x82EB39B4; continue 'dispatch;
	// 82EB39AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB39B0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB39B4: 4BDF81FD  bl 0x82cabbb0
	ctx.lr = 0x82EB39B8;
	sub_82CABBB0(ctx, base);
	// 82EB39B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB39BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB39C0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB39C4: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EB39C8: 48000890  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB39CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB39D0: 3BCBA628  addi r30, r11, -0x59d8
	ctx.r[30].s64 = ctx.r[11].s64 + -23000;
	// 82EB39D4: 4830868D  bl 0x831bc060
	ctx.lr = 0x82EB39D8;
	sub_831BC060(ctx, base);
	// 82EB39D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB39DC: 4BDF9175  bl 0x82cacb50
	ctx.lr = 0x82EB39E0;
	sub_82CACB50(ctx, base);
	// 82EB39E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB39E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB39E8: 40820048  bne 0x82eb3a30
	if !ctx.cr[0].eq {
	pc = 0x82EB3A30; continue 'dispatch;
	}
	// 82EB39EC: 4BA5A31D  bl 0x8290dd08
	ctx.lr = 0x82EB39F0;
	sub_8290DD08(ctx, base);
	// 82EB39F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB39F4: 4182FD60  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB39F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB39FC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3A00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3A04: 4182000C  beq 0x82eb3a10
	if ctx.cr[0].eq {
	pc = 0x82EB3A10; continue 'dispatch;
	}
	// 82EB3A08: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A0C: 4800000C  b 0x82eb3a18
	pc = 0x82EB3A18; continue 'dispatch;
	// 82EB3A10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3A14: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A18: 4BDF8199  bl 0x82cabbb0
	ctx.lr = 0x82EB3A1C;
	sub_82CABBB0(ctx, base);
	// 82EB3A1C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3A20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3A24: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3A28: D01D0044  stfs f0, 0x44(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EB3A2C: 4800082C  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3A30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3A34: 3BCBA618  addi r30, r11, -0x59e8
	ctx.r[30].s64 = ctx.r[11].s64 + -23016;
	// 82EB3A38: 48308629  bl 0x831bc060
	ctx.lr = 0x82EB3A3C;
	sub_831BC060(ctx, base);
	// 82EB3A3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3A40: 4BDF9111  bl 0x82cacb50
	ctx.lr = 0x82EB3A44;
	sub_82CACB50(ctx, base);
	// 82EB3A44: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3A4C: 40820048  bne 0x82eb3a94
	if !ctx.cr[0].eq {
	pc = 0x82EB3A94; continue 'dispatch;
	}
	// 82EB3A50: 4BA5A2B9  bl 0x8290dd08
	ctx.lr = 0x82EB3A54;
	sub_8290DD08(ctx, base);
	// 82EB3A54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3A58: 4182FCFC  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3A5C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3A60: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3A64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3A68: 4182000C  beq 0x82eb3a74
	if ctx.cr[0].eq {
	pc = 0x82EB3A74; continue 'dispatch;
	}
	// 82EB3A6C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A70: 4800000C  b 0x82eb3a7c
	pc = 0x82EB3A7C; continue 'dispatch;
	// 82EB3A74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3A78: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A7C: 4BDF8135  bl 0x82cabbb0
	ctx.lr = 0x82EB3A80;
	sub_82CABBB0(ctx, base);
	// 82EB3A80: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3A84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3A88: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3A8C: D01D004C  stfs f0, 0x4c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EB3A90: 480007C8  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3A94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3A98: 3BCBA608  addi r30, r11, -0x59f8
	ctx.r[30].s64 = ctx.r[11].s64 + -23032;
	// 82EB3A9C: 483085C5  bl 0x831bc060
	ctx.lr = 0x82EB3AA0;
	sub_831BC060(ctx, base);
	// 82EB3AA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3AA4: 4BDF90AD  bl 0x82cacb50
	ctx.lr = 0x82EB3AA8;
	sub_82CACB50(ctx, base);
	// 82EB3AA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3AB0: 40820044  bne 0x82eb3af4
	if !ctx.cr[0].eq {
	pc = 0x82EB3AF4; continue 'dispatch;
	}
	// 82EB3AB4: 4BA5A255  bl 0x8290dd08
	ctx.lr = 0x82EB3AB8;
	sub_8290DD08(ctx, base);
	// 82EB3AB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3ABC: 4182FC98  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3AC0: 4BDF80F1  bl 0x82cabbb0
	ctx.lr = 0x82EB3AC4;
	sub_82CABBB0(ctx, base);
	// 82EB3AC4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3AC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3ACC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3AD0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB3AD4: 4099000C  ble cr6, 0x82eb3ae0
	if !ctx.cr[6].gt {
	pc = 0x82EB3AE0; continue 'dispatch;
	}
	// 82EB3AD8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB3ADC: 4800000C  b 0x82eb3ae8
	pc = 0x82EB3AE8; continue 'dispatch;
	// 82EB3AE0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB3AE4: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 82EB3AE8: D01D0050  stfs f0, 0x50(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB3AEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3AF0: 48000768  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3AF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3AF8: 3BCBA5F8  addi r30, r11, -0x5a08
	ctx.r[30].s64 = ctx.r[11].s64 + -23048;
	// 82EB3AFC: 48308565  bl 0x831bc060
	ctx.lr = 0x82EB3B00;
	sub_831BC060(ctx, base);
	// 82EB3B00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3B04: 4BDF904D  bl 0x82cacb50
	ctx.lr = 0x82EB3B08;
	sub_82CACB50(ctx, base);
	// 82EB3B08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3B10: 40820024  bne 0x82eb3b34
	if !ctx.cr[0].eq {
	pc = 0x82EB3B34; continue 'dispatch;
	}
	// 82EB3B14: 4BA5A1F5  bl 0x8290dd08
	ctx.lr = 0x82EB3B18;
	sub_8290DD08(ctx, base);
	// 82EB3B18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3B1C: 4182FC38  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3B20: 4BDF68A1  bl 0x82caa3c0
	ctx.lr = 0x82EB3B24;
	sub_82CAA3C0(ctx, base);
	// 82EB3B24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB3B28: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3B2C: 917D0054  stw r11, 0x54(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB3B30: 48000728  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3B34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3B38: 3BCBA5EC  addi r30, r11, -0x5a14
	ctx.r[30].s64 = ctx.r[11].s64 + -23060;
	// 82EB3B3C: 48308525  bl 0x831bc060
	ctx.lr = 0x82EB3B40;
	sub_831BC060(ctx, base);
	// 82EB3B40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3B44: 4BDF900D  bl 0x82cacb50
	ctx.lr = 0x82EB3B48;
	sub_82CACB50(ctx, base);
	// 82EB3B48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3B50: 40820048  bne 0x82eb3b98
	if !ctx.cr[0].eq {
	pc = 0x82EB3B98; continue 'dispatch;
	}
	// 82EB3B54: 4BA5A1B5  bl 0x8290dd08
	ctx.lr = 0x82EB3B58;
	sub_8290DD08(ctx, base);
	// 82EB3B58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3B5C: 4182FBF8  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3B60: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3B64: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3B68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3B6C: 4182000C  beq 0x82eb3b78
	if ctx.cr[0].eq {
	pc = 0x82EB3B78; continue 'dispatch;
	}
	// 82EB3B70: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3B74: 4800000C  b 0x82eb3b80
	pc = 0x82EB3B80; continue 'dispatch;
	// 82EB3B78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3B7C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3B80: 4BDF8031  bl 0x82cabbb0
	ctx.lr = 0x82EB3B84;
	sub_82CABBB0(ctx, base);
	// 82EB3B84: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3B88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3B8C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3B90: D01D0058  stfs f0, 0x58(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB3B94: 480006C4  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3B98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3B9C: 3BCBA5D0  addi r30, r11, -0x5a30
	ctx.r[30].s64 = ctx.r[11].s64 + -23088;
	// 82EB3BA0: 483084C1  bl 0x831bc060
	ctx.lr = 0x82EB3BA4;
	sub_831BC060(ctx, base);
	// 82EB3BA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3BA8: 4BDF8FA9  bl 0x82cacb50
	ctx.lr = 0x82EB3BAC;
	sub_82CACB50(ctx, base);
	// 82EB3BAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3BB4: 40820024  bne 0x82eb3bd8
	if !ctx.cr[0].eq {
	pc = 0x82EB3BD8; continue 'dispatch;
	}
	// 82EB3BB8: 4BA5A151  bl 0x8290dd08
	ctx.lr = 0x82EB3BBC;
	sub_8290DD08(ctx, base);
	// 82EB3BBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3BC0: 4182FB94  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3BC4: 4BDF7FED  bl 0x82cabbb0
	ctx.lr = 0x82EB3BC8;
	sub_82CABBB0(ctx, base);
	// 82EB3BC8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3BCC: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB3BD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3BD4: 48000684  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3BD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3BDC: 3BCBA5C0  addi r30, r11, -0x5a40
	ctx.r[30].s64 = ctx.r[11].s64 + -23104;
	// 82EB3BE0: 48308481  bl 0x831bc060
	ctx.lr = 0x82EB3BE4;
	sub_831BC060(ctx, base);
	// 82EB3BE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3BE8: 4BDF8F69  bl 0x82cacb50
	ctx.lr = 0x82EB3BEC;
	sub_82CACB50(ctx, base);
	// 82EB3BEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3BF4: 40820048  bne 0x82eb3c3c
	if !ctx.cr[0].eq {
	pc = 0x82EB3C3C; continue 'dispatch;
	}
	// 82EB3BF8: 4BA5A111  bl 0x8290dd08
	ctx.lr = 0x82EB3BFC;
	sub_8290DD08(ctx, base);
	// 82EB3BFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3C00: 4182FB54  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3C04: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3C08: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3C0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3C10: 4182000C  beq 0x82eb3c1c
	if ctx.cr[0].eq {
	pc = 0x82EB3C1C; continue 'dispatch;
	}
	// 82EB3C14: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3C18: 4800000C  b 0x82eb3c24
	pc = 0x82EB3C24; continue 'dispatch;
	// 82EB3C1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3C20: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3C24: 4BDF7F8D  bl 0x82cabbb0
	ctx.lr = 0x82EB3C28;
	sub_82CABBB0(ctx, base);
	// 82EB3C28: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3C2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3C30: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3C34: D01D005C  stfs f0, 0x5c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB3C38: 48000620  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3C3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3C40: 3BCBA5B4  addi r30, r11, -0x5a4c
	ctx.r[30].s64 = ctx.r[11].s64 + -23116;
	// 82EB3C44: 4830841D  bl 0x831bc060
	ctx.lr = 0x82EB3C48;
	sub_831BC060(ctx, base);
	// 82EB3C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3C4C: 4BDF8F05  bl 0x82cacb50
	ctx.lr = 0x82EB3C50;
	sub_82CACB50(ctx, base);
	// 82EB3C50: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3C58: 40820060  bne 0x82eb3cb8
	if !ctx.cr[0].eq {
	pc = 0x82EB3CB8; continue 'dispatch;
	}
	// 82EB3C5C: 4BA5A0AD  bl 0x8290dd08
	ctx.lr = 0x82EB3C60;
	sub_8290DD08(ctx, base);
	// 82EB3C60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3C64: 4182FAF0  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3C68: 4BDF7F49  bl 0x82cabbb0
	ctx.lr = 0x82EB3C6C;
	sub_82CABBB0(ctx, base);
	// 82EB3C6C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3C70: D01D0064  stfs f0, 0x64(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB3C74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3C78: 4BFD1D79  bl 0x82e859f0
	ctx.lr = 0x82EB3C7C;
	sub_82E859F0(ctx, base);
	// 82EB3C7C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB3C80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3C84: 4099FC14  ble cr6, 0x82eb3898
	if !ctx.cr[6].gt {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB3C88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB3C8C: 817D01AC  lwz r11, 0x1ac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB3C90: C01D0064  lfs f0, 0x64(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3C94: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3C98: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EB3C9C: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82EB3CA0: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB3CA4: 4BFD1D4D  bl 0x82e859f0
	ctx.lr = 0x82EB3CA8;
	sub_82E859F0(ctx, base);
	// 82EB3CA8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB3CAC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3CB0: 4198FFDC  blt cr6, 0x82eb3c8c
	if ctx.cr[6].lt {
	pc = 0x82EB3C8C; continue 'dispatch;
	}
	// 82EB3CB4: 4BFFFBE4  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
	// 82EB3CB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3CBC: 3BCBA5A4  addi r30, r11, -0x5a5c
	ctx.r[30].s64 = ctx.r[11].s64 + -23132;
	// 82EB3CC0: 483083A1  bl 0x831bc060
	ctx.lr = 0x82EB3CC4;
	sub_831BC060(ctx, base);
	// 82EB3CC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3CC8: 4BDF8E89  bl 0x82cacb50
	ctx.lr = 0x82EB3CCC;
	sub_82CACB50(ctx, base);
	// 82EB3CCC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3CD4: 40820030  bne 0x82eb3d04
	if !ctx.cr[0].eq {
	pc = 0x82EB3D04; continue 'dispatch;
	}
	// 82EB3CD8: 4BA5A031  bl 0x8290dd08
	ctx.lr = 0x82EB3CDC;
	sub_8290DD08(ctx, base);
	// 82EB3CDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3CE0: 4182FA74  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3CE4: 4BDF66DD  bl 0x82caa3c0
	ctx.lr = 0x82EB3CE8;
	sub_82CAA3C0(ctx, base);
	// 82EB3CE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB3CEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3CF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB3CF4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB3CF8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EB3CFC: 997D0068  stb r11, 0x68(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 82EB3D00: 48000558  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3D04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3D08: 3BCBA594  addi r30, r11, -0x5a6c
	ctx.r[30].s64 = ctx.r[11].s64 + -23148;
	// 82EB3D0C: 48308355  bl 0x831bc060
	ctx.lr = 0x82EB3D10;
	sub_831BC060(ctx, base);
	// 82EB3D10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3D14: 4BDF8E3D  bl 0x82cacb50
	ctx.lr = 0x82EB3D18;
	sub_82CACB50(ctx, base);
	// 82EB3D18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3D20: 4082004C  bne 0x82eb3d6c
	if !ctx.cr[0].eq {
	pc = 0x82EB3D6C; continue 'dispatch;
	}
	// 82EB3D24: 4BA59FE5  bl 0x8290dd08
	ctx.lr = 0x82EB3D28;
	sub_8290DD08(ctx, base);
	// 82EB3D28: 4BFFEB39  bl 0x82eb2860
	ctx.lr = 0x82EB3D2C;
	sub_82EB2860(ctx, base);
	// 82EB3D2C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3D30: 40820030  bne 0x82eb3d60
	if !ctx.cr[0].eq {
	pc = 0x82EB3D60; continue 'dispatch;
	}
	// 82EB3D34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3D38: 4B77A751  bl 0x8262e488
	ctx.lr = 0x82EB3D3C;
	sub_8262E488(ctx, base);
	// 82EB3D3C: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3D40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3D44: 4099FA10  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3D48: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3D4C: 4B77A73D  bl 0x8262e488
	ctx.lr = 0x82EB3D50;
	sub_8262E488(ctx, base);
	// 82EB3D50: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3D54: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3D58: 4198FFF0  blt cr6, 0x82eb3d48
	if ctx.cr[6].lt {
	pc = 0x82EB3D48; continue 'dispatch;
	}
	// 82EB3D5C: 4BFFF9F8  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3D60: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3D64: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EB3D68: 480004F0  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3D6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3D70: 3BCBA588  addi r30, r11, -0x5a78
	ctx.r[30].s64 = ctx.r[11].s64 + -23160;
	// 82EB3D74: 483082ED  bl 0x831bc060
	ctx.lr = 0x82EB3D78;
	sub_831BC060(ctx, base);
	// 82EB3D78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3D7C: 4BDF8DD5  bl 0x82cacb50
	ctx.lr = 0x82EB3D80;
	sub_82CACB50(ctx, base);
	// 82EB3D80: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3D88: 4082004C  bne 0x82eb3dd4
	if !ctx.cr[0].eq {
	pc = 0x82EB3DD4; continue 'dispatch;
	}
	// 82EB3D8C: 4BA59F7D  bl 0x8290dd08
	ctx.lr = 0x82EB3D90;
	sub_8290DD08(ctx, base);
	// 82EB3D90: 4BFFEB91  bl 0x82eb2920
	ctx.lr = 0x82EB3D94;
	sub_82EB2920(ctx, base);
	// 82EB3D94: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3D98: 40820030  bne 0x82eb3dc8
	if !ctx.cr[0].eq {
	pc = 0x82EB3DC8; continue 'dispatch;
	}
	// 82EB3D9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3DA0: 4B77A781  bl 0x8262e520
	ctx.lr = 0x82EB3DA4;
	sub_8262E520(ctx, base);
	// 82EB3DA4: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3DA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3DAC: 4099F9A8  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3DB0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3DB4: 4B77A76D  bl 0x8262e520
	ctx.lr = 0x82EB3DB8;
	sub_8262E520(ctx, base);
	// 82EB3DB8: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3DBC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3DC0: 4198FFF0  blt cr6, 0x82eb3db0
	if ctx.cr[6].lt {
	pc = 0x82EB3DB0; continue 'dispatch;
	}
	// 82EB3DC4: 4BFFF990  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3DC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3DCC: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EB3DD0: 48000488  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3DD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3DD8: 3BCBA578  addi r30, r11, -0x5a88
	ctx.r[30].s64 = ctx.r[11].s64 + -23176;
	// 82EB3DDC: 48308285  bl 0x831bc060
	ctx.lr = 0x82EB3DE0;
	sub_831BC060(ctx, base);
	// 82EB3DE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3DE4: 4BDF8D6D  bl 0x82cacb50
	ctx.lr = 0x82EB3DE8;
	sub_82CACB50(ctx, base);
	// 82EB3DE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3DF0: 4082004C  bne 0x82eb3e3c
	if !ctx.cr[0].eq {
	pc = 0x82EB3E3C; continue 'dispatch;
	}
	// 82EB3DF4: 4BA59F15  bl 0x8290dd08
	ctx.lr = 0x82EB3DF8;
	sub_8290DD08(ctx, base);
	// 82EB3DF8: 4BFFECA9  bl 0x82eb2aa0
	ctx.lr = 0x82EB3DFC;
	sub_82EB2AA0(ctx, base);
	// 82EB3DFC: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E00: 40820030  bne 0x82eb3e30
	if !ctx.cr[0].eq {
	pc = 0x82EB3E30; continue 'dispatch;
	}
	// 82EB3E04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3E08: 4BFFE9E1  bl 0x82eb27e8
	ctx.lr = 0x82EB3E0C;
	sub_82EB27E8(ctx, base);
	// 82EB3E0C: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E14: 4099F940  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3E18: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3E1C: 4BFFE9CD  bl 0x82eb27e8
	ctx.lr = 0x82EB3E20;
	sub_82EB27E8(ctx, base);
	// 82EB3E20: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E24: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3E28: 4198FFF0  blt cr6, 0x82eb3e18
	if ctx.cr[6].lt {
	pc = 0x82EB3E18; continue 'dispatch;
	}
	// 82EB3E2C: 4BFFF928  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3E30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3E34: 917D00B0  stw r11, 0xb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EB3E38: 48000420  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3E3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3E40: 3BCBA56C  addi r30, r11, -0x5a94
	ctx.r[30].s64 = ctx.r[11].s64 + -23188;
	// 82EB3E44: 4830821D  bl 0x831bc060
	ctx.lr = 0x82EB3E48;
	sub_831BC060(ctx, base);
	// 82EB3E48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3E4C: 4BDF8D05  bl 0x82cacb50
	ctx.lr = 0x82EB3E50;
	sub_82CACB50(ctx, base);
	// 82EB3E50: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3E58: 4082004C  bne 0x82eb3ea4
	if !ctx.cr[0].eq {
	pc = 0x82EB3EA4; continue 'dispatch;
	}
	// 82EB3E5C: 4BA59EAD  bl 0x8290dd08
	ctx.lr = 0x82EB3E60;
	sub_8290DD08(ctx, base);
	// 82EB3E60: 4BFFED01  bl 0x82eb2b60
	ctx.lr = 0x82EB3E64;
	sub_82EB2B60(ctx, base);
	// 82EB3E64: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E68: 40820030  bne 0x82eb3e98
	if !ctx.cr[0].eq {
	pc = 0x82EB3E98; continue 'dispatch;
	}
	// 82EB3E6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3E70: 4B77A879  bl 0x8262e6e8
	ctx.lr = 0x82EB3E74;
	sub_8262E6E8(ctx, base);
	// 82EB3E74: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E7C: 4099F8D8  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3E80: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3E84: 4B77A865  bl 0x8262e6e8
	ctx.lr = 0x82EB3E88;
	sub_8262E6E8(ctx, base);
	// 82EB3E88: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E8C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3E90: 4198FFF0  blt cr6, 0x82eb3e80
	if ctx.cr[6].lt {
	pc = 0x82EB3E80; continue 'dispatch;
	}
	// 82EB3E94: 4BFFF8C0  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3E98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3E9C: 917D00B4  stw r11, 0xb4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82EB3EA0: 480003B8  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3EA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3EA8: 3BCBA560  addi r30, r11, -0x5aa0
	ctx.r[30].s64 = ctx.r[11].s64 + -23200;
	// 82EB3EAC: 483081B5  bl 0x831bc060
	ctx.lr = 0x82EB3EB0;
	sub_831BC060(ctx, base);
	// 82EB3EB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3EB4: 4BDF8C9D  bl 0x82cacb50
	ctx.lr = 0x82EB3EB8;
	sub_82CACB50(ctx, base);
	// 82EB3EB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3EC0: 4082004C  bne 0x82eb3f0c
	if !ctx.cr[0].eq {
	pc = 0x82EB3F0C; continue 'dispatch;
	}
	// 82EB3EC4: 4BA59E45  bl 0x8290dd08
	ctx.lr = 0x82EB3EC8;
	sub_8290DD08(ctx, base);
	// 82EB3EC8: 4BFFEC99  bl 0x82eb2b60
	ctx.lr = 0x82EB3ECC;
	sub_82EB2B60(ctx, base);
	// 82EB3ECC: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3ED0: 40820030  bne 0x82eb3f00
	if !ctx.cr[0].eq {
	pc = 0x82EB3F00; continue 'dispatch;
	}
	// 82EB3ED4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3ED8: 4B77A811  bl 0x8262e6e8
	ctx.lr = 0x82EB3EDC;
	sub_8262E6E8(ctx, base);
	// 82EB3EDC: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3EE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3EE4: 4099F870  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3EE8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3EEC: 4B77A7FD  bl 0x8262e6e8
	ctx.lr = 0x82EB3EF0;
	sub_8262E6E8(ctx, base);
	// 82EB3EF0: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3EF4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3EF8: 4198FFF0  blt cr6, 0x82eb3ee8
	if ctx.cr[6].lt {
	pc = 0x82EB3EE8; continue 'dispatch;
	}
	// 82EB3EFC: 4BFFF858  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3F00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3F04: 917D00B8  stw r11, 0xb8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EB3F08: 48000350  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3F0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3F10: 3BCBA548  addi r30, r11, -0x5ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -23224;
	// 82EB3F14: 4830814D  bl 0x831bc060
	ctx.lr = 0x82EB3F18;
	sub_831BC060(ctx, base);
	// 82EB3F18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3F1C: 4BDF8C35  bl 0x82cacb50
	ctx.lr = 0x82EB3F20;
	sub_82CACB50(ctx, base);
	// 82EB3F20: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3F28: 4082004C  bne 0x82eb3f74
	if !ctx.cr[0].eq {
	pc = 0x82EB3F74; continue 'dispatch;
	}
	// 82EB3F2C: 4BA59DDD  bl 0x8290dd08
	ctx.lr = 0x82EB3F30;
	sub_8290DD08(ctx, base);
	// 82EB3F30: 4BFFEDB1  bl 0x82eb2ce0
	ctx.lr = 0x82EB3F34;
	sub_82EB2CE0(ctx, base);
	// 82EB3F34: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3F38: 40820030  bne 0x82eb3f68
	if !ctx.cr[0].eq {
	pc = 0x82EB3F68; continue 'dispatch;
	}
	// 82EB3F3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3F40: 4B77A711  bl 0x8262e650
	ctx.lr = 0x82EB3F44;
	sub_8262E650(ctx, base);
	// 82EB3F44: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3F48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3F4C: 4099F808  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3F50: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3F54: 4B77A6FD  bl 0x8262e650
	ctx.lr = 0x82EB3F58;
	sub_8262E650(ctx, base);
	// 82EB3F58: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3F5C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3F60: 4198FFF0  blt cr6, 0x82eb3f50
	if ctx.cr[6].lt {
	pc = 0x82EB3F50; continue 'dispatch;
	}
	// 82EB3F64: 4BFFF7F0  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3F68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3F6C: 917D00AC  stw r11, 0xac(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82EB3F70: 480002E8  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3F74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3F78: 3BCBA53C  addi r30, r11, -0x5ac4
	ctx.r[30].s64 = ctx.r[11].s64 + -23236;
	// 82EB3F7C: 483080E5  bl 0x831bc060
	ctx.lr = 0x82EB3F80;
	sub_831BC060(ctx, base);
	// 82EB3F80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3F84: 4BDF8BCD  bl 0x82cacb50
	ctx.lr = 0x82EB3F88;
	sub_82CACB50(ctx, base);
	// 82EB3F88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3F90: 4082004C  bne 0x82eb3fdc
	if !ctx.cr[0].eq {
	pc = 0x82EB3FDC; continue 'dispatch;
	}
	// 82EB3F94: 4BA59D75  bl 0x8290dd08
	ctx.lr = 0x82EB3F98;
	sub_8290DD08(ctx, base);
	// 82EB3F98: 4BFFEC89  bl 0x82eb2c20
	ctx.lr = 0x82EB3F9C;
	sub_82EB2C20(ctx, base);
	// 82EB3F9C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3FA0: 40820030  bne 0x82eb3fd0
	if !ctx.cr[0].eq {
	pc = 0x82EB3FD0; continue 'dispatch;
	}
	// 82EB3FA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3FA8: 4B77A611  bl 0x8262e5b8
	ctx.lr = 0x82EB3FAC;
	sub_8262E5B8(ctx, base);
	// 82EB3FAC: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3FB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3FB4: 4099F7A0  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3FB8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3FBC: 4B77A5FD  bl 0x8262e5b8
	ctx.lr = 0x82EB3FC0;
	sub_8262E5B8(ctx, base);
	// 82EB3FC0: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3FC4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3FC8: 4198FFF0  blt cr6, 0x82eb3fb8
	if ctx.cr[6].lt {
	pc = 0x82EB3FB8; continue 'dispatch;
	}
	// 82EB3FCC: 4BFFF788  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3FD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3FD4: 917D00A8  stw r11, 0xa8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EB3FD8: 48000280  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3FDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3FE0: 3BCBA534  addi r30, r11, -0x5acc
	ctx.r[30].s64 = ctx.r[11].s64 + -23244;
	// 82EB3FE4: 4830807D  bl 0x831bc060
	ctx.lr = 0x82EB3FE8;
	sub_831BC060(ctx, base);
	// 82EB3FE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3FEC: 4BDF8B65  bl 0x82cacb50
	ctx.lr = 0x82EB3FF0;
	sub_82CACB50(ctx, base);
	// 82EB3FF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3FF8: 4082004C  bne 0x82eb4044
	if !ctx.cr[0].eq {
	pc = 0x82EB4044; continue 'dispatch;
	}
	// 82EB3FFC: 4BA59D0D  bl 0x8290dd08
	ctx.lr = 0x82EB4000;
	sub_8290DD08(ctx, base);
	// 82EB4000: 4BFFE9E1  bl 0x82eb29e0
	ctx.lr = 0x82EB4004;
	sub_82EB29E0(ctx, base);
	// 82EB4004: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4008: 40820030  bne 0x82eb4038
	if !ctx.cr[0].eq {
	pc = 0x82EB4038; continue 'dispatch;
	}
	// 82EB400C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB4010: 4BFFE761  bl 0x82eb2770
	ctx.lr = 0x82EB4014;
	sub_82EB2770(ctx, base);
	// 82EB4014: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB4018: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB401C: 4099F738  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB4020: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB4024: 4BFFE74D  bl 0x82eb2770
	ctx.lr = 0x82EB4028;
	sub_82EB2770(ctx, base);
	// 82EB4028: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB402C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB4030: 4198FFF0  blt cr6, 0x82eb4020
	if ctx.cr[6].lt {
	pc = 0x82EB4020; continue 'dispatch;
	}
	// 82EB4034: 4BFFF720  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB4038: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB403C: 917D00A4  stw r11, 0xa4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EB4040: 48000218  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB4044: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4048: 3BCBA528  addi r30, r11, -0x5ad8
	ctx.r[30].s64 = ctx.r[11].s64 + -23256;
	// 82EB404C: 48308015  bl 0x831bc060
	ctx.lr = 0x82EB4050;
	sub_831BC060(ctx, base);
	// 82EB4050: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4054: 4BDF8AFD  bl 0x82cacb50
	ctx.lr = 0x82EB4058;
	sub_82CACB50(ctx, base);
	// 82EB4058: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB405C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4060: 4082001C  bne 0x82eb407c
	if !ctx.cr[0].eq {
	pc = 0x82EB407C; continue 'dispatch;
	}
	// 82EB4064: 4BA59CA5  bl 0x8290dd08
	ctx.lr = 0x82EB4068;
	sub_8290DD08(ctx, base);
	// 82EB4068: 4BDF6359  bl 0x82caa3c0
	ctx.lr = 0x82EB406C;
	sub_82CAA3C0(ctx, base);
	// 82EB406C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EB4070: 387D0074  addi r3, r29, 0x74
	ctx.r[3].s64 = ctx.r[29].s64 + 116;
	// 82EB4074: 4BFDEFAD  bl 0x82e93020
	ctx.lr = 0x82EB4078;
	sub_82E93020(ctx, base);
	// 82EB4078: 4BFFF820  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
	// 82EB407C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4080: 3BCBA518  addi r30, r11, -0x5ae8
	ctx.r[30].s64 = ctx.r[11].s64 + -23272;
	// 82EB4084: 48307FDD  bl 0x831bc060
	ctx.lr = 0x82EB4088;
	sub_831BC060(ctx, base);
	// 82EB4088: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB408C: 4BDF8AC5  bl 0x82cacb50
	ctx.lr = 0x82EB4090;
	sub_82CACB50(ctx, base);
	// 82EB4090: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4098: 40820084  bne 0x82eb411c
	if !ctx.cr[0].eq {
	pc = 0x82EB411C; continue 'dispatch;
	}
	// 82EB409C: 4BA59C6D  bl 0x8290dd08
	ctx.lr = 0x82EB40A0;
	sub_8290DD08(ctx, base);
	// 82EB40A0: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82EB40A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB40A8: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB40AC: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB40B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB40B4: 4182000C  beq 0x82eb40c0
	if ctx.cr[0].eq {
	pc = 0x82EB40C0; continue 'dispatch;
	}
	// 82EB40B8: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB40BC: 48000008  b 0x82eb40c4
	pc = 0x82EB40C4; continue 'dispatch;
	// 82EB40C0: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82EB40C4: 4BDF7AED  bl 0x82cabbb0
	ctx.lr = 0x82EB40C8;
	sub_82CABBB0(ctx, base);
	// 82EB40C8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB40CC: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB40D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB40D4: ED8007F2  fmuls f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB40D8: 4182000C  beq 0x82eb40e4
	if ctx.cr[0].eq {
	pc = 0x82EB40E4; continue 'dispatch;
	}
	// 82EB40DC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB40E0: 48000008  b 0x82eb40e8
	pc = 0x82EB40E8; continue 'dispatch;
	// 82EB40E4: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 82EB40E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB40EC: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB40F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB40F4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB40F8: D01D01C4  stfs f0, 0x1c4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB40FC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4100: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EB4104: 41980008  blt cr6, 0x82eb410c
	if ctx.cr[6].lt {
	pc = 0x82EB410C; continue 'dispatch;
	}
	// 82EB4108: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 82EB410C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EB4110: 409AFFF0  bne cr6, 0x82eb4100
	if !ctx.cr[6].eq {
	pc = 0x82EB4100; continue 'dispatch;
	}
	// 82EB4114: D01D01C4  stfs f0, 0x1c4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB4118: 4BFFF780  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
	// 82EB411C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4120: 3BCBA504  addi r30, r11, -0x5afc
	ctx.r[30].s64 = ctx.r[11].s64 + -23292;
	// 82EB4124: 48307F3D  bl 0x831bc060
	ctx.lr = 0x82EB4128;
	sub_831BC060(ctx, base);
	// 82EB4128: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB412C: 4BDF8A25  bl 0x82cacb50
	ctx.lr = 0x82EB4130;
	sub_82CACB50(ctx, base);
	// 82EB4130: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4138: 408200AC  bne 0x82eb41e4
	if !ctx.cr[0].eq {
	pc = 0x82EB41E4; continue 'dispatch;
	}
	// 82EB413C: 4BA59BCD  bl 0x8290dd08
	ctx.lr = 0x82EB4140;
	sub_8290DD08(ctx, base);
	// 82EB4140: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB4144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB4148: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EB414C: 4BDF8A05  bl 0x82cacb50
	ctx.lr = 0x82EB4150;
	sub_82CACB50(ctx, base);
	// 82EB4150: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4154: 41820084  beq 0x82eb41d8
	if ctx.cr[0].eq {
	pc = 0x82EB41D8; continue 'dispatch;
	}
	// 82EB4158: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB415C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4160: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EB4164: 4BDF89ED  bl 0x82cacb50
	ctx.lr = 0x82EB4168;
	sub_82CACB50(ctx, base);
	// 82EB4168: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB416C: 4182006C  beq 0x82eb41d8
	if ctx.cr[0].eq {
	pc = 0x82EB41D8; continue 'dispatch;
	}
	// 82EB4170: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EB4174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4178: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EB417C: 4BDF89D5  bl 0x82cacb50
	ctx.lr = 0x82EB4180;
	sub_82CACB50(ctx, base);
	// 82EB4180: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4184: 41820054  beq 0x82eb41d8
	if ctx.cr[0].eq {
	pc = 0x82EB41D8; continue 'dispatch;
	}
	// 82EB4188: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB418C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4190: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EB4194: 4BDF89BD  bl 0x82cacb50
	ctx.lr = 0x82EB4198;
	sub_82CACB50(ctx, base);
	// 82EB4198: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB419C: 41820034  beq 0x82eb41d0
	if ctx.cr[0].eq {
	pc = 0x82EB41D0; continue 'dispatch;
	}
	// 82EB41A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB41A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB41A8: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EB41AC: 4BDF89A5  bl 0x82cacb50
	ctx.lr = 0x82EB41B0;
	sub_82CACB50(ctx, base);
	// 82EB41B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB41B4: 4182001C  beq 0x82eb41d0
	if ctx.cr[0].eq {
	pc = 0x82EB41D0; continue 'dispatch;
	}
	// 82EB41B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB41BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB41C0: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EB41C4: 4BDF898D  bl 0x82cacb50
	ctx.lr = 0x82EB41C8;
	sub_82CACB50(ctx, base);
	// 82EB41C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB41CC: 4082F588  bne 0x82eb3754
	if !ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB41D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB41D4: 48000008  b 0x82eb41dc
	pc = 0x82EB41DC; continue 'dispatch;
	// 82EB41D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB41DC: 997D0069  stb r11, 0x69(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82EB41E0: 4BFFF6B8  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
	// 82EB41E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB41E8: 3BCBA4DC  addi r30, r11, -0x5b24
	ctx.r[30].s64 = ctx.r[11].s64 + -23332;
	// 82EB41EC: 48307E75  bl 0x831bc060
	ctx.lr = 0x82EB41F0;
	sub_831BC060(ctx, base);
	// 82EB41F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB41F4: 4BDF895D  bl 0x82cacb50
	ctx.lr = 0x82EB41F8;
	sub_82CACB50(ctx, base);
	// 82EB41F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB41FC: 4182F69C  beq 0x82eb3898
	if ctx.cr[0].eq {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB4200: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4208: 3BCBA4F4  addi r30, r11, -0x5b0c
	ctx.r[30].s64 = ctx.r[11].s64 + -23308;
	// 82EB420C: 48307E55  bl 0x831bc060
	ctx.lr = 0x82EB4210;
	sub_831BC060(ctx, base);
	// 82EB4210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4214: 4BDF893D  bl 0x82cacb50
	ctx.lr = 0x82EB4218;
	sub_82CACB50(ctx, base);
	// 82EB4218: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB421C: 4182F67C  beq 0x82eb3898
	if ctx.cr[0].eq {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB4220: 807D01B0  lwz r3, 0x1b0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB4224: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4228: 41820024  beq 0x82eb424c
	if ctx.cr[0].eq {
	pc = 0x82EB424C; continue 'dispatch;
	}
	// 82EB422C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4230: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB4234: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB4238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB423C: 4E800421  bctrl
	ctx.lr = 0x82EB4240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4240: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4244: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB4248: 419AF650  beq cr6, 0x82eb3898
	if ctx.cr[6].eq {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB424C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB4250: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB4254: 4B7653E5  bl 0x82619638
	ctx.lr = 0x82EB4258;
	sub_82619638(ctx, base);
	// 82EB4258: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB425C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EB4260: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EB4264: 4BDF51F8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB4268 size=8
    let mut pc: u32 = 0x82EB4268;
    'dispatch: loop {
        match pc {
            0x82EB4268 => {
    //   block [0x82EB4268..0x82EB4270)
	// 82EB4268: 8063006C  lwz r3, 0x6c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB426C: 4BFDAAD4  b 0x82e8ed40
	sub_82E8ED40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4270 size=52
    let mut pc: u32 = 0x82EB4270;
    'dispatch: loop {
        match pc {
            0x82EB4270 => {
    //   block [0x82EB4270..0x82EB42A4)
	// 82EB4270: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4274: C00B00D8  lfs f0, 0xd8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4278: C1AB0044  lfs f13, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB427C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4280: 41990050  bgt cr6, 0x82eb42d0
	if ctx.cr[6].gt {
		sub_82EB42D0(ctx, base);
		return;
	}
	// 82EB4284: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4288: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB428C: 41980044  blt cr6, 0x82eb42d0
	if ctx.cr[6].lt {
		sub_82EB42D0(ctx, base);
		return;
	}
	// 82EB4290: 894B00C1  lbz r10, 0xc1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(193 as u32) ) } as u64;
	// 82EB4294: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4298: 4182000C  beq 0x82eb42a4
	if ctx.cr[0].eq {
		sub_82EB42A4(ctx, base);
		return;
	}
	// 82EB429C: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB42A0: 48000008  b 0x82eb42a8
	sub_82EB42A4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB42A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB42A4 size=44
    let mut pc: u32 = 0x82EB42A4;
    'dispatch: loop {
        match pc {
            0x82EB42A4 => {
    //   block [0x82EB42A4..0x82EB42D0)
	// 82EB42A4: C00B0014  lfs f0, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB42A8: C1AB00DC  lfs f13, 0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB42AC: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB42B0: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB42B4: C00B00D4  lfs f0, 0xd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB42B8: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB42BC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EB42C0: 41990010  bgt cr6, 0x82eb42d0
	if ctx.cr[6].gt {
		sub_82EB42D0(ctx, base);
		return;
	}
	// 82EB42C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB42C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB42CC: 4800000C  b 0x82eb42d8
	sub_82EB42D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB42D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB42D0 size=16
    let mut pc: u32 = 0x82EB42D0;
    'dispatch: loop {
        match pc {
            0x82EB42D0 => {
    //   block [0x82EB42D0..0x82EB42E0)
	// 82EB42D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB42D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB42D8: 994B00C1  stb r10, 0xc1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(193 as u32), ctx.r[10].u8 ) };
	// 82EB42DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB42E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB42E0 size=28
    let mut pc: u32 = 0x82EB42E0;
    'dispatch: loop {
        match pc {
            0x82EB42E0 => {
    //   block [0x82EB42E0..0x82EB42FC)
	// 82EB42E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB42E4: C0230044  lfs f1, 0x44(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB42E8: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82EB42EC: 8063006C  lwz r3, 0x6c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB42F0: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82EB42F4: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB42F8: 4BFDA290  b 0x82e8e588
	sub_82E8E588(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB4300 size=32
    let mut pc: u32 = 0x82EB4300;
    'dispatch: loop {
        match pc {
            0x82EB4300 => {
    //   block [0x82EB4300..0x82EB4320)
	// 82EB4300: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4304: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82EB4308: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82EB430C: 814B0178  lwz r10, 0x178(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(376 as u32) ) } as u64;
	// 82EB4310: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4314: 4082000C  bne 0x82eb4320
	if !ctx.cr[0].eq {
		sub_82EB4320(ctx, base);
		return;
	}
	// 82EB4318: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB431C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4320 size=24
    let mut pc: u32 = 0x82EB4320;
    'dispatch: loop {
        match pc {
            0x82EB4320 => {
    //   block [0x82EB4320..0x82EB4338)
	// 82EB4320: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4324: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB4328: C02B0044  lfs f1, 0x44(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB432C: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82EB4330: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4334: 4BFDA334  b 0x82e8e668
	sub_82E8E668(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB4338 size=32
    let mut pc: u32 = 0x82EB4338;
    'dispatch: loop {
        match pc {
            0x82EB4338 => {
    //   block [0x82EB4338..0x82EB4358)
	// 82EB4338: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB433C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82EB4340: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82EB4344: 814B0178  lwz r10, 0x178(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(376 as u32) ) } as u64;
	// 82EB4348: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB434C: 4082000C  bne 0x82eb4358
	if !ctx.cr[0].eq {
		sub_82EB4358(ctx, base);
		return;
	}
	// 82EB4350: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB4354: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4358 size=24
    let mut pc: u32 = 0x82EB4358;
    'dispatch: loop {
        match pc {
            0x82EB4358 => {
    //   block [0x82EB4358..0x82EB4370)
	// 82EB4358: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB435C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB4360: C02B0044  lfs f1, 0x44(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB4364: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82EB4368: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB436C: 4BFDA5C4  b 0x82e8e930
	sub_82E8E930(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4370 size=448
    let mut pc: u32 = 0x82EB4370;
    'dispatch: loop {
        match pc {
            0x82EB4370 => {
    //   block [0x82EB4370..0x82EB4530)
	// 82EB4370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB437C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB4380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB4388: 3BDF00F8  addi r30, r31, 0xf8
	ctx.r[30].s64 = ctx.r[31].s64 + 248;
	// 82EB438C: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4390: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4394: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4398: 409A0028  bne cr6, 0x82eb43c0
	if !ctx.cr[6].eq {
	pc = 0x82EB43C0; continue 'dispatch;
	}
	// 82EB439C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB43A0: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB43A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB43A8: 409A0018  bne cr6, 0x82eb43c0
	if !ctx.cr[6].eq {
	pc = 0x82EB43C0; continue 'dispatch;
	}
	// 82EB43AC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB43B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB43B4: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB43B8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB43BC: 419A0008  beq cr6, 0x82eb43c4
	if ctx.cr[6].eq {
	pc = 0x82EB43C4; continue 'dispatch;
	}
	// 82EB43C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB43C4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB43C8: 4082014C  bne 0x82eb4514
	if !ctx.cr[0].eq {
	pc = 0x82EB4514; continue 'dispatch;
	}
	// 82EB43CC: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB43D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB43D4: 4182004C  beq 0x82eb4420
	if ctx.cr[0].eq {
	pc = 0x82EB4420; continue 'dispatch;
	}
	// 82EB43D8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB43DC: 419A0044  beq cr6, 0x82eb4420
	if ctx.cr[6].eq {
	pc = 0x82EB4420; continue 'dispatch;
	}
	// 82EB43E0: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB43E4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB43E8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB43EC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB43F0: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB43F4: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB43F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB43FC: 41820024  beq 0x82eb4420
	if ctx.cr[0].eq {
	pc = 0x82EB4420; continue 'dispatch;
	}
	// 82EB4400: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4404: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB4408: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB440C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EB4410: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4414: 4E800421  bctrl
	ctx.lr = 0x82EB4418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4418: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB441C: 418200F8  beq 0x82eb4514
	if ctx.cr[0].eq {
	pc = 0x82EB4514; continue 'dispatch;
	}
	// 82EB4420: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4424: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB4428: 4BFDED61  bl 0x82e93188
	ctx.lr = 0x82EB442C;
	sub_82E93188(ctx, base);
	// 82EB442C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB4430: 907F013C  stw r3, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[3].u32 ) };
	// 82EB4434: 409A000C  bne cr6, 0x82eb4440
	if !ctx.cr[6].eq {
	pc = 0x82EB4440; continue 'dispatch;
	}
	// 82EB4438: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB443C: 480000DC  b 0x82eb4518
	pc = 0x82EB4518; continue 'dispatch;
	// 82EB4440: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4444: 1D63000C  mulli r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 * 12;
	// 82EB4448: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB444C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4450: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4454: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4458: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB445C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4460: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4464: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4468: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB446C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4470: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4474: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4478: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB447C: C17F0118  lfs f11, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB4480: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4484: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4488: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB448C: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB4490: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4494: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4498: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB449C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB44A0: 40980074  bge cr6, 0x82eb4514
	if !ctx.cr[6].lt {
	pc = 0x82EB4514; continue 'dispatch;
	}
	// 82EB44A4: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB44A8: 813F007C  lwz r9, 0x7c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB44AC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB44B0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB44B4: 4098002C  bge cr6, 0x82eb44e0
	if !ctx.cr[6].lt {
	pc = 0x82EB44E0; continue 'dispatch;
	}
	// 82EB44B8: 813F0088  lwz r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB44BC: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 * 12;
	// 82EB44C0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EB44C4: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 82EB44C8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44CC: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB44D0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44D4: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB44D8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44DC: 48000018  b 0x82eb44f4
	pc = 0x82EB44F4; continue 'dispatch;
	// 82EB44E0: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44E4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB44E8: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44EC: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB44F0: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44F4: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB44F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB44FC: 83FF0188  lwz r31, 0x188(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4500: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4504: 4B3AC4B5  bl 0x822609b8
	ctx.lr = 0x82EB4508;
	sub_822609B8(ctx, base);
	// 82EB4508: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB450C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB4510: 4B410D29  bl 0x822c5238
	ctx.lr = 0x82EB4514;
	sub_822C5238(ctx, base);
	// 82EB4514: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4518: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB451C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4524: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB4528: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB452C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4530 size=1648
    let mut pc: u32 = 0x82EB4530;
    'dispatch: loop {
        match pc {
            0x82EB4530 => {
    //   block [0x82EB4530..0x82EB4BA0)
	// 82EB4530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4534: 4BDF4EB5  bl 0x82ca93e8
	ctx.lr = 0x82EB4538;
	sub_82CA93D0(ctx, base);
	// 82EB4538: DBA1FF80  stfd f29, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[29].u64 ) };
	// 82EB453C: DBC1FF88  stfd f30, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 82EB4540: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82EB4544: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB454C: 3ADF00E0  addi r22, r31, 0xe0
	ctx.r[22].s64 = ctx.r[31].s64 + 224;
	// 82EB4550: 3B3F00F8  addi r25, r31, 0xf8
	ctx.r[25].s64 = ctx.r[31].s64 + 248;
	// 82EB4554: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4558: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB455C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4560: 409A0028  bne cr6, 0x82eb4588
	if !ctx.cr[6].eq {
	pc = 0x82EB4588; continue 'dispatch;
	}
	// 82EB4564: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4568: C1B60004  lfs f13, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB456C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4570: 409A0018  bne cr6, 0x82eb4588
	if !ctx.cr[6].eq {
	pc = 0x82EB4588; continue 'dispatch;
	}
	// 82EB4574: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4578: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB457C: C1B60008  lfs f13, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4580: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4584: 419A0008  beq cr6, 0x82eb458c
	if ctx.cr[6].eq {
	pc = 0x82EB458C; continue 'dispatch;
	}
	// 82EB4588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB458C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4590: 408205F0  bne 0x82eb4b80
	if !ctx.cr[0].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4594: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB4598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB459C: 419A05E4  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB45A0: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB45A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB45A8: 419A05D8  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB45AC: 4B3AC40D  bl 0x822609b8
	ctx.lr = 0x82EB45B0;
	sub_822609B8(ctx, base);
	// 82EB45B0: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB45B4: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82EB45B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB45BC: 4082009C  bne 0x82eb4658
	if !ctx.cr[0].eq {
	pc = 0x82EB4658; continue 'dispatch;
	}
	// 82EB45C0: C1BF0110  lfs f13, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB45C4: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB45C8: C0190000  lfs f0, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB45CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB45D0: C1990004  lfs f12, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB45D4: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB45D8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB45DC: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB45E0: C1990008  lfs f12, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB45E4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB45E8: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB45EC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB45F0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB45F4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB45F8: EFE0002C  fsqrts f31, f0
	ctx.f[31].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB45FC: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82EB4600: 40990058  ble cr6, 0x82eb4658
	if !ctx.cr[6].gt {
	pc = 0x82EB4658; continue 'dispatch;
	}
	// 82EB4604: 4B3AC3B5  bl 0x822609b8
	ctx.lr = 0x82EB4608;
	sub_822609B8(ctx, base);
	// 82EB4608: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB460C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4610: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4614: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82EB4618: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB461C: C3CB004C  lfs f30, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB4620: 4BFCD0B1  bl 0x82e816d0
	ctx.lr = 0x82EB4624;
	sub_82E816D0(ctx, base);
	// 82EB4624: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB4628: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82EB462C: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4630: EFDE0828  fsubs f30, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EB4634: C3AB0008  lfs f29, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB4638: 4BFCCCC9  bl 0x82e81300
	ctx.lr = 0x82EB463C;
	sub_82E81300(ctx, base);
	// 82EB463C: EDBFE824  fdivs f13, f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[31].f64 / ctx.f[29].f64) as f32) as f64;
	// 82EB4640: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4644: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4648: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB464C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4650: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EB4654: 4198052C  blt cr6, 0x82eb4b80
	if ctx.cr[6].lt {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4658: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EB465C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB4660: 4BFDEB29  bl 0x82e93188
	ctx.lr = 0x82EB4664;
	sub_82E93188(ctx, base);
	// 82EB4664: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB4668: 907F013C  stw r3, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[3].u32 ) };
	// 82EB466C: 419A0514  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4670: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4674: 1D63000C  mulli r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 * 12;
	// 82EB4678: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB467C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EB4680: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4684: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4688: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB468C: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4690: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4694: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4698: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB469C: 83DF013C  lwz r30, 0x13c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB46A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB46A4: 7FD5F378  mr r21, r30
	ctx.r[21].u64 = ctx.r[30].u64;
	// 82EB46A8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB46AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB46B0: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB46B4: 419A0228  beq cr6, 0x82eb48dc
	if ctx.cr[6].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB46B8: 1F9E000C  mulli r28, r30, 0xc
	ctx.r[28].s64 = ctx.r[30].s64 * 12;
	// 82EB46BC: 57DB103A  slwi r27, r30, 2
	ctx.r[27].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82EB46C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB46C4: 419A0044  beq cr6, 0x82eb4708
	if ctx.cr[6].eq {
	pc = 0x82EB4708; continue 'dispatch;
	}
	// 82EB46C8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB46CC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB46D0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EB46D4: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB46D8: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB46DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB46E0: 41820028  beq 0x82eb4708
	if ctx.cr[0].eq {
	pc = 0x82EB4708; continue 'dispatch;
	}
	// 82EB46E4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB46E8: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB46EC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB46F0: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB46F4: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EB46F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB46FC: 4E800421  bctrl
	ctx.lr = 0x82EB4700;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4700: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4704: 41820494  beq 0x82eb4b98
	if ctx.cr[0].eq {
	pc = 0x82EB4B98; continue 'dispatch;
	}
	// 82EB4708: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB470C: 3BBC000C  addi r29, r28, 0xc
	ctx.r[29].s64 = ctx.r[28].s64 + 12;
	// 82EB4710: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4714: 3B5E0001  addi r26, r30, 1
	ctx.r[26].s64 = ctx.r[30].s64 + 1;
	// 82EB4718: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB471C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4720: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4724: 3B1B0004  addi r24, r27, 4
	ctx.r[24].s64 = ctx.r[27].s64 + 4;
	// 82EB4728: C19F0114  lfs f12, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB472C: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4730: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4734: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB4738: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB473C: EDAC4828  fsubs f13, f12, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB4740: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4744: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB4748: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB474C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4750: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4754: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4758: 41990184  bgt cr6, 0x82eb48dc
	if ctx.cr[6].gt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB475C: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EB4760: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4764: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4768: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB476C: 40980008  bge cr6, 0x82eb4774
	if !ctx.cr[6].lt {
	pc = 0x82EB4774; continue 'dispatch;
	}
	// 82EB4770: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4774: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4778: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB477C: 41990160  bgt cr6, 0x82eb48dc
	if ctx.cr[6].gt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB4780: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4788: 815F00A4  lwz r10, 0xa4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB478C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4790: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EB4794: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB4798: 4E800421  bctrl
	ctx.lr = 0x82EB479C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB479C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB47A0: 4182013C  beq 0x82eb48dc
	if ctx.cr[0].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB47A4: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB47A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB47AC: 41820024  beq 0x82eb47d0
	if ctx.cr[0].eq {
	pc = 0x82EB47D0; continue 'dispatch;
	}
	// 82EB47B0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB47B4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB47B8: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB47BC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB47C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB47C4: 4E800421  bctrl
	ctx.lr = 0x82EB47C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB47C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB47CC: 41820110  beq 0x82eb48dc
	if ctx.cr[0].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB47D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB47D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB47D8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB47DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB47E0: 4E800421  bctrl
	ctx.lr = 0x82EB47E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB47E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB47E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB47EC: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB47F0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB47F4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB47F8: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB47FC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EB4800: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4804: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4808: 7CABE214  add r5, r11, r28
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB480C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4810: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4818: 4E800421  bctrl
	ctx.lr = 0x82EB481C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB481C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4820: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4824: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB4828: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB482C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EB4830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4834: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB4838: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB483C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4840: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4844: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4848: 4E800421  bctrl
	ctx.lr = 0x82EB484C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB484C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4850: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4854: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB4858: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB485C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82EB4860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4864: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4868: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB486C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4870: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4874: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4878: 4E800421  bctrl
	ctx.lr = 0x82EB487C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB487C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4880: 41820014  beq 0x82eb4894
	if ctx.cr[0].eq {
	pc = 0x82EB4894; continue 'dispatch;
	}
	// 82EB4884: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4888: 4182000C  beq 0x82eb4894
	if ctx.cr[0].eq {
	pc = 0x82EB4894; continue 'dispatch;
	}
	// 82EB488C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4890: 4182004C  beq 0x82eb48dc
	if ctx.cr[0].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB4894: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4898: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB489C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB48A0: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB48A4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB48A8: 41990034  bgt cr6, 0x82eb48dc
	if ctx.cr[6].gt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB48AC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB48B0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EB48B4: 7F55D378  mr r21, r26
	ctx.r[21].u64 = ctx.r[26].u64;
	// 82EB48B8: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48BC: 40980020  bge cr6, 0x82eb48dc
	if !ctx.cr[6].lt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB48C0: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB48C4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82EB48C8: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 82EB48CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB48D0: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82EB48D4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48D8: 409AFDE8  bne cr6, 0x82eb46c0
	if !ctx.cr[6].eq {
	pc = 0x82EB46C0; continue 'dispatch;
	}
	// 82EB48DC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB48E0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EB48E4: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48E8: 409801E0  bge cr6, 0x82eb4ac8
	if !ctx.cr[6].lt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB48EC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB48F0: 39550001  addi r10, r21, 1
	ctx.r[10].s64 = ctx.r[21].s64 + 1;
	// 82EB48F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48F8: 409A01D0  bne cr6, 0x82eb4ac8
	if !ctx.cr[6].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB48FC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4900: 1FB5000C  mulli r29, r21, 0xc
	ctx.r[29].s64 = ctx.r[21].s64 * 12;
	// 82EB4904: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4908: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB490C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4910: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82EB4914: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4918: C1440000  lfs f10, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB491C: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB4920: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4924: C1240004  lfs f9, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4928: EDA96828  fsubs f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB492C: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4930: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4934: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB4938: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB493C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4940: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4944: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4948: 40990164  ble cr6, 0x82eb4aac
	if !ctx.cr[6].gt {
	pc = 0x82EB4AAC; continue 'dispatch;
	}
	// 82EB494C: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4950: FD804890  fmr f12, f9
	ctx.f[12].f64 = ctx.f[9].f64;
	// 82EB4954: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4958: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB495C: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4960: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB4964: C1B60004  lfs f13, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4968: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB496C: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 82EB4970: C1560008  lfs f10, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4974: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4978: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB497C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4980: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4984: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4988: 41990140  bgt cr6, 0x82eb4ac8
	if ctx.cr[6].gt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB498C: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4990: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4994: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4998: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB499C: 40980008  bge cr6, 0x82eb49a4
	if !ctx.cr[6].lt {
	pc = 0x82EB49A4; continue 'dispatch;
	}
	// 82EB49A0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB49A4: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB49A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB49AC: 4199011C  bgt cr6, 0x82eb4ac8
	if ctx.cr[6].gt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB49B0: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB49B4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82EB49B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB49BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB49C0: 4E800421  bctrl
	ctx.lr = 0x82EB49C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB49C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB49C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB49CC: 409A00FC  bne cr6, 0x82eb4ac8
	if !ctx.cr[6].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB49D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB49D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB49D8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB49DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB49E0: 4E800421  bctrl
	ctx.lr = 0x82EB49E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB49E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB49E8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB49EC: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB49F0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB49F4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB49F8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB49FC: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4A00: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82EB4A04: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4A08: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82EB4A0C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4A10: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4A14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4A18: 4E800421  bctrl
	ctx.lr = 0x82EB4A1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4A1C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4A20: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4A24: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB4A28: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4A2C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EB4A30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4A34: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4A38: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4A3C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4A40: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4A44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4A48: 4E800421  bctrl
	ctx.lr = 0x82EB4A4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4A4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4A50: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4A54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB4A58: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EB4A5C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82EB4A60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4A64: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4A68: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4A6C: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4A70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4A74: 4E800421  bctrl
	ctx.lr = 0x82EB4A78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4A78: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4A7C: 4182004C  beq 0x82eb4ac8
	if ctx.cr[0].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4A80: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4A84: 41820044  beq 0x82eb4ac8
	if ctx.cr[0].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4A88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4A8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB4A90: 409A0038  bne cr6, 0x82eb4ac8
	if !ctx.cr[6].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4A94: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4A98: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4A9C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB4AA0: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4AA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4AA8: 40980020  bge cr6, 0x82eb4ac8
	if !ctx.cr[6].lt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4AAC: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4AB0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EB4AB4: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4AB8: C0160004  lfs f0, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4ABC: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4AC0: C0160008  lfs f0, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4AC4: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4AC8: 813F013C  lwz r9, 0x13c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB4ACC: 7F154840  cmplw cr6, r21, r9
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB4AD0: 409A006C  bne cr6, 0x82eb4b3c
	if !ctx.cr[6].eq {
	pc = 0x82EB4B3C; continue 'dispatch;
	}
	// 82EB4AD4: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB4AD8: 39150001  addi r8, r21, 1
	ctx.r[8].s64 = ctx.r[21].s64 + 1;
	// 82EB4ADC: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB4AE0: 40980054  bge cr6, 0x82eb4b34
	if !ctx.cr[6].lt {
	pc = 0x82EB4B34; continue 'dispatch;
	}
	// 82EB4AE4: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4AE8: 1D69000C  mulli r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 * 12;
	// 82EB4AEC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB4AF0: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4AF4: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4AF8: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4AFC: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4B00: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B04: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4B08: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4B0C: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4B10: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4B14: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4B18: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB4B1C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4B20: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4B24: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4B28: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4B2C: 40980008  bge cr6, 0x82eb4b34
	if !ctx.cr[6].lt {
	pc = 0x82EB4B34; continue 'dispatch;
	}
	// 82EB4B30: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 82EB4B34: 7F154840  cmplw cr6, r21, r9
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB4B38: 419A0048  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4B3C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4B40: 92BF013C  stw r21, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[21].u32 ) };
	// 82EB4B44: 40820028  bne 0x82eb4b6c
	if !ctx.cr[0].eq {
	pc = 0x82EB4B6C; continue 'dispatch;
	}
	// 82EB4B48: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4B4C: 1D75000C  mulli r11, r21, 0xc
	ctx.r[11].s64 = ctx.r[21].s64 * 12;
	// 82EB4B50: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB4B54: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B58: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4B5C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B60: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4B64: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B68: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4B6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4B70: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82EB4B74: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4B78: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4B7C: 4B4106BD  bl 0x822c5238
	ctx.lr = 0x82EB4B80;
	sub_822C5238(ctx, base);
	// 82EB4B80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4B84: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB4B88: CBA1FF80  lfd f29, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82EB4B8C: CBC1FF88  lfd f30, -0x78(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82EB4B90: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82EB4B94: 4BDF48A4  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
	// 82EB4B98: 92BF013C  stw r21, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[21].u32 ) };
	// 82EB4B9C: 4BFFFFAC  b 0x82eb4b48
	pc = 0x82EB4B48; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4BA0 size=128
    let mut pc: u32 = 0x82EB4BA0;
    'dispatch: loop {
        match pc {
            0x82EB4BA0 => {
    //   block [0x82EB4BA0..0x82EB4C20)
	// 82EB4BA0: C1A50000  lfs f13, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4BA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4BA8: C0030110  lfs f0, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4BAC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4BB0: C1850004  lfs f12, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4BB4: C1430114  lfs f10, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4BB8: ED4A6028  fsubs f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB4BBC: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB4BC0: C1230118  lfs f9, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4BC4: ED295828  fsubs f9, f9, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4BC8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4BCC: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4BD0: EC09027A  fmadds f0, f9, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4BD4: C12B0C18  lfs f9, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4BD8: ED40002C  fsqrts f10, f0
	ctx.f[10].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB4BDC: FF0A4800  fcmpu cr6, f10, f9
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[9].f64);
	// 82EB4BE0: 419A0040  beq cr6, 0x82eb4c20
	if ctx.cr[6].eq {
		sub_82EB4C20(ctx, base);
		return;
	}
	// 82EB4BE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4BE8: C1030110  lfs f8, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4BEC: C0E30114  lfs f7, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EB4BF0: EDAD4028  fsubs f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB4BF4: C1030118  lfs f8, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4BF8: ED8C3828  fsubs f12, f12, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB4BFC: ED6B4028  fsubs f11, f11, f8
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB4C00: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C04: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EB4C08: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB4C0C: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4C10: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB4C14: D1840008  stfs f12, 8(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4C18: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB4C1C: 48000020  b 0x82eb4c3c
	sub_82EB4C20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4C20 size=132
    let mut pc: u32 = 0x82EB4C20;
    'dispatch: loop {
        match pc {
            0x82EB4C20 => {
    //   block [0x82EB4C20..0x82EB4CA4)
	// 82EB4C20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4C24: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4C28: C00B004C  lfs f0, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C2C: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4C30: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C34: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4C38: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C3C: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB4C40: 8163015C  lwz r11, 0x15c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) } as u64;
	// 82EB4C44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4C48: 41820010  beq 0x82eb4c58
	if ctx.cr[0].eq {
	pc = 0x82EB4C58; continue 'dispatch;
	}
	// 82EB4C4C: 896B0004  lbz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4C50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4C54: 40820008  bne 0x82eb4c5c
	if !ctx.cr[0].eq {
	pc = 0x82EB4C5C; continue 'dispatch;
	}
	// 82EB4C58: D1240008  stfs f9, 8(r4)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4C5C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C60: C1A300E0  lfs f13, 0xe0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4C64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4C68: 409A0028  bne cr6, 0x82eb4c90
	if !ctx.cr[6].eq {
	pc = 0x82EB4C90; continue 'dispatch;
	}
	// 82EB4C6C: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C70: C1A300E4  lfs f13, 0xe4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4C74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4C78: 409A0018  bne cr6, 0x82eb4c90
	if !ctx.cr[6].eq {
	pc = 0x82EB4C90; continue 'dispatch;
	}
	// 82EB4C7C: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB4C84: C1A300E8  lfs f13, 0xe8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4C88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4C8C: 419A0008  beq cr6, 0x82eb4c94
	if ctx.cr[6].eq {
	pc = 0x82EB4C94; continue 'dispatch;
	}
	// 82EB4C90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB4C94: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4C98: 4182000C  beq 0x82eb4ca4
	if ctx.cr[0].eq {
		sub_82EB4CA4(ctx, base);
		return;
	}
	// 82EB4C9C: C0030040  lfs f0, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CA0: 48000008  b 0x82eb4ca8
	sub_82EB4CA4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4CA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4CA4 size=20
    let mut pc: u32 = 0x82EB4CA4;
    'dispatch: loop {
        match pc {
            0x82EB4CA4 => {
    //   block [0x82EB4CA4..0x82EB4CB8)
	// 82EB4CA4: C003003C  lfs f0, 0x3c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CA8: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82EB4CAC: 4099000C  ble cr6, 0x82eb4cb8
	if !ctx.cr[6].gt {
		sub_82EB4CB8(ctx, base);
		return;
	}
	// 82EB4CB0: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CB4: 48000014  b 0x82eb4cc8
	sub_82EB4CB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4CB8 size=28
    let mut pc: u32 = 0x82EB4CB8;
    'dispatch: loop {
        match pc {
            0x82EB4CB8 => {
    //   block [0x82EB4CB8..0x82EB4CD4)
	// 82EB4CB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4CBC: C1A30010  lfs f13, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4CC0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CC4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4CC8: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4CCC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB4CD8 size=84
    let mut pc: u32 = 0x82EB4CD8;
    'dispatch: loop {
        match pc {
            0x82EB4CD8 => {
    //   block [0x82EB4CD8..0x82EB4D2C)
	// 82EB4CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4CE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4CE4: 814301B0  lwz r10, 0x1b0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB4CE8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82EB4CEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB4CF0: 409A000C  bne cr6, 0x82eb4cfc
	if !ctx.cr[6].eq {
	pc = 0x82EB4CFC; continue 'dispatch;
	}
	// 82EB4CF4: 4BFFFEAD  bl 0x82eb4ba0
	ctx.lr = 0x82EB4CF8;
	sub_82EB4BA0(ctx, base);
	// 82EB4CF8: 48000024  b 0x82eb4d1c
	pc = 0x82EB4D1C; continue 'dispatch;
	// 82EB4CFC: 806301B0  lwz r3, 0x1b0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB4D00: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82EB4D04: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EB4D08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4D0C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4D10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4D14: 4E800421  bctrl
	ctx.lr = 0x82EB4D18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4D18: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4D1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB4D20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4D24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4D30 size=108
    let mut pc: u32 = 0x82EB4D30;
    'dispatch: loop {
        match pc {
            0x82EB4D30 => {
    //   block [0x82EB4D30..0x82EB4D9C)
	// 82EB4D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4D38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4D3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4D40: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4D48: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4D4C: C0030110  lfs f0, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D50: D00300F8  stfs f0, 0xf8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EB4D54: C0030114  lfs f0, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D58: D00300FC  stfs f0, 0xfc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EB4D5C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB4D60: C0030118  lfs f0, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D64: D0030100  stfs f0, 0x100(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EB4D68: C0030110  lfs f0, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D6C: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB4D70: C0030114  lfs f0, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D74: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB4D78: C0030118  lfs f0, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D7C: D003010C  stfs f0, 0x10c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB4D80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4D84: 4E800421  bctrl
	ctx.lr = 0x82EB4D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4D88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4D8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB4D90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4D94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4D98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4DA0 size=76
    let mut pc: u32 = 0x82EB4DA0;
    'dispatch: loop {
        match pc {
            0x82EB4DA0 => {
    //   block [0x82EB4DA0..0x82EB4DEC)
	// 82EB4DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4DA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4DAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4DB0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB4DB4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EB4DB8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB4DBC: 814B0158  lwz r10, 0x158(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB4DC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4DC4: C02A0004  lfs f1, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB4DC8: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4DCC: 4B77A745  bl 0x8262f510
	ctx.lr = 0x82EB4DD0;
	sub_8262F510(ctx, base);
	// 82EB4DD0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4DD4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB4DD8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB4DDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB4DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB4DF0 size=88
    let mut pc: u32 = 0x82EB4DF0;
    'dispatch: loop {
        match pc {
            0x82EB4DF0 => {
    //   block [0x82EB4DF0..0x82EB4E48)
	// 82EB4DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4DF4: 4BDF4619  bl 0x82ca940c
	ctx.lr = 0x82EB4DF8;
	sub_82CA93D0(ctx, base);
	// 82EB4DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB4E00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB4E04: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB4E08: 4BFFFF99  bl 0x82eb4da0
	ctx.lr = 0x82EB4E0C;
	sub_82EB4DA0(ctx, base);
	// 82EB4E0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4E10: 4082000C  bne 0x82eb4e1c
	if !ctx.cr[0].eq {
	pc = 0x82EB4E1C; continue 'dispatch;
	}
	// 82EB4E14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB4E18: 48000028  b 0x82eb4e40
	pc = 0x82EB4E40; continue 'dispatch;
	// 82EB4E1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB4E20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4E28: 4BFFCDE1  bl 0x82eb1c08
	ctx.lr = 0x82EB4E2C;
	sub_82EB1C08(ctx, base);
	// 82EB4E2C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4E30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB4E34: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB4E38: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB4E3C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82EB4E40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB4E44: 4BDF4618  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4E48 size=476
    let mut pc: u32 = 0x82EB4E48;
    'dispatch: loop {
        match pc {
            0x82EB4E48 => {
    //   block [0x82EB4E48..0x82EB5024)
	// 82EB4E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4E4C: 4BDF45C1  bl 0x82ca940c
	ctx.lr = 0x82EB4E50;
	sub_82CA93D0(ctx, base);
	// 82EB4E50: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82EB4E54: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EB4E58: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EB4E5C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4E60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB4E64: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EB4E68: C01E00E0  lfs f0, 0xe0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4E6C: C1BE00F8  lfs f13, 0xf8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4E70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4E74: 409A0028  bne cr6, 0x82eb4e9c
	if !ctx.cr[6].eq {
	pc = 0x82EB4E9C; continue 'dispatch;
	}
	// 82EB4E78: C01E00FC  lfs f0, 0xfc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4E7C: C1BE00E4  lfs f13, 0xe4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4E80: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4E84: 409A0018  bne cr6, 0x82eb4e9c
	if !ctx.cr[6].eq {
	pc = 0x82EB4E9C; continue 'dispatch;
	}
	// 82EB4E88: C01E0100  lfs f0, 0x100(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4E8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB4E90: C1BE00E8  lfs f13, 0xe8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4E94: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4E98: 419A0008  beq cr6, 0x82eb4ea0
	if ctx.cr[6].eq {
	pc = 0x82EB4EA0; continue 'dispatch;
	}
	// 82EB4E9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB4EA0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4EA4: 40820168  bne 0x82eb500c
	if !ctx.cr[0].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4EA8: 817E013C  lwz r11, 0x13c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB4EAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4EB0: 4182015C  beq 0x82eb500c
	if ctx.cr[0].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4EB4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB4EB8: 419A0154  beq cr6, 0x82eb500c
	if ctx.cr[6].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4EBC: 813E0088  lwz r9, 0x88(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4EC0: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 * 12;
	// 82EB4EC4: 7FEA4A14  add r31, r10, r9
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EB4EC8: 815E0084  lwz r10, 0x84(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EB4ECC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB4ED0: 813E006C  lwz r9, 0x6c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB4ED4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB4ED8: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4EDC: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4EE0: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4EE4: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB4EE8: C17FFFF4  lfs f11, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB4EEC: C15FFFF8  lfs f10, -8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4EF0: EFED5828  fsubs f31, f13, f11
	ctx.f[31].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4EF4: C13FFFFC  lfs f9, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4EF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB4EFC: EFA05028  fsubs f29, f0, f10
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB4F00: EFCC4828  fsubs f30, f12, f9
	ctx.f[30].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB4F04: 419A0038  beq cr6, 0x82eb4f3c
	if ctx.cr[6].eq {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F08: 81490028  lwz r10, 0x28(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB4F0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB4F10: 4098002C  bge cr6, 0x82eb4f3c
	if !ctx.cr[6].lt {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F14: 81490034  lwz r10, 0x34(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB4F18: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB4F1C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB4F20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4F24: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB4F28: 419A0014  beq cr6, 0x82eb4f3c
	if ctx.cr[6].eq {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4F30: 4182000C  beq 0x82eb4f3c
	if ctx.cr[0].eq {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F34: 4BFDA6ED  bl 0x82e8f620
	ctx.lr = 0x82EB4F38;
	sub_82E8F620(ctx, base);
	// 82EB4F38: 48000020  b 0x82eb4f58
	pc = 0x82EB4F58; continue 'dispatch;
	// 82EB4F3C: EDAD5828  fsubs f13, f13, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4F40: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB4F44: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB4F48: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB4F4C: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB4F50: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4F54: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB4F58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4F5C: C14B0C18  lfs f10, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4F60: FF015000  fcmpu cr6, f1, f10
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[10].f64);
	// 82EB4F64: 419A0080  beq cr6, 0x82eb4fe4
	if ctx.cr[6].eq {
	pc = 0x82EB4FE4; continue 'dispatch;
	}
	// 82EB4F68: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4F6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4F70: FD206850  fneg f9, f13
	ctx.f[9].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4F74: C19E0114  lfs f12, 0x114(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4F78: C1BFFFF8  lfs f13, -8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4F7C: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4F80: C11E0118  lfs f8, 0x118(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4F84: C1BFFFFC  lfs f13, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4F88: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4F8C: C19E0110  lfs f12, 0x110(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4F90: C11FFFF4  lfs f8, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4F94: ED8C4028  fsubs f12, f12, f8
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB4F98: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4F9C: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 82EB4FA0: ED6B0772  fmuls f11, f11, f29
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EB4FA4: ED6D5FBA  fmadds f11, f13, f30, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB4FA8: ED6C5FFA  fmadds f11, f12, f31, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB4FAC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4FB0: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 82EB4FB4: 41980030  blt cr6, 0x82eb4fe4
	if ctx.cr[6].lt {
	pc = 0x82EB4FE4; continue 'dispatch;
	}
	// 82EB4FB8: FF0B0800  fcmpu cr6, f11, f1
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[1].f64);
	// 82EB4FBC: 41990028  bgt cr6, 0x82eb4fe4
	if ctx.cr[6].gt {
	pc = 0x82EB4FE4; continue 'dispatch;
	}
	// 82EB4FC0: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB4FC4: EDAC6FB8  fmsubs f13, f12, f30, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4FC8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4FCC: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EB4FD0: 40980008  bge cr6, 0x82eb4fd8
	if !ctx.cr[6].lt {
	pc = 0x82EB4FD8; continue 'dispatch;
	}
	// 82EB4FD4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4FD8: C1BE005C  lfs f13, 0x5c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4FDC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4FE0: 4198002C  blt cr6, 0x82eb500c
	if ctx.cr[6].lt {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4FE4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB4FE8: 389E0110  addi r4, r30, 0x110
	ctx.r[4].s64 = ctx.r[30].s64 + 272;
	// 82EB4FEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4FF0: 4BFFCC19  bl 0x82eb1c08
	ctx.lr = 0x82EB4FF4;
	sub_82EB1C08(ctx, base);
	// 82EB4FF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4FF8: 41820014  beq 0x82eb500c
	if ctx.cr[0].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4FFC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB5000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB5004: 917E0140  stw r11, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82EB5008: 48000008  b 0x82eb5010
	pc = 0x82EB5010; continue 'dispatch;
	// 82EB500C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB5010: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5014: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EB5018: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EB501C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EB5020: 4BDF443C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5028 size=68
    let mut pc: u32 = 0x82EB5028;
    'dispatch: loop {
        match pc {
            0x82EB5028 => {
    //   block [0x82EB5028..0x82EB506C)
	// 82EB5028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB502C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5030: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5034: 81630158  lwz r11, 0x158(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB5038: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB503C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5040: 38630110  addi r3, r3, 0x110
	ctx.r[3].s64 = ctx.r[3].s64 + 272;
	// 82EB5044: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB5048: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB504C: 4B77A4C5  bl 0x8262f510
	ctx.lr = 0x82EB5050;
	sub_8262F510(ctx, base);
	// 82EB5050: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB5054: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB5058: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB505C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5070 size=216
    let mut pc: u32 = 0x82EB5070;
    'dispatch: loop {
        match pc {
            0x82EB5070 => {
    //   block [0x82EB5070..0x82EB5148)
	// 82EB5070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB507C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5088: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82EB508C: 4BFFD6E5  bl 0x82eb2770
	ctx.lr = 0x82EB5090;
	sub_82EB2770(ctx, base);
	// 82EB5090: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB5094: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB5098: 808B0040  lwz r4, 0x40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB509C: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB50A0: 40810054  ble 0x82eb50f4
	if !ctx.cr[0].gt {
	pc = 0x82EB50F4; continue 'dispatch;
	}
	// 82EB50A4: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EB50A8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB50AC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB50B0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB50B4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB50B8: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB50BC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB50C0: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EB50C4: 41820014  beq 0x82eb50d8
	if ctx.cr[0].eq {
	pc = 0x82EB50D8; continue 'dispatch;
	}
	// 82EB50C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB50CC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB50D0: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EB50D4: 419AFFE0  beq cr6, 0x82eb50b4
	if ctx.cr[6].eq {
	pc = 0x82EB50B4; continue 'dispatch;
	}
	// 82EB50D8: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB50DC: 41820030  beq 0x82eb510c
	if ctx.cr[0].eq {
	pc = 0x82EB510C; continue 'dispatch;
	}
	// 82EB50E0: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB50E4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB50E8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB50EC: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB50F0: 4198FFB8  blt cr6, 0x82eb50a8
	if ctx.cr[6].lt {
	pc = 0x82EB50A8; continue 'dispatch;
	}
	// 82EB50F4: 2B040010  cmplwi cr6, r4, 0x10
	ctx.cr[6].compare_u32(ctx.r[4].u32, 16 as u32, &mut ctx.xer);
	// 82EB50F8: 409A0020  bne cr6, 0x82eb5118
	if !ctx.cr[6].eq {
	pc = 0x82EB5118; continue 'dispatch;
	}
	// 82EB50FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB5100: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB5104: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82EB5108: 48000028  b 0x82eb5130
	pc = 0x82EB5130; continue 'dispatch;
	// 82EB510C: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB5110: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB5114: 48000018  b 0x82eb512c
	pc = 0x82EB512C; continue 'dispatch;
	// 82EB5118: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB511C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB5120: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB5124: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB5128: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EB512C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB5130: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB5134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB513C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB5140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5148 size=216
    let mut pc: u32 = 0x82EB5148;
    'dispatch: loop {
        match pc {
            0x82EB5148 => {
    //   block [0x82EB5148..0x82EB5220)
	// 82EB5148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB514C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5150: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB5154: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5158: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB515C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5160: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82EB5164: 4BFFD685  bl 0x82eb27e8
	ctx.lr = 0x82EB5168;
	sub_82EB27E8(ctx, base);
	// 82EB5168: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB516C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB5170: 808B0040  lwz r4, 0x40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB5174: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB5178: 40810054  ble 0x82eb51cc
	if !ctx.cr[0].gt {
	pc = 0x82EB51CC; continue 'dispatch;
	}
	// 82EB517C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EB5180: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5184: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB5188: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB518C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5190: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5194: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB5198: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EB519C: 41820014  beq 0x82eb51b0
	if ctx.cr[0].eq {
	pc = 0x82EB51B0; continue 'dispatch;
	}
	// 82EB51A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB51A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB51A8: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EB51AC: 419AFFE0  beq cr6, 0x82eb518c
	if ctx.cr[6].eq {
	pc = 0x82EB518C; continue 'dispatch;
	}
	// 82EB51B0: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB51B4: 41820030  beq 0x82eb51e4
	if ctx.cr[0].eq {
	pc = 0x82EB51E4; continue 'dispatch;
	}
	// 82EB51B8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB51BC: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB51C0: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB51C4: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB51C8: 4198FFB8  blt cr6, 0x82eb5180
	if ctx.cr[6].lt {
	pc = 0x82EB5180; continue 'dispatch;
	}
	// 82EB51CC: 2B040010  cmplwi cr6, r4, 0x10
	ctx.cr[6].compare_u32(ctx.r[4].u32, 16 as u32, &mut ctx.xer);
	// 82EB51D0: 409A0020  bne cr6, 0x82eb51f0
	if !ctx.cr[6].eq {
	pc = 0x82EB51F0; continue 'dispatch;
	}
	// 82EB51D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB51D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB51DC: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82EB51E0: 48000028  b 0x82eb5208
	pc = 0x82EB5208; continue 'dispatch;
	// 82EB51E4: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB51E8: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB51EC: 48000018  b 0x82eb5204
	pc = 0x82EB5204; continue 'dispatch;
	// 82EB51F0: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB51F4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB51F8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB51FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB5200: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EB5204: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB5208: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB520C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5214: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB5218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB521C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5220 size=132
    let mut pc: u32 = 0x82EB5220;
    'dispatch: loop {
        match pc {
            0x82EB5220 => {
    //   block [0x82EB5220..0x82EB52A4)
	// 82EB5220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5228: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB522C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5230: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB5234: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5238: 392BAFB4  addi r9, r11, -0x504c
	ctx.r[9].s64 = ctx.r[11].s64 + -20556;
	// 82EB523C: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82EB5240: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB5244: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EB5248: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB524C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5250: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5254: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EB5258: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB525C: 4082FFF0  bne 0x82eb524c
	if !ctx.cr[0].eq {
	pc = 0x82EB524C; continue 'dispatch;
	}
	// 82EB5260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5264: 90BF0104  stw r5, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[5].u32 ) };
	// 82EB5268: 4BFFFE09  bl 0x82eb5070
	ctx.lr = 0x82EB526C;
	sub_82EB5070(ctx, base);
	// 82EB526C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5270: 4082000C  bne 0x82eb527c
	if !ctx.cr[0].eq {
	pc = 0x82EB527C; continue 'dispatch;
	}
	// 82EB5274: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB5278: 48000010  b 0x82eb5288
	pc = 0x82EB5288; continue 'dispatch;
	// 82EB527C: 4BFFD4F5  bl 0x82eb2770
	ctx.lr = 0x82EB5280;
	sub_82EB2770(ctx, base);
	// 82EB5280: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB5284: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB5288: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82EB528C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB529C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB52A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB52A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB52A8 size=132
    let mut pc: u32 = 0x82EB52A8;
    'dispatch: loop {
        match pc {
            0x82EB52A8 => {
    //   block [0x82EB52A8..0x82EB532C)
	// 82EB52A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB52AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB52B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB52B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB52B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB52BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB52C0: 392BAFB4  addi r9, r11, -0x504c
	ctx.r[9].s64 = ctx.r[11].s64 + -20556;
	// 82EB52C4: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82EB52C8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB52CC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EB52D0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB52D4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB52D8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB52DC: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EB52E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB52E4: 4082FFF0  bne 0x82eb52d4
	if !ctx.cr[0].eq {
	pc = 0x82EB52D4; continue 'dispatch;
	}
	// 82EB52E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB52EC: 90BF0104  stw r5, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[5].u32 ) };
	// 82EB52F0: 4BFFFE59  bl 0x82eb5148
	ctx.lr = 0x82EB52F4;
	sub_82EB5148(ctx, base);
	// 82EB52F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB52F8: 4082000C  bne 0x82eb5304
	if !ctx.cr[0].eq {
	pc = 0x82EB5304; continue 'dispatch;
	}
	// 82EB52FC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB5300: 48000010  b 0x82eb5310
	pc = 0x82EB5310; continue 'dispatch;
	// 82EB5304: 4BFFD4E5  bl 0x82eb27e8
	ctx.lr = 0x82EB5308;
	sub_82EB27E8(ctx, base);
	// 82EB5308: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB530C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB5310: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82EB5314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5318: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB531C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5330 size=148
    let mut pc: u32 = 0x82EB5330;
    'dispatch: loop {
        match pc {
            0x82EB5330 => {
    //   block [0x82EB5330..0x82EB53C4)
	// 82EB5330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB533C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5344: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EB5348: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB534C: 394AA7C0  addi r10, r10, -0x5840
	ctx.r[10].s64 = ctx.r[10].s64 + -22592;
	// 82EB5350: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB5354: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EB5358: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82EB535C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB5360: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EB5364: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5368: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB536C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB5370: 409AFFF4  bne cr6, 0x82eb5364
	if !ctx.cr[6].eq {
	pc = 0x82EB5364; continue 'dispatch;
	}
	// 82EB5374: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EB5378: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB537C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB5380: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EB5384: 4B7615A5  bl 0x82616928
	ctx.lr = 0x82EB5388;
	sub_82616928(ctx, base);
	// 82EB5388: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB538C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EB5390: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5394: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB5398: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB539C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EB53A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB53A4: 4082FFEC  bne 0x82eb5390
	if !ctx.cr[0].eq {
	pc = 0x82EB5390; continue 'dispatch;
	}
	// 82EB53A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB53AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB53B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB53B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB53B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB53BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB53C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB53C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB53C8 size=84
    let mut pc: u32 = 0x82EB53C8;
    'dispatch: loop {
        match pc {
            0x82EB53C8 => {
    //   block [0x82EB53C8..0x82EB541C)
	// 82EB53C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB53CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB53D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB53D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB53D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB53DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB53E0: 396BA7C0  addi r11, r11, -0x5840
	ctx.r[11].s64 = ctx.r[11].s64 + -22592;
	// 82EB53E4: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82EB53E8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB53EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB53F0: 816ADAB4  lwz r11, -0x254c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB53F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB53F8: 4E800421  bctrl
	ctx.lr = 0x82EB53FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB53FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB5400: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB5404: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB5408: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB540C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5414: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5420 size=88
    let mut pc: u32 = 0x82EB5420;
    'dispatch: loop {
        match pc {
            0x82EB5420 => {
    //   block [0x82EB5420..0x82EB5478)
	// 82EB5420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5428: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB542C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5430: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EB5434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5438: 48306C29  bl 0x831bc060
	ctx.lr = 0x82EB543C;
	sub_831BC060(ctx, base);
	// 82EB543C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5440: 4182001C  beq 0x82eb545c
	if ctx.cr[0].eq {
	pc = 0x82EB545C; continue 'dispatch;
	}
	// 82EB5444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5448: 48306C19  bl 0x831bc060
	ctx.lr = 0x82EB544C;
	sub_831BC060(ctx, base);
	// 82EB544C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5450: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82EB5454: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB5458: 419A0008  beq cr6, 0x82eb5460
	if ctx.cr[6].eq {
	pc = 0x82EB5460; continue 'dispatch;
	}
	// 82EB545C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB5460: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EB5464: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB546C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5470: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5474: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5478 size=12
    let mut pc: u32 = 0x82EB5478;
    'dispatch: loop {
        match pc {
            0x82EB5478 => {
    //   block [0x82EB5478..0x82EB5484)
	// 82EB5478: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB547C: 386BE058  addi r3, r11, -0x1fa8
	ctx.r[3].s64 = ctx.r[11].s64 + -8104;
	// 82EB5480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5488 size=12
    let mut pc: u32 = 0x82EB5488;
    'dispatch: loop {
        match pc {
            0x82EB5488 => {
    //   block [0x82EB5488..0x82EB5494)
	// 82EB5488: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB548C: 386BDD1C  addi r3, r11, -0x22e4
	ctx.r[3].s64 = ctx.r[11].s64 + -8932;
	// 82EB5490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5498 size=12
    let mut pc: u32 = 0x82EB5498;
    'dispatch: loop {
        match pc {
            0x82EB5498 => {
    //   block [0x82EB5498..0x82EB54A4)
	// 82EB5498: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB549C: 386BDAF4  addi r3, r11, -0x250c
	ctx.r[3].s64 = ctx.r[11].s64 + -9484;
	// 82EB54A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB54A8 size=92
    let mut pc: u32 = 0x82EB54A8;
    'dispatch: loop {
        match pc {
            0x82EB54A8 => {
    //   block [0x82EB54A8..0x82EB5504)
	// 82EB54A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB54AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB54B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB54B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB54B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB54BC: 4BFFFE75  bl 0x82eb5330
	ctx.lr = 0x82EB54C0;
	sub_82EB5330(ctx, base);
	// 82EB54C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB54C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB54C8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB54CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB54D0: 396BA818  addi r11, r11, -0x57e8
	ctx.r[11].s64 = ctx.r[11].s64 + -22504;
	// 82EB54D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB54D8: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EB54DC: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EB54E0: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EB54E4: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EB54E8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB54EC: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB54F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB54F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB54F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB54FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5508 size=12
    let mut pc: u32 = 0x82EB5508;
    'dispatch: loop {
        match pc {
            0x82EB5508 => {
    //   block [0x82EB5508..0x82EB5514)
	// 82EB5508: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB550C: 386BD9E0  addi r3, r11, -0x2620
	ctx.r[3].s64 = ctx.r[11].s64 + -9760;
	// 82EB5510: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5518 size=12
    let mut pc: u32 = 0x82EB5518;
    'dispatch: loop {
        match pc {
            0x82EB5518 => {
    //   block [0x82EB5518..0x82EB5524)
	// 82EB5518: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB551C: 386BD6A4  addi r3, r11, -0x295c
	ctx.r[3].s64 = ctx.r[11].s64 + -10588;
	// 82EB5520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5528 size=12
    let mut pc: u32 = 0x82EB5528;
    'dispatch: loop {
        match pc {
            0x82EB5528 => {
    //   block [0x82EB5528..0x82EB5534)
	// 82EB5528: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB552C: 386BD8CC  addi r3, r11, -0x2734
	ctx.r[3].s64 = ctx.r[11].s64 + -10036;
	// 82EB5530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5538 size=88
    let mut pc: u32 = 0x82EB5538;
    'dispatch: loop {
        match pc {
            0x82EB5538 => {
    //   block [0x82EB5538..0x82EB5590)
	// 82EB5538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB553C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5544: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB554C: 4BFFFDE5  bl 0x82eb5330
	ctx.lr = 0x82EB5550;
	sub_82EB5330(ctx, base);
	// 82EB5550: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB5554: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB5558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB555C: 396BA86C  addi r11, r11, -0x5794
	ctx.r[11].s64 = ctx.r[11].s64 + -22420;
	// 82EB5560: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5564: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB5568: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB556C: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EB5570: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EB5574: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EB5578: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EB557C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5588: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB558C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5590 size=12
    let mut pc: u32 = 0x82EB5590;
    'dispatch: loop {
        match pc {
            0x82EB5590 => {
    //   block [0x82EB5590..0x82EB559C)
	// 82EB5590: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB5594: 386BD244  addi r3, r11, -0x2dbc
	ctx.r[3].s64 = ctx.r[11].s64 + -11708;
	// 82EB5598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB55A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB55A0 size=8
    let mut pc: u32 = 0x82EB55A0;
    'dispatch: loop {
        match pc {
            0x82EB55A0 => {
    //   block [0x82EB55A0..0x82EB55A8)
	// 82EB55A0: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EB55A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB55A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB55A8 size=8
    let mut pc: u32 = 0x82EB55A8;
    'dispatch: loop {
        match pc {
            0x82EB55A8 => {
    //   block [0x82EB55A8..0x82EB55B0)
	// 82EB55A8: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB55AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB55B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB55B0 size=148
    let mut pc: u32 = 0x82EB55B0;
    'dispatch: loop {
        match pc {
            0x82EB55B0 => {
    //   block [0x82EB55B0..0x82EB5644)
	// 82EB55B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB55B4: 4BDF3E59  bl 0x82ca940c
	ctx.lr = 0x82EB55B8;
	sub_82CA93D0(ctx, base);
	// 82EB55B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB55BC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB55C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB55C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB55C8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB55CC: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82EB55D0: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EB55D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB55D8: 4B3330A1  bl 0x821e8678
	ctx.lr = 0x82EB55DC;
	sub_821E8678(ctx, base);
	// 82EB55DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB55E0: 41820014  beq 0x82eb55f4
	if ctx.cr[0].eq {
	pc = 0x82EB55F4; continue 'dispatch;
	}
	// 82EB55E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB55E8: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB55EC: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB55F0: 4800002C  b 0x82eb561c
	pc = 0x82EB561C; continue 'dispatch;
	// 82EB55F4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB55F8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB55FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5600: 4182000C  beq 0x82eb560c
	if ctx.cr[0].eq {
	pc = 0x82EB560C; continue 'dispatch;
	}
	// 82EB5604: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5608: 4800000C  b 0x82eb5614
	pc = 0x82EB5614; continue 'dispatch;
	// 82EB560C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5610: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5614: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5618: C00B0B24  lfs f0, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB561C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5620: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5624: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB5628: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB562C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5630: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5634: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5638: 4E800421  bctrl
	ctx.lr = 0x82EB563C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB563C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB5640: 4BDF3E1C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5648 size=156
    let mut pc: u32 = 0x82EB5648;
    'dispatch: loop {
        match pc {
            0x82EB5648 => {
    //   block [0x82EB5648..0x82EB56E4)
	// 82EB5648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB564C: 4BDF3DBD  bl 0x82ca9408
	ctx.lr = 0x82EB5650;
	sub_82CA93D0(ctx, base);
	// 82EB5650: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5654: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB565C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5660: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB5664: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82EB5668: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EB566C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB5670: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EB5674: 4B333005  bl 0x821e8678
	ctx.lr = 0x82EB5678;
	sub_821E8678(ctx, base);
	// 82EB5678: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB567C: 41820014  beq 0x82eb5690
	if ctx.cr[0].eq {
	pc = 0x82EB5690; continue 'dispatch;
	}
	// 82EB5680: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5684: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5688: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB568C: 4800002C  b 0x82eb56b8
	pc = 0x82EB56B8; continue 'dispatch;
	// 82EB5690: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5694: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB5698: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB569C: 4182000C  beq 0x82eb56a8
	if ctx.cr[0].eq {
	pc = 0x82EB56A8; continue 'dispatch;
	}
	// 82EB56A0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB56A4: 4800000C  b 0x82eb56b0
	pc = 0x82EB56B0; continue 'dispatch;
	// 82EB56A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB56AC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB56B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB56B4: C00B0B24  lfs f0, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB56B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB56BC: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB56C0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB56C4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB56C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB56CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB56D0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB56D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB56D8: 4E800421  bctrl
	ctx.lr = 0x82EB56DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB56DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB56E0: 4BDF3D78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB56E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB56E8 size=12
    let mut pc: u32 = 0x82EB56E8;
    'dispatch: loop {
        match pc {
            0x82EB56E8 => {
    //   block [0x82EB56E8..0x82EB56F4)
	// 82EB56E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB56EC: 386BD590  addi r3, r11, -0x2a70
	ctx.r[3].s64 = ctx.r[11].s64 + -10864;
	// 82EB56F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB56F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB56F8 size=88
    let mut pc: u32 = 0x82EB56F8;
    'dispatch: loop {
        match pc {
            0x82EB56F8 => {
    //   block [0x82EB56F8..0x82EB5750)
	// 82EB56F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB56FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5700: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB5704: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB570C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5710: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5714: 4800B675  bl 0x82ec0d88
	ctx.lr = 0x82EB5718;
	sub_82EC0D88(ctx, base);
	// 82EB5718: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB571C: 41820018  beq 0x82eb5734
	if ctx.cr[0].eq {
	pc = 0x82EB5734; continue 'dispatch;
	}
	// 82EB5720: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB5724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5728: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB572C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5730: 4E800421  bctrl
	ctx.lr = 0x82EB5734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB5734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5738: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB573C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5744: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB5748: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB574C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5750 size=148
    let mut pc: u32 = 0x82EB5750;
    'dispatch: loop {
        match pc {
            0x82EB5750 => {
    //   block [0x82EB5750..0x82EB57E4)
	// 82EB5750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5758: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB575C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5764: 4BFFFBCD  bl 0x82eb5330
	ctx.lr = 0x82EB5768;
	sub_82EB5330(ctx, base);
	// 82EB5768: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB576C: 396BA8BC  addi r11, r11, -0x5744
	ctx.r[11].s64 = ctx.r[11].s64 + -22340;
	// 82EB5770: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB5774: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5778: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB577C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5780: 4182000C  beq 0x82eb578c
	if ctx.cr[0].eq {
	pc = 0x82EB578C; continue 'dispatch;
	}
	// 82EB5784: C18B000C  lfs f12, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5788: 4800000C  b 0x82eb5794
	pc = 0x82EB5794; continue 'dispatch;
	// 82EB578C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5790: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5794: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB5798: C00BDF3C  lfs f0, -0x20c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB579C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB57A0: C1ABBE10  lfs f13, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB57A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB57A8: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB57AC: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB57B0: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB57B4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB57B8: 4B3846F9  bl 0x82239eb0
	ctx.lr = 0x82EB57BC;
	sub_82239EB0(ctx, base);
	// 82EB57BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB57C0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB57C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB57C8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB57CC: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EB57D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB57D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB57D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB57DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB57E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB57E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB57E8 size=12
    let mut pc: u32 = 0x82EB57E8;
    'dispatch: loop {
        match pc {
            0x82EB57E8 => {
    //   block [0x82EB57E8..0x82EB57F4)
	// 82EB57E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB57EC: 386BCDF0  addi r3, r11, -0x3210
	ctx.r[3].s64 = ctx.r[11].s64 + -12816;
	// 82EB57F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB57F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB57F8 size=12
    let mut pc: u32 = 0x82EB57F8;
    'dispatch: loop {
        match pc {
            0x82EB57F8 => {
    //   block [0x82EB57F8..0x82EB5804)
	// 82EB57F8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB57FC: 386BCBC8  addi r3, r11, -0x3438
	ctx.r[3].s64 = ctx.r[11].s64 + -13368;
	// 82EB5800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5808 size=16
    let mut pc: u32 = 0x82EB5808;
    'dispatch: loop {
        match pc {
            0x82EB5808 => {
    //   block [0x82EB5808..0x82EB5818)
	// 82EB5808: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB580C: 99630040  stb r11, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 82EB5810: 9963019D  stb r11, 0x19d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(413 as u32), ctx.r[11].u8 ) };
	// 82EB5814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5818 size=12
    let mut pc: u32 = 0x82EB5818;
    'dispatch: loop {
        match pc {
            0x82EB5818 => {
    //   block [0x82EB5818..0x82EB5824)
	// 82EB5818: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB581C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB5820: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5824(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5824 size=12
    let mut pc: u32 = 0x82EB5824;
    'dispatch: loop {
        match pc {
            0x82EB5824 => {
    //   block [0x82EB5824..0x82EB5830)
	// 82EB5824: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB5828: 996500A1  stb r11, 0xa1(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(161 as u32), ctx.r[11].u8 ) };
	// 82EB582C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB5830 size=108
    let mut pc: u32 = 0x82EB5830;
    'dispatch: loop {
        match pc {
            0x82EB5830 => {
    //   block [0x82EB5830..0x82EB589C)
	// 82EB5830: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5834: 81430398  lwz r10, 0x398(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EB5838: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82EB583C: 810B01B8  lwz r8, 0x1b8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5840: 409A00B8  bne cr6, 0x82eb58f8
	if !ctx.cr[6].eq {
		sub_82EB58F8(ctx, base);
		return;
	}
	// 82EB5844: 816B01BC  lwz r11, 0x1bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB5848: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB584C: 419A00AC  beq cr6, 0x82eb58f8
	if ctx.cr[6].eq {
		sub_82EB58F8(ctx, base);
		return;
	}
	// 82EB5850: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5854: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB5858: 8163039C  lwz r11, 0x39c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EB585C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB5860: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB5864: C16B0004  lfs f11, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5868: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB586C: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5870: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB5874: C1AA0038  lfs f13, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5878: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB587C: C18A003C  lfs f12, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5880: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5884: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB5888: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB588C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5890: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5894: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB5898: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB589C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB589C size=92
    let mut pc: u32 = 0x82EB589C;
    'dispatch: loop {
        match pc {
            0x82EB589C => {
    //   block [0x82EB589C..0x82EB58F8)
	// 82EB589C: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82EB58A0: C16AFFF8  lfs f11, -8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB58A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB58A8: C14AFFFC  lfs f10, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB58AC: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB58B0: 419A0030  beq cr6, 0x82eb58e0
	if ctx.cr[6].eq {
	pc = 0x82EB58E0; continue 'dispatch;
	}
	// 82EB58B4: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB58B8: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB58BC: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB58C0: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB58C4: C129000C  lfs f9, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB58C8: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB58CC: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB58D0: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB58D4: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB58D8: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB58DC: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EB58E0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB58E4: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EB58E8: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EB58EC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB58F0: 409AFFB0  bne cr6, 0x82eb58a0
	if !ctx.cr[6].eq {
	pc = 0x82EB58A0; continue 'dispatch;
	}
	// 82EB58F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB58F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB58F8 size=64
    let mut pc: u32 = 0x82EB58F8;
    'dispatch: loop {
        match pc {
            0x82EB58F8 => {
    //   block [0x82EB58F8..0x82EB5938)
	// 82EB58F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB58FC: C00302DC  lfs f0, 0x2dc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5900: C1A302E0  lfs f13, 0x2e0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(736 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5904: C18302E4  lfs f12, 0x2e4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(740 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5908: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB590C: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5910: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB5914: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB5918: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB591C: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5920: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB5924: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5928: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB592C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5930: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB5934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5938 size=16
    let mut pc: u32 = 0x82EB5938;
    'dispatch: loop {
        match pc {
            0x82EB5938 => {
    //   block [0x82EB5938..0x82EB5948)
	// 82EB5938: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB593C: 90830038  stw r4, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[4].u32 ) };
	// 82EB5940: 99630034  stb r11, 0x34(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82EB5944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5948 size=624
    let mut pc: u32 = 0x82EB5948;
    'dispatch: loop {
        match pc {
            0x82EB5948 => {
    //   block [0x82EB5948..0x82EB5BB8)
	// 82EB5948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB594C: 4BDF3AB9  bl 0x82ca9404
	ctx.lr = 0x82EB5950;
	sub_82CA93D0(ctx, base);
	// 82EB5950: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82EB5954: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5958: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB595C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EB5960: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EB5964: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5968: 9BBF0034  stb r29, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u8 ) };
	// 82EB596C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5970: 4182023C  beq 0x82eb5bac
	if ctx.cr[0].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5974: 81630294  lwz r11, 0x294(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(660 as u32) ) } as u64;
	// 82EB5978: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EB597C: 409A0230  bne cr6, 0x82eb5bac
	if !ctx.cr[6].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5980: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB5984: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5988: 40820018  bne 0x82eb59a0
	if !ctx.cr[0].eq {
	pc = 0x82EB59A0; continue 'dispatch;
	}
	// 82EB598C: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB5990: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB5994: 388B5818  addi r4, r11, 0x5818
	ctx.r[4].s64 = ctx.r[11].s64 + 22552;
	// 82EB5998: 48017009  bl 0x82ecc9a0
	ctx.lr = 0x82EB599C;
	sub_82ECC9A0(ctx, base);
	// 82EB599C: 9BBF00A0  stb r29, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[29].u8 ) };
	// 82EB59A0: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB59A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB59A8: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB59AC: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB59B0: 419A003C  beq cr6, 0x82eb59ec
	if ctx.cr[6].eq {
	pc = 0x82EB59EC; continue 'dispatch;
	}
	// 82EB59B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB59B8: 419A0034  beq cr6, 0x82eb59ec
	if ctx.cr[6].eq {
	pc = 0x82EB59EC; continue 'dispatch;
	}
	// 82EB59BC: 4801DE95  bl 0x82ed3850
	ctx.lr = 0x82EB59C0;
	sub_82ED3850(ctx, base);
	// 82EB59C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB59C4: 41820028  beq 0x82eb59ec
	if ctx.cr[0].eq {
	pc = 0x82EB59EC; continue 'dispatch;
	}
	// 82EB59C8: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB59CC: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB59D0: 41820010  beq 0x82eb59e0
	if ctx.cr[0].eq {
	pc = 0x82EB59E0; continue 'dispatch;
	}
	// 82EB59D4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB59D8: 4801D559  bl 0x82ed2f30
	ctx.lr = 0x82EB59DC;
	sub_82ED2F30(ctx, base);
	// 82EB59DC: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB59E0: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB59E4: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB59E8: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EB59EC: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB59F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB59F4: 41820024  beq 0x82eb5a18
	if ctx.cr[0].eq {
	pc = 0x82EB5A18; continue 'dispatch;
	}
	// 82EB59F8: 4801DEB1  bl 0x82ed38a8
	ctx.lr = 0x82EB59FC;
	sub_82ED38A8(ctx, base);
	// 82EB59FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5A00: 41820018  beq 0x82eb5a18
	if ctx.cr[0].eq {
	pc = 0x82EB5A18; continue 'dispatch;
	}
	// 82EB5A04: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB5A08: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5A0C: 4801D525  bl 0x82ed2f30
	ctx.lr = 0x82EB5A10;
	sub_82ED2F30(ctx, base);
	// 82EB5A10: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB5A14: 9BBF00A1  stb r29, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[29].u8 ) };
	// 82EB5A18: C17B0000  lfs f11, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5A1C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB5A20: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A24: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB5A28: C15F0084  lfs f10, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB5A2C: C1BB0004  lfs f13, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5A30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A34: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB5A38: C19B0008  lfs f12, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5A3C: C15F0088  lfs f10, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB5A40: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB5A44: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5A48: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5A4C: ED8C033A  fmadds f12, f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5A50: 409A0010  bne cr6, 0x82eb5a60
	if !ctx.cr[6].eq {
	pc = 0x82EB5A60; continue 'dispatch;
	}
	// 82EB5A54: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB5A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A5C: 419A0058  beq cr6, 0x82eb5ab4
	if ctx.cr[6].eq {
	pc = 0x82EB5AB4; continue 'dispatch;
	}
	// 82EB5A60: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5A64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB5A68: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB5A6C: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A74: 4182000C  beq 0x82eb5a80
	if ctx.cr[0].eq {
	pc = 0x82EB5A80; continue 'dispatch;
	}
	// 82EB5A78: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5A7C: 48000008  b 0x82eb5a84
	pc = 0x82EB5A84; continue 'dispatch;
	// 82EB5A80: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EB5A84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A88: 41820008  beq 0x82eb5a90
	if ctx.cr[0].eq {
	pc = 0x82EB5A90; continue 'dispatch;
	}
	// 82EB5A8C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A90: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB5A94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5A98: C00B0B60  lfs f0, 0xb60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A9C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5AA0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EB5AA4: 40980010  bge cr6, 0x82eb5ab4
	if !ctx.cr[6].lt {
	pc = 0x82EB5AB4; continue 'dispatch;
	}
	// 82EB5AA8: 897F00A1  lbz r11, 0xa1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(161 as u32) ) } as u64;
	// 82EB5AAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5AB0: 418200FC  beq 0x82eb5bac
	if ctx.cr[0].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5AB4: D17F0080  stfs f11, 0x80(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB5AB8: 3B9F005C  addi r28, r31, 0x5c
	ctx.r[28].s64 = ctx.r[31].s64 + 92;
	// 82EB5ABC: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5AC0: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB5AC4: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5AC8: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB5ACC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5AD0: 9BDF00A1  stb r30, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[30].u8 ) };
	// 82EB5AD4: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EB5AD8: 4801C3C9  bl 0x82ed1ea0
	ctx.lr = 0x82EB5ADC;
	sub_82ED1EA0(ctx, base);
	// 82EB5ADC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB5AE0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82EB5AE4: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB5AE8: 40990008  ble cr6, 0x82eb5af0
	if !ctx.cr[6].gt {
	pc = 0x82EB5AF0; continue 'dispatch;
	}
	// 82EB5AEC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EB5AF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB5AF4: 80FF0060  lwz r7, 0x60(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB5AF8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EB5AFC: C03F002C  lfs f1, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB5B00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB5B04: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B08: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB5B0C: 4801C58D  bl 0x82ed2098
	ctx.lr = 0x82EB5B10;
	sub_82ED2098(ctx, base);
	// 82EB5B10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5B14: 41820098  beq 0x82eb5bac
	if ctx.cr[0].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5B18: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5B20: 419A008C  beq cr6, 0x82eb5bac
	if ctx.cr[6].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5B24: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB5B28: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5B2C: 4182000C  beq 0x82eb5b38
	if ctx.cr[0].eq {
	pc = 0x82EB5B38; continue 'dispatch;
	}
	// 82EB5B30: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B34: 4801D3FD  bl 0x82ed2f30
	ctx.lr = 0x82EB5B38;
	sub_82ED2F30(ctx, base);
	// 82EB5B38: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B3C: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB5B40: 4801C461  bl 0x82ed1fa0
	ctx.lr = 0x82EB5B44;
	sub_82ED1FA0(ctx, base);
	// 82EB5B44: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5B4C: 40990044  ble cr6, 0x82eb5b90
	if !ctx.cr[6].gt {
	pc = 0x82EB5B90; continue 'dispatch;
	}
	// 82EB5B50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5B54: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB5B58: C3EB0C4C  lfs f31, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB5B5C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB5B60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB5B64: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB5B68: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B6C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB5B70: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB5B74: 4801D1D5  bl 0x82ed2d48
	ctx.lr = 0x82EB5B78;
	sub_82ED2D48(ctx, base);
	// 82EB5B78: 907F0064  stw r3, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EB5B7C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB5B80: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5B84: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB5B88: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB5B8C: 4198FFD0  blt cr6, 0x82eb5b5c
	if ctx.cr[6].lt {
	pc = 0x82EB5B5C; continue 'dispatch;
	}
	// 82EB5B90: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B94: 4801C42D  bl 0x82ed1fc0
	ctx.lr = 0x82EB5B98;
	sub_82ED1FC0(ctx, base);
	// 82EB5B98: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB5B9C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82EB5BA0: 4098000C  bge cr6, 0x82eb5bac
	if !ctx.cr[6].lt {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5BA4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB5BA8: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB5BAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5BB0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EB5BB4: 4BDF38A0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5BB8 size=196
    let mut pc: u32 = 0x82EB5BB8;
    'dispatch: loop {
        match pc {
            0x82EB5BB8 => {
    //   block [0x82EB5BB8..0x82EB5C7C)
	// 82EB5BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5BBC: 4BDF3845  bl 0x82ca9400
	ctx.lr = 0x82EB5BC0;
	sub_82CA93D0(ctx, base);
	// 82EB5BC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5BC4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EB5BC8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EB5BCC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82EB5BD0: 419A00A4  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BD4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EB5BD8: 419A009C  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BDC: 83FA01BC  lwz r31, 0x1bc(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB5BE0: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5BE4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB5BE8: 419A008C  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BEC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB5BF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB5BF4: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5BF8: 4182007C  beq 0x82eb5c74
	if ctx.cr[0].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB5C00: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5C04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB5C08: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EB5C0C: 4801DCCD  bl 0x82ed38d8
	ctx.lr = 0x82EB5C10;
	sub_82ED38D8(ctx, base);
	// 82EB5C10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5C14: 4182000C  beq 0x82eb5c20
	if ctx.cr[0].eq {
	pc = 0x82EB5C20; continue 'dispatch;
	}
	// 82EB5C18: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5C1C: 48000008  b 0x82eb5c24
	pc = 0x82EB5C24; continue 'dispatch;
	// 82EB5C20: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB5C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5C28: 419A0030  beq cr6, 0x82eb5c58
	if ctx.cr[6].eq {
	pc = 0x82EB5C58; continue 'dispatch;
	}
	// 82EB5C2C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EB5C30: 419A0028  beq cr6, 0x82eb5c58
	if ctx.cr[6].eq {
	pc = 0x82EB5C58; continue 'dispatch;
	}
	// 82EB5C34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB5C38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB5C3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB5C40: 4801FD21  bl 0x82ed5960
	ctx.lr = 0x82EB5C44;
	sub_82ED5960(ctx, base);
	// 82EB5C44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5C48: 41820010  beq 0x82eb5c58
	if ctx.cr[0].eq {
	pc = 0x82EB5C58; continue 'dispatch;
	}
	// 82EB5C4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB5C50: 4801EB41  bl 0x82ed4790
	ctx.lr = 0x82EB5C54;
	sub_82ED4790(ctx, base);
	// 82EB5C54: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82EB5C58: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5C5C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB5C60: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82EB5C64: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB5C68: 419A000C  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5C6C: 37FF0014  addic. r31, r31, 0x14
	ctx.xer.ca = (ctx.r[31].u32 > (!(20 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EB5C70: 4082FF8C  bne 0x82eb5bfc
	if !ctx.cr[0].eq {
	pc = 0x82EB5BFC; continue 'dispatch;
	}
	// 82EB5C74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5C78: 4BDF37D8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5C80 size=16
    let mut pc: u32 = 0x82EB5C80;
    'dispatch: loop {
        match pc {
            0x82EB5C80 => {
    //   block [0x82EB5C80..0x82EB5C90)
	// 82EB5C80: 816301BC  lwz r11, 0x1bc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB5C84: 814301B8  lwz r10, 0x1b8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5C88: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB5C8C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5C90 size=16
    let mut pc: u32 = 0x82EB5C90;
    'dispatch: loop {
        match pc {
            0x82EB5C90 => {
    //   block [0x82EB5C90..0x82EB5CA0)
	// 82EB5C90: 1D440014  mulli r10, r4, 0x14
	ctx.r[10].s64 = ctx.r[4].s64 * 20;
	// 82EB5C94: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB5C98: 916301BC  stw r11, 0x1bc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB5C9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5CA0 size=56
    let mut pc: u32 = 0x82EB5CA0;
    'dispatch: loop {
        match pc {
            0x82EB5CA0 => {
    //   block [0x82EB5CA0..0x82EB5CD8)
	// 82EB5CA0: 816301BC  lwz r11, 0x1bc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB5CA4: 814301B8  lwz r10, 0x1b8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5CA8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB5CAC: 419A0030  beq cr6, 0x82eb5cdc
	if ctx.cr[6].eq {
		sub_82EB5CD8(ctx, base);
		return;
	}
	// 82EB5CB0: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5CB4: 5529007E  clrlwi r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB5CB8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5CBC: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB5CC0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB5CC4: 419A0014  beq cr6, 0x82eb5cd8
	if ctx.cr[6].eq {
		sub_82EB5CD8(ctx, base);
		return;
	}
	// 82EB5CC8: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EB5CCC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB5CD0: 409AFFE8  bne cr6, 0x82eb5cb8
	if !ctx.cr[6].eq {
	pc = 0x82EB5CB8; continue 'dispatch;
	}
	// 82EB5CD4: 48000008  b 0x82eb5cdc
	sub_82EB5CD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB5CD8 size=64
    let mut pc: u32 = 0x82EB5CD8;
    'dispatch: loop {
        match pc {
            0x82EB5CD8 => {
    //   block [0x82EB5CD8..0x82EB5D18)
	// 82EB5CD8: 916301B8  stw r11, 0x1b8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB5CDC: 816301B8  lwz r11, 0x1b8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5CE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB5CE4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5CE8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB5CEC: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5CF0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB5CF4: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5CF8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB5CFC: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5D00: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB5D04: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EB5D08: 816301B8  lwz r11, 0x1b8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5D0C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EB5D10: 916301B8  stw r11, 0x1b8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB5D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5D18 size=128
    let mut pc: u32 = 0x82EB5D18;
    'dispatch: loop {
        match pc {
            0x82EB5D18 => {
    //   block [0x82EB5D18..0x82EB5D98)
	// 82EB5D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5D1C: 4BDF36F1  bl 0x82ca940c
	ctx.lr = 0x82EB5D20;
	sub_82CA93D0(ctx, base);
	// 82EB5D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5D28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB5D2C: 3FA08330  lis r29, -0x7cd0
	ctx.r[29].s64 = -2094006272;
	// 82EB5D30: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5D34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5D38: 41820014  beq 0x82eb5d4c
	if ctx.cr[0].eq {
	pc = 0x82EB5D4C; continue 'dispatch;
	}
	// 82EB5D3C: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB5D40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5D44: 4E800421  bctrl
	ctx.lr = 0x82EB5D48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB5D48: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EB5D4C: 807F019C  lwz r3, 0x19c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB5D50: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EB5D54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5D58: 41820014  beq 0x82eb5d6c
	if ctx.cr[0].eq {
	pc = 0x82EB5D6C; continue 'dispatch;
	}
	// 82EB5D5C: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB5D60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5D64: 4E800421  bctrl
	ctx.lr = 0x82EB5D68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB5D68: 93DF019C  stw r30, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[30].u32 ) };
	// 82EB5D6C: 807F01B4  lwz r3, 0x1b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB5D70: 93DF01A0  stw r30, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 82EB5D74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5D78: 41820014  beq 0x82eb5d8c
	if ctx.cr[0].eq {
	pc = 0x82EB5D8C; continue 'dispatch;
	}
	// 82EB5D7C: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB5D80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5D84: 4E800421  bctrl
	ctx.lr = 0x82EB5D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB5D88: 93DF01B4  stw r30, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[30].u32 ) };
	// 82EB5D8C: 93DF01C0  stw r30, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[30].u32 ) };
	// 82EB5D90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB5D94: 4BDF36C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5D98 size=312
    let mut pc: u32 = 0x82EB5D98;
    'dispatch: loop {
        match pc {
            0x82EB5D98 => {
    //   block [0x82EB5D98..0x82EB5ED0)
	// 82EB5D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5D9C: 4BDF3661  bl 0x82ca93fc
	ctx.lr = 0x82EB5DA0;
	sub_82CA93D0(ctx, base);
	// 82EB5DA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5DA4: 81450018  lwz r10, 0x18(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5DA8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EB5DAC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB5DB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5DB4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB5DB8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EB5DBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB5DC0: 419A0024  beq cr6, 0x82eb5de4
	if ctx.cr[6].eq {
	pc = 0x82EB5DE4; continue 'dispatch;
	}
	// 82EB5DC4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB5DC8: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5DCC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB5DD0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5DD4: 913D0018  stw r9, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB5DD8: 4182000C  beq 0x82eb5de4
	if ctx.cr[0].eq {
	pc = 0x82EB5DE4; continue 'dispatch;
	}
	// 82EB5DDC: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82EB5DE0: 4BFFFFE4  b 0x82eb5dc4
	pc = 0x82EB5DC4; continue 'dispatch;
	// 82EB5DE4: 54DA043E  clrlwi r26, r6, 0x10
	ctx.r[26].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 82EB5DE8: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5DEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5DF0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5DF4: 83EB0198  lwz r31, 0x198(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB5DF8: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB5DFC: 933E0008  stw r25, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82EB5E00: 4801DA31  bl 0x82ed3830
	ctx.lr = 0x82EB5E04;
	sub_82ED3830(ctx, base);
	// 82EB5E04: 546B007E  clrlwi r11, r3, 1
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB5E08: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	// 82EB5E0C: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 82EB5E10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB5E14: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5E18: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5E1C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB5E20: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5E24: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB5E28: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5E2C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB5E30: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB5E34: B33F0012  sth r25, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[25].u16 ) };
	// 82EB5E38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5E3C: 41820040  beq 0x82eb5e7c
	if ctx.cr[0].eq {
	pc = 0x82EB5E7C; continue 'dispatch;
	}
	// 82EB5E40: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5E44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5E48: 41820034  beq 0x82eb5e7c
	if ctx.cr[0].eq {
	pc = 0x82EB5E7C; continue 'dispatch;
	}
	// 82EB5E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5E50: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5E54: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5E58: 4801FB09  bl 0x82ed5960
	ctx.lr = 0x82EB5E5C;
	sub_82ED5960(ctx, base);
	// 82EB5E5C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82EB5E60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB5E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5E68: 4801D8E9  bl 0x82ed3750
	ctx.lr = 0x82EB5E6C;
	sub_82ED3750(ctx, base);
	// 82EB5E6C: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5E70: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EB5E74: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5E78: 48000008  b 0x82eb5e80
	pc = 0x82EB5E80; continue 'dispatch;
	// 82EB5E7C: B33F0012  sth r25, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[25].u16 ) };
	// 82EB5E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5E84: 4801F2FD  bl 0x82ed5180
	ctx.lr = 0x82EB5E88;
	sub_82ED5180(ctx, base);
	// 82EB5E88: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5E8C: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82EB5E90: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82EB5E94: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5E98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB5E9C: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5EA0: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5EA4: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB5EA8: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5EAC: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB5EB0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB5EB4: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB5EB8: 914B0198  stw r10, 0x198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(408 as u32), ctx.r[10].u32 ) };
	// 82EB5EBC: 83BD0018  lwz r29, 0x18(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5EC0: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5EC4: 4082FF24  bne 0x82eb5de8
	if !ctx.cr[0].eq {
	pc = 0x82EB5DE8; continue 'dispatch;
	}
	// 82EB5EC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5ECC: 4BDF3580  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5ED0 size=300
    let mut pc: u32 = 0x82EB5ED0;
    'dispatch: loop {
        match pc {
            0x82EB5ED0 => {
    //   block [0x82EB5ED0..0x82EB5FFC)
	// 82EB5ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5ED4: 4BDF3529  bl 0x82ca93fc
	ctx.lr = 0x82EB5ED8;
	sub_82CA93D0(ctx, base);
	// 82EB5ED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5EDC: 81450018  lwz r10, 0x18(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5EE0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EB5EE4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB5EE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5EEC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB5EF0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EB5EF4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB5EF8: 419A0024  beq cr6, 0x82eb5f1c
	if ctx.cr[6].eq {
	pc = 0x82EB5F1C; continue 'dispatch;
	}
	// 82EB5EFC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB5F00: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5F04: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB5F08: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5F0C: 913D0018  stw r9, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB5F10: 4182000C  beq 0x82eb5f1c
	if ctx.cr[0].eq {
	pc = 0x82EB5F1C; continue 'dispatch;
	}
	// 82EB5F14: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82EB5F18: 4BFFFFE4  b 0x82eb5efc
	pc = 0x82EB5EFC; continue 'dispatch;
	// 82EB5F1C: 54DA043E  clrlwi r26, r6, 0x10
	ctx.r[26].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 82EB5F20: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5F24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5F28: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5F2C: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB5F30: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB5F34: 933E0008  stw r25, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82EB5F38: 4801D8F9  bl 0x82ed3830
	ctx.lr = 0x82EB5F3C;
	sub_82ED3830(ctx, base);
	// 82EB5F3C: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	// 82EB5F40: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 82EB5F44: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB5F48: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5F4C: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5F50: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB5F54: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5F58: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB5F5C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5F60: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB5F64: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB5F68: B33F0012  sth r25, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[25].u16 ) };
	// 82EB5F6C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5F70: 4182003C  beq 0x82eb5fac
	if ctx.cr[0].eq {
	pc = 0x82EB5FAC; continue 'dispatch;
	}
	// 82EB5F74: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5F78: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5F7C: 41820030  beq 0x82eb5fac
	if ctx.cr[0].eq {
	pc = 0x82EB5FAC; continue 'dispatch;
	}
	// 82EB5F80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5F84: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5F88: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5F8C: 4801F9D5  bl 0x82ed5960
	ctx.lr = 0x82EB5F90;
	sub_82ED5960(ctx, base);
	// 82EB5F90: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82EB5F94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB5F98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5F9C: 4801D7B5  bl 0x82ed3750
	ctx.lr = 0x82EB5FA0;
	sub_82ED3750(ctx, base);
	// 82EB5FA0: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FA4: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EB5FA8: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5FAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5FB0: 4801F1D1  bl 0x82ed5180
	ctx.lr = 0x82EB5FB4;
	sub_82ED5180(ctx, base);
	// 82EB5FB4: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FB8: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82EB5FBC: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82EB5FC0: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB5FC8: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5FCC: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5FD0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB5FD4: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FD8: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB5FDC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB5FE0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB5FE4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB5FE8: 83BD0018  lwz r29, 0x18(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5FEC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5FF0: 4082FF30  bne 0x82eb5f20
	if !ctx.cr[0].eq {
	pc = 0x82EB5F20; continue 'dispatch;
	}
	// 82EB5FF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5FF8: 4BDF3454  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB6000 size=88
    let mut pc: u32 = 0x82EB6000;
    'dispatch: loop {
        match pc {
            0x82EB6000 => {
    //   block [0x82EB6000..0x82EB6058)
	// 82EB6000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB6004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB6008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB600C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB6010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB6018: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB601C: 4BFFF3AD  bl 0x82eb53c8
	ctx.lr = 0x82EB6020;
	sub_82EB53C8(ctx, base);
	// 82EB6020: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6024: 41820018  beq 0x82eb603c
	if ctx.cr[0].eq {
	pc = 0x82EB603C; continue 'dispatch;
	}
	// 82EB6028: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB602C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6030: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB6034: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6038: 4E800421  bctrl
	ctx.lr = 0x82EB603C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB603C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6040: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB6044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB6048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB604C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB6050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB6054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB6058 size=324
    let mut pc: u32 = 0x82EB6058;
    'dispatch: loop {
        match pc {
            0x82EB6058 => {
    //   block [0x82EB6058..0x82EB619C)
	// 82EB6058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB605C: 4BDF33AD  bl 0x82ca9408
	ctx.lr = 0x82EB6060;
	sub_82CA93D0(ctx, base);
	// 82EB6060: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6064: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB6068: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB606C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EB6070: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6074: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB6078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB607C: 4E800421  bctrl
	ctx.lr = 0x82EB6080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB6080: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EB6084: 4182010C  beq 0x82eb6190
	if ctx.cr[0].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB608C: 4801D7C5  bl 0x82ed3850
	ctx.lr = 0x82EB6090;
	sub_82ED3850(ctx, base);
	// 82EB6090: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6094: 418200FC  beq 0x82eb6190
	if ctx.cr[0].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6098: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB609C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB60A0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB60A4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EB60A8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB60AC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB60B0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB60B4: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB60B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB60BC: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EB60C0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB60C4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB60C8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB60CC: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82EB60D0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB60D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB60D8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB60DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB60E0: 4200FFF8  bdnz 0x82eb60d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB60D8; continue 'dispatch;
	}
	// 82EB60E4: 817C009C  lwz r11, 0x9c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EB60E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB60EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB60F0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB60F4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB60F8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EB60FC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB6100: 9BC100D8  stb r30, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[30].u8 ) };
	// 82EB6104: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EB6108: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB610C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB6110: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EB6114: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB6118: 4801F419  bl 0x82ed5530
	ctx.lr = 0x82EB611C;
	sub_82ED5530(ctx, base);
	// 82EB611C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB6120: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82EB6124: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB6128: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB612C: 554BDFFF  rlwinm. r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6130: 41820060  beq 0x82eb6190
	if ctx.cr[0].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6134: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB6138: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 82EB613C: 419A0054  beq cr6, 0x82eb6190
	if ctx.cr[6].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6140: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB6144: 4801D795  bl 0x82ed38d8
	ctx.lr = 0x82EB6148;
	sub_82ED38D8(ctx, base);
	// 82EB6148: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB614C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB6150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6154: 388A75C8  addi r4, r10, 0x75c8
	ctx.r[4].s64 = ctx.r[10].s64 + 30152;
	// 82EB6158: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB615C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB6160: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6164: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB6168: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB616C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6170: 9BDF0058  stb r30, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB6174: 4BFD356D  bl 0x82e896e0
	ctx.lr = 0x82EB6178;
	sub_82E896E0(ctx, base);
	// 82EB6178: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB617C: 4182000C  beq 0x82eb6188
	if ctx.cr[0].eq {
	pc = 0x82EB6188; continue 'dispatch;
	}
	// 82EB6180: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB6184: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB6188: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB618C: 48000008  b 0x82eb6194
	pc = 0x82EB6194; continue 'dispatch;
	// 82EB6190: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB6194: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82EB6198: 4BDF32C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB61A0 size=216
    let mut pc: u32 = 0x82EB61A0;
    'dispatch: loop {
        match pc {
            0x82EB61A0 => {
    //   block [0x82EB61A0..0x82EB6278)
	// 82EB61A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB61A4: 4BDF3265  bl 0x82ca9408
	ctx.lr = 0x82EB61A8;
	sub_82CA93D0(ctx, base);
	// 82EB61A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB61AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB61B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB61B4: 809D017C  lwz r4, 0x17c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB61B8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB61BC: 41820010  beq 0x82eb61cc
	if ctx.cr[0].eq {
	pc = 0x82EB61CC; continue 'dispatch;
	}
	// 82EB61C0: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB61C4: 4801CD6D  bl 0x82ed2f30
	ctx.lr = 0x82EB61C8;
	sub_82ED2F30(ctx, base);
	// 82EB61C8: 93FD017C  stw r31, 0x17c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(380 as u32), ctx.r[31].u32 ) };
	// 82EB61CC: 817D0168  lwz r11, 0x168(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB61D0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82EB61D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB61D8: 40990064  ble cr6, 0x82eb623c
	if !ctx.cr[6].gt {
	pc = 0x82EB623C; continue 'dispatch;
	}
	// 82EB61DC: 3BDD00A8  addi r30, r29, 0xa8
	ctx.r[30].s64 = ctx.r[29].s64 + 168;
	// 82EB61E0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB61E4: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB61E8: 4182001C  beq 0x82eb6204
	if ctx.cr[0].eq {
	pc = 0x82EB6204; continue 'dispatch;
	}
	// 82EB61EC: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB61F0: 4801CD41  bl 0x82ed2f30
	ctx.lr = 0x82EB61F4;
	sub_82ED2F30(ctx, base);
	// 82EB61F4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82EB61F8: 9BFE0004  stb r31, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EB61FC: 93FE0048  stw r31, 0x48(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 82EB6200: 93FEFFFC  stw r31, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[31].u32 ) };
	// 82EB6204: 809E0060  lwz r4, 0x60(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB6208: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB620C: 4182001C  beq 0x82eb6228
	if ctx.cr[0].eq {
	pc = 0x82EB6228; continue 'dispatch;
	}
	// 82EB6210: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB6214: 4801CD1D  bl 0x82ed2f30
	ctx.lr = 0x82EB6218;
	sub_82ED2F30(ctx, base);
	// 82EB6218: 93FE0060  stw r31, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82EB621C: 9BFE0064  stb r31, 0x64(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[31].u8 ) };
	// 82EB6220: 93FE00A8  stw r31, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 82EB6224: 93FE005C  stw r31, 0x5c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82EB6228: 817D0168  lwz r11, 0x168(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB622C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB6230: 3BDE0060  addi r30, r30, 0x60
	ctx.r[30].s64 = ctx.r[30].s64 + 96;
	// 82EB6234: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6238: 4198FFA8  blt cr6, 0x82eb61e0
	if ctx.cr[6].lt {
	pc = 0x82EB61E0; continue 'dispatch;
	}
	// 82EB623C: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6240: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6244: 812B01B4  lwz r9, 0x1b4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB6248: 810B019C  lwz r8, 0x19c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB624C: 93EB01A4  stw r31, 0x1a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), ctx.r[31].u32 ) };
	// 82EB6250: 93EB01A8  stw r31, 0x1a8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(424 as u32), ctx.r[31].u32 ) };
	// 82EB6254: 93EB0190  stw r31, 0x190(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(400 as u32), ctx.r[31].u32 ) };
	// 82EB6258: 93EB0194  stw r31, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[31].u32 ) };
	// 82EB625C: 910B0198  stw r8, 0x198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(408 as u32), ctx.r[8].u32 ) };
	// 82EB6260: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB6264: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB6268: 912B01B8  stw r9, 0x1b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), ctx.r[9].u32 ) };
	// 82EB626C: 912B01BC  stw r9, 0x1bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(444 as u32), ctx.r[9].u32 ) };
	// 82EB6270: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB6274: 4BDF31E4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB6278 size=152
    let mut pc: u32 = 0x82EB6278;
    'dispatch: loop {
        match pc {
            0x82EB6278 => {
    //   block [0x82EB6278..0x82EB6310)
	// 82EB6278: 8163019C  lwz r11, 0x19c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB627C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB6280: 38EB0014  addi r7, r11, 0x14
	ctx.r[7].s64 = ctx.r[11].s64 + 20;
	// 82EB6284: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6288: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 82EB628C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6290: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB6294: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 82EB6298: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB629C: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82EB62A0: C00A0004  lfs f0, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB62A4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB62A8: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB62AC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB62B0: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB62B4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB62B8: A0CA0010  lhz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB62BC: B0CB0010  sth r6, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u16 ) };
	// 82EB62C0: A14A0012  lhz r10, 0x12(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB62C4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB62C8: B14B0012  sth r10, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[10].u16 ) };
	// 82EB62CC: 41820024  beq 0x82eb62f0
	if ctx.cr[0].eq {
	pc = 0x82EB62F0; continue 'dispatch;
	}
	// 82EB62D0: 7D493850  subf r10, r9, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82EB62D4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB62D8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB62DC: 7CEA492E  stwx r7, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 82EB62E0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB62E4: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB62E8: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EB62EC: 4198FFE8  blt cr6, 0x82eb62d4
	if ctx.cr[6].lt {
	pc = 0x82EB62D4; continue 'dispatch;
	}
	// 82EB62F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB62F4: 914301A8  stw r10, 0x1a8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), ctx.r[10].u32 ) };
	// 82EB62F8: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB62FC: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 82EB6300: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6304: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB6308: 91630198  stw r11, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB630C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB6310 size=140
    let mut pc: u32 = 0x82EB6310;
    'dispatch: loop {
        match pc {
            0x82EB6310 => {
    //   block [0x82EB6310..0x82EB639C)
	// 82EB6310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB6314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB6318: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB631C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB6320: 90A301AC  stw r5, 0x1ac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(428 as u32), ctx.r[5].u32 ) };
	// 82EB6324: 48000050  b 0x82eb6374
	pc = 0x82EB6374; continue 'dispatch;
	// 82EB6328: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB632C: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB6330: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EB6334: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB6338: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB633C: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6340: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB6344: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB6348: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB634C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB6350: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EB6354: 409A0038  bne cr6, 0x82eb638c
	if !ctx.cr[6].eq {
	pc = 0x82EB638C; continue 'dispatch;
	}
	// 82EB6358: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB635C: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 * 12;
	// 82EB6360: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82EB6364: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB6368: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB636C: 91630194  stw r11, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EB6370: 91430198  stw r10, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[10].u32 ) };
	// 82EB6374: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB6378: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB637C: 4098FFAC  bge cr6, 0x82eb6328
	if !ctx.cr[6].lt {
	pc = 0x82EB6328; continue 'dispatch;
	}
	// 82EB6380: 4BFFFEF9  bl 0x82eb6278
	ctx.lr = 0x82EB6384;
	sub_82EB6278(ctx, base);
	// 82EB6384: 90A301A4  stw r5, 0x1a4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), ctx.r[5].u32 ) };
	// 82EB6388: 90A30194  stw r5, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[5].u32 ) };
	// 82EB638C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB6390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB6394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB6398: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB63A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB63A0 size=344
    let mut pc: u32 = 0x82EB63A0;
    'dispatch: loop {
        match pc {
            0x82EB63A0 => {
    //   block [0x82EB63A0..0x82EB64F8)
	// 82EB63A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB63A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB63A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB63AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB63B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB63B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB63B8: 817F01A8  lwz r11, 0x1a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EB63BC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EB63C0: 419A0120  beq cr6, 0x82eb64e0
	if ctx.cr[6].eq {
	pc = 0x82EB64E0; continue 'dispatch;
	}
	// 82EB63C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB63C8: 409A005C  bne cr6, 0x82eb6424
	if !ctx.cr[6].eq {
	pc = 0x82EB6424; continue 'dispatch;
	}
	// 82EB63CC: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB63D0: A1440010  lhz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB63D4: B14B0010  sth r10, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u16 ) };
	// 82EB63D8: A1440012  lhz r10, 0x12(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB63DC: B14B0012  sth r10, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[10].u16 ) };
	// 82EB63E0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB63E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB63E8: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB63EC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB63F0: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB63F4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB63F8: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB63FC: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6400: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6404: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6408: 418200B4  beq 0x82eb64bc
	if ctx.cr[0].eq {
	pc = 0x82EB64BC; continue 'dispatch;
	}
	// 82EB640C: A1440012  lhz r10, 0x12(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6410: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82EB6414: 38840014  addi r4, r4, 0x14
	ctx.r[4].s64 = ctx.r[4].s64 + 20;
	// 82EB6418: 5545103E  rotlwi r5, r10, 2
	ctx.r[5].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82EB641C: 4BDF3065  bl 0x82ca9480
	ctx.lr = 0x82EB6420;
	sub_82CA9480(ctx, base);
	// 82EB6420: 4800009C  b 0x82eb64bc
	pc = 0x82EB64BC; continue 'dispatch;
	// 82EB6424: 83DF0198  lwz r30, 0x198(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB6428: A1640010  lhz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB642C: B17E0010  sth r11, 0x10(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82EB6430: A1640012  lhz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6434: B17E0012  sth r11, 0x12(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB6438: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB643C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6440: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6444: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB6448: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB644C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB6450: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6454: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6458: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB645C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6460: 41820018  beq 0x82eb6478
	if ctx.cr[0].eq {
	pc = 0x82EB6478; continue 'dispatch;
	}
	// 82EB6464: A1640012  lhz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6468: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 82EB646C: 38840014  addi r4, r4, 0x14
	ctx.r[4].s64 = ctx.r[4].s64 + 20;
	// 82EB6470: 5565103E  rotlwi r5, r11, 2
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82EB6474: 4BDF300D  bl 0x82ca9480
	ctx.lr = 0x82EB6478;
	sub_82CA9480(ctx, base);
	// 82EB6478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB647C: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB6480: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EB6484: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EB6488: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EB648C: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB6490: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB6494: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB6498: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EB649C: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB64A0: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 * 12;
	// 82EB64A4: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EB64A8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82EB64AC: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB64B0: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB64B4: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 82EB64B8: 913F0190  stw r9, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[9].u32 ) };
	// 82EB64BC: 815F01A8  lwz r10, 0x1a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EB64C0: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB64C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB64C8: 915F01A8  stw r10, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[10].u32 ) };
	// 82EB64CC: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB64D0: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 82EB64D4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB64D8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB64DC: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB64E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB64E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB64E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB64EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB64F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB64F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB64F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB64F8 size=172
    let mut pc: u32 = 0x82EB64F8;
    'dispatch: loop {
        match pc {
            0x82EB64F8 => {
    //   block [0x82EB64F8..0x82EB65A4)
	// 82EB64F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB64FC: 4BDF2F11  bl 0x82ca940c
	ctx.lr = 0x82EB6500;
	sub_82CA93D0(ctx, base);
	// 82EB6500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB6508: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB650C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB6510: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EB6514: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EB6518: 4B760411  bl 0x82616928
	ctx.lr = 0x82EB651C;
	sub_82616928(ctx, base);
	// 82EB651C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EB6520: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB6524: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB6528: 4BDF3489  bl 0x82ca99b0
	ctx.lr = 0x82EB652C;
	sub_82CA99B0(ctx, base);
	// 82EB652C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6530: 93DF01A0  stw r30, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 82EB6534: 4B7603F5  bl 0x82616928
	ctx.lr = 0x82EB6538;
	sub_82616928(ctx, base);
	// 82EB6538: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EB653C: 80BF01A0  lwz r5, 0x1a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82EB6540: 907F019C  stw r3, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[3].u32 ) };
	// 82EB6544: 4BDF346D  bl 0x82ca99b0
	ctx.lr = 0x82EB6548;
	sub_82CA99B0(ctx, base);
	// 82EB6548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB654C: 93BF01C0  stw r29, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[29].u32 ) };
	// 82EB6550: 4B7603D9  bl 0x82616928
	ctx.lr = 0x82EB6554;
	sub_82616928(ctx, base);
	// 82EB6554: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EB6558: 80BF01C0  lwz r5, 0x1c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EB655C: 907F01B4  stw r3, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[3].u32 ) };
	// 82EB6560: 4BDF3451  bl 0x82ca99b0
	ctx.lr = 0x82EB6564;
	sub_82CA99B0(ctx, base);
	// 82EB6564: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB656C: 813F01B4  lwz r9, 0x1b4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB6570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6574: 811F019C  lwz r8, 0x19c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB6578: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82EB657C: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 82EB6580: 911F0198  stw r8, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[8].u32 ) };
	// 82EB6584: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 82EB6588: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EB658C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB6590: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB6594: 913F01B8  stw r9, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[9].u32 ) };
	// 82EB6598: 913F01BC  stw r9, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[9].u32 ) };
	// 82EB659C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB65A0: 4BDF2EBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB65A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB65A8 size=2420
    let mut pc: u32 = 0x82EB65A8;
    'dispatch: loop {
        match pc {
            0x82EB65A8 => {
    //   block [0x82EB65A8..0x82EB6F1C)
	// 82EB65A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB65AC: 4BDF2E25  bl 0x82ca93d0
	ctx.lr = 0x82EB65B0;
	sub_82CA93D0(ctx, base);
	// 82EB65B0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB65B4: 4BDF7725  bl 0x82cadcd8
	ctx.lr = 0x82EB65B8;
	sub_82CADCA0(ctx, base);
	// 82EB65B8: 9421FD20  stwu r1, -0x2e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-736 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB65BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB65C0: 90E10314  stw r7, 0x314(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(788 as u32), ctx.r[7].u32 ) };
	// 82EB65C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB65C8: 9101031C  stw r8, 0x31c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(796 as u32), ctx.r[8].u32 ) };
	// 82EB65CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB65D0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EB65D4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82EB65D8: 4801D2D1  bl 0x82ed38a8
	ctx.lr = 0x82EB65DC;
	sub_82ED38A8(ctx, base);
	// 82EB65DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB65E0: 40820874  bne 0x82eb6e54
	if !ctx.cr[0].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB65E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB65E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB65EC: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 82EB65F0: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB65F4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB65F8: C3CB0C18  lfs f30, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB65FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6600: 93BF0074  stw r29, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82EB6604: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EB6608: 93BF0078  stw r29, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82EB660C: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6610: 816B9E3C  lwz r11, -0x61c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB6614: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6618: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB661C: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6620: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6624: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6628: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB662C: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6630: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6634: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82EB6638: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB663C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6640: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6644: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6648: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EB664C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6650: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6654: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6658: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB665C: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6660: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6664: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6668: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB666C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6670: D3CB0014  stfs f30, 0x14(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB6674: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EB6678: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB667C: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB6680: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB6684: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6688: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82EB668C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6690: C1780004  lfs f11, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB6694: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB6698: C1580008  lfs f10, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB669C: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB66A0: C138000C  lfs f9, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB66A4: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB66A8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB66AC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB66B0: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB66B4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB66B8: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB66BC: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB66C0: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB66C4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB66C8: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB66CC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB66D0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB66D4: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB66D8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB66DC: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB66E0: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB66E4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB66E8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB66EC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB66F0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB66F4: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB66F8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB66FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB6700: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EB6704: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6708: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB670C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EB6710: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB6714: 3A6B9128  addi r19, r11, -0x6ed8
	ctx.r[19].s64 = ctx.r[11].s64 + -28376;
	// 82EB6718: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB671C: 3B2B9128  addi r25, r11, -0x6ed8
	ctx.r[25].s64 = ctx.r[11].s64 + -28376;
	// 82EB6720: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB6724: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EB6728: C38A0BEC  lfs f28, 0xbec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EB672C: 3A4B9F1C  addi r18, r11, -0x60e4
	ctx.r[18].s64 = ctx.r[11].s64 + -24804;
	// 82EB6730: C3A90C98  lfs f29, 0xc98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3224 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB6734: 3DC08330  lis r14, -0x7cd0
	ctx.r[14].s64 = -2094006272;
	// 82EB6738: 3A80FFFF  li r20, -1
	ctx.r[20].s64 = -1;
	// 82EB673C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6740: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6744: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EB6748: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 82EB674C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6750: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB6754: 816A9E58  lwz r11, -0x61a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25000 as u32) ) } as u64;
	// 82EB6758: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 82EB675C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6760: 916A9E58  stw r11, -0x61a8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25000 as u32), ctx.r[11].u32 ) };
	// 82EB6764: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EB6768: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB676C: 40990044  ble cr6, 0x82eb67b0
	if !ctx.cr[6].gt {
	pc = 0x82EB67B0; continue 'dispatch;
	}
	// 82EB6770: 5527003E  slwi r7, r9, 0
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EB6774: 813A9E40  lwz r9, -0x61c0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6778: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB677C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EB6780: 419A0020  beq cr6, 0x82eb67a0
	if ctx.cr[6].eq {
	pc = 0x82EB67A0; continue 'dispatch;
	}
	// 82EB6784: 54C6003E  slwi r6, r6, 0
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EB6788: C1A6000C  lfs f13, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB678C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB6790: 40980010  bge cr6, 0x82eb67a0
	if !ctx.cr[6].lt {
	pc = 0x82EB67A0; continue 'dispatch;
	}
	// 82EB6794: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EB6798: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB679C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EB67A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB67A4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB67A8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EB67AC: 4198FFCC  blt cr6, 0x82eb6778
	if ctx.cr[6].lt {
	pc = 0x82EB6778; continue 'dispatch;
	}
	// 82EB67B0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB67B4: 418206A0  beq 0x82eb6e54
	if ctx.cr[0].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB67B8: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB67BC: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB67C0: 7EAB502E  lwzx r21, r11, r10
	ctx.r[21].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB67C4: 7FAB512E  stwx r29, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 82EB67C8: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB67CC: 7E0B5214  add r16, r11, r10
	ctx.r[16].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB67D0: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67D4: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB67D8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB67DC: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB67E0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB67E4: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67E8: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67F0: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82EB67F4: 556B007F  clrlwi. r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB67F8: 41820670  beq 0x82eb6e68
	if ctx.cr[0].eq {
	pc = 0x82EB6E68; continue 'dispatch;
	}
	// 82EB67FC: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82EB6800: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EB6804: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 82EB6808: 93A1008C  stw r29, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 82EB680C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82EB6810: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82EB6814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6818: 4801DA29  bl 0x82ed4240
	ctx.lr = 0x82EB681C;
	sub_82ED4240(ctx, base);
	// 82EB681C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6820: 7FAFEB78  mr r15, r29
	ctx.r[15].u64 = ctx.r[29].u64;
	// 82EB6824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6828: 419A05AC  beq cr6, 0x82eb6dd4
	if ctx.cr[6].eq {
	pc = 0x82EB6DD4; continue 'dispatch;
	}
	// 82EB682C: 7FB1EB78  mr r17, r29
	ctx.r[17].u64 = ctx.r[29].u64;
	// 82EB6830: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB6834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB6838: 7EF1582E  lwzx r23, r17, r11
	ctx.r[23].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB683C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB6840: 7ED1582E  lwzx r22, r17, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6844: D3C10088  stfs f30, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB6848: 8161031C  lwz r11, 0x31c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(796 as u32) ) } as u64;
	// 82EB684C: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EB6850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6854: 92DE000C  stw r22, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[22].u32 ) };
	// 82EB6858: 409A0188  bne cr6, 0x82eb69e0
	if !ctx.cr[6].eq {
	pc = 0x82EB69E0; continue 'dispatch;
	}
	// 82EB685C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6860: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 82EB6864: 556B0FFF  rlwinm. r11, r11, 1, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6868: 41820178  beq 0x82eb69e0
	if ctx.cr[0].eq {
	pc = 0x82EB69E0; continue 'dispatch;
	}
	// 82EB686C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6870: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB6874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6878: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB687C: 4801E095  bl 0x82ed4910
	ctx.lr = 0x82EB6880;
	sub_82ED4910(ctx, base);
	// 82EB6880: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6884: 41820538  beq 0x82eb6dbc
	if ctx.cr[0].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB688C: 4801DF05  bl 0x82ed4790
	ctx.lr = 0x82EB6890;
	sub_82ED4790(ctx, base);
	// 82EB6890: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EB6894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6898: 4BFE39B1  bl 0x82e9a248
	ctx.lr = 0x82EB689C;
	sub_82E9A248(ctx, base);
	// 82EB689C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB68A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB68A4: 4BFE3A25  bl 0x82e9a2c8
	ctx.lr = 0x82EB68A8;
	sub_82E9A2C8(ctx, base);
	// 82EB68A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB68AC: 92810084  stw r20, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[20].u32 ) };
	// 82EB68B0: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82EB68B4: 9281005C  stw r20, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[20].u32 ) };
	// 82EB68B8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB68BC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB68C0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB68C4: 92410080  stw r18, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[18].u32 ) };
	// 82EB68C8: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 82EB68CC: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB68D0: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB68D4: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB68D8: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 82EB68DC: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB68E0: 926100A0  stw r19, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[19].u32 ) };
	// 82EB68E4: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB68E8: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82EB68EC: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB68F0: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EB68F4: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB68F8: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EB68FC: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6900: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EB6904: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6908: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB690C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB6910: 4200FFF8  bdnz 0x82eb6908
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6908; continue 'dispatch;
	}
	// 82EB6914: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EB6918: 9BA100F8  stb r29, 0xf8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[29].u8 ) };
	// 82EB691C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EB6920: 4B2F7D89  bl 0x821ae6a8
	ctx.lr = 0x82EB6924;
	sub_821AE6A8(ctx, base);
	// 82EB6924: 92610160  stw r19, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[19].u32 ) };
	// 82EB6928: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB692C: 39410170  addi r10, r1, 0x170
	ctx.r[10].s64 = ctx.r[1].s64 + 368;
	// 82EB6930: D0010164  stfs f0, 0x164(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82EB6934: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB6938: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB693C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB6940: D0010168  stfs f0, 0x168(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82EB6944: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6948: D001016C  stfs f0, 0x16c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82EB694C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6950: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB6954: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB6958: 4200FFF8  bdnz 0x82eb6950
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6950; continue 'dispatch;
	}
	// 82EB695C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EB6960: 9BA101B8  stb r29, 0x1b8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[29].u8 ) };
	// 82EB6964: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82EB6968: 4B2F7D41  bl 0x821ae6a8
	ctx.lr = 0x82EB696C;
	sub_821AE6A8(ctx, base);
	// 82EB696C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6970: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6974: 39010088  addi r8, r1, 0x88
	ctx.r[8].s64 = ctx.r[1].s64 + 136;
	// 82EB6978: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB697C: 38C10160  addi r6, r1, 0x160
	ctx.r[6].s64 = ctx.r[1].s64 + 352;
	// 82EB6980: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82EB6984: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB6988: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB698C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6994: 4E800421  bctrl
	ctx.lr = 0x82EB6998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB6998: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB699C: 4082002C  bne 0x82eb69c8
	if !ctx.cr[0].eq {
	pc = 0x82EB69C8; continue 'dispatch;
	}
	// 82EB69A0: 897F007E  lbz r11, 0x7e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(126 as u32) ) } as u64;
	// 82EB69A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB69A8: 41820020  beq 0x82eb69c8
	if ctx.cr[0].eq {
	pc = 0x82EB69C8; continue 'dispatch;
	}
	// 82EB69AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB69B0: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82EB69B4: 91610160  stw r11, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82EB69B8: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EB69BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB69C0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB69C4: 480003F8  b 0x82eb6dbc
	pc = 0x82EB6DBC; continue 'dispatch;
	// 82EB69C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB69CC: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82EB69D0: 91610160  stw r11, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82EB69D4: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EB69D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB69DC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB69E0: C3F50014  lfs f31, 0x14(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB69E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB69E8: 41820010  beq 0x82eb69f8
	if ctx.cr[0].eq {
	pc = 0x82EB69F8; continue 'dispatch;
	}
	// 82EB69EC: C0010088  lfs f0, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB69F0: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB69F4: 48000188  b 0x82eb6b7c
	pc = 0x82EB6B7C; continue 'dispatch;
	// 82EB69F8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB69FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6A00: 419A015C  beq cr6, 0x82eb6b5c
	if ctx.cr[6].eq {
	pc = 0x82EB6B5C; continue 'dispatch;
	}
	// 82EB6A04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A08: D3C10078  stfs f30, 0x78(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EB6A0C: 4BFE383D  bl 0x82e9a248
	ctx.lr = 0x82EB6A10;
	sub_82E9A248(ctx, base);
	// 82EB6A10: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB6A14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A18: 4BFE38B1  bl 0x82e9a2c8
	ctx.lr = 0x82EB6A1C;
	sub_82E9A2C8(ctx, base);
	// 82EB6A1C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB6A20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A24: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EB6A28: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 82EB6A2C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6A30: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	// 82EB6A34: 4801CDFD  bl 0x82ed3830
	ctx.lr = 0x82EB6A38;
	sub_82ED3830(ctx, base);
	// 82EB6A38: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6A3C: 392101D0  addi r9, r1, 0x1d0
	ctx.r[9].s64 = ctx.r[1].s64 + 464;
	// 82EB6A40: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EB6A44: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6A48: 926101C0  stw r19, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[19].u32 ) };
	// 82EB6A4C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB6A50: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6A54: D00101C4  stfs f0, 0x1c4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB6A58: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6A5C: D00101C8  stfs f0, 0x1c8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 82EB6A60: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6A64: D00101CC  stfs f0, 0x1cc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 82EB6A68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB6A6C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB6A70: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB6A74: 4200FFF8  bdnz 0x82eb6a6c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6A6C; continue 'dispatch;
	}
	// 82EB6A78: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EB6A7C: 9BA10218  stb r29, 0x218(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), ctx.r[29].u8 ) };
	// 82EB6A80: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 82EB6A84: 4B2F7C25  bl 0x821ae6a8
	ctx.lr = 0x82EB6A88;
	sub_821AE6A8(ctx, base);
	// 82EB6A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A8C: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 82EB6A90: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB6A94: 92810064  stw r20, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u32 ) };
	// 82EB6A98: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6A9C: 4801CD95  bl 0x82ed3830
	ctx.lr = 0x82EB6AA0;
	sub_82ED3830(ctx, base);
	// 82EB6AA0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6AA4: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 82EB6AA8: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EB6AAC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6AB0: 92610100  stw r19, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[19].u32 ) };
	// 82EB6AB4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB6AB8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6ABC: D0010104  stfs f0, 0x104(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB6AC0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6AC4: D0010108  stfs f0, 0x108(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB6AC8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6ACC: D001010C  stfs f0, 0x10c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB6AD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB6AD4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB6AD8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB6ADC: 4200FFF8  bdnz 0x82eb6ad4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6AD4; continue 'dispatch;
	}
	// 82EB6AE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB6AE4: 9BA10158  stb r29, 0x158(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[29].u8 ) };
	// 82EB6AE8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82EB6AEC: 4B2F7BBD  bl 0x821ae6a8
	ctx.lr = 0x82EB6AF0;
	sub_821AE6A8(ctx, base);
	// 82EB6AF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6AF4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB6AF8: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 82EB6AFC: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 82EB6B00: 38A101C0  addi r5, r1, 0x1c0
	ctx.r[5].s64 = ctx.r[1].s64 + 448;
	// 82EB6B04: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6B08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6B0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB6B10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6B14: 4E800421  bctrl
	ctx.lr = 0x82EB6B18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB6B18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6B1C: 40820024  bne 0x82eb6b40
	if !ctx.cr[0].eq {
	pc = 0x82EB6B40; continue 'dispatch;
	}
	// 82EB6B20: 897F007F  lbz r11, 0x7f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(127 as u32) ) } as u64;
	// 82EB6B24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6B28: 41820018  beq 0x82eb6b40
	if ctx.cr[0].eq {
	pc = 0x82EB6B40; continue 'dispatch;
	}
	// 82EB6B2C: 93210100  stw r25, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[25].u32 ) };
	// 82EB6B30: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 82EB6B34: 932101C0  stw r25, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[25].u32 ) };
	// 82EB6B38: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82EB6B3C: 48000280  b 0x82eb6dbc
	pc = 0x82EB6DBC; continue 'dispatch;
	// 82EB6B40: C0010078  lfs f0, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6B44: 93210100  stw r25, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[25].u32 ) };
	// 82EB6B48: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB6B4C: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 82EB6B50: 932101C0  stw r25, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[25].u32 ) };
	// 82EB6B54: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82EB6B58: 48000024  b 0x82eb6b7c
	pc = 0x82EB6B7C; continue 'dispatch;
	// 82EB6B5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6B60: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82EB6B64: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB6B68: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 82EB6B6C: C8010098  lfd f0, 0x98(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82EB6B70: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EB6B74: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EB6B78: EFE0FF7A  fmadds f31, f0, f29, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EB6B7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6B80: 4BFE37C9  bl 0x82e9a348
	ctx.lr = 0x82EB6B84;
	sub_82E9A348(ctx, base);
	// 82EB6B84: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6B88: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6B8C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB6B90: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6B94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB6B98: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6B9C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB6BA0: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6BA8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BAC: 5565007E  clrlwi r5, r11, 1
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB6BB0: 40990060  ble cr6, 0x82eb6c10
	if !ctx.cr[6].gt {
	pc = 0x82EB6C10; continue 'dispatch;
	}
	// 82EB6BB4: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6BB8: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB6BBC: 40820054  bne 0x82eb6c10
	if !ctx.cr[0].eq {
	pc = 0x82EB6C10; continue 'dispatch;
	}
	// 82EB6BC0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB6BC8: 419A0034  beq cr6, 0x82eb6bfc
	if ctx.cr[6].eq {
	pc = 0x82EB6BFC; continue 'dispatch;
	}
	// 82EB6BCC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6BD0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BD4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BD8: 554A007E  clrlwi r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB6BDC: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB6BE0: 409A001C  bne cr6, 0x82eb6bfc
	if !ctx.cr[6].eq {
	pc = 0x82EB6BFC; continue 'dispatch;
	}
	// 82EB6BE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BE8: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EB6BEC: C00A0014  lfs f0, 0x14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6BF0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB6BF4: 41990008  bgt cr6, 0x82eb6bfc
	if ctx.cr[6].gt {
	pc = 0x82EB6BFC; continue 'dispatch;
	}
	// 82EB6BF8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB6BFC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6C00: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB6C04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB6C08: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6C0C: 4198FFAC  blt cr6, 0x82eb6bb8
	if ctx.cr[6].lt {
	pc = 0x82EB6BB8; continue 'dispatch;
	}
	// 82EB6C10: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6C14: 408201A8  bne 0x82eb6dbc
	if !ctx.cr[0].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6C18: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6C1C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EB6C20: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6C28: 40990060  ble cr6, 0x82eb6c88
	if !ctx.cr[6].gt {
	pc = 0x82EB6C88; continue 'dispatch;
	}
	// 82EB6C2C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6C30: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6C34: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB6C38: 40820050  bne 0x82eb6c88
	if !ctx.cr[0].eq {
	pc = 0x82EB6C88; continue 'dispatch;
	}
	// 82EB6C3C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6C40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB6C44: 419A0030  beq cr6, 0x82eb6c74
	if ctx.cr[6].eq {
	pc = 0x82EB6C74; continue 'dispatch;
	}
	// 82EB6C48: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6C4C: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6C50: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6C54: 5463007E  clrlwi r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB6C58: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB6C5C: 409A0018  bne cr6, 0x82eb6c74
	if !ctx.cr[6].eq {
	pc = 0x82EB6C74; continue 'dispatch;
	}
	// 82EB6C60: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6C64: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EB6C68: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB6C6C: 41990008  bgt cr6, 0x82eb6c74
	if ctx.cr[6].gt {
	pc = 0x82EB6C74; continue 'dispatch;
	}
	// 82EB6C70: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB6C74: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6C78: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB6C7C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB6C80: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6C84: 4198FFB0  blt cr6, 0x82eb6c34
	if ctx.cr[6].lt {
	pc = 0x82EB6C34; continue 'dispatch;
	}
	// 82EB6C88: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6C8C: 40820130  bne 0x82eb6dbc
	if !ctx.cr[0].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6C90: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB6C94: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB6C98: 1D0B001C  mulli r8, r11, 0x1c
	ctx.r[8].s64 = ctx.r[11].s64 * 28;
	// 82EB6C9C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6CA0: 816B9E3C  lwz r11, -0x61c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB6CA4: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB6CA8: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EB6CAC: 810EDF34  lwz r8, -0x20cc(r14)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB6CB0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB6CB4: 419A01A0  beq cr6, 0x82eb6e54
	if ctx.cr[6].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB6CB8: D3EB0014  stfs f31, 0x14(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB6CBC: 92AB0018  stw r21, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[21].u32 ) };
	// 82EB6CC0: 92CB0004  stw r22, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 82EB6CC4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EB6CC8: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EB6CCC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6CD0: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB6CD4: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB6CD8: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6CDC: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82EB6CE0: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6CE4: C1780004  lfs f11, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB6CE8: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB6CEC: C1580008  lfs f10, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB6CF0: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB6CF4: C138000C  lfs f9, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB6CF8: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB6CFC: C10B0014  lfs f8, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB6D00: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB6D04: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82EB6D08: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB6D0C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB6D10: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB6D14: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB6D18: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB6D1C: EDA0402A  fadds f13, f0, f8
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EB6D20: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6D24: 419A0008  beq cr6, 0x82eb6d2c
	if ctx.cr[6].eq {
	pc = 0x82EB6D2C; continue 'dispatch;
	}
	// 82EB6D28: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EB6D2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D30: 409A008C  bne cr6, 0x82eb6dbc
	if !ctx.cr[6].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6D34: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D38: 419A0010  beq cr6, 0x82eb6d48
	if ctx.cr[6].eq {
	pc = 0x82EB6D48; continue 'dispatch;
	}
	// 82EB6D3C: 91700000  stw r11, 0(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6D40: 7FB0EB78  mr r16, r29
	ctx.r[16].u64 = ctx.r[29].u64;
	// 82EB6D44: 48000078  b 0x82eb6dbc
	pc = 0x82EB6DBC; continue 'dispatch;
	// 82EB6D48: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6D4C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EB6D50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D54: 40990038  ble cr6, 0x82eb6d8c
	if !ctx.cr[6].gt {
	pc = 0x82EB6D8C; continue 'dispatch;
	}
	// 82EB6D58: 813A9E40  lwz r9, -0x61c0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6D5C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6D60: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D64: 419A001C  beq cr6, 0x82eb6d80
	if ctx.cr[6].eq {
	pc = 0x82EB6D80; continue 'dispatch;
	}
	// 82EB6D68: 811F0074  lwz r8, 0x74(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6D6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB6D70: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB6D74: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB6D78: 4198FFE4  blt cr6, 0x82eb6d5c
	if ctx.cr[6].lt {
	pc = 0x82EB6D5C; continue 'dispatch;
	}
	// 82EB6D7C: 48000010  b 0x82eb6d8c
	pc = 0x82EB6D8C; continue 'dispatch;
	// 82EB6D80: 811A9E40  lwz r8, -0x61c0(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6D84: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB6D88: 7D69412E  stwx r11, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 82EB6D8C: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6D90: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB6D94: 41980028  blt cr6, 0x82eb6dbc
	if ctx.cr[6].lt {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6D98: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB6D9C: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EB6DA0: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82EB6DA4: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6DA8: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EB6DAC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6DB0: 816EDF34  lwz r11, -0x20cc(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB6DB4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6DB8: 419A009C  beq cr6, 0x82eb6e54
	if ctx.cr[6].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB6DBC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6DC0: 39EF0001  addi r15, r15, 1
	ctx.r[15].s64 = ctx.r[15].s64 + 1;
	// 82EB6DC4: 3A310004  addi r17, r17, 4
	ctx.r[17].s64 = ctx.r[17].s64 + 4;
	// 82EB6DC8: 7F0F5840  cmplw cr6, r15, r11
	ctx.cr[6].compare_u32(ctx.r[15].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6DCC: 4198FA64  blt cr6, 0x82eb6830
	if ctx.cr[6].lt {
	pc = 0x82EB6830; continue 'dispatch;
	}
	// 82EB6DD0: 83610090  lwz r27, 0x90(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB6DD4: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6DD8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB6DDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB6DE0: 40990040  ble cr6, 0x82eb6e20
	if !ctx.cr[6].gt {
	pc = 0x82EB6E20; continue 'dispatch;
	}
	// 82EB6DE4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6DE8: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6DEC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6DF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB6DF4: 419A001C  beq cr6, 0x82eb6e10
	if ctx.cr[6].eq {
	pc = 0x82EB6E10; continue 'dispatch;
	}
	// 82EB6DF8: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6DFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6E00: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB6E04: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB6E08: 4198FFE4  blt cr6, 0x82eb6dec
	if ctx.cr[6].lt {
	pc = 0x82EB6DEC; continue 'dispatch;
	}
	// 82EB6E0C: 48000014  b 0x82eb6e20
	pc = 0x82EB6E20; continue 'dispatch;
	// 82EB6E10: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6E14: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB6E18: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6E1C: 7EA9512E  stwx r21, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[21].u32) };
	// 82EB6E20: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6E24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6E28: 4198F914  blt cr6, 0x82eb673c
	if ctx.cr[6].lt {
	pc = 0x82EB673C; continue 'dispatch;
	}
	// 82EB6E2C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6E30: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6E34: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6E38: 7EAA592E  stwx r21, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[21].u32) };
	// 82EB6E3C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6E40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6E44: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB6E48: 814EDF34  lwz r10, -0x20cc(r14)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB6E4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6E50: 409AF8EC  bne cr6, 0x82eb673c
	if !ctx.cr[6].eq {
	pc = 0x82EB673C; continue 'dispatch;
	}
	// 82EB6E54: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EB6E58: 382102E0  addi r1, r1, 0x2e0
	ctx.r[1].s64 = ctx.r[1].s64 + 736;
	// 82EB6E5C: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB6E60: 4BDF6EC5  bl 0x82cadd24
	ctx.lr = 0x82EB6E64;
	sub_82CADCEC(ctx, base);
	// 82EB6E64: 4BDF25BC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
	// 82EB6E68: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB6E6C: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 82EB6E70: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB6E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6E78: 419A0020  beq cr6, 0x82eb6e98
	if ctx.cr[6].eq {
	pc = 0x82EB6E98; continue 'dispatch;
	}
	// 82EB6E7C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB6E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6E84: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EB6E88: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6E8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6E90: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6E94: 4801D9B5  bl 0x82ed4848
	ctx.lr = 0x82EB6E98;
	sub_82ED4848(ctx, base);
	// 82EB6E98: 839C0018  lwz r28, 0x18(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB6E9C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EB6EA0: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6EA4: 4082FFCC  bne 0x82eb6e70
	if !ctx.cr[0].eq {
	pc = 0x82EB6E70; continue 'dispatch;
	}
	// 82EB6EA8: 83A10314  lwz r29, 0x314(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(788 as u32) ) } as u64;
	// 82EB6EAC: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 82EB6EB0: 409A0018  bne cr6, 0x82eb6ec8
	if !ctx.cr[6].eq {
	pc = 0x82EB6EC8; continue 'dispatch;
	}
	// 82EB6EB4: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 82EB6EB8: 80C1031C  lwz r6, 0x31c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(796 as u32) ) } as u64;
	// 82EB6EBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB6EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6EC4: 4BFFF00D  bl 0x82eb5ed0
	ctx.lr = 0x82EB6EC8;
	sub_82EB5ED0(ctx, base);
	// 82EB6EC8: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 82EB6ECC: 409A0048  bne cr6, 0x82eb6f14
	if !ctx.cr[6].eq {
	pc = 0x82EB6F14; continue 'dispatch;
	}
	// 82EB6ED0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6ED4: 395B0004  addi r10, r27, 4
	ctx.r[10].s64 = ctx.r[27].s64 + 4;
	// 82EB6ED8: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 * 24;
	// 82EB6EDC: 816B01A0  lwz r11, 0x1a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 82EB6EE0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6EE4: 4198001C  blt cr6, 0x82eb6f00
	if ctx.cr[6].lt {
	pc = 0x82EB6F00; continue 'dispatch;
	}
	// 82EB6EE8: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82EB6EEC: 80810090  lwz r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB6EF0: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB6EF4: 4BFD4DE5  bl 0x82e8bcd8
	ctx.lr = 0x82EB6EF8;
	sub_82E8BCD8(ctx, base);
	// 82EB6EF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6EFC: 4BFFFF5C  b 0x82eb6e58
	pc = 0x82EB6E58; continue 'dispatch;
	// 82EB6F00: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 82EB6F04: 80C1031C  lwz r6, 0x31c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(796 as u32) ) } as u64;
	// 82EB6F08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB6F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6F10: 4BFFEE89  bl 0x82eb5d98
	ctx.lr = 0x82EB6F14;
	sub_82EB5D98(ctx, base);
	// 82EB6F14: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82EB6F18: 4BFFFFD4  b 0x82eb6eec
	pc = 0x82EB6EEC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB6F20 size=3164
    let mut pc: u32 = 0x82EB6F20;
    'dispatch: loop {
        match pc {
            0x82EB6F20 => {
    //   block [0x82EB6F20..0x82EB7B7C)
	// 82EB6F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB6F24: 4BDF24AD  bl 0x82ca93d0
	ctx.lr = 0x82EB6F28;
	sub_82CA93D0(ctx, base);
	// 82EB6F28: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB6F2C: 4BDF6D9D  bl 0x82cadcc8
	ctx.lr = 0x82EB6F30;
	sub_82CADCA0(ctx, base);
	// 82EB6F30: 9421FCE0  stwu r1, -0x320(r1)
	ea = ctx.r[1].u32.wrapping_add(-800 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6F34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB6F38: 90E10354  stw r7, 0x354(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(852 as u32), ctx.r[7].u32 ) };
	// 82EB6F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB6F40: 9101035C  stw r8, 0x35c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(860 as u32), ctx.r[8].u32 ) };
	// 82EB6F44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6F48: 91210364  stw r9, 0x364(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(868 as u32), ctx.r[9].u32 ) };
	// 82EB6F4C: 7CAE2B78  mr r14, r5
	ctx.r[14].u64 = ctx.r[5].u64;
	// 82EB6F50: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 82EB6F54: 4801C955  bl 0x82ed38a8
	ctx.lr = 0x82EB6F58;
	sub_82ED38A8(ctx, base);
	// 82EB6F58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB6F5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6F60: 41820030  beq 0x82eb6f90
	if ctx.cr[0].eq {
	pc = 0x82EB6F90; continue 'dispatch;
	}
	// 82EB6F64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB6F68: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6F6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB6F70: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB6F74: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6F78: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB6F7C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6F80: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB6F84: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6F88: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB6F8C: 48000A58  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
	// 82EB6F90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6F94: 3D008335  lis r8, -0x7ccb
	ctx.r[8].s64 = -2093678592;
	// 82EB6F98: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB6F9C: 3CE08335  lis r7, -0x7ccb
	ctx.r[7].s64 = -2093678592;
	// 82EB6FA0: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 82EB6FA4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6FA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6FAC: 816B9E48  lwz r11, -0x61b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25016 as u32) ) } as u64;
	// 82EB6FB0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6FB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB6FB8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6FBC: C3CB0C18  lfs f30, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB6FC0: 409A002C  bne cr6, 0x82eb6fec
	if !ctx.cr[6].eq {
	pc = 0x82EB6FEC; continue 'dispatch;
	}
	// 82EB6FC4: 81699E4C  lwz r11, -0x61b4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25012 as u32) ) } as u64;
	// 82EB6FC8: 7F0B7040  cmplw cr6, r11, r14
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[14].u32, &mut ctx.xer);
	// 82EB6FCC: 409A0020  bne cr6, 0x82eb6fec
	if !ctx.cr[6].eq {
	pc = 0x82EB6FEC; continue 'dispatch;
	}
	// 82EB6FD0: 81689E50  lwz r11, -0x61b0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25008 as u32) ) } as u64;
	// 82EB6FD4: 7F0BA040  cmplw cr6, r11, r20
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[20].u32, &mut ctx.xer);
	// 82EB6FD8: 409A0014  bne cr6, 0x82eb6fec
	if !ctx.cr[6].eq {
	pc = 0x82EB6FEC; continue 'dispatch;
	}
	// 82EB6FDC: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB6FE0: 81679E54  lwz r11, -0x61ac(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-25004 as u32) ) } as u64;
	// 82EB6FE4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB6FE8: 419A0110  beq cr6, 0x82eb70f8
	if ctx.cr[6].eq {
	pc = 0x82EB70F8; continue 'dispatch;
	}
	// 82EB6FEC: 93BF0074  stw r29, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82EB6FF0: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EB6FF4: 93BF0078  stw r29, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82EB6FF8: 816A9E3C  lwz r11, -0x61c4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB6FFC: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7000: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB7004: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB7008: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB700C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7010: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7014: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB7018: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB701C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7020: 91CB0000  stw r14, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	// 82EB7024: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7028: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB702C: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7030: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7034: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EB7038: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB703C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7040: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7044: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7048: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB704C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7050: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7054: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7058: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB705C: D3CB0014  stfs f30, 0x14(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB7060: 91DE0004  stw r14, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[14].u32 ) };
	// 82EB7064: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7068: C1AE0004  lfs f13, 4(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB706C: C18E0008  lfs f12, 8(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB7070: C00E000C  lfs f0, 0xc(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7074: 929E0004  stw r20, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 82EB7078: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB707C: C1740004  lfs f11, 4(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB7080: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB7084: C1540008  lfs f10, 8(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB7088: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB708C: C134000C  lfs f9, 0xc(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB7090: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB7094: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7098: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB709C: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB70A0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB70A4: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB70A8: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB70AC: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB70B0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB70B4: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB70B8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB70BC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB70C0: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB70C4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB70C8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB70CC: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB70D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB70D4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB70D8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB70DC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB70E0: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB70E4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB70E8: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EB70EC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB70F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB70F4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EB70F8: 839F0194  lwz r28, 0x194(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB70FC: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82EB7100: 4B3A98B9  bl 0x822609b8
	ctx.lr = 0x82EB7104;
	sub_822609B8(ctx, base);
	// 82EB7104: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB7108: 4BFCA411  bl 0x82e81518
	ctx.lr = 0x82EB710C;
	sub_82E81518(ctx, base);
	// 82EB710C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB7110: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82EB7114: 3AEBDAC0  addi r23, r11, -0x2540
	ctx.r[23].s64 = ctx.r[11].s64 + -9536;
	// 82EB7118: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB711C: 92E100A0  stw r23, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[23].u32 ) };
	// 82EB7120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7124: 419A0018  beq cr6, 0x82eb713c
	if ctx.cr[6].eq {
	pc = 0x82EB713C; continue 'dispatch;
	}
	// 82EB7128: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB712C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7130: 4E800421  bctrl
	ctx.lr = 0x82EB7134;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB7134: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82EB7138: 48000008  b 0x82eb7140
	pc = 0x82EB7140; continue 'dispatch;
	// 82EB713C: FF80F090  fmr f28, f30
	ctx.f[28].f64 = ctx.f[30].f64;
	// 82EB7140: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB7144: 815F0444  lwz r10, 0x444(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) } as u64;
	// 82EB7148: C1BF044C  lfs f13, 0x44c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB714C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82EB7150: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB7154: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB7158: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82EB715C: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7160: F9410098  std r10, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u64 ) };
	// 82EB7164: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB7168: C9A10098  lfd f13, 0x98(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82EB716C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EB7170: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EB7174: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB7178: C3490BFC  lfs f26, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EB717C: C3080BEC  lfs f24, 0xbec(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3052 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EB7180: 3AA0FFFF  li r21, -1
	ctx.r[21].s64 = -1;
	// 82EB7184: C3270C98  lfs f25, 0xc98(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3224 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EB7188: C36A0C14  lfs f27, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EB718C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EB7190: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB7194: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EB7198: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EB719C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB71A0: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB71A4: 3A4B9128  addi r18, r11, -0x6ed8
	ctx.r[18].s64 = ctx.r[11].s64 + -28376;
	// 82EB71A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB71AC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB71B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB71B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB71B8: 3A2B9F1C  addi r17, r11, -0x60e4
	ctx.r[17].s64 = ctx.r[11].s64 + -24804;
	// 82EB71BC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB71C0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EB71C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB71C8: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EB71CC: 816A9E58  lwz r11, -0x61a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25000 as u32) ) } as u64;
	// 82EB71D0: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82EB71D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB71D8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EB71DC: 916A9E58  stw r11, -0x61a8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25000 as u32), ctx.r[11].u32 ) };
	// 82EB71E0: 409900B4  ble cr6, 0x82eb7294
	if !ctx.cr[6].gt {
	pc = 0x82EB7294; continue 'dispatch;
	}
	// 82EB71E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB71E8: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB71EC: 4BFD4AED  bl 0x82e8bcd8
	ctx.lr = 0x82EB71F0;
	sub_82E8BCD8(ctx, base);
	// 82EB71F0: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB71F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB71F8: 419A0014  beq cr6, 0x82eb720c
	if ctx.cr[6].eq {
	pc = 0x82EB720C; continue 'dispatch;
	}
	// 82EB71FC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB7200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7204: 4E800421  bctrl
	ctx.lr = 0x82EB7208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB7208: 48000008  b 0x82eb7210
	pc = 0x82EB7210; continue 'dispatch;
	// 82EB720C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EB7210: EC01E028  fsubs f0, f1, f28
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EB7214: EFBD0028  fsubs f29, f29, f0
	ctx.f[29].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB7218: FF1DF000  fcmpu cr6, f29, f30
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[30].f64);
	// 82EB721C: 409907D8  ble cr6, 0x82eb79f4
	if !ctx.cr[6].gt {
	pc = 0x82EB79F4; continue 'dispatch;
	}
	// 82EB7220: 7B6A0020  clrldi r10, r27, 0x20
	ctx.r[10].u64 = ctx.r[27].u64 & 0x00000000FFFFFFFFu64;
	// 82EB7224: C1BF044C  lfs f13, 0x44c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB7228: EDBB6828  fsubs f13, f27, f13
	ctx.f[13].f64 = (((ctx.f[27].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB722C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EB7230: 817F0448  lwz r11, 0x448(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82EB7234: F94100A8  std r10, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[10].u64 ) };
	// 82EB7238: EDADD82A  fadds f13, f13, f27
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[27].f64) as f32) as f64;
	// 82EB723C: EDAD06B2  fmuls f13, f13, f26
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[26].f64) as f32) as f64);
	// 82EB7240: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EB7244: C9A100A8  lfd f13, 0xa8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82EB7248: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EB724C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EB7250: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB7254: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EB7258: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EB725C: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 82EB7260: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB7264: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7268: 41990010  bgt cr6, 0x82eb7278
	if ctx.cr[6].gt {
	pc = 0x82EB7278; continue 'dispatch;
	}
	// 82EB726C: 817F0444  lwz r11, 0x444(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) } as u64;
	// 82EB7270: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7274: 4098000C  bge cr6, 0x82eb7280
	if !ctx.cr[6].lt {
	pc = 0x82EB7280; continue 'dispatch;
	}
	// 82EB7278: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82EB727C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82EB7280: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EB7284: FF800890  fmr f28, f1
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82EB7288: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82EB728C: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82EB7290: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EB7294: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7298: FC00C090  fmr f0, f24
	ctx.f[0].f64 = ctx.f[24].f64;
	// 82EB729C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB72A0: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB72A4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB72A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB72AC: 40990044  ble cr6, 0x82eb72f0
	if !ctx.cr[6].gt {
	pc = 0x82EB72F0; continue 'dispatch;
	}
	// 82EB72B0: 5547003E  slwi r7, r10, 0
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EB72B4: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB72B8: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB72BC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EB72C0: 419A0020  beq cr6, 0x82eb72e0
	if ctx.cr[6].eq {
	pc = 0x82EB72E0; continue 'dispatch;
	}
	// 82EB72C4: 54C6003E  slwi r6, r6, 0
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EB72C8: C1A6000C  lfs f13, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB72CC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB72D0: 40980010  bge cr6, 0x82eb72e0
	if !ctx.cr[6].lt {
	pc = 0x82EB72E0; continue 'dispatch;
	}
	// 82EB72D4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EB72D8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB72DC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB72E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB72E4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB72E8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EB72EC: 4198FFCC  blt cr6, 0x82eb72b8
	if ctx.cr[6].lt {
	pc = 0x82EB72B8; continue 'dispatch;
	}
	// 82EB72F0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB72F4: 41820748  beq 0x82eb7a3c
	if ctx.cr[0].eq {
	pc = 0x82EB7A3C; continue 'dispatch;
	}
	// 82EB72F8: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB72FC: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB7300: 7F0B502E  lwzx r24, r11, r10
	ctx.r[24].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB7304: 7FAB512E  stwx r29, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 82EB7308: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB730C: 7E0B5214  add r16, r11, r10
	ctx.r[16].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB7310: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7314: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7318: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB731C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7320: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB7324: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7328: 81540000  lwz r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB732C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7330: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82EB7334: 556B007F  clrlwi. r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7338: 4182073C  beq 0x82eb7a74
	if ctx.cr[0].eq {
	pc = 0x82EB7A74; continue 'dispatch;
	}
	// 82EB733C: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 82EB7340: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82EB7344: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82EB7348: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82EB734C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82EB7350: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82EB7354: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7358: 4801CEE9  bl 0x82ed4240
	ctx.lr = 0x82EB735C;
	sub_82ED4240(ctx, base);
	// 82EB735C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB7360: 7FAFEB78  mr r15, r29
	ctx.r[15].u64 = ctx.r[29].u64;
	// 82EB7364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7368: 419A05C4  beq cr6, 0x82eb792c
	if ctx.cr[6].eq {
	pc = 0x82EB792C; continue 'dispatch;
	}
	// 82EB736C: 7FB3EB78  mr r19, r29
	ctx.r[19].u64 = ctx.r[29].u64;
	// 82EB7370: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB7374: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB7378: 7EF3582E  lwzx r23, r19, r11
	ctx.r[23].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB737C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB7380: 7ED3582E  lwzx r22, r19, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7384: D3C10080  stfs f30, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB7388: 8161035C  lwz r11, 0x35c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EB738C: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EB7390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7394: 92DE000C  stw r22, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[22].u32 ) };
	// 82EB7398: 409A0188  bne cr6, 0x82eb7520
	if !ctx.cr[6].eq {
	pc = 0x82EB7520; continue 'dispatch;
	}
	// 82EB739C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB73A0: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 82EB73A4: 556B0FFF  rlwinm. r11, r11, 1, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB73A8: 41820178  beq 0x82eb7520
	if ctx.cr[0].eq {
	pc = 0x82EB7520; continue 'dispatch;
	}
	// 82EB73AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB73B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB73B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73B8: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB73BC: 4801D555  bl 0x82ed4910
	ctx.lr = 0x82EB73C0;
	sub_82ED4910(ctx, base);
	// 82EB73C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB73C4: 41820548  beq 0x82eb790c
	if ctx.cr[0].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB73C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73CC: 4801D3C5  bl 0x82ed4790
	ctx.lr = 0x82EB73D0;
	sub_82ED4790(ctx, base);
	// 82EB73D0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EB73D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73D8: 4BFE2E71  bl 0x82e9a248
	ctx.lr = 0x82EB73DC;
	sub_82E9A248(ctx, base);
	// 82EB73DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB73E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73E4: 4BFE2EE5  bl 0x82e9a2c8
	ctx.lr = 0x82EB73E8;
	sub_82E9A2C8(ctx, base);
	// 82EB73E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB73EC: 92A10094  stw r21, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[21].u32 ) };
	// 82EB73F0: 39410190  addi r10, r1, 0x190
	ctx.r[10].s64 = ctx.r[1].s64 + 400;
	// 82EB73F4: 92A1007C  stw r21, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[21].u32 ) };
	// 82EB73F8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB73FC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7400: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB7404: 92210090  stw r17, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[17].u32 ) };
	// 82EB7408: 92210078  stw r17, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[17].u32 ) };
	// 82EB740C: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB7410: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7414: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB7418: 91010094  stw r8, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 82EB741C: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7420: 92410180  stw r18, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[18].u32 ) };
	// 82EB7424: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB7428: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 82EB742C: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7430: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB7434: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7438: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB743C: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7440: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82EB7444: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7448: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB744C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7450: 4200FFF8  bdnz 0x82eb7448
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7448; continue 'dispatch;
	}
	// 82EB7454: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EB7458: 9BA101D8  stb r29, 0x1d8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[29].u8 ) };
	// 82EB745C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EB7460: 4B2F7249  bl 0x821ae6a8
	ctx.lr = 0x82EB7464;
	sub_821AE6A8(ctx, base);
	// 82EB7464: 924100C0  stw r18, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[18].u32 ) };
	// 82EB7468: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB746C: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82EB7470: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EB7474: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB7478: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB747C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB7480: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EB7484: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7488: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EB748C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7490: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7494: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7498: 4200FFF8  bdnz 0x82eb7490
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7490; continue 'dispatch;
	}
	// 82EB749C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82EB74A0: 9BA10118  stb r29, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[29].u8 ) };
	// 82EB74A4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EB74A8: 4B2F7201  bl 0x821ae6a8
	ctx.lr = 0x82EB74AC;
	sub_821AE6A8(ctx, base);
	// 82EB74AC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB74B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB74B4: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82EB74B8: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB74BC: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82EB74C0: 38A10180  addi r5, r1, 0x180
	ctx.r[5].s64 = ctx.r[1].s64 + 384;
	// 82EB74C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB74C8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB74CC: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB74D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB74D4: 4E800421  bctrl
	ctx.lr = 0x82EB74D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB74D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB74DC: 4082002C  bne 0x82eb7508
	if !ctx.cr[0].eq {
	pc = 0x82EB7508; continue 'dispatch;
	}
	// 82EB74E0: 897F007E  lbz r11, 0x7e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(126 as u32) ) } as u64;
	// 82EB74E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB74E8: 41820020  beq 0x82eb7508
	if ctx.cr[0].eq {
	pc = 0x82EB7508; continue 'dispatch;
	}
	// 82EB74EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB74F0: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB74F4: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EB74F8: 91610180  stw r11, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82EB74FC: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB7500: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EB7504: 48000408  b 0x82eb790c
	pc = 0x82EB790C; continue 'dispatch;
	// 82EB7508: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB750C: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB7510: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EB7514: 91610180  stw r11, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82EB7518: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB751C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EB7520: C3F80014  lfs f31, 0x14(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB7524: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7528: 41820010  beq 0x82eb7538
	if ctx.cr[0].eq {
	pc = 0x82EB7538; continue 'dispatch;
	}
	// 82EB752C: C0010080  lfs f0, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7530: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB7534: 48000190  b 0x82eb76c4
	pc = 0x82EB76C4; continue 'dispatch;
	// 82EB7538: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB753C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7540: 419A0164  beq cr6, 0x82eb76a4
	if ctx.cr[6].eq {
	pc = 0x82EB76A4; continue 'dispatch;
	}
	// 82EB7544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7548: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EB754C: 4BFE2CFD  bl 0x82e9a248
	ctx.lr = 0x82EB7550;
	sub_82E9A248(ctx, base);
	// 82EB7550: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB7554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7558: 4BFE2D71  bl 0x82e9a2c8
	ctx.lr = 0x82EB755C;
	sub_82E9A2C8(ctx, base);
	// 82EB755C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB7560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7564: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EB7568: 92210070  stw r17, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[17].u32 ) };
	// 82EB756C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7570: 92A10074  stw r21, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[21].u32 ) };
	// 82EB7574: 4801C2BD  bl 0x82ed3830
	ctx.lr = 0x82EB7578;
	sub_82ED3830(ctx, base);
	// 82EB7578: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB757C: 392101F0  addi r9, r1, 0x1f0
	ctx.r[9].s64 = ctx.r[1].s64 + 496;
	// 82EB7580: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EB7584: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB7588: 924101E0  stw r18, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[18].u32 ) };
	// 82EB758C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB7590: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7594: D00101E4  stfs f0, 0x1e4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82EB7598: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB759C: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82EB75A0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB75A4: D00101EC  stfs f0, 0x1ec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 82EB75A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB75AC: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB75B0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB75B4: 4200FFF8  bdnz 0x82eb75ac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB75AC; continue 'dispatch;
	}
	// 82EB75B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EB75BC: 9BA10238  stb r29, 0x238(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), ctx.r[29].u8 ) };
	// 82EB75C0: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 82EB75C4: 4B2F70E5  bl 0x821ae6a8
	ctx.lr = 0x82EB75C8;
	sub_821AE6A8(ctx, base);
	// 82EB75C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB75CC: 92210088  stw r17, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[17].u32 ) };
	// 82EB75D0: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB75D4: 92A1008C  stw r21, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[21].u32 ) };
	// 82EB75D8: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB75DC: 4801C255  bl 0x82ed3830
	ctx.lr = 0x82EB75E0;
	sub_82ED3830(ctx, base);
	// 82EB75E0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB75E4: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 82EB75E8: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 82EB75EC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB75F0: 92410120  stw r18, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[18].u32 ) };
	// 82EB75F4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB75F8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB75FC: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EB7600: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7604: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EB7608: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB760C: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EB7610: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB7614: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB7618: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB761C: 4200FFF8  bdnz 0x82eb7614
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7614; continue 'dispatch;
	}
	// 82EB7620: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82EB7624: 9BA10178  stb r29, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[29].u8 ) };
	// 82EB7628: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82EB762C: 4B2F707D  bl 0x821ae6a8
	ctx.lr = 0x82EB7630;
	sub_821AE6A8(ctx, base);
	// 82EB7630: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7634: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB7638: 38E10098  addi r7, r1, 0x98
	ctx.r[7].s64 = ctx.r[1].s64 + 152;
	// 82EB763C: 38C10120  addi r6, r1, 0x120
	ctx.r[6].s64 = ctx.r[1].s64 + 288;
	// 82EB7640: 38A101E0  addi r5, r1, 0x1e0
	ctx.r[5].s64 = ctx.r[1].s64 + 480;
	// 82EB7644: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB7648: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB764C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7654: 4E800421  bctrl
	ctx.lr = 0x82EB7658;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB7658: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB765C: 40820028  bne 0x82eb7684
	if !ctx.cr[0].eq {
	pc = 0x82EB7684; continue 'dispatch;
	}
	// 82EB7660: 897F007F  lbz r11, 0x7f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(127 as u32) ) } as u64;
	// 82EB7664: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7668: 4182001C  beq 0x82eb7684
	if ctx.cr[0].eq {
	pc = 0x82EB7684; continue 'dispatch;
	}
	// 82EB766C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7670: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82EB7674: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EB7678: 916101E0  stw r11, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EB767C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB7680: 4800028C  b 0x82eb790c
	pc = 0x82EB790C; continue 'dispatch;
	// 82EB7684: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7688: C0010098  lfs f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB768C: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB7690: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82EB7694: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EB7698: 916101E0  stw r11, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EB769C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB76A0: 48000024  b 0x82eb76c4
	pc = 0x82EB76C4; continue 'dispatch;
	// 82EB76A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB76A8: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82EB76AC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB76B0: F96100B0  std r11, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u64 ) };
	// 82EB76B4: C80100B0  lfd f0, 0xb0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82EB76B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EB76BC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EB76C0: EFE0FE7A  fmadds f31, f0, f25, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EB76C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB76C8: 4BFE2C81  bl 0x82e9a348
	ctx.lr = 0x82EB76CC;
	sub_82E9A348(ctx, base);
	// 82EB76CC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB76D0: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB76D4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB76D8: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB76DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB76E0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB76E4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB76E8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB76EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB76F0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB76F4: 5565007E  clrlwi r5, r11, 1
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB76F8: 40990060  ble cr6, 0x82eb7758
	if !ctx.cr[6].gt {
	pc = 0x82EB7758; continue 'dispatch;
	}
	// 82EB76FC: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7700: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB7704: 40820054  bne 0x82eb7758
	if !ctx.cr[0].eq {
	pc = 0x82EB7758; continue 'dispatch;
	}
	// 82EB7708: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB770C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB7710: 419A0034  beq cr6, 0x82eb7744
	if ctx.cr[6].eq {
	pc = 0x82EB7744; continue 'dispatch;
	}
	// 82EB7714: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7718: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB771C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7720: 554A007E  clrlwi r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB7724: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB7728: 409A001C  bne cr6, 0x82eb7744
	if !ctx.cr[6].eq {
	pc = 0x82EB7744; continue 'dispatch;
	}
	// 82EB772C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7730: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EB7734: C00A0014  lfs f0, 0x14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7738: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB773C: 41990008  bgt cr6, 0x82eb7744
	if ctx.cr[6].gt {
	pc = 0x82EB7744; continue 'dispatch;
	}
	// 82EB7740: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB7744: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7748: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB774C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB7750: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB7754: 4198FFAC  blt cr6, 0x82eb7700
	if ctx.cr[6].lt {
	pc = 0x82EB7700; continue 'dispatch;
	}
	// 82EB7758: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB775C: 408201B0  bne 0x82eb790c
	if !ctx.cr[0].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB7760: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB7764: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EB7768: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB776C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7770: 40990060  ble cr6, 0x82eb77d0
	if !ctx.cr[6].gt {
	pc = 0x82EB77D0; continue 'dispatch;
	}
	// 82EB7774: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7778: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB777C: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB7780: 40820050  bne 0x82eb77d0
	if !ctx.cr[0].eq {
	pc = 0x82EB77D0; continue 'dispatch;
	}
	// 82EB7784: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7788: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB778C: 419A0030  beq cr6, 0x82eb77bc
	if ctx.cr[6].eq {
	pc = 0x82EB77BC; continue 'dispatch;
	}
	// 82EB7790: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7794: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7798: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB779C: 5463007E  clrlwi r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB77A0: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB77A4: 409A0018  bne cr6, 0x82eb77bc
	if !ctx.cr[6].eq {
	pc = 0x82EB77BC; continue 'dispatch;
	}
	// 82EB77A8: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB77AC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EB77B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB77B4: 41990008  bgt cr6, 0x82eb77bc
	if ctx.cr[6].gt {
	pc = 0x82EB77BC; continue 'dispatch;
	}
	// 82EB77B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB77BC: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB77C0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB77C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB77C8: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB77CC: 4198FFB0  blt cr6, 0x82eb777c
	if ctx.cr[6].lt {
	pc = 0x82EB777C; continue 'dispatch;
	}
	// 82EB77D0: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB77D4: 40820138  bne 0x82eb790c
	if !ctx.cr[0].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB77D8: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB77DC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB77E0: 1D0B001C  mulli r8, r11, 0x1c
	ctx.r[8].s64 = ctx.r[11].s64 * 28;
	// 82EB77E4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB77E8: 816B9E3C  lwz r11, -0x61c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB77EC: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB77F0: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EB77F4: 3D008330  lis r8, -0x7cd0
	ctx.r[8].s64 = -2094006272;
	// 82EB77F8: 8108DF34  lwz r8, -0x20cc(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB77FC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB7800: 419A0354  beq cr6, 0x82eb7b54
	if ctx.cr[6].eq {
	pc = 0x82EB7B54; continue 'dispatch;
	}
	// 82EB7804: D3EB0014  stfs f31, 0x14(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB7808: 930B0018  stw r24, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 82EB780C: 92CB0004  stw r22, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 82EB7810: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EB7814: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EB7818: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB781C: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB7820: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB7824: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7828: 929E0004  stw r20, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 82EB782C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7830: C1740004  lfs f11, 4(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB7834: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB7838: C1540008  lfs f10, 8(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB783C: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB7840: C134000C  lfs f9, 0xc(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB7844: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB7848: C10B0014  lfs f8, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB784C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7850: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82EB7854: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB7858: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB785C: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB7860: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB7864: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB7868: EDA0402A  fadds f13, f0, f8
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EB786C: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7870: 419A0008  beq cr6, 0x82eb7878
	if ctx.cr[6].eq {
	pc = 0x82EB7878; continue 'dispatch;
	}
	// 82EB7874: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EB7878: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EB787C: 409A0090  bne cr6, 0x82eb790c
	if !ctx.cr[6].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB7880: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82EB7884: 419A0010  beq cr6, 0x82eb7894
	if ctx.cr[6].eq {
	pc = 0x82EB7894; continue 'dispatch;
	}
	// 82EB7888: 91700000  stw r11, 0(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB788C: 7FB0EB78  mr r16, r29
	ctx.r[16].u64 = ctx.r[29].u64;
	// 82EB7890: 4800007C  b 0x82eb790c
	pc = 0x82EB790C; continue 'dispatch;
	// 82EB7894: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7898: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EB789C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB78A0: 40990038  ble cr6, 0x82eb78d8
	if !ctx.cr[6].gt {
	pc = 0x82EB78D8; continue 'dispatch;
	}
	// 82EB78A4: 81399E40  lwz r9, -0x61c0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB78A8: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB78AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EB78B0: 419A001C  beq cr6, 0x82eb78cc
	if ctx.cr[6].eq {
	pc = 0x82EB78CC; continue 'dispatch;
	}
	// 82EB78B4: 811F0074  lwz r8, 0x74(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB78B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB78BC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB78C0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB78C4: 4198FFE4  blt cr6, 0x82eb78a8
	if ctx.cr[6].lt {
	pc = 0x82EB78A8; continue 'dispatch;
	}
	// 82EB78C8: 48000010  b 0x82eb78d8
	pc = 0x82EB78D8; continue 'dispatch;
	// 82EB78CC: 81199E40  lwz r8, -0x61c0(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB78D0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB78D4: 7D69412E  stwx r11, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 82EB78D8: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB78DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB78E0: 4198002C  blt cr6, 0x82eb790c
	if ctx.cr[6].lt {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB78E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB78E8: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EB78EC: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82EB78F0: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB78F4: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EB78F8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB78FC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7900: 816BDF34  lwz r11, -0x20cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB7904: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7908: 419A024C  beq cr6, 0x82eb7b54
	if ctx.cr[6].eq {
	pc = 0x82EB7B54; continue 'dispatch;
	}
	// 82EB790C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB7910: 39EF0001  addi r15, r15, 1
	ctx.r[15].s64 = ctx.r[15].s64 + 1;
	// 82EB7914: 3A730004  addi r19, r19, 4
	ctx.r[19].s64 = ctx.r[19].s64 + 4;
	// 82EB7918: 7F0F5840  cmplw cr6, r15, r11
	ctx.cr[6].compare_u32(ctx.r[15].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB791C: 4198FA54  blt cr6, 0x82eb7370
	if ctx.cr[6].lt {
	pc = 0x82EB7370; continue 'dispatch;
	}
	// 82EB7920: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB7924: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB7928: 82E100A0  lwz r23, 0xa0(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB792C: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB7930: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7934: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB7938: 40990040  ble cr6, 0x82eb7978
	if !ctx.cr[6].gt {
	pc = 0x82EB7978; continue 'dispatch;
	}
	// 82EB793C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7940: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB7944: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7948: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB794C: 419A001C  beq cr6, 0x82eb7968
	if ctx.cr[6].eq {
	pc = 0x82EB7968; continue 'dispatch;
	}
	// 82EB7950: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB7954: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7958: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB795C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB7960: 4198FFE4  blt cr6, 0x82eb7944
	if ctx.cr[6].lt {
	pc = 0x82EB7944; continue 'dispatch;
	}
	// 82EB7964: 48000014  b 0x82eb7978
	pc = 0x82EB7978; continue 'dispatch;
	// 82EB7968: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB796C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB7970: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB7974: 7F09512E  stwx r24, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[24].u32) };
	// 82EB7978: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB797C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB7980: 4198F83C  blt cr6, 0x82eb71bc
	if ctx.cr[6].lt {
	pc = 0x82EB71BC; continue 'dispatch;
	}
	// 82EB7984: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7988: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB798C: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB7990: 7F0A592E  stwx r24, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[24].u32) };
	// 82EB7994: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82EB7998: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB799C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB79A0: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB79A4: 814ADF34  lwz r10, -0x20cc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB79A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB79AC: 409AF810  bne cr6, 0x82eb71bc
	if !ctx.cr[6].eq {
	pc = 0x82EB71BC; continue 'dispatch;
	}
	// 82EB79B0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB79B4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB79B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB79BC: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB79C0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB79C4: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB79C8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB79CC: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB79D0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB79D4: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB79D8: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB79DC: 4BFD42FD  bl 0x82e8bcd8
	ctx.lr = 0x82EB79E0;
	sub_82E8BCD8(ctx, base);
	// 82EB79E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB79E4: 38210320  addi r1, r1, 0x320
	ctx.r[1].s64 = ctx.r[1].s64 + 800;
	// 82EB79E8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB79EC: 4BDF6329  bl 0x82cadd14
	ctx.lr = 0x82EB79F0;
	sub_82CADCEC(ctx, base);
	// 82EB79F0: 4BDF1A30  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
	// 82EB79F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB79F8: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB79FC: 4B3A8FBD  bl 0x822609b8
	ctx.lr = 0x82EB7A00;
	sub_822609B8(ctx, base);
	// 82EB7A00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB7A04: 4BFC9C05  bl 0x82e81608
	ctx.lr = 0x82EB7A08;
	sub_82E81608(ctx, base);
	// 82EB7A08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7A0C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A10: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82EB7A14: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB7A18: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7A1C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7A20: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A24: 91CB9E4C  stw r14, -0x61b4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25012 as u32), ctx.r[14].u32 ) };
	// 82EB7A28: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7A2C: 928B9E50  stw r20, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[20].u32 ) };
	// 82EB7A30: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB7A34: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7A38: 4BFFFFAC  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
	// 82EB7A3C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7A40: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB7A48: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7A4C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A50: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7A54: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A58: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB7A5C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7A60: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB7A64: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB7A68: 4BFD4271  bl 0x82e8bcd8
	ctx.lr = 0x82EB7A6C;
	sub_82E8BCD8(ctx, base);
	// 82EB7A6C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82EB7A70: 4BFFFF74  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
	// 82EB7A74: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7A78: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A7C: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB7A80: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82EB7A84: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7A88: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A8C: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7A90: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A94: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB7A98: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A9C: 916A9E50  stw r11, -0x61b0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25008 as u32), ctx.r[11].u32 ) };
	// 82EB7AA0: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB7AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7AA8: 419A0020  beq cr6, 0x82eb7ac8
	if ctx.cr[6].eq {
	pc = 0x82EB7AC8; continue 'dispatch;
	}
	// 82EB7AAC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7AB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7AB4: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EB7AB8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB7ABC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7AC0: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB7AC4: 4801CD85  bl 0x82ed4848
	ctx.lr = 0x82EB7AC8;
	sub_82ED4848(ctx, base);
	// 82EB7AC8: 839C0018  lwz r28, 0x18(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB7ACC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EB7AD0: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7AD4: 4082FFCC  bne 0x82eb7aa0
	if !ctx.cr[0].eq {
	pc = 0x82EB7AA0; continue 'dispatch;
	}
	// 82EB7AD8: 83A10354  lwz r29, 0x354(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(852 as u32) ) } as u64;
	// 82EB7ADC: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 82EB7AE0: 409A0018  bne cr6, 0x82eb7af8
	if !ctx.cr[6].eq {
	pc = 0x82EB7AF8; continue 'dispatch;
	}
	// 82EB7AE4: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EB7AE8: 80C1035C  lwz r6, 0x35c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EB7AEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB7AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB7AF4: 4BFFE3DD  bl 0x82eb5ed0
	ctx.lr = 0x82EB7AF8;
	sub_82EB5ED0(ctx, base);
	// 82EB7AF8: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 82EB7AFC: 409A0048  bne cr6, 0x82eb7b44
	if !ctx.cr[6].eq {
	pc = 0x82EB7B44; continue 'dispatch;
	}
	// 82EB7B00: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7B04: 395B0004  addi r10, r27, 4
	ctx.r[10].s64 = ctx.r[27].s64 + 4;
	// 82EB7B08: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 * 24;
	// 82EB7B0C: 816B01A0  lwz r11, 0x1a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 82EB7B10: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7B14: 4198001C  blt cr6, 0x82eb7b30
	if ctx.cr[6].lt {
	pc = 0x82EB7B30; continue 'dispatch;
	}
	// 82EB7B18: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82EB7B1C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB7B20: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB7B24: 4BFD41B5  bl 0x82e8bcd8
	ctx.lr = 0x82EB7B28;
	sub_82E8BCD8(ctx, base);
	// 82EB7B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7B2C: 4BFFFEB8  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
	// 82EB7B30: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EB7B34: 80C1035C  lwz r6, 0x35c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EB7B38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB7B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB7B40: 4BFFE259  bl 0x82eb5d98
	ctx.lr = 0x82EB7B44;
	sub_82EB5D98(ctx, base);
	// 82EB7B44: 81610364  lwz r11, 0x364(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EB7B48: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82EB7B4C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82EB7B50: 4BFFFFCC  b 0x82eb7b1c
	pc = 0x82EB7B1C; continue 'dispatch;
	// 82EB7B54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7B58: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7B5C: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7B60: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7B64: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7B68: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7B6C: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB7B70: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7B74: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB7B78: 4BFFFFA0  b 0x82eb7b18
	pc = 0x82EB7B18; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB7B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB7B80 size=1024
    let mut pc: u32 = 0x82EB7B80;
    'dispatch: loop {
        match pc {
            0x82EB7B80 => {
    //   block [0x82EB7B80..0x82EB7F80)
	// 82EB7B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB7B84: 4BDF1875  bl 0x82ca93f8
	ctx.lr = 0x82EB7B88;
	sub_82CA93D0(ctx, base);
	// 82EB7B88: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82EB7B8C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB7B90: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EB7B94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB7B98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB7B9C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82EB7BA0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EB7BA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7BA8: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 82EB7BAC: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7BB0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7BB4: 894B0008  lbz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7BB8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7BBC: 408202A0  bne 0x82eb7e5c
	if !ctx.cr[0].eq {
	pc = 0x82EB7E5C; continue 'dispatch;
	}
	// 82EB7BC0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7BC4: 4801BC8D  bl 0x82ed3850
	ctx.lr = 0x82EB7BC8;
	sub_82ED3850(ctx, base);
	// 82EB7BC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7BCC: 41820290  beq 0x82eb7e5c
	if ctx.cr[0].eq {
	pc = 0x82EB7E5C; continue 'dispatch;
	}
	// 82EB7BD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7BD4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB7BD8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7BDC: 408200B8  bne 0x82eb7c94
	if !ctx.cr[0].eq {
	pc = 0x82EB7C94; continue 'dispatch;
	}
	// 82EB7BE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB7BE4: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7BE8: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82EB7BEC: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB7BF0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB7BF4: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7BF8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB7BFC: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82EB7C00: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7C04: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82EB7C08: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EB7C0C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EB7C10: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB7C14: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB7C18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7C1C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7C20: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7C24: 4200FFF8  bdnz 0x82eb7c1c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7C1C; continue 'dispatch;
	}
	// 82EB7C28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB7C2C: 9B4100D8  stb r26, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[26].u8 ) };
	// 82EB7C30: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB7C34: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7C38: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB7C3C: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82EB7C40: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EB7C44: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82EB7C48: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EB7C4C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82EB7C50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB7C54: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EB7C58: 4801D8D9  bl 0x82ed5530
	ctx.lr = 0x82EB7C5C;
	sub_82ED5530(ctx, base);
	// 82EB7C5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7C60: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB7C64: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7C68: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7C6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB7C70: 7D44E850  subf r10, r4, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[4].s64;
	// 82EB7C74: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB7C78: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82EB7C7C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82EB7C80: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB7C84: 695D0001  xori r29, r10, 1
	ctx.r[29].u64 = ctx.r[10].u64 ^ 1;
	// 82EB7C88: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7C8C: 4801BC4D  bl 0x82ed38d8
	ctx.lr = 0x82EB7C90;
	sub_82ED38D8(ctx, base);
	// 82EB7C90: 4800001C  b 0x82eb7cac
	pc = 0x82EB7CAC; continue 'dispatch;
	// 82EB7C94: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7C98: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7C9C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7CA0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7CA4: 4801BC35  bl 0x82ed38d8
	ctx.lr = 0x82EB7CA8;
	sub_82ED38D8(ctx, base);
	// 82EB7CA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB7CAC: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7CB0: 418202C4  beq 0x82eb7f74
	if ctx.cr[0].eq {
	pc = 0x82EB7F74; continue 'dispatch;
	}
	// 82EB7CB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7CB8: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7CBC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7CC0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7CC4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7CC8: C00A0004  lfs f0, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7CCC: D00B0050  stfs f0, 0x50(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB7CD0: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7CD4: D00B0054  stfs f0, 0x54(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB7CD8: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7CDC: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB7CE0: 4801BB51  bl 0x82ed3830
	ctx.lr = 0x82EB7CE4;
	sub_82ED3830(ctx, base);
	// 82EB7CE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7CE8: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7CEC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7CF0: 572A063F  clrlwi. r10, r25, 0x18
	ctx.r[10].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB7CF4: 906B005C  stw r3, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EB7CF8: 418200F4  beq 0x82eb7dec
	if ctx.cr[0].eq {
	pc = 0x82EB7DEC; continue 'dispatch;
	}
	// 82EB7CFC: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7D00: 815B016C  lwz r10, 0x16c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB7D04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB7D08: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7D0C: 419A0090  beq cr6, 0x82eb7d9c
	if ctx.cr[6].eq {
	pc = 0x82EB7D9C; continue 'dispatch;
	}
	// 82EB7D10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7D14: 395D0014  addi r10, r29, 0x14
	ctx.r[10].s64 = ctx.r[29].s64 + 20;
	// 82EB7D18: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7D1C: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7D20: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82EB7D24: 8129004C  lwz r9, 0x4c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EB7D28: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB7D2C: 4099004C  ble cr6, 0x82eb7d78
	if !ctx.cr[6].gt {
	pc = 0x82EB7D78; continue 'dispatch;
	}
	// 82EB7D30: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7D34: 1D290018  mulli r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 * 24;
	// 82EB7D38: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB7D3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7D40: 39290003  addi r9, r9, 3
	ctx.r[9].s64 = ctx.r[9].s64 + 3;
	// 82EB7D44: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB7D48: 7D29F02E  lwzx r9, r9, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EB7D4C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7D50: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7D54: A13D0012  lhz r9, 0x12(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB7D58: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB7D5C: B13D0012  sth r9, 0x12(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(18 as u32), ctx.r[9].u16 ) };
	// 82EB7D60: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7D64: 1D290060  mulli r9, r9, 0x60
	ctx.r[9].s64 = ctx.r[9].s64 * 96;
	// 82EB7D68: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82EB7D6C: 8129004C  lwz r9, 0x4c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EB7D70: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB7D74: 4198FFBC  blt cr6, 0x82eb7d30
	if ctx.cr[6].lt {
	pc = 0x82EB7D30; continue 'dispatch;
	}
	// 82EB7D78: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7D7C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7D80: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB7D84: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB7D88: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB7D8C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB7D90: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB7D94: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7D98: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7D9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7DA0: B17D0010  sth r11, 0x10(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82EB7DA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7DA8: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7DAC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7DB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7DB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7DB8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7DBC: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7DC0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7DC4: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB7DC8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7DCC: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7DD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7DD4: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7DD8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7DDC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7DE0: 4801BA51  bl 0x82ed3830
	ctx.lr = 0x82EB7DE4;
	sub_82ED3830(ctx, base);
	// 82EB7DE4: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB7DE8: B35D0012  sth r26, 0x12(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(18 as u32), ctx.r[26].u16 ) };
	// 82EB7DEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7DF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB7DF4: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7DF8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7DFC: 994B0008  stb r10, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82EB7E00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E04: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7E08: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E0C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7E10: 4801B9F1  bl 0x82ed3800
	ctx.lr = 0x82EB7E14;
	sub_82ED3800(ctx, base);
	// 82EB7E14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7E18: 90780000  stw r3, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB7E1C: 40820008  bne 0x82eb7e24
	if !ctx.cr[0].eq {
	pc = 0x82EB7E24; continue 'dispatch;
	}
	// 82EB7E20: 93580000  stw r26, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82EB7E24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E28: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7E2C: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7E30: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E34: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7E38: 4801B0F9  bl 0x82ed2f30
	ctx.lr = 0x82EB7E3C;
	sub_82ED2F30(ctx, base);
	// 82EB7E3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E40: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7E44: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E48: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82EB7E4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7E54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB7E58: 4800011C  b 0x82eb7f74
	pc = 0x82EB7F74; continue 'dispatch;
	// 82EB7E5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E60: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7E64: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E68: 894B0008  lbz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7E6C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7E70: 40820104  bne 0x82eb7f74
	if !ctx.cr[0].eq {
	pc = 0x82EB7F74; continue 'dispatch;
	}
	// 82EB7E74: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7E78: 4801BA31  bl 0x82ed38a8
	ctx.lr = 0x82EB7E7C;
	sub_82ED38A8(ctx, base);
	// 82EB7E7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7E80: 418200F4  beq 0x82eb7f74
	if ctx.cr[0].eq {
	pc = 0x82EB7F74; continue 'dispatch;
	}
	// 82EB7E84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E88: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7E8C: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7E90: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E94: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7E98: 4801B099  bl 0x82ed2f30
	ctx.lr = 0x82EB7E9C;
	sub_82ED2F30(ctx, base);
	// 82EB7E9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7EA0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB7EA4: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7EA8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7EAC: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82EB7EB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7EB4: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7EB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7EBC: 409A0030  bne cr6, 0x82eb7eec
	if !ctx.cr[6].eq {
	pc = 0x82EB7EEC; continue 'dispatch;
	}
	// 82EB7EC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB7EC4: 809B00A4  lwz r4, 0xa4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB7EC8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB7ECC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB7ED0: C02B0C4C  lfs f1, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB7ED4: 4801AE75  bl 0x82ed2d48
	ctx.lr = 0x82EB7ED8;
	sub_82ED2D48(ctx, base);
	// 82EB7ED8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7EDC: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7EE0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7EE4: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EB7EE8: 4800008C  b 0x82eb7f74
	pc = 0x82EB7F74; continue 'dispatch;
	// 82EB7EEC: 4801A0B5  bl 0x82ed1fa0
	ctx.lr = 0x82EB7EF0;
	sub_82ED1FA0(ctx, base);
	// 82EB7EF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7EF4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82EB7EF8: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7EFC: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EB7F00: 816B00F0  lwz r11, 0xf0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EB7F04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7F08: 40990064  ble cr6, 0x82eb7f6c
	if !ctx.cr[6].gt {
	pc = 0x82EB7F6C; continue 'dispatch;
	}
	// 82EB7F0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB7F10: C3EB0C4C  lfs f31, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB7F14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7F18: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB7F1C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB7F20: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7F24: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 * 24;
	// 82EB7F28: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB7F2C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB7F30: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	// 82EB7F34: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB7F38: 7C8BD82E  lwzx r4, r11, r27
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EB7F3C: 4801AE0D  bl 0x82ed2d48
	ctx.lr = 0x82EB7F40;
	sub_82ED2D48(ctx, base);
	// 82EB7F40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7F44: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB7F48: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7F4C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7F50: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EB7F54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7F58: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB7F5C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EB7F60: 816B00F0  lwz r11, 0xf0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EB7F64: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7F68: 4198FFAC  blt cr6, 0x82eb7f14
	if ctx.cr[6].lt {
	pc = 0x82EB7F14; continue 'dispatch;
	}
	// 82EB7F6C: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7F70: 4801A051  bl 0x82ed1fc0
	ctx.lr = 0x82EB7F74;
	sub_82ED1FC0(ctx, base);
	// 82EB7F74: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82EB7F78: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82EB7F7C: 4BDF14CC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB7F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB7F80 size=964
    let mut pc: u32 = 0x82EB7F80;
    'dispatch: loop {
        match pc {
            0x82EB7F80 => {
    //   block [0x82EB7F80..0x82EB8344)
	// 82EB7F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB7F84: 4BDF1485  bl 0x82ca9408
	ctx.lr = 0x82EB7F88;
	sub_82CA93D0(ctx, base);
	// 82EB7F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB7F8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB7F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB7F94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB7F98: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82EB7F9C: 397F0334  addi r11, r31, 0x334
	ctx.r[11].s64 = ctx.r[31].s64 + 820;
	// 82EB7FA0: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7FA4: 395F027C  addi r10, r31, 0x27c
	ctx.r[10].s64 = ctx.r[31].s64 + 636;
	// 82EB7FA8: 393F03A4  addi r9, r31, 0x3a4
	ctx.r[9].s64 = ctx.r[31].s64 + 932;
	// 82EB7FAC: 93DF0390  stw r30, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[30].u32 ) };
	// 82EB7FB0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB7FB4: 911F03A0  stw r8, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[8].u32 ) };
	// 82EB7FB8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB7FBC: 9BDF0396  stb r30, 0x396(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(918 as u32), ctx.r[30].u8 ) };
	// 82EB7FC0: 9BDF0397  stb r30, 0x397(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(919 as u32), ctx.r[30].u8 ) };
	// 82EB7FC4: 9BDF0395  stb r30, 0x395(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(917 as u32), ctx.r[30].u8 ) };
	// 82EB7FC8: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	// 82EB7FCC: 9BDF0400  stb r30, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	// 82EB7FD0: C1A80C1C  lfs f13, 0xc1c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB7FD4: 9BDF0435  stb r30, 0x435(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1077 as u32), ctx.r[30].u8 ) };
	// 82EB7FD8: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7FDC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB7FE0: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7FE4: 9BCB0058  stb r30, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB7FE8: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7FEC: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB7FF0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7FF4: 9BCA0058  stb r30, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB7FF8: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7FFC: D0090008  stfs f0, 8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB8000: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB8004: 9BC90058  stb r30, 0x58(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB8008: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB800C: D1BF0424  stfs f13, 0x424(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	// 82EB8010: D1BF0438  stfs f13, 0x438(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), tmp.u32 ) };
	// 82EB8014: 9BDF0394  stb r30, 0x394(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[30].u8 ) };
	// 82EB8018: 9BDF019D  stb r30, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[30].u8 ) };
	// 82EB801C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8020: 40990034  ble cr6, 0x82eb8054
	if !ctx.cr[6].gt {
	pc = 0x82EB8054; continue 'dispatch;
	}
	// 82EB8024: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB8028: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EB802C: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8030: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8034: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8038: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB803C: 4E800421  bctrl
	ctx.lr = 0x82EB8040;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8040: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB8044: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB8048: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EB804C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8050: 4198FFD8  blt cr6, 0x82eb8028
	if ctx.cr[6].lt {
	pc = 0x82EB8028; continue 'dispatch;
	}
	// 82EB8054: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EB8058: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB805C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8060: 40990034  ble cr6, 0x82eb8094
	if !ctx.cr[6].gt {
	pc = 0x82EB8094; continue 'dispatch;
	}
	// 82EB8064: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8068: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB806C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8070: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8074: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB807C: 4E800421  bctrl
	ctx.lr = 0x82EB8080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8080: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EB8084: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8088: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB808C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8090: 4198FFD8  blt cr6, 0x82eb8068
	if ctx.cr[6].lt {
	pc = 0x82EB8068; continue 'dispatch;
	}
	// 82EB8094: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EB8098: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB809C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB80A0: 40990034  ble cr6, 0x82eb80d4
	if !ctx.cr[6].gt {
	pc = 0x82EB80D4; continue 'dispatch;
	}
	// 82EB80A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB80A8: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EB80AC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB80B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB80B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB80B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB80BC: 4E800421  bctrl
	ctx.lr = 0x82EB80C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB80C0: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EB80C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB80C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB80CC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB80D0: 4198FFD8  blt cr6, 0x82eb80a8
	if ctx.cr[6].lt {
	pc = 0x82EB80A8; continue 'dispatch;
	}
	// 82EB80D4: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EB80D8: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB80DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB80E0: 40990034  ble cr6, 0x82eb8114
	if !ctx.cr[6].gt {
	pc = 0x82EB8114; continue 'dispatch;
	}
	// 82EB80E4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB80E8: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EB80EC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB80F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB80F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB80F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB80FC: 4E800421  bctrl
	ctx.lr = 0x82EB8100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8100: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EB8104: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8108: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB810C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8110: 4198FFD8  blt cr6, 0x82eb80e8
	if ctx.cr[6].lt {
	pc = 0x82EB80E8; continue 'dispatch;
	}
	// 82EB8114: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EB8118: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB811C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8120: 40990034  ble cr6, 0x82eb8154
	if !ctx.cr[6].gt {
	pc = 0x82EB8154; continue 'dispatch;
	}
	// 82EB8124: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8128: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EB812C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8130: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8134: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB813C: 4E800421  bctrl
	ctx.lr = 0x82EB8140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8140: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EB8144: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8148: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB814C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8150: 4198FFD8  blt cr6, 0x82eb8128
	if ctx.cr[6].lt {
	pc = 0x82EB8128; continue 'dispatch;
	}
	// 82EB8154: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EB8158: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB815C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8160: 40990034  ble cr6, 0x82eb8194
	if !ctx.cr[6].gt {
	pc = 0x82EB8194; continue 'dispatch;
	}
	// 82EB8164: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8168: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EB816C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8174: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB817C: 4E800421  bctrl
	ctx.lr = 0x82EB8180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8180: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EB8184: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8188: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB818C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8190: 4198FFD8  blt cr6, 0x82eb8168
	if ctx.cr[6].lt {
	pc = 0x82EB8168; continue 'dispatch;
	}
	// 82EB8194: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EB8198: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB819C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB81A0: 40990034  ble cr6, 0x82eb81d4
	if !ctx.cr[6].gt {
	pc = 0x82EB81D4; continue 'dispatch;
	}
	// 82EB81A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB81A8: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EB81AC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB81B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB81B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB81B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB81BC: 4E800421  bctrl
	ctx.lr = 0x82EB81C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB81C0: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EB81C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB81C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB81CC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB81D0: 4198FFD8  blt cr6, 0x82eb81a8
	if ctx.cr[6].lt {
	pc = 0x82EB81A8; continue 'dispatch;
	}
	// 82EB81D4: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EB81D8: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB81DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB81E0: 40990034  ble cr6, 0x82eb8214
	if !ctx.cr[6].gt {
	pc = 0x82EB8214; continue 'dispatch;
	}
	// 82EB81E4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB81E8: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EB81EC: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB81F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB81F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB81F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB81FC: 4E800421  bctrl
	ctx.lr = 0x82EB8200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8200: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EB8204: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8208: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB820C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8210: 4198FFD8  blt cr6, 0x82eb81e8
	if ctx.cr[6].lt {
	pc = 0x82EB81E8; continue 'dispatch;
	}
	// 82EB8214: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EB8218: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB821C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8220: 40990034  ble cr6, 0x82eb8254
	if !ctx.cr[6].gt {
	pc = 0x82EB8254; continue 'dispatch;
	}
	// 82EB8224: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8228: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EB822C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB8230: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8234: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB823C: 4E800421  bctrl
	ctx.lr = 0x82EB8240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8240: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EB8244: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8248: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB824C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8250: 4198FFD8  blt cr6, 0x82eb8228
	if ctx.cr[6].lt {
	pc = 0x82EB8228; continue 'dispatch;
	}
	// 82EB8254: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EB8258: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB825C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8260: 40990034  ble cr6, 0x82eb8294
	if !ctx.cr[6].gt {
	pc = 0x82EB8294; continue 'dispatch;
	}
	// 82EB8264: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8268: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EB826C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB8270: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8274: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8278: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB827C: 4E800421  bctrl
	ctx.lr = 0x82EB8280;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8280: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EB8284: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8288: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB828C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8290: 4198FFD8  blt cr6, 0x82eb8268
	if ctx.cr[6].lt {
	pc = 0x82EB8268; continue 'dispatch;
	}
	// 82EB8294: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EB8298: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB829C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB82A0: 40990034  ble cr6, 0x82eb82d4
	if !ctx.cr[6].gt {
	pc = 0x82EB82D4; continue 'dispatch;
	}
	// 82EB82A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB82A8: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EB82AC: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB82B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB82B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB82B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB82BC: 4E800421  bctrl
	ctx.lr = 0x82EB82C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB82C0: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EB82C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB82C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB82CC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB82D0: 4198FFD8  blt cr6, 0x82eb82a8
	if ctx.cr[6].lt {
	pc = 0x82EB82A8; continue 'dispatch;
	}
	// 82EB82D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB82D8: 4BFFDEC9  bl 0x82eb61a0
	ctx.lr = 0x82EB82DC;
	sub_82EB61A0(ctx, base);
	// 82EB82DC: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB82E0: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EB82E4: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EB82E8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB82EC: 41820024  beq 0x82eb8310
	if ctx.cr[0].eq {
	pc = 0x82EB8310; continue 'dispatch;
	}
	// 82EB82F0: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB82F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB82F8: 41820018  beq 0x82eb8310
	if ctx.cr[0].eq {
	pc = 0x82EB8310; continue 'dispatch;
	}
	// 82EB82FC: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB8300: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8304: 4182000C  beq 0x82eb8310
	if ctx.cr[0].eq {
	pc = 0x82EB8310; continue 'dispatch;
	}
	// 82EB8308: 4801AC29  bl 0x82ed2f30
	ctx.lr = 0x82EB830C;
	sub_82ED2F30(ctx, base);
	// 82EB830C: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB8310: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB8314: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8318: 41820024  beq 0x82eb833c
	if ctx.cr[0].eq {
	pc = 0x82EB833C; continue 'dispatch;
	}
	// 82EB831C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8320: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8324: 41820018  beq 0x82eb833c
	if ctx.cr[0].eq {
	pc = 0x82EB833C; continue 'dispatch;
	}
	// 82EB8328: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB832C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8330: 4182000C  beq 0x82eb833c
	if ctx.cr[0].eq {
	pc = 0x82EB833C; continue 'dispatch;
	}
	// 82EB8334: 4801ABFD  bl 0x82ed2f30
	ctx.lr = 0x82EB8338;
	sub_82ED2F30(ctx, base);
	// 82EB8338: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB833C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB8340: 4BDF1118  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB8348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB8348 size=2008
    let mut pc: u32 = 0x82EB8348;
    'dispatch: loop {
        match pc {
            0x82EB8348 => {
    //   block [0x82EB8348..0x82EB8B20)
	// 82EB8348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB834C: 4BDF10A9  bl 0x82ca93f4
	ctx.lr = 0x82EB8350;
	sub_82CA93D0(ctx, base);
	// 82EB8350: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82EB8354: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB8358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB835C: 839F0054  lwz r28, 0x54(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8360: 817C01A4  lwz r11, 0x1a4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EB8364: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB8368: 408200F4  bne 0x82eb845c
	if !ctx.cr[0].eq {
	pc = 0x82EB845C; continue 'dispatch;
	}
	// 82EB836C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8370: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB8374: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB8378: 419A006C  beq cr6, 0x82eb83e4
	if ctx.cr[6].eq {
	pc = 0x82EB83E4; continue 'dispatch;
	}
	// 82EB837C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8380: 816301A8  lwz r11, 0x1a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EB8384: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 82EB8388: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB838C: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8390: 40820038  bne 0x82eb83c8
	if !ctx.cr[0].eq {
	pc = 0x82EB83C8; continue 'dispatch;
	}
	// 82EB8394: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8398: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB839C: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB83A0: 419A0770  beq cr6, 0x82eb8b10
	if ctx.cr[6].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB83A4: 4BFFDFFD  bl 0x82eb63a0
	ctx.lr = 0x82EB83A8;
	sub_82EB63A0(ctx, base);
	// 82EB83A8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB83AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB83B0: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB83B4: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB83B8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB83BC: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB83C0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB83C4: 4BFFFFB8  b 0x82eb837c
	pc = 0x82EB837C; continue 'dispatch;
	// 82EB83C8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB83CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB83D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB83D4: 914B01A4  stw r10, 0x1a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), ctx.r[10].u32 ) };
	// 82EB83D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB83DC: 912B01AC  stw r9, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[9].u32 ) };
	// 82EB83E0: 48000730  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB83E4: 817C01B8  lwz r11, 0x1b8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB83E8: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB83EC: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82EB83F0: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB83F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB83F8: 409A0028  bne cr6, 0x82eb8420
	if !ctx.cr[6].eq {
	pc = 0x82EB8420; continue 'dispatch;
	}
	// 82EB83FC: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8400: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8404: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8408: 409A0018  bne cr6, 0x82eb8420
	if !ctx.cr[6].eq {
	pc = 0x82EB8420; continue 'dispatch;
	}
	// 82EB840C: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8410: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB8414: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8418: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB841C: 419A0008  beq cr6, 0x82eb8424
	if ctx.cr[6].eq {
	pc = 0x82EB8424; continue 'dispatch;
	}
	// 82EB8420: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82EB8424: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB8428: 418206E8  beq 0x82eb8b10
	if ctx.cr[0].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB842C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB8430: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8434: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB8438: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB843C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB8440: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8444: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB8448: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB844C: 814B01B8  lwz r10, 0x1b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB8450: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EB8454: 914B01B8  stw r10, 0x1b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), ctx.r[10].u32 ) };
	// 82EB8458: 480006B8  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB845C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB8460: 409A06B0  bne cr6, 0x82eb8b10
	if !ctx.cr[6].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8464: 817C01BC  lwz r11, 0x1bc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB8468: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EB846C: 815C01B8  lwz r10, 0x1b8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB8470: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82EB8474: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82EB8478: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB847C: 419A0030  beq cr6, 0x82eb84ac
	if ctx.cr[6].eq {
	pc = 0x82EB84AC; continue 'dispatch;
	}
	// 82EB8480: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EB8484: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82EB8488: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EB848C: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 82EB8490: 41990680  bgt cr6, 0x82eb8b10
	if ctx.cr[6].gt {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8494: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82EB8498: 4098000C  bge cr6, 0x82eb84a4
	if !ctx.cr[6].lt {
	pc = 0x82EB84A4; continue 'dispatch;
	}
	// 82EB849C: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 82EB84A0: 48000010  b 0x82eb84b0
	pc = 0x82EB84B0; continue 'dispatch;
	// 82EB84A4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EB84A8: 40980008  bge cr6, 0x82eb84b0
	if !ctx.cr[6].lt {
	pc = 0x82EB84B0; continue 'dispatch;
	}
	// 82EB84AC: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 82EB84B0: 817C01AC  lwz r11, 0x1ac(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB84B4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB84B8: 40820324  bne 0x82eb87dc
	if !ctx.cr[0].eq {
	pc = 0x82EB87DC; continue 'dispatch;
	}
	// 82EB84BC: 817C0194  lwz r11, 0x194(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB84C0: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB84C4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB84C8: 38CB0010  addi r6, r11, 0x10
	ctx.r[6].s64 = ctx.r[11].s64 + 16;
	// 82EB84CC: 83C60008  lwz r30, 8(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB84D0: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB84D4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB84D8: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 82EB84DC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB84E0: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB84E4: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB84E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB84EC: 409A0028  bne cr6, 0x82eb8514
	if !ctx.cr[6].eq {
	pc = 0x82EB8514; continue 'dispatch;
	}
	// 82EB84F0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB84F4: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB84F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB84FC: 409A0018  bne cr6, 0x82eb8514
	if !ctx.cr[6].eq {
	pc = 0x82EB8514; continue 'dispatch;
	}
	// 82EB8500: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8504: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82EB8508: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB850C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8510: 419A0008  beq cr6, 0x82eb8518
	if ctx.cr[6].eq {
	pc = 0x82EB8518; continue 'dispatch;
	}
	// 82EB8514: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82EB8518: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB851C: 4182001C  beq 0x82eb8538
	if ctx.cr[0].eq {
	pc = 0x82EB8538; continue 'dispatch;
	}
	// 82EB8520: 92FC01A4  stw r23, 0x1a4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(420 as u32), ctx.r[23].u32 ) };
	// 82EB8524: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8528: 4BFFDDE9  bl 0x82eb6310
	ctx.lr = 0x82EB852C;
	sub_82EB6310(ctx, base);
	// 82EB852C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8530: 4BFFFE19  bl 0x82eb8348
	ctx.lr = 0x82EB8534;
	sub_82EB8348(ctx, base);
	// 82EB8534: 480005DC  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB8538: A15E0010  lhz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB853C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8540: 40820080  bne 0x82eb85c0
	if !ctx.cr[0].eq {
	pc = 0x82EB85C0; continue 'dispatch;
	}
	// 82EB8544: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8548: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB854C: 40820074  bne 0x82eb85c0
	if !ctx.cr[0].eq {
	pc = 0x82EB85C0; continue 'dispatch;
	}
	// 82EB8550: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB8554: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EB8558: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EB855C: 4BFFD745  bl 0x82eb5ca0
	ctx.lr = 0x82EB8560;
	sub_82EB5CA0(ctx, base);
	// 82EB8560: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8564: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8568: 419A002C  beq cr6, 0x82eb8594
	if ctx.cr[6].eq {
	pc = 0x82EB8594; continue 'dispatch;
	}
	// 82EB856C: A1670012  lhz r11, 0x12(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8570: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8574: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 82EB8578: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB857C: 7CEB3A14  add r7, r11, r7
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82EB8580: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82EB8584: 4BFFD71D  bl 0x82eb5ca0
	ctx.lr = 0x82EB8588;
	sub_82EB5CA0(ctx, base);
	// 82EB8588: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB858C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8590: 409AFFDC  bne cr6, 0x82eb856c
	if !ctx.cr[6].eq {
	pc = 0x82EB856C; continue 'dispatch;
	}
	// 82EB8594: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8598: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB859C: 1D2A000C  mulli r9, r10, 0xc
	ctx.r[9].s64 = ctx.r[10].s64 * 12;
	// 82EB85A0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB85A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EB85A8: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB85AC: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB85B0: 912B0198  stw r9, 0x198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(408 as u32), ctx.r[9].u32 ) };
	// 82EB85B4: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB85B8: 4BFFDD59  bl 0x82eb6310
	ctx.lr = 0x82EB85BC;
	sub_82EB6310(ctx, base);
	// 82EB85BC: 48000554  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB85C0: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB85C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB85C8: 419800A8  blt cr6, 0x82eb8670
	if ctx.cr[6].lt {
	pc = 0x82EB8670; continue 'dispatch;
	}
	// 82EB85CC: 419A00A4  beq cr6, 0x82eb8670
	if ctx.cr[6].eq {
	pc = 0x82EB8670; continue 'dispatch;
	}
	// 82EB85D0: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB85D4: 480199CD  bl 0x82ed1fa0
	ctx.lr = 0x82EB85D8;
	sub_82ED1FA0(ctx, base);
	// 82EB85D8: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB85DC: 3B7E0014  addi r27, r30, 0x14
	ctx.r[27].s64 = ctx.r[30].s64 + 20;
	// 82EB85E0: 835F0054  lwz r26, 0x54(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB85E4: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82EB85E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB85EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB85F0: C3EB0C14  lfs f31, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB85F4: 41820034  beq 0x82eb8628
	if ctx.cr[0].eq {
	pc = 0x82EB8628; continue 'dispatch;
	}
	// 82EB85F8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB85FC: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8600: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB8604: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8608: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB860C: 4801A73D  bl 0x82ed2d48
	ctx.lr = 0x82EB8610;
	sub_82ED2D48(ctx, base);
	// 82EB8610: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB8614: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8618: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB861C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EB8620: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8624: 4198FFD4  blt cr6, 0x82eb85f8
	if ctx.cr[6].lt {
	pc = 0x82EB85F8; continue 'dispatch;
	}
	// 82EB8628: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB862C: 3B9D0014  addi r28, r29, 0x14
	ctx.r[28].s64 = ctx.r[29].s64 + 20;
	// 82EB8630: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EB8634: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8638: 41820190  beq 0x82eb87c8
	if ctx.cr[0].eq {
	pc = 0x82EB87C8; continue 'dispatch;
	}
	// 82EB863C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8640: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8644: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB8648: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB864C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8650: 4801A6F9  bl 0x82ed2d48
	ctx.lr = 0x82EB8654;
	sub_82ED2D48(ctx, base);
	// 82EB8654: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB8658: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB865C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB8660: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EB8664: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8668: 4198FFD4  blt cr6, 0x82eb863c
	if ctx.cr[6].lt {
	pc = 0x82EB863C; continue 'dispatch;
	}
	// 82EB866C: 4800015C  b 0x82eb87c8
	pc = 0x82EB87C8; continue 'dispatch;
	// 82EB8670: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8674: 4801992D  bl 0x82ed1fa0
	ctx.lr = 0x82EB8678;
	sub_82ED1FA0(ctx, base);
	// 82EB8678: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB867C: 3B7E0014  addi r27, r30, 0x14
	ctx.r[27].s64 = ctx.r[30].s64 + 20;
	// 82EB8680: 835F0054  lwz r26, 0x54(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8684: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82EB8688: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB868C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8690: C3EB0C14  lfs f31, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB8694: 41820034  beq 0x82eb86c8
	if ctx.cr[0].eq {
	pc = 0x82EB86C8; continue 'dispatch;
	}
	// 82EB8698: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB869C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB86A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB86A4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB86A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB86AC: 4801A69D  bl 0x82ed2d48
	ctx.lr = 0x82EB86B0;
	sub_82ED2D48(ctx, base);
	// 82EB86B0: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB86B4: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB86B8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB86BC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EB86C0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB86C4: 4198FFD4  blt cr6, 0x82eb8698
	if ctx.cr[6].lt {
	pc = 0x82EB8698; continue 'dispatch;
	}
	// 82EB86C8: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB86CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB86D0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB86D4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB86D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB86DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB86E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB86E4: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB86E8: 4801A661  bl 0x82ed2d48
	ctx.lr = 0x82EB86EC;
	sub_82ED2D48(ctx, base);
	// 82EB86EC: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB86F0: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB86F4: A15E0010  lhz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB86F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB86FC: 409800CC  bge cr6, 0x82eb87c8
	if !ctx.cr[6].lt {
	pc = 0x82EB87C8; continue 'dispatch;
	}
	// 82EB8700: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8704: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8708: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB870C: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82EB8710: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EB8714: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82EB8718: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82EB871C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8720: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82EB8724: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB8728: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EB872C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB8730: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB8734: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8738: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB873C: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB8740: C02B4DDC  lfs f1, 0x4ddc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19932 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB8744: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8748: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB874C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8750: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB8754: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB8758: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB875C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EB8760: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8764: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB8768: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB876C: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB8770: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EB8774: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8778: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB877C: A0DE0010  lhz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8780: 48019919  bl 0x82ed2098
	ctx.lr = 0x82EB8784;
	sub_82ED2098(ctx, base);
	// 82EB8784: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB8788: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EB878C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8790: 419A0038  beq cr6, 0x82eb87c8
	if ctx.cr[6].eq {
	pc = 0x82EB87C8; continue 'dispatch;
	}
	// 82EB8794: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82EB8798: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB879C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB87A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB87A4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB87A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB87AC: 4801A59D  bl 0x82ed2d48
	ctx.lr = 0x82EB87B0;
	sub_82ED2D48(ctx, base);
	// 82EB87B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB87B4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB87B8: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB87BC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB87C0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB87C4: 4198FFD4  blt cr6, 0x82eb8798
	if ctx.cr[6].lt {
	pc = 0x82EB8798; continue 'dispatch;
	}
	// 82EB87C8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB87CC: 480197F5  bl 0x82ed1fc0
	ctx.lr = 0x82EB87D0;
	sub_82ED1FC0(ctx, base);
	// 82EB87D0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB87D4: 930B01AC  stw r24, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[24].u32 ) };
	// 82EB87D8: 48000338  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB87DC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB87E0: 409A0050  bne cr6, 0x82eb8830
	if !ctx.cr[6].eq {
	pc = 0x82EB8830; continue 'dispatch;
	}
	// 82EB87E4: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB87E8: 4801B069  bl 0x82ed3850
	ctx.lr = 0x82EB87EC;
	sub_82ED3850(ctx, base);
	// 82EB87EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB87F0: 41820014  beq 0x82eb8804
	if ctx.cr[0].eq {
	pc = 0x82EB8804; continue 'dispatch;
	}
	// 82EB87F4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB87F8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EB87FC: 914B01AC  stw r10, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[10].u32 ) };
	// 82EB8800: 48000310  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB8804: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB8808: 4801B0A1  bl 0x82ed38a8
	ctx.lr = 0x82EB880C;
	sub_82ED38A8(ctx, base);
	// 82EB880C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8810: 41820300  beq 0x82eb8b10
	if ctx.cr[0].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8814: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8818: 92EB01AC  stw r23, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[23].u32 ) };
	// 82EB881C: 809C01B0  lwz r4, 0x1b0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB8820: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8824: 4801A70D  bl 0x82ed2f30
	ctx.lr = 0x82EB8828;
	sub_82ED2F30(ctx, base);
	// 82EB8828: 92FC01B0  stw r23, 0x1b0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(432 as u32), ctx.r[23].u32 ) };
	// 82EB882C: 480002E4  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB8830: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB8834: 409A02DC  bne cr6, 0x82eb8b10
	if !ctx.cr[6].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8838: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB883C: 4801B015  bl 0x82ed3850
	ctx.lr = 0x82EB8840;
	sub_82ED3850(ctx, base);
	// 82EB8840: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8844: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8848: 4182FF8C  beq 0x82eb87d4
	if ctx.cr[0].eq {
	pc = 0x82EB87D4; continue 'dispatch;
	}
	// 82EB884C: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8850: 836B01B0  lwz r27, 0x1b0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB8854: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82EB8858: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB885C: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82EB8860: 7FAA582E  lwzx r29, r10, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8864: A13D0012  lhz r9, 0x12(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8868: A15D0010  lhz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB886C: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8870: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB8874: 7F89EA14  add r28, r9, r29
	ctx.r[28].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 82EB8878: A13C0010  lhz r9, 0x10(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB887C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB8880: 409800DC  bge cr6, 0x82eb895c
	if !ctx.cr[6].lt {
	pc = 0x82EB895C; continue 'dispatch;
	}
	// 82EB8884: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8888: 4801B051  bl 0x82ed38d8
	ctx.lr = 0x82EB888C;
	sub_82ED38D8(ctx, base);
	// 82EB888C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8890: 4801D009  bl 0x82ed5898
	ctx.lr = 0x82EB8894;
	sub_82ED5898(ctx, base);
	// 82EB8894: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB8898: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB889C: 409A0014  bne cr6, 0x82eb88b0
	if !ctx.cr[6].eq {
	pc = 0x82EB88B0; continue 'dispatch;
	}
	// 82EB88A0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB88A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB88A8: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB88AC: 48000268  b 0x82eb8b14
	pc = 0x82EB8B14; continue 'dispatch;
	// 82EB88B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB88B4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB88B8: 4801B021  bl 0x82ed38d8
	ctx.lr = 0x82EB88BC;
	sub_82ED38D8(ctx, base);
	// 82EB88BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB88C0: 4082000C  bne 0x82eb88cc
	if !ctx.cr[0].eq {
	pc = 0x82EB88CC; continue 'dispatch;
	}
	// 82EB88C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB88C8: 4800024C  b 0x82eb8b14
	pc = 0x82EB8B14; continue 'dispatch;
	// 82EB88CC: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB88D0: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EB88D4: 419AFFF0  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB88D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB88DC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB88E0: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB88E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB88E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB88EC: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB88F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB88F4: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB88F8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB88FC: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8900: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB8904: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82EB8908: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB890C: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82EB8910: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB8914: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB8918: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB891C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB8920: A11D0010  lhz r8, 0x10(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8924: 4BFFDC85  bl 0x82eb65a8
	ctx.lr = 0x82EB8928;
	sub_82EB65A8(ctx, base);
	// 82EB8928: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB892C: 419AFF98  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB8930: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8934: 408101C0  ble 0x82eb8af4
	if !ctx.cr[0].gt {
	pc = 0x82EB8AF4; continue 'dispatch;
	}
	// 82EB8938: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB893C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8940: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8944: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8948: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB894C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB8950: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB8954: 4082FFE4  bne 0x82eb8938
	if !ctx.cr[0].eq {
	pc = 0x82EB8938; continue 'dispatch;
	}
	// 82EB8958: 4800019C  b 0x82eb8af4
	pc = 0x82EB8AF4; continue 'dispatch;
	// 82EB895C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8960: 409A00DC  bne cr6, 0x82eb8a3c
	if !ctx.cr[6].eq {
	pc = 0x82EB8A3C; continue 'dispatch;
	}
	// 82EB8964: 4801AF75  bl 0x82ed38d8
	ctx.lr = 0x82EB8968;
	sub_82ED38D8(ctx, base);
	// 82EB8968: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB896C: 4182FF34  beq 0x82eb88a0
	if ctx.cr[0].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8970: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8974: 4801CF25  bl 0x82ed5898
	ctx.lr = 0x82EB8978;
	sub_82ED5898(ctx, base);
	// 82EB8978: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB897C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB8980: 419AFF20  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8984: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8988: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB898C: 4801AF4D  bl 0x82ed38d8
	ctx.lr = 0x82EB8990;
	sub_82ED38D8(ctx, base);
	// 82EB8990: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8994: 4182FF0C  beq 0x82eb88a0
	if ctx.cr[0].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8998: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB899C: 4801CEFD  bl 0x82ed5898
	ctx.lr = 0x82EB89A0;
	sub_82ED5898(ctx, base);
	// 82EB89A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB89A4: 2F06FFFF  cmpwi cr6, r6, -1
	ctx.cr[6].compare_i32(ctx.r[6].s32, -1, &mut ctx.xer);
	// 82EB89A8: 419AFEF8  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB89AC: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EB89B0: 419AFEF0  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB89B4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB89B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB89BC: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB89C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB89C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB89C8: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB89CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB89D0: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB89D4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB89D8: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB89DC: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB89E0: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82EB89E4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB89E8: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82EB89EC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB89F0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB89F4: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB89F8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB89FC: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8A00: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82EB8A04: 4BFFDBA5  bl 0x82eb65a8
	ctx.lr = 0x82EB8A08;
	sub_82EB65A8(ctx, base);
	// 82EB8A08: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB8A0C: 419AFE94  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8A10: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8A14: 408100E0  ble 0x82eb8af4
	if !ctx.cr[0].gt {
	pc = 0x82EB8AF4; continue 'dispatch;
	}
	// 82EB8A18: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8A1C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8A20: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8A24: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8A28: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB8A2C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB8A30: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB8A34: 4082FFE4  bne 0x82eb8a18
	if !ctx.cr[0].eq {
	pc = 0x82EB8A18; continue 'dispatch;
	}
	// 82EB8A38: 480000BC  b 0x82eb8af4
	pc = 0x82EB8AF4; continue 'dispatch;
	// 82EB8A3C: 4801AE9D  bl 0x82ed38d8
	ctx.lr = 0x82EB8A40;
	sub_82ED38D8(ctx, base);
	// 82EB8A40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8A44: 4182FE5C  beq 0x82eb88a0
	if ctx.cr[0].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8A48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8A4C: 4801CE4D  bl 0x82ed5898
	ctx.lr = 0x82EB8A50;
	sub_82ED5898(ctx, base);
	// 82EB8A50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB8A54: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB8A58: 419AFE48  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8A5C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8A60: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8A64: 4801AE75  bl 0x82ed38d8
	ctx.lr = 0x82EB8A68;
	sub_82ED38D8(ctx, base);
	// 82EB8A68: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8A6C: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EB8A70: 419AFE54  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB8A74: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8A78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB8A7C: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB8A80: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB8A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8A88: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8A8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB8A90: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB8A94: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8A98: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8A9C: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB8AA0: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82EB8AA4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB8AA8: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82EB8AAC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB8AB0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB8AB4: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB8AB8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB8ABC: A11C0010  lhz r8, 0x10(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8AC0: 4BFFDAE9  bl 0x82eb65a8
	ctx.lr = 0x82EB8AC4;
	sub_82EB65A8(ctx, base);
	// 82EB8AC4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB8AC8: 419AFDFC  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB8ACC: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8AD0: 40810024  ble 0x82eb8af4
	if !ctx.cr[0].gt {
	pc = 0x82EB8AF4; continue 'dispatch;
	}
	// 82EB8AD4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8AD8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8ADC: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8AE0: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8AE4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB8AE8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB8AEC: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB8AF0: 4082FFE4  bne 0x82eb8ad4
	if !ctx.cr[0].eq {
	pc = 0x82EB8AD4; continue 'dispatch;
	}
	// 82EB8AF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB8AF8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8AFC: 4801A435  bl 0x82ed2f30
	ctx.lr = 0x82EB8B00;
	sub_82ED2F30(ctx, base);
	// 82EB8B00: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8B04: 92EB01B0  stw r23, 0x1b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(432 as u32), ctx.r[23].u32 ) };
	// 82EB8B08: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8B0C: 92EB01AC  stw r23, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[23].u32 ) };
	// 82EB8B10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB8B14: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82EB8B18: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EB8B1C: 4BDF0928  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB8B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB8B20 size=1716
    let mut pc: u32 = 0x82EB8B20;
    'dispatch: loop {
        match pc {
            0x82EB8B20 => {
    //   block [0x82EB8B20..0x82EB91D4)
	// 82EB8B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB8B24: 4BDF08BD  bl 0x82ca93e0
	ctx.lr = 0x82EB8B28;
	sub_82CA93D0(ctx, base);
	// 82EB8B28: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 82EB8B2C: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82EB8B30: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82EB8B34: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB8B38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB8B3C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EB8B40: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 82EB8B44: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 82EB8B48: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EB8B4C: 827F0058  lwz r19, 0x58(r31)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB8B50: 2C130000  cmpwi r19, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB8B54: 40820114  bne 0x82eb8c68
	if !ctx.cr[0].eq {
	pc = 0x82EB8C68; continue 'dispatch;
	}
	// 82EB8B58: 3BB20004  addi r29, r18, 4
	ctx.r[29].s64 = ctx.r[18].s64 + 4;
	// 82EB8B5C: C0180000  lfs f0, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8B60: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8B64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8B68: 409A0028  bne cr6, 0x82eb8b90
	if !ctx.cr[6].eq {
	pc = 0x82EB8B90; continue 'dispatch;
	}
	// 82EB8B6C: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8B70: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8B74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8B78: 409A0018  bne cr6, 0x82eb8b90
	if !ctx.cr[6].eq {
	pc = 0x82EB8B90; continue 'dispatch;
	}
	// 82EB8B7C: C0180008  lfs f0, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8B80: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 82EB8B84: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8B88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8B8C: 419A0008  beq cr6, 0x82eb8b94
	if ctx.cr[6].eq {
	pc = 0x82EB8B94; continue 'dispatch;
	}
	// 82EB8B90: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 82EB8B94: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8B98: 4182000C  beq 0x82eb8ba4
	if ctx.cr[0].eq {
	pc = 0x82EB8BA4; continue 'dispatch;
	}
	// 82EB8B9C: 92DF0058  stw r22, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 82EB8BA0: 4800061C  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
	// 82EB8BA4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8BA8: 81630294  lwz r11, 0x294(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(660 as u32) ) } as u64;
	// 82EB8BAC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EB8BB0: 409A060C  bne cr6, 0x82eb91bc
	if !ctx.cr[6].eq {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8BB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB8BB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB8BBC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EB8BC0: 48019C71  bl 0x82ed2830
	ctx.lr = 0x82EB8BC4;
	sub_82ED2830(ctx, base);
	// 82EB8BC4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB8BC8: 40820010  bne 0x82eb8bd8
	if !ctx.cr[0].eq {
	pc = 0x82EB8BD8; continue 'dispatch;
	}
	// 82EB8BCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB8BD0: 929F0198  stw r20, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[20].u32 ) };
	// 82EB8BD4: 480005EC  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
	// 82EB8BD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB8BDC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8BE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8BE4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8BE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB8BEC: C3EBBE10  lfs f31, -0x41f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB8BF0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8BF4: 4801A155  bl 0x82ed2d48
	ctx.lr = 0x82EB8BF8;
	sub_82ED2D48(ctx, base);
	// 82EB8BF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB8BFC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8C00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB8C04: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 82EB8C08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB8C0C: 92DF00F0  stw r22, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[22].u32 ) };
	// 82EB8C10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB8C14: 9ADF00AC  stb r22, 0xac(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[22].u8 ) };
	// 82EB8C18: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EB8C1C: 48019C15  bl 0x82ed2830
	ctx.lr = 0x82EB8C20;
	sub_82ED2830(ctx, base);
	// 82EB8C20: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB8C24: 40820014  bne 0x82eb8c38
	if !ctx.cr[0].eq {
	pc = 0x82EB8C38; continue 'dispatch;
	}
	// 82EB8C28: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB8C2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB8C30: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB8C34: 4800058C  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
	// 82EB8C38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8C3C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8C40: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8C44: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB8C4C: 4801A0FD  bl 0x82ed2d48
	ctx.lr = 0x82EB8C50;
	sub_82ED2D48(ctx, base);
	// 82EB8C50: 907F0108  stw r3, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 82EB8C54: 93DF0104  stw r30, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 82EB8C58: 92DF0150  stw r22, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[22].u32 ) };
	// 82EB8C5C: 9ADF010C  stb r22, 0x10c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[22].u8 ) };
	// 82EB8C60: 92DF0050  stw r22, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 82EB8C64: 929F0058  stw r20, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[20].u32 ) };
	// 82EB8C68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8C6C: 3AA00003  li r21, 3
	ctx.r[21].s64 = 3;
	// 82EB8C70: 2F130001  cmpwi cr6, r19, 1
	ctx.cr[6].compare_i32(ctx.r[19].s32, 1, &mut ctx.xer);
	// 82EB8C74: C3AB0C4C  lfs f29, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB8C78: 409A0210  bne cr6, 0x82eb8e88
	if !ctx.cr[6].eq {
	pc = 0x82EB8E88; continue 'dispatch;
	}
	// 82EB8C7C: 3B320004  addi r25, r18, 4
	ctx.r[25].s64 = ctx.r[18].s64 + 4;
	// 82EB8C80: C1B80008  lfs f13, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8C84: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8C88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8C8C: C1980000  lfs f12, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB8C90: 83BF0050  lwz r29, 0x50(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB8C94: 3AFF005C  addi r23, r31, 0x5c
	ctx.r[23].s64 = ctx.r[31].s64 + 92;
	// 82EB8C98: C1590008  lfs f10, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB8C9C: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB8CA0: C1790004  lfs f11, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB8CA4: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB8CA8: C1790000  lfs f11, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB8CAC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB8CB0: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB8CB4: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB8CB8: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8CBC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB8CC0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB8CC4: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB8CC8: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82EB8CCC: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB8CD0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EB8CD4: 811F0060  lwz r8, 0x60(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB8CD8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB8CDC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8CE0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EB8CE4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8CE8: 92D70000  stw r22, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 82EB8CEC: 9AC10057  stb r22, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[22].u8 ) };
	// 82EB8CF0: 4801A499  bl 0x82ed3188
	ctx.lr = 0x82EB8CF4;
	sub_82ED3188(ctx, base);
	// 82EB8CF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB8CF8: 419A016C  beq cr6, 0x82eb8e64
	if ctx.cr[6].eq {
	pc = 0x82EB8E64; continue 'dispatch;
	}
	// 82EB8CFC: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 82EB8D00: 1D7D0060  mulli r11, r29, 0x60
	ctx.r[11].s64 = ctx.r[29].s64 * 96;
	// 82EB8D04: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82EB8D08: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB8D0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB8D10: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EB8D14: 3B7E00F0  addi r27, r30, 0xf0
	ctx.r[27].s64 = ctx.r[30].s64 + 240;
	// 82EB8D18: 3B5E00B0  addi r26, r30, 0xb0
	ctx.r[26].s64 = ctx.r[30].s64 + 176;
	// 82EB8D1C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 82EB8D20: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB8D24: 92DE00F0  stw r22, 0xf0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), ctx.r[22].u32 ) };
	// 82EB8D28: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8D2C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EB8D30: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D34: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EB8D38: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EB8D3C: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EB8D40: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EB8D44: FFC06818  frsp f30, f13
	ctx.f[30].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EB8D48: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8D4C: 4801934D  bl 0x82ed2098
	ctx.lr = 0x82EB8D50;
	sub_82ED2098(ctx, base);
	// 82EB8D50: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D54: 4801924D  bl 0x82ed1fa0
	ctx.lr = 0x82EB8D58;
	sub_82ED1FA0(ctx, base);
	// 82EB8D58: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EB8D5C: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EB8D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8D64: 40990034  ble cr6, 0x82eb8d98
	if !ctx.cr[6].gt {
	pc = 0x82EB8D98; continue 'dispatch;
	}
	// 82EB8D68: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8D6C: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8D70: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8D74: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D78: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82EB8D7C: 48019FCD  bl 0x82ed2d48
	ctx.lr = 0x82EB8D80;
	sub_82ED2D48(ctx, base);
	// 82EB8D80: 907E00A8  stw r3, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[3].u32 ) };
	// 82EB8D84: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8D88: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8D8C: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EB8D90: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8D94: 4198FFD4  blt cr6, 0x82eb8d68
	if ctx.cr[6].lt {
	pc = 0x82EB8D68; continue 'dispatch;
	}
	// 82EB8D98: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D9C: 48019225  bl 0x82ed1fc0
	ctx.lr = 0x82EB8DA0;
	sub_82ED1FC0(ctx, base);
	// 82EB8DA0: 3B7E0150  addi r27, r30, 0x150
	ctx.r[27].s64 = ctx.r[30].s64 + 336;
	// 82EB8DA4: 92DE00A4  stw r22, 0xa4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[22].u32 ) };
	// 82EB8DA8: 3B5E0110  addi r26, r30, 0x110
	ctx.r[26].s64 = ctx.r[30].s64 + 272;
	// 82EB8DAC: 9ADE00AC  stb r22, 0xac(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[22].u8 ) };
	// 82EB8DB0: 92DE0150  stw r22, 0x150(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(336 as u32), ctx.r[22].u32 ) };
	// 82EB8DB4: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8DB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB8DBC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8DC0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EB8DC4: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8DC8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB8DCC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EB8DD0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EB8DD4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EB8DD8: 480192C1  bl 0x82ed2098
	ctx.lr = 0x82EB8DDC;
	sub_82ED2098(ctx, base);
	// 82EB8DDC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8DE0: 480191C1  bl 0x82ed1fa0
	ctx.lr = 0x82EB8DE4;
	sub_82ED1FA0(ctx, base);
	// 82EB8DE4: 817E0150  lwz r11, 0x150(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 82EB8DE8: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EB8DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8DF0: 40990034  ble cr6, 0x82eb8e24
	if !ctx.cr[6].gt {
	pc = 0x82EB8E24; continue 'dispatch;
	}
	// 82EB8DF4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8DF8: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8DFC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8E00: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8E04: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82EB8E08: 48019F41  bl 0x82ed2d48
	ctx.lr = 0x82EB8E0C;
	sub_82ED2D48(ctx, base);
	// 82EB8E0C: 907E0108  stw r3, 0x108(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 82EB8E10: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E14: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8E18: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EB8E1C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8E20: 4198FFD4  blt cr6, 0x82eb8df4
	if ctx.cr[6].lt {
	pc = 0x82EB8DF4; continue 'dispatch;
	}
	// 82EB8E24: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8E28: 48019199  bl 0x82ed1fc0
	ctx.lr = 0x82EB8E2C;
	sub_82ED1FC0(ctx, base);
	// 82EB8E2C: 92DE0104  stw r22, 0x104(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(260 as u32), ctx.r[22].u32 ) };
	// 82EB8E30: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EB8E34: 9ADE010C  stb r22, 0x10c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(268 as u32), ctx.r[22].u8 ) };
	// 82EB8E38: 80B70000  lwz r5, 0(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E3C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8E40: 480190C9  bl 0x82ed1f08
	ctx.lr = 0x82EB8E44;
	sub_82ED1F08(ctx, base);
	// 82EB8E44: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E48: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 82EB8E4C: 40990008  ble cr6, 0x82eb8e54
	if !ctx.cr[6].gt {
	pc = 0x82EB8E54; continue 'dispatch;
	}
	// 82EB8E50: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82EB8E54: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82EB8E58: 40990018  ble cr6, 0x82eb8e70
	if !ctx.cr[6].gt {
	pc = 0x82EB8E70; continue 'dispatch;
	}
	// 82EB8E5C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB8E60: 4BFFFE68  b 0x82eb8cc8
	pc = 0x82EB8CC8; continue 'dispatch;
	// 82EB8E64: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E68: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82EB8E6C: 4BFFFFD0  b 0x82eb8e3c
	pc = 0x82EB8E3C; continue 'dispatch;
	// 82EB8E70: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB8E74: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EB8E78: 93BF0168  stw r29, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[29].u32 ) };
	// 82EB8E7C: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EB8E80: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82EB8E84: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 82EB8E88: 2F130002  cmpwi cr6, r19, 2
	ctx.cr[6].compare_i32(ctx.r[19].s32, 2, &mut ctx.xer);
	// 82EB8E8C: 409A0084  bne cr6, 0x82eb8f10
	if !ctx.cr[6].eq {
	pc = 0x82EB8F10; continue 'dispatch;
	}
	// 82EB8E90: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB8E94: 3BBF016C  addi r29, r31, 0x16c
	ctx.r[29].s64 = ctx.r[31].s64 + 364;
	// 82EB8E98: 815F0168  lwz r10, 0x168(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB8E9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB8EA0: 41990020  bgt cr6, 0x82eb8ec0
	if ctx.cr[6].gt {
	pc = 0x82EB8EC0; continue 'dispatch;
	}
	// 82EB8EA4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB8EA8: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82EB8EAC: 38DF0170  addi r6, r31, 0x170
	ctx.r[6].s64 = ctx.r[31].s64 + 368;
	// 82EB8EB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB8EB4: 389F00A4  addi r4, r31, 0xa4
	ctx.r[4].s64 = ctx.r[31].s64 + 164;
	// 82EB8EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8EBC: 4BFFECC5  bl 0x82eb7b80
	ctx.lr = 0x82EB8EC0;
	sub_82EB7B80(ctx, base);
	// 82EB8EC0: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EB8EC4: 3BDF0174  addi r30, r31, 0x174
	ctx.r[30].s64 = ctx.r[31].s64 + 372;
	// 82EB8EC8: 815F0168  lwz r10, 0x168(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB8ECC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB8ED0: 41990020  bgt cr6, 0x82eb8ef0
	if ctx.cr[6].gt {
	pc = 0x82EB8EF0; continue 'dispatch;
	}
	// 82EB8ED4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB8ED8: 38F20004  addi r7, r18, 4
	ctx.r[7].s64 = ctx.r[18].s64 + 4;
	// 82EB8EDC: 38DF0178  addi r6, r31, 0x178
	ctx.r[6].s64 = ctx.r[31].s64 + 376;
	// 82EB8EE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB8EE4: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 82EB8EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8EEC: 4BFFEC95  bl 0x82eb7b80
	ctx.lr = 0x82EB8EF0;
	sub_82EB7B80(ctx, base);
	// 82EB8EF0: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB8EF4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8EF8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8EFC: 409902C0  ble cr6, 0x82eb91bc
	if !ctx.cr[6].gt {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8F00: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8F04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8F08: 409902B4  ble cr6, 0x82eb91bc
	if !ctx.cr[6].gt {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8F0C: 92BF0058  stw r21, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 82EB8F10: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 82EB8F14: 2F130003  cmpwi cr6, r19, 3
	ctx.cr[6].compare_i32(ctx.r[19].s32, 3, &mut ctx.xer);
	// 82EB8F18: 409A006C  bne cr6, 0x82eb8f84
	if !ctx.cr[6].eq {
	pc = 0x82EB8F84; continue 'dispatch;
	}
	// 82EB8F1C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8F20: 92DF017C  stw r22, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[22].u32 ) };
	// 82EB8F24: 4801907D  bl 0x82ed1fa0
	ctx.lr = 0x82EB8F28;
	sub_82ED1FA0(ctx, base);
	// 82EB8F28: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB8F2C: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 82EB8F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8F34: 40990044  ble cr6, 0x82eb8f78
	if !ctx.cr[6].gt {
	pc = 0x82EB8F78; continue 'dispatch;
	}
	// 82EB8F38: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB8F3C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB8F40: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8F44: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8F48: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8F4C: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82EB8F50: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8F54: 48019DF5  bl 0x82ed2d48
	ctx.lr = 0x82EB8F58;
	sub_82ED2D48(ctx, base);
	// 82EB8F58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8F5C: 907F017C  stw r3, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[3].u32 ) };
	// 82EB8F60: 41820048  beq 0x82eb8fa8
	if ctx.cr[0].eq {
	pc = 0x82EB8FA8; continue 'dispatch;
	}
	// 82EB8F64: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB8F68: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB8F6C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EB8F70: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8F74: 4198FFC8  blt cr6, 0x82eb8f3c
	if ctx.cr[6].lt {
	pc = 0x82EB8F3C; continue 'dispatch;
	}
	// 82EB8F78: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8F7C: 48019045  bl 0x82ed1fc0
	ctx.lr = 0x82EB8F80;
	sub_82ED1FC0(ctx, base);
	// 82EB8F80: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB8F84: 2F130004  cmpwi cr6, r19, 4
	ctx.cr[6].compare_i32(ctx.r[19].s32, 4, &mut ctx.xer);
	// 82EB8F88: 409A0050  bne cr6, 0x82eb8fd8
	if !ctx.cr[6].eq {
	pc = 0x82EB8FD8; continue 'dispatch;
	}
	// 82EB8F8C: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8F90: 4801A8C1  bl 0x82ed3850
	ctx.lr = 0x82EB8F94;
	sub_82ED3850(ctx, base);
	// 82EB8F94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8F98: 41820018  beq 0x82eb8fb0
	if ctx.cr[0].eq {
	pc = 0x82EB8FB0; continue 'dispatch;
	}
	// 82EB8F9C: 3A600007  li r19, 7
	ctx.r[19].s64 = 7;
	// 82EB8FA0: 927F0058  stw r19, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[19].u32 ) };
	// 82EB8FA4: 4800003C  b 0x82eb8fe0
	pc = 0x82EB8FE0; continue 'dispatch;
	// 82EB8FA8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB8FAC: 4BFFFC80  b 0x82eb8c2c
	pc = 0x82EB8C2C; continue 'dispatch;
	// 82EB8FB0: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8FB4: 4801A8F5  bl 0x82ed38a8
	ctx.lr = 0x82EB8FB8;
	sub_82ED38A8(ctx, base);
	// 82EB8FB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8FBC: 41820200  beq 0x82eb91bc
	if ctx.cr[0].eq {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8FC0: 809F017C  lwz r4, 0x17c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8FC4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8FC8: 48019F69  bl 0x82ed2f30
	ctx.lr = 0x82EB8FCC;
	sub_82ED2F30(ctx, base);
	// 82EB8FCC: 92DF017C  stw r22, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[22].u32 ) };
	// 82EB8FD0: 92BF0058  stw r21, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 82EB8FD4: 480001E8  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
	// 82EB8FD8: 2F130007  cmpwi cr6, r19, 7
	ctx.cr[6].compare_i32(ctx.r[19].s32, 7, &mut ctx.xer);
	// 82EB8FDC: 409A01CC  bne cr6, 0x82eb91a8
	if !ctx.cr[6].eq {
	pc = 0x82EB91A8; continue 'dispatch;
	}
	// 82EB8FE0: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8FE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8FE8: 418201D8  beq 0x82eb91c0
	if ctx.cr[0].eq {
	pc = 0x82EB91C0; continue 'dispatch;
	}
	// 82EB8FEC: 4801A865  bl 0x82ed3850
	ctx.lr = 0x82EB8FF0;
	sub_82ED3850(ctx, base);
	// 82EB8FF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8FF4: 4082000C  bne 0x82eb9000
	if !ctx.cr[0].eq {
	pc = 0x82EB9000; continue 'dispatch;
	}
	// 82EB8FF8: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB8FFC: 480001C0  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
	// 82EB9000: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB9004: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9008: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB900C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB9010: 808B0100  lwz r4, 0x100(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) } as u64;
	// 82EB9014: 4801A8C5  bl 0x82ed38d8
	ctx.lr = 0x82EB9018;
	sub_82ED38D8(ctx, base);
	// 82EB9018: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB901C: 40820010  bne 0x82eb902c
	if !ctx.cr[0].eq {
	pc = 0x82EB902C; continue 'dispatch;
	}
	// 82EB9020: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9024: 939F0198  stw r28, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[28].u32 ) };
	// 82EB9028: 48000198  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
	// 82EB902C: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB9030: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9034: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB9038: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB903C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9040: 808B0160  lwz r4, 0x160(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB9044: 4801A895  bl 0x82ed38d8
	ctx.lr = 0x82EB9048;
	sub_82ED38D8(ctx, base);
	// 82EB9048: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB904C: 4182FFD4  beq 0x82eb9020
	if ctx.cr[0].eq {
	pc = 0x82EB9020; continue 'dispatch;
	}
	// 82EB9050: 809F017C  lwz r4, 0x17c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9054: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EB9058: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB905C: 811F0168  lwz r8, 0x168(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB9060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9064: 80C40004  lwz r6, 4(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9068: 4BFFD541  bl 0x82eb65a8
	ctx.lr = 0x82EB906C;
	sub_82EB65A8(ctx, base);
	// 82EB906C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB9070: 809F017C  lwz r4, 0x17c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9074: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9078: 48019EB9  bl 0x82ed2f30
	ctx.lr = 0x82EB907C;
	sub_82ED2F30(ctx, base);
	// 82EB907C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB9080: 92DF017C  stw r22, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[22].u32 ) };
	// 82EB9084: 409A0038  bne cr6, 0x82eb90bc
	if !ctx.cr[6].eq {
	pc = 0x82EB90BC; continue 'dispatch;
	}
	// 82EB9088: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB908C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9090: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB9094: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EB9098: 48018E21  bl 0x82ed1eb8
	ctx.lr = 0x82EB909C;
	sub_82ED1EB8(ctx, base);
	// 82EB909C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB90A0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB90A4: 40990010  ble cr6, 0x82eb90b4
	if !ctx.cr[6].gt {
	pc = 0x82EB90B4; continue 'dispatch;
	}
	// 82EB90A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB90AC: 92BF0198  stw r21, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[21].u32 ) };
	// 82EB90B0: 48000110  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
	// 82EB90B4: 929F0058  stw r20, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[20].u32 ) };
	// 82EB90B8: 48000104  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
	// 82EB90BC: 813F0168  lwz r9, 0x168(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB90C0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB90C4: 408100AC  ble 0x82eb9170
	if !ctx.cr[0].gt {
	pc = 0x82EB9170; continue 'dispatch;
	}
	// 82EB90C8: 1D690060  mulli r11, r9, 0x60
	ctx.r[11].s64 = ctx.r[9].s64 * 96;
	// 82EB90CC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB90D0: 394B015C  addi r10, r11, 0x15c
	ctx.r[10].s64 = ctx.r[11].s64 + 348;
	// 82EB90D4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB90D8: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 82EB90DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB90E0: 38EB0014  addi r7, r11, 0x14
	ctx.r[7].s64 = ctx.r[11].s64 + 20;
	// 82EB90E4: B12B0010  sth r9, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u16 ) };
	// 82EB90E8: C00AFFF8  lfs f0, -8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB90EC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB90F0: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB90F4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB90F8: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB90FC: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9100: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9104: B2CB0012  sth r22, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[22].u16 ) };
	// 82EB9108: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82EB910C: 80CAFFF4  lwz r6, -0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EB9110: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EB9114: 40990034  ble cr6, 0x82eb9148
	if !ctx.cr[6].gt {
	pc = 0x82EB9148; continue 'dispatch;
	}
	// 82EB9118: 38CAFFB4  addi r6, r10, -0x4c
	ctx.r[6].s64 = ctx.r[10].s64 + -76;
	// 82EB911C: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB9120: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB9124: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB9128: 90A70000  stw r5, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82EB912C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EB9130: A0AB0012  lhz r5, 0x12(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB9134: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB9138: B0AB0012  sth r5, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[5].u16 ) };
	// 82EB913C: 80AAFFF4  lwz r5, -0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EB9140: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB9144: 4198FFD8  blt cr6, 0x82eb911c
	if ctx.cr[6].lt {
	pc = 0x82EB911C; continue 'dispatch;
	}
	// 82EB9148: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB914C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB9150: 394AFFA0  addi r10, r10, -0x60
	ctx.r[10].s64 = ctx.r[10].s64 + -96;
	// 82EB9154: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB9158: A0E80012  lhz r7, 0x12(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB915C: 38E70005  addi r7, r7, 5
	ctx.r[7].s64 = ctx.r[7].s64 + 5;
	// 82EB9160: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EB9164: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82EB9168: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EB916C: 4181FF68  bgt 0x82eb90d4
	if ctx.cr[0].gt {
	pc = 0x82EB90D4; continue 'dispatch;
	}
	// 82EB9170: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9174: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82EB9178: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB917C: B2CB0010  sth r22, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[22].u16 ) };
	// 82EB9180: C01F0154  lfs f0, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9184: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9188: C01F0158  lfs f0, 0x158(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB918C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9190: C01F015C  lfs f0, 0x15c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9194: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9198: 813F0160  lwz r9, 0x160(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB919C: B2CB0012  sth r22, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[22].u16 ) };
	// 82EB91A0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB91A4: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EB91A8: 2F130008  cmpwi cr6, r19, 8
	ctx.cr[6].compare_i32(ctx.r[19].s32, 8, &mut ctx.xer);
	// 82EB91AC: 409A0010  bne cr6, 0x82eb91bc
	if !ctx.cr[6].eq {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB91B0: 38920004  addi r4, r18, 4
	ctx.r[4].s64 = ctx.r[18].s64 + 4;
	// 82EB91B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB91B8: 4BFFF191  bl 0x82eb8348
	ctx.lr = 0x82EB91BC;
	sub_82EB8348(ctx, base);
	// 82EB91BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB91C0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82EB91C4: CBA1FF70  lfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82EB91C8: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82EB91CC: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82EB91D0: 4BDF0260  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB91D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB91D8 size=180
    let mut pc: u32 = 0x82EB91D8;
    'dispatch: loop {
        match pc {
            0x82EB91D8 => {
    //   block [0x82EB91D8..0x82EB928C)
	// 82EB91D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB91DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB91E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB91E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB91E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB91EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB91F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB91F4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB91F8: 4099007C  ble cr6, 0x82eb9274
	if !ctx.cr[6].gt {
	pc = 0x82EB9274; continue 'dispatch;
	}
	// 82EB91FC: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82EB9200: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82EB9204: 5483103A  slwi r3, r4, 2
	ctx.r[3].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EB9208: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EB920C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB9210: 40990008  ble cr6, 0x82eb9218
	if !ctx.cr[6].gt {
	pc = 0x82EB9218; continue 'dispatch;
	}
	// 82EB9214: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EB9218: 4B75D711  bl 0x82616928
	ctx.lr = 0x82EB921C;
	sub_82616928(ctx, base);
	// 82EB921C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9220: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB9224: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB9228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB922C: 40990028  ble cr6, 0x82eb9254
	if !ctx.cr[6].gt {
	pc = 0x82EB9254; continue 'dispatch;
	}
	// 82EB9230: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9234: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9238: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB923C: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB9240: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82EB9244: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB9248: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB924C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB9250: 4198FFE4  blt cr6, 0x82eb9234
	if ctx.cr[6].lt {
	pc = 0x82EB9234; continue 'dispatch;
	}
	// 82EB9254: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9258: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB925C: 41820014  beq 0x82eb9270
	if ctx.cr[0].eq {
	pc = 0x82EB9270; continue 'dispatch;
	}
	// 82EB9260: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB9264: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB9268: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB926C: 4E800421  bctrl
	ctx.lr = 0x82EB9270;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB9270: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EB9274: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB9278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB927C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB9280: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB9284: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB9288: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB9290 size=240
    let mut pc: u32 = 0x82EB9290;
    'dispatch: loop {
        match pc {
            0x82EB9290 => {
    //   block [0x82EB9290..0x82EB9380)
	// 82EB9290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9294: 4BDF0179  bl 0x82ca940c
	ctx.lr = 0x82EB9298;
	sub_82CA93D0(ctx, base);
	// 82EB9298: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB929C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB92A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EB92A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB92A8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB92AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB92B0: 409A00A8  bne cr6, 0x82eb9358
	if !ctx.cr[6].eq {
	pc = 0x82EB9358; continue 'dispatch;
	}
	// 82EB92B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB92B8: 409A000C  bne cr6, 0x82eb92c4
	if !ctx.cr[6].eq {
	pc = 0x82EB92C4; continue 'dispatch;
	}
	// 82EB92BC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB92C0: 48000008  b 0x82eb92c8
	pc = 0x82EB92C8; continue 'dispatch;
	// 82EB92C4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB92C8: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EB92CC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB92D0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB92D4: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EB92D8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EB92DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB92E0: 40990008  ble cr6, 0x82eb92e8
	if !ctx.cr[6].gt {
	pc = 0x82EB92E8; continue 'dispatch;
	}
	// 82EB92E4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EB92E8: 4B75D641  bl 0x82616928
	ctx.lr = 0x82EB92EC;
	sub_82616928(ctx, base);
	// 82EB92EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB92F0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB92F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB92F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB92FC: 40990008  ble cr6, 0x82eb9304
	if !ctx.cr[6].gt {
	pc = 0x82EB9304; continue 'dispatch;
	}
	// 82EB9300: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EB9304: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9308: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB930C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB9310: 40990028  ble cr6, 0x82eb9338
	if !ctx.cr[6].gt {
	pc = 0x82EB9338; continue 'dispatch;
	}
	// 82EB9314: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9318: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB931C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB9320: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB9324: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82EB9328: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB932C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9330: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB9334: 4198FFE4  blt cr6, 0x82eb9318
	if ctx.cr[6].lt {
	pc = 0x82EB9318; continue 'dispatch;
	}
	// 82EB9338: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB933C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9340: 41820014  beq 0x82eb9354
	if ctx.cr[0].eq {
	pc = 0x82EB9354; continue 'dispatch;
	}
	// 82EB9344: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB9348: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB934C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB9350: 4E800421  bctrl
	ctx.lr = 0x82EB9354;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB9354: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EB9358: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB935C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB9360: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9364: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB9368: 7D49592E  stwx r10, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82EB936C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9370: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB9374: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EB9378: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB937C: 4BDF00E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB9380 size=92
    let mut pc: u32 = 0x82EB9380;
    'dispatch: loop {
        match pc {
            0x82EB9380 => {
    //   block [0x82EB9380..0x82EB93DC)
	// 82EB9380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB9388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB938C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB9394: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB9398: 396BA8F0  addi r11, r11, -0x5710
	ctx.r[11].s64 = ctx.r[11].s64 + -22288;
	// 82EB939C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB93A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB93A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB93A8: 41820014  beq 0x82eb93bc
	if ctx.cr[0].eq {
	pc = 0x82EB93BC; continue 'dispatch;
	}
	// 82EB93AC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB93B0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB93B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB93B8: 4E800421  bctrl
	ctx.lr = 0x82EB93BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB93BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB93C0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB93C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB93C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB93CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB93D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB93D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB93D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB93E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB93E0 size=88
    let mut pc: u32 = 0x82EB93E0;
    'dispatch: loop {
        match pc {
            0x82EB93E0 => {
    //   block [0x82EB93E0..0x82EB9438)
	// 82EB93E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB93E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB93E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB93EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB93F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB93F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB93F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB93FC: 4BFFFF85  bl 0x82eb9380
	ctx.lr = 0x82EB9400;
	sub_82EB9380(ctx, base);
	// 82EB9400: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9404: 41820018  beq 0x82eb941c
	if ctx.cr[0].eq {
	pc = 0x82EB941C; continue 'dispatch;
	}
	// 82EB9408: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB940C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9410: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB9414: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB9418: 4E800421  bctrl
	ctx.lr = 0x82EB941C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB941C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB9424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB9428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB942C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB9430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB9434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB9438 size=1716
    let mut pc: u32 = 0x82EB9438;
    'dispatch: loop {
        match pc {
            0x82EB9438 => {
    //   block [0x82EB9438..0x82EB9AEC)
	// 82EB9438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB943C: 4BDEFFB9  bl 0x82ca93f4
	ctx.lr = 0x82EB9440;
	sub_82CA93D0(ctx, base);
	// 82EB9440: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82EB9444: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB944C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82EB9450: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB9454: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB9458: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB945C: 837F0058  lwz r27, 0x58(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB9460: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB9464: 409A004C  bne cr6, 0x82eb94b0
	if !ctx.cr[6].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB9468: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB946C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9470: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB9474: 419A003C  beq cr6, 0x82eb94b0
	if ctx.cr[6].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB9478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB947C: 419A0034  beq cr6, 0x82eb94b0
	if ctx.cr[6].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB9480: 4801A3D1  bl 0x82ed3850
	ctx.lr = 0x82EB9484;
	sub_82ED3850(ctx, base);
	// 82EB9484: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9488: 41820028  beq 0x82eb94b0
	if ctx.cr[0].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB948C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9490: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9494: 41820010  beq 0x82eb94a4
	if ctx.cr[0].eq {
	pc = 0x82EB94A4; continue 'dispatch;
	}
	// 82EB9498: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB949C: 48019A95  bl 0x82ed2f30
	ctx.lr = 0x82EB94A0;
	sub_82ED2F30(ctx, base);
	// 82EB94A0: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EB94A4: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB94A8: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82EB94AC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EB94B0: 3B5E0004  addi r26, r30, 4
	ctx.r[26].s64 = ctx.r[30].s64 + 4;
	// 82EB94B4: C0190000  lfs f0, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB94B8: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82EB94BC: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB94C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB94C4: 409A0028  bne cr6, 0x82eb94ec
	if !ctx.cr[6].eq {
	pc = 0x82EB94EC; continue 'dispatch;
	}
	// 82EB94C8: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB94CC: C1BA0004  lfs f13, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB94D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB94D4: 409A0018  bne cr6, 0x82eb94ec
	if !ctx.cr[6].eq {
	pc = 0x82EB94EC; continue 'dispatch;
	}
	// 82EB94D8: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB94DC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82EB94E0: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB94E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB94E8: 419A0008  beq cr6, 0x82eb94f0
	if ctx.cr[6].eq {
	pc = 0x82EB94F0; continue 'dispatch;
	}
	// 82EB94EC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EB94F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB94F4: 4182000C  beq 0x82eb9500
	if ctx.cr[0].eq {
	pc = 0x82EB9500; continue 'dispatch;
	}
	// 82EB94F8: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB94FC: 480005E0  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
	// 82EB9500: 3AE00004  li r23, 4
	ctx.r[23].s64 = 4;
	// 82EB9504: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EB9508: 409A000C  bne cr6, 0x82eb9514
	if !ctx.cr[6].eq {
	pc = 0x82EB9514; continue 'dispatch;
	}
	// 82EB950C: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82EB9510: 92FF0058  stw r23, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82EB9514: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 82EB9518: 409A0080  bne cr6, 0x82eb9598
	if !ctx.cr[6].eq {
	pc = 0x82EB9598; continue 'dispatch;
	}
	// 82EB951C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9520: 48018A81  bl 0x82ed1fa0
	ctx.lr = 0x82EB9524;
	sub_82ED1FA0(ctx, base);
	// 82EB9524: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB9528: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EB952C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB9530: 4099005C  ble cr6, 0x82eb958c
	if !ctx.cr[6].gt {
	pc = 0x82EB958C; continue 'dispatch;
	}
	// 82EB9534: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB9538: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EB953C: C3EB0C4C  lfs f31, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB9540: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB9544: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB9548: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB954C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9550: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB9554: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EB9558: 480197F1  bl 0x82ed2d48
	ctx.lr = 0x82EB955C;
	sub_82ED2D48(ctx, base);
	// 82EB955C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9560: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EB9564: 40820014  bne 0x82eb9578
	if !ctx.cr[0].eq {
	pc = 0x82EB9578; continue 'dispatch;
	}
	// 82EB9568: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB956C: 48018A55  bl 0x82ed1fc0
	ctx.lr = 0x82EB9570;
	sub_82ED1FC0(ctx, base);
	// 82EB9570: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB9574: 939F005C  stw r28, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82EB9578: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB957C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB9580: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EB9584: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB9588: 4198FFB8  blt cr6, 0x82eb9540
	if ctx.cr[6].lt {
	pc = 0x82EB9540; continue 'dispatch;
	}
	// 82EB958C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9590: 48018A31  bl 0x82ed1fc0
	ctx.lr = 0x82EB9594;
	sub_82ED1FC0(ctx, base);
	// 82EB9594: 92FF0058  stw r23, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82EB9598: 3BA00007  li r29, 7
	ctx.r[29].s64 = 7;
	// 82EB959C: 2F1B0004  cmpwi cr6, r27, 4
	ctx.cr[6].compare_i32(ctx.r[27].s32, 4, &mut ctx.xer);
	// 82EB95A0: 409A00A8  bne cr6, 0x82eb9648
	if !ctx.cr[6].eq {
	pc = 0x82EB9648; continue 'dispatch;
	}
	// 82EB95A4: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB95A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB95AC: 41820530  beq 0x82eb9adc
	if ctx.cr[0].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB95B0: 4801A2A1  bl 0x82ed3850
	ctx.lr = 0x82EB95B4;
	sub_82ED3850(ctx, base);
	// 82EB95B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB95B8: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB95BC: 41820020  beq 0x82eb95dc
	if ctx.cr[0].eq {
	pc = 0x82EB95DC; continue 'dispatch;
	}
	// 82EB95C0: 3B600005  li r27, 5
	ctx.r[27].s64 = 5;
	// 82EB95C4: 809F0094  lwz r4, 0x94(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB95C8: 937F0058  stw r27, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82EB95CC: 4801A175  bl 0x82ed3740
	ctx.lr = 0x82EB95D0;
	sub_82ED3740(ctx, base);
	// 82EB95D0: 9B9F007D  stb r28, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[28].u8 ) };
	// 82EB95D4: 939F0198  stw r28, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[28].u32 ) };
	// 82EB95D8: 48000080  b 0x82eb9658
	pc = 0x82EB9658; continue 'dispatch;
	// 82EB95DC: 4801A2CD  bl 0x82ed38a8
	ctx.lr = 0x82EB95E0;
	sub_82ED38A8(ctx, base);
	// 82EB95E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB95E4: 4182002C  beq 0x82eb9610
	if ctx.cr[0].eq {
	pc = 0x82EB9610; continue 'dispatch;
	}
	// 82EB95E8: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB95EC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB95F0: 409A0010  bne cr6, 0x82eb9600
	if !ctx.cr[6].eq {
	pc = 0x82EB9600; continue 'dispatch;
	}
	// 82EB95F4: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB95F8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB95FC: 48019935  bl 0x82ed2f30
	ctx.lr = 0x82EB9600;
	sub_82ED2F30(ctx, base);
	// 82EB9600: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82EB9604: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EB9608: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB960C: 480004D0  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
	// 82EB9610: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9614: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9618: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82EB961C: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB9620: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB9624: 409A04B8  bne cr6, 0x82eb9adc
	if !ctx.cr[6].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB9628: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB962C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9630: 4182000C  beq 0x82eb963c
	if ctx.cr[0].eq {
	pc = 0x82EB963C; continue 'dispatch;
	}
	// 82EB9634: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9638: 480198F9  bl 0x82ed2f30
	ctx.lr = 0x82EB963C;
	sub_82ED2F30(ctx, base);
	// 82EB963C: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EB9640: 939F005C  stw r28, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82EB9644: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB9648: 2F1B0005  cmpwi cr6, r27, 5
	ctx.cr[6].compare_i32(ctx.r[27].s32, 5, &mut ctx.xer);
	// 82EB964C: 419A000C  beq cr6, 0x82eb9658
	if ctx.cr[6].eq {
	pc = 0x82EB9658; continue 'dispatch;
	}
	// 82EB9650: 2F1B0006  cmpwi cr6, r27, 6
	ctx.cr[6].compare_i32(ctx.r[27].s32, 6, &mut ctx.xer);
	// 82EB9654: 409A0180  bne cr6, 0x82eb97d4
	if !ctx.cr[6].eq {
	pc = 0x82EB97D4; continue 'dispatch;
	}
	// 82EB9658: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB965C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9660: 4082000C  bne 0x82eb966c
	if !ctx.cr[0].eq {
	pc = 0x82EB966C; continue 'dispatch;
	}
	// 82EB9664: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9668: 48000478  b 0x82eb9ae0
	pc = 0x82EB9AE0; continue 'dispatch;
	// 82EB966C: 4801A1E5  bl 0x82ed3850
	ctx.lr = 0x82EB9670;
	sub_82ED3850(ctx, base);
	// 82EB9670: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9674: 41820464  beq 0x82eb9ad8
	if ctx.cr[0].eq {
	pc = 0x82EB9AD8; continue 'dispatch;
	}
	// 82EB9678: 897F007D  lbz r11, 0x7d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(125 as u32) ) } as u64;
	// 82EB967C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB9680: 409A0018  bne cr6, 0x82eb9698
	if !ctx.cr[6].eq {
	pc = 0x82EB9698; continue 'dispatch;
	}
	// 82EB9684: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB9688: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB968C: 419AFFD8  beq cr6, 0x82eb9664
	if ctx.cr[6].eq {
	pc = 0x82EB9664; continue 'dispatch;
	}
	// 82EB9690: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB9694: 419AFFD0  beq cr6, 0x82eb9664
	if ctx.cr[6].eq {
	pc = 0x82EB9664; continue 'dispatch;
	}
	// 82EB9698: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB969C: 9B1F007D  stb r24, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[24].u8 ) };
	// 82EB96A0: 3BDF0090  addi r30, r31, 0x90
	ctx.r[30].s64 = ctx.r[31].s64 + 144;
	// 82EB96A4: 2F1B0005  cmpwi cr6, r27, 5
	ctx.cr[6].compare_i32(ctx.r[27].s32, 5, &mut ctx.xer);
	// 82EB96A8: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EB96AC: 409A0008  bne cr6, 0x82eb96b4
	if !ctx.cr[6].eq {
	pc = 0x82EB96B4; continue 'dispatch;
	}
	// 82EB96B0: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EB96B4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB96B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB96BC: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82EB96C0: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EB96C4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB96C8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EB96CC: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB96D0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82EB96D4: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB96D8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB96DC: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB96E0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB96E4: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB96E8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EB96EC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82EB96F0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EB96F4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EB96F8: 4200FFF8  bdnz 0x82eb96f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB96F0; continue 'dispatch;
	}
	// 82EB96FC: 807F0278  lwz r3, 0x278(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EB9700: 391F008C  addi r8, r31, 0x8c
	ctx.r[8].s64 = ctx.r[31].s64 + 140;
	// 82EB9704: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 82EB9708: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB970C: 80FF0094  lwz r7, 0x94(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB9710: 38BF02D8  addi r5, r31, 0x2d8
	ctx.r[5].s64 = ctx.r[31].s64 + 728;
	// 82EB9714: 80DF0068  lwz r6, 0x68(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9718: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB971C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB9720: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9724: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB9728: 4E800421  bctrl
	ctx.lr = 0x82EB972C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB972C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB9730: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB9734: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB9738: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB973C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB9740: 419A000C  beq cr6, 0x82eb974c
	if ctx.cr[6].eq {
	pc = 0x82EB974C; continue 'dispatch;
	}
	// 82EB9744: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82EB9748: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB974C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9750: 40820024  bne 0x82eb9774
	if !ctx.cr[0].eq {
	pc = 0x82EB9774; continue 'dispatch;
	}
	// 82EB9754: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9758: 83FF0194  lwz r31, 0x194(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB975C: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9760: 4B3A7259  bl 0x822609b8
	ctx.lr = 0x82EB9764;
	sub_822609B8(ctx, base);
	// 82EB9764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB9768: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB976C: 4BFC84CD  bl 0x82e81c38
	ctx.lr = 0x82EB9770;
	sub_82E81C38(ctx, base);
	// 82EB9770: 4800036C  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
	// 82EB9774: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB9778: 409A0028  bne cr6, 0x82eb97a0
	if !ctx.cr[6].eq {
	pc = 0x82EB97A0; continue 'dispatch;
	}
	// 82EB977C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9780: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB9784: 931F0198  stw r24, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[24].u32 ) };
	// 82EB9788: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB978C: 4B3A722D  bl 0x822609b8
	ctx.lr = 0x82EB9790;
	sub_822609B8(ctx, base);
	// 82EB9790: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB9794: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB9798: 4BFC82D9  bl 0x82e81a70
	ctx.lr = 0x82EB979C;
	sub_82E81A70(ctx, base);
	// 82EB979C: 4BFFFEC8  b 0x82eb9664
	pc = 0x82EB9664; continue 'dispatch;
	// 82EB97A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB97A4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB97A8: 409A001C  bne cr6, 0x82eb97c4
	if !ctx.cr[6].eq {
	pc = 0x82EB97C4; continue 'dispatch;
	}
	// 82EB97AC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB97B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB97B4: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB97B8: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB97BC: 83EA0014  lwz r31, 0x14(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB97C0: 4BFFFFCC  b 0x82eb978c
	pc = 0x82EB978C; continue 'dispatch;
	// 82EB97C4: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB97C8: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EB97CC: 9B9F007C  stb r28, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[28].u8 ) };
	// 82EB97D0: 939F0198  stw r28, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[28].u32 ) };
	// 82EB97D4: 2F1B0007  cmpwi cr6, r27, 7
	ctx.cr[6].compare_i32(ctx.r[27].s32, 7, &mut ctx.xer);
	// 82EB97D8: 409A0304  bne cr6, 0x82eb9adc
	if !ctx.cr[6].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB97DC: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB97E0: 4801A071  bl 0x82ed3850
	ctx.lr = 0x82EB97E4;
	sub_82ED3850(ctx, base);
	// 82EB97E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB97E8: 418202F0  beq 0x82eb9ad8
	if ctx.cr[0].eq {
	pc = 0x82EB9AD8; continue 'dispatch;
	}
	// 82EB97EC: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB97F0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB97F4: 409A0010  bne cr6, 0x82eb9804
	if !ctx.cr[6].eq {
	pc = 0x82EB9804; continue 'dispatch;
	}
	// 82EB97F8: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB97FC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82EB9800: 419AFE64  beq cr6, 0x82eb9664
	if ctx.cr[6].eq {
	pc = 0x82EB9664; continue 'dispatch;
	}
	// 82EB9804: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB9808: 9B1F007C  stb r24, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[24].u8 ) };
	// 82EB980C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB9810: 419A002C  beq cr6, 0x82eb983c
	if ctx.cr[6].eq {
	pc = 0x82EB983C; continue 'dispatch;
	}
	// 82EB9814: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9818: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB981C: 4B3A719D  bl 0x822609b8
	ctx.lr = 0x82EB9820;
	sub_822609B8(ctx, base);
	// 82EB9820: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB9824: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB9828: 4BFB68A9  bl 0x82e700d0
	ctx.lr = 0x82EB982C;
	sub_82E700D0(ctx, base);
	// 82EB982C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9830: 4082000C  bne 0x82eb983c
	if !ctx.cr[0].eq {
	pc = 0x82EB983C; continue 'dispatch;
	}
	// 82EB9834: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EB9838: 480002A4  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
	// 82EB983C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9840: 4BFFC961  bl 0x82eb61a0
	ctx.lr = 0x82EB9844;
	sub_82EB61A0(ctx, base);
	// 82EB9844: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB9848: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB984C: 9B1F006C  stb r24, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[24].u8 ) };
	// 82EB9850: 4801A089  bl 0x82ed38d8
	ctx.lr = 0x82EB9854;
	sub_82ED38D8(ctx, base);
	// 82EB9854: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9858: 40820010  bne 0x82eb9868
	if !ctx.cr[0].eq {
	pc = 0x82EB9868; continue 'dispatch;
	}
	// 82EB985C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9860: 931F0198  stw r24, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[24].u32 ) };
	// 82EB9864: 4800027C  b 0x82eb9ae0
	pc = 0x82EB9AE0; continue 'dispatch;
	// 82EB9868: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB986C: 809F0090  lwz r4, 0x90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB9870: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9874: 4801A065  bl 0x82ed38d8
	ctx.lr = 0x82EB9878;
	sub_82ED38D8(ctx, base);
	// 82EB9878: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB987C: 40820014  bne 0x82eb9890
	if !ctx.cr[0].eq {
	pc = 0x82EB9890; continue 'dispatch;
	}
	// 82EB9880: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB9884: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9888: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB988C: 48000254  b 0x82eb9ae0
	pc = 0x82EB9AE0; continue 'dispatch;
	// 82EB9890: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9894: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9898: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB989C: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB98A0: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82EB98A4: 814B019C  lwz r10, 0x19c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB98A8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB98AC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EB98B0: B38A0012  sth r28, 0x12(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[28].u16 ) };
	// 82EB98B4: C0190000  lfs f0, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB98B8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB98BC: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB98C0: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB98C4: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB98C8: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB98CC: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB98D0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB98D4: 93090000  stw r24, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB98D8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB98DC: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB98E0: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB98E4: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB98E8: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB98EC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB98F0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB98F4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EB98F8: B38A0012  sth r28, 0x12(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[28].u16 ) };
	// 82EB98FC: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9900: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9904: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EB9908: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB990C: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9910: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9914: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9918: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB991C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB9920: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EB9924: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9928: 41820010  beq 0x82eb9938
	if ctx.cr[0].eq {
	pc = 0x82EB9938; continue 'dispatch;
	}
	// 82EB992C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9930: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9934: 4BFE3335  bl 0x82e9cc68
	ctx.lr = 0x82EB9938;
	sub_82E9CC68(ctx, base);
	// 82EB9938: 897F0440  lbz r11, 0x440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1088 as u32) ) } as u64;
	// 82EB993C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB9940: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9944: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB9948: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB994C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB9950: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB9954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9958: 41820048  beq 0x82eb99a0
	if ctx.cr[0].eq {
	pc = 0x82EB99A0; continue 'dispatch;
	}
	// 82EB995C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EB9960: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EB9964: 4BFFD5BD  bl 0x82eb6f20
	ctx.lr = 0x82EB9968;
	sub_82EB6F20(ctx, base);
	// 82EB9968: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB996C: 83BF0194  lwz r29, 0x194(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB9970: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB9974: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9978: 4B3A7041  bl 0x822609b8
	ctx.lr = 0x82EB997C;
	sub_822609B8(ctx, base);
	// 82EB997C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB9980: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB9984: 4BFC8365  bl 0x82e81ce8
	ctx.lr = 0x82EB9988;
	sub_82E81CE8(ctx, base);
	// 82EB9988: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82EB998C: 419A0150  beq cr6, 0x82eb9adc
	if ctx.cr[6].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB9990: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 82EB9994: 419A0038  beq cr6, 0x82eb99cc
	if ctx.cr[6].eq {
	pc = 0x82EB99CC; continue 'dispatch;
	}
	// 82EB9998: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82EB999C: 4BFFFEE8  b 0x82eb9884
	pc = 0x82EB9884; continue 'dispatch;
	// 82EB99A0: 4BFFCC09  bl 0x82eb65a8
	ctx.lr = 0x82EB99A4;
	sub_82EB65A8(ctx, base);
	// 82EB99A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB99A8: 83BF0194  lwz r29, 0x194(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB99AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB99B0: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB99B4: 4B3A7005  bl 0x822609b8
	ctx.lr = 0x82EB99B8;
	sub_822609B8(ctx, base);
	// 82EB99B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB99BC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB99C0: 4BFC8329  bl 0x82e81ce8
	ctx.lr = 0x82EB99C4;
	sub_82E81CE8(ctx, base);
	// 82EB99C4: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB99C8: 419AFFD0  beq cr6, 0x82eb9998
	if ctx.cr[6].eq {
	pc = 0x82EB9998; continue 'dispatch;
	}
	// 82EB99CC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99D0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82EB99D4: 930B01A4  stw r24, 0x1a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), ctx.r[24].u32 ) };
	// 82EB99D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99DC: 938B01AC  stw r28, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[28].u32 ) };
	// 82EB99E0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99E4: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB99E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB99EC: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB99F0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99F4: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB99F8: 812B019C  lwz r9, 0x19c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB99FC: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82EB9A00: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB9A04: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EB9A08: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB9A0C: 813F0054  lwz r9, 0x54(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9A10: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB9A14: 81290198  lwz r9, 0x198(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB9A18: 48000018  b 0x82eb9a30
	pc = 0x82EB9A30; continue 'dispatch;
	// 82EB9A1C: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB9A20: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EB9A24: 38E70005  addi r7, r7, 5
	ctx.r[7].s64 = ctx.r[7].s64 + 5;
	// 82EB9A28: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EB9A2C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82EB9A30: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB9A34: 409AFFE8  bne cr6, 0x82eb9a1c
	if !ctx.cr[6].eq {
	pc = 0x82EB9A1C; continue 'dispatch;
	}
	// 82EB9A38: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EB9A3C: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EB9A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9A44: 4BFFE905  bl 0x82eb8348
	ctx.lr = 0x82EB9A48;
	sub_82EB8348(ctx, base);
	// 82EB9A48: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9A4C: C01A0000  lfs f0, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A50: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB9A54: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9A58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB9A5C: 409A0028  bne cr6, 0x82eb9a84
	if !ctx.cr[6].eq {
	pc = 0x82EB9A84; continue 'dispatch;
	}
	// 82EB9A60: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A64: C1BA0004  lfs f13, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9A68: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9A6C: 409A0018  bne cr6, 0x82eb9a84
	if !ctx.cr[6].eq {
	pc = 0x82EB9A84; continue 'dispatch;
	}
	// 82EB9A70: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A74: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82EB9A78: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9A7C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9A80: 419A0008  beq cr6, 0x82eb9a88
	if ctx.cr[6].eq {
	pc = 0x82EB9A88; continue 'dispatch;
	}
	// 82EB9A84: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82EB9A88: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB9A8C: 41820030  beq 0x82eb9abc
	if ctx.cr[0].eq {
	pc = 0x82EB9ABC; continue 'dispatch;
	}
	// 82EB9A90: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB9A94: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A98: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9A9C: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9AA0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9AA4: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9AA8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9AAC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9AB0: 814B01B8  lwz r10, 0x1b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB9AB4: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EB9AB8: 914B01B8  stw r10, 0x1b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), ctx.r[10].u32 ) };
	// 82EB9ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9AC0: 80BF0068  lwz r5, 0x68(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9AC4: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9AC8: 9B1F006C  stb r24, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[24].u8 ) };
	// 82EB9ACC: 4BFFC0ED  bl 0x82eb5bb8
	ctx.lr = 0x82EB9AD0;
	sub_82EB5BB8(ctx, base);
	// 82EB9AD0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82EB9AD4: 4BFFFB34  b 0x82eb9608
	pc = 0x82EB9608; continue 'dispatch;
	// 82EB9AD8: 92FF0058  stw r23, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82EB9ADC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB9AE0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EB9AE4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EB9AE8: 4BDEF95C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB9AF0 size=268
    let mut pc: u32 = 0x82EB9AF0;
    'dispatch: loop {
        match pc {
            0x82EB9AF0 => {
    //   block [0x82EB9AF0..0x82EB9BFC)
	// 82EB9AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9AF4: 4BDEF915  bl 0x82ca9408
	ctx.lr = 0x82EB9AF8;
	sub_82CA93D0(ctx, base);
	// 82EB9AF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9AFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB9B00: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB9B04: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB9B08: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB9B0C: 897F018C  lbz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB9B10: 9BBF006C  stb r29, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u8 ) };
	// 82EB9B14: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9B18: 4182007C  beq 0x82eb9b94
	if ctx.cr[0].eq {
	pc = 0x82EB9B94; continue 'dispatch;
	}
	// 82EB9B1C: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9B20: C1BF0180  lfs f13, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9B24: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9B28: 409A0028  bne cr6, 0x82eb9b50
	if !ctx.cr[6].eq {
	pc = 0x82EB9B50; continue 'dispatch;
	}
	// 82EB9B2C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9B30: C1BF0184  lfs f13, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9B34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9B38: 409A0018  bne cr6, 0x82eb9b50
	if !ctx.cr[6].eq {
	pc = 0x82EB9B50; continue 'dispatch;
	}
	// 82EB9B3C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9B40: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB9B44: C1BF0188  lfs f13, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9B48: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9B4C: 419A0008  beq cr6, 0x82eb9b54
	if ctx.cr[6].eq {
	pc = 0x82EB9B54; continue 'dispatch;
	}
	// 82EB9B50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB9B54: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9B58: 40820018  bne 0x82eb9b70
	if !ctx.cr[0].eq {
	pc = 0x82EB9B70; continue 'dispatch;
	}
	// 82EB9B5C: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9B60: 40820010  bne 0x82eb9b70
	if !ctx.cr[0].eq {
	pc = 0x82EB9B70; continue 'dispatch;
	}
	// 82EB9B64: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB9B68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9B6C: 4182004C  beq 0x82eb9bb8
	if ctx.cr[0].eq {
	pc = 0x82EB9BB8; continue 'dispatch;
	}
	// 82EB9B70: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB9B74: 9BBF0040  stb r29, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 82EB9B78: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB9B7C: 409A0020  bne cr6, 0x82eb9b9c
	if !ctx.cr[6].eq {
	pc = 0x82EB9B9C; continue 'dispatch;
	}
	// 82EB9B80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB9B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9B88: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 82EB9B8C: 4BFFC615  bl 0x82eb61a0
	ctx.lr = 0x82EB9B90;
	sub_82EB61A0(ctx, base);
	// 82EB9B90: 4800000C  b 0x82eb9b9c
	pc = 0x82EB9B9C; continue 'dispatch;
	// 82EB9B94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB9B98: 997F018C  stb r11, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u8 ) };
	// 82EB9B9C: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EB9BA0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9BA4: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EB9BA8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9BAC: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB9BB0: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9BB4: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB9BB8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB9BBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB9BC0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB9BC4: 409A0018  bne cr6, 0x82eb9bdc
	if !ctx.cr[6].eq {
	pc = 0x82EB9BDC; continue 'dispatch;
	}
	// 82EB9BC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB9BCC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB9BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9BD4: 4BFFF865  bl 0x82eb9438
	ctx.lr = 0x82EB9BD8;
	sub_82EB9438(ctx, base);
	// 82EB9BD8: 4800001C  b 0x82eb9bf4
	pc = 0x82EB9BF4; continue 'dispatch;
	// 82EB9BDC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB9BE0: 409A0014  bne cr6, 0x82eb9bf4
	if !ctx.cr[6].eq {
	pc = 0x82EB9BF4; continue 'dispatch;
	}
	// 82EB9BE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB9BE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB9BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9BF0: 4BFFEF31  bl 0x82eb8b20
	ctx.lr = 0x82EB9BF4;
	sub_82EB8B20(ctx, base);
	// 82EB9BF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB9BF8: 4BDEF860  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB9C00 size=1004
    let mut pc: u32 = 0x82EB9C00;
    'dispatch: loop {
        match pc {
            0x82EB9C00 => {
    //   block [0x82EB9C00..0x82EB9FEC)
	// 82EB9C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9C04: 4BDEF809  bl 0x82ca940c
	ctx.lr = 0x82EB9C08;
	sub_82CA93D0(ctx, base);
	// 82EB9C08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB9C10: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82EB9C14: 4BFCBCED  bl 0x82e85900
	ctx.lr = 0x82EB9C18;
	sub_82E85900(ctx, base);
	// 82EB9C18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB9C1C: 395F00A4  addi r10, r31, 0xa4
	ctx.r[10].s64 = ctx.r[31].s64 + 164;
	// 82EB9C20: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82EB9C24: 393F0104  addi r9, r31, 0x104
	ctx.r[9].s64 = ctx.r[31].s64 + 260;
	// 82EB9C28: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 82EB9C2C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9C30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB9C34: 3CA08204  lis r5, -0x7dfc
	ctx.r[5].s64 = -2113667072;
	// 82EB9C38: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EB9C3C: 390BA8F8  addi r8, r11, -0x5708
	ctx.r[8].s64 = ctx.r[11].s64 + -22280;
	// 82EB9C40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9C44: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82EB9C48: 38E7A8F0  addi r7, r7, -0x5710
	ctx.r[7].s64 = ctx.r[7].s64 + -22288;
	// 82EB9C4C: 38C6A8F0  addi r6, r6, -0x5710
	ctx.r[6].s64 = ctx.r[6].s64 + -22288;
	// 82EB9C50: 38A5A8F0  addi r5, r5, -0x5710
	ctx.r[5].s64 = ctx.r[5].s64 + -22288;
	// 82EB9C54: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB9C58: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EB9C5C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB9C60: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB9C64: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB9C68: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB9C6C: 3908A8F0  addi r8, r8, -0x5710
	ctx.r[8].s64 = ctx.r[8].s64 + -22288;
	// 82EB9C70: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB9C74: D00A0050  stfs f0, 0x50(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB9C78: D00A0054  stfs f0, 0x54(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB9C7C: D00A0058  stfs f0, 0x58(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB9C80: 395F027C  addi r10, r31, 0x27c
	ctx.r[10].s64 = ctx.r[31].s64 + 636;
	// 82EB9C84: D0090050  stfs f0, 0x50(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB9C88: D0090054  stfs f0, 0x54(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB9C8C: D0090058  stfs f0, 0x58(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB9C90: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9C94: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EB9C98: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB9C9C: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB9CA0: 90FF01A0  stw r7, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[7].u32 ) };
	// 82EB9CA4: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82EB9CA8: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 82EB9CAC: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 82EB9CB0: 90DF01B4  stw r6, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[6].u32 ) };
	// 82EB9CB4: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB9CB8: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB9CBC: 917F01C0  stw r11, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82EB9CC0: 90BF01C8  stw r5, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[5].u32 ) };
	// 82EB9CC4: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 82EB9CC8: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 82EB9CCC: 917F01D4  stw r11, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82EB9CD0: 911F01DC  stw r8, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[8].u32 ) };
	// 82EB9CD4: 3909A8F0  addi r8, r9, -0x5710
	ctx.r[8].s64 = ctx.r[9].s64 + -22288;
	// 82EB9CD8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9CDC: 917F01E0  stw r11, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EB9CE0: 917F01E4  stw r11, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82EB9CE4: 38E9A8F0  addi r7, r9, -0x5710
	ctx.r[7].s64 = ctx.r[9].s64 + -22288;
	// 82EB9CE8: 917F01E8  stw r11, 0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[11].u32 ) };
	// 82EB9CEC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9CF0: 917F01F4  stw r11, 0x1f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[11].u32 ) };
	// 82EB9CF4: 911F01F0  stw r8, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[8].u32 ) };
	// 82EB9CF8: 38C9A8F0  addi r6, r9, -0x5710
	ctx.r[6].s64 = ctx.r[9].s64 + -22288;
	// 82EB9CFC: 917F01F8  stw r11, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 82EB9D00: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D04: 917F01FC  stw r11, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[11].u32 ) };
	// 82EB9D08: 90FF0204  stw r7, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[7].u32 ) };
	// 82EB9D0C: 38A9A8F0  addi r5, r9, -0x5710
	ctx.r[5].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D10: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 82EB9D14: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D18: 917F020C  stw r11, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u32 ) };
	// 82EB9D1C: 917F0210  stw r11, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[11].u32 ) };
	// 82EB9D20: 3889A8F0  addi r4, r9, -0x5710
	ctx.r[4].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D24: 90DF0218  stw r6, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[6].u32 ) };
	// 82EB9D28: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D2C: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 82EB9D30: 917F0220  stw r11, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 82EB9D34: 3869A8F0  addi r3, r9, -0x5710
	ctx.r[3].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D38: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 82EB9D3C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D40: 90BF022C  stw r5, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[5].u32 ) };
	// 82EB9D44: 3BC9A8F0  addi r30, r9, -0x5710
	ctx.r[30].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D48: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EB9D4C: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EB9D50: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 82EB9D54: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 82EB9D58: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 82EB9D5C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EB9D60: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 82EB9D64: 909F0240  stw r4, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[4].u32 ) };
	// 82EB9D68: 917F0244  stw r11, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	// 82EB9D6C: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 82EB9D70: 917F024C  stw r11, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u32 ) };
	// 82EB9D74: 907F0254  stw r3, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[3].u32 ) };
	// 82EB9D78: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 82EB9D7C: 917F025C  stw r11, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 82EB9D80: 917F0260  stw r11, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 82EB9D84: 93DF0268  stw r30, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[30].u32 ) };
	// 82EB9D88: 917F026C  stw r11, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 82EB9D8C: 917F0270  stw r11, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 82EB9D90: 917F0274  stw r11, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	// 82EB9D94: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9D98: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9D9C: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9DA0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9DA4: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82EB9DA8: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9DAC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EB9DB0: 4200FFF8  bdnz 0x82eb9da8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9DA8; continue 'dispatch;
	}
	// 82EB9DB4: 38FF02D8  addi r7, r31, 0x2d8
	ctx.r[7].s64 = ctx.r[31].s64 + 728;
	// 82EB9DB8: 996A0058  stb r11, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9DBC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EB9DC0: 39470010  addi r10, r7, 0x10
	ctx.r[10].s64 = ctx.r[7].s64 + 16;
	// 82EB9DC4: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9DC8: D0070004  stfs f0, 4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9DCC: D0070008  stfs f0, 8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9DD0: D007000C  stfs f0, 0xc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9DD4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82EB9DD8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9DDC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB9DE0: 4200FFF8  bdnz 0x82eb9dd8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9DD8; continue 'dispatch;
	}
	// 82EB9DE4: 391F0334  addi r8, r31, 0x334
	ctx.r[8].s64 = ctx.r[31].s64 + 820;
	// 82EB9DE8: 99670058  stb r11, 0x58(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9DEC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB9DF0: 38E80010  addi r7, r8, 0x10
	ctx.r[7].s64 = ctx.r[8].s64 + 16;
	// 82EB9DF4: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9DF8: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9DFC: D0080008  stfs f0, 8(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9E00: D008000C  stfs f0, 0xc(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9E04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB9E08: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9E0C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EB9E10: 4200FFF8  bdnz 0x82eb9e08
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9E08; continue 'dispatch;
	}
	// 82EB9E14: 395F03A4  addi r10, r31, 0x3a4
	ctx.r[10].s64 = ctx.r[31].s64 + 932;
	// 82EB9E18: 99680058  stb r11, 0x58(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9E1C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EB9E20: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9E24: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9E28: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9E2C: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 82EB9E30: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9E34: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82EB9E38: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9E3C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB9E40: 4200FFF8  bdnz 0x82eb9e38
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9E38; continue 'dispatch;
	}
	// 82EB9E44: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9E48: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82EB9E4C: 996A0058  stb r11, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9E54: 39298704  addi r9, r9, -0x78fc
	ctx.r[9].s64 = ctx.r[9].s64 + -30972;
	// 82EB9E58: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EB9E5C: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EB9E60: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82EB9E64: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82EB9E68: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB9E6C: D01F0428  stfs f0, 0x428(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), tmp.u32 ) };
	// 82EB9E70: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	// 82EB9E74: 917F041C  stw r11, 0x41c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1052 as u32), ctx.r[11].u32 ) };
	// 82EB9E78: D01F042C  stfs f0, 0x42c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), tmp.u32 ) };
	// 82EB9E7C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82EB9E80: D01F0430  stfs f0, 0x430(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 82EB9E84: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB9E88: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 82EB9E8C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82EB9E90: 38A00400  li r5, 0x400
	ctx.r[5].s64 = 1024;
	// 82EB9E94: 386001F4  li r3, 0x1f4
	ctx.r[3].s64 = 500;
	// 82EB9E98: C1A90C14  lfs f13, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9E9C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EB9EA0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9EA4: 917F0418  stw r11, 0x418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), ctx.r[11].u32 ) };
	// 82EB9EA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB9EAC: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB9EB0: 814B9E38  lwz r10, -0x61c8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25032 as u32) ) } as u64;
	// 82EB9EB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB9EB8: 914B9E38  stw r10, -0x61c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25032 as u32), ctx.r[10].u32 ) };
	// 82EB9EBC: D1BF044C  stfs f13, 0x44c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1100 as u32), tmp.u32 ) };
	// 82EB9EC0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB9EC4: 909F0444  stw r4, 0x444(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1092 as u32), ctx.r[4].u32 ) };
	// 82EB9EC8: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82EB9ECC: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EB9ED0: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82EB9ED4: 997F0034  stb r11, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82EB9ED8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB9EDC: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82EB9EE0: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82EB9EE4: 93DF0198  stw r30, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[30].u32 ) };
	// 82EB9EE8: 93DF0164  stw r30, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[30].u32 ) };
	// 82EB9EEC: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9EF0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB9EF4: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB9EF8: 93DF017C  stw r30, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[30].u32 ) };
	// 82EB9EFC: 388BF090  addi r4, r11, -0xf70
	ctx.r[4].s64 = ctx.r[11].s64 + -3952;
	// 82EB9F00: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB9F04: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB9F08: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 82EB9F0C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB9F10: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82EB9F14: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EB9F18: 90FF0030  stw r7, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[7].u32 ) };
	// 82EB9F1C: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB9F20: 993F019C  stb r9, 0x19c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[9].u8 ) };
	// 82EB9F24: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB9F28: 9BDF019D  stb r30, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[30].u8 ) };
	// 82EB9F2C: 90DF0194  stw r6, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[6].u32 ) };
	// 82EB9F30: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82EB9F34: 90BF0098  stw r5, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	// 82EB9F38: 93DF009C  stw r30, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 82EB9F3C: 9BDF007E  stb r30, 0x7e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(126 as u32), ctx.r[30].u8 ) };
	// 82EB9F40: 993F007F  stb r9, 0x7f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(127 as u32), ctx.r[9].u8 ) };
	// 82EB9F44: 9BDF00A0  stb r30, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[30].u8 ) };
	// 82EB9F48: 9BDF00A1  stb r30, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[30].u8 ) };
	// 82EB9F4C: 9BDF0440  stb r30, 0x440(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1088 as u32), ctx.r[30].u8 ) };
	// 82EB9F50: 907F0448  stw r3, 0x448(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1096 as u32), ctx.r[3].u32 ) };
	// 82EB9F54: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB9F58: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB9F5C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EB9F60: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB9F64: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 82EB9F68: 9BDF00AC  stb r30, 0xac(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u8 ) };
	// 82EB9F6C: 93DF00F0  stw r30, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	// 82EB9F70: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 82EB9F74: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 82EB9F78: 9BDF010C  stb r30, 0x10c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u8 ) };
	// 82EB9F7C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EB9F80: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82EB9F84: 93DF0160  stw r30, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[30].u32 ) };
	// 82EB9F88: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82EB9F8C: 93DF0168  stw r30, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[30].u32 ) };
	// 82EB9F90: 807D0718  lwz r3, 0x718(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB9F94: 4B3ADC8D  bl 0x82267c20
	ctx.lr = 0x82EB9F98;
	sub_82267C20(ctx, base);
	// 82EB9F98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB9F9C: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82EB9FA0: 807D0718  lwz r3, 0x718(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB9FA4: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82EB9FA8: 4B3ADC79  bl 0x82267c20
	ctx.lr = 0x82EB9FAC;
	sub_82267C20(ctx, base);
	// 82EB9FAC: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 82EB9FB0: 9BDF018C  stb r30, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[30].u8 ) };
	// 82EB9FB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9FB8: 93DF01B0  stw r30, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[30].u32 ) };
	// 82EB9FBC: 93DF01C4  stw r30, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[30].u32 ) };
	// 82EB9FC0: 93DF01D8  stw r30, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[30].u32 ) };
	// 82EB9FC4: 93DF01EC  stw r30, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[30].u32 ) };
	// 82EB9FC8: 93DF0200  stw r30, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[30].u32 ) };
	// 82EB9FCC: 93DF0214  stw r30, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[30].u32 ) };
	// 82EB9FD0: 93DF0228  stw r30, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[30].u32 ) };
	// 82EB9FD4: 93DF0264  stw r30, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[30].u32 ) };
	// 82EB9FD8: 93DF0250  stw r30, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[30].u32 ) };
	// 82EB9FDC: 93DF023C  stw r30, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[30].u32 ) };
	// 82EB9FE0: 93DF0278  stw r30, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[30].u32 ) };
	// 82EB9FE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB9FE8: 4BDEF474  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB9FF0 size=12
    let mut pc: u32 = 0x82EB9FF0;
    'dispatch: loop {
        match pc {
            0x82EB9FF0 => {
    //   block [0x82EB9FF0..0x82EB9FFC)
	// 82EB9FF0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB9FF4: 386B9E5C  addi r3, r11, -0x61a4
	ctx.r[3].s64 = ctx.r[11].s64 + -24996;
	// 82EB9FF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA000 size=8
    let mut pc: u32 = 0x82EBA000;
    'dispatch: loop {
        match pc {
            0x82EBA000 => {
    //   block [0x82EBA000..0x82EBA008)
	// 82EBA000: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 82EBA004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA008 size=16
    let mut pc: u32 = 0x82EBA008;
    'dispatch: loop {
        match pc {
            0x82EBA008 => {
    //   block [0x82EBA008..0x82EBA018)
	// 82EBA008: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBA00C: 806B0068  lwz r3, 0x68(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EBA010: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA014: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA018 size=12
    let mut pc: u32 = 0x82EBA018;
    'dispatch: loop {
        match pc {
            0x82EBA018 => {
    //   block [0x82EBA018..0x82EBA024)
	// 82EBA018: 806B0064  lwz r3, 0x64(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EBA01C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA020: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA024(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA024 size=32
    let mut pc: u32 = 0x82EBA024;
    'dispatch: loop {
        match pc {
            0x82EBA024 => {
    //   block [0x82EBA024..0x82EBA044)
	// 82EBA024: 894B0034  lbz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EBA028: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA02C: 40820018  bne 0x82eba044
	if !ctx.cr[0].eq {
		sub_82EBA044(ctx, base);
		return;
	}
	// 82EBA030: 806B0048  lwz r3, 0x48(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA034: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA038: 4182000C  beq 0x82eba044
	if ctx.cr[0].eq {
		sub_82EBA044(ctx, base);
		return;
	}
	// 82EBA03C: 808B0038  lwz r4, 0x38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBA040: 4801B9F0  b 0x82ed5a30
	sub_82ED5A30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA044(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA044 size=8
    let mut pc: u32 = 0x82EBA044;
    'dispatch: loop {
        match pc {
            0x82EBA044 => {
    //   block [0x82EBA044..0x82EBA04C)
	// 82EBA044: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBA048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA050 size=8
    let mut pc: u32 = 0x82EBA050;
    'dispatch: loop {
        match pc {
            0x82EBA050 => {
    //   block [0x82EBA050..0x82EBA058)
	// 82EBA050: 80630398  lwz r3, 0x398(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EBA054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA058 size=8
    let mut pc: u32 = 0x82EBA058;
    'dispatch: loop {
        match pc {
            0x82EBA058 => {
    //   block [0x82EBA058..0x82EBA060)
	// 82EBA058: 88630396  lbz r3, 0x396(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(918 as u32) ) } as u64;
	// 82EBA05C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBA060 size=1496
    let mut pc: u32 = 0x82EBA060;
    'dispatch: loop {
        match pc {
            0x82EBA060 => {
    //   block [0x82EBA060..0x82EBA638)
	// 82EBA060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBA064: 4BDEF3A5  bl 0x82ca9408
	ctx.lr = 0x82EBA068;
	sub_82CA93D0(ctx, base);
	// 82EBA068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBA06C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBA074: 396BA8F8  addi r11, r11, -0x5708
	ctx.r[11].s64 = ctx.r[11].s64 + -22280;
	// 82EBA078: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBA07C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EBA080: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82EBA084: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA088: 816A9E38  lwz r11, -0x61c8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25032 as u32) ) } as u64;
	// 82EBA08C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA090: 916A9E38  stw r11, -0x61c8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25032 as u32), ctx.r[11].u32 ) };
	// 82EBA094: 40820070  bne 0x82eba104
	if !ctx.cr[0].eq {
	pc = 0x82EBA104; continue 'dispatch;
	}
	// 82EBA098: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82EBA09C: 807D9E3C  lwz r3, -0x61c4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EBA0A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBA0A4: 419A0018  beq cr6, 0x82eba0bc
	if ctx.cr[6].eq {
	pc = 0x82EBA0BC; continue 'dispatch;
	}
	// 82EBA0A8: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA0AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA0B0: 4E800421  bctrl
	ctx.lr = 0x82EBA0B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA0B4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EBA0B8: 917D9E3C  stw r11, -0x61c4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-25028 as u32), ctx.r[11].u32 ) };
	// 82EBA0BC: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82EBA0C0: 807D9E40  lwz r3, -0x61c0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EBA0C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBA0C8: 419A0018  beq cr6, 0x82eba0e0
	if ctx.cr[6].eq {
	pc = 0x82EBA0E0; continue 'dispatch;
	}
	// 82EBA0CC: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA0D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA0D4: 4E800421  bctrl
	ctx.lr = 0x82EBA0D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA0D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EBA0DC: 917D9E40  stw r11, -0x61c0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-25024 as u32), ctx.r[11].u32 ) };
	// 82EBA0E0: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82EBA0E4: 807D9E44  lwz r3, -0x61bc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EBA0E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBA0EC: 419A0018  beq cr6, 0x82eba104
	if ctx.cr[6].eq {
	pc = 0x82EBA104; continue 'dispatch;
	}
	// 82EBA0F0: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA0F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA0F8: 4E800421  bctrl
	ctx.lr = 0x82EBA0FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA0FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EBA100: 917D9E44  stw r11, -0x61bc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-25020 as u32), ctx.r[11].u32 ) };
	// 82EBA104: 83BF0054  lwz r29, 0x54(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBA108: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA10C: 41820020  beq 0x82eba12c
	if ctx.cr[0].eq {
	pc = 0x82EBA12C; continue 'dispatch;
	}
	// 82EBA110: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBA114: 4BFFBC05  bl 0x82eb5d18
	ctx.lr = 0x82EBA118;
	sub_82EB5D18(ctx, base);
	// 82EBA118: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA11C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBA120: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA124: 4E800421  bctrl
	ctx.lr = 0x82EBA128;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA128: 939F0054  stw r28, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EBA12C: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EBA130: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA134: 41820014  beq 0x82eba148
	if ctx.cr[0].eq {
	pc = 0x82EBA148; continue 'dispatch;
	}
	// 82EBA138: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA13C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA140: 4E800421  bctrl
	ctx.lr = 0x82EBA144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA144: 939F0094  stw r28, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	// 82EBA148: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EBA14C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA150: 41820014  beq 0x82eba164
	if ctx.cr[0].eq {
	pc = 0x82EBA164; continue 'dispatch;
	}
	// 82EBA154: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA15C: 4E800421  bctrl
	ctx.lr = 0x82EBA160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA160: 939F0060  stw r28, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EBA164: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA168: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA16C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA170: 4099004C  ble cr6, 0x82eba1bc
	if !ctx.cr[6].gt {
	pc = 0x82EBA1BC; continue 'dispatch;
	}
	// 82EBA174: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA178: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBA17C: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBA180: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA184: 419A0024  beq cr6, 0x82eba1a8
	if ctx.cr[6].eq {
	pc = 0x82EBA1A8; continue 'dispatch;
	}
	// 82EBA188: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA190: 41820018  beq 0x82eba1a8
	if ctx.cr[0].eq {
	pc = 0x82EBA1A8; continue 'dispatch;
	}
	// 82EBA194: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA198: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA19C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA1A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA1A4: 4E800421  bctrl
	ctx.lr = 0x82EBA1A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA1A8: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA1AC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA1B0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA1B4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA1B8: 4198FFC0  blt cr6, 0x82eba178
	if ctx.cr[6].lt {
	pc = 0x82EBA178; continue 'dispatch;
	}
	// 82EBA1BC: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA1C0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA1C8: 4099004C  ble cr6, 0x82eba214
	if !ctx.cr[6].gt {
	pc = 0x82EBA214; continue 'dispatch;
	}
	// 82EBA1CC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA1D0: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBA1D4: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA1D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA1DC: 419A0024  beq cr6, 0x82eba200
	if ctx.cr[6].eq {
	pc = 0x82EBA200; continue 'dispatch;
	}
	// 82EBA1E0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA1E8: 41820018  beq 0x82eba200
	if ctx.cr[0].eq {
	pc = 0x82EBA200; continue 'dispatch;
	}
	// 82EBA1EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA1F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA1F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA1F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA1FC: 4E800421  bctrl
	ctx.lr = 0x82EBA200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA200: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA204: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA208: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA20C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA210: 4198FFC0  blt cr6, 0x82eba1d0
	if ctx.cr[6].lt {
	pc = 0x82EBA1D0; continue 'dispatch;
	}
	// 82EBA214: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBA218: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA220: 4099004C  ble cr6, 0x82eba26c
	if !ctx.cr[6].gt {
	pc = 0x82EBA26C; continue 'dispatch;
	}
	// 82EBA224: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA228: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBA22C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA230: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA234: 419A0024  beq cr6, 0x82eba258
	if ctx.cr[6].eq {
	pc = 0x82EBA258; continue 'dispatch;
	}
	// 82EBA238: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA23C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA240: 41820018  beq 0x82eba258
	if ctx.cr[0].eq {
	pc = 0x82EBA258; continue 'dispatch;
	}
	// 82EBA244: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA248: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA24C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA254: 4E800421  bctrl
	ctx.lr = 0x82EBA258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA258: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBA25C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA260: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA264: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA268: 4198FFC0  blt cr6, 0x82eba228
	if ctx.cr[6].lt {
	pc = 0x82EBA228; continue 'dispatch;
	}
	// 82EBA26C: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBA270: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA278: 4099004C  ble cr6, 0x82eba2c4
	if !ctx.cr[6].gt {
	pc = 0x82EBA2C4; continue 'dispatch;
	}
	// 82EBA27C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA280: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBA284: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA288: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA28C: 419A0024  beq cr6, 0x82eba2b0
	if ctx.cr[6].eq {
	pc = 0x82EBA2B0; continue 'dispatch;
	}
	// 82EBA290: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA298: 41820018  beq 0x82eba2b0
	if ctx.cr[0].eq {
	pc = 0x82EBA2B0; continue 'dispatch;
	}
	// 82EBA29C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA2A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA2A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA2A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA2AC: 4E800421  bctrl
	ctx.lr = 0x82EBA2B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA2B0: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBA2B4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA2B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA2BC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA2C0: 4198FFC0  blt cr6, 0x82eba280
	if ctx.cr[6].lt {
	pc = 0x82EBA280; continue 'dispatch;
	}
	// 82EBA2C4: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBA2C8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA2D0: 4099004C  ble cr6, 0x82eba31c
	if !ctx.cr[6].gt {
	pc = 0x82EBA31C; continue 'dispatch;
	}
	// 82EBA2D4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA2D8: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBA2DC: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA2E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA2E4: 419A0024  beq cr6, 0x82eba308
	if ctx.cr[6].eq {
	pc = 0x82EBA308; continue 'dispatch;
	}
	// 82EBA2E8: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA2EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA2F0: 41820018  beq 0x82eba308
	if ctx.cr[0].eq {
	pc = 0x82EBA308; continue 'dispatch;
	}
	// 82EBA2F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA2F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA2FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA300: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA304: 4E800421  bctrl
	ctx.lr = 0x82EBA308;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA308: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBA30C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA310: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA314: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA318: 4198FFC0  blt cr6, 0x82eba2d8
	if ctx.cr[6].lt {
	pc = 0x82EBA2D8; continue 'dispatch;
	}
	// 82EBA31C: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBA320: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA328: 4099004C  ble cr6, 0x82eba374
	if !ctx.cr[6].gt {
	pc = 0x82EBA374; continue 'dispatch;
	}
	// 82EBA32C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA330: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBA334: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA33C: 419A0024  beq cr6, 0x82eba360
	if ctx.cr[6].eq {
	pc = 0x82EBA360; continue 'dispatch;
	}
	// 82EBA340: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA344: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA348: 41820018  beq 0x82eba360
	if ctx.cr[0].eq {
	pc = 0x82EBA360; continue 'dispatch;
	}
	// 82EBA34C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA350: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA354: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA358: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA35C: 4E800421  bctrl
	ctx.lr = 0x82EBA360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA360: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBA364: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA368: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA36C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA370: 4198FFC0  blt cr6, 0x82eba330
	if ctx.cr[6].lt {
	pc = 0x82EBA330; continue 'dispatch;
	}
	// 82EBA374: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBA378: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA380: 4099004C  ble cr6, 0x82eba3cc
	if !ctx.cr[6].gt {
	pc = 0x82EBA3CC; continue 'dispatch;
	}
	// 82EBA384: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA388: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBA38C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA394: 419A0024  beq cr6, 0x82eba3b8
	if ctx.cr[6].eq {
	pc = 0x82EBA3B8; continue 'dispatch;
	}
	// 82EBA398: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA39C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3A0: 41820018  beq 0x82eba3b8
	if ctx.cr[0].eq {
	pc = 0x82EBA3B8; continue 'dispatch;
	}
	// 82EBA3A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA3A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA3AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA3B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA3B4: 4E800421  bctrl
	ctx.lr = 0x82EBA3B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA3B8: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBA3BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA3C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA3C4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA3C8: 4198FFC0  blt cr6, 0x82eba388
	if ctx.cr[6].lt {
	pc = 0x82EBA388; continue 'dispatch;
	}
	// 82EBA3CC: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBA3D0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3D8: 4099004C  ble cr6, 0x82eba424
	if !ctx.cr[6].gt {
	pc = 0x82EBA424; continue 'dispatch;
	}
	// 82EBA3DC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA3E0: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBA3E4: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA3E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3EC: 419A0024  beq cr6, 0x82eba410
	if ctx.cr[6].eq {
	pc = 0x82EBA410; continue 'dispatch;
	}
	// 82EBA3F0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA3F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3F8: 41820018  beq 0x82eba410
	if ctx.cr[0].eq {
	pc = 0x82EBA410; continue 'dispatch;
	}
	// 82EBA3FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA400: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA404: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA40C: 4E800421  bctrl
	ctx.lr = 0x82EBA410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA410: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBA414: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA418: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA41C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA420: 4198FFC0  blt cr6, 0x82eba3e0
	if ctx.cr[6].lt {
	pc = 0x82EBA3E0; continue 'dispatch;
	}
	// 82EBA424: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBA428: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA42C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA430: 4099004C  ble cr6, 0x82eba47c
	if !ctx.cr[6].gt {
	pc = 0x82EBA47C; continue 'dispatch;
	}
	// 82EBA434: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA438: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBA43C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA440: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA444: 419A0024  beq cr6, 0x82eba468
	if ctx.cr[6].eq {
	pc = 0x82EBA468; continue 'dispatch;
	}
	// 82EBA448: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA44C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA450: 41820018  beq 0x82eba468
	if ctx.cr[0].eq {
	pc = 0x82EBA468; continue 'dispatch;
	}
	// 82EBA454: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA458: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA45C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA464: 4E800421  bctrl
	ctx.lr = 0x82EBA468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA468: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBA46C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA470: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA474: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA478: 4198FFC0  blt cr6, 0x82eba438
	if ctx.cr[6].lt {
	pc = 0x82EBA438; continue 'dispatch;
	}
	// 82EBA47C: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBA480: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA488: 4099004C  ble cr6, 0x82eba4d4
	if !ctx.cr[6].gt {
	pc = 0x82EBA4D4; continue 'dispatch;
	}
	// 82EBA48C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA490: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBA494: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA498: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA49C: 419A0024  beq cr6, 0x82eba4c0
	if ctx.cr[6].eq {
	pc = 0x82EBA4C0; continue 'dispatch;
	}
	// 82EBA4A0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA4A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA4A8: 41820018  beq 0x82eba4c0
	if ctx.cr[0].eq {
	pc = 0x82EBA4C0; continue 'dispatch;
	}
	// 82EBA4AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA4B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA4B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA4B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA4BC: 4E800421  bctrl
	ctx.lr = 0x82EBA4C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA4C0: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBA4C4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA4C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA4CC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA4D0: 4198FFC0  blt cr6, 0x82eba490
	if ctx.cr[6].lt {
	pc = 0x82EBA490; continue 'dispatch;
	}
	// 82EBA4D4: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBA4D8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA4DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA4E0: 4099004C  ble cr6, 0x82eba52c
	if !ctx.cr[6].gt {
	pc = 0x82EBA52C; continue 'dispatch;
	}
	// 82EBA4E4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA4E8: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBA4EC: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA4F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA4F4: 419A0024  beq cr6, 0x82eba518
	if ctx.cr[6].eq {
	pc = 0x82EBA518; continue 'dispatch;
	}
	// 82EBA4F8: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA4FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA500: 41820018  beq 0x82eba518
	if ctx.cr[0].eq {
	pc = 0x82EBA518; continue 'dispatch;
	}
	// 82EBA504: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA508: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA50C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA514: 4E800421  bctrl
	ctx.lr = 0x82EBA518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA518: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBA51C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA520: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA524: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA528: 4198FFC0  blt cr6, 0x82eba4e8
	if ctx.cr[6].lt {
	pc = 0x82EBA4E8; continue 'dispatch;
	}
	// 82EBA52C: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EBA530: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA534: 41820024  beq 0x82eba558
	if ctx.cr[0].eq {
	pc = 0x82EBA558; continue 'dispatch;
	}
	// 82EBA538: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA53C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA540: 41820018  beq 0x82eba558
	if ctx.cr[0].eq {
	pc = 0x82EBA558; continue 'dispatch;
	}
	// 82EBA544: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EBA548: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EBA54C: 388B5818  addi r4, r11, 0x5818
	ctx.r[4].s64 = ctx.r[11].s64 + 22552;
	// 82EBA550: 480125B1  bl 0x82eccb00
	ctx.lr = 0x82EBA554;
	sub_82ECCB00(ctx, base);
	// 82EBA554: 9B9F00A0  stb r28, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[28].u8 ) };
	// 82EBA558: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EBA55C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA560: 41820020  beq 0x82eba580
	if ctx.cr[0].eq {
	pc = 0x82EBA580; continue 'dispatch;
	}
	// 82EBA564: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA568: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA56C: 41820014  beq 0x82eba580
	if ctx.cr[0].eq {
	pc = 0x82EBA580; continue 'dispatch;
	}
	// 82EBA570: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EBA574: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA578: 41820008  beq 0x82eba580
	if ctx.cr[0].eq {
	pc = 0x82EBA580; continue 'dispatch;
	}
	// 82EBA57C: 480189B5  bl 0x82ed2f30
	ctx.lr = 0x82EBA580;
	sub_82ED2F30(ctx, base);
	// 82EBA580: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EBA584: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82EBA588: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA58C: 41820020  beq 0x82eba5ac
	if ctx.cr[0].eq {
	pc = 0x82EBA5AC; continue 'dispatch;
	}
	// 82EBA590: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA598: 41820014  beq 0x82eba5ac
	if ctx.cr[0].eq {
	pc = 0x82EBA5AC; continue 'dispatch;
	}
	// 82EBA59C: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EBA5A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA5A4: 41820008  beq 0x82eba5ac
	if ctx.cr[0].eq {
	pc = 0x82EBA5AC; continue 'dispatch;
	}
	// 82EBA5A8: 48018989  bl 0x82ed2f30
	ctx.lr = 0x82EBA5AC;
	sub_82ED2F30(ctx, base);
	// 82EBA5AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBA5B0: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EBA5B4: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 82EBA5B8: 387F0268  addi r3, r31, 0x268
	ctx.r[3].s64 = ctx.r[31].s64 + 616;
	// 82EBA5BC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EBA5C0: 917F0418  stw r11, 0x418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), ctx.r[11].u32 ) };
	// 82EBA5C4: 917F03A4  stw r11, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[11].u32 ) };
	// 82EBA5C8: 917F0334  stw r11, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[11].u32 ) };
	// 82EBA5CC: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	// 82EBA5D0: 917F027C  stw r11, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[11].u32 ) };
	// 82EBA5D4: 4BFFEDAD  bl 0x82eb9380
	ctx.lr = 0x82EBA5D8;
	sub_82EB9380(ctx, base);
	// 82EBA5D8: 387F0254  addi r3, r31, 0x254
	ctx.r[3].s64 = ctx.r[31].s64 + 596;
	// 82EBA5DC: 4BFFEDA5  bl 0x82eb9380
	ctx.lr = 0x82EBA5E0;
	sub_82EB9380(ctx, base);
	// 82EBA5E0: 387F0240  addi r3, r31, 0x240
	ctx.r[3].s64 = ctx.r[31].s64 + 576;
	// 82EBA5E4: 4BFFED9D  bl 0x82eb9380
	ctx.lr = 0x82EBA5E8;
	sub_82EB9380(ctx, base);
	// 82EBA5E8: 387F022C  addi r3, r31, 0x22c
	ctx.r[3].s64 = ctx.r[31].s64 + 556;
	// 82EBA5EC: 4BFFED95  bl 0x82eb9380
	ctx.lr = 0x82EBA5F0;
	sub_82EB9380(ctx, base);
	// 82EBA5F0: 387F0218  addi r3, r31, 0x218
	ctx.r[3].s64 = ctx.r[31].s64 + 536;
	// 82EBA5F4: 4BFFED8D  bl 0x82eb9380
	ctx.lr = 0x82EBA5F8;
	sub_82EB9380(ctx, base);
	// 82EBA5F8: 387F0204  addi r3, r31, 0x204
	ctx.r[3].s64 = ctx.r[31].s64 + 516;
	// 82EBA5FC: 4BFFED85  bl 0x82eb9380
	ctx.lr = 0x82EBA600;
	sub_82EB9380(ctx, base);
	// 82EBA600: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 82EBA604: 4BFFED7D  bl 0x82eb9380
	ctx.lr = 0x82EBA608;
	sub_82EB9380(ctx, base);
	// 82EBA608: 387F01DC  addi r3, r31, 0x1dc
	ctx.r[3].s64 = ctx.r[31].s64 + 476;
	// 82EBA60C: 4BFFED75  bl 0x82eb9380
	ctx.lr = 0x82EBA610;
	sub_82EB9380(ctx, base);
	// 82EBA610: 387F01C8  addi r3, r31, 0x1c8
	ctx.r[3].s64 = ctx.r[31].s64 + 456;
	// 82EBA614: 4BFFED6D  bl 0x82eb9380
	ctx.lr = 0x82EBA618;
	sub_82EB9380(ctx, base);
	// 82EBA618: 387F01B4  addi r3, r31, 0x1b4
	ctx.r[3].s64 = ctx.r[31].s64 + 436;
	// 82EBA61C: 4BFFED65  bl 0x82eb9380
	ctx.lr = 0x82EBA620;
	sub_82EB9380(ctx, base);
	// 82EBA620: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EBA624: 4BFFED5D  bl 0x82eb9380
	ctx.lr = 0x82EBA628;
	sub_82EB9380(ctx, base);
	// 82EBA628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBA62C: 4BFCB24D  bl 0x82e85878
	ctx.lr = 0x82EBA630;
	sub_82E85878(ctx, base);
	// 82EBA630: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBA634: 4BDEEE24  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBA638 size=3388
    let mut pc: u32 = 0x82EBA638;
    'dispatch: loop {
        match pc {
            0x82EBA638 => {
    //   block [0x82EBA638..0x82EBB374)
	// 82EBA638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBA63C: 4BDEEDC1  bl 0x82ca93fc
	ctx.lr = 0x82EBA640;
	sub_82CA93D0(ctx, base);
	// 82EBA640: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBA644: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EBA648: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBA64C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EBA650: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBA654: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EBA658: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBA65C: C14A0C14  lfs f10, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBA660: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA664: 4182000C  beq 0x82eba670
	if ctx.cr[0].eq {
	pc = 0x82EBA670; continue 'dispatch;
	}
	// 82EBA668: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBA66C: 48000008  b 0x82eba674
	pc = 0x82EBA674; continue 'dispatch;
	// 82EBA670: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EBA674: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA678: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBA67C: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBA680: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA684: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBA688: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBA68C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBA690: 41980008  blt cr6, 0x82eba698
	if ctx.cr[6].lt {
	pc = 0x82EBA698; continue 'dispatch;
	}
	// 82EBA694: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82EBA698: FF0C6000  fcmpu cr6, f12, f12
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[12].f64);
	// 82EBA69C: 409AFFF0  bne cr6, 0x82eba68c
	if !ctx.cr[6].eq {
	pc = 0x82EBA68C; continue 'dispatch;
	}
	// 82EBA6A0: D19F0024  stfs f12, 0x24(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBA6A4: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBA6A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA6AC: 4182000C  beq 0x82eba6b8
	if ctx.cr[0].eq {
	pc = 0x82EBA6B8; continue 'dispatch;
	}
	// 82EBA6B0: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBA6B4: 48000008  b 0x82eba6bc
	pc = 0x82EBA6BC; continue 'dispatch;
	// 82EBA6B8: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 82EBA6BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA6C0: C01F002C  lfs f0, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBA6C4: C1AB0AEC  lfs f13, 0xaec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBA6C8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBA6CC: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EBA6D0: 41980008  blt cr6, 0x82eba6d8
	if ctx.cr[6].lt {
	pc = 0x82EBA6D8; continue 'dispatch;
	}
	// 82EBA6D4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBA6D8: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBA6DC: 409AFFF0  bne cr6, 0x82eba6cc
	if !ctx.cr[6].eq {
	pc = 0x82EBA6CC; continue 'dispatch;
	}
	// 82EBA6E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA6E4: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EBA6E8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EBA6EC: D15F043C  stfs f10, 0x43c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1084 as u32), tmp.u32 ) };
	// 82EBA6F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBA6F4: C1AB0BF8  lfs f13, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBA6F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBA6FC: D1BF0420  stfs f13, 0x420(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1056 as u32), tmp.u32 ) };
	// 82EBA700: 9B3F019D  stb r25, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[25].u8 ) };
	// 82EBA704: 997F019C  stb r11, 0x19c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u8 ) };
	// 82EBA708: 4BFCACA1  bl 0x82e853a8
	ctx.lr = 0x82EBA70C;
	sub_82E853A8(ctx, base);
	// 82EBA70C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA710: 4082000C  bne 0x82eba71c
	if !ctx.cr[0].eq {
	pc = 0x82EBA71C; continue 'dispatch;
	}
	// 82EBA714: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBA718: 48000C54  b 0x82ebb36c
	pc = 0x82EBB36C; continue 'dispatch;
	// 82EBA71C: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EBA720: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EBA724: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 82EBA728: 615CFFFF  ori r28, r10, 0xffff
	ctx.r[28].u64 = ctx.r[10].u64 | 65535;
	// 82EBA72C: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA730: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EBA734: 40990008  ble cr6, 0x82eba73c
	if !ctx.cr[6].gt {
	pc = 0x82EBA73C; continue 'dispatch;
	}
	// 82EBA738: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBA73C: 4B75C1ED  bl 0x82616928
	ctx.lr = 0x82EBA740;
	sub_82616928(ctx, base);
	// 82EBA740: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EBA744: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBA748: 907F0060  stw r3, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EBA74C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA750: 40990024  ble cr6, 0x82eba774
	if !ctx.cr[6].gt {
	pc = 0x82EBA774; continue 'dispatch;
	}
	// 82EBA754: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82EBA758: 813F0060  lwz r9, 0x60(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EBA75C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBA760: 7F29512E  stwx r25, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[25].u32) };
	// 82EBA764: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EBA768: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EBA76C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EBA770: 4198FFE8  blt cr6, 0x82eba758
	if ctx.cr[6].lt {
	pc = 0x82EBA758; continue 'dispatch;
	}
	// 82EBA774: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EBA778: 4B75C1B1  bl 0x82616928
	ctx.lr = 0x82EBA77C;
	sub_82616928(ctx, base);
	// 82EBA77C: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EBA780: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82EBA784: 907F0094  stw r3, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EBA788: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA78C: 817E9E3C  lwz r11, -0x61c4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EBA790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA794: 409A006C  bne cr6, 0x82eba800
	if !ctx.cr[6].eq {
	pc = 0x82EBA800; continue 'dispatch;
	}
	// 82EBA798: 3FA08330  lis r29, -0x7cd0
	ctx.r[29].s64 = -2094006272;
	// 82EBA79C: 3D400924  lis r10, 0x924
	ctx.r[10].s64 = 153354240;
	// 82EBA7A0: 614A9249  ori r10, r10, 0x9249
	ctx.r[10].u64 = ctx.r[10].u64 | 37449;
	// 82EBA7A4: 817DDF34  lwz r11, -0x20cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EBA7A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EBA7AC: 1C6B001C  mulli r3, r11, 0x1c
	ctx.r[3].s64 = ctx.r[11].s64 * 28;
	// 82EBA7B0: 40990008  ble cr6, 0x82eba7b8
	if !ctx.cr[6].gt {
	pc = 0x82EBA7B8; continue 'dispatch;
	}
	// 82EBA7B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBA7B8: 4B75C171  bl 0x82616928
	ctx.lr = 0x82EBA7BC;
	sub_82616928(ctx, base);
	// 82EBA7BC: 817DDF34  lwz r11, -0x20cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EBA7C0: 907E9E3C  stw r3, -0x61c4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-25028 as u32), ctx.r[3].u32 ) };
	// 82EBA7C4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EBA7C8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA7CC: 40990008  ble cr6, 0x82eba7d4
	if !ctx.cr[6].gt {
	pc = 0x82EBA7D4; continue 'dispatch;
	}
	// 82EBA7D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBA7D4: 4B75C155  bl 0x82616928
	ctx.lr = 0x82EBA7D8;
	sub_82616928(ctx, base);
	// 82EBA7D8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBA7DC: 817DDF34  lwz r11, -0x20cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EBA7E0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EBA7E4: 906A9E40  stw r3, -0x61c0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25024 as u32), ctx.r[3].u32 ) };
	// 82EBA7E8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA7EC: 40990008  ble cr6, 0x82eba7f4
	if !ctx.cr[6].gt {
	pc = 0x82EBA7F4; continue 'dispatch;
	}
	// 82EBA7F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBA7F4: 4B75C135  bl 0x82616928
	ctx.lr = 0x82EBA7F8;
	sub_82616928(ctx, base);
	// 82EBA7F8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBA7FC: 906B9E44  stw r3, -0x61bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25020 as u32), ctx.r[3].u32 ) };
	// 82EBA800: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBA804: 386001C4  li r3, 0x1c4
	ctx.r[3].s64 = 452;
	// 82EBA808: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EBA80C: 409A0020  bne cr6, 0x82eba82c
	if !ctx.cr[6].eq {
	pc = 0x82EBA82C; continue 'dispatch;
	}
	// 82EBA810: 4B75C119  bl 0x82616928
	ctx.lr = 0x82EBA814;
	sub_82616928(ctx, base);
	// 82EBA814: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA818: 41820040  beq 0x82eba858
	if ctx.cr[0].eq {
	pc = 0x82EBA858; continue 'dispatch;
	}
	// 82EBA81C: 3CC00005  lis r6, 5
	ctx.r[6].s64 = 327680;
	// 82EBA820: 38A02800  li r5, 0x2800
	ctx.r[5].s64 = 10240;
	// 82EBA824: 38803800  li r4, 0x3800
	ctx.r[4].s64 = 14336;
	// 82EBA828: 48000028  b 0x82eba850
	pc = 0x82EBA850; continue 'dispatch;
	// 82EBA82C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EBA830: 1FCB0018  mulli r30, r11, 0x18
	ctx.r[30].s64 = ctx.r[11].s64 * 24;
	// 82EBA834: 1FAB0014  mulli r29, r11, 0x14
	ctx.r[29].s64 = ctx.r[11].s64 * 20;
	// 82EBA838: 4B75C0F1  bl 0x82616928
	ctx.lr = 0x82EBA83C;
	sub_82616928(ctx, base);
	// 82EBA83C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA840: 41820018  beq 0x82eba858
	if ctx.cr[0].eq {
	pc = 0x82EBA858; continue 'dispatch;
	}
	// 82EBA844: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EBA848: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBA84C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA850: 4BFFBCA9  bl 0x82eb64f8
	ctx.lr = 0x82EBA854;
	sub_82EB64F8(ctx, base);
	// 82EBA854: 48000008  b 0x82eba85c
	pc = 0x82EBA85C; continue 'dispatch;
	// 82EBA858: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBA85C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA860: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EBA864: 3BCBA9B8  addi r30, r11, -0x5648
	ctx.r[30].s64 = ctx.r[11].s64 + -22088;
	// 82EBA868: 4B3A6151  bl 0x822609b8
	ctx.lr = 0x82EBA86C;
	sub_822609B8(ctx, base);
	// 82EBA86C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBA870: 4BFC68F9  bl 0x82e81168
	ctx.lr = 0x82EBA874;
	sub_82E81168(ctx, base);
	// 82EBA874: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA878: 907F0194  stw r3, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[3].u32 ) };
	// 82EBA87C: 3BCBA994  addi r30, r11, -0x566c
	ctx.r[30].s64 = ctx.r[11].s64 + -22124;
	// 82EBA880: 4B3A6139  bl 0x822609b8
	ctx.lr = 0x82EBA884;
	sub_822609B8(ctx, base);
	// 82EBA884: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBA888: 4BFC68E1  bl 0x82e81168
	ctx.lr = 0x82EBA88C;
	sub_82E81168(ctx, base);
	// 82EBA88C: 817F01B0  lwz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EBA890: 3B7F01B0  addi r27, r31, 0x1b0
	ctx.r[27].s64 = ctx.r[31].s64 + 432;
	// 82EBA894: 907F0414  stw r3, 0x414(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1044 as u32), ctx.r[3].u32 ) };
	// 82EBA898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA89C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA8A0: 3B4BA98C  addi r26, r11, -0x5674
	ctx.r[26].s64 = ctx.r[11].s64 + -22132;
	// 82EBA8A4: 409A00F0  bne cr6, 0x82eba994
	if !ctx.cr[6].eq {
	pc = 0x82EBA994; continue 'dispatch;
	}
	// 82EBA8A8: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA8AC: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBA8B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA8B4: 40990078  ble cr6, 0x82eba92c
	if !ctx.cr[6].gt {
	pc = 0x82EBA92C; continue 'dispatch;
	}
	// 82EBA8B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBA8BC: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBA8C0: 3B8BE058  addi r28, r11, -0x1fa8
	ctx.r[28].s64 = ctx.r[11].s64 + -8104;
	// 82EBA8C4: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBA8C8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA8CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA8D0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBA8D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA8D8: 4E800421  bctrl
	ctx.lr = 0x82EBA8DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA8DC: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBA8E0: 419A0034  beq cr6, 0x82eba914
	if ctx.cr[6].eq {
	pc = 0x82EBA914; continue 'dispatch;
	}
	// 82EBA8E4: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBA8E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA8EC: 4082FFF0  bne 0x82eba8dc
	if !ctx.cr[0].eq {
	pc = 0x82EBA8DC; continue 'dispatch;
	}
	// 82EBA8F0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBA8F4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA8F8: 40820024  bne 0x82eba91c
	if !ctx.cr[0].eq {
	pc = 0x82EBA91C; continue 'dispatch;
	}
	// 82EBA8FC: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA900: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA904: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA908: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA90C: 4198FFB8  blt cr6, 0x82eba8c4
	if ctx.cr[6].lt {
	pc = 0x82EBA8C4; continue 'dispatch;
	}
	// 82EBA910: 4800001C  b 0x82eba92c
	pc = 0x82EBA92C; continue 'dispatch;
	// 82EBA914: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBA918: 4BFFFFDC  b 0x82eba8f4
	pc = 0x82EBA8F4; continue 'dispatch;
	// 82EBA91C: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBA920: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBA924: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBA928: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA92C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA934: 409A0060  bne cr6, 0x82eba994
	if !ctx.cr[6].eq {
	pc = 0x82EBA994; continue 'dispatch;
	}
	// 82EBA938: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBA93C: 4B75BFED  bl 0x82616928
	ctx.lr = 0x82EBA940;
	sub_82616928(ctx, base);
	// 82EBA940: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBA944: 41820028  beq 0x82eba96c
	if ctx.cr[0].eq {
	pc = 0x82EBA96C; continue 'dispatch;
	}
	// 82EBA948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBA94C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBA950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBA954: 4BFFA9DD  bl 0x82eb5330
	ctx.lr = 0x82EBA958;
	sub_82EB5330(ctx, base);
	// 82EBA958: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBA960: 396BA7D0  addi r11, r11, -0x5830
	ctx.r[11].s64 = ctx.r[11].s64 + -22576;
	// 82EBA964: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA968: 48000008  b 0x82eba970
	pc = 0x82EBA970; continue 'dispatch;
	// 82EBA96C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBA970: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBA974: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBA978: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA97C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBA980: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA984: 4E800421  bctrl
	ctx.lr = 0x82EBA988;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA988: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBA98C: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EBA990: 4BFFE901  bl 0x82eb9290
	ctx.lr = 0x82EBA994;
	sub_82EB9290(ctx, base);
	// 82EBA994: 817F01C4  lwz r11, 0x1c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EBA998: 3B7F01C4  addi r27, r31, 0x1c4
	ctx.r[27].s64 = ctx.r[31].s64 + 452;
	// 82EBA99C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA9A0: 409A00F0  bne cr6, 0x82ebaa90
	if !ctx.cr[6].eq {
	pc = 0x82EBAA90; continue 'dispatch;
	}
	// 82EBA9A4: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA9A8: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBA9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA9B0: 40990078  ble cr6, 0x82ebaa28
	if !ctx.cr[6].gt {
	pc = 0x82EBAA28; continue 'dispatch;
	}
	// 82EBA9B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBA9B8: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBA9BC: 3B8BDD1C  addi r28, r11, -0x22e4
	ctx.r[28].s64 = ctx.r[11].s64 + -8932;
	// 82EBA9C0: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBA9C4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA9C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA9CC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBA9D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA9D4: 4E800421  bctrl
	ctx.lr = 0x82EBA9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA9D8: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBA9DC: 419A0034  beq cr6, 0x82ebaa10
	if ctx.cr[6].eq {
	pc = 0x82EBAA10; continue 'dispatch;
	}
	// 82EBA9E0: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBA9E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA9E8: 4082FFF0  bne 0x82eba9d8
	if !ctx.cr[0].eq {
	pc = 0x82EBA9D8; continue 'dispatch;
	}
	// 82EBA9EC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBA9F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA9F4: 40820024  bne 0x82ebaa18
	if !ctx.cr[0].eq {
	pc = 0x82EBAA18; continue 'dispatch;
	}
	// 82EBA9F8: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA9FC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAA00: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAA04: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAA08: 4198FFB8  blt cr6, 0x82eba9c0
	if ctx.cr[6].lt {
	pc = 0x82EBA9C0; continue 'dispatch;
	}
	// 82EBAA0C: 4800001C  b 0x82ebaa28
	pc = 0x82EBAA28; continue 'dispatch;
	// 82EBAA10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAA14: 4BFFFFDC  b 0x82eba9f0
	pc = 0x82EBA9F0; continue 'dispatch;
	// 82EBAA18: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBAA1C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAA20: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAA24: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAA28: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAA30: 409A0060  bne cr6, 0x82ebaa90
	if !ctx.cr[6].eq {
	pc = 0x82EBAA90; continue 'dispatch;
	}
	// 82EBAA34: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EBAA38: 4B75BEF1  bl 0x82616928
	ctx.lr = 0x82EBAA3C;
	sub_82616928(ctx, base);
	// 82EBAA3C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAA40: 41820028  beq 0x82ebaa68
	if ctx.cr[0].eq {
	pc = 0x82EBAA68; continue 'dispatch;
	}
	// 82EBAA44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAA48: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAA4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAA50: 4BFFA8E1  bl 0x82eb5330
	ctx.lr = 0x82EBAA54;
	sub_82EB5330(ctx, base);
	// 82EBAA54: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAA5C: 396BA7E8  addi r11, r11, -0x5818
	ctx.r[11].s64 = ctx.r[11].s64 + -22552;
	// 82EBAA60: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAA64: 48000008  b 0x82ebaa6c
	pc = 0x82EBAA6C; continue 'dispatch;
	// 82EBAA68: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAA6C: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAA70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAA74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAA78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAA7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAA80: 4E800421  bctrl
	ctx.lr = 0x82EBAA84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAA84: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAA88: 387F01B4  addi r3, r31, 0x1b4
	ctx.r[3].s64 = ctx.r[31].s64 + 436;
	// 82EBAA8C: 4BFFE805  bl 0x82eb9290
	ctx.lr = 0x82EBAA90;
	sub_82EB9290(ctx, base);
	// 82EBAA90: 817F01D8  lwz r11, 0x1d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EBAA94: 3B7F01D8  addi r27, r31, 0x1d8
	ctx.r[27].s64 = ctx.r[31].s64 + 472;
	// 82EBAA98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAA9C: 409A00F0  bne cr6, 0x82ebab8c
	if !ctx.cr[6].eq {
	pc = 0x82EBAB8C; continue 'dispatch;
	}
	// 82EBAAA0: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBAAA4: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAAA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAAAC: 40990078  ble cr6, 0x82ebab24
	if !ctx.cr[6].gt {
	pc = 0x82EBAB24; continue 'dispatch;
	}
	// 82EBAAB0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAAB4: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAAB8: 3B8BDAF4  addi r28, r11, -0x250c
	ctx.r[28].s64 = ctx.r[11].s64 + -9484;
	// 82EBAABC: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBAAC0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBAAC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAAC8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBAACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAAD0: 4E800421  bctrl
	ctx.lr = 0x82EBAAD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAAD4: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBAAD8: 419A0034  beq cr6, 0x82ebab0c
	if ctx.cr[6].eq {
	pc = 0x82EBAB0C; continue 'dispatch;
	}
	// 82EBAADC: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBAAE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAAE4: 4082FFF0  bne 0x82ebaad4
	if !ctx.cr[0].eq {
	pc = 0x82EBAAD4; continue 'dispatch;
	}
	// 82EBAAE8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBAAEC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBAAF0: 40820024  bne 0x82ebab14
	if !ctx.cr[0].eq {
	pc = 0x82EBAB14; continue 'dispatch;
	}
	// 82EBAAF4: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBAAF8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAAFC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAB00: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAB04: 4198FFB8  blt cr6, 0x82ebaabc
	if ctx.cr[6].lt {
	pc = 0x82EBAABC; continue 'dispatch;
	}
	// 82EBAB08: 4800001C  b 0x82ebab24
	pc = 0x82EBAB24; continue 'dispatch;
	// 82EBAB0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAB10: 4BFFFFDC  b 0x82ebaaec
	pc = 0x82EBAAEC; continue 'dispatch;
	// 82EBAB14: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBAB18: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAB1C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAB20: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAB24: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAB28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAB2C: 409A0060  bne cr6, 0x82ebab8c
	if !ctx.cr[6].eq {
	pc = 0x82EBAB8C; continue 'dispatch;
	}
	// 82EBAB30: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EBAB34: 4B75BDF5  bl 0x82616928
	ctx.lr = 0x82EBAB38;
	sub_82616928(ctx, base);
	// 82EBAB38: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAB3C: 41820028  beq 0x82ebab64
	if ctx.cr[0].eq {
	pc = 0x82EBAB64; continue 'dispatch;
	}
	// 82EBAB40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAB44: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAB48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAB4C: 4BFFA7E5  bl 0x82eb5330
	ctx.lr = 0x82EBAB50;
	sub_82EB5330(ctx, base);
	// 82EBAB50: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAB54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAB58: 396BA800  addi r11, r11, -0x5800
	ctx.r[11].s64 = ctx.r[11].s64 + -22528;
	// 82EBAB5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAB60: 48000008  b 0x82ebab68
	pc = 0x82EBAB68; continue 'dispatch;
	// 82EBAB64: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAB68: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAB6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAB70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAB74: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAB78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAB7C: 4E800421  bctrl
	ctx.lr = 0x82EBAB80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAB80: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAB84: 387F01C8  addi r3, r31, 0x1c8
	ctx.r[3].s64 = ctx.r[31].s64 + 456;
	// 82EBAB88: 4BFFE709  bl 0x82eb9290
	ctx.lr = 0x82EBAB8C;
	sub_82EB9290(ctx, base);
	// 82EBAB8C: 817F01EC  lwz r11, 0x1ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EBAB90: 3B7F01EC  addi r27, r31, 0x1ec
	ctx.r[27].s64 = ctx.r[31].s64 + 492;
	// 82EBAB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAB98: 409A00DC  bne cr6, 0x82ebac74
	if !ctx.cr[6].eq {
	pc = 0x82EBAC74; continue 'dispatch;
	}
	// 82EBAB9C: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBABA0: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBABA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBABA8: 40990078  ble cr6, 0x82ebac20
	if !ctx.cr[6].gt {
	pc = 0x82EBAC20; continue 'dispatch;
	}
	// 82EBABAC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBABB0: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBABB4: 3B8BD9E0  addi r28, r11, -0x2620
	ctx.r[28].s64 = ctx.r[11].s64 + -9760;
	// 82EBABB8: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBABBC: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBABC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBABC4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBABC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBABCC: 4E800421  bctrl
	ctx.lr = 0x82EBABD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBABD0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBABD4: 419A0034  beq cr6, 0x82ebac08
	if ctx.cr[6].eq {
	pc = 0x82EBAC08; continue 'dispatch;
	}
	// 82EBABD8: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBABDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBABE0: 4082FFF0  bne 0x82ebabd0
	if !ctx.cr[0].eq {
	pc = 0x82EBABD0; continue 'dispatch;
	}
	// 82EBABE4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBABE8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBABEC: 40820024  bne 0x82ebac10
	if !ctx.cr[0].eq {
	pc = 0x82EBAC10; continue 'dispatch;
	}
	// 82EBABF0: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBABF4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBABF8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBABFC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAC00: 4198FFB8  blt cr6, 0x82ebabb8
	if ctx.cr[6].lt {
	pc = 0x82EBABB8; continue 'dispatch;
	}
	// 82EBAC04: 4800001C  b 0x82ebac20
	pc = 0x82EBAC20; continue 'dispatch;
	// 82EBAC08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAC0C: 4BFFFFDC  b 0x82ebabe8
	pc = 0x82EBABE8; continue 'dispatch;
	// 82EBAC10: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBAC14: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAC18: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAC1C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAC20: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAC24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC28: 409A004C  bne cr6, 0x82ebac74
	if !ctx.cr[6].eq {
	pc = 0x82EBAC74; continue 'dispatch;
	}
	// 82EBAC2C: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 82EBAC30: 4B75BCF9  bl 0x82616928
	ctx.lr = 0x82EBAC34;
	sub_82616928(ctx, base);
	// 82EBAC34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC38: 41820014  beq 0x82ebac4c
	if ctx.cr[0].eq {
	pc = 0x82EBAC4C; continue 'dispatch;
	}
	// 82EBAC3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAC40: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAC44: 4BFFA865  bl 0x82eb54a8
	ctx.lr = 0x82EBAC48;
	sub_82EB54A8(ctx, base);
	// 82EBAC48: 48000008  b 0x82ebac50
	pc = 0x82EBAC50; continue 'dispatch;
	// 82EBAC4C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAC50: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAC54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAC58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAC5C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAC64: 4E800421  bctrl
	ctx.lr = 0x82EBAC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAC68: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAC6C: 387F01DC  addi r3, r31, 0x1dc
	ctx.r[3].s64 = ctx.r[31].s64 + 476;
	// 82EBAC70: 4BFFE621  bl 0x82eb9290
	ctx.lr = 0x82EBAC74;
	sub_82EB9290(ctx, base);
	// 82EBAC74: 817F0200  lwz r11, 0x200(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EBAC78: 3B7F0200  addi r27, r31, 0x200
	ctx.r[27].s64 = ctx.r[31].s64 + 512;
	// 82EBAC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC80: 409A00F0  bne cr6, 0x82ebad70
	if !ctx.cr[6].eq {
	pc = 0x82EBAD70; continue 'dispatch;
	}
	// 82EBAC84: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBAC88: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC90: 40990078  ble cr6, 0x82ebad08
	if !ctx.cr[6].gt {
	pc = 0x82EBAD08; continue 'dispatch;
	}
	// 82EBAC94: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAC98: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAC9C: 3B8BD8CC  addi r28, r11, -0x2734
	ctx.r[28].s64 = ctx.r[11].s64 + -10036;
	// 82EBACA0: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBACA4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBACA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBACAC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBACB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBACB4: 4E800421  bctrl
	ctx.lr = 0x82EBACB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBACB8: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBACBC: 419A0034  beq cr6, 0x82ebacf0
	if ctx.cr[6].eq {
	pc = 0x82EBACF0; continue 'dispatch;
	}
	// 82EBACC0: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBACC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBACC8: 4082FFF0  bne 0x82ebacb8
	if !ctx.cr[0].eq {
	pc = 0x82EBACB8; continue 'dispatch;
	}
	// 82EBACCC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBACD0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBACD4: 40820024  bne 0x82ebacf8
	if !ctx.cr[0].eq {
	pc = 0x82EBACF8; continue 'dispatch;
	}
	// 82EBACD8: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBACDC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBACE0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBACE4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBACE8: 4198FFB8  blt cr6, 0x82ebaca0
	if ctx.cr[6].lt {
	pc = 0x82EBACA0; continue 'dispatch;
	}
	// 82EBACEC: 4800001C  b 0x82ebad08
	pc = 0x82EBAD08; continue 'dispatch;
	// 82EBACF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBACF4: 4BFFFFDC  b 0x82ebacd0
	pc = 0x82EBACD0; continue 'dispatch;
	// 82EBACF8: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBACFC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAD00: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAD04: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAD08: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAD0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAD10: 409A0060  bne cr6, 0x82ebad70
	if !ctx.cr[6].eq {
	pc = 0x82EBAD70; continue 'dispatch;
	}
	// 82EBAD14: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EBAD18: 4B75BC11  bl 0x82616928
	ctx.lr = 0x82EBAD1C;
	sub_82616928(ctx, base);
	// 82EBAD1C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAD20: 41820028  beq 0x82ebad48
	if ctx.cr[0].eq {
	pc = 0x82EBAD48; continue 'dispatch;
	}
	// 82EBAD24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAD28: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAD2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAD30: 4BFFA601  bl 0x82eb5330
	ctx.lr = 0x82EBAD34;
	sub_82EB5330(ctx, base);
	// 82EBAD34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAD38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAD3C: 396BA84C  addi r11, r11, -0x57b4
	ctx.r[11].s64 = ctx.r[11].s64 + -22452;
	// 82EBAD40: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAD44: 48000008  b 0x82ebad4c
	pc = 0x82EBAD4C; continue 'dispatch;
	// 82EBAD48: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAD4C: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAD50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAD54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAD58: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAD5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAD60: 4E800421  bctrl
	ctx.lr = 0x82EBAD64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAD64: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAD68: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 82EBAD6C: 4BFFE525  bl 0x82eb9290
	ctx.lr = 0x82EBAD70;
	sub_82EB9290(ctx, base);
	// 82EBAD70: 817F0214  lwz r11, 0x214(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EBAD74: 3B7F0214  addi r27, r31, 0x214
	ctx.r[27].s64 = ctx.r[31].s64 + 532;
	// 82EBAD78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAD7C: 409A00F0  bne cr6, 0x82ebae6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAE6C; continue 'dispatch;
	}
	// 82EBAD80: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBAD84: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAD8C: 40990078  ble cr6, 0x82ebae04
	if !ctx.cr[6].gt {
	pc = 0x82EBAE04; continue 'dispatch;
	}
	// 82EBAD90: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAD94: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAD98: 3B8BD6A4  addi r28, r11, -0x295c
	ctx.r[28].s64 = ctx.r[11].s64 + -10588;
	// 82EBAD9C: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBADA0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBADA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBADA8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBADAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBADB0: 4E800421  bctrl
	ctx.lr = 0x82EBADB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBADB4: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBADB8: 419A0034  beq cr6, 0x82ebadec
	if ctx.cr[6].eq {
	pc = 0x82EBADEC; continue 'dispatch;
	}
	// 82EBADBC: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBADC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBADC4: 4082FFF0  bne 0x82ebadb4
	if !ctx.cr[0].eq {
	pc = 0x82EBADB4; continue 'dispatch;
	}
	// 82EBADC8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBADCC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBADD0: 40820024  bne 0x82ebadf4
	if !ctx.cr[0].eq {
	pc = 0x82EBADF4; continue 'dispatch;
	}
	// 82EBADD4: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBADD8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBADDC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBADE0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBADE4: 4198FFB8  blt cr6, 0x82ebad9c
	if ctx.cr[6].lt {
	pc = 0x82EBAD9C; continue 'dispatch;
	}
	// 82EBADE8: 4800001C  b 0x82ebae04
	pc = 0x82EBAE04; continue 'dispatch;
	// 82EBADEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBADF0: 4BFFFFDC  b 0x82ebadcc
	pc = 0x82EBADCC; continue 'dispatch;
	// 82EBADF4: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBADF8: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBADFC: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAE00: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAE04: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAE08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAE0C: 409A0060  bne cr6, 0x82ebae6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAE6C; continue 'dispatch;
	}
	// 82EBAE10: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EBAE14: 4B75BB15  bl 0x82616928
	ctx.lr = 0x82EBAE18;
	sub_82616928(ctx, base);
	// 82EBAE18: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAE1C: 41820028  beq 0x82ebae44
	if ctx.cr[0].eq {
	pc = 0x82EBAE44; continue 'dispatch;
	}
	// 82EBAE20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAE24: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAE28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAE2C: 4BFFA505  bl 0x82eb5330
	ctx.lr = 0x82EBAE30;
	sub_82EB5330(ctx, base);
	// 82EBAE30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAE34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAE38: 396BA834  addi r11, r11, -0x57cc
	ctx.r[11].s64 = ctx.r[11].s64 + -22476;
	// 82EBAE3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAE40: 48000008  b 0x82ebae48
	pc = 0x82EBAE48; continue 'dispatch;
	// 82EBAE44: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAE48: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAE4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAE50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAE54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAE58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAE5C: 4E800421  bctrl
	ctx.lr = 0x82EBAE60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAE60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAE64: 387F0204  addi r3, r31, 0x204
	ctx.r[3].s64 = ctx.r[31].s64 + 516;
	// 82EBAE68: 4BFFE429  bl 0x82eb9290
	ctx.lr = 0x82EBAE6C;
	sub_82EB9290(ctx, base);
	// 82EBAE6C: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EBAE70: 3B7F0228  addi r27, r31, 0x228
	ctx.r[27].s64 = ctx.r[31].s64 + 552;
	// 82EBAE74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAE78: 409A00F4  bne cr6, 0x82ebaf6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAF6C; continue 'dispatch;
	}
	// 82EBAE7C: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBAE80: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAE88: 40990078  ble cr6, 0x82ebaf00
	if !ctx.cr[6].gt {
	pc = 0x82EBAF00; continue 'dispatch;
	}
	// 82EBAE8C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAE90: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAE94: 3B8BD590  addi r28, r11, -0x2a70
	ctx.r[28].s64 = ctx.r[11].s64 + -10864;
	// 82EBAE98: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBAE9C: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAEA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAEA4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBAEA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAEAC: 4E800421  bctrl
	ctx.lr = 0x82EBAEB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAEB0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBAEB4: 419A0034  beq cr6, 0x82ebaee8
	if ctx.cr[6].eq {
	pc = 0x82EBAEE8; continue 'dispatch;
	}
	// 82EBAEB8: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBAEBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAEC0: 4082FFF0  bne 0x82ebaeb0
	if !ctx.cr[0].eq {
	pc = 0x82EBAEB0; continue 'dispatch;
	}
	// 82EBAEC4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBAEC8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBAECC: 40820024  bne 0x82ebaef0
	if !ctx.cr[0].eq {
	pc = 0x82EBAEF0; continue 'dispatch;
	}
	// 82EBAED0: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBAED4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAED8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAEDC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAEE0: 4198FFB8  blt cr6, 0x82ebae98
	if ctx.cr[6].lt {
	pc = 0x82EBAE98; continue 'dispatch;
	}
	// 82EBAEE4: 4800001C  b 0x82ebaf00
	pc = 0x82EBAF00; continue 'dispatch;
	// 82EBAEE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAEEC: 4BFFFFDC  b 0x82ebaec8
	pc = 0x82EBAEC8; continue 'dispatch;
	// 82EBAEF0: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBAEF4: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAEF8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAEFC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAF00: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAF08: 409A0064  bne cr6, 0x82ebaf6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAF6C; continue 'dispatch;
	}
	// 82EBAF0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EBAF10: 4B75BA19  bl 0x82616928
	ctx.lr = 0x82EBAF14;
	sub_82616928(ctx, base);
	// 82EBAF14: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAF18: 4182002C  beq 0x82ebaf44
	if ctx.cr[0].eq {
	pc = 0x82EBAF44; continue 'dispatch;
	}
	// 82EBAF1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAF20: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAF24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAF28: 4BFFA409  bl 0x82eb5330
	ctx.lr = 0x82EBAF2C;
	sub_82EB5330(ctx, base);
	// 82EBAF2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAF30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAF34: 933E000C  stw r25, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 82EBAF38: 396BA890  addi r11, r11, -0x5770
	ctx.r[11].s64 = ctx.r[11].s64 + -22384;
	// 82EBAF3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAF40: 48000008  b 0x82ebaf48
	pc = 0x82EBAF48; continue 'dispatch;
	// 82EBAF44: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAF48: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAF4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAF50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAF54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAF58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAF5C: 4E800421  bctrl
	ctx.lr = 0x82EBAF60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAF60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAF64: 387F0218  addi r3, r31, 0x218
	ctx.r[3].s64 = ctx.r[31].s64 + 536;
	// 82EBAF68: 4BFFE329  bl 0x82eb9290
	ctx.lr = 0x82EBAF6C;
	sub_82EB9290(ctx, base);
	// 82EBAF6C: 817F0264  lwz r11, 0x264(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBAF70: 3B7F0264  addi r27, r31, 0x264
	ctx.r[27].s64 = ctx.r[31].s64 + 612;
	// 82EBAF74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAF78: 409A00DC  bne cr6, 0x82ebb054
	if !ctx.cr[6].eq {
	pc = 0x82EBB054; continue 'dispatch;
	}
	// 82EBAF7C: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBAF80: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAF84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAF88: 40990078  ble cr6, 0x82ebb000
	if !ctx.cr[6].gt {
	pc = 0x82EBB000; continue 'dispatch;
	}
	// 82EBAF8C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAF90: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAF94: 3B8BCDF0  addi r28, r11, -0x3210
	ctx.r[28].s64 = ctx.r[11].s64 + -12816;
	// 82EBAF98: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBAF9C: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAFA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAFA4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBAFA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAFAC: 4E800421  bctrl
	ctx.lr = 0x82EBAFB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAFB0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBAFB4: 419A0034  beq cr6, 0x82ebafe8
	if ctx.cr[6].eq {
	pc = 0x82EBAFE8; continue 'dispatch;
	}
	// 82EBAFB8: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBAFBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAFC0: 4082FFF0  bne 0x82ebafb0
	if !ctx.cr[0].eq {
	pc = 0x82EBAFB0; continue 'dispatch;
	}
	// 82EBAFC4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBAFC8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBAFCC: 40820024  bne 0x82ebaff0
	if !ctx.cr[0].eq {
	pc = 0x82EBAFF0; continue 'dispatch;
	}
	// 82EBAFD0: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBAFD4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAFD8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAFDC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAFE0: 4198FFB8  blt cr6, 0x82ebaf98
	if ctx.cr[6].lt {
	pc = 0x82EBAF98; continue 'dispatch;
	}
	// 82EBAFE4: 4800001C  b 0x82ebb000
	pc = 0x82EBB000; continue 'dispatch;
	// 82EBAFE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAFEC: 4BFFFFDC  b 0x82ebafc8
	pc = 0x82EBAFC8; continue 'dispatch;
	// 82EBAFF0: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBAFF4: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAFF8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAFFC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB000: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB008: 409A004C  bne cr6, 0x82ebb054
	if !ctx.cr[6].eq {
	pc = 0x82EBB054; continue 'dispatch;
	}
	// 82EBB00C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82EBB010: 4B75B919  bl 0x82616928
	ctx.lr = 0x82EBB014;
	sub_82616928(ctx, base);
	// 82EBB014: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB018: 41820014  beq 0x82ebb02c
	if ctx.cr[0].eq {
	pc = 0x82EBB02C; continue 'dispatch;
	}
	// 82EBB01C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB020: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB024: 4BFFA72D  bl 0x82eb5750
	ctx.lr = 0x82EBB028;
	sub_82EB5750(ctx, base);
	// 82EBB028: 48000008  b 0x82ebb030
	pc = 0x82EBB030; continue 'dispatch;
	// 82EBB02C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBB030: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB034: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB038: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB03C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB040: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB044: 4E800421  bctrl
	ctx.lr = 0x82EBB048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB048: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB04C: 387F0254  addi r3, r31, 0x254
	ctx.r[3].s64 = ctx.r[31].s64 + 596;
	// 82EBB050: 4BFFE241  bl 0x82eb9290
	ctx.lr = 0x82EBB054;
	sub_82EB9290(ctx, base);
	// 82EBB054: 817F0250  lwz r11, 0x250(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBB058: 3B7F0250  addi r27, r31, 0x250
	ctx.r[27].s64 = ctx.r[31].s64 + 592;
	// 82EBB05C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB060: 409A00DC  bne cr6, 0x82ebb13c
	if !ctx.cr[6].eq {
	pc = 0x82EBB13C; continue 'dispatch;
	}
	// 82EBB064: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBB068: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBB06C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB070: 40990078  ble cr6, 0x82ebb0e8
	if !ctx.cr[6].gt {
	pc = 0x82EBB0E8; continue 'dispatch;
	}
	// 82EBB074: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EBB078: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBB07C: 3B8B89BC  addi r28, r11, -0x7644
	ctx.r[28].s64 = ctx.r[11].s64 + -30276;
	// 82EBB080: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBB084: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBB088: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB08C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBB090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB094: 4E800421  bctrl
	ctx.lr = 0x82EBB098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB098: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBB09C: 419A0034  beq cr6, 0x82ebb0d0
	if ctx.cr[6].eq {
	pc = 0x82EBB0D0; continue 'dispatch;
	}
	// 82EBB0A0: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBB0A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB0A8: 4082FFF0  bne 0x82ebb098
	if !ctx.cr[0].eq {
	pc = 0x82EBB098; continue 'dispatch;
	}
	// 82EBB0AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBB0B0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBB0B4: 40820024  bne 0x82ebb0d8
	if !ctx.cr[0].eq {
	pc = 0x82EBB0D8; continue 'dispatch;
	}
	// 82EBB0B8: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBB0BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBB0C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBB0C4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBB0C8: 4198FFB8  blt cr6, 0x82ebb080
	if ctx.cr[6].lt {
	pc = 0x82EBB080; continue 'dispatch;
	}
	// 82EBB0CC: 4800001C  b 0x82ebb0e8
	pc = 0x82EBB0E8; continue 'dispatch;
	// 82EBB0D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBB0D4: 4BFFFFDC  b 0x82ebb0b0
	pc = 0x82EBB0B0; continue 'dispatch;
	// 82EBB0D8: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBB0DC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBB0E0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB0E4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB0E8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB0EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB0F0: 409A004C  bne cr6, 0x82ebb13c
	if !ctx.cr[6].eq {
	pc = 0x82EBB13C; continue 'dispatch;
	}
	// 82EBB0F4: 3860011C  li r3, 0x11c
	ctx.r[3].s64 = 284;
	// 82EBB0F8: 4B75B831  bl 0x82616928
	ctx.lr = 0x82EBB0FC;
	sub_82616928(ctx, base);
	// 82EBB0FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB100: 41820014  beq 0x82ebb114
	if ctx.cr[0].eq {
	pc = 0x82EBB114; continue 'dispatch;
	}
	// 82EBB104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB108: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB10C: 4801FD75  bl 0x82edae80
	ctx.lr = 0x82EBB110;
	sub_82EDAE80(ctx, base);
	// 82EBB110: 48000008  b 0x82ebb118
	pc = 0x82EBB118; continue 'dispatch;
	// 82EBB114: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBB118: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB11C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB120: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB124: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB128: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB12C: 4E800421  bctrl
	ctx.lr = 0x82EBB130;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB130: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB134: 387F0240  addi r3, r31, 0x240
	ctx.r[3].s64 = ctx.r[31].s64 + 576;
	// 82EBB138: 4BFFE159  bl 0x82eb9290
	ctx.lr = 0x82EBB13C;
	sub_82EB9290(ctx, base);
	// 82EBB13C: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EBB140: 3B7F023C  addi r27, r31, 0x23c
	ctx.r[27].s64 = ctx.r[31].s64 + 572;
	// 82EBB144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB148: 409A00DC  bne cr6, 0x82ebb224
	if !ctx.cr[6].eq {
	pc = 0x82EBB224; continue 'dispatch;
	}
	// 82EBB14C: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBB150: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBB154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB158: 40990078  ble cr6, 0x82ebb1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBB1D0; continue 'dispatch;
	}
	// 82EBB15C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBB160: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBB164: 3B8BD244  addi r28, r11, -0x2dbc
	ctx.r[28].s64 = ctx.r[11].s64 + -11708;
	// 82EBB168: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBB16C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBB170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB174: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBB178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB17C: 4E800421  bctrl
	ctx.lr = 0x82EBB180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB180: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBB184: 419A0034  beq cr6, 0x82ebb1b8
	if ctx.cr[6].eq {
	pc = 0x82EBB1B8; continue 'dispatch;
	}
	// 82EBB188: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBB18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB190: 4082FFF0  bne 0x82ebb180
	if !ctx.cr[0].eq {
	pc = 0x82EBB180; continue 'dispatch;
	}
	// 82EBB194: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBB198: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBB19C: 40820024  bne 0x82ebb1c0
	if !ctx.cr[0].eq {
	pc = 0x82EBB1C0; continue 'dispatch;
	}
	// 82EBB1A0: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBB1A4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBB1A8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBB1AC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBB1B0: 4198FFB8  blt cr6, 0x82ebb168
	if ctx.cr[6].lt {
	pc = 0x82EBB168; continue 'dispatch;
	}
	// 82EBB1B4: 4800001C  b 0x82ebb1d0
	pc = 0x82EBB1D0; continue 'dispatch;
	// 82EBB1B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBB1BC: 4BFFFFDC  b 0x82ebb198
	pc = 0x82EBB198; continue 'dispatch;
	// 82EBB1C0: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBB1C4: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBB1C8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB1CC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB1D0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB1D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB1D8: 409A004C  bne cr6, 0x82ebb224
	if !ctx.cr[6].eq {
	pc = 0x82EBB224; continue 'dispatch;
	}
	// 82EBB1DC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EBB1E0: 4B75B749  bl 0x82616928
	ctx.lr = 0x82EBB1E4;
	sub_82616928(ctx, base);
	// 82EBB1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB1E8: 41820014  beq 0x82ebb1fc
	if ctx.cr[0].eq {
	pc = 0x82EBB1FC; continue 'dispatch;
	}
	// 82EBB1EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB1F0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB1F4: 4BFFA345  bl 0x82eb5538
	ctx.lr = 0x82EBB1F8;
	sub_82EB5538(ctx, base);
	// 82EBB1F8: 48000008  b 0x82ebb200
	pc = 0x82EBB200; continue 'dispatch;
	// 82EBB1FC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBB200: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB204: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB20C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB214: 4E800421  bctrl
	ctx.lr = 0x82EBB218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB218: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB21C: 387F022C  addi r3, r31, 0x22c
	ctx.r[3].s64 = ctx.r[31].s64 + 556;
	// 82EBB220: 4BFFE071  bl 0x82eb9290
	ctx.lr = 0x82EBB224;
	sub_82EB9290(ctx, base);
	// 82EBB224: 817F0278  lwz r11, 0x278(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EBB228: 3B7F0278  addi r27, r31, 0x278
	ctx.r[27].s64 = ctx.r[31].s64 + 632;
	// 82EBB22C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB230: 409A00F0  bne cr6, 0x82ebb320
	if !ctx.cr[6].eq {
	pc = 0x82EBB320; continue 'dispatch;
	}
	// 82EBB234: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBB238: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBB23C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB240: 40990078  ble cr6, 0x82ebb2b8
	if !ctx.cr[6].gt {
	pc = 0x82EBB2B8; continue 'dispatch;
	}
	// 82EBB244: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBB248: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBB24C: 3B8BCBC8  addi r28, r11, -0x3438
	ctx.r[28].s64 = ctx.r[11].s64 + -13368;
	// 82EBB250: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBB254: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB25C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBB260: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB264: 4E800421  bctrl
	ctx.lr = 0x82EBB268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB268: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBB26C: 419A0034  beq cr6, 0x82ebb2a0
	if ctx.cr[6].eq {
	pc = 0x82EBB2A0; continue 'dispatch;
	}
	// 82EBB270: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBB274: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB278: 4082FFF0  bne 0x82ebb268
	if !ctx.cr[0].eq {
	pc = 0x82EBB268; continue 'dispatch;
	}
	// 82EBB27C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBB280: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBB284: 40820024  bne 0x82ebb2a8
	if !ctx.cr[0].eq {
	pc = 0x82EBB2A8; continue 'dispatch;
	}
	// 82EBB288: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBB28C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBB290: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBB294: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBB298: 4198FFB8  blt cr6, 0x82ebb250
	if ctx.cr[6].lt {
	pc = 0x82EBB250; continue 'dispatch;
	}
	// 82EBB29C: 4800001C  b 0x82ebb2b8
	pc = 0x82EBB2B8; continue 'dispatch;
	// 82EBB2A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBB2A4: 4BFFFFDC  b 0x82ebb280
	pc = 0x82EBB280; continue 'dispatch;
	// 82EBB2A8: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBB2AC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBB2B0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB2B4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB2B8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB2C0: 409A0060  bne cr6, 0x82ebb320
	if !ctx.cr[6].eq {
	pc = 0x82EBB320; continue 'dispatch;
	}
	// 82EBB2C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBB2C8: 4B75B661  bl 0x82616928
	ctx.lr = 0x82EBB2CC;
	sub_82616928(ctx, base);
	// 82EBB2CC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBB2D0: 41820028  beq 0x82ebb2f8
	if ctx.cr[0].eq {
	pc = 0x82EBB2F8; continue 'dispatch;
	}
	// 82EBB2D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB2D8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB2DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBB2E0: 4BFFA051  bl 0x82eb5330
	ctx.lr = 0x82EBB2E4;
	sub_82EB5330(ctx, base);
	// 82EBB2E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBB2E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBB2EC: 396BA8D8  addi r11, r11, -0x5728
	ctx.r[11].s64 = ctx.r[11].s64 + -22312;
	// 82EBB2F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB2F4: 48000008  b 0x82ebb2fc
	pc = 0x82EBB2FC; continue 'dispatch;
	// 82EBB2F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBB2FC: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB300: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB304: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB308: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB30C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB310: 4E800421  bctrl
	ctx.lr = 0x82EBB314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB314: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB318: 387F0268  addi r3, r31, 0x268
	ctx.r[3].s64 = ctx.r[31].s64 + 616;
	// 82EBB31C: 4BFFDF75  bl 0x82eb9290
	ctx.lr = 0x82EBB320;
	sub_82EB9290(ctx, base);
	// 82EBB320: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB324: 389F0418  addi r4, r31, 0x418
	ctx.r[4].s64 = ctx.r[31].s64 + 1048;
	// 82EBB328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB32C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EBB330: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB334: 4E800421  bctrl
	ctx.lr = 0x82EBB338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB338: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB33C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB340: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBB344: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB348: 4E800421  bctrl
	ctx.lr = 0x82EBB34C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB34C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBB350: 3BCBA974  addi r30, r11, -0x568c
	ctx.r[30].s64 = ctx.r[11].s64 + -22156;
	// 82EBB354: 4B3A5665  bl 0x822609b8
	ctx.lr = 0x82EBB358;
	sub_822609B8(ctx, base);
	// 82EBB358: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBB35C: 4BFC5EDD  bl 0x82e81238
	ctx.lr = 0x82EBB360;
	sub_82E81238(ctx, base);
	// 82EBB360: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBB364: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBB368: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EBB36C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EBB370: 4BDEE0DC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB378 size=116
    let mut pc: u32 = 0x82EBB378;
    'dispatch: loop {
        match pc {
            0x82EBB378 => {
    //   block [0x82EBB378..0x82EBB3EC)
	// 82EBB378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB384: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB388: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB38C: 816AA374  lwz r11, -0x5c8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23692 as u32) ) } as u64;
	// 82EBB390: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB394: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB398: 3BE99F70  addi r31, r9, -0x6090
	ctx.r[31].s64 = ctx.r[9].s64 + -24720;
	// 82EBB39C: 40820038  bne 0x82ebb3d4
	if !ctx.cr[0].eq {
	pc = 0x82EBB3D4; continue 'dispatch;
	}
	// 82EBB3A0: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB3A4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB3A8: 8909DF40  lbz r8, -0x20c0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8384 as u32) ) } as u64;
	// 82EBB3AC: 916AA374  stw r11, -0x5c8c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-23692 as u32), ctx.r[11].u32 ) };
	// 82EBB3B0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB3B4: 4182000C  beq 0x82ebb3c0
	if ctx.cr[0].eq {
	pc = 0x82EBB3C0; continue 'dispatch;
	}
	// 82EBB3B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB3BC: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB3C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB3C4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB3C8: 386A8BA8  addi r3, r10, -0x7458
	ctx.r[3].s64 = ctx.r[10].s64 + -29784;
	// 82EBB3CC: 9969DF40  stb r11, -0x20c0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8384 as u32), ctx.r[11].u8 ) };
	// 82EBB3D0: 4BDEEB51  bl 0x82ca9f20
	ctx.lr = 0x82EBB3D4;
	sub_82CA9F20(ctx, base);
	// 82EBB3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB3D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB3DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB3E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB3E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB3E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB3F0 size=116
    let mut pc: u32 = 0x82EBB3F0;
    'dispatch: loop {
        match pc {
            0x82EBB3F0 => {
    //   block [0x82EBB3F0..0x82EBB464)
	// 82EBB3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB3F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB3FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB400: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB404: 816AA77C  lwz r11, -0x5884(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-22660 as u32) ) } as u64;
	// 82EBB408: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB40C: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB410: 3BE9A378  addi r31, r9, -0x5c88
	ctx.r[31].s64 = ctx.r[9].s64 + -23688;
	// 82EBB414: 40820038  bne 0x82ebb44c
	if !ctx.cr[0].eq {
	pc = 0x82EBB44C; continue 'dispatch;
	}
	// 82EBB418: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB41C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB420: 8909DF41  lbz r8, -0x20bf(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8383 as u32) ) } as u64;
	// 82EBB424: 916AA77C  stw r11, -0x5884(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-22660 as u32), ctx.r[11].u32 ) };
	// 82EBB428: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB42C: 4182000C  beq 0x82ebb438
	if ctx.cr[0].eq {
	pc = 0x82EBB438; continue 'dispatch;
	}
	// 82EBB430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB434: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB43C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB440: 386A8B90  addi r3, r10, -0x7470
	ctx.r[3].s64 = ctx.r[10].s64 + -29808;
	// 82EBB444: 9969DF41  stb r11, -0x20bf(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8383 as u32), ctx.r[11].u8 ) };
	// 82EBB448: 4BDEEAD9  bl 0x82ca9f20
	ctx.lr = 0x82EBB44C;
	sub_82CA9F20(ctx, base);
	// 82EBB44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB450: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB45C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB468 size=116
    let mut pc: u32 = 0x82EBB468;
    'dispatch: loop {
        match pc {
            0x82EBB468 => {
    //   block [0x82EBB468..0x82EBB4DC)
	// 82EBB468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB470: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB474: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB478: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB47C: 816AAB84  lwz r11, -0x547c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21628 as u32) ) } as u64;
	// 82EBB480: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB484: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB488: 3BE9A780  addi r31, r9, -0x5880
	ctx.r[31].s64 = ctx.r[9].s64 + -22656;
	// 82EBB48C: 40820038  bne 0x82ebb4c4
	if !ctx.cr[0].eq {
	pc = 0x82EBB4C4; continue 'dispatch;
	}
	// 82EBB490: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB494: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB498: 8909DF42  lbz r8, -0x20be(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8382 as u32) ) } as u64;
	// 82EBB49C: 916AAB84  stw r11, -0x547c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21628 as u32), ctx.r[11].u32 ) };
	// 82EBB4A0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB4A4: 4182000C  beq 0x82ebb4b0
	if ctx.cr[0].eq {
	pc = 0x82EBB4B0; continue 'dispatch;
	}
	// 82EBB4A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB4AC: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB4B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB4B4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB4B8: 386A8B78  addi r3, r10, -0x7488
	ctx.r[3].s64 = ctx.r[10].s64 + -29832;
	// 82EBB4BC: 9969DF42  stb r11, -0x20be(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8382 as u32), ctx.r[11].u8 ) };
	// 82EBB4C0: 4BDEEA61  bl 0x82ca9f20
	ctx.lr = 0x82EBB4C4;
	sub_82CA9F20(ctx, base);
	// 82EBB4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB4C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB4CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB4D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB4D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB4D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB4E0 size=116
    let mut pc: u32 = 0x82EBB4E0;
    'dispatch: loop {
        match pc {
            0x82EBB4E0 => {
    //   block [0x82EBB4E0..0x82EBB554)
	// 82EBB4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB4E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB4EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB4F0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB4F4: 816AAF8C  lwz r11, -0x5074(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20596 as u32) ) } as u64;
	// 82EBB4F8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB4FC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB500: 3BE9AB88  addi r31, r9, -0x5478
	ctx.r[31].s64 = ctx.r[9].s64 + -21624;
	// 82EBB504: 40820038  bne 0x82ebb53c
	if !ctx.cr[0].eq {
	pc = 0x82EBB53C; continue 'dispatch;
	}
	// 82EBB508: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB50C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB510: 8909DF44  lbz r8, -0x20bc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8380 as u32) ) } as u64;
	// 82EBB514: 916AAF8C  stw r11, -0x5074(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20596 as u32), ctx.r[11].u32 ) };
	// 82EBB518: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB51C: 4182000C  beq 0x82ebb528
	if ctx.cr[0].eq {
	pc = 0x82EBB528; continue 'dispatch;
	}
	// 82EBB520: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB524: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB52C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB530: 386A8B60  addi r3, r10, -0x74a0
	ctx.r[3].s64 = ctx.r[10].s64 + -29856;
	// 82EBB534: 9969DF44  stb r11, -0x20bc(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8380 as u32), ctx.r[11].u8 ) };
	// 82EBB538: 4BDEE9E9  bl 0x82ca9f20
	ctx.lr = 0x82EBB53C;
	sub_82CA9F20(ctx, base);
	// 82EBB53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB540: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB544: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB548: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB54C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB558 size=116
    let mut pc: u32 = 0x82EBB558;
    'dispatch: loop {
        match pc {
            0x82EBB558 => {
    //   block [0x82EBB558..0x82EBB5CC)
	// 82EBB558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB560: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB564: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB568: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB56C: 816AB394  lwz r11, -0x4c6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19564 as u32) ) } as u64;
	// 82EBB570: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB574: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB578: 3BE9AF90  addi r31, r9, -0x5070
	ctx.r[31].s64 = ctx.r[9].s64 + -20592;
	// 82EBB57C: 40820038  bne 0x82ebb5b4
	if !ctx.cr[0].eq {
	pc = 0x82EBB5B4; continue 'dispatch;
	}
	// 82EBB580: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB584: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB588: 8909DF46  lbz r8, -0x20ba(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8378 as u32) ) } as u64;
	// 82EBB58C: 916AB394  stw r11, -0x4c6c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19564 as u32), ctx.r[11].u32 ) };
	// 82EBB590: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB594: 4182000C  beq 0x82ebb5a0
	if ctx.cr[0].eq {
	pc = 0x82EBB5A0; continue 'dispatch;
	}
	// 82EBB598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB59C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB5A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB5A4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB5A8: 386A8B48  addi r3, r10, -0x74b8
	ctx.r[3].s64 = ctx.r[10].s64 + -29880;
	// 82EBB5AC: 9969DF46  stb r11, -0x20ba(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8378 as u32), ctx.r[11].u8 ) };
	// 82EBB5B0: 4BDEE971  bl 0x82ca9f20
	ctx.lr = 0x82EBB5B4;
	sub_82CA9F20(ctx, base);
	// 82EBB5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB5B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB5BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB5C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB5C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB5C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB5D0 size=116
    let mut pc: u32 = 0x82EBB5D0;
    'dispatch: loop {
        match pc {
            0x82EBB5D0 => {
    //   block [0x82EBB5D0..0x82EBB644)
	// 82EBB5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB5D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB5D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB5DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB5E0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB5E4: 816AB79C  lwz r11, -0x4864(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18532 as u32) ) } as u64;
	// 82EBB5E8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB5EC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB5F0: 3BE9B398  addi r31, r9, -0x4c68
	ctx.r[31].s64 = ctx.r[9].s64 + -19560;
	// 82EBB5F4: 40820038  bne 0x82ebb62c
	if !ctx.cr[0].eq {
	pc = 0x82EBB62C; continue 'dispatch;
	}
	// 82EBB5F8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB5FC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB600: 8909DF45  lbz r8, -0x20bb(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8379 as u32) ) } as u64;
	// 82EBB604: 916AB79C  stw r11, -0x4864(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18532 as u32), ctx.r[11].u32 ) };
	// 82EBB608: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB60C: 4182000C  beq 0x82ebb618
	if ctx.cr[0].eq {
	pc = 0x82EBB618; continue 'dispatch;
	}
	// 82EBB610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB614: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB61C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB620: 386A8B30  addi r3, r10, -0x74d0
	ctx.r[3].s64 = ctx.r[10].s64 + -29904;
	// 82EBB624: 9969DF45  stb r11, -0x20bb(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8379 as u32), ctx.r[11].u8 ) };
	// 82EBB628: 4BDEE8F9  bl 0x82ca9f20
	ctx.lr = 0x82EBB62C;
	sub_82CA9F20(ctx, base);
	// 82EBB62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB63C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB648 size=116
    let mut pc: u32 = 0x82EBB648;
    'dispatch: loop {
        match pc {
            0x82EBB648 => {
    //   block [0x82EBB648..0x82EBB6BC)
	// 82EBB648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB654: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB658: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB65C: 816ABBA4  lwz r11, -0x445c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17500 as u32) ) } as u64;
	// 82EBB660: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB664: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB668: 3BE9B7A0  addi r31, r9, -0x4860
	ctx.r[31].s64 = ctx.r[9].s64 + -18528;
	// 82EBB66C: 40820038  bne 0x82ebb6a4
	if !ctx.cr[0].eq {
	pc = 0x82EBB6A4; continue 'dispatch;
	}
	// 82EBB670: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB674: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB678: 8909DF47  lbz r8, -0x20b9(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8377 as u32) ) } as u64;
	// 82EBB67C: 916ABBA4  stw r11, -0x445c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17500 as u32), ctx.r[11].u32 ) };
	// 82EBB680: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB684: 4182000C  beq 0x82ebb690
	if ctx.cr[0].eq {
	pc = 0x82EBB690; continue 'dispatch;
	}
	// 82EBB688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB68C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB694: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB698: 386A8B18  addi r3, r10, -0x74e8
	ctx.r[3].s64 = ctx.r[10].s64 + -29928;
	// 82EBB69C: 9969DF47  stb r11, -0x20b9(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8377 as u32), ctx.r[11].u8 ) };
	// 82EBB6A0: 4BDEE881  bl 0x82ca9f20
	ctx.lr = 0x82EBB6A4;
	sub_82CA9F20(ctx, base);
	// 82EBB6A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB6A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB6AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB6B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB6B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB6B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB6C0 size=116
    let mut pc: u32 = 0x82EBB6C0;
    'dispatch: loop {
        match pc {
            0x82EBB6C0 => {
    //   block [0x82EBB6C0..0x82EBB734)
	// 82EBB6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB6C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB6CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB6D0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB6D4: 816ABFAC  lwz r11, -0x4054(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16468 as u32) ) } as u64;
	// 82EBB6D8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB6DC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB6E0: 3BE9BBA8  addi r31, r9, -0x4458
	ctx.r[31].s64 = ctx.r[9].s64 + -17496;
	// 82EBB6E4: 40820038  bne 0x82ebb71c
	if !ctx.cr[0].eq {
	pc = 0x82EBB71C; continue 'dispatch;
	}
	// 82EBB6E8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB6EC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB6F0: 8909DF43  lbz r8, -0x20bd(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8381 as u32) ) } as u64;
	// 82EBB6F4: 916ABFAC  stw r11, -0x4054(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16468 as u32), ctx.r[11].u32 ) };
	// 82EBB6F8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB6FC: 4182000C  beq 0x82ebb708
	if ctx.cr[0].eq {
	pc = 0x82EBB708; continue 'dispatch;
	}
	// 82EBB700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB704: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB70C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB710: 386A8B00  addi r3, r10, -0x7500
	ctx.r[3].s64 = ctx.r[10].s64 + -29952;
	// 82EBB714: 9969DF43  stb r11, -0x20bd(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8381 as u32), ctx.r[11].u8 ) };
	// 82EBB718: 4BDEE809  bl 0x82ca9f20
	ctx.lr = 0x82EBB71C;
	sub_82CA9F20(ctx, base);
	// 82EBB71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB720: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB72C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB738 size=116
    let mut pc: u32 = 0x82EBB738;
    'dispatch: loop {
        match pc {
            0x82EBB738 => {
    //   block [0x82EBB738..0x82EBB7AC)
	// 82EBB738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB73C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB740: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB744: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB748: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB74C: 816AC3B4  lwz r11, -0x3c4c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15436 as u32) ) } as u64;
	// 82EBB750: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB754: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB758: 3BE9BFB0  addi r31, r9, -0x4050
	ctx.r[31].s64 = ctx.r[9].s64 + -16464;
	// 82EBB75C: 40820038  bne 0x82ebb794
	if !ctx.cr[0].eq {
	pc = 0x82EBB794; continue 'dispatch;
	}
	// 82EBB760: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB764: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB768: 8909DF49  lbz r8, -0x20b7(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8375 as u32) ) } as u64;
	// 82EBB76C: 916AC3B4  stw r11, -0x3c4c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-15436 as u32), ctx.r[11].u32 ) };
	// 82EBB770: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB774: 4182000C  beq 0x82ebb780
	if ctx.cr[0].eq {
	pc = 0x82EBB780; continue 'dispatch;
	}
	// 82EBB778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB77C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB780: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB784: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB788: 386A8AE8  addi r3, r10, -0x7518
	ctx.r[3].s64 = ctx.r[10].s64 + -29976;
	// 82EBB78C: 9969DF49  stb r11, -0x20b7(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8375 as u32), ctx.r[11].u8 ) };
	// 82EBB790: 4BDEE791  bl 0x82ca9f20
	ctx.lr = 0x82EBB794;
	sub_82CA9F20(ctx, base);
	// 82EBB794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB798: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB79C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB7A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB7A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB7B0 size=116
    let mut pc: u32 = 0x82EBB7B0;
    'dispatch: loop {
        match pc {
            0x82EBB7B0 => {
    //   block [0x82EBB7B0..0x82EBB824)
	// 82EBB7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB7B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB7BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB7C0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB7C4: 816AC7BC  lwz r11, -0x3844(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14404 as u32) ) } as u64;
	// 82EBB7C8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB7CC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB7D0: 3BE9C3B8  addi r31, r9, -0x3c48
	ctx.r[31].s64 = ctx.r[9].s64 + -15432;
	// 82EBB7D4: 40820038  bne 0x82ebb80c
	if !ctx.cr[0].eq {
	pc = 0x82EBB80C; continue 'dispatch;
	}
	// 82EBB7D8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB7DC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB7E0: 8909DF48  lbz r8, -0x20b8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8376 as u32) ) } as u64;
	// 82EBB7E4: 916AC7BC  stw r11, -0x3844(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-14404 as u32), ctx.r[11].u32 ) };
	// 82EBB7E8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB7EC: 4182000C  beq 0x82ebb7f8
	if ctx.cr[0].eq {
	pc = 0x82EBB7F8; continue 'dispatch;
	}
	// 82EBB7F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB7F4: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB7F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB7FC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB800: 386A8AD0  addi r3, r10, -0x7530
	ctx.r[3].s64 = ctx.r[10].s64 + -30000;
	// 82EBB804: 9969DF48  stb r11, -0x20b8(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8376 as u32), ctx.r[11].u8 ) };
	// 82EBB808: 4BDEE719  bl 0x82ca9f20
	ctx.lr = 0x82EBB80C;
	sub_82CA9F20(ctx, base);
	// 82EBB80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB810: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB81C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB828 size=116
    let mut pc: u32 = 0x82EBB828;
    'dispatch: loop {
        match pc {
            0x82EBB828 => {
    //   block [0x82EBB828..0x82EBB89C)
	// 82EBB828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB82C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB834: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB838: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB83C: 816ACBC4  lwz r11, -0x343c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13372 as u32) ) } as u64;
	// 82EBB840: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB844: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB848: 3BE9C7C0  addi r31, r9, -0x3840
	ctx.r[31].s64 = ctx.r[9].s64 + -14400;
	// 82EBB84C: 40820038  bne 0x82ebb884
	if !ctx.cr[0].eq {
	pc = 0x82EBB884; continue 'dispatch;
	}
	// 82EBB850: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB854: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB858: 8909DF4A  lbz r8, -0x20b6(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8374 as u32) ) } as u64;
	// 82EBB85C: 916ACBC4  stw r11, -0x343c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-13372 as u32), ctx.r[11].u32 ) };
	// 82EBB860: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB864: 4182000C  beq 0x82ebb870
	if ctx.cr[0].eq {
	pc = 0x82EBB870; continue 'dispatch;
	}
	// 82EBB868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB86C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB874: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB878: 386A8AB8  addi r3, r10, -0x7548
	ctx.r[3].s64 = ctx.r[10].s64 + -30024;
	// 82EBB87C: 9969DF4A  stb r11, -0x20b6(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8374 as u32), ctx.r[11].u8 ) };
	// 82EBB880: 4BDEE6A1  bl 0x82ca9f20
	ctx.lr = 0x82EBB884;
	sub_82CA9F20(ctx, base);
	// 82EBB884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB888: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB88C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB8A0 size=160
    let mut pc: u32 = 0x82EBB8A0;
    'dispatch: loop {
        match pc {
            0x82EBB8A0 => {
    //   block [0x82EBB8A0..0x82EBB940)
	// 82EBB8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB8A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB8AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB8B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBB8B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBB8B8: 419A0064  beq cr6, 0x82ebb91c
	if ctx.cr[6].eq {
	pc = 0x82EBB91C; continue 'dispatch;
	}
	// 82EBB8BC: 4BFFFABD  bl 0x82ebb378
	ctx.lr = 0x82EBB8C0;
	sub_82EBB378(ctx, base);
	// 82EBB8C0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBB8C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBB8C8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB8CC: 40810050  ble 0x82ebb91c
	if !ctx.cr[0].gt {
	pc = 0x82EBB91C; continue 'dispatch;
	}
	// 82EBB8D0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBB8D4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB8D8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBB8DC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBB8E0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB8E4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB8E8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB8EC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBB8F0: 41820014  beq 0x82ebb904
	if ctx.cr[0].eq {
	pc = 0x82EBB904; continue 'dispatch;
	}
	// 82EBB8F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBB8F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBB8FC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBB900: 419AFFE0  beq cr6, 0x82ebb8e0
	if ctx.cr[6].eq {
	pc = 0x82EBB8E0; continue 'dispatch;
	}
	// 82EBB904: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB908: 4182002C  beq 0x82ebb934
	if ctx.cr[0].eq {
	pc = 0x82EBB934; continue 'dispatch;
	}
	// 82EBB90C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBB910: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBB914: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBB918: 4198FFBC  blt cr6, 0x82ebb8d4
	if ctx.cr[6].lt {
	pc = 0x82EBB8D4; continue 'dispatch;
	}
	// 82EBB91C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBB920: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB92C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB930: 4E800020  blr
	return;
	// 82EBB934: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBB938: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBB93C: 4BFFFFE4  b 0x82ebb920
	pc = 0x82EBB920; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB940 size=160
    let mut pc: u32 = 0x82EBB940;
    'dispatch: loop {
        match pc {
            0x82EBB940 => {
    //   block [0x82EBB940..0x82EBB9E0)
	// 82EBB940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB948: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB94C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB950: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBB954: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBB958: 419A0064  beq cr6, 0x82ebb9bc
	if ctx.cr[6].eq {
	pc = 0x82EBB9BC; continue 'dispatch;
	}
	// 82EBB95C: 4BFFFA95  bl 0x82ebb3f0
	ctx.lr = 0x82EBB960;
	sub_82EBB3F0(ctx, base);
	// 82EBB960: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBB964: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBB968: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB96C: 40810050  ble 0x82ebb9bc
	if !ctx.cr[0].gt {
	pc = 0x82EBB9BC; continue 'dispatch;
	}
	// 82EBB970: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBB974: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB978: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBB97C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBB980: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB984: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB988: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB98C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBB990: 41820014  beq 0x82ebb9a4
	if ctx.cr[0].eq {
	pc = 0x82EBB9A4; continue 'dispatch;
	}
	// 82EBB994: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBB998: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBB99C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBB9A0: 419AFFE0  beq cr6, 0x82ebb980
	if ctx.cr[6].eq {
	pc = 0x82EBB980; continue 'dispatch;
	}
	// 82EBB9A4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB9A8: 4182002C  beq 0x82ebb9d4
	if ctx.cr[0].eq {
	pc = 0x82EBB9D4; continue 'dispatch;
	}
	// 82EBB9AC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBB9B0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBB9B4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBB9B8: 4198FFBC  blt cr6, 0x82ebb974
	if ctx.cr[6].lt {
	pc = 0x82EBB974; continue 'dispatch;
	}
	// 82EBB9BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBB9C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB9C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB9C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB9CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB9D0: 4E800020  blr
	return;
	// 82EBB9D4: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBB9D8: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBB9DC: 4BFFFFE4  b 0x82ebb9c0
	pc = 0x82EBB9C0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB9E0 size=160
    let mut pc: u32 = 0x82EBB9E0;
    'dispatch: loop {
        match pc {
            0x82EBB9E0 => {
    //   block [0x82EBB9E0..0x82EBBA80)
	// 82EBB9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB9E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB9EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB9F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBB9F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBB9F8: 419A0064  beq cr6, 0x82ebba5c
	if ctx.cr[6].eq {
	pc = 0x82EBBA5C; continue 'dispatch;
	}
	// 82EBB9FC: 4BFFFA6D  bl 0x82ebb468
	ctx.lr = 0x82EBBA00;
	sub_82EBB468(ctx, base);
	// 82EBBA00: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBA04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBA08: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBA0C: 40810050  ble 0x82ebba5c
	if !ctx.cr[0].gt {
	pc = 0x82EBBA5C; continue 'dispatch;
	}
	// 82EBBA10: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBBA14: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBA18: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBA1C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBBA20: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBA24: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBA28: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBA2C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBA30: 41820014  beq 0x82ebba44
	if ctx.cr[0].eq {
	pc = 0x82EBBA44; continue 'dispatch;
	}
	// 82EBBA34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBA38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBA3C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBA40: 419AFFE0  beq cr6, 0x82ebba20
	if ctx.cr[6].eq {
	pc = 0x82EBBA20; continue 'dispatch;
	}
	// 82EBBA44: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBA48: 4182002C  beq 0x82ebba74
	if ctx.cr[0].eq {
	pc = 0x82EBBA74; continue 'dispatch;
	}
	// 82EBBA4C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBA50: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBA54: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBA58: 4198FFBC  blt cr6, 0x82ebba14
	if ctx.cr[6].lt {
	pc = 0x82EBBA14; continue 'dispatch;
	}
	// 82EBBA5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBA60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBA64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBA68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBA6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBA70: 4E800020  blr
	return;
	// 82EBBA74: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBA78: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBA7C: 4BFFFFE4  b 0x82ebba60
	pc = 0x82EBBA60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBA80 size=160
    let mut pc: u32 = 0x82EBBA80;
    'dispatch: loop {
        match pc {
            0x82EBBA80 => {
    //   block [0x82EBBA80..0x82EBBB20)
	// 82EBBA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBA8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBA94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBA98: 419A0064  beq cr6, 0x82ebbafc
	if ctx.cr[6].eq {
	pc = 0x82EBBAFC; continue 'dispatch;
	}
	// 82EBBA9C: 4BFFFA45  bl 0x82ebb4e0
	ctx.lr = 0x82EBBAA0;
	sub_82EBB4E0(ctx, base);
	// 82EBBAA0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBAA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBAA8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBAAC: 40810050  ble 0x82ebbafc
	if !ctx.cr[0].gt {
	pc = 0x82EBBAFC; continue 'dispatch;
	}
	// 82EBBAB0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBBAB4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBAB8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBABC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBBAC0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBAC4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBAC8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBACC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBAD0: 41820014  beq 0x82ebbae4
	if ctx.cr[0].eq {
	pc = 0x82EBBAE4; continue 'dispatch;
	}
	// 82EBBAD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBAD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBADC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBAE0: 419AFFE0  beq cr6, 0x82ebbac0
	if ctx.cr[6].eq {
	pc = 0x82EBBAC0; continue 'dispatch;
	}
	// 82EBBAE4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBAE8: 4182002C  beq 0x82ebbb14
	if ctx.cr[0].eq {
	pc = 0x82EBBB14; continue 'dispatch;
	}
	// 82EBBAEC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBAF0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBAF4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBAF8: 4198FFBC  blt cr6, 0x82ebbab4
	if ctx.cr[6].lt {
	pc = 0x82EBBAB4; continue 'dispatch;
	}
	// 82EBBAFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBB00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBB04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBB08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBB0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBB10: 4E800020  blr
	return;
	// 82EBBB14: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBB18: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBB1C: 4BFFFFE4  b 0x82ebbb00
	pc = 0x82EBBB00; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBB20 size=160
    let mut pc: u32 = 0x82EBBB20;
    'dispatch: loop {
        match pc {
            0x82EBBB20 => {
    //   block [0x82EBBB20..0x82EBBBC0)
	// 82EBBB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBB28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBB2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBB30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBB34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBB38: 419A0064  beq cr6, 0x82ebbb9c
	if ctx.cr[6].eq {
	pc = 0x82EBBB9C; continue 'dispatch;
	}
	// 82EBBB3C: 4BFFFA1D  bl 0x82ebb558
	ctx.lr = 0x82EBBB40;
	sub_82EBB558(ctx, base);
	// 82EBBB40: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBB44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBB48: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBB4C: 40810050  ble 0x82ebbb9c
	if !ctx.cr[0].gt {
	pc = 0x82EBBB9C; continue 'dispatch;
	}
	// 82EBBB50: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBBB54: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBB58: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBB5C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBBB60: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBB64: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBB68: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBB6C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBB70: 41820014  beq 0x82ebbb84
	if ctx.cr[0].eq {
	pc = 0x82EBBB84; continue 'dispatch;
	}
	// 82EBBB74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBB78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBB7C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBB80: 419AFFE0  beq cr6, 0x82ebbb60
	if ctx.cr[6].eq {
	pc = 0x82EBBB60; continue 'dispatch;
	}
	// 82EBBB84: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBB88: 4182002C  beq 0x82ebbbb4
	if ctx.cr[0].eq {
	pc = 0x82EBBBB4; continue 'dispatch;
	}
	// 82EBBB8C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBB90: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBB94: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBB98: 4198FFBC  blt cr6, 0x82ebbb54
	if ctx.cr[6].lt {
	pc = 0x82EBBB54; continue 'dispatch;
	}
	// 82EBBB9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBBA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBBA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBBA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBBAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBBB0: 4E800020  blr
	return;
	// 82EBBBB4: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBBB8: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBBBC: 4BFFFFE4  b 0x82ebbba0
	pc = 0x82EBBBA0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBBC0 size=160
    let mut pc: u32 = 0x82EBBBC0;
    'dispatch: loop {
        match pc {
            0x82EBBBC0 => {
    //   block [0x82EBBBC0..0x82EBBC60)
	// 82EBBBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBBC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBBCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBBD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBBD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBBD8: 419A0064  beq cr6, 0x82ebbc3c
	if ctx.cr[6].eq {
	pc = 0x82EBBC3C; continue 'dispatch;
	}
	// 82EBBBDC: 4BFFF9F5  bl 0x82ebb5d0
	ctx.lr = 0x82EBBBE0;
	sub_82EBB5D0(ctx, base);
	// 82EBBBE0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBBE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBBE8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBBEC: 40810050  ble 0x82ebbc3c
	if !ctx.cr[0].gt {
	pc = 0x82EBBC3C; continue 'dispatch;
	}
	// 82EBBBF0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBBBF4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBBF8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBBFC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBBC00: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBC04: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBC08: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBC0C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBC10: 41820014  beq 0x82ebbc24
	if ctx.cr[0].eq {
	pc = 0x82EBBC24; continue 'dispatch;
	}
	// 82EBBC14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBC18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBC1C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBC20: 419AFFE0  beq cr6, 0x82ebbc00
	if ctx.cr[6].eq {
	pc = 0x82EBBC00; continue 'dispatch;
	}
	// 82EBBC24: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBC28: 4182002C  beq 0x82ebbc54
	if ctx.cr[0].eq {
	pc = 0x82EBBC54; continue 'dispatch;
	}
	// 82EBBC2C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBC30: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBC34: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBC38: 4198FFBC  blt cr6, 0x82ebbbf4
	if ctx.cr[6].lt {
	pc = 0x82EBBBF4; continue 'dispatch;
	}
	// 82EBBC3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBC40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBC44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBC48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBC4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBC50: 4E800020  blr
	return;
	// 82EBBC54: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBC58: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBC5C: 4BFFFFE4  b 0x82ebbc40
	pc = 0x82EBBC40; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBC60 size=160
    let mut pc: u32 = 0x82EBBC60;
    'dispatch: loop {
        match pc {
            0x82EBBC60 => {
    //   block [0x82EBBC60..0x82EBBD00)
	// 82EBBC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBC68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBC6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBC70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBC74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBC78: 419A0064  beq cr6, 0x82ebbcdc
	if ctx.cr[6].eq {
	pc = 0x82EBBCDC; continue 'dispatch;
	}
	// 82EBBC7C: 4BFFF9CD  bl 0x82ebb648
	ctx.lr = 0x82EBBC80;
	sub_82EBB648(ctx, base);
	// 82EBBC80: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBC84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBC88: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBC8C: 40810050  ble 0x82ebbcdc
	if !ctx.cr[0].gt {
	pc = 0x82EBBCDC; continue 'dispatch;
	}
	// 82EBBC90: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBBC94: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBC98: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBC9C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBBCA0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBCA4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBCA8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBCAC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBCB0: 41820014  beq 0x82ebbcc4
	if ctx.cr[0].eq {
	pc = 0x82EBBCC4; continue 'dispatch;
	}
	// 82EBBCB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBCB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBCBC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBCC0: 419AFFE0  beq cr6, 0x82ebbca0
	if ctx.cr[6].eq {
	pc = 0x82EBBCA0; continue 'dispatch;
	}
	// 82EBBCC4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBCC8: 4182002C  beq 0x82ebbcf4
	if ctx.cr[0].eq {
	pc = 0x82EBBCF4; continue 'dispatch;
	}
	// 82EBBCCC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBCD0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBCD4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBCD8: 4198FFBC  blt cr6, 0x82ebbc94
	if ctx.cr[6].lt {
	pc = 0x82EBBC94; continue 'dispatch;
	}
	// 82EBBCDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBCE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBCE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBCE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBCEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBCF0: 4E800020  blr
	return;
	// 82EBBCF4: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBCF8: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBCFC: 4BFFFFE4  b 0x82ebbce0
	pc = 0x82EBBCE0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBD00 size=160
    let mut pc: u32 = 0x82EBBD00;
    'dispatch: loop {
        match pc {
            0x82EBBD00 => {
    //   block [0x82EBBD00..0x82EBBDA0)
	// 82EBBD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBD08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBD0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBD10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBD14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBD18: 419A0064  beq cr6, 0x82ebbd7c
	if ctx.cr[6].eq {
	pc = 0x82EBBD7C; continue 'dispatch;
	}
	// 82EBBD1C: 4BFFF9A5  bl 0x82ebb6c0
	ctx.lr = 0x82EBBD20;
	sub_82EBB6C0(ctx, base);
	// 82EBBD20: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBD24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBD28: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBD2C: 40810050  ble 0x82ebbd7c
	if !ctx.cr[0].gt {
	pc = 0x82EBBD7C; continue 'dispatch;
	}
	// 82EBBD30: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBBD34: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBD38: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBD3C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBBD40: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBD44: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBD48: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBD4C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBD50: 41820014  beq 0x82ebbd64
	if ctx.cr[0].eq {
	pc = 0x82EBBD64; continue 'dispatch;
	}
	// 82EBBD54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBD58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBD5C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBD60: 419AFFE0  beq cr6, 0x82ebbd40
	if ctx.cr[6].eq {
	pc = 0x82EBBD40; continue 'dispatch;
	}
	// 82EBBD64: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBD68: 4182002C  beq 0x82ebbd94
	if ctx.cr[0].eq {
	pc = 0x82EBBD94; continue 'dispatch;
	}
	// 82EBBD6C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBD70: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBD74: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBD78: 4198FFBC  blt cr6, 0x82ebbd34
	if ctx.cr[6].lt {
	pc = 0x82EBBD34; continue 'dispatch;
	}
	// 82EBBD7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBD80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBD84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBD88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBD8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBD90: 4E800020  blr
	return;
	// 82EBBD94: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBD98: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBD9C: 4BFFFFE4  b 0x82ebbd80
	pc = 0x82EBBD80; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBDA0 size=160
    let mut pc: u32 = 0x82EBBDA0;
    'dispatch: loop {
        match pc {
            0x82EBBDA0 => {
    //   block [0x82EBBDA0..0x82EBBE40)
	// 82EBBDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBDA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBDA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBDAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBDB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBDB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBDB8: 419A0064  beq cr6, 0x82ebbe1c
	if ctx.cr[6].eq {
	pc = 0x82EBBE1C; continue 'dispatch;
	}
	// 82EBBDBC: 4BFFF97D  bl 0x82ebb738
	ctx.lr = 0x82EBBDC0;
	sub_82EBB738(ctx, base);
	// 82EBBDC0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBDC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBDC8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBDCC: 40810050  ble 0x82ebbe1c
	if !ctx.cr[0].gt {
	pc = 0x82EBBE1C; continue 'dispatch;
	}
	// 82EBBDD0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBBDD4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBDD8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBDDC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBBDE0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBDE4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBDE8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBDEC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBDF0: 41820014  beq 0x82ebbe04
	if ctx.cr[0].eq {
	pc = 0x82EBBE04; continue 'dispatch;
	}
	// 82EBBDF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBDF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBDFC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBE00: 419AFFE0  beq cr6, 0x82ebbde0
	if ctx.cr[6].eq {
	pc = 0x82EBBDE0; continue 'dispatch;
	}
	// 82EBBE04: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBE08: 4182002C  beq 0x82ebbe34
	if ctx.cr[0].eq {
	pc = 0x82EBBE34; continue 'dispatch;
	}
	// 82EBBE0C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBE10: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBE14: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBE18: 4198FFBC  blt cr6, 0x82ebbdd4
	if ctx.cr[6].lt {
	pc = 0x82EBBDD4; continue 'dispatch;
	}
	// 82EBBE1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBE20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBE24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBE28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBE2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBE30: 4E800020  blr
	return;
	// 82EBBE34: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBE38: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBE3C: 4BFFFFE4  b 0x82ebbe20
	pc = 0x82EBBE20; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBE40 size=160
    let mut pc: u32 = 0x82EBBE40;
    'dispatch: loop {
        match pc {
            0x82EBBE40 => {
    //   block [0x82EBBE40..0x82EBBEE0)
	// 82EBBE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBE44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBE48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBE4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBE50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBE54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBE58: 419A0064  beq cr6, 0x82ebbebc
	if ctx.cr[6].eq {
	pc = 0x82EBBEBC; continue 'dispatch;
	}
	// 82EBBE5C: 4BFFF955  bl 0x82ebb7b0
	ctx.lr = 0x82EBBE60;
	sub_82EBB7B0(ctx, base);
	// 82EBBE60: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBE64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBE68: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBE6C: 40810050  ble 0x82ebbebc
	if !ctx.cr[0].gt {
	pc = 0x82EBBEBC; continue 'dispatch;
	}
	// 82EBBE70: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBBE74: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBE78: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBE7C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBBE80: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBE84: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBE88: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBE8C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBE90: 41820014  beq 0x82ebbea4
	if ctx.cr[0].eq {
	pc = 0x82EBBEA4; continue 'dispatch;
	}
	// 82EBBE94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBE98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBE9C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBEA0: 419AFFE0  beq cr6, 0x82ebbe80
	if ctx.cr[6].eq {
	pc = 0x82EBBE80; continue 'dispatch;
	}
	// 82EBBEA4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBEA8: 4182002C  beq 0x82ebbed4
	if ctx.cr[0].eq {
	pc = 0x82EBBED4; continue 'dispatch;
	}
	// 82EBBEAC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBEB0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBEB4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBEB8: 4198FFBC  blt cr6, 0x82ebbe74
	if ctx.cr[6].lt {
	pc = 0x82EBBE74; continue 'dispatch;
	}
	// 82EBBEBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBEC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBEC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBEC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBED0: 4E800020  blr
	return;
	// 82EBBED4: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBED8: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBEDC: 4BFFFFE4  b 0x82ebbec0
	pc = 0x82EBBEC0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBEE0 size=160
    let mut pc: u32 = 0x82EBBEE0;
    'dispatch: loop {
        match pc {
            0x82EBBEE0 => {
    //   block [0x82EBBEE0..0x82EBBF80)
	// 82EBBEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBEE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBEEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBEF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBEF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBEF8: 419A0064  beq cr6, 0x82ebbf5c
	if ctx.cr[6].eq {
	pc = 0x82EBBF5C; continue 'dispatch;
	}
	// 82EBBEFC: 4BFFF92D  bl 0x82ebb828
	ctx.lr = 0x82EBBF00;
	sub_82EBB828(ctx, base);
	// 82EBBF00: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBF04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBF08: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBF0C: 40810050  ble 0x82ebbf5c
	if !ctx.cr[0].gt {
	pc = 0x82EBBF5C; continue 'dispatch;
	}
	// 82EBBF10: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82EBBF14: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBF18: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBF1C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EBBF20: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBF24: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBF28: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBF2C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBF30: 41820014  beq 0x82ebbf44
	if ctx.cr[0].eq {
	pc = 0x82EBBF44; continue 'dispatch;
	}
	// 82EBBF34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBF38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBF3C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBF40: 419AFFE0  beq cr6, 0x82ebbf20
	if ctx.cr[6].eq {
	pc = 0x82EBBF20; continue 'dispatch;
	}
	// 82EBBF44: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBF48: 4182002C  beq 0x82ebbf74
	if ctx.cr[0].eq {
	pc = 0x82EBBF74; continue 'dispatch;
	}
	// 82EBBF4C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBF50: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBF54: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBF58: 4198FFBC  blt cr6, 0x82ebbf14
	if ctx.cr[6].lt {
	pc = 0x82EBBF14; continue 'dispatch;
	}
	// 82EBBF5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBF60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBF64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBF68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBF6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBF70: 4E800020  blr
	return;
	// 82EBBF74: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBF78: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBF7C: 4BFFFFE4  b 0x82ebbf60
	pc = 0x82EBBF60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBF80 size=72
    let mut pc: u32 = 0x82EBBF80;
    'dispatch: loop {
        match pc {
            0x82EBBF80 => {
    //   block [0x82EBBF80..0x82EBBFC8)
	// 82EBBF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBF88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBF8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBF90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBF94: 38600450  li r3, 0x450
	ctx.r[3].s64 = 1104;
	// 82EBBF98: 4B75A991  bl 0x82616928
	ctx.lr = 0x82EBBF9C;
	sub_82616928(ctx, base);
	// 82EBBF9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBBFA0: 41820010  beq 0x82ebbfb0
	if ctx.cr[0].eq {
	pc = 0x82EBBFB0; continue 'dispatch;
	}
	// 82EBBFA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBBFA8: 4BFFDC59  bl 0x82eb9c00
	ctx.lr = 0x82EBBFAC;
	sub_82EB9C00(ctx, base);
	// 82EBBFAC: 48000008  b 0x82ebbfb4
	pc = 0x82EBBFB4; continue 'dispatch;
	// 82EBBFB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBFB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBFB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBFBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBFC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBFC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBFC8 size=88
    let mut pc: u32 = 0x82EBBFC8;
    'dispatch: loop {
        match pc {
            0x82EBBFC8 => {
    //   block [0x82EBBFC8..0x82EBC020)
	// 82EBBFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBFD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBBFD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBFD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBFDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBFE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBBFE4: 4BFFE07D  bl 0x82eba060
	ctx.lr = 0x82EBBFE8;
	sub_82EBA060(ctx, base);
	// 82EBBFE8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBBFEC: 41820018  beq 0x82ebc004
	if ctx.cr[0].eq {
	pc = 0x82EBC004; continue 'dispatch;
	}
	// 82EBBFF0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBBFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBBFF8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBBFFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC000: 4E800421  bctrl
	ctx.lr = 0x82EBC004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBC00C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBC010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBC014: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBC018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBC01C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBC020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBC020 size=7308
    let mut pc: u32 = 0x82EBC020;
    'dispatch: loop {
        match pc {
            0x82EBC020 => {
    //   block [0x82EBC020..0x82EBDCAC)
	// 82EBC020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBC024: 4BDED3DD  bl 0x82ca9400
	ctx.lr = 0x82EBC028;
	sub_82CA93D0(ctx, base);
	// 82EBC028: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EBC02C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBC030: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBC034: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EBC038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC03C: 48300025  bl 0x831bc060
	ctx.lr = 0x82EBC040;
	sub_831BC060(ctx, base);
	// 82EBC040: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC044: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82EBC048: 409A000C  bne cr6, 0x82ebc054
	if !ctx.cr[6].eq {
	pc = 0x82EBC054; continue 'dispatch;
	}
	// 82EBC04C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBC050: 48000184  b 0x82ebc1d4
	pc = 0x82EBC1D4; continue 'dispatch;
	// 82EBC054: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC05C: 3BCBACD0  addi r30, r11, -0x5330
	ctx.r[30].s64 = ctx.r[11].s64 + -21296;
	// 82EBC060: 48300001  bl 0x831bc060
	ctx.lr = 0x82EBC064;
	sub_831BC060(ctx, base);
	// 82EBC064: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC068: 4BDF0AE9  bl 0x82cacb50
	ctx.lr = 0x82EBC06C;
	sub_82CACB50(ctx, base);
	// 82EBC06C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC074: 40820034  bne 0x82ebc0a8
	if !ctx.cr[0].eq {
	pc = 0x82EBC0A8; continue 'dispatch;
	}
	// 82EBC078: 4BA51C91  bl 0x8290dd08
	ctx.lr = 0x82EBC07C;
	sub_8290DD08(ctx, base);
	// 82EBC07C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC080: 4182FFCC  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC084: 4BDEE33D  bl 0x82caa3c0
	ctx.lr = 0x82EBC088;
	sub_82CAA3C0(ctx, base);
	// 82EBC088: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EBC08C: 40980008  bge cr6, 0x82ebc094
	if !ctx.cr[6].lt {
	pc = 0x82EBC094; continue 'dispatch;
	}
	// 82EBC090: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBC094: 2B031000  cmplwi cr6, r3, 0x1000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4096 as u32, &mut ctx.xer);
	// 82EBC098: 40990008  ble cr6, 0x82ebc0a0
	if !ctx.cr[6].gt {
	pc = 0x82EBC0A0; continue 'dispatch;
	}
	// 82EBC09C: 38601000  li r3, 0x1000
	ctx.r[3].s64 = 4096;
	// 82EBC0A0: 907A0030  stw r3, 0x30(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82EBC0A4: 4BFFFFA8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC0A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC0AC: 3BCBACBC  addi r30, r11, -0x5344
	ctx.r[30].s64 = ctx.r[11].s64 + -21316;
	// 82EBC0B0: 482FFFB1  bl 0x831bc060
	ctx.lr = 0x82EBC0B4;
	sub_831BC060(ctx, base);
	// 82EBC0B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC0B8: 4BDF0A99  bl 0x82cacb50
	ctx.lr = 0x82EBC0BC;
	sub_82CACB50(ctx, base);
	// 82EBC0BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC0C4: 40820034  bne 0x82ebc0f8
	if !ctx.cr[0].eq {
	pc = 0x82EBC0F8; continue 'dispatch;
	}
	// 82EBC0C8: 4BA51C41  bl 0x8290dd08
	ctx.lr = 0x82EBC0CC;
	sub_8290DD08(ctx, base);
	// 82EBC0CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC0D0: 4182FF7C  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC0D4: 4BDEE2ED  bl 0x82caa3c0
	ctx.lr = 0x82EBC0D8;
	sub_82CAA3C0(ctx, base);
	// 82EBC0D8: 2B030008  cmplwi cr6, r3, 8
	ctx.cr[6].compare_u32(ctx.r[3].u32, 8 as u32, &mut ctx.xer);
	// 82EBC0DC: 40980008  bge cr6, 0x82ebc0e4
	if !ctx.cr[6].lt {
	pc = 0x82EBC0E4; continue 'dispatch;
	}
	// 82EBC0E0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82EBC0E4: 2B030800  cmplwi cr6, r3, 0x800
	ctx.cr[6].compare_u32(ctx.r[3].u32, 2048 as u32, &mut ctx.xer);
	// 82EBC0E8: 40990008  ble cr6, 0x82ebc0f0
	if !ctx.cr[6].gt {
	pc = 0x82EBC0F0; continue 'dispatch;
	}
	// 82EBC0EC: 38600800  li r3, 0x800
	ctx.r[3].s64 = 2048;
	// 82EBC0F0: 907A0028  stw r3, 0x28(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 82EBC0F4: 4BFFFF58  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC0F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC0FC: 3BCBAC94  addi r30, r11, -0x536c
	ctx.r[30].s64 = ctx.r[11].s64 + -21356;
	// 82EBC100: 482FFF61  bl 0x831bc060
	ctx.lr = 0x82EBC104;
	sub_831BC060(ctx, base);
	// 82EBC104: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC108: 4BDF0A49  bl 0x82cacb50
	ctx.lr = 0x82EBC10C;
	sub_82CACB50(ctx, base);
	// 82EBC10C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC114: 40820038  bne 0x82ebc14c
	if !ctx.cr[0].eq {
	pc = 0x82EBC14C; continue 'dispatch;
	}
	// 82EBC118: 4BA51BF1  bl 0x8290dd08
	ctx.lr = 0x82EBC11C;
	sub_8290DD08(ctx, base);
	// 82EBC11C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC120: 4182FF2C  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC124: 4BDEE29D  bl 0x82caa3c0
	ctx.lr = 0x82EBC128;
	sub_82CAA3C0(ctx, base);
	// 82EBC128: 2B030400  cmplwi cr6, r3, 0x400
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1024 as u32, &mut ctx.xer);
	// 82EBC12C: 40980008  bge cr6, 0x82ebc134
	if !ctx.cr[6].lt {
	pc = 0x82EBC134; continue 'dispatch;
	}
	// 82EBC130: 38600400  li r3, 0x400
	ctx.r[3].s64 = 1024;
	// 82EBC134: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 82EBC138: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC13C: 40990008  ble cr6, 0x82ebc144
	if !ctx.cr[6].gt {
	pc = 0x82EBC144; continue 'dispatch;
	}
	// 82EBC140: 3C600004  lis r3, 4
	ctx.r[3].s64 = 262144;
	// 82EBC144: 907A0098  stw r3, 0x98(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 82EBC148: 4BFFFF04  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC14C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC150: 3BCBAC60  addi r30, r11, -0x53a0
	ctx.r[30].s64 = ctx.r[11].s64 + -21408;
	// 82EBC154: 482FFF0D  bl 0x831bc060
	ctx.lr = 0x82EBC158;
	sub_831BC060(ctx, base);
	// 82EBC158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC15C: 4BDF09F5  bl 0x82cacb50
	ctx.lr = 0x82EBC160;
	sub_82CACB50(ctx, base);
	// 82EBC160: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC168: 4082001C  bne 0x82ebc184
	if !ctx.cr[0].eq {
	pc = 0x82EBC184; continue 'dispatch;
	}
	// 82EBC16C: 4BA51B9D  bl 0x8290dd08
	ctx.lr = 0x82EBC170;
	sub_8290DD08(ctx, base);
	// 82EBC170: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC174: 4182FED8  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC178: 4BDEE249  bl 0x82caa3c0
	ctx.lr = 0x82EBC17C;
	sub_82CAA3C0(ctx, base);
	// 82EBC17C: 907A009C  stw r3, 0x9c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(156 as u32), ctx.r[3].u32 ) };
	// 82EBC180: 4BFFFECC  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC184: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC188: 3BCB9C80  addi r30, r11, -0x6380
	ctx.r[30].s64 = ctx.r[11].s64 + -25472;
	// 82EBC18C: 482FFED5  bl 0x831bc060
	ctx.lr = 0x82EBC190;
	sub_831BC060(ctx, base);
	// 82EBC190: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC194: 4BDF09BD  bl 0x82cacb50
	ctx.lr = 0x82EBC198;
	sub_82CACB50(ctx, base);
	// 82EBC198: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC1A0: 40820040  bne 0x82ebc1e0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1E0; continue 'dispatch;
	}
	// 82EBC1A4: 4BA51B65  bl 0x8290dd08
	ctx.lr = 0x82EBC1A8;
	sub_8290DD08(ctx, base);
	// 82EBC1A8: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EBC1AC: 4182FEA0  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC1B0: 817A0044  lwz r11, 0x44(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EBC1B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC1B8: 41820018  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC1BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EBC1C0: 48012321  bl 0x82ece4e0
	ctx.lr = 0x82EBC1C4;
	sub_82ECE4E0(ctx, base);
	// 82EBC1C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC1C8: 907A0048  stw r3, 0x48(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82EBC1CC: 4082FE80  bne 0x82ebc04c
	if !ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC1D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBC1D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EBC1D8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EBC1DC: 4BDED274  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 82EBC1E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC1E4: 3BCBAC54  addi r30, r11, -0x53ac
	ctx.r[30].s64 = ctx.r[11].s64 + -21420;
	// 82EBC1E8: 482FFE79  bl 0x831bc060
	ctx.lr = 0x82EBC1EC;
	sub_831BC060(ctx, base);
	// 82EBC1EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC1F0: 4BDF0961  bl 0x82cacb50
	ctx.lr = 0x82EBC1F4;
	sub_82CACB50(ctx, base);
	// 82EBC1F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC1F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC1FC: 4082005C  bne 0x82ebc258
	if !ctx.cr[0].eq {
	pc = 0x82EBC258; continue 'dispatch;
	}
	// 82EBC200: 4BA51B09  bl 0x8290dd08
	ctx.lr = 0x82EBC204;
	sub_8290DD08(ctx, base);
	// 82EBC204: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBC208: 4182FFC8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC20C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82EBC210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC214: 388BD7D0  addi r4, r11, -0x2830
	ctx.r[4].s64 = ctx.r[11].s64 + -10288;
	// 82EBC218: 4BDF0939  bl 0x82cacb50
	ctx.lr = 0x82EBC21C;
	sub_82CACB50(ctx, base);
	// 82EBC21C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC220: 40820014  bne 0x82ebc234
	if !ctx.cr[0].eq {
	pc = 0x82EBC234; continue 'dispatch;
	}
	// 82EBC224: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC228: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBC22C: 917A0020  stw r11, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EBC230: 4BFFFFA4  b 0x82ebc1d4
	pc = 0x82EBC1D4; continue 'dispatch;
	// 82EBC234: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC23C: 388BAC44  addi r4, r11, -0x53bc
	ctx.r[4].s64 = ctx.r[11].s64 + -21436;
	// 82EBC240: 4BDF0911  bl 0x82cacb50
	ctx.lr = 0x82EBC244;
	sub_82CACB50(ctx, base);
	// 82EBC244: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC248: 4082FF88  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC24C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EBC250: 917A0020  stw r11, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EBC254: 4BFFFDF8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC258: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC25C: 3BCBAC28  addi r30, r11, -0x53d8
	ctx.r[30].s64 = ctx.r[11].s64 + -21464;
	// 82EBC260: 482FFE01  bl 0x831bc060
	ctx.lr = 0x82EBC264;
	sub_831BC060(ctx, base);
	// 82EBC264: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC268: 4BDF08E9  bl 0x82cacb50
	ctx.lr = 0x82EBC26C;
	sub_82CACB50(ctx, base);
	// 82EBC26C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC274: 408200AC  bne 0x82ebc320
	if !ctx.cr[0].eq {
	pc = 0x82EBC320; continue 'dispatch;
	}
	// 82EBC278: 4BA51A91  bl 0x8290dd08
	ctx.lr = 0x82EBC27C;
	sub_8290DD08(ctx, base);
	// 82EBC27C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBC284: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EBC288: 4BDF08C9  bl 0x82cacb50
	ctx.lr = 0x82EBC28C;
	sub_82CACB50(ctx, base);
	// 82EBC28C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC290: 41820084  beq 0x82ebc314
	if ctx.cr[0].eq {
	pc = 0x82EBC314; continue 'dispatch;
	}
	// 82EBC294: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC29C: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EBC2A0: 4BDF08B1  bl 0x82cacb50
	ctx.lr = 0x82EBC2A4;
	sub_82CACB50(ctx, base);
	// 82EBC2A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2A8: 4182006C  beq 0x82ebc314
	if ctx.cr[0].eq {
	pc = 0x82EBC314; continue 'dispatch;
	}
	// 82EBC2AC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EBC2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2B4: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EBC2B8: 4BDF0899  bl 0x82cacb50
	ctx.lr = 0x82EBC2BC;
	sub_82CACB50(ctx, base);
	// 82EBC2BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2C0: 41820054  beq 0x82ebc314
	if ctx.cr[0].eq {
	pc = 0x82EBC314; continue 'dispatch;
	}
	// 82EBC2C4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2CC: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EBC2D0: 4BDF0881  bl 0x82cacb50
	ctx.lr = 0x82EBC2D4;
	sub_82CACB50(ctx, base);
	// 82EBC2D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2D8: 41820034  beq 0x82ebc30c
	if ctx.cr[0].eq {
	pc = 0x82EBC30C; continue 'dispatch;
	}
	// 82EBC2DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC2E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2E4: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EBC2E8: 4BDF0869  bl 0x82cacb50
	ctx.lr = 0x82EBC2EC;
	sub_82CACB50(ctx, base);
	// 82EBC2EC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2F0: 4182001C  beq 0x82ebc30c
	if ctx.cr[0].eq {
	pc = 0x82EBC30C; continue 'dispatch;
	}
	// 82EBC2F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC2F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2FC: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EBC300: 4BDF0851  bl 0x82cacb50
	ctx.lr = 0x82EBC304;
	sub_82CACB50(ctx, base);
	// 82EBC304: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC308: 4082FEC8  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC30C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBC310: 48000008  b 0x82ebc318
	pc = 0x82EBC318; continue 'dispatch;
	// 82EBC314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC318: 997A007E  stb r11, 0x7e(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(126 as u32), ctx.r[11].u8 ) };
	// 82EBC31C: 4BFFFD30  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC320: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC324: 3BCBAC0C  addi r30, r11, -0x53f4
	ctx.r[30].s64 = ctx.r[11].s64 + -21492;
	// 82EBC328: 482FFD39  bl 0x831bc060
	ctx.lr = 0x82EBC32C;
	sub_831BC060(ctx, base);
	// 82EBC32C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC330: 4BDF0821  bl 0x82cacb50
	ctx.lr = 0x82EBC334;
	sub_82CACB50(ctx, base);
	// 82EBC334: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC33C: 408200B4  bne 0x82ebc3f0
	if !ctx.cr[0].eq {
	pc = 0x82EBC3F0; continue 'dispatch;
	}
	// 82EBC340: 4BA519C9  bl 0x8290dd08
	ctx.lr = 0x82EBC344;
	sub_8290DD08(ctx, base);
	// 82EBC344: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBC348: 4182FD04  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC34C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC354: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EBC358: 4BDF07F9  bl 0x82cacb50
	ctx.lr = 0x82EBC35C;
	sub_82CACB50(ctx, base);
	// 82EBC35C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC360: 41820084  beq 0x82ebc3e4
	if ctx.cr[0].eq {
	pc = 0x82EBC3E4; continue 'dispatch;
	}
	// 82EBC364: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC36C: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EBC370: 4BDF07E1  bl 0x82cacb50
	ctx.lr = 0x82EBC374;
	sub_82CACB50(ctx, base);
	// 82EBC374: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC378: 4182006C  beq 0x82ebc3e4
	if ctx.cr[0].eq {
	pc = 0x82EBC3E4; continue 'dispatch;
	}
	// 82EBC37C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EBC380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC384: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EBC388: 4BDF07C9  bl 0x82cacb50
	ctx.lr = 0x82EBC38C;
	sub_82CACB50(ctx, base);
	// 82EBC38C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC390: 41820054  beq 0x82ebc3e4
	if ctx.cr[0].eq {
	pc = 0x82EBC3E4; continue 'dispatch;
	}
	// 82EBC394: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC39C: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EBC3A0: 4BDF07B1  bl 0x82cacb50
	ctx.lr = 0x82EBC3A4;
	sub_82CACB50(ctx, base);
	// 82EBC3A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC3A8: 41820034  beq 0x82ebc3dc
	if ctx.cr[0].eq {
	pc = 0x82EBC3DC; continue 'dispatch;
	}
	// 82EBC3AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC3B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC3B4: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EBC3B8: 4BDF0799  bl 0x82cacb50
	ctx.lr = 0x82EBC3BC;
	sub_82CACB50(ctx, base);
	// 82EBC3BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC3C0: 4182001C  beq 0x82ebc3dc
	if ctx.cr[0].eq {
	pc = 0x82EBC3DC; continue 'dispatch;
	}
	// 82EBC3C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC3C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC3CC: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EBC3D0: 4BDF0781  bl 0x82cacb50
	ctx.lr = 0x82EBC3D4;
	sub_82CACB50(ctx, base);
	// 82EBC3D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC3D8: 4082FDF8  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC3DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBC3E0: 48000008  b 0x82ebc3e8
	pc = 0x82EBC3E8; continue 'dispatch;
	// 82EBC3E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC3E8: 997A007F  stb r11, 0x7f(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(127 as u32), ctx.r[11].u8 ) };
	// 82EBC3EC: 4BFFFC60  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC3F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC3F4: 3BCBABFC  addi r30, r11, -0x5404
	ctx.r[30].s64 = ctx.r[11].s64 + -21508;
	// 82EBC3F8: 482FFC69  bl 0x831bc060
	ctx.lr = 0x82EBC3FC;
	sub_831BC060(ctx, base);
	// 82EBC3FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC400: 4BDF0751  bl 0x82cacb50
	ctx.lr = 0x82EBC404;
	sub_82CACB50(ctx, base);
	// 82EBC404: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC40C: 40820064  bne 0x82ebc470
	if !ctx.cr[0].eq {
	pc = 0x82EBC470; continue 'dispatch;
	}
	// 82EBC410: 4BA518F9  bl 0x8290dd08
	ctx.lr = 0x82EBC414;
	sub_8290DD08(ctx, base);
	// 82EBC414: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC418: 4182FDB8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC41C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBC420: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBC424: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC428: 4182000C  beq 0x82ebc434
	if ctx.cr[0].eq {
	pc = 0x82EBC434; continue 'dispatch;
	}
	// 82EBC42C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC430: 4800000C  b 0x82ebc43c
	pc = 0x82EBC43C; continue 'dispatch;
	// 82EBC434: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC438: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC43C: 4BDEF775  bl 0x82cabbb0
	ctx.lr = 0x82EBC440;
	sub_82CABBB0(ctx, base);
	// 82EBC440: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBC444: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC448: C01A0024  lfs f0, 0x24(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBC44C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBC450: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBC454: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBC458: 41980008  blt cr6, 0x82ebc460
	if ctx.cr[6].lt {
	pc = 0x82EBC460; continue 'dispatch;
	}
	// 82EBC45C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBC460: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBC464: 409AFFF0  bne cr6, 0x82ebc454
	if !ctx.cr[6].eq {
	pc = 0x82EBC454; continue 'dispatch;
	}
	// 82EBC468: D01A0024  stfs f0, 0x24(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBC46C: 4BFFFBE0  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC470: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC474: 3BCBABE0  addi r30, r11, -0x5420
	ctx.r[30].s64 = ctx.r[11].s64 + -21536;
	// 82EBC478: 482FFBE9  bl 0x831bc060
	ctx.lr = 0x82EBC47C;
	sub_831BC060(ctx, base);
	// 82EBC47C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC480: 4BDF06D1  bl 0x82cacb50
	ctx.lr = 0x82EBC484;
	sub_82CACB50(ctx, base);
	// 82EBC484: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC48C: 40820064  bne 0x82ebc4f0
	if !ctx.cr[0].eq {
	pc = 0x82EBC4F0; continue 'dispatch;
	}
	// 82EBC490: 4BA51879  bl 0x8290dd08
	ctx.lr = 0x82EBC494;
	sub_8290DD08(ctx, base);
	// 82EBC494: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC498: 4182FD38  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC49C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBC4A0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBC4A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC4A8: 4182000C  beq 0x82ebc4b4
	if ctx.cr[0].eq {
	pc = 0x82EBC4B4; continue 'dispatch;
	}
	// 82EBC4AC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC4B0: 4800000C  b 0x82ebc4bc
	pc = 0x82EBC4BC; continue 'dispatch;
	// 82EBC4B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC4B8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC4BC: 4BDEF6F5  bl 0x82cabbb0
	ctx.lr = 0x82EBC4C0;
	sub_82CABBB0(ctx, base);
	// 82EBC4C0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBC4C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC4C8: C01A002C  lfs f0, 0x2c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBC4CC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBC4D0: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBC4D4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBC4D8: 41980008  blt cr6, 0x82ebc4e0
	if ctx.cr[6].lt {
	pc = 0x82EBC4E0; continue 'dispatch;
	}
	// 82EBC4DC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBC4E0: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBC4E4: 409AFFF0  bne cr6, 0x82ebc4d4
	if !ctx.cr[6].eq {
	pc = 0x82EBC4D4; continue 'dispatch;
	}
	// 82EBC4E8: D01A002C  stfs f0, 0x2c(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EBC4EC: 4BFFFB60  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC4F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC4F4: 3BCBABD0  addi r30, r11, -0x5430
	ctx.r[30].s64 = ctx.r[11].s64 + -21552;
	// 82EBC4F8: 482FFB69  bl 0x831bc060
	ctx.lr = 0x82EBC4FC;
	sub_831BC060(ctx, base);
	// 82EBC4FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC500: 4BDF0651  bl 0x82cacb50
	ctx.lr = 0x82EBC504;
	sub_82CACB50(ctx, base);
	// 82EBC504: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC50C: 408200E0  bne 0x82ebc5ec
	if !ctx.cr[0].eq {
	pc = 0x82EBC5EC; continue 'dispatch;
	}
	// 82EBC510: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC514: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82EBC518: 4BA517F1  bl 0x8290dd08
	ctx.lr = 0x82EBC51C;
	sub_8290DD08(ctx, base);
	// 82EBC51C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC520: 4BDF0631  bl 0x82cacb50
	ctx.lr = 0x82EBC524;
	sub_82CACB50(ctx, base);
	// 82EBC524: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC528: 418200AC  beq 0x82ebc5d4
	if ctx.cr[0].eq {
	pc = 0x82EBC5D4; continue 'dispatch;
	}
	// 82EBC52C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC534: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82EBC538: 4BA517D1  bl 0x8290dd08
	ctx.lr = 0x82EBC53C;
	sub_8290DD08(ctx, base);
	// 82EBC53C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC540: 4BDF0611  bl 0x82cacb50
	ctx.lr = 0x82EBC544;
	sub_82CACB50(ctx, base);
	// 82EBC544: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC548: 4182008C  beq 0x82ebc5d4
	if ctx.cr[0].eq {
	pc = 0x82EBC5D4; continue 'dispatch;
	}
	// 82EBC54C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EBC550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC554: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82EBC558: 4BA517B1  bl 0x8290dd08
	ctx.lr = 0x82EBC55C;
	sub_8290DD08(ctx, base);
	// 82EBC55C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC560: 4BDF05F1  bl 0x82cacb50
	ctx.lr = 0x82EBC564;
	sub_82CACB50(ctx, base);
	// 82EBC564: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC568: 4182006C  beq 0x82ebc5d4
	if ctx.cr[0].eq {
	pc = 0x82EBC5D4; continue 'dispatch;
	}
	// 82EBC56C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC574: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82EBC578: 4BA51791  bl 0x8290dd08
	ctx.lr = 0x82EBC57C;
	sub_8290DD08(ctx, base);
	// 82EBC57C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC580: 4BDF05D1  bl 0x82cacb50
	ctx.lr = 0x82EBC584;
	sub_82CACB50(ctx, base);
	// 82EBC584: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC588: 41820044  beq 0x82ebc5cc
	if ctx.cr[0].eq {
	pc = 0x82EBC5CC; continue 'dispatch;
	}
	// 82EBC58C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC594: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82EBC598: 4BA51771  bl 0x8290dd08
	ctx.lr = 0x82EBC59C;
	sub_8290DD08(ctx, base);
	// 82EBC59C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC5A0: 4BDF05B1  bl 0x82cacb50
	ctx.lr = 0x82EBC5A4;
	sub_82CACB50(ctx, base);
	// 82EBC5A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC5A8: 41820024  beq 0x82ebc5cc
	if ctx.cr[0].eq {
	pc = 0x82EBC5CC; continue 'dispatch;
	}
	// 82EBC5AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC5B4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82EBC5B8: 4BA51751  bl 0x8290dd08
	ctx.lr = 0x82EBC5BC;
	sub_8290DD08(ctx, base);
	// 82EBC5BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC5C0: 4BDF0591  bl 0x82cacb50
	ctx.lr = 0x82EBC5C4;
	sub_82CACB50(ctx, base);
	// 82EBC5C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC5C8: 4082FC08  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC5CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBC5D0: 48000008  b 0x82ebc5d8
	pc = 0x82EBC5D8; continue 'dispatch;
	// 82EBC5D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC5D8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC5DC: 4182FA70  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC5E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC5E4: 997A0440  stb r11, 0x440(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(1088 as u32), ctx.r[11].u8 ) };
	// 82EBC5E8: 4BFFFA64  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC5EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC5F0: 3BCBA5B4  addi r30, r11, -0x5a4c
	ctx.r[30].s64 = ctx.r[11].s64 + -23116;
	// 82EBC5F4: 482FFA6D  bl 0x831bc060
	ctx.lr = 0x82EBC5F8;
	sub_831BC060(ctx, base);
	// 82EBC5F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC5FC: 4BDF0555  bl 0x82cacb50
	ctx.lr = 0x82EBC600;
	sub_82CACB50(ctx, base);
	// 82EBC600: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC608: 40820050  bne 0x82ebc658
	if !ctx.cr[0].eq {
	pc = 0x82EBC658; continue 'dispatch;
	}
	// 82EBC60C: 4BA516FD  bl 0x8290dd08
	ctx.lr = 0x82EBC610;
	sub_8290DD08(ctx, base);
	// 82EBC610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC614: 4182FBBC  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC618: 4BDEF599  bl 0x82cabbb0
	ctx.lr = 0x82EBC61C;
	sub_82CABBB0(ctx, base);
	// 82EBC61C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBC620: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC624: C1BA044C  lfs f13, 0x44c(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBC628: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBC62C: C16A0C18  lfs f11, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBC630: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBC634: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBC638: 41980010  blt cr6, 0x82ebc648
	if ctx.cr[6].lt {
	pc = 0x82EBC648; continue 'dispatch;
	}
	// 82EBC63C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EBC640: 41990008  bgt cr6, 0x82ebc648
	if ctx.cr[6].gt {
	pc = 0x82EBC648; continue 'dispatch;
	}
	// 82EBC644: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EBC648: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EBC64C: 409AFFE8  bne cr6, 0x82ebc634
	if !ctx.cr[6].eq {
	pc = 0x82EBC634; continue 'dispatch;
	}
	// 82EBC650: D1BA044C  stfs f13, 0x44c(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(1100 as u32), tmp.u32 ) };
	// 82EBC654: 4BFFF9F8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC658: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC65C: 3BCBABB8  addi r30, r11, -0x5448
	ctx.r[30].s64 = ctx.r[11].s64 + -21576;
	// 82EBC660: 482FFA01  bl 0x831bc060
	ctx.lr = 0x82EBC664;
	sub_831BC060(ctx, base);
	// 82EBC664: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC668: 4BDF04E9  bl 0x82cacb50
	ctx.lr = 0x82EBC66C;
	sub_82CACB50(ctx, base);
	// 82EBC66C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC670: 40820118  bne 0x82ebc788
	if !ctx.cr[0].eq {
	pc = 0x82EBC788; continue 'dispatch;
	}
	// 82EBC674: 387A01A0  addi r3, r26, 0x1a0
	ctx.r[3].s64 = ctx.r[26].s64 + 416;
	// 82EBC678: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC67C: 4BFFCB5D  bl 0x82eb91d8
	ctx.lr = 0x82EBC680;
	sub_82EB91D8(ctx, base);
	// 82EBC680: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC684: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBC688: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBC68C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC690: 409900D0  ble cr6, 0x82ebc760
	if !ctx.cr[6].gt {
	pc = 0x82EBC760; continue 'dispatch;
	}
	// 82EBC694: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC698: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBC69C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBC6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC6A4: 4BFC7985  bl 0x82e84028
	ctx.lr = 0x82EBC6A8;
	sub_82E84028(ctx, base);
	// 82EBC6A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBC6AC: 482FF9B5  bl 0x831bc060
	ctx.lr = 0x82EBC6B0;
	sub_831BC060(ctx, base);
	// 82EBC6B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBC6B4: 4BDF049D  bl 0x82cacb50
	ctx.lr = 0x82EBC6B8;
	sub_82CACB50(ctx, base);
	// 82EBC6B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC6BC: 40820014  bne 0x82ebc6d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC6D0; continue 'dispatch;
	}
	// 82EBC6C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBC6C4: 4BA51645  bl 0x8290dd08
	ctx.lr = 0x82EBC6C8;
	sub_8290DD08(ctx, base);
	// 82EBC6C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBC6CC: 48000024  b 0x82ebc6f0
	pc = 0x82EBC6F0; continue 'dispatch;
	// 82EBC6D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC6D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC6D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBC6DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC6E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC6E4: 4E800421  bctrl
	ctx.lr = 0x82EBC6E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC6E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC6EC: 4182FAE4  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC6F0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC6F4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBC6F8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC6FC: 4198FFA0  blt cr6, 0x82ebc69c
	if ctx.cr[6].lt {
	pc = 0x82EBC69C; continue 'dispatch;
	}
	// 82EBC700: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBC704: 419A005C  beq cr6, 0x82ebc760
	if ctx.cr[6].eq {
	pc = 0x82EBC760; continue 'dispatch;
	}
	// 82EBC708: 817A01AC  lwz r11, 0x1ac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBC70C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBC710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC714: 4099004C  ble cr6, 0x82ebc760
	if !ctx.cr[6].gt {
	pc = 0x82EBC760; continue 'dispatch;
	}
	// 82EBC718: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBC71C: 817A01A4  lwz r11, 0x1a4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBC720: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBC724: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC728: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC72C: 4BDF0425  bl 0x82cacb50
	ctx.lr = 0x82EBC730;
	sub_82CACB50(ctx, base);
	// 82EBC730: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC734: 4182001C  beq 0x82ebc750
	if ctx.cr[0].eq {
	pc = 0x82EBC750; continue 'dispatch;
	}
	// 82EBC738: 817A01AC  lwz r11, 0x1ac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBC73C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBC740: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBC744: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC748: 4198FFD4  blt cr6, 0x82ebc71c
	if ctx.cr[6].lt {
	pc = 0x82EBC71C; continue 'dispatch;
	}
	// 82EBC74C: 48000014  b 0x82ebc760
	pc = 0x82EBC760; continue 'dispatch;
	// 82EBC750: 817A01A4  lwz r11, 0x1a4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBC754: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBC758: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC75C: 917A01B0  stw r11, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 82EBC760: 817A01B0  lwz r11, 0x1b0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EBC764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC768: 409AF8E4  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC76C: 817A01AC  lwz r11, 0x1ac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBC770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC774: 419AF8D8  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC778: 817A01A4  lwz r11, 0x1a4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBC77C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC780: 917A01B0  stw r11, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 82EBC784: 4BFFF8C8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC788: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC790: 3BCBAB98  addi r30, r11, -0x5468
	ctx.r[30].s64 = ctx.r[11].s64 + -21608;
	// 82EBC794: 482FF8CD  bl 0x831bc060
	ctx.lr = 0x82EBC798;
	sub_831BC060(ctx, base);
	// 82EBC798: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC79C: 4BDF03B5  bl 0x82cacb50
	ctx.lr = 0x82EBC7A0;
	sub_82CACB50(ctx, base);
	// 82EBC7A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC7A4: 40820118  bne 0x82ebc8bc
	if !ctx.cr[0].eq {
	pc = 0x82EBC8BC; continue 'dispatch;
	}
	// 82EBC7A8: 387A01B4  addi r3, r26, 0x1b4
	ctx.r[3].s64 = ctx.r[26].s64 + 436;
	// 82EBC7AC: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC7B0: 4BFFCA29  bl 0x82eb91d8
	ctx.lr = 0x82EBC7B4;
	sub_82EB91D8(ctx, base);
	// 82EBC7B4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC7B8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBC7BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBC7C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC7C4: 409900D0  ble cr6, 0x82ebc894
	if !ctx.cr[6].gt {
	pc = 0x82EBC894; continue 'dispatch;
	}
	// 82EBC7C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC7CC: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBC7D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBC7D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC7D8: 4BFC7851  bl 0x82e84028
	ctx.lr = 0x82EBC7DC;
	sub_82E84028(ctx, base);
	// 82EBC7DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBC7E0: 482FF881  bl 0x831bc060
	ctx.lr = 0x82EBC7E4;
	sub_831BC060(ctx, base);
	// 82EBC7E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBC7E8: 4BDF0369  bl 0x82cacb50
	ctx.lr = 0x82EBC7EC;
	sub_82CACB50(ctx, base);
	// 82EBC7EC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC7F0: 40820014  bne 0x82ebc804
	if !ctx.cr[0].eq {
	pc = 0x82EBC804; continue 'dispatch;
	}
	// 82EBC7F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBC7F8: 4BA51511  bl 0x8290dd08
	ctx.lr = 0x82EBC7FC;
	sub_8290DD08(ctx, base);
	// 82EBC7FC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBC800: 48000024  b 0x82ebc824
	pc = 0x82EBC824; continue 'dispatch;
	// 82EBC804: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC808: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC80C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBC810: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC818: 4E800421  bctrl
	ctx.lr = 0x82EBC81C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC81C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC820: 4182F9B0  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC824: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC828: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBC82C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC830: 4198FFA0  blt cr6, 0x82ebc7d0
	if ctx.cr[6].lt {
	pc = 0x82EBC7D0; continue 'dispatch;
	}
	// 82EBC834: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBC838: 419A005C  beq cr6, 0x82ebc894
	if ctx.cr[6].eq {
	pc = 0x82EBC894; continue 'dispatch;
	}
	// 82EBC83C: 817A01C0  lwz r11, 0x1c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBC840: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBC844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC848: 4099004C  ble cr6, 0x82ebc894
	if !ctx.cr[6].gt {
	pc = 0x82EBC894; continue 'dispatch;
	}
	// 82EBC84C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBC850: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBC854: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBC858: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBC85C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC860: 4BDF02F1  bl 0x82cacb50
	ctx.lr = 0x82EBC864;
	sub_82CACB50(ctx, base);
	// 82EBC864: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC868: 4182001C  beq 0x82ebc884
	if ctx.cr[0].eq {
	pc = 0x82EBC884; continue 'dispatch;
	}
	// 82EBC86C: 817A01C0  lwz r11, 0x1c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBC870: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBC874: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBC878: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC87C: 4198FFD4  blt cr6, 0x82ebc850
	if ctx.cr[6].lt {
	pc = 0x82EBC850; continue 'dispatch;
	}
	// 82EBC880: 48000014  b 0x82ebc894
	pc = 0x82EBC894; continue 'dispatch;
	// 82EBC884: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBC888: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBC88C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC890: 917A01C4  stw r11, 0x1c4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 82EBC894: 817A01C4  lwz r11, 0x1c4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EBC898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC89C: 409AF7B0  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC8A0: 817A01C0  lwz r11, 0x1c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBC8A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC8A8: 419AF7A4  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC8AC: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBC8B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC8B4: 917A01C4  stw r11, 0x1c4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 82EBC8B8: 4BFFF794  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC8BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC8C4: 3BCBAB78  addi r30, r11, -0x5488
	ctx.r[30].s64 = ctx.r[11].s64 + -21640;
	// 82EBC8C8: 482FF799  bl 0x831bc060
	ctx.lr = 0x82EBC8CC;
	sub_831BC060(ctx, base);
	// 82EBC8CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC8D0: 4BDF0281  bl 0x82cacb50
	ctx.lr = 0x82EBC8D4;
	sub_82CACB50(ctx, base);
	// 82EBC8D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC8D8: 40820118  bne 0x82ebc9f0
	if !ctx.cr[0].eq {
	pc = 0x82EBC9F0; continue 'dispatch;
	}
	// 82EBC8DC: 387A01C8  addi r3, r26, 0x1c8
	ctx.r[3].s64 = ctx.r[26].s64 + 456;
	// 82EBC8E0: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC8E4: 4BFFC8F5  bl 0x82eb91d8
	ctx.lr = 0x82EBC8E8;
	sub_82EB91D8(ctx, base);
	// 82EBC8E8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC8EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBC8F0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBC8F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC8F8: 409900D0  ble cr6, 0x82ebc9c8
	if !ctx.cr[6].gt {
	pc = 0x82EBC9C8; continue 'dispatch;
	}
	// 82EBC8FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC900: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBC904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBC908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC90C: 4BFC771D  bl 0x82e84028
	ctx.lr = 0x82EBC910;
	sub_82E84028(ctx, base);
	// 82EBC910: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBC914: 482FF74D  bl 0x831bc060
	ctx.lr = 0x82EBC918;
	sub_831BC060(ctx, base);
	// 82EBC918: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBC91C: 4BDF0235  bl 0x82cacb50
	ctx.lr = 0x82EBC920;
	sub_82CACB50(ctx, base);
	// 82EBC920: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC924: 40820014  bne 0x82ebc938
	if !ctx.cr[0].eq {
	pc = 0x82EBC938; continue 'dispatch;
	}
	// 82EBC928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBC92C: 4BA513DD  bl 0x8290dd08
	ctx.lr = 0x82EBC930;
	sub_8290DD08(ctx, base);
	// 82EBC930: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBC934: 48000024  b 0x82ebc958
	pc = 0x82EBC958; continue 'dispatch;
	// 82EBC938: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC93C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC940: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBC944: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC948: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC94C: 4E800421  bctrl
	ctx.lr = 0x82EBC950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC950: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC954: 4182F87C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC958: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC95C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBC960: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC964: 4198FFA0  blt cr6, 0x82ebc904
	if ctx.cr[6].lt {
	pc = 0x82EBC904; continue 'dispatch;
	}
	// 82EBC968: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBC96C: 419A005C  beq cr6, 0x82ebc9c8
	if ctx.cr[6].eq {
	pc = 0x82EBC9C8; continue 'dispatch;
	}
	// 82EBC970: 817A01D4  lwz r11, 0x1d4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBC974: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBC978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC97C: 4099004C  ble cr6, 0x82ebc9c8
	if !ctx.cr[6].gt {
	pc = 0x82EBC9C8; continue 'dispatch;
	}
	// 82EBC980: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBC984: 817A01CC  lwz r11, 0x1cc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBC988: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBC98C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC990: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC994: 4BDF01BD  bl 0x82cacb50
	ctx.lr = 0x82EBC998;
	sub_82CACB50(ctx, base);
	// 82EBC998: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC99C: 4182001C  beq 0x82ebc9b8
	if ctx.cr[0].eq {
	pc = 0x82EBC9B8; continue 'dispatch;
	}
	// 82EBC9A0: 817A01D4  lwz r11, 0x1d4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBC9A4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBC9A8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBC9AC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC9B0: 4198FFD4  blt cr6, 0x82ebc984
	if ctx.cr[6].lt {
	pc = 0x82EBC984; continue 'dispatch;
	}
	// 82EBC9B4: 48000014  b 0x82ebc9c8
	pc = 0x82EBC9C8; continue 'dispatch;
	// 82EBC9B8: 817A01CC  lwz r11, 0x1cc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBC9BC: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBC9C0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC9C4: 917A01D8  stw r11, 0x1d8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 82EBC9C8: 817A01D8  lwz r11, 0x1d8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EBC9CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC9D0: 409AF67C  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC9D4: 817A01D4  lwz r11, 0x1d4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBC9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC9DC: 419AF670  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC9E0: 817A01CC  lwz r11, 0x1cc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBC9E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC9E8: 917A01D8  stw r11, 0x1d8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 82EBC9EC: 4BFFF660  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC9F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC9F8: 3BCBAB64  addi r30, r11, -0x549c
	ctx.r[30].s64 = ctx.r[11].s64 + -21660;
	// 82EBC9FC: 482FF665  bl 0x831bc060
	ctx.lr = 0x82EBCA00;
	sub_831BC060(ctx, base);
	// 82EBCA00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCA04: 4BDF014D  bl 0x82cacb50
	ctx.lr = 0x82EBCA08;
	sub_82CACB50(ctx, base);
	// 82EBCA08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCA0C: 40820118  bne 0x82ebcb24
	if !ctx.cr[0].eq {
	pc = 0x82EBCB24; continue 'dispatch;
	}
	// 82EBCA10: 387A0218  addi r3, r26, 0x218
	ctx.r[3].s64 = ctx.r[26].s64 + 536;
	// 82EBCA14: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCA18: 4BFFC7C1  bl 0x82eb91d8
	ctx.lr = 0x82EBCA1C;
	sub_82EB91D8(ctx, base);
	// 82EBCA1C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCA20: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCA24: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCA28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCA2C: 409900D0  ble cr6, 0x82ebcafc
	if !ctx.cr[6].gt {
	pc = 0x82EBCAFC; continue 'dispatch;
	}
	// 82EBCA30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCA34: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBCA38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCA3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCA40: 4BFC75E9  bl 0x82e84028
	ctx.lr = 0x82EBCA44;
	sub_82E84028(ctx, base);
	// 82EBCA44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCA48: 482FF619  bl 0x831bc060
	ctx.lr = 0x82EBCA4C;
	sub_831BC060(ctx, base);
	// 82EBCA4C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCA50: 4BDF0101  bl 0x82cacb50
	ctx.lr = 0x82EBCA54;
	sub_82CACB50(ctx, base);
	// 82EBCA54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCA58: 40820014  bne 0x82ebca6c
	if !ctx.cr[0].eq {
	pc = 0x82EBCA6C; continue 'dispatch;
	}
	// 82EBCA5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCA60: 4BA512A9  bl 0x8290dd08
	ctx.lr = 0x82EBCA64;
	sub_8290DD08(ctx, base);
	// 82EBCA64: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCA68: 48000024  b 0x82ebca8c
	pc = 0x82EBCA8C; continue 'dispatch;
	// 82EBCA6C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCA70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCA74: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCA78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCA7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCA80: 4E800421  bctrl
	ctx.lr = 0x82EBCA84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCA84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCA88: 4182F748  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBCA8C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCA90: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCA94: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCA98: 4198FFA0  blt cr6, 0x82ebca38
	if ctx.cr[6].lt {
	pc = 0x82EBCA38; continue 'dispatch;
	}
	// 82EBCA9C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCAA0: 419A005C  beq cr6, 0x82ebcafc
	if ctx.cr[6].eq {
	pc = 0x82EBCAFC; continue 'dispatch;
	}
	// 82EBCAA4: 817A0224  lwz r11, 0x224(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBCAA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCAB0: 4099004C  ble cr6, 0x82ebcafc
	if !ctx.cr[6].gt {
	pc = 0x82EBCAFC; continue 'dispatch;
	}
	// 82EBCAB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBCAB8: 817A021C  lwz r11, 0x21c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBCABC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCAC0: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBCAC4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCAC8: 4BDF0089  bl 0x82cacb50
	ctx.lr = 0x82EBCACC;
	sub_82CACB50(ctx, base);
	// 82EBCACC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCAD0: 4182001C  beq 0x82ebcaec
	if ctx.cr[0].eq {
	pc = 0x82EBCAEC; continue 'dispatch;
	}
	// 82EBCAD4: 817A0224  lwz r11, 0x224(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBCAD8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCADC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCAE0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCAE4: 4198FFD4  blt cr6, 0x82ebcab8
	if ctx.cr[6].lt {
	pc = 0x82EBCAB8; continue 'dispatch;
	}
	// 82EBCAE8: 48000014  b 0x82ebcafc
	pc = 0x82EBCAFC; continue 'dispatch;
	// 82EBCAEC: 817A021C  lwz r11, 0x21c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBCAF0: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCAF4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCAF8: 917A0228  stw r11, 0x228(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 82EBCAFC: 817A0228  lwz r11, 0x228(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EBCB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCB04: 409AF548  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCB08: 817A0224  lwz r11, 0x224(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBCB0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCB10: 419AF53C  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCB14: 817A021C  lwz r11, 0x21c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBCB18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCB1C: 917A0228  stw r11, 0x228(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 82EBCB20: 4BFFF52C  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBCB24: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCB2C: 3BCBAB48  addi r30, r11, -0x54b8
	ctx.r[30].s64 = ctx.r[11].s64 + -21688;
	// 82EBCB30: 482FF531  bl 0x831bc060
	ctx.lr = 0x82EBCB34;
	sub_831BC060(ctx, base);
	// 82EBCB34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCB38: 4BDF0019  bl 0x82cacb50
	ctx.lr = 0x82EBCB3C;
	sub_82CACB50(ctx, base);
	// 82EBCB3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCB40: 40820118  bne 0x82ebcc58
	if !ctx.cr[0].eq {
	pc = 0x82EBCC58; continue 'dispatch;
	}
	// 82EBCB44: 387A01DC  addi r3, r26, 0x1dc
	ctx.r[3].s64 = ctx.r[26].s64 + 476;
	// 82EBCB48: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCB4C: 4BFFC68D  bl 0x82eb91d8
	ctx.lr = 0x82EBCB50;
	sub_82EB91D8(ctx, base);
	// 82EBCB50: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCB54: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCB58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCB5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCB60: 409900D0  ble cr6, 0x82ebcc30
	if !ctx.cr[6].gt {
	pc = 0x82EBCC30; continue 'dispatch;
	}
	// 82EBCB64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCB68: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBCB6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCB70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCB74: 4BFC74B5  bl 0x82e84028
	ctx.lr = 0x82EBCB78;
	sub_82E84028(ctx, base);
	// 82EBCB78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCB7C: 482FF4E5  bl 0x831bc060
	ctx.lr = 0x82EBCB80;
	sub_831BC060(ctx, base);
	// 82EBCB80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCB84: 4BDEFFCD  bl 0x82cacb50
	ctx.lr = 0x82EBCB88;
	sub_82CACB50(ctx, base);
	// 82EBCB88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCB8C: 40820014  bne 0x82ebcba0
	if !ctx.cr[0].eq {
	pc = 0x82EBCBA0; continue 'dispatch;
	}
	// 82EBCB90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCB94: 4BA51175  bl 0x8290dd08
	ctx.lr = 0x82EBCB98;
	sub_8290DD08(ctx, base);
	// 82EBCB98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCB9C: 48000024  b 0x82ebcbc0
	pc = 0x82EBCBC0; continue 'dispatch;
	// 82EBCBA0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCBA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCBA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCBAC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCBB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCBB4: 4E800421  bctrl
	ctx.lr = 0x82EBCBB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCBB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCBBC: 4182F614  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBCBC0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCBC4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCBC8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCBCC: 4198FFA0  blt cr6, 0x82ebcb6c
	if ctx.cr[6].lt {
	pc = 0x82EBCB6C; continue 'dispatch;
	}
	// 82EBCBD0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCBD4: 419A005C  beq cr6, 0x82ebcc30
	if ctx.cr[6].eq {
	pc = 0x82EBCC30; continue 'dispatch;
	}
	// 82EBCBD8: 817A01E8  lwz r11, 0x1e8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBCBDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCBE4: 4099004C  ble cr6, 0x82ebcc30
	if !ctx.cr[6].gt {
	pc = 0x82EBCC30; continue 'dispatch;
	}
	// 82EBCBE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBCBEC: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBCBF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCBF4: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCBF8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCBFC: 4BDEFF55  bl 0x82cacb50
	ctx.lr = 0x82EBCC00;
	sub_82CACB50(ctx, base);
	// 82EBCC00: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCC04: 4182001C  beq 0x82ebcc20
	if ctx.cr[0].eq {
	pc = 0x82EBCC20; continue 'dispatch;
	}
	// 82EBCC08: 817A01E8  lwz r11, 0x1e8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBCC0C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCC10: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCC14: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCC18: 4198FFD4  blt cr6, 0x82ebcbec
	if ctx.cr[6].lt {
	pc = 0x82EBCBEC; continue 'dispatch;
	}
	// 82EBCC1C: 48000014  b 0x82ebcc30
	pc = 0x82EBCC30; continue 'dispatch;
	// 82EBCC20: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBCC24: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCC28: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCC2C: 917A01EC  stw r11, 0x1ec(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
	// 82EBCC30: 817A01EC  lwz r11, 0x1ec(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EBCC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCC38: 409AF414  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCC3C: 817A01E8  lwz r11, 0x1e8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBCC40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCC44: 419AF408  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCC48: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBCC4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCC50: 917A01EC  stw r11, 0x1ec(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
	// 82EBCC54: 4BFFF3F8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBCC58: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCC5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCC60: 3BCBAB24  addi r30, r11, -0x54dc
	ctx.r[30].s64 = ctx.r[11].s64 + -21724;
	// 82EBCC64: 482FF3FD  bl 0x831bc060
	ctx.lr = 0x82EBCC68;
	sub_831BC060(ctx, base);
	// 82EBCC68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCC6C: 4BDEFEE5  bl 0x82cacb50
	ctx.lr = 0x82EBCC70;
	sub_82CACB50(ctx, base);
	// 82EBCC70: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCC74: 40820118  bne 0x82ebcd8c
	if !ctx.cr[0].eq {
	pc = 0x82EBCD8C; continue 'dispatch;
	}
	// 82EBCC78: 387A01F0  addi r3, r26, 0x1f0
	ctx.r[3].s64 = ctx.r[26].s64 + 496;
	// 82EBCC7C: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCC80: 4BFFC559  bl 0x82eb91d8
	ctx.lr = 0x82EBCC84;
	sub_82EB91D8(ctx, base);
	// 82EBCC84: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCC88: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCC8C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCC94: 409900D0  ble cr6, 0x82ebcd64
	if !ctx.cr[6].gt {
	pc = 0x82EBCD64; continue 'dispatch;
	}
	// 82EBCC98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCC9C: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBCCA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCCA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCCA8: 4BFC7381  bl 0x82e84028
	ctx.lr = 0x82EBCCAC;
	sub_82E84028(ctx, base);
	// 82EBCCAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCCB0: 482FF3B1  bl 0x831bc060
	ctx.lr = 0x82EBCCB4;
	sub_831BC060(ctx, base);
	// 82EBCCB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCCB8: 4BDEFE99  bl 0x82cacb50
	ctx.lr = 0x82EBCCBC;
	sub_82CACB50(ctx, base);
	// 82EBCCBC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCCC0: 40820014  bne 0x82ebccd4
	if !ctx.cr[0].eq {
	pc = 0x82EBCCD4; continue 'dispatch;
	}
	// 82EBCCC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCCC8: 4BA51041  bl 0x8290dd08
	ctx.lr = 0x82EBCCCC;
	sub_8290DD08(ctx, base);
	// 82EBCCCC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCCD0: 48000024  b 0x82ebccf4
	pc = 0x82EBCCF4; continue 'dispatch;
	// 82EBCCD4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCCD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCCDC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCCE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCCE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCCE8: 4E800421  bctrl
	ctx.lr = 0x82EBCCEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCCEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCCF0: 4182F4E0  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBCCF4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCCF8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCCFC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCD00: 4198FFA0  blt cr6, 0x82ebcca0
	if ctx.cr[6].lt {
	pc = 0x82EBCCA0; continue 'dispatch;
	}
	// 82EBCD04: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCD08: 419A005C  beq cr6, 0x82ebcd64
	if ctx.cr[6].eq {
	pc = 0x82EBCD64; continue 'dispatch;
	}
	// 82EBCD0C: 817A01FC  lwz r11, 0x1fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBCD10: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCD14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCD18: 4099004C  ble cr6, 0x82ebcd64
	if !ctx.cr[6].gt {
	pc = 0x82EBCD64; continue 'dispatch;
	}
	// 82EBCD1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBCD20: 817A01F4  lwz r11, 0x1f4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBCD24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCD28: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBCD2C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCD30: 4BDEFE21  bl 0x82cacb50
	ctx.lr = 0x82EBCD34;
	sub_82CACB50(ctx, base);
	// 82EBCD34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCD38: 4182001C  beq 0x82ebcd54
	if ctx.cr[0].eq {
	pc = 0x82EBCD54; continue 'dispatch;
	}
	// 82EBCD3C: 817A01FC  lwz r11, 0x1fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBCD40: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCD44: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCD48: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCD4C: 4198FFD4  blt cr6, 0x82ebcd20
	if ctx.cr[6].lt {
	pc = 0x82EBCD20; continue 'dispatch;
	}
	// 82EBCD50: 48000014  b 0x82ebcd64
	pc = 0x82EBCD64; continue 'dispatch;
	// 82EBCD54: 817A01F4  lwz r11, 0x1f4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBCD58: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCD5C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCD60: 917A0200  stw r11, 0x200(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 82EBCD64: 817A0200  lwz r11, 0x200(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EBCD68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCD6C: 409AF2E0  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCD70: 817A01FC  lwz r11, 0x1fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBCD74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCD78: 419AF2D4  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCD7C: 817A01F4  lwz r11, 0x1f4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBCD80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCD84: 917A0200  stw r11, 0x200(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 82EBCD88: 4BFFF2C4  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBCD8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCD90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCD94: 3BCBAB00  addi r30, r11, -0x5500
	ctx.r[30].s64 = ctx.r[11].s64 + -21760;
	// 82EBCD98: 482FF2C9  bl 0x831bc060
	ctx.lr = 0x82EBCD9C;
	sub_831BC060(ctx, base);
	// 82EBCD9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCDA0: 4BDEFDB1  bl 0x82cacb50
	ctx.lr = 0x82EBCDA4;
	sub_82CACB50(ctx, base);
	// 82EBCDA4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCDA8: 40820118  bne 0x82ebcec0
	if !ctx.cr[0].eq {
	pc = 0x82EBCEC0; continue 'dispatch;
	}
	// 82EBCDAC: 387A0204  addi r3, r26, 0x204
	ctx.r[3].s64 = ctx.r[26].s64 + 516;
	// 82EBCDB0: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCDB4: 4BFFC425  bl 0x82eb91d8
	ctx.lr = 0x82EBCDB8;
	sub_82EB91D8(ctx, base);
	// 82EBCDB8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCDBC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCDC0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCDC8: 409900D0  ble cr6, 0x82ebce98
	if !ctx.cr[6].gt {
	pc = 0x82EBCE98; continue 'dispatch;
	}
	// 82EBCDCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCDD0: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBCDD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCDD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCDDC: 4BFC724D  bl 0x82e84028
	ctx.lr = 0x82EBCDE0;
	sub_82E84028(ctx, base);
	// 82EBCDE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCDE4: 482FF27D  bl 0x831bc060
	ctx.lr = 0x82EBCDE8;
	sub_831BC060(ctx, base);
	// 82EBCDE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCDEC: 4BDEFD65  bl 0x82cacb50
	ctx.lr = 0x82EBCDF0;
	sub_82CACB50(ctx, base);
	// 82EBCDF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCDF4: 40820014  bne 0x82ebce08
	if !ctx.cr[0].eq {
	pc = 0x82EBCE08; continue 'dispatch;
	}
	// 82EBCDF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCDFC: 4BA50F0D  bl 0x8290dd08
	ctx.lr = 0x82EBCE00;
	sub_8290DD08(ctx, base);
	// 82EBCE00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCE04: 48000024  b 0x82ebce28
	pc = 0x82EBCE28; continue 'dispatch;
	// 82EBCE08: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCE0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCE10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCE14: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCE18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCE1C: 4E800421  bctrl
	ctx.lr = 0x82EBCE20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCE20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCE24: 4182F3AC  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBCE28: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCE2C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCE30: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCE34: 4198FFA0  blt cr6, 0x82ebcdd4
	if ctx.cr[6].lt {
	pc = 0x82EBCDD4; continue 'dispatch;
	}
	// 82EBCE38: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCE3C: 419A005C  beq cr6, 0x82ebce98
	if ctx.cr[6].eq {
	pc = 0x82EBCE98; continue 'dispatch;
	}
	// 82EBCE40: 817A0210  lwz r11, 0x210(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBCE44: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCE48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCE4C: 4099004C  ble cr6, 0x82ebce98
	if !ctx.cr[6].gt {
	pc = 0x82EBCE98; continue 'dispatch;
	}
	// 82EBCE50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBCE54: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBCE58: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCE5C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCE60: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCE64: 4BDEFCED  bl 0x82cacb50
	ctx.lr = 0x82EBCE68;
	sub_82CACB50(ctx, base);
	// 82EBCE68: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCE6C: 4182001C  beq 0x82ebce88
	if ctx.cr[0].eq {
	pc = 0x82EBCE88; continue 'dispatch;
	}
	// 82EBCE70: 817A0210  lwz r11, 0x210(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBCE74: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCE78: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCE7C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCE80: 4198FFD4  blt cr6, 0x82ebce54
	if ctx.cr[6].lt {
	pc = 0x82EBCE54; continue 'dispatch;
	}
	// 82EBCE84: 48000014  b 0x82ebce98
	pc = 0x82EBCE98; continue 'dispatch;
	// 82EBCE88: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBCE8C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCE90: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCE94: 917A0214  stw r11, 0x214(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 82EBCE98: 817A0214  lwz r11, 0x214(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EBCE9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCEA0: 409AF1AC  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCEA4: 817A0210  lwz r11, 0x210(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBCEA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCEAC: 419AF1A0  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCEB0: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBCEB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCEB8: 917A0214  stw r11, 0x214(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 82EBCEBC: 4BFFF190  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBCEC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCEC8: 3BCBAAE0  addi r30, r11, -0x5520
	ctx.r[30].s64 = ctx.r[11].s64 + -21792;
	// 82EBCECC: 482FF195  bl 0x831bc060
	ctx.lr = 0x82EBCED0;
	sub_831BC060(ctx, base);
	// 82EBCED0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCED4: 4BDEFC7D  bl 0x82cacb50
	ctx.lr = 0x82EBCED8;
	sub_82CACB50(ctx, base);
	// 82EBCED8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCEDC: 40820118  bne 0x82ebcff4
	if !ctx.cr[0].eq {
	pc = 0x82EBCFF4; continue 'dispatch;
	}
	// 82EBCEE0: 387A022C  addi r3, r26, 0x22c
	ctx.r[3].s64 = ctx.r[26].s64 + 556;
	// 82EBCEE4: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCEE8: 4BFFC2F1  bl 0x82eb91d8
	ctx.lr = 0x82EBCEEC;
	sub_82EB91D8(ctx, base);
	// 82EBCEEC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCEF0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCEF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCEF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCEFC: 409900D0  ble cr6, 0x82ebcfcc
	if !ctx.cr[6].gt {
	pc = 0x82EBCFCC; continue 'dispatch;
	}
	// 82EBCF00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCF04: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBCF08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCF10: 4BFC7119  bl 0x82e84028
	ctx.lr = 0x82EBCF14;
	sub_82E84028(ctx, base);
	// 82EBCF14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCF18: 482FF149  bl 0x831bc060
	ctx.lr = 0x82EBCF1C;
	sub_831BC060(ctx, base);
	// 82EBCF1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCF20: 4BDEFC31  bl 0x82cacb50
	ctx.lr = 0x82EBCF24;
	sub_82CACB50(ctx, base);
	// 82EBCF24: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCF28: 40820014  bne 0x82ebcf3c
	if !ctx.cr[0].eq {
	pc = 0x82EBCF3C; continue 'dispatch;
	}
	// 82EBCF2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCF30: 4BA50DD9  bl 0x8290dd08
	ctx.lr = 0x82EBCF34;
	sub_8290DD08(ctx, base);
	// 82EBCF34: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCF38: 48000024  b 0x82ebcf5c
	pc = 0x82EBCF5C; continue 'dispatch;
	// 82EBCF3C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCF40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCF44: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCF48: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCF4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCF50: 4E800421  bctrl
	ctx.lr = 0x82EBCF54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCF54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCF58: 4182F278  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBCF5C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCF60: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCF64: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCF68: 4198FFA0  blt cr6, 0x82ebcf08
	if ctx.cr[6].lt {
	pc = 0x82EBCF08; continue 'dispatch;
	}
	// 82EBCF6C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCF70: 419A005C  beq cr6, 0x82ebcfcc
	if ctx.cr[6].eq {
	pc = 0x82EBCFCC; continue 'dispatch;
	}
	// 82EBCF74: 817A0238  lwz r11, 0x238(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBCF78: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCF80: 4099004C  ble cr6, 0x82ebcfcc
	if !ctx.cr[6].gt {
	pc = 0x82EBCFCC; continue 'dispatch;
	}
	// 82EBCF84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBCF88: 817A0230  lwz r11, 0x230(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBCF8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCF90: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBCF94: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCF98: 4BDEFBB9  bl 0x82cacb50
	ctx.lr = 0x82EBCF9C;
	sub_82CACB50(ctx, base);
	// 82EBCF9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCFA0: 4182001C  beq 0x82ebcfbc
	if ctx.cr[0].eq {
	pc = 0x82EBCFBC; continue 'dispatch;
	}
	// 82EBCFA4: 817A0238  lwz r11, 0x238(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBCFA8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCFAC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCFB0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCFB4: 4198FFD4  blt cr6, 0x82ebcf88
	if ctx.cr[6].lt {
	pc = 0x82EBCF88; continue 'dispatch;
	}
	// 82EBCFB8: 48000014  b 0x82ebcfcc
	pc = 0x82EBCFCC; continue 'dispatch;
	// 82EBCFBC: 817A0230  lwz r11, 0x230(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBCFC0: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCFC4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCFC8: 917A023C  stw r11, 0x23c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 82EBCFCC: 817A023C  lwz r11, 0x23c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EBCFD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCFD4: 409AF078  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCFD8: 817A0238  lwz r11, 0x238(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBCFDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCFE0: 419AF06C  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCFE4: 817A0230  lwz r11, 0x230(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBCFE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCFEC: 917A023C  stw r11, 0x23c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 82EBCFF0: 4BFFF05C  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBCFF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCFF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCFFC: 3BCBAAD0  addi r30, r11, -0x5530
	ctx.r[30].s64 = ctx.r[11].s64 + -21808;
	// 82EBD000: 482FF061  bl 0x831bc060
	ctx.lr = 0x82EBD004;
	sub_831BC060(ctx, base);
	// 82EBD004: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD008: 4BDEFB49  bl 0x82cacb50
	ctx.lr = 0x82EBD00C;
	sub_82CACB50(ctx, base);
	// 82EBD00C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD010: 40820118  bne 0x82ebd128
	if !ctx.cr[0].eq {
	pc = 0x82EBD128; continue 'dispatch;
	}
	// 82EBD014: 387A0240  addi r3, r26, 0x240
	ctx.r[3].s64 = ctx.r[26].s64 + 576;
	// 82EBD018: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD01C: 4BFFC1BD  bl 0x82eb91d8
	ctx.lr = 0x82EBD020;
	sub_82EB91D8(ctx, base);
	// 82EBD020: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD024: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBD028: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBD02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD030: 409900D0  ble cr6, 0x82ebd100
	if !ctx.cr[6].gt {
	pc = 0x82EBD100; continue 'dispatch;
	}
	// 82EBD034: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD038: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBD03C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBD040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD044: 4BFC6FE5  bl 0x82e84028
	ctx.lr = 0x82EBD048;
	sub_82E84028(ctx, base);
	// 82EBD048: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBD04C: 482FF015  bl 0x831bc060
	ctx.lr = 0x82EBD050;
	sub_831BC060(ctx, base);
	// 82EBD050: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBD054: 4BDEFAFD  bl 0x82cacb50
	ctx.lr = 0x82EBD058;
	sub_82CACB50(ctx, base);
	// 82EBD058: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD05C: 40820014  bne 0x82ebd070
	if !ctx.cr[0].eq {
	pc = 0x82EBD070; continue 'dispatch;
	}
	// 82EBD060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBD064: 4BA50CA5  bl 0x8290dd08
	ctx.lr = 0x82EBD068;
	sub_8290DD08(ctx, base);
	// 82EBD068: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBD06C: 48000024  b 0x82ebd090
	pc = 0x82EBD090; continue 'dispatch;
	// 82EBD070: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD074: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD078: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD07C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD080: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD084: 4E800421  bctrl
	ctx.lr = 0x82EBD088;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD088: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD08C: 4182F144  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD090: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD094: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBD098: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD09C: 4198FFA0  blt cr6, 0x82ebd03c
	if ctx.cr[6].lt {
	pc = 0x82EBD03C; continue 'dispatch;
	}
	// 82EBD0A0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBD0A4: 419A005C  beq cr6, 0x82ebd100
	if ctx.cr[6].eq {
	pc = 0x82EBD100; continue 'dispatch;
	}
	// 82EBD0A8: 817A024C  lwz r11, 0x24c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBD0AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBD0B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD0B4: 4099004C  ble cr6, 0x82ebd100
	if !ctx.cr[6].gt {
	pc = 0x82EBD100; continue 'dispatch;
	}
	// 82EBD0B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD0BC: 817A0244  lwz r11, 0x244(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBD0C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBD0C4: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD0C8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD0CC: 4BDEFA85  bl 0x82cacb50
	ctx.lr = 0x82EBD0D0;
	sub_82CACB50(ctx, base);
	// 82EBD0D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD0D4: 4182001C  beq 0x82ebd0f0
	if ctx.cr[0].eq {
	pc = 0x82EBD0F0; continue 'dispatch;
	}
	// 82EBD0D8: 817A024C  lwz r11, 0x24c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBD0DC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBD0E0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBD0E4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD0E8: 4198FFD4  blt cr6, 0x82ebd0bc
	if ctx.cr[6].lt {
	pc = 0x82EBD0BC; continue 'dispatch;
	}
	// 82EBD0EC: 48000014  b 0x82ebd100
	pc = 0x82EBD100; continue 'dispatch;
	// 82EBD0F0: 817A0244  lwz r11, 0x244(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBD0F4: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBD0F8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD0FC: 917A0250  stw r11, 0x250(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(592 as u32), ctx.r[11].u32 ) };
	// 82EBD100: 817A0250  lwz r11, 0x250(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBD104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD108: 409AEF44  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD10C: 817A024C  lwz r11, 0x24c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBD110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD114: 419AEF38  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD118: 817A0244  lwz r11, 0x244(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBD11C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD120: 917A0250  stw r11, 0x250(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(592 as u32), ctx.r[11].u32 ) };
	// 82EBD124: 4BFFEF28  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD128: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD12C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD130: 3BCBAABC  addi r30, r11, -0x5544
	ctx.r[30].s64 = ctx.r[11].s64 + -21828;
	// 82EBD134: 482FEF2D  bl 0x831bc060
	ctx.lr = 0x82EBD138;
	sub_831BC060(ctx, base);
	// 82EBD138: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD13C: 4BDEFA15  bl 0x82cacb50
	ctx.lr = 0x82EBD140;
	sub_82CACB50(ctx, base);
	// 82EBD140: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD144: 40820118  bne 0x82ebd25c
	if !ctx.cr[0].eq {
	pc = 0x82EBD25C; continue 'dispatch;
	}
	// 82EBD148: 387A0254  addi r3, r26, 0x254
	ctx.r[3].s64 = ctx.r[26].s64 + 596;
	// 82EBD14C: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD150: 4BFFC089  bl 0x82eb91d8
	ctx.lr = 0x82EBD154;
	sub_82EB91D8(ctx, base);
	// 82EBD154: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD158: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBD15C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBD160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD164: 409900D0  ble cr6, 0x82ebd234
	if !ctx.cr[6].gt {
	pc = 0x82EBD234; continue 'dispatch;
	}
	// 82EBD168: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD16C: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBD170: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBD174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD178: 4BFC6EB1  bl 0x82e84028
	ctx.lr = 0x82EBD17C;
	sub_82E84028(ctx, base);
	// 82EBD17C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBD180: 482FEEE1  bl 0x831bc060
	ctx.lr = 0x82EBD184;
	sub_831BC060(ctx, base);
	// 82EBD184: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBD188: 4BDEF9C9  bl 0x82cacb50
	ctx.lr = 0x82EBD18C;
	sub_82CACB50(ctx, base);
	// 82EBD18C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD190: 40820014  bne 0x82ebd1a4
	if !ctx.cr[0].eq {
	pc = 0x82EBD1A4; continue 'dispatch;
	}
	// 82EBD194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBD198: 4BA50B71  bl 0x8290dd08
	ctx.lr = 0x82EBD19C;
	sub_8290DD08(ctx, base);
	// 82EBD19C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBD1A0: 48000024  b 0x82ebd1c4
	pc = 0x82EBD1C4; continue 'dispatch;
	// 82EBD1A4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD1A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD1AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD1B0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD1B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD1B8: 4E800421  bctrl
	ctx.lr = 0x82EBD1BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD1BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD1C0: 4182F010  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD1C4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD1C8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBD1CC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD1D0: 4198FFA0  blt cr6, 0x82ebd170
	if ctx.cr[6].lt {
	pc = 0x82EBD170; continue 'dispatch;
	}
	// 82EBD1D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBD1D8: 419A005C  beq cr6, 0x82ebd234
	if ctx.cr[6].eq {
	pc = 0x82EBD234; continue 'dispatch;
	}
	// 82EBD1DC: 817A0260  lwz r11, 0x260(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBD1E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBD1E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD1E8: 4099004C  ble cr6, 0x82ebd234
	if !ctx.cr[6].gt {
	pc = 0x82EBD234; continue 'dispatch;
	}
	// 82EBD1EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD1F0: 817A0258  lwz r11, 0x258(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBD1F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBD1F8: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD1FC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD200: 4BDEF951  bl 0x82cacb50
	ctx.lr = 0x82EBD204;
	sub_82CACB50(ctx, base);
	// 82EBD204: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD208: 4182001C  beq 0x82ebd224
	if ctx.cr[0].eq {
	pc = 0x82EBD224; continue 'dispatch;
	}
	// 82EBD20C: 817A0260  lwz r11, 0x260(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBD210: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBD214: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBD218: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD21C: 4198FFD4  blt cr6, 0x82ebd1f0
	if ctx.cr[6].lt {
	pc = 0x82EBD1F0; continue 'dispatch;
	}
	// 82EBD220: 48000014  b 0x82ebd234
	pc = 0x82EBD234; continue 'dispatch;
	// 82EBD224: 817A0258  lwz r11, 0x258(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBD228: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBD22C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD230: 917A0264  stw r11, 0x264(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 82EBD234: 817A0264  lwz r11, 0x264(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBD238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD23C: 409AEE10  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD240: 817A0260  lwz r11, 0x260(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBD244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD248: 419AEE04  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD24C: 817A0258  lwz r11, 0x258(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBD250: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD254: 917A0264  stw r11, 0x264(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 82EBD258: 4BFFEDF4  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD25C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD264: 3BCBAA98  addi r30, r11, -0x5568
	ctx.r[30].s64 = ctx.r[11].s64 + -21864;
	// 82EBD268: 482FEDF9  bl 0x831bc060
	ctx.lr = 0x82EBD26C;
	sub_831BC060(ctx, base);
	// 82EBD26C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD270: 4BDEF8E1  bl 0x82cacb50
	ctx.lr = 0x82EBD274;
	sub_82CACB50(ctx, base);
	// 82EBD274: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD278: 40820118  bne 0x82ebd390
	if !ctx.cr[0].eq {
	pc = 0x82EBD390; continue 'dispatch;
	}
	// 82EBD27C: 387A0268  addi r3, r26, 0x268
	ctx.r[3].s64 = ctx.r[26].s64 + 616;
	// 82EBD280: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD284: 4BFFBF55  bl 0x82eb91d8
	ctx.lr = 0x82EBD288;
	sub_82EB91D8(ctx, base);
	// 82EBD288: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD28C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBD290: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBD294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD298: 409900D0  ble cr6, 0x82ebd368
	if !ctx.cr[6].gt {
	pc = 0x82EBD368; continue 'dispatch;
	}
	// 82EBD29C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD2A0: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBD2A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBD2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD2AC: 4BFC6D7D  bl 0x82e84028
	ctx.lr = 0x82EBD2B0;
	sub_82E84028(ctx, base);
	// 82EBD2B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBD2B4: 482FEDAD  bl 0x831bc060
	ctx.lr = 0x82EBD2B8;
	sub_831BC060(ctx, base);
	// 82EBD2B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBD2BC: 4BDEF895  bl 0x82cacb50
	ctx.lr = 0x82EBD2C0;
	sub_82CACB50(ctx, base);
	// 82EBD2C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD2C4: 40820014  bne 0x82ebd2d8
	if !ctx.cr[0].eq {
	pc = 0x82EBD2D8; continue 'dispatch;
	}
	// 82EBD2C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBD2CC: 4BA50A3D  bl 0x8290dd08
	ctx.lr = 0x82EBD2D0;
	sub_8290DD08(ctx, base);
	// 82EBD2D0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBD2D4: 48000024  b 0x82ebd2f8
	pc = 0x82EBD2F8; continue 'dispatch;
	// 82EBD2D8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD2DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD2E0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD2E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD2E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD2EC: 4E800421  bctrl
	ctx.lr = 0x82EBD2F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD2F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD2F4: 4182EEDC  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD2F8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD2FC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBD300: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD304: 4198FFA0  blt cr6, 0x82ebd2a4
	if ctx.cr[6].lt {
	pc = 0x82EBD2A4; continue 'dispatch;
	}
	// 82EBD308: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBD30C: 419A005C  beq cr6, 0x82ebd368
	if ctx.cr[6].eq {
	pc = 0x82EBD368; continue 'dispatch;
	}
	// 82EBD310: 817A0274  lwz r11, 0x274(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBD314: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBD318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD31C: 4099004C  ble cr6, 0x82ebd368
	if !ctx.cr[6].gt {
	pc = 0x82EBD368; continue 'dispatch;
	}
	// 82EBD320: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD324: 817A026C  lwz r11, 0x26c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBD328: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBD32C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD330: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD334: 4BDEF81D  bl 0x82cacb50
	ctx.lr = 0x82EBD338;
	sub_82CACB50(ctx, base);
	// 82EBD338: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD33C: 4182001C  beq 0x82ebd358
	if ctx.cr[0].eq {
	pc = 0x82EBD358; continue 'dispatch;
	}
	// 82EBD340: 817A0274  lwz r11, 0x274(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBD344: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBD348: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBD34C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD350: 4198FFD4  blt cr6, 0x82ebd324
	if ctx.cr[6].lt {
	pc = 0x82EBD324; continue 'dispatch;
	}
	// 82EBD354: 48000014  b 0x82ebd368
	pc = 0x82EBD368; continue 'dispatch;
	// 82EBD358: 817A026C  lwz r11, 0x26c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBD35C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBD360: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD364: 917A0278  stw r11, 0x278(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 82EBD368: 817A0278  lwz r11, 0x278(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EBD36C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD370: 409AECDC  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD374: 817A0274  lwz r11, 0x274(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBD378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD37C: 419AECD0  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD380: 817A026C  lwz r11, 0x26c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBD384: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD388: 917A0278  stw r11, 0x278(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 82EBD38C: 4BFFECC0  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD390: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD398: 3BCBAA8C  addi r30, r11, -0x5574
	ctx.r[30].s64 = ctx.r[11].s64 + -21876;
	// 82EBD39C: 482FECC5  bl 0x831bc060
	ctx.lr = 0x82EBD3A0;
	sub_831BC060(ctx, base);
	// 82EBD3A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD3A4: 4BDEF7AD  bl 0x82cacb50
	ctx.lr = 0x82EBD3A8;
	sub_82CACB50(ctx, base);
	// 82EBD3A8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD3AC: 408200B8  bne 0x82ebd464
	if !ctx.cr[0].eq {
	pc = 0x82EBD464; continue 'dispatch;
	}
	// 82EBD3B0: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD3B4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD3B8: 4182EE18  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD3BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD3C4: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD3C8: 4BFC6B51  bl 0x82e83f18
	ctx.lr = 0x82EBD3CC;
	sub_82E83F18(ctx, base);
	// 82EBD3CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD3D0: 4182000C  beq 0x82ebd3dc
	if ctx.cr[0].eq {
	pc = 0x82EBD3DC; continue 'dispatch;
	}
	// 82EBD3D4: 4BA50935  bl 0x8290dd08
	ctx.lr = 0x82EBD3D8;
	sub_8290DD08(ctx, base);
	// 82EBD3D8: 48000008  b 0x82ebd3e0
	pc = 0x82EBD3E0; continue 'dispatch;
	// 82EBD3DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBD3E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD3E4: 419AEDEC  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD3E8: 4BFFE4B9  bl 0x82ebb8a0
	ctx.lr = 0x82EBD3EC;
	sub_82EBB8A0(ctx, base);
	// 82EBD3EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD3F0: 40820030  bne 0x82ebd420
	if !ctx.cr[0].eq {
	pc = 0x82EBD420; continue 'dispatch;
	}
	// 82EBD3F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD3F8: 4BFFDF81  bl 0x82ebb378
	ctx.lr = 0x82EBD3FC;
	sub_82EBB378(ctx, base);
	// 82EBD3FC: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD400: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD404: 4099EDCC  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD408: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD40C: 4BFFDF6D  bl 0x82ebb378
	ctx.lr = 0x82EBD410;
	sub_82EBB378(ctx, base);
	// 82EBD410: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD414: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD418: 4198FFF0  blt cr6, 0x82ebd408
	if ctx.cr[6].lt {
	pc = 0x82EBD408; continue 'dispatch;
	}
	// 82EBD41C: 4BFFEDB4  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBD420: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD424: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD428: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD42C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD430: 4E800421  bctrl
	ctx.lr = 0x82EBD434;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD434: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD438: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD43C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD440: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD444: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD448: 4E800421  bctrl
	ctx.lr = 0x82EBD44C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD44C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD450: 4182ED80  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD454: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD458: 387A01A0  addi r3, r26, 0x1a0
	ctx.r[3].s64 = ctx.r[26].s64 + 416;
	// 82EBD45C: 4BFFBE35  bl 0x82eb9290
	ctx.lr = 0x82EBD460;
	sub_82EB9290(ctx, base);
	// 82EBD460: 4BFFEBEC  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD464: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD46C: 3BCBAA78  addi r30, r11, -0x5588
	ctx.r[30].s64 = ctx.r[11].s64 + -21896;
	// 82EBD470: 482FEBF1  bl 0x831bc060
	ctx.lr = 0x82EBD474;
	sub_831BC060(ctx, base);
	// 82EBD474: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD478: 4BDEF6D9  bl 0x82cacb50
	ctx.lr = 0x82EBD47C;
	sub_82CACB50(ctx, base);
	// 82EBD47C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD480: 408200B8  bne 0x82ebd538
	if !ctx.cr[0].eq {
	pc = 0x82EBD538; continue 'dispatch;
	}
	// 82EBD484: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD488: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD48C: 4182ED44  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD490: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD498: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD49C: 4BFC6A7D  bl 0x82e83f18
	ctx.lr = 0x82EBD4A0;
	sub_82E83F18(ctx, base);
	// 82EBD4A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD4A4: 4182000C  beq 0x82ebd4b0
	if ctx.cr[0].eq {
	pc = 0x82EBD4B0; continue 'dispatch;
	}
	// 82EBD4A8: 4BA50861  bl 0x8290dd08
	ctx.lr = 0x82EBD4AC;
	sub_8290DD08(ctx, base);
	// 82EBD4AC: 48000008  b 0x82ebd4b4
	pc = 0x82EBD4B4; continue 'dispatch;
	// 82EBD4B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBD4B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD4B8: 419AED18  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD4BC: 4BFFE485  bl 0x82ebb940
	ctx.lr = 0x82EBD4C0;
	sub_82EBB940(ctx, base);
	// 82EBD4C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD4C4: 40820030  bne 0x82ebd4f4
	if !ctx.cr[0].eq {
	pc = 0x82EBD4F4; continue 'dispatch;
	}
	// 82EBD4C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD4CC: 4BFFDF25  bl 0x82ebb3f0
	ctx.lr = 0x82EBD4D0;
	sub_82EBB3F0(ctx, base);
	// 82EBD4D0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD4D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD4D8: 4099ECF8  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD4DC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD4E0: 4BFFDF11  bl 0x82ebb3f0
	ctx.lr = 0x82EBD4E4;
	sub_82EBB3F0(ctx, base);
	// 82EBD4E4: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD4E8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD4EC: 4198FFF0  blt cr6, 0x82ebd4dc
	if ctx.cr[6].lt {
	pc = 0x82EBD4DC; continue 'dispatch;
	}
	// 82EBD4F0: 4BFFECE0  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBD4F4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD4F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD4FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD504: 4E800421  bctrl
	ctx.lr = 0x82EBD508;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD50C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD510: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD514: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD518: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD51C: 4E800421  bctrl
	ctx.lr = 0x82EBD520;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD520: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD524: 4182ECAC  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD528: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD52C: 387A01B4  addi r3, r26, 0x1b4
	ctx.r[3].s64 = ctx.r[26].s64 + 436;
	// 82EBD530: 4BFFBD61  bl 0x82eb9290
	ctx.lr = 0x82EBD534;
	sub_82EB9290(ctx, base);
	// 82EBD534: 4BFFEB18  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD538: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD540: 3BCBAA64  addi r30, r11, -0x559c
	ctx.r[30].s64 = ctx.r[11].s64 + -21916;
	// 82EBD544: 482FEB1D  bl 0x831bc060
	ctx.lr = 0x82EBD548;
	sub_831BC060(ctx, base);
	// 82EBD548: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD54C: 4BDEF605  bl 0x82cacb50
	ctx.lr = 0x82EBD550;
	sub_82CACB50(ctx, base);
	// 82EBD550: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD554: 408200B8  bne 0x82ebd60c
	if !ctx.cr[0].eq {
	pc = 0x82EBD60C; continue 'dispatch;
	}
	// 82EBD558: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD55C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD560: 4182EC70  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD564: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD56C: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD570: 4BFC69A9  bl 0x82e83f18
	ctx.lr = 0x82EBD574;
	sub_82E83F18(ctx, base);
	// 82EBD574: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD578: 4182000C  beq 0x82ebd584
	if ctx.cr[0].eq {
	pc = 0x82EBD584; continue 'dispatch;
	}
	// 82EBD57C: 4BA5078D  bl 0x8290dd08
	ctx.lr = 0x82EBD580;
	sub_8290DD08(ctx, base);
	// 82EBD580: 48000008  b 0x82ebd588
	pc = 0x82EBD588; continue 'dispatch;
	// 82EBD584: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBD588: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD58C: 419AEC44  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD590: 4BFFE451  bl 0x82ebb9e0
	ctx.lr = 0x82EBD594;
	sub_82EBB9E0(ctx, base);
	// 82EBD594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD598: 40820030  bne 0x82ebd5c8
	if !ctx.cr[0].eq {
	pc = 0x82EBD5C8; continue 'dispatch;
	}
	// 82EBD59C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD5A0: 4BFFDEC9  bl 0x82ebb468
	ctx.lr = 0x82EBD5A4;
	sub_82EBB468(ctx, base);
	// 82EBD5A4: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD5A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD5AC: 4099EC24  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD5B0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD5B4: 4BFFDEB5  bl 0x82ebb468
	ctx.lr = 0x82EBD5B8;
	sub_82EBB468(ctx, base);
	// 82EBD5B8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD5BC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD5C0: 4198FFF0  blt cr6, 0x82ebd5b0
	if ctx.cr[6].lt {
	pc = 0x82EBD5B0; continue 'dispatch;
	}
	// 82EBD5C4: 4BFFEC0C  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBD5C8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD5CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD5D0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD5D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD5D8: 4E800421  bctrl
	ctx.lr = 0x82EBD5DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD5DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD5E0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD5E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD5E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD5EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD5F0: 4E800421  bctrl
	ctx.lr = 0x82EBD5F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD5F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD5F8: 4182EBD8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD5FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD600: 387A01C8  addi r3, r26, 0x1c8
	ctx.r[3].s64 = ctx.r[26].s64 + 456;
	// 82EBD604: 4BFFBC8D  bl 0x82eb9290
	ctx.lr = 0x82EBD608;
	sub_82EB9290(ctx, base);
	// 82EBD608: 4BFFEA44  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD60C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD614: 3BCBAA5C  addi r30, r11, -0x55a4
	ctx.r[30].s64 = ctx.r[11].s64 + -21924;
	// 82EBD618: 482FEA49  bl 0x831bc060
	ctx.lr = 0x82EBD61C;
	sub_831BC060(ctx, base);
	// 82EBD61C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD620: 4BDEF531  bl 0x82cacb50
	ctx.lr = 0x82EBD624;
	sub_82CACB50(ctx, base);
	// 82EBD624: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD628: 408200B8  bne 0x82ebd6e0
	if !ctx.cr[0].eq {
	pc = 0x82EBD6E0; continue 'dispatch;
	}
	// 82EBD62C: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD630: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD634: 4182EB9C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD638: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD63C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD640: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD644: 4BFC68D5  bl 0x82e83f18
	ctx.lr = 0x82EBD648;
	sub_82E83F18(ctx, base);
	// 82EBD648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD64C: 4182000C  beq 0x82ebd658
	if ctx.cr[0].eq {
	pc = 0x82EBD658; continue 'dispatch;
	}
	// 82EBD650: 4BA506B9  bl 0x8290dd08
	ctx.lr = 0x82EBD654;
	sub_8290DD08(ctx, base);
	// 82EBD654: 48000008  b 0x82ebd65c
	pc = 0x82EBD65C; continue 'dispatch;
	// 82EBD658: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBD65C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD660: 419AEB70  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD664: 4BFFE69D  bl 0x82ebbd00
	ctx.lr = 0x82EBD668;
	sub_82EBBD00(ctx, base);
	// 82EBD668: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD66C: 40820030  bne 0x82ebd69c
	if !ctx.cr[0].eq {
	pc = 0x82EBD69C; continue 'dispatch;
	}
	// 82EBD670: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD674: 4BFFE04D  bl 0x82ebb6c0
	ctx.lr = 0x82EBD678;
	sub_82EBB6C0(ctx, base);
	// 82EBD678: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD67C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD680: 4099EB50  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD684: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD688: 4BFFE039  bl 0x82ebb6c0
	ctx.lr = 0x82EBD68C;
	sub_82EBB6C0(ctx, base);
	// 82EBD68C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD690: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD694: 4198FFF0  blt cr6, 0x82ebd684
	if ctx.cr[6].lt {
	pc = 0x82EBD684; continue 'dispatch;
	}
	// 82EBD698: 4BFFEB38  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBD69C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD6A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD6A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD6A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD6AC: 4E800421  bctrl
	ctx.lr = 0x82EBD6B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD6B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD6B4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD6B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD6BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD6C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD6C4: 4E800421  bctrl
	ctx.lr = 0x82EBD6C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD6C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD6CC: 4182EB04  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD6D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD6D4: 387A0218  addi r3, r26, 0x218
	ctx.r[3].s64 = ctx.r[26].s64 + 536;
	// 82EBD6D8: 4BFFBBB9  bl 0x82eb9290
	ctx.lr = 0x82EBD6DC;
	sub_82EB9290(ctx, base);
	// 82EBD6DC: 4BFFE970  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD6E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD6E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD6E8: 3BCBAA4C  addi r30, r11, -0x55b4
	ctx.r[30].s64 = ctx.r[11].s64 + -21940;
	// 82EBD6EC: 482FE975  bl 0x831bc060
	ctx.lr = 0x82EBD6F0;
	sub_831BC060(ctx, base);
	// 82EBD6F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD6F4: 4BDEF45D  bl 0x82cacb50
	ctx.lr = 0x82EBD6F8;
	sub_82CACB50(ctx, base);
	// 82EBD6F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD6FC: 408200B8  bne 0x82ebd7b4
	if !ctx.cr[0].eq {
	pc = 0x82EBD7B4; continue 'dispatch;
	}
	// 82EBD700: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD704: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD708: 4182EAC8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD70C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD714: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD718: 4BFC6801  bl 0x82e83f18
	ctx.lr = 0x82EBD71C;
	sub_82E83F18(ctx, base);
	// 82EBD71C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD720: 4182000C  beq 0x82ebd72c
	if ctx.cr[0].eq {
	pc = 0x82EBD72C; continue 'dispatch;
	}
	// 82EBD724: 4BA505E5  bl 0x8290dd08
	ctx.lr = 0x82EBD728;
	sub_8290DD08(ctx, base);
	// 82EBD728: 48000008  b 0x82ebd730
	pc = 0x82EBD730; continue 'dispatch;
	// 82EBD72C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBD730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD734: 419AEA9C  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD738: 4BFFE349  bl 0x82ebba80
	ctx.lr = 0x82EBD73C;
	sub_82EBBA80(ctx, base);
	// 82EBD73C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD740: 40820030  bne 0x82ebd770
	if !ctx.cr[0].eq {
	pc = 0x82EBD770; continue 'dispatch;
	}
	// 82EBD744: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD748: 4BFFDD99  bl 0x82ebb4e0
	ctx.lr = 0x82EBD74C;
	sub_82EBB4E0(ctx, base);
	// 82EBD74C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD750: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD754: 4099EA7C  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD758: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD75C: 4BFFDD85  bl 0x82ebb4e0
	ctx.lr = 0x82EBD760;
	sub_82EBB4E0(ctx, base);
	// 82EBD760: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD764: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD768: 4198FFF0  blt cr6, 0x82ebd758
	if ctx.cr[6].lt {
	pc = 0x82EBD758; continue 'dispatch;
	}
	// 82EBD76C: 4BFFEA64  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBD770: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD774: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD778: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD77C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD780: 4E800421  bctrl
	ctx.lr = 0x82EBD784;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD784: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD788: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD78C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD790: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD794: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD798: 4E800421  bctrl
	ctx.lr = 0x82EBD79C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD79C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD7A0: 4182EA30  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD7A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD7A8: 387A01DC  addi r3, r26, 0x1dc
	ctx.r[3].s64 = ctx.r[26].s64 + 476;
	// 82EBD7AC: 4BFFBAE5  bl 0x82eb9290
	ctx.lr = 0x82EBD7B0;
	sub_82EB9290(ctx, base);
	// 82EBD7B0: 4BFFE89C  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD7B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD7B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD7BC: 3BCBAA30  addi r30, r11, -0x55d0
	ctx.r[30].s64 = ctx.r[11].s64 + -21968;
	// 82EBD7C0: 482FE8A1  bl 0x831bc060
	ctx.lr = 0x82EBD7C4;
	sub_831BC060(ctx, base);
	// 82EBD7C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD7C8: 4BDEF389  bl 0x82cacb50
	ctx.lr = 0x82EBD7CC;
	sub_82CACB50(ctx, base);
	// 82EBD7CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD7D0: 408200B8  bne 0x82ebd888
	if !ctx.cr[0].eq {
	pc = 0x82EBD888; continue 'dispatch;
	}
	// 82EBD7D4: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD7D8: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD7DC: 4182E9F4  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD7E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD7E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD7E8: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD7EC: 4BFC672D  bl 0x82e83f18
	ctx.lr = 0x82EBD7F0;
	sub_82E83F18(ctx, base);
	// 82EBD7F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD7F4: 4182000C  beq 0x82ebd800
	if ctx.cr[0].eq {
	pc = 0x82EBD800; continue 'dispatch;
	}
	// 82EBD7F8: 4BA50511  bl 0x8290dd08
	ctx.lr = 0x82EBD7FC;
	sub_8290DD08(ctx, base);
	// 82EBD7FC: 48000008  b 0x82ebd804
	pc = 0x82EBD804; continue 'dispatch;
	// 82EBD800: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBD804: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD808: 419AE9C8  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD80C: 4BFFE3B5  bl 0x82ebbbc0
	ctx.lr = 0x82EBD810;
	sub_82EBBBC0(ctx, base);
	// 82EBD810: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD814: 40820030  bne 0x82ebd844
	if !ctx.cr[0].eq {
	pc = 0x82EBD844; continue 'dispatch;
	}
	// 82EBD818: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD81C: 4BFFDDB5  bl 0x82ebb5d0
	ctx.lr = 0x82EBD820;
	sub_82EBB5D0(ctx, base);
	// 82EBD820: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD824: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD828: 4099E9A8  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD82C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD830: 4BFFDDA1  bl 0x82ebb5d0
	ctx.lr = 0x82EBD834;
	sub_82EBB5D0(ctx, base);
	// 82EBD834: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD838: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD83C: 4198FFF0  blt cr6, 0x82ebd82c
	if ctx.cr[6].lt {
	pc = 0x82EBD82C; continue 'dispatch;
	}
	// 82EBD840: 4BFFE990  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBD844: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD84C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD854: 4E800421  bctrl
	ctx.lr = 0x82EBD858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD858: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD85C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD860: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD864: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD86C: 4E800421  bctrl
	ctx.lr = 0x82EBD870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD870: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD874: 4182E95C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD878: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD87C: 387A01F0  addi r3, r26, 0x1f0
	ctx.r[3].s64 = ctx.r[26].s64 + 496;
	// 82EBD880: 4BFFBA11  bl 0x82eb9290
	ctx.lr = 0x82EBD884;
	sub_82EB9290(ctx, base);
	// 82EBD884: 4BFFE7C8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD888: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD88C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD890: 3BCBAA18  addi r30, r11, -0x55e8
	ctx.r[30].s64 = ctx.r[11].s64 + -21992;
	// 82EBD894: 482FE7CD  bl 0x831bc060
	ctx.lr = 0x82EBD898;
	sub_831BC060(ctx, base);
	// 82EBD898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD89C: 4BDEF2B5  bl 0x82cacb50
	ctx.lr = 0x82EBD8A0;
	sub_82CACB50(ctx, base);
	// 82EBD8A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD8A4: 408200B8  bne 0x82ebd95c
	if !ctx.cr[0].eq {
	pc = 0x82EBD95C; continue 'dispatch;
	}
	// 82EBD8A8: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD8AC: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD8B0: 4182E920  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD8B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD8B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD8BC: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD8C0: 4BFC6659  bl 0x82e83f18
	ctx.lr = 0x82EBD8C4;
	sub_82E83F18(ctx, base);
	// 82EBD8C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD8C8: 4182000C  beq 0x82ebd8d4
	if ctx.cr[0].eq {
	pc = 0x82EBD8D4; continue 'dispatch;
	}
	// 82EBD8CC: 4BA5043D  bl 0x8290dd08
	ctx.lr = 0x82EBD8D0;
	sub_8290DD08(ctx, base);
	// 82EBD8D0: 48000008  b 0x82ebd8d8
	pc = 0x82EBD8D8; continue 'dispatch;
	// 82EBD8D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBD8D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD8DC: 419AE8F4  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD8E0: 4BFFE241  bl 0x82ebbb20
	ctx.lr = 0x82EBD8E4;
	sub_82EBBB20(ctx, base);
	// 82EBD8E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD8E8: 40820030  bne 0x82ebd918
	if !ctx.cr[0].eq {
	pc = 0x82EBD918; continue 'dispatch;
	}
	// 82EBD8EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD8F0: 4BFFDC69  bl 0x82ebb558
	ctx.lr = 0x82EBD8F4;
	sub_82EBB558(ctx, base);
	// 82EBD8F4: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD8F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD8FC: 4099E8D4  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD900: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD904: 4BFFDC55  bl 0x82ebb558
	ctx.lr = 0x82EBD908;
	sub_82EBB558(ctx, base);
	// 82EBD908: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD90C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD910: 4198FFF0  blt cr6, 0x82ebd900
	if ctx.cr[6].lt {
	pc = 0x82EBD900; continue 'dispatch;
	}
	// 82EBD914: 4BFFE8BC  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBD918: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD91C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD920: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD924: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD928: 4E800421  bctrl
	ctx.lr = 0x82EBD92C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD92C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD930: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD938: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD93C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD940: 4E800421  bctrl
	ctx.lr = 0x82EBD944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD944: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD948: 4182E888  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD94C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD950: 387A0204  addi r3, r26, 0x204
	ctx.r[3].s64 = ctx.r[26].s64 + 516;
	// 82EBD954: 4BFFB93D  bl 0x82eb9290
	ctx.lr = 0x82EBD958;
	sub_82EB9290(ctx, base);
	// 82EBD958: 4BFFE6F4  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBD95C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD964: 3BCBAA04  addi r30, r11, -0x55fc
	ctx.r[30].s64 = ctx.r[11].s64 + -22012;
	// 82EBD968: 482FE6F9  bl 0x831bc060
	ctx.lr = 0x82EBD96C;
	sub_831BC060(ctx, base);
	// 82EBD96C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD970: 4BDEF1E1  bl 0x82cacb50
	ctx.lr = 0x82EBD974;
	sub_82CACB50(ctx, base);
	// 82EBD974: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD978: 408200B8  bne 0x82ebda30
	if !ctx.cr[0].eq {
	pc = 0x82EBDA30; continue 'dispatch;
	}
	// 82EBD97C: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD980: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD984: 4182E84C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD988: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD990: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD994: 4BFC6585  bl 0x82e83f18
	ctx.lr = 0x82EBD998;
	sub_82E83F18(ctx, base);
	// 82EBD998: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD99C: 4182000C  beq 0x82ebd9a8
	if ctx.cr[0].eq {
	pc = 0x82EBD9A8; continue 'dispatch;
	}
	// 82EBD9A0: 4BA50369  bl 0x8290dd08
	ctx.lr = 0x82EBD9A4;
	sub_8290DD08(ctx, base);
	// 82EBD9A4: 48000008  b 0x82ebd9ac
	pc = 0x82EBD9AC; continue 'dispatch;
	// 82EBD9A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBD9AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD9B0: 419AE820  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD9B4: 4BFFE2AD  bl 0x82ebbc60
	ctx.lr = 0x82EBD9B8;
	sub_82EBBC60(ctx, base);
	// 82EBD9B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD9BC: 40820030  bne 0x82ebd9ec
	if !ctx.cr[0].eq {
	pc = 0x82EBD9EC; continue 'dispatch;
	}
	// 82EBD9C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD9C4: 4BFFDC85  bl 0x82ebb648
	ctx.lr = 0x82EBD9C8;
	sub_82EBB648(ctx, base);
	// 82EBD9C8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD9CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD9D0: 4099E800  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD9D4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD9D8: 4BFFDC71  bl 0x82ebb648
	ctx.lr = 0x82EBD9DC;
	sub_82EBB648(ctx, base);
	// 82EBD9DC: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD9E0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD9E4: 4198FFF0  blt cr6, 0x82ebd9d4
	if ctx.cr[6].lt {
	pc = 0x82EBD9D4; continue 'dispatch;
	}
	// 82EBD9E8: 4BFFE7E8  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBD9EC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD9F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD9F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD9F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD9FC: 4E800421  bctrl
	ctx.lr = 0x82EBDA00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDA00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDA04: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBDA08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBDA0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDA14: 4E800421  bctrl
	ctx.lr = 0x82EBDA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDA18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDA1C: 4182E7B4  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDA20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBDA24: 387A022C  addi r3, r26, 0x22c
	ctx.r[3].s64 = ctx.r[26].s64 + 556;
	// 82EBDA28: 4BFFB869  bl 0x82eb9290
	ctx.lr = 0x82EBDA2C;
	sub_82EB9290(ctx, base);
	// 82EBDA2C: 4BFFE620  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBDA30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDA38: 3BCBA9FC  addi r30, r11, -0x5604
	ctx.r[30].s64 = ctx.r[11].s64 + -22020;
	// 82EBDA3C: 482FE625  bl 0x831bc060
	ctx.lr = 0x82EBDA40;
	sub_831BC060(ctx, base);
	// 82EBDA40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDA44: 4BDEF10D  bl 0x82cacb50
	ctx.lr = 0x82EBDA48;
	sub_82CACB50(ctx, base);
	// 82EBDA48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDA4C: 408200B8  bne 0x82ebdb04
	if !ctx.cr[0].eq {
	pc = 0x82EBDB04; continue 'dispatch;
	}
	// 82EBDA50: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDA54: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDA58: 4182E778  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDA5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDA64: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBDA68: 4BFC64B1  bl 0x82e83f18
	ctx.lr = 0x82EBDA6C;
	sub_82E83F18(ctx, base);
	// 82EBDA6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDA70: 4182000C  beq 0x82ebda7c
	if ctx.cr[0].eq {
	pc = 0x82EBDA7C; continue 'dispatch;
	}
	// 82EBDA74: 4BA50295  bl 0x8290dd08
	ctx.lr = 0x82EBDA78;
	sub_8290DD08(ctx, base);
	// 82EBDA78: 48000008  b 0x82ebda80
	pc = 0x82EBDA80; continue 'dispatch;
	// 82EBDA7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDA80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBDA84: 419AE74C  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDA88: 4BFFE3B9  bl 0x82ebbe40
	ctx.lr = 0x82EBDA8C;
	sub_82EBBE40(ctx, base);
	// 82EBDA8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDA90: 40820030  bne 0x82ebdac0
	if !ctx.cr[0].eq {
	pc = 0x82EBDAC0; continue 'dispatch;
	}
	// 82EBDA94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBDA98: 4BFFDD19  bl 0x82ebb7b0
	ctx.lr = 0x82EBDA9C;
	sub_82EBB7B0(ctx, base);
	// 82EBDA9C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDAA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDAA4: 4099E72C  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDAA8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBDAAC: 4BFFDD05  bl 0x82ebb7b0
	ctx.lr = 0x82EBDAB0;
	sub_82EBB7B0(ctx, base);
	// 82EBDAB0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDAB4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBDAB8: 4198FFF0  blt cr6, 0x82ebdaa8
	if ctx.cr[6].lt {
	pc = 0x82EBDAA8; continue 'dispatch;
	}
	// 82EBDABC: 4BFFE714  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBDAC0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDAC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDAC8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBDACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDAD0: 4E800421  bctrl
	ctx.lr = 0x82EBDAD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDAD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDAD8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBDADC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBDAE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDAE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDAE8: 4E800421  bctrl
	ctx.lr = 0x82EBDAEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDAEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDAF0: 4182E6E0  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDAF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBDAF8: 387A0240  addi r3, r26, 0x240
	ctx.r[3].s64 = ctx.r[26].s64 + 576;
	// 82EBDAFC: 4BFFB795  bl 0x82eb9290
	ctx.lr = 0x82EBDB00;
	sub_82EB9290(ctx, base);
	// 82EBDB00: 4BFFE54C  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBDB04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDB08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDB0C: 3BCBA9F0  addi r30, r11, -0x5610
	ctx.r[30].s64 = ctx.r[11].s64 + -22032;
	// 82EBDB10: 482FE551  bl 0x831bc060
	ctx.lr = 0x82EBDB14;
	sub_831BC060(ctx, base);
	// 82EBDB14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDB18: 4BDEF039  bl 0x82cacb50
	ctx.lr = 0x82EBDB1C;
	sub_82CACB50(ctx, base);
	// 82EBDB1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDB20: 408200B8  bne 0x82ebdbd8
	if !ctx.cr[0].eq {
	pc = 0x82EBDBD8; continue 'dispatch;
	}
	// 82EBDB24: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDB28: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDB2C: 4182E6A4  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDB30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDB38: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBDB3C: 4BFC63DD  bl 0x82e83f18
	ctx.lr = 0x82EBDB40;
	sub_82E83F18(ctx, base);
	// 82EBDB40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDB44: 4182000C  beq 0x82ebdb50
	if ctx.cr[0].eq {
	pc = 0x82EBDB50; continue 'dispatch;
	}
	// 82EBDB48: 4BA501C1  bl 0x8290dd08
	ctx.lr = 0x82EBDB4C;
	sub_8290DD08(ctx, base);
	// 82EBDB4C: 48000008  b 0x82ebdb54
	pc = 0x82EBDB54; continue 'dispatch;
	// 82EBDB50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDB54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBDB58: 419AE678  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDB5C: 4BFFE245  bl 0x82ebbda0
	ctx.lr = 0x82EBDB60;
	sub_82EBBDA0(ctx, base);
	// 82EBDB60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDB64: 40820030  bne 0x82ebdb94
	if !ctx.cr[0].eq {
	pc = 0x82EBDB94; continue 'dispatch;
	}
	// 82EBDB68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBDB6C: 4BFFDBCD  bl 0x82ebb738
	ctx.lr = 0x82EBDB70;
	sub_82EBB738(ctx, base);
	// 82EBDB70: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDB74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDB78: 4099E658  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDB7C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBDB80: 4BFFDBB9  bl 0x82ebb738
	ctx.lr = 0x82EBDB84;
	sub_82EBB738(ctx, base);
	// 82EBDB84: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDB88: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBDB8C: 4198FFF0  blt cr6, 0x82ebdb7c
	if ctx.cr[6].lt {
	pc = 0x82EBDB7C; continue 'dispatch;
	}
	// 82EBDB90: 4BFFE640  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBDB94: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDB98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDB9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBDBA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDBA4: 4E800421  bctrl
	ctx.lr = 0x82EBDBA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDBA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDBAC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBDBB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBDBB4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDBB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDBBC: 4E800421  bctrl
	ctx.lr = 0x82EBDBC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDBC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDBC4: 4182E60C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDBC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBDBCC: 387A0254  addi r3, r26, 0x254
	ctx.r[3].s64 = ctx.r[26].s64 + 596;
	// 82EBDBD0: 4BFFB6C1  bl 0x82eb9290
	ctx.lr = 0x82EBDBD4;
	sub_82EB9290(ctx, base);
	// 82EBDBD4: 4BFFE478  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBDBD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDBDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDBE0: 3BCBA9D8  addi r30, r11, -0x5628
	ctx.r[30].s64 = ctx.r[11].s64 + -22056;
	// 82EBDBE4: 482FE47D  bl 0x831bc060
	ctx.lr = 0x82EBDBE8;
	sub_831BC060(ctx, base);
	// 82EBDBE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDBEC: 4BDEEF65  bl 0x82cacb50
	ctx.lr = 0x82EBDBF0;
	sub_82CACB50(ctx, base);
	// 82EBDBF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDBF4: 4082E5DC  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDBF8: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDBFC: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDC00: 4182E5D0  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDC04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDC08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDC0C: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBDC10: 4BFC6309  bl 0x82e83f18
	ctx.lr = 0x82EBDC14;
	sub_82E83F18(ctx, base);
	// 82EBDC14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDC18: 4182000C  beq 0x82ebdc24
	if ctx.cr[0].eq {
	pc = 0x82EBDC24; continue 'dispatch;
	}
	// 82EBDC1C: 4BA500ED  bl 0x8290dd08
	ctx.lr = 0x82EBDC20;
	sub_8290DD08(ctx, base);
	// 82EBDC20: 48000008  b 0x82ebdc28
	pc = 0x82EBDC28; continue 'dispatch;
	// 82EBDC24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDC28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBDC2C: 419AE5A4  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDC30: 4BFFE2B1  bl 0x82ebbee0
	ctx.lr = 0x82EBDC34;
	sub_82EBBEE0(ctx, base);
	// 82EBDC34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDC38: 40820030  bne 0x82ebdc68
	if !ctx.cr[0].eq {
	pc = 0x82EBDC68; continue 'dispatch;
	}
	// 82EBDC3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBDC40: 4BFFDBE9  bl 0x82ebb828
	ctx.lr = 0x82EBDC44;
	sub_82EBB828(ctx, base);
	// 82EBDC44: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDC48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDC4C: 4099E584  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDC50: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBDC54: 4BFFDBD5  bl 0x82ebb828
	ctx.lr = 0x82EBDC58;
	sub_82EBB828(ctx, base);
	// 82EBDC58: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDC5C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBDC60: 4198FFF0  blt cr6, 0x82ebdc50
	if ctx.cr[6].lt {
	pc = 0x82EBDC50; continue 'dispatch;
	}
	// 82EBDC64: 4BFFE56C  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
	// 82EBDC68: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDC6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDC70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBDC74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDC78: 4E800421  bctrl
	ctx.lr = 0x82EBDC7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDC7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDC80: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBDC84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBDC88: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDC8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDC90: 4E800421  bctrl
	ctx.lr = 0x82EBDC94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDC94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDC98: 4182E538  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDC9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBDCA0: 387A0268  addi r3, r26, 0x268
	ctx.r[3].s64 = ctx.r[26].s64 + 616;
	// 82EBDCA4: 4BFFB5ED  bl 0x82eb9290
	ctx.lr = 0x82EBDCA8;
	sub_82EB9290(ctx, base);
	// 82EBDCA8: 4BFFE3A4  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDCB0 size=84
    let mut pc: u32 = 0x82EBDCB0;
    'dispatch: loop {
        match pc {
            0x82EBDCB0 => {
    //   block [0x82EBDCB0..0x82EBDD04)
	// 82EBDCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDCB4: 4BDEB759  bl 0x82ca940c
	ctx.lr = 0x82EBDCB8;
	sub_82CA93D0(ctx, base);
	// 82EBDCB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDCBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBDCC0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBDCC4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBDCC8: 4B758C61  bl 0x82616928
	ctx.lr = 0x82EBDCCC;
	sub_82616928(ctx, base);
	// 82EBDCCC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBDCD0: 41820028  beq 0x82ebdcf8
	if ctx.cr[0].eq {
	pc = 0x82EBDCF8; continue 'dispatch;
	}
	// 82EBDCD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBDCD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDCDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDCE0: 4BFF7651  bl 0x82eb5330
	ctx.lr = 0x82EBDCE4;
	sub_82EB5330(ctx, base);
	// 82EBDCE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDCEC: 396BA8D8  addi r11, r11, -0x5728
	ctx.r[11].s64 = ctx.r[11].s64 + -22312;
	// 82EBDCF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBDCF4: 48000008  b 0x82ebdcfc
	pc = 0x82EBDCFC; continue 'dispatch;
	// 82EBDCF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDCFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBDD00: 4BDEB75C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDD08 size=276
    let mut pc: u32 = 0x82EBDD08;
    'dispatch: loop {
        match pc {
            0x82EBDD08 => {
    //   block [0x82EBDD08..0x82EBDE1C)
	// 82EBDD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDD0C: 4BDEB6F1  bl 0x82ca93fc
	ctx.lr = 0x82EBDD10;
	sub_82CA93D0(ctx, base);
	// 82EBDD10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDD14: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EBDD18: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDD1C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EBDD20: 388B75C8  addi r4, r11, 0x75c8
	ctx.r[4].s64 = ctx.r[11].s64 + 30152;
	// 82EBDD24: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBDD28: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EBDD2C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82EBDD30: 4BFCB9B1  bl 0x82e896e0
	ctx.lr = 0x82EBDD34;
	sub_82E896E0(ctx, base);
	// 82EBDD34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD38: 418200B4  beq 0x82ebddec
	if ctx.cr[0].eq {
	pc = 0x82EBDDEC; continue 'dispatch;
	}
	// 82EBDD3C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDD40: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDD44: 48015B95  bl 0x82ed38d8
	ctx.lr = 0x82EBDD48;
	sub_82ED38D8(ctx, base);
	// 82EBDD48: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBDD4C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDD50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD54: 4182000C  beq 0x82ebdd60
	if ctx.cr[0].eq {
	pc = 0x82EBDD60; continue 'dispatch;
	}
	// 82EBDD58: 48017CB9  bl 0x82ed5a10
	ctx.lr = 0x82EBDD5C;
	sub_82ED5A10(ctx, base);
	// 82EBDD5C: 48000008  b 0x82ebdd64
	pc = 0x82EBDD64; continue 'dispatch;
	// 82EBDD60: 48017CC1  bl 0x82ed5a20
	ctx.lr = 0x82EBDD64;
	sub_82ED5A20(ctx, base);
	// 82EBDD64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBDD68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD6C: 419A0078  beq cr6, 0x82ebdde4
	if ctx.cr[6].eq {
	pc = 0x82EBDDE4; continue 'dispatch;
	}
	// 82EBDD70: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82EBDD74: 419A0070  beq cr6, 0x82ebdde4
	if ctx.cr[6].eq {
	pc = 0x82EBDDE4; continue 'dispatch;
	}
	// 82EBDD78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDD7C: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82EBDD80: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDD84: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBDD88: 4B3A9E99  bl 0x82267c20
	ctx.lr = 0x82EBDD8C;
	sub_82267C20(ctx, base);
	// 82EBDD8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD90: 4182005C  beq 0x82ebddec
	if ctx.cr[0].eq {
	pc = 0x82EBDDEC; continue 'dispatch;
	}
	// 82EBDD94: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EBDD98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBDD9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EBDDA0: 419A003C  beq cr6, 0x82ebdddc
	if ctx.cr[6].eq {
	pc = 0x82EBDDDC; continue 'dispatch;
	}
	// 82EBDDA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDDA8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDDAC: 48017C0D  bl 0x82ed59b8
	ctx.lr = 0x82EBDDB0;
	sub_82ED59B8(ctx, base);
	// 82EBDDB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EBDDB4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDDB8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDDBC: 48016B55  bl 0x82ed4910
	ctx.lr = 0x82EBDDC0;
	sub_82ED4910(ctx, base);
	// 82EBDDC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDDC4: 40820014  bne 0x82ebddd8
	if !ctx.cr[0].eq {
	pc = 0x82EBDDD8; continue 'dispatch;
	}
	// 82EBDDC8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBDDCC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EBDDD0: 4198FFD4  blt cr6, 0x82ebdda4
	if ctx.cr[6].lt {
	pc = 0x82EBDDA4; continue 'dispatch;
	}
	// 82EBDDD4: 48000008  b 0x82ebdddc
	pc = 0x82EBDDDC; continue 'dispatch;
	// 82EBDDD8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EBDDDC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDDE0: 4082000C  bne 0x82ebddec
	if !ctx.cr[0].eq {
	pc = 0x82EBDDEC; continue 'dispatch;
	}
	// 82EBDDE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDDE8: 4800002C  b 0x82ebde14
	pc = 0x82EBDE14; continue 'dispatch;
	// 82EBDDEC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDDF0: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EBDDF4: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDDF8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EBDDFC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDE00: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBDE04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDE08: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBDE0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDE10: 4E800421  bctrl
	ctx.lr = 0x82EBDE14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDE14: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EBDE18: 4BDEB634  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDE20 size=392
    let mut pc: u32 = 0x82EBDE20;
    'dispatch: loop {
        match pc {
            0x82EBDE20 => {
    //   block [0x82EBDE20..0x82EBDFA8)
	// 82EBDE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDE24: 4BDEB5D5  bl 0x82ca93f8
	ctx.lr = 0x82EBDE28;
	sub_82CA93D0(ctx, base);
	// 82EBDE28: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDE2C: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82EBDE30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBDE34: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EBDE38: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EBDE3C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EBDE40: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDE44: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82EBDE48: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDE4C: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 82EBDE50: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EBDE54: 409A0094  bne cr6, 0x82ebdee8
	if !ctx.cr[6].eq {
	pc = 0x82EBDEE8; continue 'dispatch;
	}
	// 82EBDE58: 57A3003E  slwi r3, r29, 0
	ctx.r[3].u32 = ctx.r[29].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBDE5C: 81630250  lwz r11, 0x250(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBDE60: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EBDE64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDE68: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBDE6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDE70: 4E800421  bctrl
	ctx.lr = 0x82EBDE74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDE74: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDE78: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EBDE7C: 3D4082EC  lis r10, -0x7d14
	ctx.r[10].s64 = -2098462720;
	// 82EBDE80: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EBDE84: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EBDE88: 38AADD08  addi r5, r10, -0x22f8
	ctx.r[5].s64 = ctx.r[10].s64 + -8952;
	// 82EBDE8C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EBDE90: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDE94: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EBDE98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EBDE9C: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82EBDEA0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EBDEA4: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82EBDEA8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EBDEAC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EBDEB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBDEB4: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBDEB8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EBDEBC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBDEC0: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82EBDEC4: 9B410080  stb r26, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u8 ) };
	// 82EBDEC8: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82EBDECC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBDED0: 48017661  bl 0x82ed5530
	ctx.lr = 0x82EBDED4;
	sub_82ED5530(ctx, base);
	// 82EBDED4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDED8: 40820034  bne 0x82ebdf0c
	if !ctx.cr[0].eq {
	pc = 0x82EBDF0C; continue 'dispatch;
	}
	// 82EBDEDC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDEE0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EBDEE4: 419A00B8  beq cr6, 0x82ebdf9c
	if ctx.cr[6].eq {
	pc = 0x82EBDF9C; continue 'dispatch;
	}
	// 82EBDEE8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDEEC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBDEF0: 388B75C8  addi r4, r11, 0x75c8
	ctx.r[4].s64 = ctx.r[11].s64 + 30152;
	// 82EBDEF4: 4BFCB7ED  bl 0x82e896e0
	ctx.lr = 0x82EBDEF8;
	sub_82E896E0(ctx, base);
	// 82EBDEF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDEFC: 41820018  beq 0x82ebdf14
	if ctx.cr[0].eq {
	pc = 0x82EBDF14; continue 'dispatch;
	}
	// 82EBDF00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF04: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBDF08: 48000094  b 0x82ebdf9c
	pc = 0x82EBDF9C; continue 'dispatch;
	// 82EBDF0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDF10: 48000090  b 0x82ebdfa0
	pc = 0x82EBDFA0; continue 'dispatch;
	// 82EBDF14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF18: 81630250  lwz r11, 0x250(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBDF1C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EBDF20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDF24: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBDF28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDF2C: 4E800421  bctrl
	ctx.lr = 0x82EBDF30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDF30: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF34: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EBDF38: 3D4082EC  lis r10, -0x7d14
	ctx.r[10].s64 = -2098462720;
	// 82EBDF3C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EBDF40: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EBDF44: 38AADD08  addi r5, r10, -0x22f8
	ctx.r[5].s64 = ctx.r[10].s64 + -8952;
	// 82EBDF48: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBDF4C: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EBDF54: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EBDF58: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82EBDF5C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EBDF60: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82EBDF64: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EBDF68: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EBDF6C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBDF70: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBDF74: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBDF78: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EBDF7C: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82EBDF80: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82EBDF84: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82EBDF88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBDF8C: 480175A5  bl 0x82ed5530
	ctx.lr = 0x82EBDF90;
	sub_82ED5530(ctx, base);
	// 82EBDF90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDF94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDF98: 40820008  bne 0x82ebdfa0
	if !ctx.cr[0].eq {
	pc = 0x82EBDFA0; continue 'dispatch;
	}
	// 82EBDF9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBDFA0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EBDFA4: 4BDEB4A4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBDFA8 size=12
    let mut pc: u32 = 0x82EBDFA8;
    'dispatch: loop {
        match pc {
            0x82EBDFA8 => {
    //   block [0x82EBDFA8..0x82EBDFB4)
	// 82EBDFA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBDFAC: 386BCCDC  addi r3, r11, -0x3324
	ctx.r[3].s64 = ctx.r[11].s64 + -13092;
	// 82EBDFB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDFB8 size=84
    let mut pc: u32 = 0x82EBDFB8;
    'dispatch: loop {
        match pc {
            0x82EBDFB8 => {
    //   block [0x82EBDFB8..0x82EBE00C)
	// 82EBDFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDFBC: 4BDEB451  bl 0x82ca940c
	ctx.lr = 0x82EBDFC0;
	sub_82CA93D0(ctx, base);
	// 82EBDFC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDFC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBDFC8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBDFCC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBDFD0: 4B758959  bl 0x82616928
	ctx.lr = 0x82EBDFD4;
	sub_82616928(ctx, base);
	// 82EBDFD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBDFD8: 41820028  beq 0x82ebe000
	if ctx.cr[0].eq {
	pc = 0x82EBE000; continue 'dispatch;
	}
	// 82EBDFDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBDFE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDFE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDFE8: 4BFF7349  bl 0x82eb5330
	ctx.lr = 0x82EBDFEC;
	sub_82EB5330(ctx, base);
	// 82EBDFEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDFF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDFF4: 396BAD3C  addi r11, r11, -0x52c4
	ctx.r[11].s64 = ctx.r[11].s64 + -21188;
	// 82EBDFF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBDFFC: 48000008  b 0x82ebe004
	pc = 0x82EBE004; continue 'dispatch;
	// 82EBE000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE004: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE008: 4BDEB454  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE010 size=4
    let mut pc: u32 = 0x82EBE010;
    'dispatch: loop {
        match pc {
            0x82EBE010 => {
    //   block [0x82EBE010..0x82EBE014)
	// 82EBE010: 4BFF7410  b 0x82eb5420
	sub_82EB5420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE018 size=424
    let mut pc: u32 = 0x82EBE018;
    'dispatch: loop {
        match pc {
            0x82EBE018 => {
    //   block [0x82EBE018..0x82EBE1C0)
	// 82EBE018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE01C: 4BDEB3E5  bl 0x82ca9400
	ctx.lr = 0x82EBE020;
	sub_82CA93D0(ctx, base);
	// 82EBE020: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EBE024: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE028: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EBE02C: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82EBE030: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE034: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE038: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EBE03C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBE040: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82EBE044: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82EBE048: 4B32A631  bl 0x821e8678
	ctx.lr = 0x82EBE04C;
	sub_821E8678(ctx, base);
	// 82EBE04C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE050: 41820160  beq 0x82ebe1b0
	if ctx.cr[0].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE054: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE058: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE05C: 41820154  beq 0x82ebe1b0
	if ctx.cr[0].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE060: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE064: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE068: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82EBE06C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE070: 4BFBF651  bl 0x82e7d6c0
	ctx.lr = 0x82EBE074;
	sub_82E7D6C0(ctx, base);
	// 82EBE074: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE078: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE07C: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 82EBE080: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE088: 4BFBF639  bl 0x82e7d6c0
	ctx.lr = 0x82EBE08C;
	sub_82E7D6C0(ctx, base);
	// 82EBE08C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE090: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBE094: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82EBE098: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE0A0: 4BFBF621  bl 0x82e7d6c0
	ctx.lr = 0x82EBE0A4;
	sub_82E7D6C0(ctx, base);
	// 82EBE0A4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EBE0A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EBE0AC: 419A0104  beq cr6, 0x82ebe1b0
	if ctx.cr[6].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE0B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EBE0B4: 419A00FC  beq cr6, 0x82ebe1b0
	if ctx.cr[6].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE0B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EBE0BC: 419A00F4  beq cr6, 0x82ebe1b0
	if ctx.cr[6].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE0C0: C01B0038  lfs f0, 0x38(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE0C8: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE0CC: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE0D0: C01B003C  lfs f0, 0x3c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0D4: C19A000C  lfs f12, 0xc(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE0D8: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE0DC: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0E0: C17B0034  lfs f11, 0x34(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE0E4: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBE0E8: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBE0EC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE0F0: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE0F4: ED40002C  fsqrts f10, f0
	ctx.f[10].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBE0F8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0FC: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82EBE100: 409A000C  bne cr6, 0x82ebe10c
	if !ctx.cr[6].eq {
	pc = 0x82EBE10C; continue 'dispatch;
	}
	// 82EBE104: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE108: 480000AC  b 0x82ebe1b4
	pc = 0x82EBE1B4; continue 'dispatch;
	// 82EBE10C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE110: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBE114: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBE118: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE11C: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EBE120: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBE124: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBE128: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBE12C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBE130: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBE134: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBE138: 4BFC7C31  bl 0x82e85d68
	ctx.lr = 0x82EBE13C;
	sub_82E85D68(ctx, base);
	// 82EBE13C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EBE140: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82EBE144: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE148: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE14C: 9BFC0004  stb r31, 4(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EBE150: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE154: C00B0ED4  lfs f0, 0xed4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE158: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE15C: 4B37BD55  bl 0x82239eb0
	ctx.lr = 0x82EBE160;
	sub_82239EB0(ctx, base);
	// 82EBE160: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE164: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBE168: 9BFE0004  stb r31, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EBE16C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE170: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EBE174: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE178: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE17C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE180: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE184: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBE188: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE18C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE190: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE194: C1410050  lfs f10, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBE198: 9BFD0004  stb r31, 4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EBE19C: EC0C583A  fmadds f0, f12, f0, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EBE1A0: EC0D02BA  fmadds f0, f13, f10, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE1A4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE1A8: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE1AC: 48000008  b 0x82ebe1b4
	pc = 0x82EBE1B4; continue 'dispatch;
	// 82EBE1B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE1B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EBE1B8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EBE1BC: 4BDEB294  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBE1C0 size=88
    let mut pc: u32 = 0x82EBE1C0;
    'dispatch: loop {
        match pc {
            0x82EBE1C0 => {
    //   block [0x82EBE1C0..0x82EBE218)
	// 82EBE1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBE1C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBE1CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBE1D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE1D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBE1D8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82EBE1DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBE1E0: 4B758749  bl 0x82616928
	ctx.lr = 0x82EBE1E4;
	sub_82616928(ctx, base);
	// 82EBE1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE1E8: 41820014  beq 0x82ebe1fc
	if ctx.cr[0].eq {
	pc = 0x82EBE1FC; continue 'dispatch;
	}
	// 82EBE1EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBE1F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBE1F4: 4BFF755D  bl 0x82eb5750
	ctx.lr = 0x82EBE1F8;
	sub_82EB5750(ctx, base);
	// 82EBE1F8: 48000008  b 0x82ebe200
	pc = 0x82EBE200; continue 'dispatch;
	// 82EBE1FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE200: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE204: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBE208: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBE20C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBE210: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBE214: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE218 size=360
    let mut pc: u32 = 0x82EBE218;
    'dispatch: loop {
        match pc {
            0x82EBE218 => {
    //   block [0x82EBE218..0x82EBE380)
	// 82EBE218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE21C: 4BDEB1F1  bl 0x82ca940c
	ctx.lr = 0x82EBE220;
	sub_82CA93D0(ctx, base);
	// 82EBE220: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBE224: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE228: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBE22C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE230: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBE234: 482FDE2D  bl 0x831bc060
	ctx.lr = 0x82EBE238;
	sub_831BC060(ctx, base);
	// 82EBE238: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBE23C: 4182012C  beq 0x82ebe368
	if ctx.cr[0].eq {
	pc = 0x82EBE368; continue 'dispatch;
	}
	// 82EBE240: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE248: 388BAD78  addi r4, r11, -0x5288
	ctx.r[4].s64 = ctx.r[11].s64 + -21128;
	// 82EBE24C: 4BDEE905  bl 0x82cacb50
	ctx.lr = 0x82EBE250;
	sub_82CACB50(ctx, base);
	// 82EBE250: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE254: 40820064  bne 0x82ebe2b8
	if !ctx.cr[0].eq {
	pc = 0x82EBE2B8; continue 'dispatch;
	}
	// 82EBE258: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE25C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBE260: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE264: 4182000C  beq 0x82ebe270
	if ctx.cr[0].eq {
	pc = 0x82EBE270; continue 'dispatch;
	}
	// 82EBE268: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE26C: 4800000C  b 0x82ebe278
	pc = 0x82EBE278; continue 'dispatch;
	// 82EBE270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE274: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE278: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBE27C: 4BA4FA8D  bl 0x8290dd08
	ctx.lr = 0x82EBE280;
	sub_8290DD08(ctx, base);
	// 82EBE280: 4BDED931  bl 0x82cabbb0
	ctx.lr = 0x82EBE284;
	sub_82CABBB0(ctx, base);
	// 82EBE284: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE288: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE28C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE290: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE294: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE298: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBE29C: 41980008  blt cr6, 0x82ebe2a4
	if ctx.cr[6].lt {
	pc = 0x82EBE2A4; continue 'dispatch;
	}
	// 82EBE2A0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBE2A4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBE2A8: 409AFFF0  bne cr6, 0x82ebe298
	if !ctx.cr[6].eq {
	pc = 0x82EBE298; continue 'dispatch;
	}
	// 82EBE2AC: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBE2B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE2B4: 480000C0  b 0x82ebe374
	pc = 0x82EBE374; continue 'dispatch;
	// 82EBE2B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE2C0: 388BAD6C  addi r4, r11, -0x5294
	ctx.r[4].s64 = ctx.r[11].s64 + -21140;
	// 82EBE2C4: 4BDEE88D  bl 0x82cacb50
	ctx.lr = 0x82EBE2C8;
	sub_82CACB50(ctx, base);
	// 82EBE2C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE2CC: 4082009C  bne 0x82ebe368
	if !ctx.cr[0].eq {
	pc = 0x82EBE368; continue 'dispatch;
	}
	// 82EBE2D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBE2D4: 4BA4FA35  bl 0x8290dd08
	ctx.lr = 0x82EBE2D8;
	sub_8290DD08(ctx, base);
	// 82EBE2D8: 4BDED8D9  bl 0x82cabbb0
	ctx.lr = 0x82EBE2DC;
	sub_82CABBB0(ctx, base);
	// 82EBE2DC: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE2E0: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE2E4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82EBE2E8: 4B3A2659  bl 0x82260940
	ctx.lr = 0x82EBE2EC;
	sub_82260940(ctx, base);
	// 82EBE2EC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBE2F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE2F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBE2F8: C1ABDF6C  lfs f13, -0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE2FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE300: C16A0A44  lfs f11, 0xa44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2628 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE304: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EBE308: C18B89C8  lfs f12, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE30C: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE310: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 82EBE314: 41980010  blt cr6, 0x82ebe324
	if ctx.cr[6].lt {
	pc = 0x82EBE324; continue 'dispatch;
	}
	// 82EBE318: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82EBE31C: 41990008  bgt cr6, 0x82ebe324
	if ctx.cr[6].gt {
	pc = 0x82EBE324; continue 'dispatch;
	}
	// 82EBE320: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EBE324: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBE328: 409AFFE8  bne cr6, 0x82ebe310
	if !ctx.cr[6].eq {
	pc = 0x82EBE310; continue 'dispatch;
	}
	// 82EBE32C: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE330: EC2D07F2  fmuls f1, f13, f31
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE334: 4B37BB7D  bl 0x82239eb0
	ctx.lr = 0x82EBE338;
	sub_82239EB0(ctx, base);
	// 82EBE338: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE33C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE340: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE344: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE348: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE34C: 41990014  bgt cr6, 0x82ebe360
	if ctx.cr[6].gt {
	pc = 0x82EBE360; continue 'dispatch;
	}
	// 82EBE350: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE354: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE358: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE35C: 4098FF54  bge cr6, 0x82ebe2b0
	if !ctx.cr[6].lt {
	pc = 0x82EBE2B0; continue 'dispatch;
	}
	// 82EBE360: D1BE0010  stfs f13, 0x10(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE364: 4BFFFF4C  b 0x82ebe2b0
	pc = 0x82EBE2B0; continue 'dispatch;
	// 82EBE368: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE36C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBE370: 4BFF70B1  bl 0x82eb5420
	ctx.lr = 0x82EBE374;
	sub_82EB5420(ctx, base);
	// 82EBE374: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBE378: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBE37C: 4BDEB0E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE380 size=12
    let mut pc: u32 = 0x82EBE380;
    'dispatch: loop {
        match pc {
            0x82EBE380 => {
    //   block [0x82EBE380..0x82EBE38C)
	// 82EBE380: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE384: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EBE388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE390 size=808
    let mut pc: u32 = 0x82EBE390;
    'dispatch: loop {
        match pc {
            0x82EBE390 => {
    //   block [0x82EBE390..0x82EBE6B8)
	// 82EBE390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE394: 4BDEB071  bl 0x82ca9404
	ctx.lr = 0x82EBE398;
	sub_82CA93D0(ctx, base);
	// 82EBE398: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EBE39C: 4BDEF935  bl 0x82cadcd0
	ctx.lr = 0x82EBE3A0;
	sub_82CADCA0(ctx, base);
	// 82EBE3A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE3A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBE3A8: C1A60004  lfs f13, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBE3B0: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82EBE3B4: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 82EBE3B8: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EBE3BC: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE3C0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBE3C4: 409A0028  bne cr6, 0x82ebe3ec
	if !ctx.cr[6].eq {
	pc = 0x82EBE3EC; continue 'dispatch;
	}
	// 82EBE3C8: C0060008  lfs f0, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE3CC: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE3D4: 409A0018  bne cr6, 0x82ebe3ec
	if !ctx.cr[6].eq {
	pc = 0x82EBE3EC; continue 'dispatch;
	}
	// 82EBE3D8: C006000C  lfs f0, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE3DC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EBE3E0: C1BE003C  lfs f13, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE3E8: 419A0008  beq cr6, 0x82ebe3f0
	if ctx.cr[6].eq {
	pc = 0x82EBE3F0; continue 'dispatch;
	}
	// 82EBE3EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE3F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBE3F4: 408202B0  bne 0x82ebe6a4
	if !ctx.cr[0].eq {
	pc = 0x82EBE6A4; continue 'dispatch;
	}
	// 82EBE3F8: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE400: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE404: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBE408: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE40C: C186000C  lfs f12, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE410: C1BE003C  lfs f13, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE414: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EBE418: C38B0C18  lfs f28, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EBE41C: D3810054  stfs f28, 0x54(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBE420: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE424: EC0C6828  fsubs f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBE428: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE42C: C19E0034  lfs f12, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE430: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBE434: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBE438: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBE43C: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EBE440: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE444: EFC0002C  fsqrts f30, f0
	ctx.f[30].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBE448: 4BFC7921  bl 0x82e85d68
	ctx.lr = 0x82EBE44C;
	sub_82E85D68(ctx, base);
	// 82EBE44C: C1A10084  lfs f13, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE450: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE454: C01E0044  lfs f0, 0x44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE458: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE45C: FF406890  fmr f26, f13
	ctx.f[26].f64 = ctx.f[13].f64;
	// 82EBE460: C1AB0A44  lfs f13, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE464: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE468: 40990014  ble cr6, 0x82ebe47c
	if !ctx.cr[6].gt {
	pc = 0x82EBE47C; continue 'dispatch;
	}
	// 82EBE46C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE470: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE474: EFA06828  fsubs f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBE478: 48000028  b 0x82ebe4a0
	pc = 0x82EBE4A0; continue 'dispatch;
	// 82EBE47C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE480: C1AB89C8  lfs f13, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE484: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE488: 40980014  bge cr6, 0x82ebe49c
	if !ctx.cr[6].lt {
	pc = 0x82EBE49C; continue 'dispatch;
	}
	// 82EBE48C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE490: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE494: EFA0682A  fadds f29, f0, f13
	ctx.f[29].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBE498: 48000008  b 0x82ebe4a0
	pc = 0x82EBE4A0; continue 'dispatch;
	// 82EBE49C: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	// 82EBE4A0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBE4A4: C00BDF6C  lfs f0, -0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE4A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE4AC: EDA00772  fmuls f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EBE4B0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE4B4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE4B8: 4B37B9F9  bl 0x82239eb0
	ctx.lr = 0x82EBE4BC;
	sub_82239EB0(ctx, base);
	// 82EBE4BC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE4C0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE4C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE4C8: 388BC904  addi r4, r11, -0x36fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14076;
	// 82EBE4CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE4D0: EF6007F2  fmuls f27, f0, f31
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE4D4: 4BFBF1ED  bl 0x82e7d6c0
	ctx.lr = 0x82EBE4D8;
	sub_82E7D6C0(ctx, base);
	// 82EBE4D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBE4DC: 418200F4  beq 0x82ebe5d0
	if ctx.cr[0].eq {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE4E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE4E4: 895D0014  lbz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBE4E8: C1BD000C  lfs f13, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE4EC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE4F0: C00B0C80  lfs f0, 0xc80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE4F4: 41820008  beq 0x82ebe4fc
	if ctx.cr[0].eq {
	pc = 0x82EBE4FC; continue 'dispatch;
	}
	// 82EBE4F8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE4FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBE500: 419A0010  beq cr6, 0x82ebe510
	if ctx.cr[6].eq {
	pc = 0x82EBE510; continue 'dispatch;
	}
	// 82EBE504: C19D0010  lfs f12, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE508: EFEC0032  fmuls f31, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE50C: 48000008  b 0x82ebe514
	pc = 0x82EBE514; continue 'dispatch;
	// 82EBE510: C3FD0010  lfs f31, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE514: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE518: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 82EBE51C: 997D0014  stb r11, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EBE520: 409900B0  ble cr6, 0x82ebe5d0
	if !ctx.cr[6].gt {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE524: FF1E6800  fcmpu cr6, f30, f13
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[13].f64);
	// 82EBE528: 409800A8  bge cr6, 0x82ebe5d0
	if !ctx.cr[6].lt {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE52C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE530: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE534: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EBE538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBE53C: 4B32A13D  bl 0x821e8678
	ctx.lr = 0x82EBE540;
	sub_821E8678(ctx, base);
	// 82EBE540: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE544: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EBE548: 40820008  bne 0x82ebe550
	if !ctx.cr[0].eq {
	pc = 0x82EBE550; continue 'dispatch;
	}
	// 82EBE54C: 397E004C  addi r11, r30, 0x4c
	ctx.r[11].s64 = ctx.r[30].s64 + 76;
	// 82EBE550: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE554: ED7F07B2  fmuls f11, f31, f30
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EBE558: C1410050  lfs f10, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBE55C: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBE560: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE564: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE568: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE56C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBE570: 40980060  bge cr6, 0x82ebe5d0
	if !ctx.cr[6].lt {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE574: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE578: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EBE57C: 9B7D0014  stb r27, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82EBE580: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE584: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE588: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EBE58C: C1AB03B0  lfs f13, 0x3b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(944 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE590: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE594: C18B03AC  lfs f12, 0x3ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(940 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE598: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE59C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBE5A0: C18B03A8  lfs f12, 0x3a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(936 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE5A4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBE5A8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EBE5AC: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EBE5B0: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EBE5B4: 4BFC77B5  bl 0x82e85d68
	ctx.lr = 0x82EBE5B8;
	sub_82E85D68(ctx, base);
	// 82EBE5B8: C0010074  lfs f0, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE5BC: 9B7F0004  stb r27, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE5C0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBE5C4: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE5C8: 9B7F0004  stb r27, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE5CC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE5D0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE5D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE5D8: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82EBE5DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE5E0: 4BFBF0E1  bl 0x82e7d6c0
	ctx.lr = 0x82EBE5E4;
	sub_82E7D6C0(ctx, base);
	// 82EBE5E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBE5E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE5EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE5F0: C3CA0EE0  lfs f30, 0xee0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3808 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBE5F4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE5F8: 40820044  bne 0x82ebe63c
	if !ctx.cr[0].eq {
	pc = 0x82EBE63C; continue 'dispatch;
	}
	// 82EBE5FC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE600: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE604: 388BCB2C  addi r4, r11, -0x34d4
	ctx.r[4].s64 = ctx.r[11].s64 + -13524;
	// 82EBE608: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE60C: 4BFBF0B5  bl 0x82e7d6c0
	ctx.lr = 0x82EBE610;
	sub_82E7D6C0(ctx, base);
	// 82EBE610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE614: 4082000C  bne 0x82ebe620
	if !ctx.cr[0].eq {
	pc = 0x82EBE620; continue 'dispatch;
	}
	// 82EBE618: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE61C: 4800008C  b 0x82ebe6a8
	pc = 0x82EBE6A8; continue 'dispatch;
	// 82EBE620: FF1DE000  fcmpu cr6, f29, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[28].f64);
	// 82EBE624: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE628: 4099000C  ble cr6, 0x82ebe634
	if !ctx.cr[6].gt {
	pc = 0x82EBE634; continue 'dispatch;
	}
	// 82EBE62C: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE630: 48000014  b 0x82ebe644
	pc = 0x82EBE644; continue 'dispatch;
	// 82EBE634: D3C30008  stfs f30, 8(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE638: 4800000C  b 0x82ebe644
	pc = 0x82EBE644; continue 'dispatch;
	// 82EBE63C: D3430008  stfs f26, 8(r3)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE640: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE644: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE648: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE64C: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82EBE650: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE654: 4BFBF06D  bl 0x82e7d6c0
	ctx.lr = 0x82EBE658;
	sub_82E7D6C0(ctx, base);
	// 82EBE658: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE65C: 40820040  bne 0x82ebe69c
	if !ctx.cr[0].eq {
	pc = 0x82EBE69C; continue 'dispatch;
	}
	// 82EBE660: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE664: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE668: 388BCF7C  addi r4, r11, -0x3084
	ctx.r[4].s64 = ctx.r[11].s64 + -12420;
	// 82EBE66C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE670: 4BFBF051  bl 0x82e7d6c0
	ctx.lr = 0x82EBE674;
	sub_82E7D6C0(ctx, base);
	// 82EBE674: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE678: 4182FFA0  beq 0x82ebe618
	if ctx.cr[0].eq {
	pc = 0x82EBE618; continue 'dispatch;
	}
	// 82EBE67C: C01E0058  lfs f0, 0x58(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE680: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE684: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EBE688: 4099000C  ble cr6, 0x82ebe694
	if !ctx.cr[6].gt {
	pc = 0x82EBE694; continue 'dispatch;
	}
	// 82EBE68C: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE690: 48000014  b 0x82ebe6a4
	pc = 0x82EBE6A4; continue 'dispatch;
	// 82EBE694: D3C30008  stfs f30, 8(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE698: 4800000C  b 0x82ebe6a4
	pc = 0x82EBE6A4; continue 'dispatch;
	// 82EBE69C: D3630008  stfs f27, 8(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE6A0: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE6A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE6A8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EBE6AC: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EBE6B0: 4BDEF66D  bl 0x82cadd1c
	ctx.lr = 0x82EBE6B4;
	sub_82CADCEC(ctx, base);
	// 82EBE6B4: 4BDEADA0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE6B8 size=24
    let mut pc: u32 = 0x82EBE6B8;
    'dispatch: loop {
        match pc {
            0x82EBE6B8 => {
    //   block [0x82EBE6B8..0x82EBE6D0)
	// 82EBE6B8: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82EBE6BC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82EBE6C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBE6C4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBE6C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBE6CC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE6D0 size=12
    let mut pc: u32 = 0x82EBE6D0;
    'dispatch: loop {
        match pc {
            0x82EBE6D0 => {
    //   block [0x82EBE6D0..0x82EBE6DC)
	// 82EBE6D0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBE6D4: 386BCF04  addi r3, r11, -0x30fc
	ctx.r[3].s64 = ctx.r[11].s64 + -12540;
	// 82EBE6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBE6E0 size=84
    let mut pc: u32 = 0x82EBE6E0;
    'dispatch: loop {
        match pc {
            0x82EBE6E0 => {
    //   block [0x82EBE6E0..0x82EBE734)
	// 82EBE6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE6E4: 4BDEAD29  bl 0x82ca940c
	ctx.lr = 0x82EBE6E8;
	sub_82CA93D0(ctx, base);
	// 82EBE6E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE6EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE6F0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBE6F4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBE6F8: 4B758231  bl 0x82616928
	ctx.lr = 0x82EBE6FC;
	sub_82616928(ctx, base);
	// 82EBE6FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBE700: 41820028  beq 0x82ebe728
	if ctx.cr[0].eq {
	pc = 0x82EBE728; continue 'dispatch;
	}
	// 82EBE704: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBE708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBE70C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE710: 4BFF6C21  bl 0x82eb5330
	ctx.lr = 0x82EBE714;
	sub_82EB5330(ctx, base);
	// 82EBE714: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE71C: 396BADA4  addi r11, r11, -0x525c
	ctx.r[11].s64 = ctx.r[11].s64 + -21084;
	// 82EBE720: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBE724: 48000008  b 0x82ebe72c
	pc = 0x82EBE72C; continue 'dispatch;
	// 82EBE728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE72C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE730: 4BDEAD2C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE738 size=4
    let mut pc: u32 = 0x82EBE738;
    'dispatch: loop {
        match pc {
            0x82EBE738 => {
    //   block [0x82EBE738..0x82EBE73C)
	// 82EBE738: 48005940  b 0x82ec4078
	sub_82EC4078(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBE740 size=52
    let mut pc: u32 = 0x82EBE740;
    'dispatch: loop {
        match pc {
            0x82EBE740 => {
    //   block [0x82EBE740..0x82EBE774)
	// 82EBE740: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE744: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82EBE748: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82EBE74C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EBE750: C02B0010  lfs f1, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EBE754: 806B0264  lwz r3, 0x264(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBE758: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE75C: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82EBE760: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBE764: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBE768: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBE76C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBE770: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE778 size=448
    let mut pc: u32 = 0x82EBE778;
    'dispatch: loop {
        match pc {
            0x82EBE778 => {
    //   block [0x82EBE778..0x82EBE938)
	// 82EBE778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE77C: 4BDEAC91  bl 0x82ca940c
	ctx.lr = 0x82EBE780;
	sub_82CA93D0(ctx, base);
	// 82EBE780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE784: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBE788: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE78C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE794: 3BABAE40  addi r29, r11, -0x51c0
	ctx.r[29].s64 = ctx.r[11].s64 + -20928;
	// 82EBE798: 482FD8C9  bl 0x831bc060
	ctx.lr = 0x82EBE79C;
	sub_831BC060(ctx, base);
	// 82EBE79C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE7A0: 4BDEE3B1  bl 0x82cacb50
	ctx.lr = 0x82EBE7A4;
	sub_82CACB50(ctx, base);
	// 82EBE7A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE7AC: 4082001C  bne 0x82ebe7c8
	if !ctx.cr[0].eq {
	pc = 0x82EBE7C8; continue 'dispatch;
	}
	// 82EBE7B0: 4BA4F559  bl 0x8290dd08
	ctx.lr = 0x82EBE7B4;
	sub_8290DD08(ctx, base);
	// 82EBE7B4: 4BDED3FD  bl 0x82cabbb0
	ctx.lr = 0x82EBE7B8;
	sub_82CABBB0(ctx, base);
	// 82EBE7B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE7BC: D01E00D8  stfs f0, 0xd8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EBE7C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE7C4: 4800016C  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
	// 82EBE7C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE7CC: 3BABAE30  addi r29, r11, -0x51d0
	ctx.r[29].s64 = ctx.r[11].s64 + -20944;
	// 82EBE7D0: 482FD891  bl 0x831bc060
	ctx.lr = 0x82EBE7D4;
	sub_831BC060(ctx, base);
	// 82EBE7D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE7D8: 4BDEE379  bl 0x82cacb50
	ctx.lr = 0x82EBE7DC;
	sub_82CACB50(ctx, base);
	// 82EBE7DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE7E4: 4082001C  bne 0x82ebe800
	if !ctx.cr[0].eq {
	pc = 0x82EBE800; continue 'dispatch;
	}
	// 82EBE7E8: 4BA4F521  bl 0x8290dd08
	ctx.lr = 0x82EBE7EC;
	sub_8290DD08(ctx, base);
	// 82EBE7EC: 4BDED3C5  bl 0x82cabbb0
	ctx.lr = 0x82EBE7F0;
	sub_82CABBB0(ctx, base);
	// 82EBE7F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE7F4: D01E00D4  stfs f0, 0xd4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EBE7F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE7FC: 48000134  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
	// 82EBE800: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE804: 3BABAE20  addi r29, r11, -0x51e0
	ctx.r[29].s64 = ctx.r[11].s64 + -20960;
	// 82EBE808: 482FD859  bl 0x831bc060
	ctx.lr = 0x82EBE80C;
	sub_831BC060(ctx, base);
	// 82EBE80C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE810: 4BDEE341  bl 0x82cacb50
	ctx.lr = 0x82EBE814;
	sub_82CACB50(ctx, base);
	// 82EBE814: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE81C: 4082001C  bne 0x82ebe838
	if !ctx.cr[0].eq {
	pc = 0x82EBE838; continue 'dispatch;
	}
	// 82EBE820: 4BA4F4E9  bl 0x8290dd08
	ctx.lr = 0x82EBE824;
	sub_8290DD08(ctx, base);
	// 82EBE824: 4BDED38D  bl 0x82cabbb0
	ctx.lr = 0x82EBE828;
	sub_82CABBB0(ctx, base);
	// 82EBE828: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE82C: D01E00DC  stfs f0, 0xdc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EBE830: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE834: 480000FC  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
	// 82EBE838: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE83C: 3BABAE10  addi r29, r11, -0x51f0
	ctx.r[29].s64 = ctx.r[11].s64 + -20976;
	// 82EBE840: 482FD821  bl 0x831bc060
	ctx.lr = 0x82EBE844;
	sub_831BC060(ctx, base);
	// 82EBE844: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE848: 4BDEE309  bl 0x82cacb50
	ctx.lr = 0x82EBE84C;
	sub_82CACB50(ctx, base);
	// 82EBE84C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE854: 4082001C  bne 0x82ebe870
	if !ctx.cr[0].eq {
	pc = 0x82EBE870; continue 'dispatch;
	}
	// 82EBE858: 4BA4F4B1  bl 0x8290dd08
	ctx.lr = 0x82EBE85C;
	sub_8290DD08(ctx, base);
	// 82EBE85C: 4BDED355  bl 0x82cabbb0
	ctx.lr = 0x82EBE860;
	sub_82CABBB0(ctx, base);
	// 82EBE860: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE864: D01E00E0  stfs f0, 0xe0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EBE868: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE86C: 480000C4  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
	// 82EBE870: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE874: 3BABAE00  addi r29, r11, -0x5200
	ctx.r[29].s64 = ctx.r[11].s64 + -20992;
	// 82EBE878: 482FD7E9  bl 0x831bc060
	ctx.lr = 0x82EBE87C;
	sub_831BC060(ctx, base);
	// 82EBE87C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE880: 4BDEE2D1  bl 0x82cacb50
	ctx.lr = 0x82EBE884;
	sub_82CACB50(ctx, base);
	// 82EBE884: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE88C: 4082001C  bne 0x82ebe8a8
	if !ctx.cr[0].eq {
	pc = 0x82EBE8A8; continue 'dispatch;
	}
	// 82EBE890: 4BA4F479  bl 0x8290dd08
	ctx.lr = 0x82EBE894;
	sub_8290DD08(ctx, base);
	// 82EBE894: 4BDED31D  bl 0x82cabbb0
	ctx.lr = 0x82EBE898;
	sub_82CABBB0(ctx, base);
	// 82EBE898: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE89C: D01E00E4  stfs f0, 0xe4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EBE8A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE8A4: 4800008C  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
	// 82EBE8A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE8AC: 3BABADEC  addi r29, r11, -0x5214
	ctx.r[29].s64 = ctx.r[11].s64 + -21012;
	// 82EBE8B0: 482FD7B1  bl 0x831bc060
	ctx.lr = 0x82EBE8B4;
	sub_831BC060(ctx, base);
	// 82EBE8B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE8B8: 4BDEE299  bl 0x82cacb50
	ctx.lr = 0x82EBE8BC;
	sub_82CACB50(ctx, base);
	// 82EBE8BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE8C4: 4082001C  bne 0x82ebe8e0
	if !ctx.cr[0].eq {
	pc = 0x82EBE8E0; continue 'dispatch;
	}
	// 82EBE8C8: 4BA4F441  bl 0x8290dd08
	ctx.lr = 0x82EBE8CC;
	sub_8290DD08(ctx, base);
	// 82EBE8CC: 4BDED2E5  bl 0x82cabbb0
	ctx.lr = 0x82EBE8D0;
	sub_82CABBB0(ctx, base);
	// 82EBE8D0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE8D4: D01E00E8  stfs f0, 0xe8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EBE8D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE8DC: 48000054  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
	// 82EBE8E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE8E4: 3BABADD4  addi r29, r11, -0x522c
	ctx.r[29].s64 = ctx.r[11].s64 + -21036;
	// 82EBE8E8: 482FD779  bl 0x831bc060
	ctx.lr = 0x82EBE8EC;
	sub_831BC060(ctx, base);
	// 82EBE8EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE8F0: 4BDEE261  bl 0x82cacb50
	ctx.lr = 0x82EBE8F4;
	sub_82CACB50(ctx, base);
	// 82EBE8F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE8F8: 4082002C  bne 0x82ebe924
	if !ctx.cr[0].eq {
	pc = 0x82EBE924; continue 'dispatch;
	}
	// 82EBE8FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE900: 4BA4F409  bl 0x8290dd08
	ctx.lr = 0x82EBE904;
	sub_8290DD08(ctx, base);
	// 82EBE904: 4BDED2AD  bl 0x82cabbb0
	ctx.lr = 0x82EBE908;
	sub_82CABBB0(ctx, base);
	// 82EBE908: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE90C: C1BE0018  lfs f13, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE910: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE914: D01E00EC  stfs f0, 0xec(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EBE918: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE91C: D01E00D0  stfs f0, 0xd0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EBE920: 48000010  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
	// 82EBE924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBE928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBE92C: 4BFFF6E5  bl 0x82ebe010
	ctx.lr = 0x82EBE930;
	sub_82EBE010(ctx, base);
	// 82EBE930: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE934: 4BDEAB28  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE938 size=4
    let mut pc: u32 = 0x82EBE938;
    'dispatch: loop {
        match pc {
            0x82EBE938 => {
    //   block [0x82EBE938..0x82EBE93C)
	// 82EBE938: 4BFFFE00  b 0x82ebe738
	sub_82EBE738(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE940 size=16
    let mut pc: u32 = 0x82EBE940;
    'dispatch: loop {
        match pc {
            0x82EBE940 => {
    //   block [0x82EBE940..0x82EBE950)
	// 82EBE940: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE944: 996300C8  stb r11, 0xc8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82EBE948: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBE94C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE950 size=544
    let mut pc: u32 = 0x82EBE950;
    'dispatch: loop {
        match pc {
            0x82EBE950 => {
    //   block [0x82EBE950..0x82EBEB70)
	// 82EBE950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBE958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBE95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBE960: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82EBE964: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EBE968: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBE970: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBE974: 4BFF69BD  bl 0x82eb5330
	ctx.lr = 0x82EBE978;
	sub_82EB5330(ctx, base);
	// 82EBE978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE97C: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE980: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE984: 394BAE50  addi r10, r11, -0x51b0
	ctx.r[10].s64 = ctx.r[11].s64 + -20912;
	// 82EBE988: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE98C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EBE990: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EBE994: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE998: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EBE99C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBE9A0: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBE9A4: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBE9A8: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBE9AC: D3FF0024  stfs f31, 0x24(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBE9B0: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EBE9B4: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EBE9B8: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EBE9BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBE9C0: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EBE9C4: 997F0034  stb r11, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82EBE9C8: D3FF0038  stfs f31, 0x38(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EBE9CC: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82EBE9D0: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EBE9D4: D3FF0044  stfs f31, 0x44(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EBE9D8: D3FF0048  stfs f31, 0x48(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82EBE9DC: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EBE9E0: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBE9E4: D3FF0050  stfs f31, 0x50(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBE9E8: D3FF00BC  stfs f31, 0xbc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EBE9EC: D3FF00C0  stfs f31, 0xc0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EBE9F0: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EBE9F4: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82EBE9F8: D3FF00CC  stfs f31, 0xcc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EBE9FC: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBEA00: C3CA0C14  lfs f30, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBEA04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEA08: 4182000C  beq 0x82ebea14
	if ctx.cr[0].eq {
	pc = 0x82EBEA14; continue 'dispatch;
	}
	// 82EBEA0C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEA10: 48000008  b 0x82ebea18
	pc = 0x82EBEA18; continue 'dispatch;
	// 82EBEA14: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 82EBEA18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA1C: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EBEA20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBEA24: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82EBEA28: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEA2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA30: ED4D0032  fmuls f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEA34: D15F00D0  stfs f10, 0xd0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EBEA38: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EBEA3C: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEA40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA44: D1BF00D4  stfs f13, 0xd4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EBEA48: D1BF00E4  stfs f13, 0xe4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EBEA4C: C18B0BF8  lfs f12, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEA50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA54: D19F00D8  stfs f12, 0xd8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EBEA58: C16B0EE0  lfs f11, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEA5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA60: D17F00DC  stfs f11, 0xdc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EBEA64: C14B0A7C  lfs f10, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEA68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBEA6C: D15F00E8  stfs f10, 0xe8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EBEA70: C18BBE10  lfs f12, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEA74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA78: D19F00EC  stfs f12, 0xec(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EBEA7C: D19F00F4  stfs f12, 0xf4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EBEA80: C00B0B64  lfs f0, 0xb64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEA84: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EBEA88: 4BDEAF29  bl 0x82ca99b0
	ctx.lr = 0x82EBEA8C;
	sub_82CA99B0(ctx, base);
	// 82EBEA8C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEA90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEA94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBEA98: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EBEA9C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEAA0: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBEAA4: 4B329BD5  bl 0x821e8678
	ctx.lr = 0x82EBEAA8;
	sub_821E8678(ctx, base);
	// 82EBEAA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEAAC: 41820014  beq 0x82ebeac0
	if ctx.cr[0].eq {
	pc = 0x82EBEAC0; continue 'dispatch;
	}
	// 82EBEAB0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEAB4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBEAB8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EBEABC: 409A0020  bne cr6, 0x82ebeadc
	if !ctx.cr[6].eq {
	pc = 0x82EBEADC; continue 'dispatch;
	}
	// 82EBEAC0: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBEAC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEAC8: 4182000C  beq 0x82ebead4
	if ctx.cr[0].eq {
	pc = 0x82EBEAD4; continue 'dispatch;
	}
	// 82EBEACC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEAD0: 48000008  b 0x82ebead8
	pc = 0x82EBEAD8; continue 'dispatch;
	// 82EBEAD4: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82EBEAD8: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBEADC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEAE0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEAE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBEAE8: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EBEAEC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEAF0: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBEAF4: 4B329B85  bl 0x821e8678
	ctx.lr = 0x82EBEAF8;
	sub_821E8678(ctx, base);
	// 82EBEAF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEAFC: 4182000C  beq 0x82ebeb08
	if ctx.cr[0].eq {
	pc = 0x82EBEB08; continue 'dispatch;
	}
	// 82EBEB00: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEB04: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBEB08: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEB0C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEB10: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBEB14: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EBEB18: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEB1C: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBEB20: 4B329B59  bl 0x821e8678
	ctx.lr = 0x82EBEB24;
	sub_821E8678(ctx, base);
	// 82EBEB24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEB28: 4182000C  beq 0x82ebeb34
	if ctx.cr[0].eq {
	pc = 0x82EBEB34; continue 'dispatch;
	}
	// 82EBEB2C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEB30: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBEB34: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEB38: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBEB3C: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82EBEB40: 4B3A90E1  bl 0x82267c20
	ctx.lr = 0x82EBEB44;
	sub_82267C20(ctx, base);
	// 82EBEB44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBEB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBEB4C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EBEB50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBEB54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBEB58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBEB5C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBEB60: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EBEB64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBEB68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBEB6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBEB70 size=12
    let mut pc: u32 = 0x82EBEB70;
    'dispatch: loop {
        match pc {
            0x82EBEB70 => {
    //   block [0x82EBEB70..0x82EBEB7C)
	// 82EBEB70: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBEB74: 386BD018  addi r3, r11, -0x2fe8
	ctx.r[3].s64 = ctx.r[11].s64 + -12264;
	// 82EBEB78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBEB80 size=32
    let mut pc: u32 = 0x82EBEB80;
    'dispatch: loop {
        match pc {
            0x82EBEB80 => {
    //   block [0x82EBEB80..0x82EBEBA0)
	// 82EBEB80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEB84: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEB88: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82EBEB8C: 409A0024  bne cr6, 0x82ebebb0
	if !ctx.cr[6].eq {
		sub_82EBEBB0(ctx, base);
		return;
	}
	// 82EBEB90: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EBEB94: 409A000C  bne cr6, 0x82ebeba0
	if !ctx.cr[6].eq {
		sub_82EBEBA0(ctx, base);
		return;
	}
	// 82EBEB98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBEB9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBEBA0 size=16
    let mut pc: u32 = 0x82EBEBA0;
    'dispatch: loop {
        match pc {
            0x82EBEBA0 => {
    //   block [0x82EBEBA0..0x82EBEBB0)
	// 82EBEBA0: EC031024  fdivs f0, f3, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[3].f64 / ctx.f[2].f64) as f32) as f64;
	// 82EBEBA4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EBEBA8: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EBEBAC: 48000048  b 0x82ebebf4
	sub_82EBEBB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBEBB0 size=80
    let mut pc: u32 = 0x82EBEBB0;
    'dispatch: loop {
        match pc {
            0x82EBEBB0 => {
    //   block [0x82EBEBB0..0x82EBEC00)
	// 82EBEBB0: ED8100F2  fmuls f12, f1, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[3].f64) as f32) as f64);
	// 82EBEBB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEBB8: C1AB0A4C  lfs f13, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEBBC: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEBC0: EDA268B8  fmsubs f13, f2, f2, f13
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBEBC4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBEBC8: 4198FFD0  blt cr6, 0x82ebeb98
	if ctx.cr[6].lt {
		sub_82EBEB80(ctx, base);
		return;
	}
	// 82EBEBCC: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82EBEBD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEBD4: FD801050  fneg f12, f2
	ctx.f[12].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EBEBD8: ED6D1028  fsubs f11, f13, f2
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 82EBEBDC: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEBE0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEBE4: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBEBE8: ED8B0024  fdivs f12, f11, f0
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBEBEC: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EBEBF0: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBEBF4: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EBEBF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBEBFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBEC00 size=96
    let mut pc: u32 = 0x82EBEC00;
    'dispatch: loop {
        match pc {
            0x82EBEC00 => {
    //   block [0x82EBEC00..0x82EBEC60)
	// 82EBEC00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEC04: C0E50000  lfs f7, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBEC08: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEC0C: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEC10: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEC14: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEC18: C10B0A98  lfs f8, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBEC1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEC20: ED070232  fmuls f8, f7, f8
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EBEC24: C1430008  lfs f10, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEC28: ECEB02F2  fmuls f7, f11, f11
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEC2C: C1240008  lfs f9, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBEC30: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEC34: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEC38: ECED3B7A  fmadds f7, f13, f13, f7
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EBEC3C: EDAD583A  fmadds f13, f13, f0, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EBEC40: EC00603A  fmadds f0, f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EBEC44: ED893A7A  fmadds f12, f9, f9, f7
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EBEC48: EDA96ABA  fmadds f13, f9, f10, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBEC4C: EC2A02BA  fmadds f1, f10, f10, f0
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEC50: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEC54: EC68623C  fnmsubs f3, f8, f8, f12
	ctx.f[3].f64 = -(((ctx.f[8].f64 * ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBEC58: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEC5C: 4BFFFF24  b 0x82ebeb80
	sub_82EBEB80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBEC60 size=88
    let mut pc: u32 = 0x82EBEC60;
    'dispatch: loop {
        match pc {
            0x82EBEC60 => {
    //   block [0x82EBEC60..0x82EBECB8)
	// 82EBEC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBEC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBEC68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBEC6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBEC70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBEC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBEC78: 386000F8  li r3, 0xf8
	ctx.r[3].s64 = 248;
	// 82EBEC7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBEC80: 4B757CA9  bl 0x82616928
	ctx.lr = 0x82EBEC84;
	sub_82616928(ctx, base);
	// 82EBEC84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEC88: 41820014  beq 0x82ebec9c
	if ctx.cr[0].eq {
	pc = 0x82EBEC9C; continue 'dispatch;
	}
	// 82EBEC8C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBEC90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBEC94: 4BFFFCBD  bl 0x82ebe950
	ctx.lr = 0x82EBEC98;
	sub_82EBE950(ctx, base);
	// 82EBEC98: 48000008  b 0x82ebeca0
	pc = 0x82EBECA0; continue 'dispatch;
	// 82EBEC9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBECA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBECA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBECA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBECAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBECB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBECB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBECB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBECB8 size=820
    let mut pc: u32 = 0x82EBECB8;
    'dispatch: loop {
        match pc {
            0x82EBECB8 => {
    //   block [0x82EBECB8..0x82EBEFEC)
	// 82EBECB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBECBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBECC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBECC4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EBECC8: 4BDEEFFD  bl 0x82cadcc4
	ctx.lr = 0x82EBECCC;
	sub_82CADCA0(ctx, base);
	// 82EBECCC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBECD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBECD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBECD8: C36B0C18  lfs f27, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EBECDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBECE0: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBECE4: FDA0D890  fmr f13, f27
	ctx.f[13].f64 = ctx.f[27].f64;
	// 82EBECE8: FD80D890  fmr f12, f27
	ctx.f[12].f64 = ctx.f[27].f64;
	// 82EBECEC: FD60D890  fmr f11, f27
	ctx.f[11].f64 = ctx.f[27].f64;
	// 82EBECF0: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBECF4: C34B0C14  lfs f26, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EBECF8: 40810070  ble 0x82ebed68
	if !ctx.cr[0].gt {
	pc = 0x82EBED68; continue 'dispatch;
	}
	// 82EBECFC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBED00: 393F0058  addi r9, r31, 0x58
	ctx.r[9].s64 = ctx.r[31].s64 + 88;
	// 82EBED04: C0EB0034  lfs f7, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBED08: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EBED0C: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EBED10: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBED14: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBED18: ED254828  fsubs f9, f5, f9
	ctx.f[9].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBED1C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBED20: ED470028  fsubs f10, f7, f0
	ctx.f[10].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBED24: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBED28: ED060028  fsubs f8, f6, f0
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBED2C: EC090272  fmuls f0, f9, f9
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EBED30: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED34: EC08023A  fmadds f0, f8, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED38: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBED3C: 40990020  ble cr6, 0x82ebed5c
	if !ctx.cr[6].gt {
	pc = 0x82EBED5C; continue 'dispatch;
	}
	// 82EBED40: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBED44: ED4002B2  fmuls f10, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBED48: ED000232  fmuls f8, f0, f8
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EBED4C: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EBED50: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBED54: ED88602A  fadds f12, f8, f12
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBED58: ED60582A  fadds f11, f0, f11
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EBED5C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EBED60: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EBED64: 4082FFAC  bne 0x82ebed10
	if !ctx.cr[0].eq {
	pc = 0x82EBED10; continue 'dispatch;
	}
	// 82EBED68: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBED6C: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED70: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED74: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBED78: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBED7C: 40990018  ble cr6, 0x82ebed94
	if !ctx.cr[6].gt {
	pc = 0x82EBED94; continue 'dispatch;
	}
	// 82EBED80: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBED84: EF200372  fmuls f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBED88: EEE00332  fmuls f23, f0, f12
	ctx.f[23].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBED8C: EF0002F2  fmuls f24, f0, f11
	ctx.f[24].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBED90: 48000010  b 0x82ebeda0
	pc = 0x82EBEDA0; continue 'dispatch;
	// 82EBED94: FF20D890  fmr f25, f27
	ctx.f[25].f64 = ctx.f[27].f64;
	// 82EBED98: FEE0D890  fmr f23, f27
	ctx.f[23].f64 = ctx.f[27].f64;
	// 82EBED9C: FF00D890  fmr f24, f27
	ctx.f[24].f64 = ctx.f[27].f64;
	// 82EBEDA0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBEDA4: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEDA8: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEDAC: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEDB0: C143003C  lfs f10, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEDB4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEDB8: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEDBC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBEDC0: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEDC4: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBEDC8: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEDCC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEDD0: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEDD4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBEDD8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBEDDC: 40990018  ble cr6, 0x82ebedf4
	if !ctx.cr[6].gt {
	pc = 0x82EBEDF4; continue 'dispatch;
	}
	// 82EBEDE0: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBEDE4: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEDE8: EFA002F2  fmuls f29, f0, f11
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEDEC: EFC00332  fmuls f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEDF0: 48000010  b 0x82ebee00
	pc = 0x82EBEE00; continue 'dispatch;
	// 82EBEDF4: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 82EBEDF8: FFA0D890  fmr f29, f27
	ctx.f[29].f64 = ctx.f[27].f64;
	// 82EBEDFC: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82EBEE00: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEE04: C39F00D4  lfs f28, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EBEE08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBEE0C: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EBEE10: 4B329869  bl 0x821e8678
	ctx.lr = 0x82EBEE14;
	sub_821E8678(ctx, base);
	// 82EBEE14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEE18: 4182010C  beq 0x82ebef24
	if ctx.cr[0].eq {
	pc = 0x82EBEF24; continue 'dispatch;
	}
	// 82EBEE1C: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEE20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEE24: 41820100  beq 0x82ebef24
	if ctx.cr[0].eq {
	pc = 0x82EBEF24; continue 'dispatch;
	}
	// 82EBEE28: ED9D0672  fmuls f12, f29, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EBEE2C: EC1E05F2  fmuls f0, f30, f23
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[23].f64) as f32) as f64);
	// 82EBEE30: ED5807F2  fmuls f10, f24, f31
	ctx.f[10].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBEE34: ED7767F8  fmsubs f11, f23, f31, f12
	ctx.f[11].f64 = (((ctx.f[23].f64 * ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBEE38: EDBD0638  fmsubs f13, f29, f24, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBEE3C: ED9E5678  fmsubs f12, f30, f25, f10
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEE40: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEE44: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEE48: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEE4C: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBEE50: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBEE54: 409A0074  bne cr6, 0x82ebeec8
	if !ctx.cr[6].eq {
	pc = 0x82EBEEC8; continue 'dispatch;
	}
	// 82EBEE58: FF1FD800  fcmpu cr6, f31, f27
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[27].f64);
	// 82EBEE5C: 409A0018  bne cr6, 0x82ebee74
	if !ctx.cr[6].eq {
	pc = 0x82EBEE74; continue 'dispatch;
	}
	// 82EBEE60: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EBEE64: 409A0010  bne cr6, 0x82ebee74
	if !ctx.cr[6].eq {
	pc = 0x82EBEE74; continue 'dispatch;
	}
	// 82EBEE68: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBEE6C: 396BDBE4  addi r11, r11, -0x241c
	ctx.r[11].s64 = ctx.r[11].s64 + -9244;
	// 82EBEE70: 4800000C  b 0x82ebee7c
	pc = 0x82EBEE7C; continue 'dispatch;
	// 82EBEE74: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBEE78: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EBEE7C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEE80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBEE84: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEE88: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEE8C: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEE90: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEE94: ED3D0332  fmuls f9, f29, f12
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEE98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBEE9C: EC1D5838  fmsubs f0, f29, f0, f11
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBEEA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBEEA4: EC1E5338  fmsubs f0, f30, f12, f10
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEEA8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBEEAC: EC1F4B78  fmsubs f0, f31, f13, f9
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBEEB0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBEEB4: 4B3C03B5  bl 0x8227f268
	ctx.lr = 0x82EBEEB8;
	sub_8227F268(ctx, base);
	// 82EBEEB8: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEEBC: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEEC0: C1630008  lfs f11, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEEC4: 48000030  b 0x82ebeef4
	pc = 0x82EBEEF4; continue 'dispatch;
	// 82EBEEC8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBEECC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEED0: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEED4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEED8: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEEDC: ED2C07F2  fmuls f9, f12, f31
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBEEE0: ED400772  fmuls f10, f0, f29
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EBEEE4: ED4C57B8  fmsubs f10, f12, f30, f10
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEEE8: ED805FF8  fmsubs f12, f0, f31, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBEEEC: ED7D4B78  fmsubs f11, f29, f13, f9
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBEEF0: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EBEEF4: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EBEEF8: ED5F0732  fmuls f10, f31, f28
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEEFC: ED3D0732  fmuls f9, f29, f28
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF00: ED1E0732  fmuls f8, f30, f28
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF04: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF08: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF0C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF10: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBEF14: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBEF18: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBEF1C: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBEF20: 48000084  b 0x82ebefa4
	pc = 0x82EBEFA4; continue 'dispatch;
	// 82EBEF24: EC1807F2  fmuls f0, f24, f31
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBEF28: FDA0D090  fmr f13, f26
	ctx.f[13].f64 = ctx.f[26].f64;
	// 82EBEF2C: EC1E0678  fmsubs f0, f30, f25, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBEF30: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBEF34: 4098000C  bge cr6, 0x82ebef40
	if !ctx.cr[6].lt {
	pc = 0x82EBEF40; continue 'dispatch;
	}
	// 82EBEF38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEF3C: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEF40: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBEF44: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EBEF48: ED3F0732  fmuls f9, f31, f28
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF4C: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EBEF50: ECFE0732  fmuls f7, f30, f28
	ctx.f[7].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF54: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEF58: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEF5C: ED1D02F2  fmuls f8, f29, f11
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEF60: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEF64: ECDE02B2  fmuls f6, f30, f10
	ctx.f[6].f64 = (((ctx.f[30].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBEF68: ECBF0332  fmuls f5, f31, f12
	ctx.f[5].f64 = (((ctx.f[31].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEF6C: ED9E4338  fmsubs f12, f30, f12, f8
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EBEF70: ED7F32F8  fmsubs f11, f31, f11, f6
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EBEF74: ED5D2AB8  fmsubs f10, f29, f10, f5
	ctx.f[10].f64 = (((ctx.f[29].f64 * ctx.f[10].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EBEF78: ED1D0732  fmuls f8, f29, f28
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF7C: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF80: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF84: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF88: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF8C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF90: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF94: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBEF98: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBEF9C: EDA8582A  fadds f13, f8, f11
	ctx.f[13].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EBEFA0: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBEFA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBEFA8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBEFAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBEFB0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBEFB4: 4B3C02B5  bl 0x8227f268
	ctx.lr = 0x82EBEFB8;
	sub_8227F268(ctx, base);
	// 82EBEFB8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEFBC: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EBEFC0: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEFC4: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EBEFC8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEFCC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EBEFD0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EBEFD4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EBEFD8: 4BDEED39  bl 0x82cadd10
	ctx.lr = 0x82EBEFDC;
	sub_82CADCEC(ctx, base);
	// 82EBEFDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBEFE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBEFE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBEFE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBEFF0 size=708
    let mut pc: u32 = 0x82EBEFF0;
    'dispatch: loop {
        match pc {
            0x82EBEFF0 => {
    //   block [0x82EBEFF0..0x82EBF2B4)
	// 82EBEFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBEFF4: 4BDEA419  bl 0x82ca940c
	ctx.lr = 0x82EBEFF8;
	sub_82CA93D0(ctx, base);
	// 82EBEFF8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EBEFFC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBF000: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF004: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF008: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF00C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF010: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF014: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EBF018: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF01C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBF020: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF024: 4182000C  beq 0x82ebf030
	if ctx.cr[0].eq {
	pc = 0x82EBF030; continue 'dispatch;
	}
	// 82EBF028: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBF02C: 48000008  b 0x82ebf034
	pc = 0x82EBF034; continue 'dispatch;
	// 82EBF030: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82EBF034: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF038: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBF03C: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EBF040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBF044: 4B329635  bl 0x821e8678
	ctx.lr = 0x82EBF048;
	sub_821E8678(ctx, base);
	// 82EBF048: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF04C: 41820008  beq 0x82ebf054
	if ctx.cr[0].eq {
	pc = 0x82EBF054; continue 'dispatch;
	}
	// 82EBF050: C3C30004  lfs f30, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBF054: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF058: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF05C: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF060: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF064: C19E003C  lfs f12, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF068: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF06C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBF070: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF074: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF078: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBF07C: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBF080: C14A0C18  lfs f10, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF084: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF088: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF08C: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF090: ED20002C  fsqrts f9, f0
	ctx.f[9].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBF094: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 82EBF098: 40990018  ble cr6, 0x82ebf0b0
	if !ctx.cr[6].gt {
	pc = 0x82EBF0B0; continue 'dispatch;
	}
	// 82EBF09C: EC1F4824  fdivs f0, f31, f9
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[9].f64) as f32) as f64;
	// 82EBF0A0: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBF0A4: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF0A8: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBF0AC: 48000010  b 0x82ebf0bc
	pc = 0x82EBF0BC; continue 'dispatch;
	// 82EBF0B0: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 82EBF0B4: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EBF0B8: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 82EBF0BC: C18B0050  lfs f12, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF0C0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF0C4: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF0C8: C10B004C  lfs f8, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBF0CC: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBF0D0: EC0802FA  fmadds f0, f8, f11, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF0D4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EBF0D8: 41990010  bgt cr6, 0x82ebf0e8
	if ctx.cr[6].gt {
	pc = 0x82EBF0E8; continue 'dispatch;
	}
	// 82EBF0DC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF0E0: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82EBF0E4: 409801C0  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF0E8: C00B0058  lfs f0, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF0EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF0F0: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF0F4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EBF0F8: C12B004C  lfs f9, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF0FC: C17E004C  lfs f11, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF100: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF104: C10B0050  lfs f8, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBF108: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF10C: C15E0050  lfs f10, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF110: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF114: C0FE0054  lfs f7, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBF118: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF11C: C08B0054  lfs f4, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EBF120: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF124: EC040032  fmuls f0, f4, f0
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF128: C0CB0034  lfs f6, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EBF12C: C0FE0034  lfs f7, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBF130: ECE73028  fsubs f7, f7, f6
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EBF134: C0BE0038  lfs f5, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EBF138: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EBF13C: ECC53028  fsubs f6, f5, f6
	ctx.f[6].f64 = (((ctx.f[5].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EBF140: C18A0A40  lfs f12, 0xa40(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2624 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF144: C07E003C  lfs f3, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EBF148: FFE06090  fmr f31, f12
	ctx.f[31].f64 = ctx.f[12].f64;
	// 82EBF14C: ED6B4828  fsubs f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBF150: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EBF154: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EBF158: ECA32828  fsubs f5, f3, f5
	ctx.f[5].f64 = (((ctx.f[3].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EBF15C: ED6A4028  fsubs f11, f10, f8
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EBF160: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EBF164: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBF168: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EBF16C: 419A0040  beq cr6, 0x82ebf1ac
	if ctx.cr[6].eq {
	pc = 0x82EBF1AC; continue 'dispatch;
	}
	// 82EBF170: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF174: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF178: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBF17C: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF180: C10B003C  lfs f8, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBF184: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBF188: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF18C: C12B0034  lfs f9, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF190: ED695828  fsubs f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF194: C14B0058  lfs f10, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF198: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF19C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF1A0: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF1A4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBF1A8: EFE05024  fdivs f31, f0, f10
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EBF1AC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF1B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF1B4: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EBF1B8: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EBF1BC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EBF1C0: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBF1C4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EBF1C8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBF1CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EBF1D0: D0E10070  stfs f7, 0x70(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EBF1D4: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF1D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBF1DC: D0C10074  stfs f6, 0x74(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EBF1E0: D0A10078  stfs f5, 0x78(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EBF1E4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF1E8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBF1EC: 4BFFFA15  bl 0x82ebec00
	ctx.lr = 0x82EBF1F0;
	sub_82EBEC00(ctx, base);
	// 82EBF1F0: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF1F4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF1F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF1FC: 41980008  blt cr6, 0x82ebf204
	if ctx.cr[6].lt {
	pc = 0x82EBF204; continue 'dispatch;
	}
	// 82EBF200: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBF204: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBF208: 4182009C  beq 0x82ebf2a4
	if ctx.cr[0].eq {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF20C: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF210: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF214: 40980090  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF218: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EBF21C: 40980088  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF220: C1BF00DC  lfs f13, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF224: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF228: 4099007C  ble cr6, 0x82ebf2a4
	if !ctx.cr[6].gt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF22C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBF230: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 82EBF234: 4098001C  bge cr6, 0x82ebf250
	if !ctx.cr[6].lt {
	pc = 0x82EBF250; continue 'dispatch;
	}
	// 82EBF238: 396B0016  addi r11, r11, 0x16
	ctx.r[11].s64 = ctx.r[11].s64 + 22;
	// 82EBF23C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBF240: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	// 82EBF244: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBF248: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBF24C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBF250: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF254: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF258: 4098004C  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF25C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EBF260: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF264: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBF268: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82EBF26C: 995F003C  stb r10, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u8 ) };
	// 82EBF270: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF274: C16B0050  lfs f11, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF278: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF27C: C14B0054  lfs f10, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF280: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF284: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF288: C1AB0058  lfs f13, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF28C: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF290: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EBF294: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF298: D17F0048  stfs f11, 0x48(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82EBF29C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF2A0: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EBF2A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EBF2A8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EBF2AC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBF2B0: 4BDEA1AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF2B8 size=344
    let mut pc: u32 = 0x82EBF2B8;
    'dispatch: loop {
        match pc {
            0x82EBF2B8 => {
    //   block [0x82EBF2B8..0x82EBF410)
	// 82EBF2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF2BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF2C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF2C4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF2C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBF2CC: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EBF2D0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF2D4: C1AB00C0  lfs f13, 0xc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF2D8: C16B00C4  lfs f11, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF2DC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF2E0: C12B00BC  lfs f9, 0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF2E4: C00B00F0  lfs f0, 0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF2E8: C18A0050  lfs f12, 0x50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF2EC: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF2F0: C18A0054  lfs f12, 0x54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF2F4: C14A004C  lfs f10, 0x4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF2F8: 807F0264  lwz r3, 0x264(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBF2FC: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBF300: EDAA6A7A  fmadds f13, f10, f9, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBF304: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBF308: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF30C: C1AB00F4  lfs f13, 0xf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF310: 40990054  ble cr6, 0x82ebf364
	if !ctx.cr[6].gt {
	pc = 0x82EBF364; continue 'dispatch;
	}
	// 82EBF314: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF318: 40980018  bge cr6, 0x82ebf330
	if !ctx.cr[6].lt {
	pc = 0x82EBF330; continue 'dispatch;
	}
	// 82EBF31C: C04B0024  lfs f2, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EBF320: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EBF324: C1AB00C0  lfs f13, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF328: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	// 82EBF32C: 48000060  b 0x82ebf38c
	pc = 0x82EBF38C; continue 'dispatch;
	// 82EBF330: C16B00E4  lfs f11, 0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF334: C14B0024  lfs f10, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF338: EC4B02B2  fmuls f2, f11, f10
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBF33C: C16A0034  lfs f11, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF340: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF344: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF348: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF34C: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF350: C14A0038  lfs f10, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF354: C16A003C  lfs f11, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF358: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBF35C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF360: 4800002C  b 0x82ebf38c
	pc = 0x82EBF38C; continue 'dispatch;
	// 82EBF364: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF368: C18B00C4  lfs f12, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF36C: C00B00BC  lfs f0, 0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF370: C1AB00C0  lfs f13, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF374: C14B0024  lfs f10, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF378: 4098000C  bge cr6, 0x82ebf384
	if !ctx.cr[6].lt {
	pc = 0x82EBF384; continue 'dispatch;
	}
	// 82EBF37C: C16B00E8  lfs f11, 0xe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF380: 48000008  b 0x82ebf388
	pc = 0x82EBF388; continue 'dispatch;
	// 82EBF384: C16B00E4  lfs f11, 0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF388: EC4B02B2  fmuls f2, f11, f10
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBF38C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBF390: C16A0034  lfs f11, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF394: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBF398: C14A0038  lfs f10, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF39C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EBF3A0: C16A003C  lfs f11, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF3A4: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBF3A8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBF3AC: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBF3B0: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBF3B4: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EBF3B8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EBF3BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBF3C0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EBF3C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EBF3C8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82EBF3CC: 90C70000  stw r6, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82EBF3D0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBF3D4: 4200FFF8  bdnz 0x82ebf3cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBF3CC; continue 'dispatch;
	}
	// 82EBF3D8: 98C100A8  stb r6, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[6].u8 ) };
	// 82EBF3DC: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EBF3E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBF3E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EBF3E8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EBF3EC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EBF3F0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF3F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF3F8: 4E800421  bctrl
	ctx.lr = 0x82EBF3FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF3FC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EBF400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF40C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF410 size=340
    let mut pc: u32 = 0x82EBF410;
    'dispatch: loop {
        match pc {
            0x82EBF410 => {
    //   block [0x82EBF410..0x82EBF564)
	// 82EBF410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF414: 4BDE9FF5  bl 0x82ca9408
	ctx.lr = 0x82EBF418;
	sub_82CA93D0(ctx, base);
	// 82EBF418: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF420: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF424: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBF428: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EBF42C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF430: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF434: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBF438: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82EBF43C: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EBF440: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF444: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBF448: 4182006C  beq 0x82ebf4b4
	if ctx.cr[0].eq {
	pc = 0x82EBF4B4; continue 'dispatch;
	}
	// 82EBF44C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF450: C03F00D0  lfs f1, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EBF454: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EBF458: 4BFC8851  bl 0x82e87ca8
	ctx.lr = 0x82EBF45C;
	sub_82E87CA8(ctx, base);
	// 82EBF45C: 4800004C  b 0x82ebf4a8
	pc = 0x82EBF4A8; continue 'dispatch;
	// 82EBF460: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF464: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBF468: 419A0038  beq cr6, 0x82ebf4a0
	if ctx.cr[6].eq {
	pc = 0x82EBF4A0; continue 'dispatch;
	}
	// 82EBF46C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF470: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF474: 4182001C  beq 0x82ebf490
	if ctx.cr[0].eq {
	pc = 0x82EBF490; continue 'dispatch;
	}
	// 82EBF478: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF47C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF480: 4E800421  bctrl
	ctx.lr = 0x82EBF484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF484: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EBF488: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EBF48C: 409A0014  bne cr6, 0x82ebf4a0
	if !ctx.cr[6].eq {
	pc = 0x82EBF4A0; continue 'dispatch;
	}
	// 82EBF490: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EBF494: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF49C: 4BFFFB55  bl 0x82ebeff0
	ctx.lr = 0x82EBF4A0;
	sub_82EBEFF0(ctx, base);
	// 82EBF4A0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF4A4: 4BFC82CD  bl 0x82e87770
	ctx.lr = 0x82EBF4A8;
	sub_82E87770(ctx, base);
	// 82EBF4A8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBF4AC: 4082FFB4  bne 0x82ebf460
	if !ctx.cr[0].eq {
	pc = 0x82EBF460; continue 'dispatch;
	}
	// 82EBF4B0: 480000AC  b 0x82ebf55c
	pc = 0x82EBF55C; continue 'dispatch;
	// 82EBF4B4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF4B8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF4BC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF4C0: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBF4C4: 48000090  b 0x82ebf554
	pc = 0x82EBF554; continue 'dispatch;
	// 82EBF4C8: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF4CC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF4D0: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBF4D4: 419A007C  beq cr6, 0x82ebf550
	if ctx.cr[6].eq {
	pc = 0x82EBF550; continue 'dispatch;
	}
	// 82EBF4D8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF4DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF4E0: 4182001C  beq 0x82ebf4fc
	if ctx.cr[0].eq {
	pc = 0x82EBF4FC; continue 'dispatch;
	}
	// 82EBF4E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF4E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF4EC: 4E800421  bctrl
	ctx.lr = 0x82EBF4F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF4F0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EBF4F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EBF4F8: 409A0058  bne cr6, 0x82ebf550
	if !ctx.cr[6].eq {
	pc = 0x82EBF550; continue 'dispatch;
	}
	// 82EBF4FC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF500: C01F00D0  lfs f0, 0xd0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF504: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF508: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF50C: C19E0038  lfs f12, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF510: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF514: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBF518: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF51C: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBF520: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF524: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF528: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBF52C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF530: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF534: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF538: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBF53C: 40980014  bge cr6, 0x82ebf550
	if !ctx.cr[6].lt {
	pc = 0x82EBF550; continue 'dispatch;
	}
	// 82EBF540: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EBF544: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF54C: 4BFFFAA5  bl 0x82ebeff0
	ctx.lr = 0x82EBF550;
	sub_82EBEFF0(ctx, base);
	// 82EBF550: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF554: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF558: 4082FF70  bne 0x82ebf4c8
	if !ctx.cr[0].eq {
	pc = 0x82EBF4C8; continue 'dispatch;
	}
	// 82EBF55C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBF560: 4BDE9EF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF568 size=200
    let mut pc: u32 = 0x82EBF568;
    'dispatch: loop {
        match pc {
            0x82EBF568 => {
    //   block [0x82EBF568..0x82EBF630)
	// 82EBF568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF56C: 4BDE9E9D  bl 0x82ca9408
	ctx.lr = 0x82EBF570;
	sub_82CA93D0(ctx, base);
	// 82EBF570: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF578: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EBF57C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EBF580: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82EBF584: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF58C: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF590: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBF594: 4BFFFE7D  bl 0x82ebf410
	ctx.lr = 0x82EBF598;
	sub_82EBF410(ctx, base);
	// 82EBF598: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EBF59C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF5A0: 4182003C  beq 0x82ebf5dc
	if ctx.cr[0].eq {
	pc = 0x82EBF5DC; continue 'dispatch;
	}
	// 82EBF5A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF5A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF5AC: 4BFFF70D  bl 0x82ebecb8
	ctx.lr = 0x82EBF5B0;
	sub_82EBECB8(ctx, base);
	// 82EBF5B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBF5B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBF5B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF5BC: 4BFFFCFD  bl 0x82ebf2b8
	ctx.lr = 0x82EBF5C0;
	sub_82EBF2B8(ctx, base);
	// 82EBF5C0: 4B3A13F9  bl 0x822609b8
	ctx.lr = 0x82EBF5C4;
	sub_822609B8(ctx, base);
	// 82EBF5C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBF5C8: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF5CC: C01F00D8  lfs f0, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF5D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBF5D4: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EBF5D8: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82EBF5DC: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EBF5E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF5E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF5E8: 40820014  bne 0x82ebf5fc
	if !ctx.cr[0].eq {
	pc = 0x82EBF5FC; continue 'dispatch;
	}
	// 82EBF5EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBF5F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBF5F4: 4BFFF14D  bl 0x82ebe740
	ctx.lr = 0x82EBF5F8;
	sub_82EBE740(ctx, base);
	// 82EBF5F8: 48000030  b 0x82ebf628
	pc = 0x82EBF628; continue 'dispatch;
	// 82EBF5FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBF600: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBF604: 4BFFFCB5  bl 0x82ebf2b8
	ctx.lr = 0x82EBF608;
	sub_82EBF2B8(ctx, base);
	// 82EBF608: 4B3A13B1  bl 0x822609b8
	ctx.lr = 0x82EBF60C;
	sub_822609B8(ctx, base);
	// 82EBF60C: C01F00CC  lfs f0, 0xcc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF610: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF614: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF618: 4098000C  bge cr6, 0x82ebf624
	if !ctx.cr[6].lt {
	pc = 0x82EBF624; continue 'dispatch;
	}
	// 82EBF61C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBF620: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82EBF624: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBF628: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBF62C: 4BDE9E2C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF630 size=296
    let mut pc: u32 = 0x82EBF630;
    'dispatch: loop {
        match pc {
            0x82EBF630 => {
    //   block [0x82EBF630..0x82EBF758)
	// 82EBF630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF634: 4BDE9DD9  bl 0x82ca940c
	ctx.lr = 0x82EBF638;
	sub_82CA93D0(ctx, base);
	// 82EBF638: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBF63C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF640: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBF644: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBF648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF64C: 482FCA15  bl 0x831bc060
	ctx.lr = 0x82EBF650;
	sub_831BC060(ctx, base);
	// 82EBF650: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF654: 41820084  beq 0x82ebf6d8
	if ctx.cr[0].eq {
	pc = 0x82EBF6D8; continue 'dispatch;
	}
	// 82EBF658: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBF65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF660: 3BCBAEA0  addi r30, r11, -0x5160
	ctx.r[30].s64 = ctx.r[11].s64 + -20832;
	// 82EBF664: 482FC9FD  bl 0x831bc060
	ctx.lr = 0x82EBF668;
	sub_831BC060(ctx, base);
	// 82EBF668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF66C: 4BDED4E5  bl 0x82cacb50
	ctx.lr = 0x82EBF670;
	sub_82CACB50(ctx, base);
	// 82EBF670: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBF674: 40820064  bne 0x82ebf6d8
	if !ctx.cr[0].eq {
	pc = 0x82EBF6D8; continue 'dispatch;
	}
	// 82EBF678: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF67C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF680: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF684: 4182000C  beq 0x82ebf690
	if ctx.cr[0].eq {
	pc = 0x82EBF690; continue 'dispatch;
	}
	// 82EBF688: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBF68C: 4800000C  b 0x82ebf698
	pc = 0x82EBF698; continue 'dispatch;
	// 82EBF690: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF694: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBF698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF69C: 4BA4E66D  bl 0x8290dd08
	ctx.lr = 0x82EBF6A0;
	sub_8290DD08(ctx, base);
	// 82EBF6A0: 4BDEC511  bl 0x82cabbb0
	ctx.lr = 0x82EBF6A4;
	sub_82CABBB0(ctx, base);
	// 82EBF6A4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBF6A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF6AC: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF6B0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF6B4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBF6B8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBF6BC: 40990008  ble cr6, 0x82ebf6c4
	if !ctx.cr[6].gt {
	pc = 0x82EBF6C4; continue 'dispatch;
	}
	// 82EBF6C0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBF6C4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBF6C8: 409AFFF0  bne cr6, 0x82ebf6b8
	if !ctx.cr[6].eq {
	pc = 0x82EBF6B8; continue 'dispatch;
	}
	// 82EBF6CC: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBF6D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBF6D4: 48000078  b 0x82ebf74c
	pc = 0x82EBF74C; continue 'dispatch;
	// 82EBF6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF6DC: 482FC985  bl 0x831bc060
	ctx.lr = 0x82EBF6E0;
	sub_831BC060(ctx, base);
	// 82EBF6E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF6E4: 4182005C  beq 0x82ebf740
	if ctx.cr[0].eq {
	pc = 0x82EBF740; continue 'dispatch;
	}
	// 82EBF6E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBF6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF6F0: 3BCBAE90  addi r30, r11, -0x5170
	ctx.r[30].s64 = ctx.r[11].s64 + -20848;
	// 82EBF6F4: 482FC96D  bl 0x831bc060
	ctx.lr = 0x82EBF6F8;
	sub_831BC060(ctx, base);
	// 82EBF6F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF6FC: 4BDED455  bl 0x82cacb50
	ctx.lr = 0x82EBF700;
	sub_82CACB50(ctx, base);
	// 82EBF700: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBF704: 4082003C  bne 0x82ebf740
	if !ctx.cr[0].eq {
	pc = 0x82EBF740; continue 'dispatch;
	}
	// 82EBF708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF70C: 4BA4E5FD  bl 0x8290dd08
	ctx.lr = 0x82EBF710;
	sub_8290DD08(ctx, base);
	// 82EBF710: 4BDEC4A1  bl 0x82cabbb0
	ctx.lr = 0x82EBF714;
	sub_82CABBB0(ctx, base);
	// 82EBF714: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF718: C01D0088  lfs f0, 0x88(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF71C: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBF720: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF724: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBF728: 41980008  blt cr6, 0x82ebf730
	if ctx.cr[6].lt {
	pc = 0x82EBF730; continue 'dispatch;
	}
	// 82EBF72C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBF730: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBF734: 409AFFF0  bne cr6, 0x82ebf724
	if !ctx.cr[6].eq {
	pc = 0x82EBF724; continue 'dispatch;
	}
	// 82EBF738: D01D0088  stfs f0, 0x88(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EBF73C: 4BFFFF94  b 0x82ebf6d0
	pc = 0x82EBF6D0; continue 'dispatch;
	// 82EBF740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBF744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBF748: 4BFF5CD9  bl 0x82eb5420
	ctx.lr = 0x82EBF74C;
	sub_82EB5420(ctx, base);
	// 82EBF74C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBF750: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBF754: 4BDE9D08  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF758 size=144
    let mut pc: u32 = 0x82EBF758;
    'dispatch: loop {
        match pc {
            0x82EBF758 => {
    //   block [0x82EBF758..0x82EBF7E8)
	// 82EBF758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBF764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF76C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF770: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF774: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF778: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF77C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF780: 4182000C  beq 0x82ebf78c
	if ctx.cr[0].eq {
	pc = 0x82EBF78C; continue 'dispatch;
	}
	// 82EBF784: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF788: 4800000C  b 0x82ebf794
	pc = 0x82EBF794; continue 'dispatch;
	// 82EBF78C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF790: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF794: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF798: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBF79C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF7A0: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF7A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF7A8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF7AC: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBF7B0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF7B4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF7B8: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EBF7BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF7C0: 4E800421  bctrl
	ctx.lr = 0x82EBF7C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF7C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF7CC: 480048AD  bl 0x82ec4078
	ctx.lr = 0x82EBF7D0;
	sub_82EC4078(ctx, base);
	// 82EBF7D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBF7D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF7D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF7DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBF7E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF7E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBF7E8 size=44
    let mut pc: u32 = 0x82EBF7E8;
    'dispatch: loop {
        match pc {
            0x82EBF7E8 => {
    //   block [0x82EBF7E8..0x82EBF814)
	// 82EBF7E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF7EC: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF7F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF7F4: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBF7F8: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBF7FC: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF800: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF804: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EBF808: C00B0C1C  lfs f0, 0xc1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF80C: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EBF810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF818 size=152
    let mut pc: u32 = 0x82EBF818;
    'dispatch: loop {
        match pc {
            0x82EBF818 => {
    //   block [0x82EBF818..0x82EBF8B0)
	// 82EBF818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF824: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF82C: 4BFF5B05  bl 0x82eb5330
	ctx.lr = 0x82EBF830;
	sub_82EB5330(ctx, base);
	// 82EBF830: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF834: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EBF838: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 82EBF83C: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EBF840: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EBF844: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF848: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EBF84C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EBF850: 394AAEB0  addi r10, r10, -0x5150
	ctx.r[10].s64 = ctx.r[10].s64 + -20816;
	// 82EBF854: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EBF858: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBF85C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EBF860: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 82EBF864: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBF868: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBF86C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBF870: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBF874: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EBF878: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EBF87C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBF880: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBF884: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82EBF888: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EBF88C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EBF890: 4200FFF8  bdnz 0x82ebf888
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBF888; continue 'dispatch;
	}
	// 82EBF894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF898: 98EB0058  stb r7, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[7].u8 ) };
	// 82EBF89C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBF8A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF8A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF8A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF8AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBF8B0 size=12
    let mut pc: u32 = 0x82EBF8B0;
    'dispatch: loop {
        match pc {
            0x82EBF8B0 => {
    //   block [0x82EBF8B0..0x82EBF8BC)
	// 82EBF8B0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBF8B4: 386BD12C  addi r3, r11, -0x2ed4
	ctx.r[3].s64 = ctx.r[11].s64 + -11988;
	// 82EBF8B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBF8C0 size=100
    let mut pc: u32 = 0x82EBF8C0;
    'dispatch: loop {
        match pc {
            0x82EBF8C0 => {
    //   block [0x82EBF8C0..0x82EBF924)
	// 82EBF8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF8C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBF8CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF8D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF8D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBF8D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF8DC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EBF8E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF8E4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EBF8E8: 4BFF5AE1  bl 0x82eb53c8
	ctx.lr = 0x82EBF8EC;
	sub_82EB53C8(ctx, base);
	// 82EBF8EC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBF8F0: 41820018  beq 0x82ebf908
	if ctx.cr[0].eq {
	pc = 0x82EBF908; continue 'dispatch;
	}
	// 82EBF8F4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBF8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF8FC: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBF900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF904: 4E800421  bctrl
	ctx.lr = 0x82EBF908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF90C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBF910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF918: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBF91C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBF928 size=88
    let mut pc: u32 = 0x82EBF928;
    'dispatch: loop {
        match pc {
            0x82EBF928 => {
    //   block [0x82EBF928..0x82EBF980)
	// 82EBF928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF92C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF930: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBF934: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF938: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF93C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF940: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82EBF944: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF948: 4B756FE1  bl 0x82616928
	ctx.lr = 0x82EBF94C;
	sub_82616928(ctx, base);
	// 82EBF94C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF950: 41820014  beq 0x82ebf964
	if ctx.cr[0].eq {
	pc = 0x82EBF964; continue 'dispatch;
	}
	// 82EBF954: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBF958: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBF95C: 4BFFFEBD  bl 0x82ebf818
	ctx.lr = 0x82EBF960;
	sub_82EBF818(ctx, base);
	// 82EBF960: 48000008  b 0x82ebf968
	pc = 0x82EBF968; continue 'dispatch;
	// 82EBF964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBF968: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBF96C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF974: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBF978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF980 size=1144
    let mut pc: u32 = 0x82EBF980;
    'dispatch: loop {
        match pc {
            0x82EBF980 => {
    //   block [0x82EBF980..0x82EBFDF8)
	// 82EBF980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF984: 4BDE9A71  bl 0x82ca93f4
	ctx.lr = 0x82EBF988;
	sub_82CA93D0(ctx, base);
	// 82EBF988: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82EBF98C: 4BDEE349  bl 0x82cadcd4
	ctx.lr = 0x82EBF990;
	sub_82CADCA0(ctx, base);
	// 82EBF990: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF998: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EBF99C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82EBF9A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF9A4: 83CB039C  lwz r30, 0x39c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EBF9A8: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBF9AC: 3BBE0014  addi r29, r30, 0x14
	ctx.r[29].s64 = ctx.r[30].s64 + 20;
	// 82EBF9B0: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBF9B4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBF9B8: 409A000C  bne cr6, 0x82ebf9c4
	if !ctx.cr[6].eq {
	pc = 0x82EBF9C4; continue 'dispatch;
	}
	// 82EBF9BC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EBF9C0: 4800041C  b 0x82ebfddc
	pc = 0x82EBFDDC; continue 'dispatch;
	// 82EBF9C4: 4B3A0FF5  bl 0x822609b8
	ctx.lr = 0x82EBF9C8;
	sub_822609B8(ctx, base);
	// 82EBF9C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF9CC: C01F0088  lfs f0, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF9D0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EBF9D4: C17F008C  lfs f11, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF9D8: C183004C  lfs f12, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF9DC: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF9E0: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF9E4: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF9E8: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EBF9EC: 4099000C  ble cr6, 0x82ebf9f8
	if !ctx.cr[6].gt {
	pc = 0x82EBF9F8; continue 'dispatch;
	}
	// 82EBF9F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBF9F4: 48000024  b 0x82ebfa18
	pc = 0x82EBFA18; continue 'dispatch;
	// 82EBF9F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBF9FC: 40990018  ble cr6, 0x82ebfa14
	if !ctx.cr[6].gt {
	pc = 0x82EBFA14; continue 'dispatch;
	}
	// 82EBFA00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFA04: 896B0410  lbz r11, 0x410(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EBFA08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFA0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFA10: 40820008  bne 0x82ebfa18
	if !ctx.cr[0].eq {
	pc = 0x82EBFA18; continue 'dispatch;
	}
	// 82EBFA14: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFA18: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFA1C: 4082008C  bne 0x82ebfaa8
	if !ctx.cr[0].eq {
	pc = 0x82EBFAA8; continue 'dispatch;
	}
	// 82EBFA20: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA24: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA28: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFA2C: 409A0028  bne cr6, 0x82ebfa54
	if !ctx.cr[6].eq {
	pc = 0x82EBFA54; continue 'dispatch;
	}
	// 82EBFA30: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA34: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA3C: 409A0018  bne cr6, 0x82ebfa54
	if !ctx.cr[6].eq {
	pc = 0x82EBFA54; continue 'dispatch;
	}
	// 82EBFA40: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFA48: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA50: 419A0008  beq cr6, 0x82ebfa58
	if ctx.cr[6].eq {
	pc = 0x82EBFA58; continue 'dispatch;
	}
	// 82EBFA54: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFA58: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFA5C: 4182FF60  beq 0x82ebf9bc
	if ctx.cr[0].eq {
	pc = 0x82EBF9BC; continue 'dispatch;
	}
	// 82EBFA60: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA64: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA68: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFA6C: 409A0028  bne cr6, 0x82ebfa94
	if !ctx.cr[6].eq {
	pc = 0x82EBFA94; continue 'dispatch;
	}
	// 82EBFA70: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA74: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA78: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA7C: 409A0018  bne cr6, 0x82ebfa94
	if !ctx.cr[6].eq {
	pc = 0x82EBFA94; continue 'dispatch;
	}
	// 82EBFA80: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFA88: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA8C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA90: 419A0008  beq cr6, 0x82ebfa98
	if ctx.cr[6].eq {
	pc = 0x82EBFA98; continue 'dispatch;
	}
	// 82EBFA94: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFA98: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFA9C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82EBFAA0: 4082033C  bne 0x82ebfddc
	if !ctx.cr[0].eq {
	pc = 0x82EBFDDC; continue 'dispatch;
	}
	// 82EBFAA4: 4BFFFF18  b 0x82ebf9bc
	pc = 0x82EBF9BC; continue 'dispatch;
	// 82EBFAA8: D19F008C  stfs f12, 0x8c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EBFAAC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAB0: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFAB8: 409A0028  bne cr6, 0x82ebfae0
	if !ctx.cr[6].eq {
	pc = 0x82EBFAE0; continue 'dispatch;
	}
	// 82EBFABC: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAC0: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAC4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFAC8: 409A0018  bne cr6, 0x82ebfae0
	if !ctx.cr[6].eq {
	pc = 0x82EBFAE0; continue 'dispatch;
	}
	// 82EBFACC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAD0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFAD4: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAD8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFADC: 419A0008  beq cr6, 0x82ebfae4
	if ctx.cr[6].eq {
	pc = 0x82EBFAE4; continue 'dispatch;
	}
	// 82EBFAE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFAE4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFAE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFAEC: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBFAF0: 40820044  bne 0x82ebfb34
	if !ctx.cr[0].eq {
	pc = 0x82EBFB34; continue 'dispatch;
	}
	// 82EBFAF4: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAF8: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAFC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFB00: 409A0028  bne cr6, 0x82ebfb28
	if !ctx.cr[6].eq {
	pc = 0x82EBFB28; continue 'dispatch;
	}
	// 82EBFB04: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB08: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB0C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFB10: 409A0018  bne cr6, 0x82ebfb28
	if !ctx.cr[6].eq {
	pc = 0x82EBFB28; continue 'dispatch;
	}
	// 82EBFB14: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB18: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFB1C: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB20: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFB24: 419A0008  beq cr6, 0x82ebfb2c
	if ctx.cr[6].eq {
	pc = 0x82EBFB2C; continue 'dispatch;
	}
	// 82EBFB28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFB2C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFB30: 41820044  beq 0x82ebfb74
	if ctx.cr[0].eq {
	pc = 0x82EBFB74; continue 'dispatch;
	}
	// 82EBFB34: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB38: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EBFB3C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBFB40: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82EBFB44: C0180008  lfs f0, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB48: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EBFB4C: C018000C  lfs f0, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB50: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBFB54: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB58: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBFB5C: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB60: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBFB64: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB68: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBFB6C: D3DF0084  stfs f30, 0x84(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EBFB70: 4BFB0389  bl 0x82e6fef8
	ctx.lr = 0x82EBFB74;
	sub_82E6FEF8(ctx, base);
	// 82EBFB74: C1BE0004  lfs f13, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB78: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB7C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBFB80: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFB84: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB88: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBFB8C: C17E000C  lfs f11, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFB90: C19D000C  lfs f12, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFB94: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBFB98: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBFB9C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBFBA0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBFBA4: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBFBA8: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 82EBFBAC: 409A001C  bne cr6, 0x82ebfbc8
	if !ctx.cr[6].eq {
	pc = 0x82EBFBC8; continue 'dispatch;
	}
	// 82EBFBB0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EBFBB4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82EBFBB8: 4BFB0341  bl 0x82e6fef8
	ctx.lr = 0x82EBFBBC;
	sub_82E6FEF8(ctx, base);
	// 82EBFBBC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EBFBC0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82EBFBC4: 4800021C  b 0x82ebfde0
	pc = 0x82EBFDE0; continue 'dispatch;
	// 82EBFBC8: C19F000C  lfs f12, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFBCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFBD0: C17F0084  lfs f11, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFBD4: EFEC582A  fadds f31, f12, f11
	ctx.f[31].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EBFBD8: C17D0004  lfs f11, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFBDC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFBE0: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBFBE4: C15D0008  lfs f10, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBFBE8: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFBEC: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFBF0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EBFBF4: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBFBF8: C15E000C  lfs f10, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBFBFC: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82EBFC00: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFC04: ED4D5028  fsubs f10, f13, f10
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBFC08: EDA00332  fmuls f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBFC0C: ED8002F2  fmuls f12, f0, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBFC10: ED6002B2  fmuls f11, f0, f10
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBFC14: 419901C4  bgt cr6, 0x82ebfdd8
	if ctx.cr[6].gt {
	pc = 0x82EBFDD8; continue 'dispatch;
	}
	// 82EBFC18: EC0D07F2  fmuls f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFC1C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFC20: EDAC07F2  fmuls f13, f12, f31
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFC24: C15E0008  lfs f10, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBFC28: ED8B07F2  fmuls f12, f11, f31
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFC2C: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFC30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFC34: EFAB002A  fadds f29, f11, f0
	ctx.f[29].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBFC38: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC3C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBFC40: EF8A682A  fadds f28, f10, f13
	ctx.f[28].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBFC44: EF60602A  fadds f27, f0, f12
	ctx.f[27].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBFC48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFC4C: 4E800421  bctrl
	ctx.lr = 0x82EBFC50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFC50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFC54: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EBFC58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBFC5C: 3B8A9128  addi r28, r10, -0x6ed8
	ctx.r[28].s64 = ctx.r[10].s64 + -28376;
	// 82EBFC60: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82EBFC64: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFC68: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EBFC6C: 83AB0250  lwz r29, 0x250(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBFC70: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EBFC74: 83C70014  lwz r30, 0x14(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBFC78: D3C10054  stfs f30, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBFC7C: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBFC80: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EBFC84: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBFC88: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC8C: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EBFC90: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC94: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EBFC98: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC9C: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EBFCA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EBFCA4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EBFCA8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EBFCAC: 4200FFF8  bdnz 0x82ebfca4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBFCA4; continue 'dispatch;
	}
	// 82EBFCB0: 9B210118  stb r25, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[25].u8 ) };
	// 82EBFCB4: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EBFCB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFCBC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EBFCC0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EBFCC4: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EBFCC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFCCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBFCD0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBFCD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFCD8: 4E800421  bctrl
	ctx.lr = 0x82EBFCDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFCDC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFCE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBFCE4: 3B4B9128  addi r26, r11, -0x6ed8
	ctx.r[26].s64 = ctx.r[11].s64 + -28376;
	// 82EBFCE8: 418200EC  beq 0x82ebfdd4
	if ctx.cr[0].eq {
	pc = 0x82EBFDD4; continue 'dispatch;
	}
	// 82EBFCEC: D3A10064  stfs f29, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EBFCF0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82EBFCF4: D3810068  stfs f28, 0x68(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EBFCF8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EBFCFC: D361006C  stfs f27, 0x6c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EBFD00: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82EBFD04: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EBFD08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EBFD0C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EBFD10: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EBFD14: 4200FFF8  bdnz 0x82ebfd0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBFD0C; continue 'dispatch;
	}
	// 82EBFD18: 9B2100B8  stb r25, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[25].u8 ) };
	// 82EBFD1C: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82EBFD20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFD24: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EBFD28: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EBFD2C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EBFD30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFD34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBFD38: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBFD3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFD40: 4E800421  bctrl
	ctx.lr = 0x82EBFD44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFD44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFD48: 41820088  beq 0x82ebfdd0
	if ctx.cr[0].eq {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFD4C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFD50: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82EBFD54: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EBFD58: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EBFD5C: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EBFD60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFD64: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBFD68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBFD6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFD70: 4E800421  bctrl
	ctx.lr = 0x82EBFD74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFD74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFD78: 41820058  beq 0x82ebfdd0
	if ctx.cr[0].eq {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFD7C: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFD80: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFD84: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBFD88: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFD8C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFD90: 41990040  bgt cr6, 0x82ebfdd0
	if ctx.cr[6].gt {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFD94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFD98: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EBFD9C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EBFDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFDA4: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EBFDA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFDAC: 4E800421  bctrl
	ctx.lr = 0x82EBFDB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFDB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFDB4: 4182001C  beq 0x82ebfdd0
	if ctx.cr[0].eq {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFDB8: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 82EBFDBC: D3AB0004  stfs f29, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EBFDC0: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBFDC4: D36B000C  stfs f27, 0xc(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBFDC8: 9B2B0058  stb r25, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[25].u8 ) };
	// 82EBFDCC: D3FF0084  stfs f31, 0x84(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EBFDD0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82EBFDD4: 934100C0  stw r26, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u32 ) };
	// 82EBFDD8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82EBFDDC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82EBFDE0: 4BFB0119  bl 0x82e6fef8
	ctx.lr = 0x82EBFDE4;
	sub_82E6FEF8(ctx, base);
	// 82EBFDE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBFDE8: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82EBFDEC: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82EBFDF0: 4BDEDF31  bl 0x82cadd20
	ctx.lr = 0x82EBFDF4;
	sub_82CADCEC(ctx, base);
	// 82EBFDF4: 4BDE9650  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBFDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBFDF8 size=88
    let mut pc: u32 = 0x82EBFDF8;
    'dispatch: loop {
        match pc {
            0x82EBFDF8 => {
    //   block [0x82EBFDF8..0x82EBFE50)
	// 82EBFDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBFDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBFE00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBFE04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBFE08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBFE0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBFE10: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EBFE14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBFE18: 4B756B11  bl 0x82616928
	ctx.lr = 0x82EBFE1C;
	sub_82616928(ctx, base);
	// 82EBFE1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFE20: 41820014  beq 0x82ebfe34
	if ctx.cr[0].eq {
	pc = 0x82EBFE34; continue 'dispatch;
	}
	// 82EBFE24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBFE28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBFE2C: 4BFF570D  bl 0x82eb5538
	ctx.lr = 0x82EBFE30;
	sub_82EB5538(ctx, base);
	// 82EBFE30: 48000008  b 0x82ebfe38
	pc = 0x82EBFE38; continue 'dispatch;
	// 82EBFE34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBFE38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBFE3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBFE40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBFE44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBFE48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBFE4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBFE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBFE50 size=576
    let mut pc: u32 = 0x82EBFE50;
    'dispatch: loop {
        match pc {
            0x82EBFE50 => {
    //   block [0x82EBFE50..0x82EC0090)
	// 82EBFE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBFE54: 4BDE95B9  bl 0x82ca940c
	ctx.lr = 0x82EBFE58;
	sub_82CA93D0(ctx, base);
	// 82EBFE58: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBFE5C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBFE60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBFE64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBFE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFE6C: 482FC1F5  bl 0x831bc060
	ctx.lr = 0x82EBFE70;
	sub_831BC060(ctx, base);
	// 82EBFE70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFE74: 41820084  beq 0x82ebfef8
	if ctx.cr[0].eq {
	pc = 0x82EBFEF8; continue 'dispatch;
	}
	// 82EBFE78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBFE7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFE80: 3BCBAF1C  addi r30, r11, -0x50e4
	ctx.r[30].s64 = ctx.r[11].s64 + -20708;
	// 82EBFE84: 482FC1DD  bl 0x831bc060
	ctx.lr = 0x82EBFE88;
	sub_831BC060(ctx, base);
	// 82EBFE88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFE8C: 4BDECCC5  bl 0x82cacb50
	ctx.lr = 0x82EBFE90;
	sub_82CACB50(ctx, base);
	// 82EBFE90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBFE94: 40820064  bne 0x82ebfef8
	if !ctx.cr[0].eq {
	pc = 0x82EBFEF8; continue 'dispatch;
	}
	// 82EBFE98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBFE9C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBFEA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFEA4: 4182000C  beq 0x82ebfeb0
	if ctx.cr[0].eq {
	pc = 0x82EBFEB0; continue 'dispatch;
	}
	// 82EBFEA8: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBFEAC: 4800000C  b 0x82ebfeb8
	pc = 0x82EBFEB8; continue 'dispatch;
	// 82EBFEB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFEB4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBFEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFEBC: 4BA4DE4D  bl 0x8290dd08
	ctx.lr = 0x82EBFEC0;
	sub_8290DD08(ctx, base);
	// 82EBFEC0: 4BDEBCF1  bl 0x82cabbb0
	ctx.lr = 0x82EBFEC4;
	sub_82CABBB0(ctx, base);
	// 82EBFEC4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBFEC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFECC: C01D0014  lfs f0, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFED0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFED4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFED8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBFEDC: 41980008  blt cr6, 0x82ebfee4
	if ctx.cr[6].lt {
	pc = 0x82EBFEE4; continue 'dispatch;
	}
	// 82EBFEE0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBFEE4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBFEE8: 409AFFF0  bne cr6, 0x82ebfed8
	if !ctx.cr[6].eq {
	pc = 0x82EBFED8; continue 'dispatch;
	}
	// 82EBFEEC: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EBFEF0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBFEF4: 48000190  b 0x82ec0084
	pc = 0x82EC0084; continue 'dispatch;
	// 82EBFEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFEFC: 482FC165  bl 0x831bc060
	ctx.lr = 0x82EBFF00;
	sub_831BC060(ctx, base);
	// 82EBFF00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFF04: 41820080  beq 0x82ebff84
	if ctx.cr[0].eq {
	pc = 0x82EBFF84; continue 'dispatch;
	}
	// 82EBFF08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBFF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFF10: 3BCBAF10  addi r30, r11, -0x50f0
	ctx.r[30].s64 = ctx.r[11].s64 + -20720;
	// 82EBFF14: 482FC14D  bl 0x831bc060
	ctx.lr = 0x82EBFF18;
	sub_831BC060(ctx, base);
	// 82EBFF18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFF1C: 4BDECC35  bl 0x82cacb50
	ctx.lr = 0x82EBFF20;
	sub_82CACB50(ctx, base);
	// 82EBFF20: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBFF24: 40820060  bne 0x82ebff84
	if !ctx.cr[0].eq {
	pc = 0x82EBFF84; continue 'dispatch;
	}
	// 82EBFF28: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBFF2C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBFF30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFF34: 4182000C  beq 0x82ebff40
	if ctx.cr[0].eq {
	pc = 0x82EBFF40; continue 'dispatch;
	}
	// 82EBFF38: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBFF3C: 4800000C  b 0x82ebff48
	pc = 0x82EBFF48; continue 'dispatch;
	// 82EBFF40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFF44: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBFF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFF4C: 4BA4DDBD  bl 0x8290dd08
	ctx.lr = 0x82EBFF50;
	sub_8290DD08(ctx, base);
	// 82EBFF50: 4BDEBC61  bl 0x82cabbb0
	ctx.lr = 0x82EBFF54;
	sub_82CABBB0(ctx, base);
	// 82EBFF54: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBFF58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFF5C: C01D001C  lfs f0, 0x1c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFF60: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFF64: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFF68: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBFF6C: 41980008  blt cr6, 0x82ebff74
	if ctx.cr[6].lt {
	pc = 0x82EBFF74; continue 'dispatch;
	}
	// 82EBFF70: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBFF74: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBFF78: 409AFFF0  bne cr6, 0x82ebff68
	if !ctx.cr[6].eq {
	pc = 0x82EBFF68; continue 'dispatch;
	}
	// 82EBFF7C: D01D001C  stfs f0, 0x1c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBFF80: 4BFFFF70  b 0x82ebfef0
	pc = 0x82EBFEF0; continue 'dispatch;
	// 82EBFF84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFF88: 482FC0D9  bl 0x831bc060
	ctx.lr = 0x82EBFF8C;
	sub_831BC060(ctx, base);
	// 82EBFF8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFF90: 4182005C  beq 0x82ebffec
	if ctx.cr[0].eq {
	pc = 0x82EBFFEC; continue 'dispatch;
	}
	// 82EBFF94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBFF98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFF9C: 3BCBAEFC  addi r30, r11, -0x5104
	ctx.r[30].s64 = ctx.r[11].s64 + -20740;
	// 82EBFFA0: 482FC0C1  bl 0x831bc060
	ctx.lr = 0x82EBFFA4;
	sub_831BC060(ctx, base);
	// 82EBFFA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFFA8: 4BDECBA9  bl 0x82cacb50
	ctx.lr = 0x82EBFFAC;
	sub_82CACB50(ctx, base);
	// 82EBFFAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBFFB0: 4082003C  bne 0x82ebffec
	if !ctx.cr[0].eq {
	pc = 0x82EBFFEC; continue 'dispatch;
	}
	// 82EBFFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFFB8: 4BA4DD51  bl 0x8290dd08
	ctx.lr = 0x82EBFFBC;
	sub_8290DD08(ctx, base);
	// 82EBFFBC: 4BDEBBF5  bl 0x82cabbb0
	ctx.lr = 0x82EBFFC0;
	sub_82CABBB0(ctx, base);
	// 82EBFFC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFFC4: C01D0020  lfs f0, 0x20(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFFC8: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBFFCC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFFD0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBFFD4: 41980008  blt cr6, 0x82ebffdc
	if ctx.cr[6].lt {
	pc = 0x82EBFFDC; continue 'dispatch;
	}
	// 82EBFFD8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBFFDC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBFFE0: 409AFFF0  bne cr6, 0x82ebffd0
	if !ctx.cr[6].eq {
	pc = 0x82EBFFD0; continue 'dispatch;
	}
	// 82EBFFE4: D01D0020  stfs f0, 0x20(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBFFE8: 4BFFFF08  b 0x82ebfef0
	pc = 0x82EBFEF0; continue 'dispatch;
	// 82EBFFEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFFF0: 482FC071  bl 0x831bc060
	ctx.lr = 0x82EBFFF4;
	sub_831BC060(ctx, base);
	// 82EBFFF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFFF8: 41820080  beq 0x82ec0078
	if ctx.cr[0].eq {
	pc = 0x82EC0078; continue 'dispatch;
	}
	// 82EBFFFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0004: 3BCBAEEC  addi r30, r11, -0x5114
	ctx.r[30].s64 = ctx.r[11].s64 + -20756;
	// 82EC0008: 482FC059  bl 0x831bc060
	ctx.lr = 0x82EC000C;
	sub_831BC060(ctx, base);
	// 82EC000C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0010: 4BDECB41  bl 0x82cacb50
	ctx.lr = 0x82EC0014;
	sub_82CACB50(ctx, base);
	// 82EC0014: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC0018: 40820060  bne 0x82ec0078
	if !ctx.cr[0].eq {
	pc = 0x82EC0078; continue 'dispatch;
	}
	// 82EC001C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0020: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0024: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0028: 4182000C  beq 0x82ec0034
	if ctx.cr[0].eq {
	pc = 0x82EC0034; continue 'dispatch;
	}
	// 82EC002C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC0030: 4800000C  b 0x82ec003c
	pc = 0x82EC003C; continue 'dispatch;
	// 82EC0034: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0038: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC003C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0040: 4BA4DCC9  bl 0x8290dd08
	ctx.lr = 0x82EC0044;
	sub_8290DD08(ctx, base);
	// 82EC0044: 4BDEBB6D  bl 0x82cabbb0
	ctx.lr = 0x82EC0048;
	sub_82CABBB0(ctx, base);
	// 82EC0048: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC004C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0050: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0054: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0058: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC005C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC0060: 41980008  blt cr6, 0x82ec0068
	if ctx.cr[6].lt {
	pc = 0x82EC0068; continue 'dispatch;
	}
	// 82EC0064: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC0068: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC006C: 409AFFF0  bne cr6, 0x82ec005c
	if !ctx.cr[6].eq {
	pc = 0x82EC005C; continue 'dispatch;
	}
	// 82EC0070: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC0074: 4BFFFE7C  b 0x82ebfef0
	pc = 0x82EBFEF0; continue 'dispatch;
	// 82EC0078: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC007C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC0080: 4BFF53A1  bl 0x82eb5420
	ctx.lr = 0x82EC0084;
	sub_82EB5420(ctx, base);
	// 82EC0084: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC0088: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC008C: 4BDE93D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0090 size=216
    let mut pc: u32 = 0x82EC0090;
    'dispatch: loop {
        match pc {
            0x82EC0090 => {
    //   block [0x82EC0090..0x82EC0168)
	// 82EC0090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0098: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC009C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC00A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC00A4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC00A8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC00AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC00B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC00B4: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC00B8: C1890C14  lfs f12, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC00BC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC00C0: 4182000C  beq 0x82ec00cc
	if ctx.cr[0].eq {
	pc = 0x82EC00CC; continue 'dispatch;
	}
	// 82EC00C4: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC00C8: 48000008  b 0x82ec00d0
	pc = 0x82EC00D0; continue 'dispatch;
	// 82EC00CC: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 82EC00D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC00D4: C1AA0A54  lfs f13, 0xa54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC00D8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC00DC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC00E0: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC00E4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC00E8: 4182000C  beq 0x82ec00f4
	if ctx.cr[0].eq {
	pc = 0x82EC00F4; continue 'dispatch;
	}
	// 82EC00EC: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC00F0: 48000008  b 0x82ec00f8
	pc = 0x82EC00F8; continue 'dispatch;
	// 82EC00F4: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 82EC00F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC00FC: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC0100: C00A0A7C  lfs f0, 0xa7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0104: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0108: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC010C: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0110: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0114: 41820008  beq 0x82ec011c
	if ctx.cr[0].eq {
	pc = 0x82EC011C; continue 'dispatch;
	}
	// 82EC0118: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC011C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC0120: 388A1BA0  addi r4, r10, 0x1ba0
	ctx.r[4].s64 = ctx.r[10].s64 + 7072;
	// 82EC0124: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC0128: C00A0A9C  lfs f0, 0xa9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2716 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC012C: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0130: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC0134: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0138: 4B3A7AE9  bl 0x82267c20
	ctx.lr = 0x82EC013C;
	sub_82267C20(ctx, base);
	// 82EC013C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC0140: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0148: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC014C: 48003F2D  bl 0x82ec4078
	ctx.lr = 0x82EC0150;
	sub_82EC4078(ctx, base);
	// 82EC0150: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC015C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC0160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC0164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC0168 size=76
    let mut pc: u32 = 0x82EC0168;
    'dispatch: loop {
        match pc {
            0x82EC0168 => {
    //   block [0x82EC0168..0x82EC01B4)
	// 82EC0168: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC016C: C1A40004  lfs f13, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0170: C00B02DC  lfs f0, 0x2dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0174: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC0178: 409A0028  bne cr6, 0x82ec01a0
	if !ctx.cr[6].eq {
	pc = 0x82EC01A0; continue 'dispatch;
	}
	// 82EC017C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0180: C1AB02E0  lfs f13, 0x2e0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(736 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0184: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC0188: 409A0018  bne cr6, 0x82ec01a0
	if !ctx.cr[6].eq {
	pc = 0x82EC01A0; continue 'dispatch;
	}
	// 82EC018C: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0190: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC0194: C1AB02E4  lfs f13, 0x2e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(740 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0198: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC019C: 419A0008  beq cr6, 0x82ec01a4
	if ctx.cr[6].eq {
	pc = 0x82EC01A4; continue 'dispatch;
	}
	// 82EC01A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC01A4: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC01A8: 4182000C  beq 0x82ec01b4
	if ctx.cr[0].eq {
		sub_82EC01B4(ctx, base);
		return;
	}
	// 82EC01AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC01B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC01B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC01B4 size=76
    let mut pc: u32 = 0x82EC01B4;
    'dispatch: loop {
        match pc {
            0x82EC01B4 => {
    //   block [0x82EC01B4..0x82EC0200)
	// 82EC01B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC01B8: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC01BC: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC01C0: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC01C4: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC01C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC01CC: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC01D0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC01D4: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC01D8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC01DC: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC01E0: EDA96028  fsubs f13, f9, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC01E4: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC01E8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC01EC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC01F0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC01F4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC01F8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC01FC: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0200 size=8
    let mut pc: u32 = 0x82EC0200;
    'dispatch: loop {
        match pc {
            0x82EC0200 => {
    //   block [0x82EC0200..0x82EC0208)
	// 82EC0200: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0208 size=1088
    let mut pc: u32 = 0x82EC0208;
    'dispatch: loop {
        match pc {
            0x82EC0208 => {
    //   block [0x82EC0208..0x82EC0648)
	// 82EC0208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC020C: 4BDE91F5  bl 0x82ca9400
	ctx.lr = 0x82EC0210;
	sub_82CA93D0(ctx, base);
	// 82EC0210: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EC0214: 4BDEDAB5  bl 0x82cadcc8
	ctx.lr = 0x82EC0218;
	sub_82CADCA0(ctx, base);
	// 82EC0218: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC021C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC0220: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0224: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC0228: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82EC022C: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EC0230: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC0234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0238: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EC023C: 4B32843D  bl 0x821e8678
	ctx.lr = 0x82EC0240;
	sub_821E8678(ctx, base);
	// 82EC0240: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC0244: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0248: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC024C: 3F608334  lis r27, -0x7ccc
	ctx.r[27].s64 = -2093744128;
	// 82EC0250: C3AA0C14  lfs f29, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EC0254: C3CB0BFC  lfs f30, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC0258: 41820010  beq 0x82ec0268
	if ctx.cr[0].eq {
	pc = 0x82EC0268; continue 'dispatch;
	}
	// 82EC025C: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0260: EFE007B2  fmuls f31, f0, f30
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC0264: 4800001C  b 0x82ec0280
	pc = 0x82EC0280; continue 'dispatch;
	// 82EC0268: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC026C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0270: 4182000C  beq 0x82ec027c
	if ctx.cr[0].eq {
	pc = 0x82EC027C; continue 'dispatch;
	}
	// 82EC0274: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC0278: 48000008  b 0x82ec0280
	pc = 0x82EC0280; continue 'dispatch;
	// 82EC027C: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 82EC0280: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0284: 807C0024  lwz r3, 0x24(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0288: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EC028C: C1BC0020  lfs f13, 0x20(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0290: C19F003C  lfs f12, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0294: C15C0030  lfs f10, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC0298: C13C002C  lfs f9, 0x2c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC029C: C0E30034  lfs f7, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC02A0: C11C0028  lfs f8, 0x28(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC02A4: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC02A8: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC02AC: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC02B0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC02B4: C1A3003C  lfs f13, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC02B8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC02BC: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC02C0: ED8C3828  fsubs f12, f12, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EC02C4: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC02C8: EC09683A  fmadds f0, f9, f0, f13
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC02CC: EC08033A  fmadds f0, f8, f12, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC02D0: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EC02D4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC02D8: 4199035C  bgt cr6, 0x82ec0634
	if ctx.cr[6].gt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC02DC: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC02E0: 419A0354  beq cr6, 0x82ec0634
	if ctx.cr[6].eq {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC02E4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC02E8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC02EC: 419A0348  beq cr6, 0x82ec0634
	if ctx.cr[6].eq {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC02F0: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC02F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC02F8: 41820018  beq 0x82ec0310
	if ctx.cr[0].eq {
	pc = 0x82EC0310; continue 'dispatch;
	}
	// 82EC02FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0300: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0304: 4E800421  bctrl
	ctx.lr = 0x82EC0308;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0308: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC030C: 41820328  beq 0x82ec0634
	if ctx.cr[0].eq {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC0310: C01F0038  lfs f0, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0314: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0318: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC031C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC0320: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC0324: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC0328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC032C: C35F0034  lfs f26, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EC0330: C33F003C  lfs f25, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EC0334: EF00F828  fsubs f24, f0, f31
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EC0338: 4B328341  bl 0x821e8678
	ctx.lr = 0x82EC033C;
	sub_821E8678(ctx, base);
	// 82EC033C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0340: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC0344: 388BDA4C  addi r4, r11, -0x25b4
	ctx.r[4].s64 = ctx.r[11].s64 + -9652;
	// 82EC0348: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC034C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0350: 4B328329  bl 0x821e8678
	ctx.lr = 0x82EC0354;
	sub_821E8678(ctx, base);
	// 82EC0354: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EC0358: 419A000C  beq cr6, 0x82ec0364
	if ctx.cr[6].eq {
	pc = 0x82EC0364; continue 'dispatch;
	}
	// 82EC035C: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0360: 4800001C  b 0x82ec037c
	pc = 0x82EC037C; continue 'dispatch;
	// 82EC0364: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0368: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC036C: 4182000C  beq 0x82ec0378
	if ctx.cr[0].eq {
	pc = 0x82EC0378; continue 'dispatch;
	}
	// 82EC0370: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0374: 48000008  b 0x82ec037c
	pc = 0x82EC037C; continue 'dispatch;
	// 82EC0378: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82EC037C: C1BC001C  lfs f13, 0x1c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0380: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC0384: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC038C: 419A0204  beq cr6, 0x82ec0590
	if ctx.cr[6].eq {
	pc = 0x82EC0590; continue 'dispatch;
	}
	// 82EC0390: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC0394: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0398: ED6B67BA  fmadds f11, f11, f30, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[30].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EC039C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC03A0: ED8C682A  fadds f12, f12, f13
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC03A4: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EC03A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC03AC: EFEB682A  fadds f31, f11, f13
	ctx.f[31].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC03B0: EFCC002A  fadds f30, f12, f0
	ctx.f[30].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC03B4: 4B3282C5  bl 0x821e8678
	ctx.lr = 0x82EC03B8;
	sub_821E8678(ctx, base);
	// 82EC03B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC03BC: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 82EC03C0: 40820008  bne 0x82ec03c8
	if !ctx.cr[0].eq {
	pc = 0x82EC03C8; continue 'dispatch;
	}
	// 82EC03C4: 395F004C  addi r10, r31, 0x4c
	ctx.r[10].s64 = ctx.r[31].s64 + 76;
	// 82EC03C8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC03CC: C38A0004  lfs f28, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EC03D0: C36A0008  lfs f27, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EC03D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC03D8: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EC03DC: C3AA0000  lfs f29, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EC03E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC03E4: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC03E8: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC03EC: ED7C0372  fmuls f11, f28, f13
	ctx.f[11].f64 = (((ctx.f[28].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC03F0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC03F4: ED5B0332  fmuls f10, f27, f12
	ctx.f[10].f64 = (((ctx.f[27].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC03F8: ED3D0032  fmuls f9, f29, f0
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC03FC: EC1B5838  fmsubs f0, f27, f0, f11
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC0400: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC0404: EC1D5378  fmsubs f0, f29, f13, f10
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC0408: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC040C: EC1C4B38  fmsubs f0, f28, f12, f9
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC0410: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC0414: 4B3BEE55  bl 0x8227f268
	ctx.lr = 0x82EC0418;
	sub_8227F268(ctx, base);
	// 82EC0418: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC041C: C1BF0038  lfs f13, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0420: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0424: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0428: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC042C: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0430: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0434: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0438: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC043C: ED4D6028  fsubs f10, f13, f12
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0440: EDA00732  fmuls f13, f0, f28
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC0444: EDAB6EFA  fmadds f13, f11, f27, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC0448: EDAA6F7A  fmadds f13, f10, f29, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC044C: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82EC0450: 419901E4  bgt cr6, 0x82ec0634
	if ctx.cr[6].gt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC0454: FD80F850  fneg f12, f31
	ctx.f[12].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC0458: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC045C: 419801D8  blt cr6, 0x82ec0634
	if ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC0460: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0464: ED2D0032  fmuls f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0468: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC046C: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0470: ED6C4AFA  fmadds f11, f12, f11, f9
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EC0474: ED605ABA  fmadds f11, f0, f10, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EC0478: FF0BF000  fcmpu cr6, f11, f30
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[30].f64);
	// 82EC047C: 419901B8  bgt cr6, 0x82ec0634
	if ctx.cr[6].gt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC0480: FD40F050  fneg f10, f30
	ctx.f[10].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC0484: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 82EC0488: 419801AC  blt cr6, 0x82ec0634
	if ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC048C: ED7D07F2  fmuls f11, f29, f31
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC0490: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EC0494: ED5C07F2  fmuls f10, f28, f31
	ctx.f[10].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC0498: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82EC049C: ED3B07F2  fmuls f9, f27, f31
	ctx.f[9].f64 = (((ctx.f[27].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC04A0: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC04A4: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC04A8: ED8C07B2  fmuls f12, f12, f30
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC04AC: ED0BD02A  fadds f8, f11, f26
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EC04B0: ECEAC02A  fadds f7, f10, f24
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[24].f64) as f32) as f64;
	// 82EC04B4: ECC9C82A  fadds f6, f9, f25
	ctx.f[6].f64 = ((ctx.f[9].f64 + ctx.f[25].f64) as f32) as f64;
	// 82EC04B8: ED7A5828  fsubs f11, f26, f11
	ctx.f[11].f64 = (((ctx.f[26].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC04BC: ED585028  fsubs f10, f24, f10
	ctx.f[10].f64 = (((ctx.f[24].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC04C0: ED394828  fsubs f9, f25, f9
	ctx.f[9].f64 = (((ctx.f[25].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC04C4: ECA8002A  fadds f5, f8, f0
	ctx.f[5].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC04C8: D0A10070  stfs f5, 0x70(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC04CC: ED080028  fsubs f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC04D0: D101007C  stfs f8, 0x7c(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EC04D4: ED076828  fsubs f8, f7, f13
	ctx.f[8].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC04D8: D1010080  stfs f8, 0x80(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EC04DC: ED066028  fsubs f8, f6, f12
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC04E0: D1010084  stfs f8, 0x84(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EC04E4: ED0B0028  fsubs f8, f11, f0
	ctx.f[8].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC04E8: D1010088  stfs f8, 0x88(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EC04EC: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC04F0: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EC04F4: ECA7682A  fadds f5, f7, f13
	ctx.f[5].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC04F8: D0A10074  stfs f5, 0x74(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EC04FC: ED0A6828  fsubs f8, f10, f13
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0500: D101008C  stfs f8, 0x8c(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EC0504: EC0A682A  fadds f0, f10, f13
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC0508: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EC050C: ECA6602A  fadds f5, f6, f12
	ctx.f[5].f64 = ((ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC0510: D0A10078  stfs f5, 0x78(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EC0514: ED096028  fsubs f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0518: D1010090  stfs f8, 0x90(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EC051C: EC09602A  fadds f0, f9, f12
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC0520: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EC0524: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0528: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EC052C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82EC0530: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0534: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 82EC0538: 57EB07BE  clrlwi r11, r31, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000003u64;
	// 82EC053C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EC0540: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EC0544: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0548: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC054C: 4B3C8BCD  bl 0x82289118
	ctx.lr = 0x82EC0550;
	sub_82289118(ctx, base);
	// 82EC0550: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC0554: 40820034  bne 0x82ec0588
	if !ctx.cr[0].eq {
	pc = 0x82EC0588; continue 'dispatch;
	}
	// 82EC0558: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82EC055C: 2B1F0004  cmplwi cr6, r31, 4
	ctx.cr[6].compare_u32(ctx.r[31].u32, 4 as u32, &mut ctx.xer);
	// 82EC0560: 4198FFC4  blt cr6, 0x82ec0524
	if ctx.cr[6].lt {
	pc = 0x82EC0524; continue 'dispatch;
	}
	// 82EC0564: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0568: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC056C: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC0570: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0574: D01A0004  stfs f0, 4(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC0578: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC057C: D01A0008  stfs f0, 8(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC0580: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC0584: 480000B4  b 0x82ec0638
	pc = 0x82EC0638; continue 'dispatch;
	// 82EC0588: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC058C: 480000AC  b 0x82ec0638
	pc = 0x82EC0638; continue 'dispatch;
	// 82EC0590: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC0594: C13A0000  lfs f9, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC0598: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC059C: C11A0008  lfs f8, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC05A0: ED88C828  fsubs f12, f8, f25
	ctx.f[12].f64 = (((ctx.f[8].f64 - ctx.f[25].f64) as f32) as f64);
	// 82EC05A4: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC05A8: C0EB0008  lfs f7, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC05AC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC05B0: EDA9D028  fsubs f13, f9, f26
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[26].f64) as f32) as f64);
	// 82EC05B4: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC05B8: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC05BC: ED47533A  fmadds f10, f7, f12, f10
	ctx.f[10].f64 = (((ctx.f[7].f64 * ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC05C0: FF0A5800  fcmpu cr6, f10, f11
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[11].f64);
	// 82EC05C4: 41980070  blt cr6, 0x82ec0634
	if ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC05C8: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82EC05CC: 40980068  bge cr6, 0x82ec0634
	if !ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC05D0: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC05D4: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC05D8: EDAC69F8  fmsubs f13, f12, f7, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC05DC: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EC05E0: 41980054  blt cr6, 0x82ec0634
	if ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC05E4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC05E8: 4098004C  bge cr6, 0x82ec0634
	if !ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC05EC: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC05F0: C1BE0010  lfs f13, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC05F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC05F8: 40980008  bge cr6, 0x82ec0600
	if !ctx.cr[6].lt {
	pc = 0x82EC0600; continue 'dispatch;
	}
	// 82EC05FC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC0600: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0604: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0608: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC060C: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC0610: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0614: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0618: C17A0004  lfs f11, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC061C: EDA96828  fsubs f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0620: D1BA0000  stfs f13, 0(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC0624: EDAB6028  fsubs f13, f11, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0628: D1BA0004  stfs f13, 4(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC062C: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC0630: 4BFFFF4C  b 0x82ec057c
	pc = 0x82EC057C; continue 'dispatch;
	// 82EC0634: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0638: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EC063C: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EC0640: 4BDED6D5  bl 0x82cadd14
	ctx.lr = 0x82EC0644;
	sub_82CADCEC(ctx, base);
	// 82EC0644: 4BDE8E0C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0648 size=512
    let mut pc: u32 = 0x82EC0648;
    'dispatch: loop {
        match pc {
            0x82EC0648 => {
    //   block [0x82EC0648..0x82EC0848)
	// 82EC0648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC064C: 4BDE8DB9  bl 0x82ca9404
	ctx.lr = 0x82EC0650;
	sub_82CA93D0(ctx, base);
	// 82EC0650: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82EC0654: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82EC0658: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC065C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC0660: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0664: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC0668: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82EC066C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC0674: 419A0174  beq cr6, 0x82ec07e8
	if ctx.cr[6].eq {
	pc = 0x82EC07E8; continue 'dispatch;
	}
	// 82EC0678: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC067C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0680: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC0684: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0688: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC068C: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0690: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC0694: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0698: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC069C: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC06A0: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC06A4: C1A30038  lfs f13, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC06A8: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC06AC: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC06B0: C143003C  lfs f10, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC06B4: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC06B8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC06BC: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC06C0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC06C4: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC06C8: EFC0002C  fsqrts f30, f0
	ctx.f[30].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC06CC: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC06D0: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EC06D4: 419A0114  beq cr6, 0x82ec07e8
	if ctx.cr[6].eq {
	pc = 0x82EC07E8; continue 'dispatch;
	}
	// 82EC06D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC06DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC06E0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC06E4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC06E8: EC1FF024  fdivs f0, f31, f30
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[30].f64) as f32) as f64;
	// 82EC06EC: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC06F0: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC06F4: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC06F8: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC06FC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC0700: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC0704: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC0708: 4B327F71  bl 0x821e8678
	ctx.lr = 0x82EC070C;
	sub_821E8678(ctx, base);
	// 82EC070C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0710: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC0714: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EC0718: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC071C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0720: 4B327F59  bl 0x821e8678
	ctx.lr = 0x82EC0724;
	sub_821E8678(ctx, base);
	// 82EC0724: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0728: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EC072C: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0730: 419A000C  beq cr6, 0x82ec073c
	if ctx.cr[6].eq {
	pc = 0x82EC073C; continue 'dispatch;
	}
	// 82EC0734: C1BE0004  lfs f13, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0738: 48000018  b 0x82ec0750
	pc = 0x82EC0750; continue 'dispatch;
	// 82EC073C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0740: 4182000C  beq 0x82ec074c
	if ctx.cr[0].eq {
	pc = 0x82EC074C; continue 'dispatch;
	}
	// 82EC0744: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0748: 48000008  b 0x82ec0750
	pc = 0x82EC0750; continue 'dispatch;
	// 82EC074C: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 82EC0750: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0754: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC0758: 396B0BFC  addi r11, r11, 0xbfc
	ctx.r[11].s64 = ctx.r[11].s64 + 3068;
	// 82EC075C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0760: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0764: 419A0010  beq cr6, 0x82ec0774
	if ctx.cr[6].eq {
	pc = 0x82EC0774; continue 'dispatch;
	}
	// 82EC0768: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC076C: EFEC0032  fmuls f31, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0770: 48000010  b 0x82ec0780
	pc = 0x82EC0780; continue 'dispatch;
	// 82EC0774: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0778: 41820008  beq 0x82ec0780
	if ctx.cr[0].eq {
	pc = 0x82EC0780; continue 'dispatch;
	}
	// 82EC077C: C3EA000C  lfs f31, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC0780: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC0784: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC0788: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC078C: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82EC0790: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC0794: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EC0798: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC079C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC07A0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EC07A4: 41820060  beq 0x82ec0804
	if ctx.cr[0].eq {
	pc = 0x82EC0804; continue 'dispatch;
	}
	// 82EC07A8: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC07AC: C03F0018  lfs f1, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC07B0: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EC07B4: 4BFC74F5  bl 0x82e87ca8
	ctx.lr = 0x82EC07B8;
	sub_82E87CA8(ctx, base);
	// 82EC07B8: 48000028  b 0x82ec07e0
	pc = 0x82EC07E0; continue 'dispatch;
	// 82EC07BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC07C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC07C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC07C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC07CC: 4BFFFA3D  bl 0x82ec0208
	ctx.lr = 0x82EC07D0;
	sub_82EC0208(ctx, base);
	// 82EC07D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC07D4: 40820028  bne 0x82ec07fc
	if !ctx.cr[0].eq {
	pc = 0x82EC07FC; continue 'dispatch;
	}
	// 82EC07D8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC07DC: 4BFC6F95  bl 0x82e87770
	ctx.lr = 0x82EC07E0;
	sub_82E87770(ctx, base);
	// 82EC07E0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC07E4: 4082FFD8  bne 0x82ec07bc
	if !ctx.cr[0].eq {
	pc = 0x82EC07BC; continue 'dispatch;
	}
	// 82EC07E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC07EC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EC07F0: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EC07F4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EC07F8: 4BDE8C5C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82EC07FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC0800: 4BFFFFEC  b 0x82ec07ec
	pc = 0x82EC07EC; continue 'dispatch;
	// 82EC0804: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0808: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC080C: 48000028  b 0x82ec0834
	pc = 0x82EC0834; continue 'dispatch;
	// 82EC0810: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0814: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC0818: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC081C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0820: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC0824: 4BFFF9E5  bl 0x82ec0208
	ctx.lr = 0x82EC0828;
	sub_82EC0208(ctx, base);
	// 82EC0828: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC082C: 40820014  bne 0x82ec0840
	if !ctx.cr[0].eq {
	pc = 0x82EC0840; continue 'dispatch;
	}
	// 82EC0830: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0834: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0838: 4082FFD8  bne 0x82ec0810
	if !ctx.cr[0].eq {
	pc = 0x82EC0810; continue 'dispatch;
	}
	// 82EC083C: 4BFFFFAC  b 0x82ec07e8
	pc = 0x82EC07E8; continue 'dispatch;
	// 82EC0840: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC0844: 4BFFFFA8  b 0x82ec07ec
	pc = 0x82EC07EC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0848 size=736
    let mut pc: u32 = 0x82EC0848;
    'dispatch: loop {
        match pc {
            0x82EC0848 => {
    //   block [0x82EC0848..0x82EC0B28)
	// 82EC0848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC084C: 4BDE8BB9  bl 0x82ca9404
	ctx.lr = 0x82EC0850;
	sub_82CA93D0(ctx, base);
	// 82EC0850: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EC0854: 4BDED481  bl 0x82cadcd4
	ctx.lr = 0x82EC0858;
	sub_82CADCA0(ctx, base);
	// 82EC0858: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC085C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC0860: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0864: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC0868: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC086C: 4BFAF68D  bl 0x82e6fef8
	ctx.lr = 0x82EC0870;
	sub_82E6FEF8(ctx, base);
	// 82EC0870: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0874: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC087C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC0880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0884: 4E800421  bctrl
	ctx.lr = 0x82EC0888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0888: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC088C: 40820288  bne 0x82ec0b14
	if !ctx.cr[0].eq {
	pc = 0x82EC0B14; continue 'dispatch;
	}
	// 82EC0890: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0894: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0898: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC089C: C15F0004  lfs f10, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC08A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC08A4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC08A8: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC08AC: 917E0024  stw r11, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC08B0: ED6D5828  fsubs f11, f13, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC08B4: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC08B8: ED806028  fsubs f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC08BC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC08C0: ED4A0028  fsubs f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC08C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC08C8: C36B0C18  lfs f27, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EC08CC: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC08D0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC08D4: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC08D8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC08DC: 419A0238  beq cr6, 0x82ec0b14
	if ctx.cr[6].eq {
	pc = 0x82EC0B14; continue 'dispatch;
	}
	// 82EC08E0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC08E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC08E8: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC08EC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC08F0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC08F4: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC08F8: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC08FC: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC0900: 814A0718  lwz r10, 0x718(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0904: EFC002F2  fmuls f30, f0, f11
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC0908: EFE002B2  fmuls f31, f0, f10
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC090C: EFA00332  fmuls f29, f0, f12
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC0910: FC00F050  fneg f0, f30
	ctx.f[0].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC0914: ED7F06F2  fmuls f11, f31, f27
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EC0918: EDBD07F2  fmuls f13, f29, f31
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC091C: ED9E0032  fmuls f12, f30, f0
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0920: EC1D5838  fmsubs f0, f29, f0, f11
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC0924: D01E0030  stfs f0, 0x30(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC0928: EDBE6EF8  fmsubs f13, f30, f27, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[27].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC092C: D1BE0028  stfs f13, 0x28(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC0930: ED9F67F8  fmsubs f12, f31, f31, f12
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0934: D19E002C  stfs f12, 0x2c(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC0938: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC093C: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0940: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 82EC0944: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0948: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC094C: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC0950: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC0954: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC0958: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC095C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC0960: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0964: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC0968: ED4D5028  fsubs f10, f13, f10
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC096C: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC0970: ED2C4828  fsubs f9, f12, f9
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC0974: C10B0034  lfs f8, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC0978: EC004028  fsubs f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EC097C: 83EA0014  lwz r31, 0x14(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0980: 2C1F0000  cmpwi r31, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC0984: ED4A0772  fmuls f10, f10, f29
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EC0988: ED4957BA  fmadds f10, f9, f30, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[30].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC098C: EF8057FA  fmadds f28, f0, f31, f10
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC0990: 40810140  ble 0x82ec0ad0
	if !ctx.cr[0].gt {
	pc = 0x82EC0AD0; continue 'dispatch;
	}
	// 82EC0994: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 82EC0998: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC099C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EC09A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC09A4: 4BFFFCA5  bl 0x82ec0648
	ctx.lr = 0x82EC09A8;
	sub_82EC0648(ctx, base);
	// 82EC09A8: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC09AC: 7C661B79  or. r6, r3, r3
	ctx.r[6].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82EC09B0: 41820118  beq 0x82ec0ac8
	if ctx.cr[0].eq {
	pc = 0x82EC0AC8; continue 'dispatch;
	}
	// 82EC09B4: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC09B8: C01BD240  lfs f0, -0x2dc0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC09BC: ED3C0028  fsubs f9, f28, f0
	ctx.f[9].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC09C0: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC09C4: ED4D6028  fsubs f10, f13, f12
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC09C8: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC09CC: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC09D0: ED0C5828  fsubs f8, f12, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC09D4: C0EB0034  lfs f7, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC09D8: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC09DC: ECEB3828  fsubs f7, f11, f7
	ctx.f[7].f64 = (((ctx.f[11].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EC09E0: ED4A0772  fmuls f10, f10, f29
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EC09E4: ED4857BA  fmadds f10, f8, f30, f10
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[30].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC09E8: ED4757FA  fmadds f10, f7, f31, f10
	ctx.f[10].f64 = (((ctx.f[7].f64 * ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC09EC: FF0A4800  fcmpu cr6, f10, f9
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[9].f64);
	// 82EC09F0: 40990064  ble cr6, 0x82ec0a54
	if !ctx.cr[6].gt {
	pc = 0x82EC0A54; continue 'dispatch;
	}
	// 82EC09F4: FF0AD800  fcmpu cr6, f10, f27
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[27].f64);
	// 82EC09F8: 41980040  blt cr6, 0x82ec0a38
	if ctx.cr[6].lt {
	pc = 0x82EC0A38; continue 'dispatch;
	}
	// 82EC09FC: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 82EC0A00: 40990038  ble cr6, 0x82ec0a38
	if !ctx.cr[6].gt {
	pc = 0x82EC0A38; continue 'dispatch;
	}
	// 82EC0A04: EDBF0032  fmuls f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0A08: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC0A0C: ED9D0032  fmuls f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0A10: EC1E0032  fmuls f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0A14: FD404890  fmr f10, f9
	ctx.f[10].f64 = ctx.f[9].f64;
	// 82EC0A18: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0A1C: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0A20: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0A24: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0A28: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC0A2C: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC0A30: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC0A34: 4800001C  b 0x82ec0a50
	pc = 0x82EC0A50; continue 'dispatch;
	// 82EC0A38: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC0A3C: FD40D890  fmr f10, f27
	ctx.f[10].f64 = ctx.f[27].f64;
	// 82EC0A40: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC0A44: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0A48: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC0A4C: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0A50: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC0A54: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC0A58: 397D0010  addi r11, r29, 0x10
	ctx.r[11].s64 = ctx.r[29].s64 + 16;
	// 82EC0A5C: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC0A60: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EC0A64: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC0A68: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC0A6C: FF805090  fmr f28, f10
	ctx.f[28].f64 = ctx.f[10].f64;
	// 82EC0A70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC0A74: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC0A78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC0A7C: 4200FFF8  bdnz 0x82ec0a74
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC0A74; continue 'dispatch;
	}
	// 82EC0A80: 9B9D0058  stb r28, 0x58(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EC0A84: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0A88: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0A8C: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82EC0A90: 409A0020  bne cr6, 0x82ec0ab0
	if !ctx.cr[6].eq {
	pc = 0x82EC0AB0; continue 'dispatch;
	}
	// 82EC0A94: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0A98: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC0A9C: 409A0014  bne cr6, 0x82ec0ab0
	if !ctx.cr[6].eq {
	pc = 0x82EC0AB0; continue 'dispatch;
	}
	// 82EC0AA0: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0AA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC0AA8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EC0AAC: 419A0008  beq cr6, 0x82ec0ab4
	if ctx.cr[6].eq {
	pc = 0x82EC0AB4; continue 'dispatch;
	}
	// 82EC0AB0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC0AB4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC0AB8: 40820018  bne 0x82ec0ad0
	if !ctx.cr[0].eq {
	pc = 0x82EC0AD0; continue 'dispatch;
	}
	// 82EC0ABC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0AC0: 4181FED8  bgt 0x82ec0998
	if ctx.cr[0].gt {
	pc = 0x82EC0998; continue 'dispatch;
	}
	// 82EC0AC4: 4800000C  b 0x82ec0ad0
	pc = 0x82EC0AD0; continue 'dispatch;
	// 82EC0AC8: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0ACC: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC0AD0: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0AD4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC0AD8: 409A0020  bne cr6, 0x82ec0af8
	if !ctx.cr[6].eq {
	pc = 0x82EC0AF8; continue 'dispatch;
	}
	// 82EC0ADC: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0AE0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC0AE4: 409A0014  bne cr6, 0x82ec0af8
	if !ctx.cr[6].eq {
	pc = 0x82EC0AF8; continue 'dispatch;
	}
	// 82EC0AE8: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0AEC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC0AF0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC0AF4: 419A0008  beq cr6, 0x82ec0afc
	if ctx.cr[6].eq {
	pc = 0x82EC0AFC; continue 'dispatch;
	}
	// 82EC0AF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC0AFC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC0B00: 41820014  beq 0x82ec0b14
	if ctx.cr[0].eq {
	pc = 0x82EC0B14; continue 'dispatch;
	}
	// 82EC0B04: D17D0004  stfs f11, 4(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC0B08: D1BD0008  stfs f13, 8(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC0B0C: D19D000C  stfs f12, 0xc(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC0B10: 9B9D0058  stb r28, 0x58(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EC0B14: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC0B18: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC0B1C: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EC0B20: 4BDED201  bl 0x82cadd20
	ctx.lr = 0x82EC0B24;
	sub_82CADCEC(ctx, base);
	// 82EC0B24: 4BDE8930  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0B28 size=12
    let mut pc: u32 = 0x82EC0B28;
    'dispatch: loop {
        match pc {
            0x82EC0B28 => {
    //   block [0x82EC0B28..0x82EC0B34)
	// 82EC0B28: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC0B2C: 386BD358  addi r3, r11, -0x2ca8
	ctx.r[3].s64 = ctx.r[11].s64 + -11432;
	// 82EC0B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0B38 size=84
    let mut pc: u32 = 0x82EC0B38;
    'dispatch: loop {
        match pc {
            0x82EC0B38 => {
    //   block [0x82EC0B38..0x82EC0B8C)
	// 82EC0B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0B3C: 4BDE88D1  bl 0x82ca940c
	ctx.lr = 0x82EC0B40;
	sub_82CA93D0(ctx, base);
	// 82EC0B40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0B44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0B48: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EC0B4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0B50: 4B755DD9  bl 0x82616928
	ctx.lr = 0x82EC0B54;
	sub_82616928(ctx, base);
	// 82EC0B54: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0B58: 41820028  beq 0x82ec0b80
	if ctx.cr[0].eq {
	pc = 0x82EC0B80; continue 'dispatch;
	}
	// 82EC0B5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0B60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0B68: 4BFF47C9  bl 0x82eb5330
	ctx.lr = 0x82EC0B6C;
	sub_82EB5330(ctx, base);
	// 82EC0B6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0B74: 396BAF44  addi r11, r11, -0x50bc
	ctx.r[11].s64 = ctx.r[11].s64 + -20668;
	// 82EC0B78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0B7C: 48000008  b 0x82ec0b84
	pc = 0x82EC0B84; continue 'dispatch;
	// 82EC0B80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0B84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0B88: 4BDE88D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0B90 size=40
    let mut pc: u32 = 0x82EC0B90;
    'dispatch: loop {
        match pc {
            0x82EC0B90 => {
    //   block [0x82EC0B90..0x82EC0BB8)
	// 82EC0B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0B98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0B9C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82EC0BA0: 4BFAF359  bl 0x82e6fef8
	ctx.lr = 0x82EC0BA4;
	sub_82E6FEF8(ctx, base);
	// 82EC0BA4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC0BA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC0BAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0BB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC0BB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0BB8 size=12
    let mut pc: u32 = 0x82EC0BB8;
    'dispatch: loop {
        match pc {
            0x82EC0BB8 => {
    //   block [0x82EC0BB8..0x82EC0BC4)
	// 82EC0BB8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC0BBC: 386BD47C  addi r3, r11, -0x2b84
	ctx.r[3].s64 = ctx.r[11].s64 + -11140;
	// 82EC0BC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0BC8 size=84
    let mut pc: u32 = 0x82EC0BC8;
    'dispatch: loop {
        match pc {
            0x82EC0BC8 => {
    //   block [0x82EC0BC8..0x82EC0C1C)
	// 82EC0BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0BCC: 4BDE8841  bl 0x82ca940c
	ctx.lr = 0x82EC0BD0;
	sub_82CA93D0(ctx, base);
	// 82EC0BD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0BD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0BD8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EC0BDC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0BE0: 4B755D49  bl 0x82616928
	ctx.lr = 0x82EC0BE4;
	sub_82616928(ctx, base);
	// 82EC0BE4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0BE8: 41820028  beq 0x82ec0c10
	if ctx.cr[0].eq {
	pc = 0x82EC0C10; continue 'dispatch;
	}
	// 82EC0BEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0BF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0BF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0BF8: 4BFF4739  bl 0x82eb5330
	ctx.lr = 0x82EC0BFC;
	sub_82EB5330(ctx, base);
	// 82EC0BFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0C04: 396BAF7C  addi r11, r11, -0x5084
	ctx.r[11].s64 = ctx.r[11].s64 + -20612;
	// 82EC0C08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0C0C: 48000008  b 0x82ec0c14
	pc = 0x82EC0C14; continue 'dispatch;
	// 82EC0C10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0C14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0C18: 4BDE8844  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0C20 size=120
    let mut pc: u32 = 0x82EC0C20;
    'dispatch: loop {
        match pc {
            0x82EC0C20 => {
    //   block [0x82EC0C20..0x82EC0C98)
	// 82EC0C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0C28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0C2C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC0C30: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC0C34: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EC0C38: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0C3C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC0C40: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82EC0C44: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0C48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC0C4C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0C50: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0C54: 409A000C  bne cr6, 0x82ec0c60
	if !ctx.cr[6].eq {
	pc = 0x82EC0C60; continue 'dispatch;
	}
	// 82EC0C58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0C5C: 48000020  b 0x82ec0c7c
	pc = 0x82EC0C7C; continue 'dispatch;
	// 82EC0C60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC0C64: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0C68: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EC0C6C: C00A0C4C  lfs f0, 0xc4c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0C70: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0C74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0C78: 4E800421  bctrl
	ctx.lr = 0x82EC0C7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0C7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC0C80: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC0C84: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC0C88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC0C8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0C90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC0C94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


